# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EdgeGUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 24716a188674d4449a2ec3ca3f5fc46c
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEditor.Graphs;
using UnityEngine;
using Graphs = UnityEditor.Graphs;

namespace EventVisualizer.Base
{
	// Specialized edge drawer class
	public class EdgeGUI : IEdgeGUI
	{
		public const float EDGE_WIDTH = 6;
		private const float K_EDGE_BOTTOM_MARGIN = 4;
		private const float K_NODE_TITLE_SPACE = 36;
		private const float K_NODE_EDGE_SEPARATION = 12;
		
		private Edge moveEdge;
		private Slot dragSourceSlot;
		private Slot dropTarget;

		public GraphGUI host { get; set; }
		public List<int> edgeSelection { get; set; }

		public EdgeGUI()
		{
			edgeSelection = new List<int>();
		}

		#region IEdgeGUI implementation

		public void DoEdges()
		{
			// Draw edges on repaint.
			if (Event.current.type == EventType.Repaint)
			{
				foreach (Edge edge in host.graph.edges)
				{
					if (edge == moveEdge) continue;

					Vector2Int indexes = FindSlotIndexes(edge);
					DrawEdge(edge, indexes, ColorForIndex(edge.fromSlotName));
				}
			}
		}
		
		private Vector2Int FindSlotIndexes(Edge edge)
		{
			Vector2Int indexes = Vector2Int.zero;

			int totalOutputs = 0;
			bool found = false;
			foreach(Slot slot in edge.fromSlot.node.outputSlots)
			{
				if(slot != edge.fromSlot && !found)
				{
					indexes.x++;
				}
				else
				{
					found = true;
				}
				totalOutputs++;
			}
			indexes.x = totalOutputs - indexes.x - 1;

			foreach (Slot slot in edge.toSlot.node.inputSlots)
			{
				if (slot != edge.toSlot)
				{
					indexes.y++;
				}
				else
				{
					break;
				}
			}

			return indexes;
		}

		public static Color ColorForIndex(string name)
		{
			int hash = Math.Abs(Animator.StringToHash(name));
			return Color.HSVToRGB((float) (hash / (double) int.MaxValue), 1f, 1f);
		}

		public void DoDraggedEdge() { }

		public void BeginSlotDragging(Slot slot, bool allowStartDrag, bool allowEndDrag) { }

		public void SlotDragging(Slot slot, bool allowEndDrag, bool allowMultiple) { }

		public void EndSlotDragging(Slot slot, bool allowMultiple) { }
		
		public void EndDragging() { }

		public Edge FindClosestEdge()
		{
			return null;
		}
		
		#endregion

		#region Edge drawer

		static private void DrawEdge(Edge edge, Vector2Int indexes, Color color)
		{
			Vector2 p1 = GetPositionAsFromSlot(edge.fromSlot, indexes.x);
			Vector2 p2 = GetPositionAsToSlot(edge.toSlot, indexes.y);
			DrawEdge(p1, p2,  color * edge.color, EdgeTriggersTracker.GetTimings(edge));
		}

		static private void DrawEdge(Vector2 p1, Vector2 p2, Color color, List<float> triggers)
		{
			Color prevColor = Handles.color;
			Handles.color = color;

			float l = Mathf.Min(Mathf.Abs(p1.y - p2.y), 50);
			Vector2 p3 = p1 + new Vector2(l, 0);
			Vector2 p4 = p2 - new Vector2(l, 0);
			Texture2D texture = (Texture2D)Styles.selectedConnectionTexture.image;
			Handles.DrawBezier(p1, p2, p3, p4, color, texture, EDGE_WIDTH);
			
			foreach (float trigger in triggers)
			{
				Vector3 pos = CalculateBezierPoint(trigger, p1, p3, p4, p2);
				Handles.DrawSolidArc(pos, Vector3.back, pos + Vector3.up, 360, EDGE_WIDTH );
			}

			Handles.color = prevColor;
		}

		#endregion

		#region Utilities to access private members
		
		static private Vector2 GetPositionAsFromSlot(Slot slot, int index)
		{
			NodeGUI node = slot.node as NodeGUI;
			if (node != null)
			{
				Vector2 pos = node.position.position;
			
				pos.y = node.position.yMax - K_EDGE_BOTTOM_MARGIN;
				pos.y -= K_NODE_EDGE_SEPARATION * index;

				pos.x = node.position.xMax;

				return pos;
			}
			
			return Vector2.zero;
		}

		static private Vector2 GetPositionAsToSlot(Slot slot, int index)
		{
			NodeGUI node = slot.node as NodeGUI;
			if (node != null)
			{
				Vector2 pos = node.position.position;
				pos.y += K_NODE_TITLE_SPACE;
				pos.y += K_NODE_EDGE_SEPARATION * index;
				pos.x = node.position.x;

				return pos;
			}
			
			return Vector2.zero;
		}
		
		#endregion

		public static Vector3 CalculateBezierPoint(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
		{
			float u = 1.0f - t;
			float tt = t * t;
			float uu = u * u;
			float uuu = uu * u;
			float ttt = tt * t;

			Vector3 p = uuu * p0;
			p += 3 * uu * t * p1;
			p += 3 * u * tt * p2;
			p += ttt * p3;

			return p;
		}
	}

}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EdgeGUI.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EdgeTriggersTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 57a57526436160744ba47854e093c284
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using UnityEditor.Graphs;
using UnityEngine;

namespace EventVisualizer.Base
{
    public static class EdgeTriggersTracker
    {
        public class EdgeTrigger
        {
			public EventCall eventCall;
            public Edge edge;
            public float triggeredTime;
        }

        public static readonly float TimeToLive = 1f;
        private static readonly List<EdgeTrigger> Triggers = new List<EdgeTrigger>();

        public static void RegisterTrigger(Edge edge, EventCall eventCall)
        {
            Triggers.Add(new EdgeTrigger() { edge = edge, eventCall = eventCall, triggeredTime = Time.unscaledTime });
        }

		public static List<float> GetTimings(EventCall eventCall) 
		{
			float now = Time.unscaledTime;
			List<EdgeTrigger> acceptedTriggers = Triggers.FindAll(t => t.eventCall == eventCall);
			return GetTimings(acceptedTriggers);
		}

		public static List<float> GetTimings(Edge edge) 
		{
			List<EdgeTrigger> acceptedTriggers = Triggers.FindAll(t => t.edge == edge);
			return GetTimings(acceptedTriggers);
		}

		private static List<float> GetTimings(List<EdgeTrigger> acceptedTriggers)
		{
			float now = Time.unscaledTime;
			List<float> timings = new List<float>();//TODO cache
			foreach (EdgeTrigger t in acceptedTriggers) 
			{
				float time = Mathf.Abs(t.triggeredTime - now) / TimeToLive;
				if (time <= 1f) 
				{
					timings.Add(time);
				}
				else 
				{
					Triggers.Remove(t);
				}
			}
			return timings;
		}

        public static void CleanObsolete()
        {
            float now = Time.unscaledTime;
            Triggers.RemoveAll(trigger => Mathf.Abs(now - trigger.triggeredTime) > TimeToLive);
        }

        public static bool HasData()
        {
            return Triggers.Count > 0;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EdgeTriggersTracker.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EditorZoomArea.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 740582e9454097243a1e7bb1aa2e503f
# ASMDEF: ldx.framework.editor.dll
# ---
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace EventVisualizer.Base
{
    public class EditorZoomArea
    {
        private const float EDITOR_WINDOW_TAB_HEIGHT = 21.0f;
        private static Matrix4x4 PrevGuiMatrix;

        public static Rect Begin(float zoomScale, Rect screenCoordsArea)
        {
            GUI.EndGroup();        // End the group Unity begins automatically for an EditorWindow to clip out the window tab. This allows us to draw outside of the size of the EditorWindow.

            Rect clippedArea = screenCoordsArea.ScaleSizeBy(1.0f / zoomScale, screenCoordsArea.TopLeft());
            clippedArea.y += EDITOR_WINDOW_TAB_HEIGHT;
            GUI.BeginGroup(clippedArea);

            PrevGuiMatrix = GUI.matrix;
            Matrix4x4 translation = Matrix4x4.TRS(clippedArea.TopLeft(), Quaternion.identity, Vector3.one);
            Matrix4x4 scale = Matrix4x4.Scale(new Vector3(zoomScale, zoomScale, 1.0f));
            GUI.matrix = translation * scale * translation.inverse * GUI.matrix;

            return clippedArea;
        }

        public static void End()
        {
            GUI.matrix = PrevGuiMatrix;
            GUI.EndGroup();
            GUI.BeginGroup(new Rect(0.0f, EDITOR_WINDOW_TAB_HEIGHT, Screen.width, Screen.height));
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EditorZoomArea.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventCall.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b9a31c3ec17359c4184082738f092498
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Reflection;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEngine;
using UnityEngine.Events;

namespace EventVisualizer.Base
{
    [System.Serializable]
    public class EventCall
    {
        private static Regex parenteshesPattern = new Regex(@"\(([^\(]*)\)$");
        
        public readonly Object sender;
        public readonly Object receiver;
		public readonly string eventShortName;
		public readonly string eventFullName;
		public readonly string method;
        public readonly Color color;
        public readonly UnityEventBase unityEvent;
        
        public System.Action OnTriggered;

		public NodeData nodeSender;
        public NodeData nodeReceiver;
        
        public string ReceiverComponentName { get; private set; }
        public string ReceiverComponentNameSimple { get; private set; }
        public string MethodFullPath => ReceiverComponentName + "." + method;
        public double lastTimeExecuted { get; private set; }
        public int timesExecuted { get; private set; }

        public EventCall(Object sender, Object receiver, string eventShortName, string eventFullName, string methodName, UnityEventBase unityEvent)
        {
            this.sender = sender as Component ? (sender as Component)?.gameObject : sender;
            this.receiver = receiver as Component ? (receiver as Component)?.gameObject : receiver;
			this.eventShortName = eventShortName;
			this.eventFullName = eventFullName;
			method = methodName;
			color = EdgeGUI.ColorForIndex(this.eventShortName);
			this.unityEvent = unityEvent;

            UpdateReceiverComponentName(receiver);
            AttachTrigger(unityEvent);
        }

        private void AttachTrigger(UnityEventBase unityEvent)
        {
            if (unityEvent == null)
            {
                return;
            }
            MethodInfo eventRegisterMethod = unityEvent.GetType().GetMethod("AddListener");
            if (eventRegisterMethod != null)
            {
                System.Type eventType = eventRegisterMethod.GetParameters()[0].ParameterType;
                ParameterInfo[] eventParameters = eventType.GetMethod("Invoke")?.GetParameters(); 
                
                if (eventParameters is { Length: 0 })
                {
                    MethodInfo methodInfo = this.GetType()
                        .GetMethod("TriggerZeroArgs", BindingFlags.Public | BindingFlags.Instance);

                    System.Type actionT = typeof(UnityAction);
                    System.Delegate triggerAction = System.Delegate.CreateDelegate(actionT, this, methodInfo);

                    eventRegisterMethod.Invoke(unityEvent, new object[]
                    {
                        triggerAction
                    });
                }

                else if (eventParameters is { Length: 1 })
                {
                    System.Type t0 = eventParameters[0].ParameterType;

                    MethodInfo methodInfo = GetType()
                        .GetMethod("TriggerOneArg", BindingFlags.Public | BindingFlags.Instance)
                        ?.MakeGenericMethod(t0);

                    System.Type actionT = typeof(UnityAction<>).MakeGenericType(t0);
                    System.Delegate triggerAction = System.Delegate.CreateDelegate(actionT, this, methodInfo);

                    eventRegisterMethod.Invoke(unityEvent, new object[]
                    {
                        triggerAction
                    });
                }
                else if (eventParameters is { Length: 2 })
                {
                    System.Type t0 = eventParameters[0].ParameterType;
                    System.Type t1 = eventParameters[1].ParameterType;

                    MethodInfo methodInfo = GetType()
                        .GetMethod("TriggerTwoArgs", BindingFlags.Public | BindingFlags.Instance)
                        ?.MakeGenericMethod(t0, t1);

                    System.Type actionT = typeof(UnityAction<,>).MakeGenericType(t0, t1);
                    System.Delegate triggerAction = System.Delegate.CreateDelegate(actionT, this, methodInfo);

                    eventRegisterMethod.Invoke(unityEvent, new object[]
                    {
                        triggerAction
                    });
                }
                else if (eventParameters is { Length: 3 })
                {
                    System.Type t0 = eventParameters[0].ParameterType;
                    System.Type t1 = eventParameters[1].ParameterType;
                    System.Type t2 = eventParameters[2].ParameterType;

                    MethodInfo methodInfo = GetType()
                        .GetMethod("TriggerThreeArgs", BindingFlags.Public | BindingFlags.Instance)
                        ?.MakeGenericMethod(t0, t1,t2);

                    System.Type actionT = typeof(UnityAction<,,>).MakeGenericType(t0, t1,t2);
                    System.Delegate triggerAction = System.Delegate.CreateDelegate(actionT, this, methodInfo);

                    eventRegisterMethod.Invoke(unityEvent, new object[]
                    {
                        triggerAction
                    });
                }
                else if (eventParameters is { Length: 2 })
                {
                    System.Type t0 = eventParameters[0].ParameterType;
                    System.Type t1 = eventParameters[1].ParameterType;
                    System.Type t2 = eventParameters[2].ParameterType;
                    System.Type t3 = eventParameters[3].ParameterType;

                    MethodInfo methodInfo = GetType()
                        .GetMethod("TriggerFourArgs", BindingFlags.Public | BindingFlags.Instance)
                        ?.MakeGenericMethod(t0, t1,t2,t3);

                    System.Type actionT = typeof(UnityAction<,,,>).MakeGenericType(t0, t1, t2,t3);
                    System.Delegate triggerAction = System.Delegate.CreateDelegate(actionT, this, methodInfo);

                    eventRegisterMethod.Invoke(unityEvent, new object[]
                    {
                        triggerAction
                    });
                }
            }
        }

        #region generic callers
        public void TriggerZeroArgs()
        {
            OnExecuted();
            OnTriggered?.Invoke();
        }

        public void TriggerOneArg<T0>(T0 arg0)
        {
            OnExecuted();
            OnTriggered?.Invoke();
        }
        public void TriggerTwoArgs<T0,T1>(T0 arg0, T1 arg1)
        {
            OnExecuted();
            OnTriggered?.Invoke();
        }
        public void TriggerThreeArgs<T0,T1,T2>(T0 arg,T1 arg1, T2 arg2)
        {
            OnExecuted();
            OnTriggered?.Invoke();
        }
        public void TriggerFourArgs<T0, T1, T2, T3>(T0 arg, T1 arg1, T2 arg2, T3 arg3)
        {
            OnExecuted();
            OnTriggered?.Invoke();
        }

        private void OnExecuted() 
        {
            timesExecuted++;
            lastTimeExecuted = EditorApplication.timeSinceStartup;
        }
        #endregion

        private void UpdateReceiverComponentName(Object component)
        {
            if (receiver != null)
            {
                MatchCollection matches = parenteshesPattern.Matches(component.ToString());
                if (matches is { Count: 1 })
                {
                    ReceiverComponentName = matches[0].Value;
                    ReceiverComponentName = ReceiverComponentName.Substring(1, ReceiverComponentName.Length - 2);
					int lastDot = ReceiverComponentName.LastIndexOf('.') + 1;
					ReceiverComponentNameSimple = ReceiverComponentName.Substring(lastDot, ReceiverComponentName.Length - lastDot);
				}
            }
        }
        
		public override bool Equals(object obj) 
        {
			EventCall ec = (EventCall) obj;
			return null != ec && ec.unityEvent == unityEvent && receiver == ec.receiver && method == ec.method;
		}

		public override int GetHashCode() 
        {
			return unityEvent == null ? 0 : unityEvent.GetHashCode() ^ (receiver == null ? 0 : receiver.GetHashCode() ^ method.GetHashCode());
		}
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventCall.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventsGraph.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a48afff5ab5b4244f86f43a26d925a16
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;
using System.Collections.Generic;
using UnityEditor.Graphs;
using System.Linq;
using UnityEditor;

namespace EventVisualizer.Base
{
	[System.Serializable]
	public class EventsGraph : Graph
	{
		private const float VERTICAL_SPACING = 80f;
		private const float HORIZONTAL_SPACING = 400f;
		private const int WARNING_CALLS_THRESHOLD = 1000;
		
		private HashSet<Node> positionedNodes = new HashSet<Node>();
		private GameObject[] selectedRoots;
		private bool searchingHierarchy;

		static public EventsGraph Create()
		{
			EventsGraph graph = CreateInstance<EventsGraph>();
			graph.hideFlags = HideFlags.HideAndDontSave;
			return graph;
		}

		public EventsGraphGUI GetEditor()
		{
			EventsGraphGUI gui = CreateInstance<EventsGraphGUI>();
			gui.graph = this;
			gui.hideFlags = HideFlags.HideAndDontSave;
			return gui;
		}

		public void RebuildGraph(GameObject[] roots, bool searchHierarchy)
		{
			selectedRoots = roots;
			searchingHierarchy = searchHierarchy;
			BuildGraph(selectedRoots, searchHierarchy);
			SortGraph(nodes,false);
		}

		public void RefreshGraphConnections()
		{
			Dictionary<string, Rect> positions = new Dictionary<string, Rect>();
			List<Node> adriftNodes = new List<Node>();
			NodeGUI singleNode = null;
			
			foreach (Node node1 in nodes)
			{
				singleNode = (NodeGUI)node1;
				positions.Add(singleNode.name, singleNode.position);
			}
			BuildGraph(selectedRoots, searchingHierarchy);

			foreach (Node node1 in nodes)
			{
				singleNode = (NodeGUI)node1;
				if(positions.TryGetValue(singleNode.name, out Rect position))
				{
					singleNode.position = position;
				}
				else
				{
					adriftNodes.Add(singleNode);
				}
			}
			SortGraph(adriftNodes,true);
		}

		private void BuildGraph(GameObject[] roots, bool searchHierarchy)
		{
			NodeData.ClearAll();
			Clear(true);
			List<EventCall> calls = EventsFinder.FindAllEvents(roots, searchHierarchy);
			if(calls.Count > WARNING_CALLS_THRESHOLD)
			{
				bool goAhead = EditorUtility.DisplayDialog("Confirm massive graph",
					"You are about to generate a graph with "+ calls.Count+" events.\n"
					+ "Tip: You can select some gameobjects and search events in just those or their children instead.",
					"Go ahead",
					"Abort");

				if(goAhead)
				{
					GenerateGraphFromCalls(calls);
				}
			}
			else
			{
				GenerateGraphFromCalls(calls);
			}
		}

		private void GenerateGraphFromCalls(List<EventCall> calls)
		{
			foreach (EventCall call in calls)
			{
				NodeData.RegisterEvent(call);
			}

			NodeGUI node = null;
			foreach (NodeData data in NodeData.Nodes)
			{
				node = NodeGUI.Create(data);
				if (!nodes.Contains(node))
				{
					AddNode(node);
				}
			}
			foreach (Node node1 in nodes)
			{
				node = (NodeGUI)node1;
				node.PopulateEdges();
			}
		}

		#region sorting

		private void SortGraph(List<Node> nodesToSort, bool skipParents)
		{
			positionedNodes.Clear();

			List<Node> sortedNodes = new List<Node>(nodesToSort); //cannot sort the original collection so a clone is needed
			sortedNodes.Sort((x, y) =>
			{
				int xScore = x.outputEdges.Count() - x.inputEdges.Count();
				int yScore = y.outputEdges.Count() - y.inputEdges.Count();
				return yScore.CompareTo(xScore);
			});

			Vector2 position = Vector2.zero;
			foreach (Node node in sortedNodes)
			{
				if (!positionedNodes.Contains(node))
				{
					positionedNodes.Add(node);
					position.y += PositionNodeHierarchy(node, position, skipParents);
				}
			}
		}
		
		private float PositionNodeHierarchy(Node currentNode, Vector2 masterPosition, bool skipParents)
		{
			float height = VERTICAL_SPACING;
			if (!skipParents)
			{
				foreach (Edge outputEdge in currentNode.outputEdges)
				{
					Node node = outputEdge.toSlot.node;
					if (!positionedNodes.Contains(node))
					{
						positionedNodes.Add(node);
						height += PositionNodeHierarchy(node, masterPosition
							+ Vector2.right * HORIZONTAL_SPACING
							+ Vector2.up * height, skipParents);
					}
				}
			}
			currentNode.position = new Rect(masterPosition + Vector2.up * height * 0.5f, currentNode.position.size);

			return height;
		}

		#endregion
	}
}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventsGraph.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventsGraphGUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d0a9d505156c000439f4832d50c68d7f
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;
using UnityEditor;
using EventVisualizer.Base;
using System.Collections.Generic;
using UnityEditor.Graphs;
using UnityEngine.Serialization;

namespace EventVisualizer.Base
{
    [System.Serializable]
	public class EventsGraphGUI : GraphGUI
    {
        public int SelectionOverride;
      
        public override void OnGraphGUI()
        {
            // Show node subwindows.
			m_Host.BeginWindows();
			
			foreach (Node node in graph.nodes)
            {
                // Recapture the variable for the delegate.
                Node node2 = node;

                // Subwindow style (active/nonactive)
                bool isActive = selection.Contains(node);
                GUIStyle style = Styles.GetNodeStyle(node.style, node.color, isActive);
                
                node.position = GUILayout.Window
                (
                    node.GetInstanceID(), 
                    node.position,
                    delegate { NodeGUI(node2); },
                    node.title, 
                    style, 
                    GUILayout.Width(150)
                );
            }
            
            if (graph.nodes.Count == 0)
            { 
                GUILayout.Window(0, new Rect(0, 0, 1, 1), delegate {}, "", "MiniLabel");
            }
			
			m_Host.EndWindows();

			// Graph edges
			edgeGUI.DoEdges();

			
			// Mouse drag
#if UNITY_2017 || UNITY_2017_1_OR_NEWER
			DragSelection();
#else
			DragSelection(new Rect(-5000, -5000, 10000, 10000));
#endif
        }
        
        public override IEdgeGUI edgeGUI
        {
            get
            {
                if (m_EdgeGUI == null)
                    m_EdgeGUI = new EdgeGUI { host = this };
                return m_EdgeGUI;
            }
        }
        
        public override void NodeGUI(Node node)
        {
            SelectNode(node);

            foreach (Slot slot in node.inputSlots)
                LayoutSlot(slot, slot.title, false, true, true, Styles.triggerPinIn);

            node.NodeUI(this);

            foreach (Slot slot in node.outputSlots)
            {
                EditorGUILayout.BeginHorizontal();
                GUILayout.FlexibleSpace();
                LayoutSlot(slot, slot.title, true, false, true, Styles.triggerPinOut);
                EditorGUILayout.EndHorizontal();
            }

            DragNodes();

            UpdateSelection();
        }

        private void UpdateSelection()
        {
            OverrideSelection();
            if (selection.Count > 0)
            {
                int[] selectedIds = new int[selection.Count];
                for (int i = 0; i < selection.Count; i++)
                {
					if(selection[i] != null)
					{
						selectedIds[i] = int.Parse(selection[i].name);
					}
                }
                Selection.instanceIDs = selectedIds;
            }
        }

        private void OverrideSelection()
        {
            if (SelectionOverride != 0)
            {
                Node selectedNode = graph[SelectionOverride.ToString()];
                
                if (selectedNode != null)
                {
                    selection.Clear();
                    selection.Add(selectedNode);
                    CenterGraph(selectedNode.position.position);
                }
                SelectionOverride = 0;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventsGraphGUI.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventsGraphWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 29ac7234bb09f2f4d8dafebd9faacc56
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Text;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEngine;
using UnityEngine.Serialization;

namespace EventVisualizer.Base
{
	public class EventsGraphWindow : EditorWindow
	{
		private const float BAR_HEIGHT = 17;
		private const float ZOOM_MIN = 0.1f;
		private const float ZOOM_MAX = 1.0f;
		
		private static readonly string[] toolbarStrings = new string[] {"Rebuild on selected Hierarchy", "Rebuild JUST selected", "Update connections" };

		[Serializable]
		public class SavedPrefBool 
		{
			public readonly string name;
			protected readonly bool defaultValue;
			protected bool value;
			private bool ready = false;

			public SavedPrefBool(string name, bool defaultValue) 
			{
				this.name = name;
				this.defaultValue = defaultValue;
			}

			public bool Get() 
			{
				if (!ready) {
					ready = true;
					value = EditorPrefs.GetBool(name, defaultValue);
				}
				return value;
			}
			
			public void Set(bool value) 
			{
				this.value = value;
				EditorPrefs.SetBool(name, value);
			}
		}
		
		[FormerlySerializedAs("_graph")]
		[SerializeField] private EventsGraph graph;
		[FormerlySerializedAs("_graphGUI")]
		[SerializeField] private EventsGraphGUI graphGUI;
		[SerializeField] private SavedPrefBool showOnlyWhenSelected = new SavedPrefBool("EventVisualizer_showOnlyWhenSelected", true);
		[SerializeField] private SavedPrefBool showLabels = new SavedPrefBool("EventVisualizer_showLabels", true);
		[SerializeField] private SavedPrefBool showComponentName = new SavedPrefBool("EventVisualizer_showComponentName", true);
		[SerializeField] private SavedPrefBool showTimesExecuted = new SavedPrefBool("EventVisualizer_showTimesExecuted", true);
		[SerializeField] private SavedPrefBool eventFullName = new SavedPrefBool("EventVisualizer_eventFullName", true);

		private struct Bezier 
		{
			public enum Tangent { None, Auto, Positive, Negative, PositiveUnscaled, NegativeUnscaled }
			public Vector2 start;
			public Vector2 end;
			public Tangent startTangent, endTangent;
		}

		private struct EventBox 
		{
			public EventCall ev;
			public GUIContent content;
			public Rect rect;
		}

		private Dictionary<EventCall, Bezier> beziersToDraw = new Dictionary<EventCall, Bezier>();
		private List<EventBox> boxesToDraw = new List<EventBox>();
		
		public float separation = 3;
		public GUISkin guiSkin;
		private Rect zoomArea = new Rect(0.0f, 75.0f, 600.0f, 300.0f - 100.0f);
		private float zoom = 1f;
		private Vector2 zoomCoordsOrigin = Vector2.zero;
		private bool initialized = false;

		[MenuItem("Window/Events Graph editor")]
		static private void ShowEditor()
		{
			EventsGraphWindow editor = EditorWindow.GetWindow<EventsGraphWindow>();
			editor.hideFlags = HideFlags.HideAndDontSave;
			editor.Initialize();
		}

		public void Initialize()
		{
			if (initialized) return;
			initialized = true;
			graph = EventsGraph.Create();
			//_graph.RebuildGraph();

			graphGUI = graph.GetEditor();
			graphGUI.CenterGraph();

			EditorUtility.SetDirty(graphGUI);
			EditorUtility.SetDirty(graph);
		}
		
		private void OnGUI()
		{
			Initialize();

			float width = position.width;
			float height = position.height;
			zoomArea = new Rect(0, 0, width, height);
			HandleEvents();

			if (graphGUI != null)
			{
				Rect r = EditorZoomArea.Begin(zoom, zoomArea);
				// Main graph area
				graphGUI.BeginGraphGUI(this, r);
				graphGUI.OnGraphGUI();
				graphGUI.EndGraphGUI();

				// Clear selection on background click
				Event e = Event.current;
				if (e.type == EventType.MouseDown && e.clickCount == 1)
					graphGUI.ClearSelection();
				
				EditorZoomArea.End();
			}
			
			// Status bar
			GUILayout.BeginArea(new Rect(0, 0, width, BAR_HEIGHT+5));
			int result = GUILayout.Toolbar(-1, toolbarStrings);
			switch (result)
			{
				case 0:
					RebuildGraphOnSelected(true);
					break;
				case 1:
					RebuildGraphOnSelected(false);
					break;
				case 2:
					RefreshGraphConnections();
					break;
			}
			GUILayout.EndArea();

			const float maxWidth = 200;
			GUILayout.BeginArea(new Rect(0, BAR_HEIGHT + 5, maxWidth, 20 * 5), GUI.skin.box);
			showOnlyWhenSelected.Set(EditorGUILayout.Toggle("Show only when selected", showOnlyWhenSelected.Get(), GUILayout.MaxWidth(maxWidth)));
			showLabels.Set(EditorGUILayout.Toggle("Labels", showLabels.Get(), GUILayout.MaxWidth(maxWidth)));
			showComponentName.Set(EditorGUILayout.Toggle("Function Full Path", showComponentName.Get(), GUILayout.MaxWidth(maxWidth)));
			eventFullName.Set(EditorGUILayout.Toggle("Event Full Name", eventFullName.Get(), GUILayout.MaxWidth(maxWidth)));
			showTimesExecuted.Set(EditorGUILayout.Toggle("Times Executed", showTimesExecuted.Get(), GUILayout.MaxWidth(maxWidth)));
			GUILayout.EndArea();
		}
		
		private void Update()
		{
			if (EdgeTriggersTracker.HasData())
			{
				Repaint();
			}
		}

		public void OverrideSelection(int overrideIndex)
		{
			graphGUI.SelectionOverride = overrideIndex;
		}

		public Vector2 ConvertScreenCoordsToZoomCoords(Vector2 screenCoords)
		{
			return (screenCoords - zoomArea.TopLeft()) / zoom + zoomCoordsOrigin;
		}
		
		private void HandleEvents()
		{
			if (Event.current.type == EventType.ScrollWheel)
			{
				Vector2 screenCoordsMousePos = Event.current.mousePosition;
				Vector2 delta = Event.current.delta;
				Vector2 zoomCoordsMousePos = ConvertScreenCoordsToZoomCoords(screenCoordsMousePos);
				float zoomDelta = -delta.y / 150.0f;
				float oldZoom = zoom;
				zoom += zoomDelta;
				zoom = Mathf.Clamp(zoom, ZOOM_MIN, ZOOM_MAX);
				zoomCoordsOrigin += (zoomCoordsMousePos - zoomCoordsOrigin) - (oldZoom / zoom) * (zoomCoordsMousePos - zoomCoordsOrigin);

				Event.current.Use();
			}
		}
		
		public void RebuildGraphOnSelected(bool searchHierarchy)
		{
			RebuildGraph(Selection.gameObjects, searchHierarchy);
		}

		public void RebuildGraph(GameObject[] roots, bool searchHierarchy)
		{
			if (graph != null)
			{
				graph.RebuildGraph(Selection.gameObjects, searchHierarchy);
			}
		}

		public void RefreshGraphConnections()
		{
			Debug.Log("Refreshing UnityEventVisualizer Graph Connections");
			if (graph != null)
			{
				graph.RefreshGraphConnections();
			}
		}
		
		private void OnFocus() 
		{
			RemoveCallbacks();
			AddCallbacks();
		}

		private void OnDestroy() 
		{
			RemoveCallbacks();
		}

		private void AddCallbacks() 
		{
			SceneView.duringSceneGui += OnSceneGUI;
			EditorApplication.playModeStateChanged += OnPlayModeStateChanged;
		}

		private void RemoveCallbacks() 
		{
			SceneView.duringSceneGui -= OnSceneGUI;
			EditorApplication.playModeStateChanged -= OnPlayModeStateChanged;
		}

		private void OnPlayModeStateChanged(PlayModeStateChange mode) 
		{
			switch (mode) 
			{
				case PlayModeStateChange.EnteredEditMode:
					break;
				case PlayModeStateChange.EnteredPlayMode:
					RefreshGraphConnections();
					break;
			}
		}

		private void OnSceneGUI(SceneView sceneView) 
		{
			Handles.BeginGUI();
			GUI.skin = guiSkin;
			
			foreach (NodeData elem in NodeData.Nodes) 
			{
				GameObject entity = elem.Entity as GameObject;
				if (null != entity) 
				{
					bool isEntitySelected = CheckSelection(entity.gameObject);
					Vector2 senderPos2D = WorldToGUIPoint(entity.transform.position, SceneView.currentDrawingSceneView.camera.transform.position, out bool behindScreen);

					if (isEntitySelected) 
					{
						StringBuilder sb = new StringBuilder();
						foreach (EventCall ev in elem.Inputs)
						{
							GameObject receiver = ev.receiver as GameObject;
							GameObject sender = ev.sender as GameObject;

							if (null != sender && receiver != ev.sender) 
							{
								if (behindScreen) senderPos2D = WorldToGUIPoint(entity.transform.position, sender.transform.position, out behindScreen);
								Rect rect = DrawEventBox(sb, "➜● ", boxesToDraw, ev, ref senderPos2D, behindScreen);
								sb.Length = 0;

								beziersToDraw.TryGetValue(ev, out Bezier b);
								b.endTangent = Bezier.Tangent.Negative;
								b.end = new Vector2(rect.x, rect.y + rect.height * 0.5f);
								beziersToDraw[ev] = b;
							}
						}
						foreach (EventCall ev in elem.Inputs)
						{
							GameObject receiver = ev.receiver as GameObject;
							if (receiver == ev.sender) 
							{
								if (behindScreen) continue; // Don't draw
								Rect rect = DrawEventBox(sb, " ●  ", boxesToDraw, ev, ref senderPos2D, behindScreen);
								sb.Length = 0;

								Bezier b;
								beziersToDraw.TryGetValue(ev, out b);
								b.endTangent = Bezier.Tangent.NegativeUnscaled;
								b.startTangent = Bezier.Tangent.NegativeUnscaled;
								b.start = new Vector2(rect.x, rect.y + rect.height * 0.25f);
								b.end = new Vector2(rect.x, rect.y + rect.height * 0.75f);
								beziersToDraw[ev] = b;
							}
						}
						
						foreach (EventCall ev in elem.Outputs)
						{
							GameObject receiver = ev.receiver as GameObject;
							if (null != receiver && receiver != ev.sender)
							{
								if (behindScreen) senderPos2D = WorldToGUIPoint(entity.transform.position, receiver.transform.position, out behindScreen);
								Rect rect = DrawEventBox(sb, "●➜ ", boxesToDraw, ev, ref senderPos2D, behindScreen);
								sb.Length = 0;

								Bezier b;
								beziersToDraw.TryGetValue(ev, out b);
								b.startTangent = behindScreen ? Bezier.Tangent.None : Bezier.Tangent.Positive;
								b.start = new Vector2(rect.x + rect.width, rect.y + rect.height * 0.5f);
								beziersToDraw[ev] = b;
							}
						}
					}
					else
					{
						foreach (EventCall ev in elem.Inputs)
						{
							GameObject sender = ev.sender as GameObject;
							if (null != sender) 
							{
								bool isSenderSelected = CheckSelection(sender.gameObject);

								if (isSenderSelected || ev.lastTimeExecuted + EdgeTriggersTracker.TimeToLive >= EditorApplication.timeSinceStartup) 
								{
									if (behindScreen) senderPos2D = WorldToGUIPoint(entity.transform.position, sender.transform.position, out behindScreen);
									Vector2 localEnd2D = senderPos2D + new Vector2(0, separation * ev.nodeSender.Inputs.IndexOf(ev));

									beziersToDraw.TryGetValue(ev, out Bezier b);
									b.endTangent = behindScreen ? Bezier.Tangent.None : Bezier.Tangent.Auto;
									b.end = localEnd2D;
									beziersToDraw[ev] = b;
								}
							}
						}

						for (int i = 0; i < elem.Outputs.Count; i++) 
						{
							EventCall ev = elem.Outputs[i];
							GameObject receiver = ev.receiver as GameObject;
							if (null != receiver) 
							{
								bool isReceiverSelected = CheckSelection(receiver.gameObject);

								if (isReceiverSelected || ev.lastTimeExecuted + EdgeTriggersTracker.TimeToLive >= EditorApplication.timeSinceStartup) 
								{
									if (behindScreen) senderPos2D = WorldToGUIPoint(entity.transform.position, receiver.transform.position, out behindScreen);
									Vector2 localStart2D = senderPos2D + new Vector2(0, separation * i);

									beziersToDraw.TryGetValue(ev, out Bezier b);
									b.startTangent = Bezier.Tangent.Auto;
									b.start = localStart2D;
									beziersToDraw[ev] = b;
								}
							}
						}
					}
				}
			}

			foreach (KeyValuePair<EventCall, Bezier> elem in beziersToDraw) 
			{
				DrawConnection(elem.Key, elem.Value);
			}
			
			beziersToDraw.Clear();

			foreach (EventBox box in boxesToDraw) 
			{
				DrawEventBox(box);
			}
			boxesToDraw.Clear();

			Handles.EndGUI();
		}

		private bool CheckSelection(GameObject go) 
		{
			return !showOnlyWhenSelected.Get() || Selection.Contains(go);
		}

		private Rect DrawEventBox(StringBuilder sb, string type, List<EventBox> boxes, EventCall ev, ref Vector2 boxPos, bool outsideScreen) 
		{
			Rect rect = new Rect(boxPos, new Vector2(0, separation));

			if (!outsideScreen && showLabels.Get()) 
			{
				sb.Append(type);
				if (showTimesExecuted.Get()) sb.Append("(").Append(ev.timesExecuted).Append(") ");
				sb.Append(eventFullName.Get() ? ev.eventFullName : ev.eventShortName).Append("  ▶  ");
				if (showComponentName.Get()) sb.Append(ev.ReceiverComponentNameSimple).Append(".");
				sb.Append(ev.method);

				GUIContent content = new GUIContent(sb.ToString());

				rect.size = GUI.skin.box.CalcSize(content);

				boxes.Add(new EventBox() 
				{
					content = content,
					ev = ev,
					rect = rect
				});
			}

			boxPos.y += rect.height;
			return rect;
		}
		
		private static void DrawEventBox(EventBox box) 
		{
			Color originalContentColor = GUI.contentColor;
			Color originalBackgroundColor = GUI.backgroundColor;

			GUI.backgroundColor = box.ev.color;
			GUI.contentColor = Brightness(box.ev.color) < 0.5f ? Color.white : Color.black;
			
			if (GUI.Button(box.rect, box.content)) 
			{
				Selection.activeObject = box.ev.sender;
			}

			GUI.contentColor = originalContentColor;
			GUI.backgroundColor = originalBackgroundColor;
		}

		private static float Brightness(Color color) 
		{
			return 0.2126f * color.r + 0.7152f * color.g + 0.0722f * color.b;
		}
		
		private static void DrawConnection(EventCall ev, Bezier b) 
		{
			const float tangentSize = 50;

			float diff = b.end.x - b.start.x;
			diff = Mathf.Sign(diff) * Mathf.Min(Mathf.Abs(diff), tangentSize);

			Vector2 p1 = b.start;
			Vector2 p2 = b.end;
			Vector2 p3 = p1;
			Vector2 p4 = p2;

			if (b.startTangent == Bezier.Tangent.Auto) p3 += new Vector2(diff, 0);
			else if (b.startTangent == Bezier.Tangent.Negative) p3 -= new Vector2(Math.Abs(diff), 0);
			else if (b.startTangent == Bezier.Tangent.Positive) p3 += new Vector2(Math.Abs(diff), 0);
			else if (b.startTangent == Bezier.Tangent.NegativeUnscaled) p3 -= new Vector2(tangentSize, 0);
			else if (b.startTangent == Bezier.Tangent.PositiveUnscaled) p3 += new Vector2(tangentSize, 0);

			if (b.endTangent == Bezier.Tangent.Auto) p4 -= new Vector2(diff, 0);
			else if (b.endTangent == Bezier.Tangent.Negative) p4 -= new Vector2(Math.Abs(diff), 0);
			else if (b.endTangent == Bezier.Tangent.Positive) p4 += new Vector2(Math.Abs(diff), 0);
			else if (b.endTangent == Bezier.Tangent.NegativeUnscaled) p4 -= new Vector2(tangentSize, 0);
			else if (b.endTangent == Bezier.Tangent.PositiveUnscaled) p4 += new Vector2(tangentSize, 0);
			
			Color c = ev.color;
			Color prevColor = Handles.color;
			Handles.color = c;
			Handles.DrawBezier(p1, p2, p3, p4, c, (Texture2D) UnityEditor.Graphs.Styles.selectedConnectionTexture.image, EdgeGUI.EDGE_WIDTH);
			foreach (float trigger in EdgeTriggersTracker.GetTimings(ev)) 
			{
				Vector3 pos = EdgeGUI.CalculateBezierPoint(trigger, p1, p3, p4, p2);
				Handles.DrawSolidArc(pos, Vector3.back, pos + Vector3.up, 360, EdgeGUI.EDGE_WIDTH);
			}
			Handles.color = prevColor;
		}

		/// <param name="p2">if p is behind the screen, p2 is used to trace a line to p and raycast it to the near clipping camera of the scene camera</param>
		private static Vector2 WorldToGUIPoint(Vector3 p, Vector3 p2, out bool behindScreen) 
		{
			Camera cam = SceneView.currentDrawingSceneView.camera;
			Vector3 viewPos = cam.WorldToViewportPoint(p);
			behindScreen = viewPos.z < 0;

			if (behindScreen && cam.WorldToViewportPoint(p2).z < 0)
			{
				return Vector2.zero;
			}

			if (behindScreen) 
			{
				if (p2 == cam.transform.position) return Vector2.zero;
				
				Plane plane = new Plane(cam.transform.forward, cam.transform.position + cam.transform.forward * cam.nearClipPlane);
				Ray r = new Ray(p, p2 - p);

				if (!plane.Raycast(r, out float enter))
				{
					return Vector2.zero;
				}

				Vector3 proj = r.origin + r.direction * enter;

				viewPos = cam.WorldToViewportPoint(proj);
			}
			float scaleFactor = 1f;
			return new Vector2(viewPos.x *  cam.scaledPixelWidth, (1 - viewPos.y) * cam.scaledPixelHeight) * scaleFactor;
		}
	}
}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventsGraphWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventsVisualizer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f765f9e5d63c890448d227f118754401
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using UnityEngine.EventSystems;
using System.Reflection;
using UnityEngine.Events;
using System;
using System.Diagnostics;
using UnityEditor.Callbacks;
using System.Linq;
using Debug = UnityEngine.Debug;

namespace EventVisualizer.Base
{
    public static class EventsFinder
    {
	    public static bool NeedsGraphRefresh = false;
	    private static HashSet<Type> ComponentsThatCanHaveUnityEvent = new HashSet<Type>();
	    private static Dictionary<Type, bool> TmpSearchedTypes = new Dictionary<Type, bool>();
	    
        public static List<EventCall> FindAllEvents(GameObject[] roots, bool searchHierarchy = true)
        {
            HashSet<EventCall> calls = new HashSet<EventCall>();
			foreach (Type type in ComponentsThatCanHaveUnityEvent)
			{
				if(type.IsGenericTypeDefinition)
				{
					continue;
				}

				HashSet<UnityEngine.Object> selectedComponents = new HashSet<UnityEngine.Object>();
				if(roots is { Length: > 0 })
				{
					foreach(GameObject root in roots)
					{
						if(root != null)
						{
							if(searchHierarchy)
							{
								selectedComponents.UnionWith(root.GetComponentsInChildren(type));
							}
							else
							{
								selectedComponents.Add(root.GetComponent(type));
							}
						}
					}
				}
				else 
				{
					selectedComponents = new HashSet<UnityEngine.Object>(GameObject.FindObjectsOfType(type));
				}

				foreach (UnityEngine.Object caller in selectedComponents)
				{
					Component comp = caller as Component;
					if(comp != null)
					{
						ExtractDefaultEventTriggers(calls, comp);
						ExtractEvents(calls, comp);
					}
				}
			}
			return calls.ToList();
        }

		private static void ExtractEvents(HashSet<EventCall> calls, Component caller)
        {
            SerializedProperty iterator = new SerializedObject(caller).GetIterator();
            iterator.Next(true);
			RecursivelyExtractEvents(calls, caller, iterator, 0);
        }

		private static bool RecursivelyExtractEvents(HashSet<EventCall> calls, Component caller, SerializedProperty iterator, int level) 
		{
			bool hasData = true;

			do 
			{
				SerializedProperty persistentCalls = iterator.FindPropertyRelative("m_PersistentCalls.m_Calls");
				bool isUnityEvent = persistentCalls != null;
				if (isUnityEvent && persistentCalls.arraySize > 0) 
				{
					UnityEventBase unityEvent = Puppy.EditorHelper.GetTargetObjectOfProperty(iterator) as UnityEventBase;
					AddEventCalls(calls, caller, unityEvent, iterator.displayName, iterator.propertyPath);
				}
				hasData = iterator.Next(!isUnityEvent);
				if (hasData) 
				{
					if (iterator.depth < level)
					{
						return hasData;
					}
					
					if (iterator.depth > level)
					{
						hasData = RecursivelyExtractEvents(calls, caller, iterator, iterator.depth);
					}
				}
			}
			
			while (hasData);
			return false;
		}

        private static void ExtractDefaultEventTriggers(HashSet<EventCall> calls, Component caller)
        {
            EventTrigger eventTrigger = caller as EventTrigger;
            if (eventTrigger != null)
            {
                foreach (EventTrigger.Entry trigger in eventTrigger.triggers)
                {
					string name = trigger.eventID.ToString();
					AddEventCalls(calls, caller, trigger.callback, name, name);
                }
            }
        }

		private static void AddEventCalls(HashSet<EventCall> calls, Component caller, UnityEventBase unityEvent, string eventShortName, string eventFullName) 
		{
			for (int i = 0; i < unityEvent.GetPersistentEventCount(); i++) 
			{
				string methodName = unityEvent.GetPersistentMethodName(i);
				UnityEngine.Object receiver = unityEvent.GetPersistentTarget(i);

				if (receiver != null && methodName != null && methodName != "") 
				{
					calls.Add(new EventCall(caller, receiver, eventShortName, eventFullName, methodName, unityEvent));
				}
			}
		}
		
		[DidReloadScripts, InitializeOnLoadMethod]
		static void RefreshTypesThatCanHoldUnityEvents() 
		{
			Stopwatch sw = System.Diagnostics.Stopwatch.StartNew();
			
#if NET_4_6
			IEnumerable<Type> objects = AppDomain.CurrentDomain.GetAssemblies().Where(a => !a.IsDynamic)
				.SelectMany(a => a.GetTypes())
				.Where(t => typeof(Component).IsAssignableFrom(t));
#else
			var objects = AppDomain.CurrentDomain.GetAssemblies()
				.SelectMany(a => a.GetTypes())
				.Where(t => typeof(Component).IsAssignableFrom(t));
#endif

			foreach (Type obj in objects) 
			{
				if (RecursivelySearchFields<UnityEventBase>(obj)) 
				{
					ComponentsThatCanHaveUnityEvent.Add(obj);
				}
			}
			TmpSearchedTypes.Clear();
			
			Debug.Log("UnityEventVisualizer Updated Components that can have UnityEvents (" + ComponentsThatCanHaveUnityEvent.Count + "). Milliseconds: " + sw.Elapsed.TotalMilliseconds);
		}

		/// <summary>
		/// Search for types that have a field or property of type <typeparamref name="T"/> or can hold an object that can.
		/// </summary>
		/// <typeparam name="T">Needle</typeparam>
		/// <param name="type">Haystack</param>
		/// <returns>Can contain some object <typeparamref name="T"/></returns>
		static bool RecursivelySearchFields<T>(Type type) 
		{
			if (TmpSearchedTypes.TryGetValue(type, out bool wanted))
			{
				return wanted;
			}
			
			TmpSearchedTypes.Add(type, false);
			
			const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;
			foreach (Type fType in type.GetFields(flags)
				         .Where(f => !f.FieldType.IsPrimitive)
				         .Select(f => f.FieldType)
				         .Concat(type.GetProperties(flags)
					         .Select(p => p.PropertyType))) 
			{
				if (typeof(T).IsAssignableFrom(fType)) 
				{
					return TmpSearchedTypes[type] = true;
				}
				if (typeof(UnityEngine.Object).IsAssignableFrom(fType)) 
				{
					continue;
				}
				if (!TmpSearchedTypes.TryGetValue(fType, out wanted)) 
				{
					if (RecursivelySearchFields<T>(fType)) 
					{
						return TmpSearchedTypes[type] = true;
					}
				}
				else if (wanted) 
				{
					return TmpSearchedTypes[type] = true;
				}
			}

			if (type.IsArray) 
			{
				if (RecursivelySearchFields<T>(type.GetElementType())) 
				{
					return TmpSearchedTypes[type] = true;
				}
			}

			return false;
		}
	}
}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventsVisualizer.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/FindInGraphButton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 82c731ab640f84c418a051295fc47a71
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace EventVisualizer.Base
{
    public static class FindInGraphButton
    {
        [MenuItem("GameObject/EventGraph/Find in current graph", false, 0)]
        private static void FindEvents()
        {
            EventsGraphWindow window = EditorWindow.GetWindow<EventsGraphWindow>();
            if(window != null)
            {
                window.OverrideSelection(Selection.activeInstanceID);
            }
        }

		[MenuItem("GameObject/EventGraph/Graph just this", false, 0)]
		private static void GraphSelection()
		{
			EventsGraphWindow window = EditorWindow.GetWindow<EventsGraphWindow>();
			window.RebuildGraph(new GameObject[] { Selection.activeGameObject }, false);
		}
		
		[MenuItem("GameObject/EventGraph/Graph this hierarchy", false, 0)]
		private static void GraphSelectionHierarchy()
		{
			EventsGraphWindow window = EditorWindow.GetWindow<EventsGraphWindow>();
			window.RebuildGraph(new GameObject[] { Selection.activeGameObject }, true);
		}
	}

}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/FindInGraphButton.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/NodeData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e15846c0f71123d4e8406b6a6a30b732
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using UnityEngine;

namespace EventVisualizer.Base
{
    [System.Serializable]
    public class NodeData
    {
	    private static Dictionary<int, NodeData> nodes = new Dictionary<int, NodeData>();
	    public static ICollection<NodeData> Nodes => nodes?.Values;
	    
        public Object Entity { get; private set; }
        public string Name => Entity != null ? Entity.name : "<Missing>";
        public List<EventCall> Outputs { get; private set; }
        public List<EventCall> Inputs { get; private set; }

        public NodeData(Object entity)
        {
	        Entity = entity;
	        Outputs = new List<EventCall>();
	        Inputs = new List<EventCall>();
        }
        
        public static void ClearAll() 
        {
            nodes.Clear();
        }

		public static void ClearSlots()
		{
			foreach(int node in nodes.Keys)
			{
				nodes[node].Outputs.Clear();
				nodes[node].Inputs.Clear();
			}
		}
        
        public static void RegisterEvent(EventCall eventCall)
        {
            NodeData nodeSender = CreateNode(eventCall.sender);
            NodeData nodeReceiver = CreateNode(eventCall.receiver);

			eventCall.nodeSender = nodeSender;
			eventCall.nodeReceiver = nodeReceiver;

			nodeSender.Outputs.Add(eventCall);
			nodeReceiver.Inputs.Add(eventCall);
        }
        
        private static NodeData CreateNode(Object entity)
        {
			int id = entity.GetInstanceID();

			if (!nodes.TryGetValue(id, out NodeData nodeData))
            {
                nodes.Add(id, nodeData = new NodeData(entity));
            }
			return nodeData;
		}
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/NodeData.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/NodeGUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 387c6d86b11d7d241a2da4a68b1dd9a5
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;
using UnityEditor;
using System.Linq;
using UnityEditor.Graphs;
using System.Collections.Generic;

namespace EventVisualizer.Base
{
    public class NodeGUI : Node
    {
	    private Texture2D icon;
	    private NodeData runtimeInstance;
	    
	    public bool IsValid => runtimeInstance != null;
	    public override string title => IsValid ? runtimeInstance.Name : "<Missing>";

	    static public NodeGUI Create(NodeData dataInstance)
        {
			bool isGameObject = dataInstance.Entity is GameObject;

			NodeGUI node = CreateInstance<NodeGUI>();
            node.Initialize(dataInstance);
            node.name = dataInstance.Entity.GetInstanceID().ToString();
			node.icon = (Texture2D)EditorGUIUtility.IconContent(isGameObject?"GameObject Icon" : "ScriptableObject Icon").image;
			return node;
        }
	    
	    private void Initialize(NodeData instance)
	    {
		    hideFlags = HideFlags.DontSave;
			
		    runtimeInstance = instance;
		    position = new Rect(Vector2.one * Random.Range(0, 500), Vector2.zero);

		    PopulateSlots();
	    }
	    
		public override void NodeUI(GraphGUI host)
		{
			base.NodeUI(host);
			if (icon != null)
			{
				GUI.DrawTexture(new Rect(Vector2.one * 5, new Vector2(20, 20)), icon);
			}
		}

		private void PopulateSlots()
        {
            foreach (EventCall call in runtimeInstance.Outputs)
            {
                string eventName = call.eventShortName;
                string eventTitle = ObjectNames.NicifyVariableName(eventName);
                
                if (outputSlots.All(s => s.title != eventTitle))
                {
                    Slot slot = AddOutputSlot(eventName);
                    slot.title = eventTitle;
                }
            }

            foreach (EventCall call in runtimeInstance.Inputs)
            {
                string methodPath = call.MethodFullPath;
                string methodName = ObjectNames.NicifyVariableName(methodPath);
                if (inputSlots.All(s => s.title != methodName))
                {
                    Slot slot = AddInputSlot(methodPath);
                    slot.title = methodName;
                }
            }
        }

        public void PopulateEdges()
        {
            foreach (Slot outSlot in outputSlots)
            {
                List<EventCall> outCalls = runtimeInstance.Outputs.FindAll(call => call.eventShortName == outSlot.name);

                foreach (EventCall call in outCalls)
                {
                    Node targetNode = graph[call.receiver.GetInstanceID().ToString()];
                    Slot inSlot = targetNode[call.MethodFullPath];
					
					if (graph.Connected(outSlot, inSlot))
					{
						Edge existingEdge = graph.edges.Find(e => e.fromSlot == outSlot && e.toSlot == inSlot);
						graph.RemoveEdge(existingEdge);
					}

					Edge edge = graph.Connect(outSlot, inSlot);
					call.OnTriggered += (() => EdgeTriggersTracker.RegisterTrigger(edge, call));
				}
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/NodeGUI.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/PuppyEditor/EditorHelper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: df6a2a6945f2bdd459f360036853fb7f
# ASMDEF: ldx.framework.editor.dll
# ---
//https://github.com/lordofduct/spacepuppy-unity-framework/blob/master/SpacepuppyBaseEditor/EditorHelper.cs
// Removed some functions from the original file that aren't needed here

using System;
using System.Collections;
using UnityEditor;
using System.Linq;
using System.Reflection;

namespace EventVisualizer.Puppy
{
	public static class EditorHelper
	{
		#region SerializedProperty Helpers
		
		public static object GetTargetObjectOfProperty(SerializedProperty prop)
		{
			string path = prop.propertyPath.Replace(".Array.data[", "[");
			object obj = prop.serializedObject.targetObject;
			string[] elements = path.Split('.');
			foreach (string element in elements)
			{
				if (element.Contains("["))
				{
					string elementName = element.Substring(0, element.IndexOf("["));
					int index = System.Convert.ToInt32(element.Substring(element.IndexOf("[")).Replace("[", "").Replace("]", ""));
					obj = GetValue_Imp(obj, elementName, index);
				}
				else
				{
					obj = GetValue_Imp(obj, element);
				}
			}
			return obj;
		}
		
		public static object GetTargetObjectWithProperty(SerializedProperty prop)
		{
			string path = prop.propertyPath.Replace(".Array.data[", "[");
			object obj = prop.serializedObject.targetObject;
			string[] elements = path.Split('.');
			foreach (string element in elements.Take(elements.Length - 1))
			{
				if (element.Contains("["))
				{
					string elementName = element.Substring(0, element.IndexOf("["));
					int index = System.Convert.ToInt32(element.Substring(element.IndexOf("[")).Replace("[", "").Replace("]", ""));
					obj = GetValue_Imp(obj, elementName, index);
				}
				else
				{
					obj = GetValue_Imp(obj, element);
				}
			}
			return obj;
		}

		private static object GetValue_Imp(object source, string name)
		{
			if (source == null)
				return null;
			Type type = source.GetType();

			while (type != null)
			{
				FieldInfo f = type.GetField(name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance);
				if (f != null)
					return f.GetValue(source);

				PropertyInfo p = type.GetProperty(name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
				if (p != null)
					return p.GetValue(source, null);

				type = type.BaseType;
			}
			return null;
		}

		private static object GetValue_Imp(object source, string name, int index)
		{
			IEnumerable enumerable = GetValue_Imp(source, name) as System.Collections.IEnumerable;
			if (enumerable == null) return null;
			IEnumerator enm = enumerable.GetEnumerator();

			for (int i = 0; i <= index; i++)
			{
				if (!enm.MoveNext()) return null;
			}
			return enm.Current;
		}

		#endregion
	}

}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/PuppyEditor/EditorHelper.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/CallbackManager.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 82a67790066696745bdebd45b38f9c82
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System;
using System.Collections.Generic;
using UnityEditor;

namespace MarkupAttributes.Editor
{
    public enum CallbackEvent
    {
        BeforeProperty,
        ReplaceProperty,
        AfterProperty
    }

    internal class CallbackManager
    {
        private readonly bool usedByShaderGUI;
        private readonly SerializedProperty[] properties;
        private readonly MaterialPropertiesWrapper materialProperties;
        private readonly MaterialEditor materialEditor;

        private readonly Dictionary<string, int> propertyIndices = new Dictionary<string, int>();
        private readonly Dictionary<(int, CallbackEvent), Action<SerializedProperty>> callbacks;
        private readonly Dictionary<(int, CallbackEvent), Action<MaterialEditor, MaterialProperty[], MaterialProperty>> shaderGuiCallbacks;

        public CallbackManager(SerializedProperty[] props)
        {
            properties = props;
            callbacks = new Dictionary<(int, CallbackEvent), Action<SerializedProperty>>();
            for (int i = 0; i < props.Length; i++)
            {
                if (!propertyIndices.ContainsKey(props[i].name))
                    propertyIndices.Add(props[i].name, i);
            }
        }

        public CallbackManager(MaterialEditor materialEditor, MaterialPropertiesWrapper materialProperties)
        {
            usedByShaderGUI = true;
            this.materialEditor = materialEditor;
            this.materialProperties = materialProperties;
            shaderGuiCallbacks = new Dictionary<(int, CallbackEvent), Action<MaterialEditor, MaterialProperty[], MaterialProperty>>();
            for (int i = 0; i < materialProperties.value.Length; i++)
            {
                if (!propertyIndices.ContainsKey(materialProperties.value[i].name))
                    propertyIndices.Add(materialProperties.value[i].name, i);
            }
        }

        public void AddCallback(SerializedProperty property, CallbackEvent callbackType, 
            Action<SerializedProperty> action)
        {
            if (propertyIndices.ContainsKey(property.name))
            {
                var key = (propertyIndices[property.name], callbackType);
                if (callbacks.ContainsKey(key))
                {
                    UnityEngine.Debug.LogError("Callback for property " + property.name +
                        " with type " + callbackType.ToString() + " already exists.");
                }
                else
                {
                    callbacks.Add(key, action);
                }
            }
        }

        public void AddCallback(MaterialProperty property, CallbackEvent callbackType,
            Action<MaterialEditor, MaterialProperty[], MaterialProperty> action)
        {

            if (propertyIndices.ContainsKey(property.name))
            {
                var key = (propertyIndices[property.name], callbackType);
                if (shaderGuiCallbacks.ContainsKey(key))
                {
                    UnityEngine.Debug.LogError("Callback for property " + property.name +
                        " with type " + callbackType.ToString() + " already exists.");
                }
                else
                {
                    shaderGuiCallbacks.Add(key, action);
                }
            }
        }

        public bool InvokeCallback(int index, CallbackEvent hookType)
        {
            var id = (index, hookType);
            if (!usedByShaderGUI)
            {
                if (callbacks.ContainsKey(id))
                {
                    callbacks[id].Invoke(properties[index]);
                    return true;
                }
            }
            else
            {
                if (shaderGuiCallbacks.ContainsKey(id))
                {
                    shaderGuiCallbacks[id].Invoke(materialEditor, 
                        materialProperties.value, materialProperties.value[index]);
                    return true;
                }
            }
            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/CallbackManager.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/ConditionWrapper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 818db179e4cec2b43ba9f373f3ddda24
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEditor;
using UnityEngine;

namespace MarkupAttributes.Editor
{
    internal class ConditionWrapper
    {
        private readonly bool alwaysTrue;
        private readonly bool alwaysFalse;
        private readonly bool inverted;

        private readonly TargetObjectWrapper targetObjectWrapper;
        private readonly FieldInfo fieldInfo;
        private readonly PropertyInfo propertyInfo;
        private readonly MethodInfo methodInfo;
        private readonly object memberValue;
        private readonly bool hasMemberValue;

        private readonly int materialPropertyIndex;
        private readonly Material targetMaterial;
        private readonly string shaderKeyword;
        private readonly bool isShaderKeywordGlobal;
        private readonly MaterialPropertiesWrapper materialProperties;

        public static ConditionWrapper Create(ConditionDescriptor descriptor, TargetObjectWrapper targetObjectWrapper)
        {
            if (descriptor.fixedValue.HasValue)
                return new ConditionWrapper(descriptor.fixedValue.Value);

            if (targetObjectWrapper != null && targetObjectWrapper.Target != null)
            {
                object targetObject = targetObjectWrapper.Target;
                Type type = targetObject.GetType();

                FieldInfo fieldInfo = type.GetField(descriptor.memberName, MarkupEditorUtils.DefaultBindingFlags);
                if (fieldInfo != null)
                {
                    if (IsConditionValid(fieldInfo.FieldType, descriptor))
                        return new ConditionWrapper(descriptor.isInverted, targetObjectWrapper, fieldInfo, null, null, descriptor.value, descriptor.hasValue);
                }

                PropertyInfo propertyInfo = type.GetProperty(descriptor.memberName, MarkupEditorUtils.DefaultBindingFlags);
                if (propertyInfo != null)
                {
                    if (IsConditionValid(propertyInfo.PropertyType, descriptor))
                        return new ConditionWrapper(descriptor.isInverted, targetObjectWrapper, null, propertyInfo, null, descriptor.value, descriptor.hasValue);
                }

                MethodInfo methodInfo = type.GetMethod(descriptor.memberName, MarkupEditorUtils.DefaultBindingFlags);
                if (methodInfo != null && methodInfo.GetParameters().Length == 0)
                {
                    if (IsConditionValid(methodInfo.ReturnType, descriptor))
                        return new ConditionWrapper(descriptor.isInverted, targetObjectWrapper, null, null, methodInfo, descriptor.value, descriptor.hasValue);
                }
            }
            return null;
        }

        public static ConditionWrapper Create(ConditionDescriptor descriptor, 
            MaterialPropertiesWrapper materialProperties, Material targetMaterial)
        {
            if (descriptor.fixedValue.HasValue)
                return new ConditionWrapper(descriptor.fixedValue.Value);

            var props = materialProperties.value;
            for (int i = 0; i < props.Length; i++)
            {
                var materialProperty = props[i];
                if ((materialProperty.propertyType == UnityEngine.Rendering.ShaderPropertyType.Float
                                    || materialProperty.propertyType == UnityEngine.Rendering.ShaderPropertyType.Range)
                                    && materialProperty.name == descriptor.memberName)
                {
                    return new ConditionWrapper(descriptor.isInverted, i, materialProperties,
                        null, null, false);
                }
            }

            string keyword = ShaderAttributesParser.GetKeyword(descriptor.memberName, out bool isGlobal);
            return new ConditionWrapper(descriptor.isInverted, -1, null, targetMaterial, keyword, isGlobal);
        }

        private ConditionWrapper(bool inverted, TargetObjectWrapper targetObjectWrapper, 
            FieldInfo fieldInfo, PropertyInfo propertyInfo, MethodInfo methodInfo, object memberValue, bool hasValue)
        {
            this.inverted = inverted;
            this.targetObjectWrapper = targetObjectWrapper;
            this.fieldInfo = fieldInfo;
            this.propertyInfo = propertyInfo;
            this.methodInfo = methodInfo;
            this.memberValue = memberValue;
            this.hasMemberValue = hasValue;
        }

        private ConditionWrapper(bool inverted, int materialPropertyIndex, 
            MaterialPropertiesWrapper materialPropertiesWrapper,
            Material targetMaterial, string shaderKeyword, bool isShaderKeywordGlobal)
        {
            this.inverted = inverted;
            this.materialPropertyIndex = materialPropertyIndex;
            this.materialProperties = materialPropertiesWrapper;
            this.targetMaterial = targetMaterial;
            this.shaderKeyword = shaderKeyword;
            this.isShaderKeywordGlobal = isShaderKeywordGlobal;
        }

        private ConditionWrapper(bool value)
        {
            if (value)
                alwaysTrue = true;
            else
                alwaysFalse = false;
        }

        public bool GetValue()
        {
            if (alwaysTrue) return true;
            if (alwaysFalse) return false;

            object target = null;
            if (targetObjectWrapper != null)
                target = targetObjectWrapper.Target;

            if (target != null)
            {
                if (fieldInfo != null)
                    return FromMemberValue(fieldInfo.GetValue(target));

                if (propertyInfo != null)
                    return FromMemberValue(propertyInfo.GetValue(target));

                if (methodInfo != null)
                    return FromMemberValue(methodInfo.Invoke(target, null));
            }

            if (materialProperties != null)
            {
                return (materialProperties.value[materialPropertyIndex].floatValue > 0) ^ inverted;
            }

            if (isShaderKeywordGlobal && shaderKeyword != null)
            {
                return Shader.IsKeywordEnabled(shaderKeyword) ^ inverted;
            }

            if (targetMaterial != null && shaderKeyword != null)
            {
                return targetMaterial.IsKeywordEnabled(shaderKeyword) ^ inverted;
            }

            return false;
        }

        private bool FromMemberValue(object value)
        {
            if (hasMemberValue)
                return value.Equals(memberValue) ^ inverted;
            else
                return (bool)value ^ inverted;
        }

        private static bool IsConditionValid(Type type, ConditionDescriptor descriptor) =>
            type == typeof(bool) || descriptor.hasValue;
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/ConditionWrapper.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/EditorLayoutDataBuilder.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b1e629edeb5d2754c8204c94ebe7f259
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEditor;

namespace MarkupAttributes.Editor
{
    internal class InlineEditorData
    {
        public UnityEditor.Editor editor;
        public InlineEditorMode mode;
        public bool enabled = true;

        public InlineEditorData(UnityEditor.Editor editor, InlineEditorAttribute attribute)
        {
            this.editor = editor;
            mode = attribute.Mode;
        }
    }

    internal static class EditorLayoutDataBuilder
    {
        public static void BuildLayoutData(SerializedObject serializedObject,
            out SerializedProperty[] allProps,
            out SerializedProperty[] topLevelProps,
            out List<PropertyLayoutData> layoutData,
            out Dictionary<SerializedProperty, InlineEditorData> inlineEditors,
            out List<TargetObjectWrapper> targetsRequireUpdate)
        {
            var props = new List<SerializedProperty>();
            layoutData = new List<PropertyLayoutData>();
            inlineEditors = new Dictionary<SerializedProperty, InlineEditorData>();
            targetsRequireUpdate = new List<TargetObjectWrapper>();
            Type targetType = serializedObject.targetObject.GetType();

            topLevelProps = MarkupEditorUtils.GetSerializedObjectProperties(serializedObject);
            GetLayoutDataForSiblings(null, topLevelProps, targetType, 
                new TargetObjectWrapper(serializedObject.targetObject),
                props, layoutData, inlineEditors, targetsRequireUpdate);
            allProps = props.ToArray();
        }

        private static int GetLayoutDataForSiblings(InspectorLayoutGroup scopeGroup,
            SerializedProperty[] siblings, Type targetType, TargetObjectWrapper targetObjectWrapper,
            List<SerializedProperty> allProps, List<PropertyLayoutData> layoutData,
            Dictionary<SerializedProperty, InlineEditorData> inlineEditors, List<TargetObjectWrapper> targetObjectWrappers)
        {
            int scopesToClose = 0;
            for (int i = 0; i < siblings.Length; i++)
            {
                var sibling = siblings[i];
                var groups = new List<InspectorLayoutGroup>();
                if (scopeGroup != null && i == 0)
                {
                    groups.Add(scopeGroup);
                }

                FieldInfo fieldInfo = targetType.GetField(sibling.name, MarkupEditorUtils.DefaultBindingFlags);

                PropertyLayoutData data = null;
                if (fieldInfo != null)
                {
                    // layout groups
                    var groupAttribues = fieldInfo.GetCustomAttributes<LayoutGroupAttribute>(true).ToArray();

                    bool isPropertyHidden = false;
                    foreach (var groupAttribute in groupAttribues)
                    {
                        var group = CreateGroupFromAttribute(ref isPropertyHidden, 
                            groupAttribute, sibling, targetObjectWrapper);
                        groups.Add(group);
                    }

                    // conditionals 
                    var hideConditions = new List<ConditionWrapper>();
                    foreach (var attribute in fieldInfo.GetCustomAttributes<HideIfAttribute>())
                    {
                        hideConditions.Add(ConditionWrapper.Create(attribute.Condition, targetObjectWrapper));
                    }

                    var disableConditions = new List<ConditionWrapper>();
                    foreach (var attribute in fieldInfo.GetCustomAttributes<DisableIfAttribute>())
                    {
                        disableConditions.Add(ConditionWrapper.Create(attribute.Condition, targetObjectWrapper));
                    }

                    var end = fieldInfo.GetCustomAttribute<EndGroupAttribute>();
                    data = new PropertyLayoutData(groups, hideConditions, disableConditions, end);
                    data.alwaysHide = isPropertyHidden;
                    data.isTopLevel = scopeGroup == null;
                    data.numberOfScopesToClose = scopesToClose;
                    scopesToClose = 0;
                    

                    // InlineEditors
                    var inline = fieldInfo.GetCustomAttribute<InlineEditorAttribute>();
                    if (inline != null)
                        inlineEditors.Add(sibling, new InlineEditorData(null, inline));
                }

                allProps.Add(sibling);
                layoutData.Add(data);

                // Nested properties
                if (sibling.propertyType == SerializedPropertyType.Generic
                    && fieldInfo != null)
                {
                    var markedUp = fieldInfo.GetCustomAttribute<MarkedUpTypeAttribute>();
                    if (markedUp == null)
                        markedUp = fieldInfo.FieldType.GetCustomAttribute<MarkedUpTypeAttribute>(true);

                    if (markedUp != null)
                    {
                        var subTarget = MarkupEditorUtils.GetTargetObjectOfProperty(sibling);
                        var subTargetType = subTarget.GetType();
                        var subTargetWrapper = new TargetObjectWrapper(subTarget, sibling);
                        if (subTargetType.IsValueType)
                            targetObjectWrappers.Add(subTargetWrapper);
                        if (subTargetType != targetType)
                        {
                            var children = MarkupEditorUtils.GetChildrenOfProperty(sibling).ToArray();
                            if (children != null && children.Length > 0)
                            {
                                data.includeChildren = false;
                                data.alwaysHide |= !markedUp.ShowControl;
                                var subScopeGroup = InspectorLayoutGroup.CreateScopeGroup(
                                    "./" + sibling.name, sibling, subTargetType.FullName, 
                                    markedUp.ShowControl, markedUp.IndentChildren);
                                scopesToClose += GetLayoutDataForSiblings(
                                    subScopeGroup, children, subTargetType, subTargetWrapper, 
                                    allProps, layoutData, inlineEditors, targetObjectWrappers);
                                scopesToClose += 1;
                            }
                        }
                    }
                }
            }
            return scopesToClose;
        }

        private static InspectorLayoutGroup CreateGroupFromAttribute(ref bool isHidden,
            LayoutGroupAttribute attribute, SerializedProperty property, TargetObjectWrapper targetObjectWrapper)
        {
            ConditionWrapper conditionWrapper = null;
            if (attribute.HasCondition)
            {
                conditionWrapper = ConditionWrapper.Create(attribute.Condition, targetObjectWrapper);
                if (conditionWrapper == null)
                    return null;
            }

            TogglableValueWrapper togglableValueWrapper = null;
            if (attribute.Toggle)
            {
                togglableValueWrapper = TogglableValueWrapper.Create(property);
                if (togglableValueWrapper == null)
                    return null;
                isHidden = true;
            }

            return new InspectorLayoutGroup(attribute, conditionWrapper, togglableValueWrapper);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/EditorLayoutDataBuilder.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/HeaderlessMaterialEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 3c2fabac705015648a641e96f00af8fc
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using UnityEditor;
using UnityEditorInternal;

namespace MarkupAttributes.Editor
{
    internal class HeaderlessMaterialEditor : MaterialEditor
    {
        protected override void OnHeaderGUI()
        {
            InternalEditorUtility.SetIsInspectorExpanded(target, true);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/HeaderlessMaterialEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/InspectorLayoutController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 0219c6840910b53418ee2e1185a2773c
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace MarkupAttributes.Editor
{
    internal class InspectorLayoutController
    {
        public bool IncludeChildren(int index) => layoutData[index] == null || layoutData[index].includeChildren;
        public bool IsPropertyVisible(int index) => layoutData[index] == null || layoutData[index].IsVisible();
        public bool IsPropertyEnabled(int index) => layoutData[index] == null || layoutData[index].IsEnabled();

        public bool IsTopLevel(int index) => layoutData[index] == null || layoutData[index].isTopLevel;
        public bool ScopeEnabled => groupsStack.Count == 0 || groupsStack.Peek().isEnabled;
        public bool ScopeVisible => groupsStack.Count == 0 || groupsStack.Peek().isVisible;
        
        private readonly string defaultPrefsPrefix;
        private readonly PropertyLayoutData[] layoutData;
        private readonly Stack<InspectorLayoutGroup> groupsStack = new Stack<InspectorLayoutGroup>();
        private List<string> currentPath = new List<string>();
        private string prefsPrefix = null;
        private int localScopeStart = -1;
        private string activeTabName;

        public InspectorLayoutController(string prefsPrefix, PropertyLayoutData[] layoutData)
        {
            defaultPrefsPrefix = prefsPrefix;
            this.layoutData = layoutData;
        }

        public void Begin()
        {
            groupsStack.Clear();
            currentPath.Clear();
            prefsPrefix = defaultPrefsPrefix;
            localScopeStart = -1;
            activeTabName = null;
        }

        public void Finish()
        {
            EndAll();
        }

        public void BeforeProperty(int index)
        {
            var layout = layoutData[index];
            if (layout == null) return;

            if (layout.end != null)
            {
                EndGroupsUntill(layout.end.GroupName);
            }

            for (int i = 0; i < layout.numberOfScopesToClose; i++)
            {
                EndLocalScope();
            }

            if (layout.groups == null)
                return;

            foreach (var group in layout.groups)
            {
                SetScope(group.pathArray);
                bool isVisible = ScopeVisible;
                bool isEnabled = ScopeEnabled;

                if (group.data.Type == LayoutGroupType.LocalScope)
                {
                    group.cachedLocalScopeStart = localScopeStart;
                    localScopeStart = groupsStack.Count;
                }

                if (ScopeVisible)
                {
                    BeginGroup(group, ref isVisible, ref isEnabled);
                }

                group.isVisible = isVisible;
                group.isEnabled = isEnabled;
                groupsStack.Push(group);
            }
        }

        private void BeginGroup(InspectorLayoutGroup group, ref bool isVisible, ref bool isEnabled)
        {
            if (group.data.Space > 0)
                GUILayout.Space(group.data.Space);

            if (group.data.Type == LayoutGroupType.LocalScope)
            {
                group.guiHandle = new MarkupGUI.GroupHandle(false, false);
                if (group.localScope.indent)
                    EditorGUI.indentLevel += 1;
                isVisible &= !group.localScope.showControl || group.localScope.IsExpanded;
                group.cachedPrefsPrefix = prefsPrefix;
                prefsPrefix = group.localScope.prefsPrefixOverride;
            }

            if (group.data.Type == LayoutGroupType.DisableIf)
            {
                isEnabled &= !group.data.conditionWrapper.GetValue();
            }

            if (group.data.Type == LayoutGroupType.HideIf)
            {
                isVisible &= !group.data.conditionWrapper.GetValue();
            }

            if (group.data.Type == LayoutGroupType.Tab)
            {
                isVisible &= (activeTabName == null || activeTabName == group.name);
            }

            if (group.data.Type == LayoutGroupType.TabScope)
            {
                bool boxed = group.data.BodyStyle == MarkupBodyStyle.Box;
                string prefsName = GetPrefsName();
                int activeTab = MarkupAttributesPrefs.GetInt(prefsName);
                group.guiHandle = MarkupGUI.BeginTabsGroup(ref activeTab, group.data.Tabs, boxed);
                MarkupAttributesPrefs.SetInt(prefsName, activeTab);
                group.cachedActiveTab = activeTabName;
                activeTabName = group.data.Tabs[activeTab];
            }

            if (group.data.Type == LayoutGroupType.Horizontal)
            {
                group.guiHandle = new MarkupGUI.GroupHandle(false, true);
                EditorGUIUtility.labelWidth = group.data.LabelWidth;
                EditorGUILayout.BeginHorizontal(GUIStyle.none);
            }

            if (group.data.Type == LayoutGroupType.Vertical)
            {
                string prefsName = GetPrefsName();
                bool isExpanded = MarkupAttributesPrefs.GetBool(prefsName);

                group.guiHandle = MarkupGUI.BeginGenericVerticalGroup(
                    ref isExpanded, ref isEnabled,
                    group.data.HeaderStyle, group.data.BodyStyle, group.name,
                    group.data.togglableValueWrapper);

                MarkupAttributesPrefs.SetBool(prefsName, isExpanded);
                isVisible &= isExpanded;
            }
        }
        
        private string GetPrefsName()
        {
            if (prefsPrefix != null)
            {
                return prefsPrefix + "/" + string.Join("/", currentPath.ToArray(),
                    localScopeStart + 1, currentPath.Count - localScopeStart - 1);
            }
            else
            {
                return defaultPrefsPrefix + "/" + string.Join("/", currentPath);
            }
        }

        private void SetScope(string[] path)
        {
            if (path == null || path.Length < 1)
            {
                EndAll();
                currentPath.Add("");
                return;
            }

            if (path.Length > 1 && (path[0] == "." || path[0] == ".."))
            {
                if (currentPath.Count > 0 && path[0] == "..")
                {
                    EndGroup();
                }
                currentPath.Add(path.Last());
                return;
            }

            var newPath = new List<string>();
            int i = 0;
            int j = 0;
            while (j < path.Length && i < currentPath.Count)
            {
                if (i <= localScopeStart)
                {
                    newPath.Add(currentPath[i]);
                }
                else
                {
                    if (path[j] != currentPath[i])
                    {
                        break;
                    }
                    newPath.Add(path[j]);
                    j++;
                }
                i++;
            }

            if (j < path.Length)
                newPath.Add(path.Last());

            int groupsToRemove = currentPath.Count - i;
            for (int k = 0; k < groupsToRemove; k++)
            {
                EndGroup();
            }

            currentPath = newPath;
        }

        private void EndGroupsUntill(string name)
        {
            int limit = name != null ? -1 :
                Mathf.Max(-1, currentPath.Count - 2);
            limit = Mathf.Max(limit, localScopeStart);
            int index = currentPath.Count - 1;
            while (index > limit)
            {
                if (currentPath[index] != name)
                {
                    EndGroup();
                    index -= 1;
                }
                else
                {
                    EndGroup();
                    break;
                }     
            }
        }

        private void EndLocalScope()
        {
            int count = localScopeStart;
            while (groupsStack.Count > count)
            {
                EndGroup();
            }
        }

        private void EndAll()
        {
            while (groupsStack.Count > 0)
            {
                EndGroup();
            }
        }

        private void EndGroup()
        {
            if (groupsStack.Count > 0)
            {
                InspectorLayoutGroup group = groupsStack.Pop();
                if (currentPath.Count > 0)
                    currentPath.RemoveAt(currentPath.Count - 1);

                if (group.cachedLocalScopeStart.HasValue)
                    localScopeStart = group.cachedLocalScopeStart.Value;
                if (ScopeVisible)
                {
                    if (group.cachedPrefsPrefix != null)
                        prefsPrefix = group.cachedPrefsPrefix;

                    if (group.cachedActiveTab != null)
                        activeTabName = group.cachedActiveTab;

                    if (group.guiHandle.HasValue)
                        group.guiHandle.Value.End();

                    group.cachedPrefsPrefix = null;
                    group.cachedActiveTab = null;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/InspectorLayoutController.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/InspectorLayoutGroup.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 397caf8001d83484daf9dfdcadbd4f62
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System.Linq;
using UnityEditor;

namespace MarkupAttributes.Editor
{
    internal class InspectorLayoutGroup
    {
        public readonly Params data;
        public readonly string[] pathArray;
        public readonly string name;
        public readonly LocalScopeData localScope;
        public bool isVisible;
        public bool isEnabled;
        public string cachedPrefsPrefix = null;
        public int? cachedLocalScopeStart = null;
        public string cachedActiveTab = null;
        public MarkupGUI.GroupHandle? guiHandle;

        public int Order()
        {
            if (data.Type == LayoutGroupType.LocalScope)
                return pathArray.Length - 1000;
            if (pathArray.Length > 0 && (pathArray[0] == "." || pathArray[0] == ".."))
                return pathArray.Length + 1000;
            return pathArray.Length;
        }

        public static InspectorLayoutGroup CreateScopeGroup(string path, 
            SerializedProperty property, string prefsPrefix,
            bool showControl, bool indent)
        {
            return new InspectorLayoutGroup(path, 
                new LocalScopeData(property, prefsPrefix, showControl, indent));
        }

        public InspectorLayoutGroup(LayoutGroupAttribute attribute, ConditionWrapper conditionWrapper = null, 
            TogglableValueWrapper togglableValueWrapper = null)
        {
            data = new Params(attribute, conditionWrapper, togglableValueWrapper);
            SetNameAndPathArray(attribute.Path, out pathArray, out name);
        }

        private InspectorLayoutGroup(string path, LocalScopeData scopeData)
        {
            data = new Params(path, LayoutGroupType.LocalScope);
            localScope = scopeData;
            SetNameAndPathArray(path, out pathArray, out name);
        }

        private void SetNameAndPathArray(string path, 
            out string[] pathArray, out string name)
        {
            if (path != null)
            {
                pathArray = path.Split('/');
                if (pathArray.Length > 0)
                    name = pathArray.Last();
                else
                    name = "";
            }
            else
            {
                pathArray = new string[0];
                name = "";
            }
        }

        public class Params
        {
            public string Path => path;
            public LayoutGroupType Type => type;
            public MarkupHeaderFlags HeaderStyle => headerStyle;
            public MarkupBodyStyle BodyStyle => bodyStyle;
            public float LabelWidth => labelWidth;
            public float Space => space;
            public string[] Tabs => tabs;

            public readonly ConditionWrapper conditionWrapper;
            public readonly TogglableValueWrapper togglableValueWrapper;
            private readonly string path;
            private readonly LayoutGroupType type;
            private readonly MarkupHeaderFlags headerStyle;
            private readonly MarkupBodyStyle bodyStyle;
            private readonly float labelWidth;
            private readonly float space;
            private readonly string[] tabs;

            public Params(LayoutGroupAttribute attribute, ConditionWrapper conditionWrapper,
                TogglableValueWrapper togglableValueWrapper)
            {
                path = attribute.Path;
                type = attribute.Type;
                headerStyle = attribute.HeaderFlags;
                bodyStyle = attribute.BodyStyle;
                labelWidth = attribute.LabelWidth;
                space = attribute.Space;
                tabs = attribute.Tabs;
                this.conditionWrapper = conditionWrapper;
                this.togglableValueWrapper = togglableValueWrapper;
            }

            public Params(string path, LayoutGroupType type)
            {
                this.path = path;
                this.type = type;
            }
        }

        public class LocalScopeData
        {
            public readonly bool showControl;
            public readonly bool indent;
            public readonly string prefsPrefixOverride;
            private readonly SerializedProperty serializedProperty;
            public bool IsExpanded => serializedProperty.isExpanded;

            public LocalScopeData(SerializedProperty property, string prefsPrefix, bool showControl, bool indent)
            {
                serializedProperty = property;
                prefsPrefixOverride = prefsPrefix;
                this.showControl = showControl;
                this.indent = indent;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/InspectorLayoutGroup.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkedUpEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 62168cb1e92a5494b89909fd2443875b
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace MarkupAttributes.Editor
{
    [CanEditMultipleObjects]
    public class MarkedUpEditor : UnityEditor.Editor
    {
        private SerializedProperty[] allProps;
        private SerializedProperty[] firstLevelProps;
        private List<PropertyLayoutData> layoutData;

        private InspectorLayoutController layoutController;
        private CallbackManager callbackManager;
        private Dictionary<SerializedProperty, InlineEditorData> inlineEditors;
        private List<TargetObjectWrapper> targetsRequireUpdate;

        protected virtual void OnInitialize() { }
        protected virtual void OnCleanup() { }
        protected void AddCallback(SerializedProperty property, CallbackEvent type, Action<SerializedProperty> callback)
        {
            callbackManager.AddCallback(property, type, callback);
        }

        protected void OnEnable()
        {
            InitializeMarkedUpEditor();
        }

        protected void OnDisable()
        {
            CleanupMarkedUpEditor();
        }

        public override void OnInspectorGUI()
        {
            DrawMarkedUpInspector();
        }

        protected void InitializeMarkedUpEditor()
        {
            EditorLayoutDataBuilder.BuildLayoutData(serializedObject, out allProps, 
                out firstLevelProps, out layoutData, out inlineEditors, out targetsRequireUpdate);
            layoutController = new InspectorLayoutController(target.GetType().FullName,
                layoutData.ToArray());
            callbackManager = new CallbackManager(firstLevelProps);
            OnInitialize();
        }

        protected void CleanupMarkedUpEditor()
        {
            OnCleanup();
            foreach (var item in inlineEditors)
            {
                DestroyImmediate(item.Value.editor);
            }
        }

        protected bool DrawMarkedUpInspector()
        {
            EditorGUI.BeginChangeCheck();
            serializedObject.UpdateIfRequiredOrScript();

            CreateInlineEditors();
            UpdateTargets();
            int topLevelIndex = 1;
            layoutController.Begin();

            if (!MarkupGUI.IsInsideInlineEditor)
            {
                using (new EditorGUI.DisabledScope(true))
                {
                    EditorGUILayout.PropertyField(allProps[0]);
                }
            }

            for (int i = 1; i < allProps.Length; i++)
            {
                layoutController.BeforeProperty(i);
                if (layoutController.ScopeVisible)
                {
                    using (new EditorGUI.DisabledScope(!layoutController.ScopeEnabled))
                    {
                        DrawProperty(i, topLevelIndex);
                    }
                }

                if (layoutController.IsTopLevel(i))
                    topLevelIndex += 1;
            }
            layoutController.Finish();

            serializedObject.ApplyModifiedProperties();
            return EditorGUI.EndChangeCheck();
        }

        private void DrawProperty(int index, int topLevelIndex)
        {
            var prop = allProps[index];
            bool topLevel = layoutController.IsTopLevel(index);

            if (topLevel) callbackManager.InvokeCallback(topLevelIndex, CallbackEvent.BeforeProperty);
            

            using (new EditorGUI.DisabledScope(!layoutController.IsPropertyEnabled(index)))
            {
                if (layoutController.IsPropertyVisible(index))
                {
                    if (!topLevel || !callbackManager.InvokeCallback(index, CallbackEvent.ReplaceProperty))
                    {
                        if (inlineEditors.ContainsKey(prop))
                        {
                            InlineEditorData data = inlineEditors[prop];
                            MarkupGUI.DrawEditorInline(prop, data.editor, data.mode, data.enabled);
                        }
                        else
                        {
                            EditorGUILayout.PropertyField(prop, layoutController.IncludeChildren(index));
                        }
                    }
                }
            }
            if (topLevel) callbackManager.InvokeCallback(topLevelIndex, CallbackEvent.AfterProperty);
        }

        private void CreateInlineEditors()
        {
            var props = new List<SerializedProperty>(inlineEditors.Keys);
            foreach (var prop in props)
            {
                var editor = inlineEditors[prop].editor;

                if (prop.objectReferenceValue != serializedObject.targetObject)
                {
                    Material material = prop.objectReferenceValue as Material;
                    if (material != null)
                    {
                        CreateCachedEditor(material, typeof(HeaderlessMaterialEditor), ref editor);
                        inlineEditors[prop].enabled = AssetDatabase.GetAssetPath(material).StartsWith("Assets");
                    }
                    else
                        CreateCachedEditor(prop.objectReferenceValue, null, ref editor);
                }
                else
                {
                    editor = null;
                    prop.objectReferenceValue = null;
                    Debug.LogError("Self reference in the InlinedEditor property is not allowed.");
                }

                
                inlineEditors[prop].editor = editor;
            }
        }

        private void UpdateTargets()
        {
            foreach (var wrapper in targetsRequireUpdate)
            {
                wrapper.Update();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkedUpEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkedUpShaderGUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 4b7102832313cd84c92c9ea75e82aa04
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using UnityEngine;
using UnityEditor;
using System;

namespace MarkupAttributes.Editor
{
    [CanEditMultipleObjects()]
    public class MarkedUpShaderGUI : ShaderGUI
    {
        private static MaterialEditor currentEditor;
        private static MaterialPropertiesWrapper materialPropertiesWrapper;
        private static string[][] allAttributes;
        private static InspectorLayoutController layoutController;
        private static CallbackManager callbackManager;
        private static Shader shader;
        private static Material material;
        private static int systemPropertiesIndex;

        protected virtual void OnInitialize(MaterialEditor materialEditor, MaterialProperty[] properties) { }

        protected void AddCallback(MaterialProperty property, CallbackEvent type, 
            Action<MaterialEditor, MaterialProperty[], MaterialProperty> callback)
        {
            callbackManager.AddCallback(property, type, callback);
        }

        public override void OnGUI(MaterialEditor materialEditor, MaterialProperty[] properties)
        {
            Initialize(materialEditor, properties);

            layoutController.Begin();
            for (int i = 0; i < properties.Length; i++)
            {
                layoutController.BeforeProperty(i);
                
                if (layoutController.ScopeVisible && layoutController.IsPropertyVisible(i))
                {
                    callbackManager.InvokeCallback(i, CallbackEvent.BeforeProperty);
                    using (new EditorGUI.DisabledScope(
                        !layoutController.ScopeEnabled || !layoutController.IsPropertyEnabled(i)))
                    {
                        if (!callbackManager.InvokeCallback(i, CallbackEvent.ReplaceProperty))
                            DrawProperty(materialEditor, properties[i]);
                    }
                    callbackManager.InvokeCallback(i, CallbackEvent.AfterProperty);

                    if (i == systemPropertiesIndex)
                    {
                        EditorGUILayout.Space();
                        DrawSystemProperties(materialEditor);
                    }

                }
            }
            layoutController.Finish();
        }

        private void Initialize(MaterialEditor materialEditor, MaterialProperty[] properties)
        {
            if (currentEditor == materialEditor && allAttributes != null
                && properties.Length == materialPropertiesWrapper.value.Length)
            {
                materialPropertiesWrapper.value = properties;
                return;
            }

            material = (Material)materialEditor.target;
            shader = material.shader;
            currentEditor = materialEditor;
            allAttributes = GetAttributes(shader, properties.Length);
            materialPropertiesWrapper = new MaterialPropertiesWrapper();
            materialPropertiesWrapper.value = properties;
            layoutController = new InspectorLayoutController(shader.name,
                ShaderAttributesParser.GetLayoutData(allAttributes, materialPropertiesWrapper, material));
            callbackManager = new CallbackManager(materialEditor, materialPropertiesWrapper);
            systemPropertiesIndex = ShaderAttributesParser.GetDrawSystemPropertiesAttribute(allAttributes);
            
            OnInitialize(materialEditor, properties);
        }

        private string[][] GetAttributes(Shader shader, int propsCount)
        {
            var output = new string[propsCount][];
            for (int i = 0; i < propsCount; i++)
            {
                output[i] = shader.GetPropertyAttributes(i);
            }
            return output;
        }

        private void DrawProperty(MaterialEditor editor, MaterialProperty prop)
        {
            if (prop.propertyFlags.HasFlag(UnityEngine.Rendering.ShaderPropertyFlags.HideInInspector))
                return;
            bool hierarchyMode = EditorGUIUtility.hierarchyMode;
            if (prop.propertyType == UnityEngine.Rendering.ShaderPropertyType.Range)
                EditorGUIUtility.hierarchyMode = true;
            editor.ShaderProperty(prop, MakeLabel(prop));
            EditorGUIUtility.hierarchyMode = hierarchyMode;
        }

        private void DrawSystemProperties(MaterialEditor materialEditor)
        {
            materialEditor.RenderQueueField();
            materialEditor.EnableInstancingField();
            materialEditor.DoubleSidedGIField();
        }

        private static GUIContent TempLabel = new GUIContent();
        private static GUIContent MakeLabel(MaterialProperty property, string tooltip = null)
        {
            TempLabel.text = property.displayName;
            TempLabel.tooltip = tooltip;
            return TempLabel;
        }

        
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkedUpShaderGUI.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupAttributesPrefs.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: da0d25574c33ac64d98db1c615ce7ff9
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace MarkupAttributes.Editor
{
    internal class MarkupAttributesPrefs : ScriptableObject
    {
        private static MarkupAttributesPrefs instance;
        private static MarkupAttributesPrefs Instance
        {
            get
            {
                if (instance == null)
                {
                    var guids = AssetDatabase.FindAssets(
                        string.Format("t:{0}", typeof(MarkupAttributesPrefs)));

                    MarkupAttributesPrefs asset = null;
                    for (int i = 0; i < guids.Length; i++)
                    {
                        string path = AssetDatabase.GUIDToAssetPath(guids[i]);
                        asset = AssetDatabase.LoadAssetAtPath<MarkupAttributesPrefs>(path);
                        if (asset != null) break;
                    }
                    if (asset == null)
                    {
                        asset = CreateInstance<MarkupAttributesPrefs>();
                        if (!AssetDatabase.IsValidFolder("Assets/Editor"))
                            AssetDatabase.CreateFolder("Assets", "Editor");
                        AssetDatabase.CreateAsset(asset, "Assets/Editor/MarkupAttributesPersistentData.asset");
                        AssetDatabase.SaveAssets();
                    }

                    instance = asset;
                    SerializedObject so = new SerializedObject(instance);
                    instance.boolsHandler =
                        new SerializedDictionaryHandler(so.FindProperty("serializedBoolEntries"));
                    instance.intsHandler =
                        new SerializedDictionaryHandler(so.FindProperty("serializedIntEntries"));
                }
                return instance;
            }
        }

        public static bool GetBool(string key, bool defaultValue = false)
        {
            return Instance.boolsHandler.GetBool(key, defaultValue);
        }
        public static void SetBool(string key, bool value)
        {
            Instance.boolsHandler.SetBool(key, value);
        }
        public static int GetInt(string key, int defaultValue = 0)
        {
            return Instance.boolsHandler.GetInt(key, defaultValue);
        }
        public static void SetInt(string key, int value)
        {
            Instance.boolsHandler.SetInt(key, value);
        }

        public static void DeleteAll()
        {
            Instance.boolsHandler.DeleteAll();
            Instance.intsHandler.DeleteAll();
        }

        private SerializedDictionaryHandler boolsHandler;
        private SerializedDictionaryHandler intsHandler;

        [NonReorderable]
        [SerializeField] private BoolEntry[] serializedBoolEntries;
        [NonReorderable]
        [SerializeField] private IntEntry[] serializedIntEntries;

        [System.Serializable]
        private class BoolEntry
        {
            public string key;
            public bool value;
        }

        [System.Serializable]
        private class IntEntry
        {
            public string key;
            public int value;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupAttributesPrefs.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupAttributesPrefsEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d25dab21600856347aceaf6e44131ea6
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace MarkupAttributes.Editor
{
    [CustomEditor(typeof(MarkupAttributesPrefs))]
    internal class MarkupAttributesPrefsEditor : UnityEditor.Editor
    {
        string message = "Hi! I am a file that keeps data about " +
            "selected tabs, expanded foldouts and things like that for " +
            "MarkupAttributes.\n" +
            "1. You can keep me inside any of your Editor folders.\n" +
            "2. You can check me out of your version control.";

        public override void OnInspectorGUI()
        {
            EditorGUILayout.HelpBox(message, MessageType.Info);

            using (new EditorGUI.DisabledScope(true))
            {
                DrawDefaultInspector();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupAttributesPrefsEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupEditorUtils.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7c7df93f6d00b3c418191b311072bfba
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEditor;

namespace MarkupAttributes.Editor
{
	internal static class MarkupEditorUtils
	{
		public const BindingFlags DefaultBindingFlags = BindingFlags.Instance | BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public;

		public static SerializedProperty[] GetSerializedObjectProperties(SerializedObject serializedObject)
		{
			List<SerializedProperty> props = new List<SerializedProperty>();
			using (SerializedProperty iterator = serializedObject.GetIterator())
			{
				if (iterator.NextVisible(true))
				{
					do
					{
						props.Add(iterator.Copy());
					}
					while (iterator.NextVisible(false));
				}
			}
			return props.ToArray();
		}

		public static SerializedProperty[] GetChildrenProperties(SerializedProperty serializedProperty)
		{
			return GetChildrenOfProperty(serializedProperty).ToArray();
		}

		public static IEnumerable<SerializedProperty> GetChildrenOfProperty(SerializedProperty serializedProperty)
		{
			SerializedProperty currentProperty = serializedProperty.Copy();
			SerializedProperty nextSiblingProperty = serializedProperty.Copy();

			nextSiblingProperty.Next(false);
			if (currentProperty.Next(true))
			{
				do
				{
					if (SerializedProperty.EqualContents(currentProperty, nextSiblingProperty))
						break;

					yield return currentProperty.Copy();
				}
				while (currentProperty.Next(false));
			}
		}


		// from https://github.com/lordofduct/spacepuppy-unity-framework-3.0/blob/master/SpacepuppyUnityFrameworkEditor/EditorHelper.cs
		public static object GetTargetObjectOfProperty(SerializedProperty property)
		{
			if (property == null)
			{
				return null;
			}

			string path = property.propertyPath.Replace(".Array.data[", "[");
			object obj = property.serializedObject.targetObject;
			string[] elements = path.Split('.');

			foreach (var element in elements)
			{
				if (element.Contains("["))
				{
					string elementName = element.Substring(0, element.IndexOf("["));
					int index = Convert.ToInt32(element.Substring(element.IndexOf("[")).Replace("[", "").Replace("]", ""));
					obj = GetValue_Imp(obj, elementName, index);
				}
				else
				{
					obj = GetValue_Imp(obj, element);
				}
			}

			return obj;
		}

		private static object GetValue_Imp(object source, string name)
		{
			if (source == null)
			{
				return null;
			}

			Type type = source.GetType();

			while (type != null)
			{
				FieldInfo field = type.GetField(name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance);
				if (field != null)
				{
					return field.GetValue(source);
				}

				PropertyInfo property = type.GetProperty(name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
				if (property != null)
				{
					return property.GetValue(source, null);
				}

				type = type.BaseType;
			}

			return null;
		}

		private static object GetValue_Imp(object source, string name, int index)
		{
			IEnumerable enumerable = GetValue_Imp(source, name) as IEnumerable;
			if (enumerable == null)
			{
				return null;
			}

			IEnumerator enumerator = enumerable.GetEnumerator();
			for (int i = 0; i <= index; i++)
			{
				if (!enumerator.MoveNext())
				{
					return null;
				}
			}

			return enumerator.Current;
		}
	}
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupEditorUtils.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupGUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 51862abc1839c29419a81574e53da6a0
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace MarkupAttributes.Editor
{
    public static class MarkupGUI
    {
        internal const float SpaceAfterBoxedHeader = 4;
        internal const float SpaceBeforeHeader = 5;

        #region Utility

        private static readonly GUIContent tempContent = new GUIContent();
        private static GUIContent GetContent(string label = null, string tooltip = null)
        {
            if (label == null)
                return GUIContent.none;
            tempContent.text = label;
            tempContent.tooltip = tooltip;
            return tempContent;
        }

        public static bool IsInsideInlineEditor { get; private set; } = false;
        public class InlineEditorScope : IDisposable
        {
            private readonly bool cachedIsInsideInlineEditor;

            public InlineEditorScope()
            {
                cachedIsInsideInlineEditor = IsInsideInlineEditor;
                IsInsideInlineEditor = true;
            }

            public void Dispose()
            {
                IsInsideInlineEditor = cachedIsInsideInlineEditor;
            }
        }

        private struct LabelState
        {
            private bool? hierarchyMode;
            private int? indentLevel;
            private float? labelWidth;

            public static LabelState Current()
            {
                LabelState state = new LabelState();
                state.hierarchyMode = EditorGUIUtility.hierarchyMode;
                state.indentLevel = EditorGUI.indentLevel;
                state.labelWidth = EditorGUIUtility.labelWidth;
                return state;
            }

            public void Restore()
            {
                if (hierarchyMode.HasValue)
                    EditorGUIUtility.hierarchyMode = hierarchyMode.Value;
                if (indentLevel.HasValue)
                    EditorGUI.indentLevel = indentLevel.Value;
                if (labelWidth.HasValue)
                    EditorGUIUtility.labelWidth = labelWidth.Value;
            }
        }

        internal static void StartNonHierarchyScope(float padding)
        {
            float labelWidth = EditorGUIUtility.labelWidth;
            EditorGUIUtility.hierarchyMode = false;
            EditorGUIUtility.labelWidth = labelWidth - padding;
        }

        public struct GroupHandle
        {
            private readonly LabelState labelState;
            private readonly bool isVertical;
            private readonly bool isHorizontal;

            public GroupHandle(bool isVertical, bool isHorizontal)
            {
                labelState = LabelState.Current();
                this.isVertical = isVertical;
                this.isHorizontal = isHorizontal;
            }

            public void End()
            {
                labelState.Restore();
                if (isVertical)
                    EditorGUILayout.EndVertical();
                if (isHorizontal)
                    EditorGUILayout.EndHorizontal();
            }
        }

        public class GroupsStack
        {
            private readonly Stack<GroupHandle> groups = new Stack<GroupHandle>();
            public void PushGroup(GroupHandle group) => groups.Push(group);

            public void EndAll()
            {
                while (groups.Count > 0)
                {
                    groups.Pop().End();
                }
            }

            public void EndGroup()
            {
                if (groups.Count < 1)
                {
                    Debug.LogWarning("No MarkupGUI groups to end.");
                }
                groups.Pop().End();
            }

            public void Clear()
            {
                groups.Clear();
            }

            public static GroupsStack operator +(GroupsStack stateStack, GroupHandle group)
            {
                stateStack.PushGroup(group);
                return stateStack;
            }

        }

        #endregion Utility

        public static void HorizontalLine(float height = 1)
        {
            float c = EditorGUIUtility.isProSkin ? 0.45f : 0.4f;
            HorizontalLine(new Color(c, c, c), height);
        }
        public static void HorizontalLine(Color color, float height)
        {
            Rect rect = EditorGUILayout.GetControlRect(false, height);
            rect = EditorGUI.IndentedRect(rect);
            EditorGUI.DrawRect(rect, color);
            GUILayout.Space(2);
        }
        public static Rect BeginVertical(MarkupBodyStyle style, MarkupHeaderFlags headerFlags, bool isExpanded)
        {
            Rect headerRect = Rect.zero;
            bool hasHeader = headerFlags.HasFlag(MarkupHeaderFlags.Label);
            bool underline = headerFlags.HasFlag(MarkupHeaderFlags.Underline);
            if (style == MarkupBodyStyle.None)
            {
                EditorGUILayout.BeginVertical();
                if (hasHeader)
                {
                    headerRect = EditorGUILayout.GetControlRect();
                    if (isExpanded && underline)
                    {
                        HorizontalLine();
                    }
                }
                return headerRect;
            }

            if (style == MarkupBodyStyle.ContentBox)
            {
                // Inlined editors create unwanted padding, 
                // if there is an empty GUIStyle.none vertical scope
                // (which can happen, for example, in unexpanded foldouts).
                // I don't know if it's a bug or an intended behaviour.
                // Workaround - put header inside the scope if it's not expanded.
                if (!isExpanded)
                    EditorGUILayout.BeginVertical();
                if (hasHeader)
                    headerRect = EditorGUILayout.GetControlRect();
                if (isExpanded)
                    EditorGUILayout.BeginVertical(MarkupStyles.Box);
                return headerRect;
            }

            if (style == MarkupBodyStyle.Box)
            {
                EditorGUILayout.BeginVertical(MarkupStyles.OutlinedBox);
                if (hasHeader)
                {
                    headerRect = EditorGUILayout.GetControlRect();
                    Rect headerBoxRect = MarkupStyles.OutlinedBox.padding.Add(headerRect);
                    GUI.Box(headerBoxRect, GUIContent.none, MarkupStyles.OutlinedHeaderBox(isExpanded));
                    if (isExpanded)
                    {
                        GUILayout.Space(SpaceAfterBoxedHeader);
                    }
                }
                return headerRect;
            }

            EditorGUILayout.BeginVertical();
            return headerRect;
        }

        internal static GroupHandle BeginGenericVerticalGroup(
            ref bool isExpanded, ref bool isEnabled,
            MarkupHeaderFlags headerStyle, MarkupBodyStyle bodyStyle,
            string label, TogglableValueWrapper togglableValue)
        {
            return BeginGenericVerticalGroup(ref isExpanded, ref isEnabled,
                headerStyle, bodyStyle, GetContent(label), togglableValue);
        }

        internal static GroupHandle BeginGenericVerticalGroup(
            ref bool isExpanded, ref bool isEnabled,
            MarkupHeaderFlags headerFlags, MarkupBodyStyle bodyStyle, 
            GUIContent label, TogglableValueWrapper togglableValue)
        {
            var handle = new GroupHandle(true, false);
            bool hasLabel = headerFlags.HasFlag(MarkupHeaderFlags.Label);
            bool isFoldable = headerFlags.HasFlag(MarkupHeaderFlags.Foldable);
            if (!isFoldable)
            {
                isExpanded = togglableValue == null || togglableValue.GetValue();
            }

            Rect headerRect = BeginVertical(bodyStyle, headerFlags, isExpanded);

            if (bodyStyle == MarkupBodyStyle.Box)
            {
                StartNonHierarchyScope(MarkupStyles.OutlinedBox.padding.left);
            }

            if (hasLabel)
            {
                if (togglableValue != null)
                {
                    if (!isFoldable)
                        isExpanded = togglableValue.GetValue();
                    bool value = Toggle(headerRect, togglableValue, label, 
                        ref isExpanded, isFoldable);
                    if (isFoldable)
                    {
                        isEnabled &= value;
                    }
                    else
                        isExpanded &= value;
                }
                else
                {
                    using (new EditorGUI.DisabledScope(!isEnabled))
                    {
                        if (isFoldable)
                        {
                            isExpanded = EditorGUI.Foldout(headerRect, isExpanded, label, true, MarkupStyles.BoldFoldout);
                        }
                        else
                        {
                            EditorGUI.LabelField(headerRect, label, EditorStyles.boldLabel);
                        }
                    }
                }
            }

            if (bodyStyle == MarkupBodyStyle.ContentBox)
            {
                StartNonHierarchyScope(MarkupStyles.Box.padding.left);
            }

            return handle;
        }

        public static GroupHandle BeginBoxGroup(string label = null) => BeginBoxGroup(GetContent(label));

        public static GroupHandle BeginBoxGroup(GUIContent label)
        {
            bool isExpanded = true;
            bool isEnabled = true;
            return BeginGenericVerticalGroup(ref isExpanded, ref isEnabled,
                label != GUIContent.none ? MarkupHeaderFlags.Label : MarkupHeaderFlags.None,
                MarkupBodyStyle.Box, label, null);
        }

        public static GroupHandle BeginTitleGroup(string label, bool contentBox = false, bool underline = true) 
            => BeginTitleGroup(GetContent(label), contentBox, underline);

        public static GroupHandle BeginTitleGroup(GUIContent label, bool contentBox = false, bool underline = true)
        {
            bool isExpanded = true;
            bool isEnabled = true;
            MarkupHeaderFlags headerFlags = MarkupHeaderFlags.Label;
            if (underline)
                headerFlags |= MarkupHeaderFlags.Underline;
            return BeginGenericVerticalGroup(ref isExpanded, ref isEnabled, headerFlags, 
                contentBox ? MarkupBodyStyle.ContentBox : MarkupBodyStyle.None, label, null);
        }

        public static GroupHandle BeginFoldoutGroup(ref bool isExpanded, string label, bool box = true)
            => BeginFoldoutGroup(ref isExpanded, GetContent(label), box);

        public static GroupHandle BeginFoldoutGroup(ref bool isExpanded, GUIContent label, bool box = true)
        {
            bool isEnabled = true;
            return BeginGenericVerticalGroup(ref isExpanded, ref isEnabled,
                MarkupHeaderFlags.Foldable | MarkupHeaderFlags.Label, box ?
                MarkupBodyStyle.Box : MarkupBodyStyle.ContentBox, label, null);
        }

        public static GroupHandle BeginTabsGroup(ref int selected, string[] tabs, bool box = false)
        {
            var handle = new GroupHandle(true, false);
            if (box)
            {
                EditorGUILayout.BeginVertical(MarkupStyles.TabsBox);
                StartNonHierarchyScope(MarkupStyles.TabsBox.padding.left);

                Rect position = EditorGUILayout.GetControlRect(false);
                var padding = MarkupStyles.OutlinedBox.padding;
                position.x -= padding.left;
                position.width += padding.right + padding.left - 1;
                position.y -= padding.top;
                position.height += padding.top;

                for (int i = 0; i < tabs.Length; i++)
                {
                    Rect r = GetTabRect(position, i, tabs.Length, out GUIStyle style);
                    if (EditorGUI.Toggle(r, i == selected, style))
                        selected = i;
                    EditorGUI.LabelField(r, tabs[i], MarkupStyles.CenteredLabel);
                }
            }
            else
            {
                selected = GUILayout.Toolbar(selected, tabs);
                EditorGUILayout.BeginVertical(GUIStyle.none);
            }
            GUILayout.Space(SpaceAfterBoxedHeader);

            return handle;
        }

        private static Rect GetTabRect(Rect rect, int tabIndex, int tabCount, out GUIStyle tabStyle)
        {
            tabStyle = MarkupStyles.TabMiddle;

            if (tabCount == 1)
            {
                tabStyle = MarkupStyles.TabOnlyOne;
            }
            else if (tabIndex == 0)
            {
                tabStyle = MarkupStyles.TabFirst;
            }
            else if (tabIndex == (tabCount - 1))
            {
                tabStyle = MarkupStyles.TabLast;
            }

            float tabWidth = rect.width / tabCount;
            int left = Mathf.RoundToInt(tabIndex * tabWidth);
            int right = Mathf.RoundToInt((tabIndex + 1) * tabWidth);
            return new Rect(rect.x + left, rect.y, right - left, rect.height);
        }

        internal static bool FoldoutWithObjectField(SerializedProperty property)
        {
            Rect rect = EditorGUILayout.GetControlRect();
            bool res = FoldoutWithObjectField(rect, property);
            return res;
        }

        internal static bool FoldoutWithObjectField(Rect position,
            SerializedProperty property, GUIContent label = null)
        {
            label = EditorGUI.BeginProperty(position, label, property);
            var foldoutRect = new Rect(position.x, position.y, EditorGUIUtility.labelWidth, EditorGUIUtility.singleLineHeight);
            bool result = false;
            if (property.objectReferenceValue != null)
                result = EditorGUI.Foldout(foldoutRect, property.isExpanded, label, true);
            else
                EditorGUI.LabelField(position, label);

            float xOffset = EditorGUIUtility.labelWidth + EditorGUIUtility.standardVerticalSpacing;
            var propertyRect = new Rect(position.x + xOffset,
                position.y, position.width - xOffset, EditorGUIUtility.singleLineHeight);
            EditorGUI.ObjectField(propertyRect, property, GUIContent.none);
            EditorGUI.EndProperty();
            return result;
        }

        internal static bool Toggle(Rect position,
            TogglableValueWrapper wrapper, GUIContent label, ref bool isExpanded, bool foldable)
        {
            float toggleWidth = EditorStyles.boldLabel.CalcSize(label).x + 20;
            Rect rectToggle = position;
            rectToggle.width = toggleWidth;
            Rect rectFoldout = position;
            rectFoldout.x += toggleWidth;
            rectFoldout.width -= toggleWidth;

            bool hasMixedValue = wrapper.HasMixedValue;
            bool value = wrapper.GetValue();
            if (wrapper.TargetSerializedProperty != null)
                label = EditorGUI.BeginProperty(position, label, wrapper.TargetSerializedProperty);
            else
                EditorGUI.showMixedValue = hasMixedValue;

            EditorGUI.BeginChangeCheck();

            value = EditorGUI.ToggleLeft(rectToggle, label, value, EditorStyles.boldLabel);
            if (EditorGUI.EndChangeCheck())
                wrapper.SetValue(value, true);

            if (foldable)
            {
                Rect smallRect = rectFoldout;
                smallRect.x += rectFoldout.width - 20;
                smallRect.width = 20;
                isExpanded = EditorGUI.Foldout(smallRect, isExpanded, GUIContent.none);

                Rect controlRect = rectFoldout;
                var padding = MarkupStyles.OutlinedBox.padding;
                controlRect.y -= padding.top;
                controlRect.height += padding.top + padding.bottom;
                isExpanded = EditorGUI.Foldout(controlRect, isExpanded,
                    GUIContent.none, true, EditorStyles.label);
            }

            if (wrapper.TargetSerializedProperty != null)
                EditorGUI.EndProperty();
            else
                EditorGUI.showMixedValue = false;

            if (!foldable)
                isExpanded = value;
            return value && !hasMixedValue;
        }

        public static void DrawEditorInline(SerializedProperty property,
            UnityEditor.Editor editor, InlineEditorMode mode, bool enabled = true)
        {
            var labelState = LabelState.Current();
            
            bool expanded = mode == InlineEditorMode.Stripped || property.isExpanded;
            expanded &= editor != null;
            expanded &= !property.hasMultipleDifferentValues;
            MaterialEditor materialEditor = editor as MaterialEditor;

            if (mode == InlineEditorMode.Box)
            {
                Rect headerRect = BeginVertical(MarkupBodyStyle.Box, MarkupHeaderFlags.Label, property.isExpanded);
                StartNonHierarchyScope(MarkupStyles.OutlinedBox.padding.left);
                property.isExpanded = FoldoutWithObjectField(headerRect, property);
            }

            if (mode == InlineEditorMode.ContentBox)
            {
                Rect headerRect = BeginVertical(MarkupBodyStyle.ContentBox, MarkupHeaderFlags.Label, property.isExpanded);
                property.isExpanded = FoldoutWithObjectField(headerRect, property);
                StartNonHierarchyScope(MarkupStyles.Box.padding.left);
            }

            if (mode == InlineEditorMode.Stripped)
            {
                if (editor == null)
                    FoldoutWithObjectField(EditorGUILayout.GetControlRect(), property);
            }

            if (expanded)
            {
                // begin dummy vertical group,
                // because MaterialEditor interrupts one in OnInspectorGUI
                if (materialEditor)
                {
                    EditorGUILayout.BeginVertical();
                }
                using (new EditorGUI.DisabledScope(!enabled))
                {
                    using (new InlineEditorScope())
                    {
                        if (materialEditor)
                            editor.DrawHeader();
                        editor.OnInspectorGUI();
                    }
                }
                if (materialEditor)
                    EditorGUILayout.EndVertical();
            }

            if (mode != InlineEditorMode.Stripped)
            {
                EditorGUILayout.EndVertical();
                labelState.Restore();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupGUI.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupStyles.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b244c28a611b27b4091704d0f2acbe6f
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace MarkupAttributes.Editor
{
    public static class MarkupStyles
    {
        public static GUIStyle OutlinedBox => EditorStyles.helpBox;
        public static GUIStyle Box => GUI.skin.box;

        public static GUIStyle CenteredLabel
        {
            get
            {
                if (centeredLabel == null)
                {
                    centeredLabel = new GUIStyle(EditorStyles.label);
                    centeredLabel.alignment = TextAnchor.MiddleCenter;
                }
                return centeredLabel;
            }
        }

        public static GUIStyle BoldFoldout
        {
            get
            {
                if (boldFoldout == null)
                {
                    boldFoldout = new GUIStyle(EditorStyles.foldout);
                    boldFoldout.font = EditorStyles.boldFont;
                }
                return boldFoldout;
            }
        }

        public static GUIStyle OutlinedHeaderBox(bool opened)
        {
            InitializeHeaderStyles();
            if (opened)
                return EditorGUIUtility.isProSkin ? headerBoxOpenedDark : headerBoxOpenedLight;
            else
                return EditorGUIUtility.isProSkin ? headerBoxClosedDark : headerBoxClosedLight;
        }

        public static GUIStyle TabOnlyOne = "Tab onlyOne";
        public static GUIStyle TabFirst = "Tab first";
        public static GUIStyle TabMiddle = "Tab middle";
        public static GUIStyle TabLast = "Tab last";
        public static GUIStyle TabsBox
        {
            get
            {
                if (frameBox == null)
                {
                    frameBox = new GUIStyle("FrameBox");
                    frameBox.padding = EditorStyles.helpBox.padding;
                }
                return frameBox;
            }
        }

        private static GUIStyle centeredLabel;
        private static GUIStyle boldFoldout;
        private static GUIStyle frameBox;
        private static GUIStyle headerBoxOpenedDark;
        private static GUIStyle headerBoxOpenedLight;
        private static GUIStyle headerBoxClosedDark;
        private static GUIStyle headerBoxClosedLight;

        private static void InitializeHeaderStyles()
        {
            if (headerBoxOpenedDark == null)
            {
                headerBoxOpenedDark = CreateBoxStyle(GetTexture("MarkupAttributes_HeaderOpened_Dark"));
                headerBoxOpenedLight = CreateBoxStyle(GetTexture("MarkupAttributes_HeaderOpened_Light"));
                headerBoxClosedDark = CreateBoxStyle(GetTexture("MarkupAttributes_HeaderClosed_Dark"));
                headerBoxClosedLight = CreateBoxStyle(GetTexture("MarkupAttributes_HeaderClosed_Light"));
            }
        }

        private static GUIStyle CreateBoxStyle(Texture2D texture)
        {
            var style = new GUIStyle(EditorStyles.helpBox);
            if (texture != null)
            {
                style.normal.background = texture;
                style.normal.scaledBackgrounds = new Texture2D[0];
            }
            return style;
        }

        private static Texture2D GetTexture(string name)
        {
            string[] results = AssetDatabase.FindAssets(name);
            if (results != null && results.Length > 0)
                return AssetDatabase.LoadAssetAtPath<Texture2D>(AssetDatabase.GUIDToAssetPath(results[0]));
            return null;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupStyles.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MaterialPropertiesWrapper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 487fd20e934be0e4d898e531a6468334
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using UnityEditor;

namespace MarkupAttributes.Editor
{
    internal class MaterialPropertiesWrapper
    {
        public MaterialProperty[] value {get; set;}
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MaterialPropertiesWrapper.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/PropertyLayoutData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 749c26665bfd07245b0e37e400387a41
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System.Collections.Generic;

namespace MarkupAttributes.Editor
{
    internal class PropertyLayoutData
    {
        public readonly InspectorLayoutGroup[] groups;
        public readonly EndGroupAttribute end;
        public readonly ConditionWrapper[] hideConditions;
        public readonly ConditionWrapper[] disableConditions;
        public bool isTopLevel = true;
        public bool alwaysHide = false;
        public bool includeChildren = true;
        public int numberOfScopesToClose;

        public bool IsVisible()
        {
            if (alwaysHide)
                return false;
            for (int i = 0; i < hideConditions.Length; i++)
            {
                if (hideConditions[i].GetValue())
                    return false;
            }
            return true;
        }

        public bool IsEnabled()
        {
            for (int i = 0; i < disableConditions.Length; i++)
            {
                if (disableConditions[i].GetValue())
                    return false;
            }
            return true;
        }

        public PropertyLayoutData(List<InspectorLayoutGroup> groups, 
            List<ConditionWrapper> hideConditions, List<ConditionWrapper> disableConditions,
            EndGroupAttribute end)
        {
            groups.Sort((g0, g1) => g0.Order().CompareTo(g1.Order()));

            this.groups = groups.ToArray();
            this.hideConditions = hideConditions.ToArray();
            this.disableConditions = disableConditions.ToArray();
            this.end = end;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/PropertyLayoutData.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/SerializedDictionaryHandler.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 5db5e42b4b6ebc64598d8b52bd13dee6
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System.Collections.Generic;
using UnityEditor;

namespace MarkupAttributes.Editor
{
    internal class SerializedDictionaryHandler
    {
        private readonly SerializedProperty array;
        private Dictionary<string, SerializedProperty> dictionary;

        public SerializedDictionaryHandler(SerializedProperty targetArray)
        {
            array = targetArray;
            dictionary = new Dictionary<string, SerializedProperty>();

            for (int i = 0; i < array.arraySize; i++)
            {
                var prop = array.GetArrayElementAtIndex(i);
                dictionary.Add(prop.FindPropertyRelative("key").stringValue,
                    prop.FindPropertyRelative("value"));
            }
        }

        public void DeleteAll()
        {
            array.arraySize = 0;
            array.serializedObject.ApplyModifiedPropertiesWithoutUndo();
        }

        public bool GetBool(string key, bool defaultValue = false)
        {
            var prop = GetValueProp(key, false);
            return prop == null ? defaultValue : prop.boolValue;
        }
        public int GetInt(string key, int defaultValue = 0)
        {
            var prop = GetValueProp(key, false);
            return prop == null ? defaultValue : prop.intValue;
        }
        public void SetBool(string key, bool value)
        {
            var prop = GetValueProp(key, true);
            prop.boolValue = value;
            array.serializedObject.ApplyModifiedPropertiesWithoutUndo();
        }
        public void SetInt(string key, int value)
        {
            var prop = GetValueProp(key, true);
            prop.intValue = value;
            array.serializedObject.ApplyModifiedPropertiesWithoutUndo();
        }

        private SerializedProperty GetValueProp(string key, bool createIfNotPresent)
        {
            if (dictionary.TryGetValue(key, out SerializedProperty prop))
                return prop;
            else
                return createIfNotPresent ? AddKey(key) : null;
        }

        private SerializedProperty AddKey(string key)
        {
            array.arraySize += 1;
            SerializedProperty prop = array.GetArrayElementAtIndex(array.arraySize - 1);
            prop.FindPropertyRelative("key").stringValue = key;
            SerializedProperty valueProp = prop.FindPropertyRelative("value");
            dictionary.Add(key, valueProp);
            return valueProp;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/SerializedDictionaryHandler.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/ShaderAttributesParser.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 34bb20890b6122d4990bcd780184febf
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;

namespace MarkupAttributes.Editor
{
    internal static class ShaderAttributesParser
    {
        public static string GetKeyword(string arg, out bool isGlobal)
        {
            string[] s = arg.Split(' ');
            if (s.Length < 2)
            {
                isGlobal = false;
                return arg;
            }
            else
            {
                isGlobal = s[0] == "G";
                return s[1];
            }
        }

        public static int GetDrawSystemPropertiesAttribute(string[][] allAttributes)
        {
            for (int i = 0; i < allAttributes.Length; i++)
            {
                var attributes = allAttributes[i];
                foreach (var attribute in attributes)
                {
                    if (ParseAttribute(attribute, "DrawSystemProperties"))
                        return i;
                }
            }
            return -1;
        }

        public static PropertyLayoutData[] GetLayoutData(string[][] allAttributes,
            MaterialPropertiesWrapper propertiesWrapper, Material targetMaterial)
        {
            var props = propertiesWrapper.value;
            var output = new PropertyLayoutData[props.Length];
            for (int i = 0; i < props.Length; i++)
            {
                bool isPropertyHidden = false;

                var groupAttributes = GetLayoutGroupAttributes(allAttributes[i]);
                var groups = new List<InspectorLayoutGroup>();
                foreach (var groupAttribute in groupAttributes)
                {
                    var group = CreateGroupFromAttribute(ref isPropertyHidden, groupAttribute,
                        i, propertiesWrapper, targetMaterial);
                    if (group != null)
                        groups.Add(group);
                }

                var conditionals = GetConditionals(allAttributes[i], propertiesWrapper, targetMaterial);

                output[i] = new PropertyLayoutData(groups, conditionals.Item1, conditionals.Item2,
                    GetEndGroupAttribute(allAttributes[i]));
                output[i].alwaysHide = isPropertyHidden;
            }

            return output;
        }

        private static InspectorLayoutGroup CreateGroupFromAttribute(ref bool isHidden,
            LayoutGroupAttribute attribute, int index, 
            MaterialPropertiesWrapper allProperties, Material targetMaterial)
        {
            ConditionWrapper conditionWrapper = null;
            if (attribute.HasCondition)
            {
                conditionWrapper = ConditionWrapper.Create(attribute.Condition, 
                    allProperties, targetMaterial);
                if (conditionWrapper == null) return null;
            }

            TogglableValueWrapper togglableValueWrapper = null;
            if (attribute.Toggle)
            {
                if (attribute.ToggleShaderKeyword != null)
                {
                    togglableValueWrapper = TogglableValueWrapper.Create(index, allProperties, targetMaterial, attribute.ToggleShaderKeyword);
                    isHidden = true;
                }
                else
                {
                    togglableValueWrapper = TogglableValueWrapper.Create(index, allProperties);
                    isHidden = true;
                }
                
                if (togglableValueWrapper == null)
                    return null;
            }

            return new InspectorLayoutGroup(attribute, conditionWrapper, togglableValueWrapper);
        }

        private static EndGroupAttribute GetEndGroupAttribute(string[] attributes)
        {
            foreach (var attribute in attributes)
            {
                if (ParseAttribute(attribute, "EndGroup", 0, out string[] args))
                {
                    EndGroupAttribute a;
                    if (args != null && args.Length > 0)
                        a = new EndGroupAttribute(args[0]);
                    else
                        a = new EndGroupAttribute();
                    return a;
                }
            }
            return null;
        }

        private static (List<ConditionWrapper>, List<ConditionWrapper>) GetConditionals(
            string[] attributes, MaterialPropertiesWrapper materialProperties, Material material)
        {
            List<ConditionWrapper> hideConditions = new List<ConditionWrapper>();
            List<ConditionWrapper> disableConditions = new List<ConditionWrapper>();

            foreach (var attribute in attributes)
            {
                var hideIf = GetHideIfAttribute(attribute);
                if (hideIf != null)
                    hideConditions.Add(ConditionWrapper.Create(
                        hideIf.Condition, materialProperties, material));
                
                var disableIf = GetDisableIfAttribute(attribute);
                if (disableIf != null)
                    disableConditions.Add(ConditionWrapper.Create(
                        disableIf.Condition, materialProperties, material));
            }

            return (hideConditions, disableConditions);
        }

        private static HideIfAttribute GetHideIfAttribute(string attribute)
        {
            string[] args;
            bool valid = ParseAttribute(attribute, "HideIf", 1, out args);
            if (valid)
                return new HideIfAttribute(args[0]);
            valid = ParseAttribute(attribute, "ShowIf", 1, out args);
            if (valid)
                return new ShowIfAttribute(args[0]);
            return null;
        }

        private static DisableIfAttribute GetDisableIfAttribute(string attribute)
        {
            string[] args;
            bool valid = ParseAttribute(attribute, "DisableIf", 1, out args);
            if (valid)
                return new DisableIfAttribute(args[0]);
            valid = ParseAttribute(attribute, "EnableIf", 1, out args);
            if (valid)
                return new EnableIfAttribute(args[0]);
            valid = ParseAttribute(attribute, "ReadOnly");
            if (valid)
                return new ReadOnlyAttribute();

            return null;
        }

        private static LayoutGroupAttribute[] GetLayoutGroupAttributes(string[] attributes)
        {
            var groups = new List<LayoutGroupAttribute>();
            var temp = new List<LayoutGroupAttribute>();
            for (int i = 0; i < attributes.Length; i++)
            {
                temp.Clear();
                temp.Add(GetHideIfGroupAttribute(attributes[i]));
                temp.Add(GetDisableIfGroupAttribute(attributes[i]));
                temp.Add(GetTabScopeAttribute(attributes[i]));
                temp.Add(GetTabAttribute(attributes[i]));
                temp.Add(GetVerticalGroupAttribute(attributes[i]));
                temp.Add(GetHorizontalGroupAttribute(attributes[i]));
                temp.Add(GetTitleGroupAttribute(attributes[i]));
                temp.Add(GetFoldoutGroupAttribute(attributes[i]));
                temp.Add(GetToggleGroupAttribute(attributes[i]));
                temp.Add(GetBoxAttribute(attributes[i]));

                foreach (var g in temp)
                {
                    if (g != null)
                        groups.Add(g);
                }
            }
            return groups.ToArray();
        }

        private static HideIfGroupAttribute GetHideIfGroupAttribute(string attribute)
        {
            string[] args;
            bool valid = ParseAttribute(attribute, "HideIfGroup", 2, out args);
            if (valid)
                return new HideIfGroupAttribute(GetPath(args[0]), args[1]);
            valid = ParseAttribute(attribute, "ShowIfGroup", 2, out args);
            if (valid)
                return new ShowIfGroupAttribute(GetPath(args[0]), args[1]);
            return null;
        }

        private static DisableIfGroupAttribute GetDisableIfGroupAttribute(string attribute)
        {
            string[] args;
            bool valid = ParseAttribute(attribute, "DisableIfGroup", 2, out args);
            if (valid)
                return new DisableIfGroupAttribute(GetPath(args[0]), args[1]);
            valid = ParseAttribute(attribute, "EnableIfGroup", 2, out args);
            if (valid)
                return new EnableIfGroupAttribute(GetPath(args[0]), args[1]);
            valid = ParseAttribute(attribute, "ReadOnlyGroup", 1, out args);
            if (valid)
                return new ReadOnlyGroupAttribute(GetPath(args[0]));
            return null;
        }

        private static TabScopeAttribute GetTabScopeAttribute(string attribute)
        {
            bool valid = ParseAttribute(attribute, "TabScope", 2, out string[] args);
            if (valid)
            {
                if (args.Length < 3)
                    return new TabScopeAttribute(GetPath(args[0]), GetTabs(args[1]));
                if (args.Length < 4)
                    return new TabScopeAttribute(GetPath(args[0]), GetTabs(args[1]), GetBool(args[2]));
                else
                    return new TabScopeAttribute(GetPath(args[0]), GetTabs(args[1]), GetBool(args[2]), GetFloat(args[3]));
            }
            return null;
        }

        private static TabAttribute GetTabAttribute(string attribute)
        {
            bool valid = ParseAttribute(attribute, "Tab", 1, out string[] args);
            if (valid)
                return new TabAttribute(GetPath(args[0]));
            return null;
        }

        private static VerticalGroupAttribute GetVerticalGroupAttribute(string attribute)
        {
            bool valid = ParseAttribute(attribute, "VerticalGroup", 1, out string[] args);
            if (valid)
            {
                if (args.Length < 2)
                    return new VerticalGroupAttribute(GetPath(args[0]));
                else
                    return new VerticalGroupAttribute(GetPath(args[0]), GetFloat(args[1]));
            }  
            return null;
        }

        private static HorizontalGroupAttribute GetHorizontalGroupAttribute(string attribute)
        {
            bool valid = ParseAttribute(attribute, "HorizontalGroup", 2, out string[] args);
            if (valid)
            {
                if (args.Length < 3)
                    return new HorizontalGroupAttribute(GetPath(args[0]), GetFloat(args[1]));
                else
                    return new HorizontalGroupAttribute(GetPath(args[0]), GetFloat(args[1]), GetFloat(args[2]));
            }
            return null;
        }

        private static FoldoutAttribute GetFoldoutGroupAttribute(string attribute)
        {
            bool valid = ParseAttribute(attribute, "Foldout", 1, out string[] args);
            if (valid)
            {
                if (args.Length < 2)
                    return new FoldoutAttribute(GetPath(args[0]));
                if (args.Length < 3)
                    return new FoldoutAttribute(GetPath(args[0]), GetBool(args[1]));
                else
                    return new FoldoutAttribute(GetPath(args[0]), GetBool(args[1]), GetFloat(args[2]));
            }
            return null;
        }

        private static ToggleGroupAttribute GetToggleGroupAttribute(string attribute)
        {
            bool valid = ParseAttribute(attribute, "ToggleGroup", 1, out string[] args);
            if (valid)
            {
                if (args.Length < 2)
                    return ToggleGroupAttribute.CreateForShader(GetPath(args[0]), false, true, null);
                if (args.Length < 3)
                    return ToggleGroupAttribute.CreateForShader(GetPath(args[0]), GetBool(args[1]), true, null);
                if (args.Length < 4)
                    return ToggleGroupAttribute.CreateForShader(GetPath(args[0]), GetBool(args[1]), GetBool(args[2]), null);
                return ToggleGroupAttribute.CreateForShader(GetPath(args[0]), GetBool(args[1]), GetBool(args[2]), args[3]);
            }
            return null;
        }

        private static TitleGroupAttribute GetTitleGroupAttribute(string attribute)
        {
            bool valid = ParseAttribute(attribute, "TitleGroup", 1, out string[] args);
            if (valid)
            {
                if (args.Length < 2)
                    return new TitleGroupAttribute(GetPath(args[0]));
                if (args.Length < 3)
                    return new TitleGroupAttribute(GetPath(args[0]), GetBool(args[1]));
                if (args.Length < 4)
                    return new TitleGroupAttribute(GetPath(args[0]), GetBool(args[1]), GetBool(args[2]));
                else
                    return new TitleGroupAttribute(GetPath(args[0]), GetBool(args[1]), GetBool(args[2]), GetFloat(args[3]));
            }
            return null;
        }

        private static BoxAttribute GetBoxAttribute(string attribute)
        {
            bool valid = ParseAttribute(attribute, "Box", 1, out string[] args);
            if (valid)
            {
                if (args.Length < 2)
                    return new BoxAttribute(GetPath(args[0]));
                if (args.Length < 3)
                    return new BoxAttribute(GetPath(args[0]), GetBool(args[1]));
                else
                    return new BoxAttribute(GetPath(args[0]), GetBool(args[1]), GetFloat(args[2]));
            }
            return null;
        }

        private static string GetPath(string arg)
        {
            arg = arg.Replace(' ', '/');
            arg = arg.Replace('_', ' ');
            return arg;
        }

        private static string GetTabs(string arg)
        {
            arg = arg.Replace(' ', '|');
            arg = arg.Replace('_', ' ');
            return arg;
        }

        private static float GetFloat(string arg) => float.Parse(arg, CultureInfo.InvariantCulture.NumberFormat);

        private static bool GetBool(string arg) => arg == "true";

        private static T GetEnum<T>(string arg) where T : Enum
        {
            var values = Enum.GetValues(typeof(T)).Cast<T>();
            foreach (var value in values)
            {
                if (Enum.GetName(typeof(T), value) == arg)
                    return value;
            }
            return values.First();
        }

        private static bool ParseAttribute(string attribute, string attributeName)
        {
            return ParseAttribute(attribute, attributeName, 0, out _);
        }

        private static bool ParseAttribute(string attribute, string attributeName, int minArgsCount, out string[] args)
        {
            args = null;
            int argStartIndex = attribute.IndexOf('(');
            if (argStartIndex < 0 && minArgsCount > 0)
                return false;
            if (!(argStartIndex < 0 ? attribute : attribute.Substring(0, argStartIndex)).Equals(attributeName))
                return false;

            if (argStartIndex < 0)
                return true;

            string argument = attribute.Substring(argStartIndex + 1, attribute.Length - argStartIndex - 1);
            argument = argument.Trim(')');
            if (argument.Length < 1)
                return !(minArgsCount > 0);

            args = argument.Split(',');
            if (args.Length < minArgsCount)
                return false;

            for (int i = 0; i < args.Length; i++)
            {
                args[i] = args[i].Trim();
            }
            return true;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/ShaderAttributesParser.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/TargetObjectWrapper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: fba078294f8f0f04ea472aa55ba1e24b
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace MarkupAttributes.Editor
{
    internal class TargetObjectWrapper
    {
        public object Target => targetObject;

        private object targetObject;
        private readonly SerializedProperty serializedProperty;

        public TargetObjectWrapper(object targetObject, SerializedProperty serializedProperty = null)
        {
            this.targetObject = targetObject;
            if (serializedProperty != null && targetObject.GetType().IsValueType)
                this.serializedProperty = serializedProperty;
        }

        public void Update()
        {
            if (serializedProperty != null)
            {
                targetObject = MarkupEditorUtils.GetTargetObjectOfProperty(serializedProperty);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/TargetObjectWrapper.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/TogglableValueWrapper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d6fe201aa42070f4aad8270b16f84f97
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System.Reflection;
using UnityEditor;
using UnityEngine;

namespace MarkupAttributes.Editor
{
    internal class TogglableValueWrapper
    {
        private readonly SerializedProperty serializedProperty;

        private readonly MaterialPropertiesWrapper materialProperties;
        private readonly int materialPropertyIndex;
        private readonly Material targetMaterial;
        private readonly string shaderKeyword;

        public MaterialProperty MaterialProperty
        {
            get
            {
                if (materialProperties != null)
                    return materialProperties.value[materialPropertyIndex];
                return null;
            }
        }

        public SerializedProperty TargetSerializedProperty => serializedProperty;

        public static TogglableValueWrapper Create(SerializedProperty serializedProperty)
        {
            if (serializedProperty.propertyType == SerializedPropertyType.Boolean)
                return new TogglableValueWrapper(serializedProperty);
            return null;
        }

        public static TogglableValueWrapper Create(int index, MaterialPropertiesWrapper materialProperties)
        {
            if (materialProperties.value[index].propertyType == UnityEngine.Rendering.ShaderPropertyType.Float)
                return new TogglableValueWrapper(index, materialProperties);
            return null;
        }

        public static TogglableValueWrapper Create(int index, MaterialPropertiesWrapper materialProperties, 
            Material material, string keyword)
        {
            if (material != null && keyword != null &&
                materialProperties.value[index].propertyType == UnityEngine.Rendering.ShaderPropertyType.Float)
            {
                return new TogglableValueWrapper(index, materialProperties, material, keyword);
            }
            return null;
        }

        public bool HasMixedValue
        {
            get
            {
                if (serializedProperty != null && serializedProperty.hasMultipleDifferentValues)
                    return true;
                if (MaterialProperty != null && MaterialProperty.hasMixedValue)
                {
                    return true;
                }
                return false;
            }
        }

        private TogglableValueWrapper(SerializedProperty serializedProperty)
        {
            this.serializedProperty = serializedProperty;
        }

        private TogglableValueWrapper(int index, MaterialPropertiesWrapper materialProperties, 
            Material material = null, string shaderKeyword = null)
        {
            this.materialPropertyIndex = index;
            this.materialProperties = materialProperties;
            targetMaterial = material;
            this.shaderKeyword = shaderKeyword;
        }

        public bool GetValue()
        {
            if (serializedProperty != null)
                return serializedProperty.boolValue;

            if (MaterialProperty != null)
            {
                bool b = MaterialProperty.floatValue > 0;
                SetKeywordOnMaterial(b);
                return b;
            }

            return false;
        }

        public void SetValue(bool b, bool forceIfMixed)
        {
            if (serializedProperty != null)
            {
                if (!forceIfMixed && serializedProperty.hasMultipleDifferentValues)
                    return;
                serializedProperty.boolValue = b;
                return;
            }

            if (MaterialProperty != null)
            {
                if (!forceIfMixed && MaterialProperty.hasMixedValue)
                    return;
                MaterialProperty.floatValue = b ? 1 : 0;
                SetKeywordOnMaterial(b);
                return;
            }
        }

        private void SetKeywordOnMaterial(bool b)
        {
            if (targetMaterial != null && shaderKeyword != null)
            {
                if (b)
                    targetMaterial.EnableKeyword(shaderKeyword);
                else
                    targetMaterial.DisableKeyword(shaderKeyword);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/TogglableValueWrapper.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Rope/Core/DisableInPlayModePropertyDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f096bd19e16171c4bad990519eddc8b7
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;
using UnityEditor;

namespace RopeToolkit
{
    [CustomPropertyDrawer(typeof(DisableInPlayModeAttribute))]
    public class BeginLockInPlayModeDecoratorDrawer : PropertyDrawer
    {
        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            return EditorGUI.GetPropertyHeight(property, label, true);
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            var playing = Application.isPlaying;
            if (playing)
            {
                GUI.enabled = false;
            }

            var ranges = fieldInfo.GetCustomAttributes(typeof(RangeAttribute), true);
            var range = ranges != null && ranges.Length > 0 ? ranges[0] as RangeAttribute : null;
            if (range != null && property.propertyType == SerializedPropertyType.Float)
            {
                EditorGUI.Slider(position, property, range.min, range.max);
            }
            else if (range != null && property.propertyType == SerializedPropertyType.Integer)
            {
                EditorGUI.IntSlider(position, property, (int)range.min, (int)range.max);
            }
            else
            {
                EditorGUI.PropertyField(position, property, label, true);
            }

            if (playing)
            {
                GUI.enabled = true;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Rope/Core/DisableInPlayModePropertyDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Rope/Core/RopeEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: cb712eea104baa44597cd77e9a7f2cb1
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;
using UnityEditor;
using Unity.Mathematics;

namespace RopeToolkit
{
    [CustomEditor(typeof(Rope)), CanEditMultipleObjects]
    public class RopeEditor : Editor
    {
        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
        }

        public void OnSceneGUI()
        {
            if (Application.isPlaying)
            {
                return;
            }

            var rope = target as Rope;
            if (rope == null)
            {
                return;
            }

            // Draw floating window with buttons
            if (Selection.objects.Length == 1)
            {
                Handles.BeginGUI();
                GUI.skin = EditorGUIUtility.GetBuiltinSkin(EditorSkin.Scene);

                var lastSpawn = rope.spawnPoints.Count > 0 ? rope.spawnPoints[rope.spawnPoints.Count - 1] : float3.zero;
                var location = HandleUtility.WorldToGUIPoint(rope.transform.TransformPoint(lastSpawn)) + Vector2.right * 64.0f;
                GUILayout.Window(0, new Rect(location, Vector2.one), (id) =>
                {
                    if (GUILayout.Button("Push spawn point"))
                    {
                        Undo.RecordObject(rope, "Push Rope Spawn Point");
                        rope.PushSpawnPoint();
                    }
                    if (rope.spawnPoints.Count > 2 && GUILayout.Button("Pop spawn point"))
                    {
                        Undo.RecordObject(rope, "Pop Rope Spawn Point");
                        rope.PopSpawnPoint();
                    }
                }, rope.gameObject.name);

                Handles.EndGUI();
            }

            // Draw position handles
            Handles.color = Rope.Colors.spawnPointHandle;
            for (int i = 0; i < rope.spawnPoints.Count; i++)
            {
                var spawnPoint = rope.spawnPoints[i];
                var position = rope.transform.TransformPoint(spawnPoint);

                EditorGUI.BeginChangeCheck();
                if (Event.current.modifiers.HasFlag(EventModifiers.Shift))
                {
                    position = Handles.PositionHandle(position, Quaternion.identity);
                }
                else
                {
                    var fmh_69_65_638846360657886157 = Quaternion.identity; position = Handles.FreeMoveHandle(position, rope.radius * 4.0f, Vector3.one * 0.5f, Handles.SphereHandleCap);
                }
                if (EditorGUI.EndChangeCheck())
                {
                    Undo.RecordObject(rope, "Move Rope Spawn Point");
                    spawnPoint = rope.transform.InverseTransformPoint(position);
                    rope.spawnPoints[i] = spawnPoint;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Rope/Core/RopeEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/00_Main/ApplyTorqueOnKey.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c1451225f8bdb1545ae082cfd03cddfd
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;

namespace RopeToolkit.Example
{
    public class ApplyTorqueOnKey : MonoBehaviour
    {
        public Vector3 relativeTorque;
        public float maxAngularSpeed;

        public KeyCode key;

        protected Rigidbody rb;

        public void Start()
        {
            rb = GetComponent<Rigidbody>();
        }

        public void FixedUpdate()
        {
            if (rb == null)
            {
                return;
            }

            if (Input.GetKey(key))
            {
                var torqueAxis = relativeTorque.normalized;
                var strength = Mathf.SmoothStep(relativeTorque.magnitude, 0.0f, Vector3.Dot(torqueAxis, rb.angularVelocity) / maxAngularSpeed);
                rb.AddRelativeTorque(torqueAxis * strength, ForceMode.Force);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/00_Main/ApplyTorqueOnKey.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/00_Main/RopeBridgePlank.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1a91ac0b60b8b4d4eba00ef9563d2003
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;
using Unity.Mathematics;

namespace RopeToolkit.Example
{
    [RequireComponent(typeof(Rigidbody))]
    public class RopeBridgePlank : MonoBehaviour
    {
        public Rope ropeLeft;
        public Rope ropeRight;
        public float extentLeft = -0.5f;
        public float extentRight = 0.5f;
        public float extentPivot = 0.5f;

        [Tooltip("A measure of the longitudal stiffness of the plank. That is, how quickly should the particles on the opposite ropes move to the correct distance between them.")]
        [Range(0.0f, 1.0f)] public float longitudalStiffness = 0.25f;

        public float restingRigidbodyMassMultiplier = 5.0f;

        protected Rigidbody rb;
        protected int particleLeft;
        protected int particleRight;
        protected int particlePivotLeft;
        protected int particlePivotRight;
        protected float distance;
        protected float frameTotalMass;

        public void Start()
        {
            rb = GetComponent<Rigidbody>();
            if (rb != null)
            {
                rb.isKinematic = true;
            }

            var pointOnBodyLeft = transform.TransformPoint(Vector3.right * extentLeft);
            var pointOnBodyRight = transform.TransformPoint(Vector3.right * extentRight);
            var pointOnBodyPivot = transform.TransformPoint(Vector3.forward * extentPivot);

            if (ropeLeft != null)
            {
                ropeLeft.GetClosestParticle(pointOnBodyLeft, out particleLeft, out float distance);
                ropeLeft.GetClosestParticle(pointOnBodyPivot, out particlePivotLeft, out distance);
            }
            if (ropeRight != null)
            {
                ropeRight.GetClosestParticle(pointOnBodyRight, out particleRight, out float distance);
                ropeRight.GetClosestParticle(pointOnBodyPivot, out particlePivotRight, out distance);
            }

            if (ropeLeft != null && ropeRight != null)
            {
                distance = math.distance(ropeLeft.GetPositionAt(particleLeft), ropeRight.GetPositionAt(particleRight));
            }
        }

        public void FixedUpdate()
        {
            if (rb == null)
            {
                return;
            }
            if (ropeLeft == null || ropeRight == null)
            {
                rb.isKinematic = false;
                return;
            }

            var left = ropeLeft.GetPositionAt(particleLeft);
            var right = ropeRight.GetPositionAt(particleRight);
            var pivot = (ropeLeft.GetPositionAt(particlePivotLeft) + ropeRight.GetPositionAt(particlePivotRight)) * 0.5f;

            left.KeepAtDistance(ref right, distance, longitudalStiffness);

            var middle = (left + right) * 0.5f;

            rb.MoveRotation(Quaternion.LookRotation(pivot - middle, Vector3.Cross(pivot - middle, right - left)));
            rb.MovePosition((Vector3)middle - transform.TransformVector(Vector3.right * (extentLeft + extentRight) * 0.5f));

            ropeLeft.SetPositionAt(particleLeft, left);
            ropeRight.SetPositionAt(particleRight, right);

            var massMultiplier = 1.0f + frameTotalMass * restingRigidbodyMassMultiplier;
            frameTotalMass = 0.0f;

            if (ropeLeft.GetMassMultiplierAt(particleLeft) > 0.0f)
            {
                ropeLeft.SetMassMultiplierAt(particleLeft, massMultiplier);
            }
            if (ropeRight.GetMassMultiplierAt(particleRight) > 0.0f)
            {
                ropeRight.SetMassMultiplierAt(particleRight, massMultiplier);
            }
        }

        public void OnCollisionStay(Collision collision)
        {
            if (collision.rigidbody != null)
            {
                frameTotalMass += collision.rigidbody.mass;
            }
        }

#if UNITY_EDITOR
        public void OnDrawGizmosSelected()
        {
            var pointOnBodyLeft = transform.TransformPoint(Vector3.right * extentLeft);
            var pointOnBodyRight = transform.TransformPoint(Vector3.right * extentRight);
            var pointOnBodyPivot = transform.TransformPoint(Vector3.forward * extentPivot);

            Gizmos.color = Color.red;
            Gizmos.DrawWireSphere(pointOnBodyLeft, 0.05f);
            Gizmos.DrawWireSphere(pointOnBodyRight, 0.05f);
            Gizmos.DrawLine(pointOnBodyLeft, pointOnBodyRight);

            Gizmos.color = Color.blue;
            Gizmos.DrawWireSphere(pointOnBodyPivot, 0.05f);
            Gizmos.DrawLine(pointOnBodyLeft, pointOnBodyPivot);
            Gizmos.DrawLine(pointOnBodyRight, pointOnBodyPivot);
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/00_Main/RopeBridgePlank.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/00_Main/RopeMouseInteraction.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d741c2b5cb0190448822896128d51f8a
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;
using Unity.Mathematics;
using System.Collections.Generic;

namespace RopeToolkit
{
    public class RopeMouseInteraction : MonoBehaviour
    {
        public Mesh indicatorMesh;
        public Material indicatorMaterial;

        public List<Rope> ropes;

        protected bool ready;
        protected Rope pulledRope;
        protected int pulledParticle;
        protected float pulledDistance;
        protected float3 currentPosition;
        protected float3 targetPosition;

        protected Rope GetClosestRope(Ray ray, out int closestParticleIndex, out float closestDistanceAlongRay)
        {
            closestParticleIndex = -1;
            closestDistanceAlongRay = 0.0f;

            var closestRopeIndex = -1;
            var closestDistance = 0.0f;
            for (int i = 0; i < ropes.Count; i++)
            {
                ropes[i].GetClosestParticle(ray, out int particleIndex, out float distance, out float distanceAlongRay);

                if (distance < closestDistance || closestRopeIndex == -1)
                {
                    closestRopeIndex = i;
                    closestParticleIndex = particleIndex;
                    closestDistance = distance;
                    closestDistanceAlongRay = distanceAlongRay;
                }
            }

            return closestRopeIndex != -1 ? ropes[closestRopeIndex] : null;
        }
        
        public void FixedUpdate()
        {
            var ray = Camera.main.ScreenPointToRay(Input.mousePosition);
            
            if (Input.GetMouseButton(0))
            {
                // Mouse down
                if (ready && pulledRope == null)
                {
                    // Not pulling a rope, find the closest one to the mouse
                    var closestRope = GetClosestRope(ray, out int closestParticleIndex, out float closestDistanceAlongRay);

                    if (closestRope != null && closestParticleIndex != -1 && closestRope.GetMassMultiplierAt(closestParticleIndex) > 0.0f)
                    {
                        // Found a rope and particle on the rope, start pulling that particle!
                        pulledRope = closestRope;
                        pulledParticle = closestParticleIndex;
                        pulledDistance = closestDistanceAlongRay;

                        ready = false;
                    }
                }
            }
            else
            {
                // Mouse up
                if (pulledRope != null)
                {
                    // Stop pulling the rope
                    pulledRope.SetMassMultiplierAt(pulledParticle, 1.0f);
                    pulledRope = null;
                }
            }

            if (pulledRope != null)
            {
                // We are pulling the rope

                // Adjust the grab plane
                pulledDistance += Input.mouseScrollDelta.y * 2.0f;

                // Move the rope particle to the mouse position on the grab-plane
                currentPosition = pulledRope.GetPositionAt(pulledParticle);
                targetPosition = ray.GetPoint(pulledDistance);

                pulledRope.SetPositionAt(pulledParticle, targetPosition);
                pulledRope.SetVelocityAt(pulledParticle, float3.zero);
                pulledRope.SetMassMultiplierAt(pulledParticle, 0.0f);

                // Split the rope if spacebar is pressed!
                if (Input.GetKey(KeyCode.Space))
                {
                    ropes.Remove(pulledRope);

                    var newRopes = new Rope[2];
                    pulledRope.SplitAt(pulledParticle, newRopes);
                    if (newRopes[0] != null) ropes.Add(newRopes[0]);
                    if (newRopes[1] != null) ropes.Add(newRopes[1]);

                    pulledRope = null;
                }
            }
        }

        public void Update()
        {
            if (!Input.GetMouseButton(0))
            {
                ready = true;
            }

            if (indicatorMesh == null || indicatorMaterial == null)
            {
                return;
            }

            if (pulledRope != null)
            {
                Graphics.DrawMesh(indicatorMesh, Matrix4x4.TRS(currentPosition, Quaternion.identity, Vector3.one * 0.25f), indicatorMaterial, 0);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/00_Main/RopeMouseInteraction.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/00_Main/SoftBackdrop/SoftBackdrop.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6c341fba7d5799942b92f6085edb4743
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;
using System.Collections.Generic;
using UnityEngine.Rendering;

[ExecuteAlways]
public class SoftBackdrop : MonoBehaviour
{
    protected const int ParticleCount = 32;
    protected const float Size = 10.0f;

    public Material speckMaterial;
    public Mesh speckMesh;
    public float speckScale = 0.5f;
    public float speckMaxSpeed = 1.0f;

    public Material sphereMaterial;
    public Mesh sphereMesh;

    protected Mesh invertedSphereMesh;

    protected Vector3[] positions;
    protected Vector3[] velocities;
    protected Matrix4x4[] transforms;

    public void Start()
    {
        Init();
    }

    public void OnValidate()
    {
        Init();
    }

    public void Init()
    {
        positions = new Vector3[ParticleCount];
        velocities = new Vector3[ParticleCount];
        transforms = new Matrix4x4[ParticleCount];

        for (int i = 0; i < positions.Length; i++)
        {
            positions[i] = (new Vector3(Random.value, Random.value, Random.value) * 2.0f - new Vector3(1.0f, 1.0f, 1.0f)) * Size;
            velocities[i] = Random.insideUnitSphere * Random.value * speckMaxSpeed;
        }

        if (sphereMesh != null)
        {
            var n = sphereMesh.normals;
            for (int i = 0; i < n.Length; i++)
            {
                n[i] = -n[i];
            }
            var t = sphereMesh.triangles;
            for (int i = 0; i < t.Length / 3; i++)
            {
                var i1 = t[i * 3 + 1];
                t[i * 3 + 1] = t[i * 3 + 2];
                t[i * 3 + 2] = i1;
            }
            if (invertedSphereMesh != null)
            {
                if (Application.isPlaying)
                {
                    Destroy(invertedSphereMesh);
                }
                else
                {
                    DestroyImmediate(invertedSphereMesh);
                }
            }
            invertedSphereMesh = new Mesh
            {
                vertices = sphereMesh.vertices,
                normals = n,
                triangles = t,
            };
        }
    }

    public void OnDestroy()
    {
        if (invertedSphereMesh != null)
        {
            if (Application.isPlaying)
            {
                Destroy(invertedSphereMesh);
            }
            else
            {
                DestroyImmediate(invertedSphereMesh);
            }
        }
    }

    public void Update()
    {
        if (positions == null)
        {
            return;
        }

        for (int i = 0; i < positions.Length; i++)
        {
            var p = positions[i];
            var v = velocities[i];

            p += v * Time.deltaTime;

            if (p.magnitude > Size)
            {
                p = -p.normalized * Size;
            }

            positions[i] = p;
        }

        for (int i = 0; i < positions.Length; i++)
        {
            var dir = positions[i].normalized;
            var size = 1.0f - Mathf.Pow(Mathf.Clamp01(positions[i].magnitude / Size), 4.0f);
            size *= speckScale;
            transforms[i] = Matrix4x4.TRS(transform.TransformPoint(dir * 0.3f), Quaternion.LookRotation(dir), transform.lossyScale * size);
        }

        if (invertedSphereMesh != null && sphereMaterial != null)
        {
            Graphics.DrawMesh(invertedSphereMesh, transform.localToWorldMatrix, sphereMaterial, 0, null, 0, null, false, false);
        }

        if (speckMesh != null && speckMaterial != null)
        {
            speckMaterial.enableInstancing = true;
            Graphics.DrawMeshInstanced(speckMesh, 0, speckMaterial, transforms, transforms.Length, null, ShadowCastingMode.Off, false);
        }
    }

    public void OnDrawGizmos()
    {
        if (positions == null)
        {
            return;
        }

        Gizmos.color = Color.red;
        for (int i = 0; i < positions.Length; i++)
        {
            Gizmos.DrawWireSphere(transform.TransformPoint(positions[i]), 0.5f);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/00_Main/SoftBackdrop/SoftBackdrop.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/01_DynamicAttach/BackAndForthMovement.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e4453a595a14042518c9341023037a8d
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace RopeToolkit.Example
{
    public class BackAndForthMovement : MonoBehaviour
    {
        public Vector3 amount = new Vector3(2.0f, 0.0f, 0.0f);

        protected Vector3 startPos;

        public void Start()
        {
            startPos = transform.position;
        }

        public void Update()
        {
            transform.position = startPos + amount * Mathf.Sin(Time.time);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/01_DynamicAttach/BackAndForthMovement.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/01_DynamicAttach/DynamicAttach.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6ae913a7495f9445da3517bf946c1e9f
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace RopeToolkit.Example
{
    public class DynamicAttach : MonoBehaviour
    {
        public Material ropeMaterial;

        public Vector3 attachPoint;
        public Transform target;
        public Vector3 targetAttachPoint;

        protected GameObject ropeObject;

        public void Detach()
        {
            if (ropeObject)
            {
                Destroy(ropeObject);
            }
            ropeObject = null;
        }

        public void Attach()
        {
            Detach();

            ropeObject = new GameObject();
            ropeObject.name = "Rope";

            var start = transform.TransformPoint(attachPoint);
            var end = target.TransformPoint(targetAttachPoint);

            var rope = ropeObject.AddComponent<Rope>();
            rope.material = ropeMaterial;
            rope.spawnPoints.Add(ropeObject.transform.InverseTransformPoint(start));
            rope.spawnPoints.Add(ropeObject.transform.InverseTransformPoint(end));

            var conn0 = ropeObject.AddComponent<RopeConnection>();
            conn0.type = RopeConnectionType.PinRopeToTransform;
            conn0.ropeLocation = 0.0f;
            conn0.transformSettings.transform = transform;
            conn0.localConnectionPoint = attachPoint;

            var conn1 = ropeObject.AddComponent<RopeConnection>();
            conn1.type = RopeConnectionType.PinRopeToTransform;
            conn1.ropeLocation = 1.0f;
            conn1.transformSettings.transform = target;
            conn1.localConnectionPoint = targetAttachPoint;
        }

        public void OnGUI()
        {
            if (GUI.Button(new Rect(16, 16, 100, 32), "Attach"))
            {
                Attach();
            }
            if (GUI.Button(new Rect(16, 64, 100, 32), "Detach"))
            {
                Detach();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/01_DynamicAttach/DynamicAttach.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/02_BoxingRing/Spawner.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d7f10005d854a49a4b3371d4701441fd
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Spawner : MonoBehaviour
{
    public Transform prefab;
    public float randomRange = 0.5f;
    public float timeToSpawn = 4.0f;

    private float timer;

    public void Update()
    {
        timer += Time.deltaTime;

        if (timer >= timeToSpawn)
        {
            timer = 0.0f;

            var obj = Instantiate(prefab, transform.position + Random.insideUnitSphere * randomRange, transform.rotation);
            obj.gameObject.SetActive(true);
        }
    }

    public void OnDrawGizmos()
    {
        Gizmos.color = Color.yellow;
        Gizmos.DrawWireSphere(transform.position, randomRange);
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/02_BoxingRing/Spawner.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/SplineMesh/Editor/SplineEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 939ffc1cc7c3bfc42b8b61242dd8f0f6
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace SplineMesh {
    [CustomEditor(typeof(Spline))]
    public class SplineEditor : Editor {

        private const int QUAD_SIZE = 12;
        private static Color CURVE_COLOR = new Color(0.8f, 0.8f, 0.8f);
        private static Color CURVE_BUTTON_COLOR = new Color(0.8f, 0.8f, 0.8f);
        private static Color DIRECTION_COLOR = Color.red;
        private static Color DIRECTION_BUTTON_COLOR = Color.red;
        private static Color UP_BUTTON_COLOR = Color.green;

        private static bool showUpVector = false;

        private enum SelectionType {
            Node,
            Direction,
            InverseDirection,
            Up
        }

        private SplineNode selection;
        private SelectionType selectionType;
        private bool mustCreateNewNode = false;
        private SerializedProperty nodesProp { get { return serializedObject.FindProperty("nodes"); } }
        private Spline spline { get { return (Spline)serializedObject.targetObject; } }

        private GUIStyle nodeButtonStyle, directionButtonStyle, upButtonStyle;

        private void OnEnable() {
            Texture2D t = new Texture2D(1, 1);
            t.SetPixel(0, 0, CURVE_BUTTON_COLOR);
            t.Apply();
            nodeButtonStyle = new GUIStyle();
            nodeButtonStyle.normal.background = t;

            t = new Texture2D(1, 1);
            t.SetPixel(0, 0, DIRECTION_BUTTON_COLOR);
            t.Apply();
            directionButtonStyle = new GUIStyle();
            directionButtonStyle.normal.background = t;

            t = new Texture2D(1, 1);
            t.SetPixel(0, 0, UP_BUTTON_COLOR);
            t.Apply();
            upButtonStyle = new GUIStyle();
            upButtonStyle.normal.background = t;
            selection = null;
			
            Undo.undoRedoPerformed -= spline.RefreshCurves;
            Undo.undoRedoPerformed += spline.RefreshCurves;
        }

        SplineNode AddClonedNode(SplineNode node) {
            int index = spline.nodes.IndexOf(node);
            SplineNode res = new SplineNode(node.Position, node.Direction);
            if (index == spline.nodes.Count - 1) {
                spline.AddNode(res);
            } else {
                spline.InsertNode(index + 1, res);
            }
            return res;
        }

        void OnSceneGUI() {
            // disable game object transform gyzmo
            // if the spline script is active
            if (Selection.activeGameObject == spline.gameObject) {
                if (!spline.enabled) {
                    Tools.current = Tool.Move;
                } else {
                    Tools.current = Tool.None;
                    if (selection == null && spline.nodes.Count > 0)
                        selection = spline.nodes[0];
                }
            }

            // draw a bezier curve for each curve in the spline
            foreach (CubicBezierCurve curve in spline.GetCurves()) {
                Handles.DrawBezier(spline.transform.TransformPoint(curve.n1.Position),
                    spline.transform.TransformPoint(curve.n2.Position),
                    spline.transform.TransformPoint(curve.n1.Direction),
                    spline.transform.TransformPoint(curve.GetInverseDirection()),
                    CURVE_COLOR,
                    null,
                    3);
            }

            if (!spline.enabled)
                return;

            // draw the selection handles
            switch (selectionType) {
                case SelectionType.Node:
                    // place a handle on the node and manage position change

                    // TODO place the handle depending on user params (local or world)
                    Vector3 newPosition = spline.transform.InverseTransformPoint(Handles.PositionHandle(spline.transform.TransformPoint(selection.Position), spline.transform.rotation));
                    if (newPosition != selection.Position) {
                        Undo.RecordObject(spline, "Spline node change");
                        // position handle has been moved
                        if (mustCreateNewNode) {
                            mustCreateNewNode = false;
                            selection = AddClonedNode(selection);
                            selection.Direction += newPosition - selection.Position;
                            selection.Position = newPosition;
                        } else {
                            selection.Direction += newPosition - selection.Position;
                            selection.Position = newPosition;
                        }
                    }
                    break;
                case SelectionType.Direction:
                    var result = Handles.PositionHandle(spline.transform.TransformPoint(selection.Direction), Quaternion.identity);
                    Vector3 newDir = spline.transform.InverseTransformPoint(result);
                    if (newDir != selection.Direction)
                    {
                        Undo.RecordObject(spline, "Spline node change");
                        selection.Direction = newDir;
                    }
                    break;
                case SelectionType.InverseDirection:
                    result = Handles.PositionHandle(2 * spline.transform.TransformPoint(selection.Position) - spline.transform.TransformPoint(selection.Direction), Quaternion.identity);
                    result = 2 * selection.Position - spline.transform.InverseTransformPoint(result);
                    if (result != selection.Direction)
                    {
                        Undo.RecordObject(spline, "Spline node change");
                        selection.Direction = result;
                    }
                    break;
                case SelectionType.Up:
                    result = Handles.PositionHandle(spline.transform.TransformPoint(selection.Position + selection.Up), Quaternion.LookRotation(selection.Direction - selection.Position));
                    result = (spline.transform.InverseTransformPoint(result) - selection.Position).normalized;
                    if (result != selection.Up)
                    {
                        Undo.RecordObject(spline, "Spline node change");
                        selection.Up = result;
                    }
                    break;
            }

            // draw the handles of all nodes, and manage selection motion
            Handles.BeginGUI();
            foreach (SplineNode n in spline.nodes) {
                var dir = spline.transform.TransformPoint(n.Direction);
                var pos = spline.transform.TransformPoint(n.Position);
                var invDir = spline.transform.TransformPoint(2 * n.Position - n.Direction);
                var up = spline.transform.TransformPoint(n.Position + n.Up);
                // first we check if at least one thing is in the camera field of view
                if (!(CameraUtility.IsOnScreen(pos) ||
                    CameraUtility.IsOnScreen(dir) ||
                    CameraUtility.IsOnScreen(invDir) ||
                    (showUpVector && CameraUtility.IsOnScreen(up)))) {
                    continue;
                }

                Vector3 guiPos = HandleUtility.WorldToGUIPoint(pos);
                if (n == selection) {
                    Vector3 guiDir = HandleUtility.WorldToGUIPoint(dir);
                    Vector3 guiInvDir = HandleUtility.WorldToGUIPoint(invDir);
                    Vector3 guiUp = HandleUtility.WorldToGUIPoint(up);

                    // for the selected node, we also draw a line and place two buttons for directions
                    Handles.color = DIRECTION_COLOR;
                    Handles.DrawLine(guiDir, guiInvDir);

                    // draw quads direction and inverse direction if they are not selected
                    if (selectionType != SelectionType.Node) {
                        if (Button(guiPos, directionButtonStyle)) {
                            selectionType = SelectionType.Node;
                        }
                    }
                    if (selectionType != SelectionType.Direction) {
                        if (Button(guiDir, directionButtonStyle)) {
                            selectionType = SelectionType.Direction;
                        }
                    }
                    if (selectionType != SelectionType.InverseDirection) {
                        if (Button(guiInvDir, directionButtonStyle)) {
                            selectionType = SelectionType.InverseDirection;
                        }
                    }
                    if (showUpVector) {
                        Handles.color = Color.green;
                        Handles.DrawLine(guiPos, guiUp);
                        if (selectionType != SelectionType.Up) {
                            if (Button(guiUp, upButtonStyle)) {
                                selectionType = SelectionType.Up;
                            }
                        }
                    }
                } else {
                    if (Button(guiPos, nodeButtonStyle)) {
                        selection = n;
                        selectionType = SelectionType.Node;
                    }
                }
            }
            Handles.EndGUI();
            if (GUI.changed)
                EditorUtility.SetDirty(target);
        }

        bool Button(Vector2 position, GUIStyle style) {
            return GUI.Button(new Rect(position - new Vector2(QUAD_SIZE / 2, QUAD_SIZE / 2), new Vector2(QUAD_SIZE, QUAD_SIZE)), GUIContent.none, style);
        }

        public override void OnInspectorGUI() {
            serializedObject.Update();

            if(spline.nodes.IndexOf(selection) < 0) {
                selection = null;
            }

            // add button
            if (selection == null) {
                GUI.enabled = false;
            }
            if (GUILayout.Button("Add node after selected")) {
                Undo.RecordObject(spline, "add spline node");
                SplineNode newNode = new SplineNode(selection.Direction, selection.Direction + selection.Direction - selection.Position);
                var index = spline.nodes.IndexOf(selection);
                if(index == spline.nodes.Count - 1) {
                    spline.AddNode(newNode);
                } else {
                    spline.InsertNode(index + 1, newNode);
                }
                selection = newNode;
                serializedObject.Update();
            }
            GUI.enabled = true;

            // delete button
            if (selection == null || spline.nodes.Count <= 2) {
                GUI.enabled = false;
            }
            if (GUILayout.Button("Delete selected node")) {
                Undo.RecordObject(spline, "delete spline node");
                spline.RemoveNode(selection);
                selection = null;
                serializedObject.Update();
            }
            GUI.enabled = true;

            showUpVector = GUILayout.Toggle(showUpVector, "Show up vector");
            spline.IsLoop = GUILayout.Toggle(spline.IsLoop, "Is loop");

            // nodes
            GUI.enabled = false;
            EditorGUILayout.PropertyField(nodesProp);
            GUI.enabled = true;

            if (selection != null) {
                int index = spline.nodes.IndexOf(selection);
                SerializedProperty nodeProp = nodesProp.GetArrayElementAtIndex(index);

                EditorGUILayout.LabelField("Selected node (node " + index + ")");

                EditorGUI.indentLevel++;
                DrawNodeData(nodeProp, selection);
                EditorGUI.indentLevel--;
            } else {
                EditorGUILayout.LabelField("No selected node");
            }
        }

        private void DrawNodeData(SerializedProperty nodeProperty, SplineNode node) {
            var positionProp = nodeProperty.FindPropertyRelative("position");
            var directionProp = nodeProperty.FindPropertyRelative("direction");
            var upProp = nodeProperty.FindPropertyRelative("up");
            var scaleProp = nodeProperty.FindPropertyRelative("scale");
            var rollProp = nodeProperty.FindPropertyRelative("roll");

            EditorGUI.BeginChangeCheck();
            EditorGUILayout.PropertyField(positionProp, new GUIContent("Position"));
            EditorGUILayout.PropertyField(directionProp, new GUIContent("Direction"));
            EditorGUILayout.PropertyField(upProp, new GUIContent("Up"));
            EditorGUILayout.PropertyField(scaleProp, new GUIContent("Scale"));
            EditorGUILayout.PropertyField(rollProp, new GUIContent("Roll"));

            if (EditorGUI.EndChangeCheck()) {
                Undo.RecordObject(target, "Spline nodes change");
                node.Position = positionProp.vector3Value;
                node.Direction = directionProp.vector3Value;
                node.Up = upProp.vector3Value;
                node.Scale = scaleProp.vector2Value;
                node.Roll = rollProp.floatValue;
                serializedObject.Update();
            }
        }

        [MenuItem("GameObject/3D Object/Spline")]
        public static void CreateSpline() {
            new GameObject("Spline", typeof(Spline));
        }

        [DrawGizmo(GizmoType.InSelectionHierarchy)]
        static void DisplayUnselected(Spline spline, GizmoType gizmoType) {
            foreach (CubicBezierCurve curve in spline.GetCurves()) {
                Handles.DrawBezier(spline.transform.TransformPoint(curve.n1.Position),
                    spline.transform.TransformPoint(curve.n2.Position),
                    spline.transform.TransformPoint(curve.n1.Direction),
                    spline.transform.TransformPoint(curve.GetInverseDirection()),
                    CURVE_COLOR,
                    null,
                    3);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/SplineMesh/Editor/SplineEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/SplineMesh/Editor/SplineExtrusionEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7f8d2f224507f8d4881b64654b6cb902
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;
using System.Collections;
using UnityEditor;

namespace SplineMesh {
    [CustomEditor(typeof(SplineExtrusion))]
    public class SplineExtrusionEditor : Editor {
        private const int QUAD_SIZE = 10;
        private Color CURVE_COLOR = new Color(0.8f, 0.8f, 0.8f);
        private bool mustCreateNewNode = false;
        private SerializedProperty textureScale;
        private SerializedProperty sampleSpacing;
        private SerializedProperty material;
        private SerializedProperty vertices;

        private SplineExtrusion se;
        private ExtrusionSegment.Vertex selection = null;

        private void OnEnable() {
            se = (SplineExtrusion)target;
            textureScale = serializedObject.FindProperty("textureScale");
            sampleSpacing = serializedObject.FindProperty("sampleSpacing");
            material = serializedObject.FindProperty("material");
            vertices = serializedObject.FindProperty("shapeVertices");
        }

        void OnSceneGUI() {
            Event e = Event.current;
            if (e.type == EventType.MouseDown) {
                Undo.RegisterCompleteObjectUndo(se, "change extruded shape");
                // if control key pressed, we will have to create a new vertex if position is changed
                if (e.alt) {
                    mustCreateNewNode = true;
                }
            }
            if (e.type == EventType.MouseUp) {
                mustCreateNewNode = false;
            }
            var spline = se.GetComponent<Spline>();

            CurveSample startSample = spline.GetSample(0);
            Quaternion q = startSample.Rotation;
            foreach (ExtrusionSegment.Vertex v in se.shapeVertices) {
                // we create point and normal relative to the spline start where the shape is drawn
                Vector3 point = se.transform.TransformPoint(q * v.point + startSample.location);
                Vector3 normal = se.transform.TransformPoint(q * (v.point + v.normal) + startSample.location);

                // first we check if at least one thing is in the camera field of view
                if (!CameraUtility.IsOnScreen(point) && !CameraUtility.IsOnScreen(normal)) continue;

                if (v == selection) {
                    // draw the handles for selected vertex position and normal
                    float size = HandleUtility.GetHandleSize(point) * 0.3f;
                    float snap = 0.1f;

                    // create a handle for the vertex position
                    Vector3 movedPoint = Handles.Slider2D(0, point, startSample.tangent, Vector3.right, Vector3.up, size, Handles.CircleHandleCap, new Vector2(snap, snap));
                    if (movedPoint != point) {
                        // position has been moved
                        Vector2 newVertexPoint = Quaternion.Inverse(q) * (se.transform.InverseTransformPoint(movedPoint) - startSample.location);
                        if (mustCreateNewNode) {
                            // We must create a new node
                            mustCreateNewNode = false;
                            ExtrusionSegment.Vertex newVertex = new ExtrusionSegment.Vertex(newVertexPoint, v.normal, v.uCoord);
                            int i = se.shapeVertices.IndexOf(v);
                            if (i == se.shapeVertices.Count - 1) {
                                se.shapeVertices.Add(newVertex);
                            } else {
                                se.shapeVertices.Insert(i + 1, newVertex);
                            }
                            selection = newVertex;
                        } else {
                            v.point = newVertexPoint;
                            // normal must be updated if point has been moved
                            normal = se.transform.TransformPoint(q * (v.point + v.normal) + startSample.location);
                        }
                        se.SetToUpdate();
                    } else {
                        // vertex position handle hasn't been moved
                        // create a handle for normal
                        Vector3 movedNormal = Handles.Slider2D(normal, startSample.tangent, Vector3.right, Vector3.up, size, Handles.CircleHandleCap, snap);
                        if (movedNormal != normal) {
                            // normal has been moved
                            v.normal = (Vector2)(Quaternion.Inverse(q) * (se.transform.InverseTransformPoint(movedNormal) - startSample.location)) - v.point;
                            se.SetToUpdate();
                        }
                    }

                    Handles.BeginGUI();
                    DrawQuad(HandleUtility.WorldToGUIPoint(point), CURVE_COLOR);
                    DrawQuad(HandleUtility.WorldToGUIPoint(normal), Color.red);
                    Handles.EndGUI();
                } else {
                    // we draw a button to allow selection of the vertex
                    Handles.BeginGUI();
                    Vector2 p = HandleUtility.WorldToGUIPoint(point);
                    if (GUI.Button(new Rect(p - new Vector2(QUAD_SIZE / 2, QUAD_SIZE / 2), new Vector2(QUAD_SIZE, QUAD_SIZE)), GUIContent.none)) {
                        selection = v;
                    }
                    Handles.EndGUI();
                }

                // draw an arrow from the vertex location to the normal
                Handles.color = Color.red;
                Handles.DrawLine(point, normal);

                // draw a line between that vertex and the next one
                int index = se.shapeVertices.IndexOf(v);
                int nextIndex = index == se.shapeVertices.Count - 1 ? 0 : index + 1;
                ExtrusionSegment.Vertex next = se.shapeVertices[nextIndex];
                Handles.color = CURVE_COLOR;
                Vector3 vAtSplineEnd = se.transform.TransformPoint(q * next.point + startSample.location);
                Handles.DrawLine(point, vAtSplineEnd);
            }
        }

        void DrawQuad(Rect rect, Color color) {
            Texture2D texture = new Texture2D(1, 1);
            texture.SetPixel(0, 0, color);
            texture.Apply();
            GUI.skin.box.normal.background = texture;
            GUI.Box(rect, GUIContent.none);
        }

        void DrawQuad(Vector2 position, Color color) {
            DrawQuad(new Rect(position - new Vector2(QUAD_SIZE / 2, QUAD_SIZE / 2), new Vector2(QUAD_SIZE, QUAD_SIZE)), color);
        }

        public override void OnInspectorGUI() {
            serializedObject.Update();
            // Add vertex hint
            EditorGUILayout.HelpBox("Hold Alt and drag a vertex to create a new one.", MessageType.Info);

            // Delete vertex button
            if (selection == null || se.shapeVertices.Count <= 3) {
                GUI.enabled = false;
            }
            if (GUILayout.Button("Delete selected vertex")) {
                Undo.RegisterCompleteObjectUndo(se, "delete vertex");
                se.shapeVertices.Remove(selection);
                selection = null;
                se.SetToUpdate();
            }
            GUI.enabled = true;

            // Properties
            EditorGUILayout.PropertyField(textureScale, true);
            EditorGUILayout.PropertyField(sampleSpacing, true);
            EditorGUILayout.PropertyField(material, true);

            EditorGUILayout.PropertyField(vertices);
            EditorGUI.indentLevel += 1;
            if (vertices.isExpanded) {
                for (int i = 0; i < vertices.arraySize; i++) {
                    EditorGUILayout.PropertyField(vertices.GetArrayElementAtIndex(i), new GUIContent("Vertex " + i), true);
                }
            }
            EditorGUI.indentLevel -= 1;

            serializedObject.ApplyModifiedProperties();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/SplineMesh/Editor/SplineExtrusionEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Curvy Examples/Editor/E01_HeightMetadataEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 90ad9f4a58552ff48aecd9e1464f44a9
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.Curvy.Examples;
using FluffyUnderware.CurvyEditor;

namespace FluffyUnderware.Curvy.ExamplesEditor
{

    [CanEditMultipleObjects]
    [CustomEditor(typeof(E01_HeightMetadata))]
    public class E01_HeightMetadataEditor : DTEditor<E01_HeightMetadata>
    {

        [DrawGizmo(GizmoType.Active | GizmoType.NonSelected | GizmoType.InSelectionHierarchy)]
        static void GizmoDrawer(E01_HeightMetadata data, GizmoType context)
        {
            if (CurvyGlobalManager.ShowMetadataGizmo && data.Spline.ShowGizmos)
            {
                Vector3 position = data.ControlPoint.transform.position;
#pragma warning disable CS0618
                CurvyGizmo.PointLabel(position, data.MetaDataValue.ToString(), OrientationAxisEnum.Down);
#pragma warning restore CS0618
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Curvy Examples/Editor/E01_HeightMetadataEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/AboutWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: abfe48122637018449c040b59b54099e
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy;
using FluffyUnderware.DevToolsEditor;
using System.Linq;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.CurvyEditor
{

    public class AboutWindow : EditorWindow
    {
        static bool heightHasBeenSet = false;


        public static void Open()
        {
            EditorWindow.GetWindow<AboutWindow>(true, "About Curvy");
        }

        void OnEnable()
        {
            CurvyProject.Instance.ShowAboutOnLoad = false;
        }

        void OnGUI()
        {
            GUILayout.BeginVertical();
            GUILayout.Label(new GUIContent(CurvyStyles.TexLogoBig));
            DTGUI.PushContentColor(Color.black);

            GUIStyle labelStyle = new GUIStyle(EditorStyles.label);
            labelStyle.alignment = TextAnchor.UpperLeft;
            labelStyle.fontSize = 18;
            labelStyle.richText = true;

            GUI.Label(new Rect(300, 70, 215, 40), "<b>v " + CurvySpline.VERSION + "</b>", labelStyle);
            labelStyle.fontSize = 14;
            GUI.Label(new Rect(300, 95, 215, 40), "© 2013 ToolBuddy", labelStyle);
            DTGUI.PopContentColor();


            //head("Links");
            if (buttonCol("Release notes", "View release notes and upgrade instructions"))
                OpenReleaseNotes();
            if (buttonCol("Leave a review", "We've got to feed the Asset Store's algorithm"))
                Application.OpenURL("https://assetstore.unity.com/packages/tools/level-design/curvy-splines-7038");
            if (buttonCol("Custom development", "We can provide custom modifications for Curvy"))
                Application.OpenURL("mailto:admin@curvyeditor.com?subject=Curvy custom development request");
            if (buttonCol("Curvy Website", "Visit Curvy Splines' website"))
                OpenWeb();
            if (buttonCol("Our other assets", "Find our other assets on the Asset Store"))
                Application.OpenURL("https://assetstore.unity.com/publishers/304");
            if (buttonCol("Submit a bug report", "Found a bug? Please issue a bug report"))
                CurvyEditorUtility.SendBugReport();
            foot();

            GUILayout.Space(10);

            head("Learning Resources");
            if (buttonCol("View Examples", "Show examples folder in the Project window"))
                ShowExamples();
            if (buttonCol("Tutorials", "Watch some tutorials"))
                OpenTutorials();
            if (buttonCol("Documentation", "Manuals! That magic source of wisdom"))
                OpenDocs();
            if (buttonCol("API Reference", "Browse the API reference"))
                OpenAPIDocs();
            if (buttonCol("Support Forum", "Visit Support forum"))
                OpenForum();
            foot();

            GUILayout.EndVertical();

            if (!heightHasBeenSet && Event.current.type == EventType.Repaint)
                setHeightToContent();
        }

        private void setHeightToContent()
        {
            int w = 500;
            float height = GUILayoutUtility.GetLastRect().height + 10f;
            position.Set(position.x, position.y, w, height);
            minSize = new Vector2(w, height);
            maxSize = new Vector2(w, height + 1);
            heightHasBeenSet = true;
        }

        void head(string text)
        {
            GUILayout.BeginHorizontal();
            GUILayout.Space(35);
            GUILayout.Label(text, EditorStyles.boldLabel);
            GUILayout.FlexibleSpace();
            GUILayout.EndHorizontal();
            GUILayout.Space(3);
        }

        void foot()
        {
            GUILayout.Space(5);
        }

        bool buttonCol(string btnText, string text)
        {
            return buttonCol(new GUIContent(btnText), text);
        }

        bool buttonCol(GUIContent btn, string text)
        {
            GUILayout.BeginHorizontal();
            GUILayout.Space(20);
            bool res = GUILayout.Button(btn, GUILayout.Width(150));
            GUILayout.Space(20);
            EditorGUILayout.LabelField("<i>" + text + "</i>", DTStyles.HtmlLabel);
            GUILayout.EndHorizontal();
            return res;
        }

        public static void ShowExamples()
        {
            string searchString;
            searchString = "t:Folder Curvy Examples";
            string[] assetsGuids = AssetDatabase.FindAssets(searchString);
            if (assetsGuids.Any())
                EditorGUIUtility.PingObject(AssetDatabase.LoadMainAssetAtPath(AssetDatabase.GUIDToAssetPath(assetsGuids.First())));
            else
                DTLog.LogError("[Curvy] Could not find the \"Curvy Examples\" folder");
        }

        public static void OpenTutorials()
        {
            Application.OpenURL(CurvySpline.DOCLINK + "tutorials");
        }
        public static void OpenReleaseNotes()
        {
            Application.OpenURL(CurvySpline.DOCLINK + "releasenotes");
        }

        public static void OpenDocs()
        {
            Application.OpenURL(CurvySpline.WEBROOT + "documentation/");
        }

        public static void OpenAPIDocs()
        {
            Application.OpenURL("https://api.curvyeditor.com/" + CurvySpline.APIVERSION + "/");
        }

        public static void OpenWeb()
        {
            Application.OpenURL(CurvySpline.WEBROOT);
        }

        public static void OpenForum()
        {
            Application.OpenURL("https://forum.curvyeditor.com");
        }


    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/AboutWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildRasterizedPathEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a22d0d1b506cab148ac30469a3cbe49d
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator.Modules;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(BuildRasterizedPath))]
    public class BuildRasterizedPathEditor : CGModuleEditor<BuildRasterizedPath>
    {
        protected override void OnEnable()
        {
            base.OnEnable();
            HasDebugVisuals = true;
        }

        public override void OnModuleSceneDebugGUI()
        {
            base.OnModuleSceneDebugGUI();
            CGPath data = Target.OutPath.GetData<CGPath>();
            if (data)
            {
                Handles.matrix = Target.Generator.transform.localToWorldMatrix;
                CGEditorUtility.SceneGUIPlot(data.Positions.Array, data.Positions.Count, 0.1f, Color.white);
                Handles.matrix = Matrix4x4.identity;
            }
        }

        public override void OnModuleDebugGUI()
        {
            CGPath data = Target.OutPath.GetData<CGPath>();
            if (data)
            {
                EditorGUILayout.LabelField("Samples: " + data.Count.ToString());
            }
        }
    }




}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildRasterizedPathEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildShapeExtrusionEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 665128a47ac13454d8d965e27da8833b
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevToolsEditor;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(BuildShapeExtrusion))]
    public class BuildShapeExtrusionEditor : CGModuleEditor<BuildShapeExtrusion>
    {
        bool mEditCross;
        bool mShowEditButton;

        public override void OnModuleDebugGUI()
        {
            EditorGUILayout.LabelField("Samples Path/Cross: " + Target.PathSamples.ToString() + "/" + Target.CrossSamples.ToString());
            EditorGUILayout.LabelField("Cross Sample Groups: " + Target.CrossGroups.ToString());
        }

        void CBEditCrossButton()
        {

            if (DTGUI.IsLayout)
                mShowEditButton = (Target.IsConfigured && Target.InCross.SourceSlot().ExternalInput != null && Target.InCross.SourceSlot().ExternalInput.SupportsIPE);

            if (mShowEditButton)
            {
                EditorGUI.BeginChangeCheck();
                mEditCross = GUILayout.Toggle(mEditCross, "Edit Cross", EditorStyles.miniButton);
                if (EditorGUI.EndChangeCheck())
                {
                    if (mEditCross)
                    {
                        CGGraph.SetIPE(Target.Cross, this);
                    }
                    else
                        CGGraph.SetIPE();
                }
            }
        }

        /// <summary>
        /// Called for the IPE initiator to get the TRS values for the target
        /// </summary>
        internal override void OnIPEGetTRS(out Vector3 position, out Quaternion rotation, out Vector3 scale)
        {
            position = Target.CrossPosition;
            rotation = Target.CrossRotation;
            Vector2 scaleVector = (Target as ScalingModule).GetScale(0);
            scale = new Vector3(scaleVector.x, scaleVector.y, 1);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildShapeExtrusionEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildVolumeCapsEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a5d8157ce69d4dd4b92fdc9a14c40e18
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevToolsEditor;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(BuildVolumeCaps))]
    public class BuildVolumeCapsEditor : CGModuleEditor<BuildVolumeCaps>
    {


        public override void OnModuleDebugGUI()
        {
            CGVMesh vmesh = Target.OutVMesh.GetData<CGVMesh>();
            if (vmesh)
            {
                EditorGUILayout.LabelField("Vertices: " + vmesh.Count.ToString());
                EditorGUILayout.LabelField("Triangles: " + vmesh.TriangleCount.ToString());
                EditorGUILayout.LabelField("SubMeshes: " + vmesh.SubMeshes.Length.ToString());
            }
        }


    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildVolumeCapsEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildVolumeMeshEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1ea43086e5fba3b4e8d79ebce55076b7
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator.Modules;
using System.Linq;
using FluffyUnderware.DevToolsEditor;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(BuildVolumeMesh))]
    public class BuildVolumeMeshEditor : CGModuleEditor<BuildVolumeMesh>
    {
        bool showAddButton;
        int matcount;

        public override void OnModuleDebugGUI()
        {
            CGVMesh vmesh = Target.OutVMesh.GetData<CGVMesh>();
            if (vmesh)
            {
                EditorGUILayout.LabelField("Vertices: " + vmesh.Count.ToString());
                EditorGUILayout.LabelField("Triangles: " + vmesh.TriangleCount.ToString());
                EditorGUILayout.LabelField("SubMeshes: " + vmesh.SubMeshes.Length.ToString());
            }
        }

        protected override void OnReadNodes()
        {
            ensureMaterialTabs();
        }

        void ensureMaterialTabs()
        {
            DTGroupNode tabbar = Node.FindTabBarAt("Default");

            if (tabbar == null)
                return;

            tabbar.MaxItemsPerRow = 4;
            for (int i = 0; i < Target.MaterialCount; i++)
            {
                string tabName = string.Format("Mat {0}", i);
                if (tabbar.Count <= i + 1)
                    tabbar.AddTab(tabName, OnRenderTab);
                else
                {
                    tabbar[i + 1].Name = tabName;
                    tabbar[i + 1].GUIContent.text = tabName;
                }
            }
            while (tabbar.Count > Target.MaterialCount + 1)
                tabbar[tabbar.Count - 1].Delete();
            matcount = Target.MaterialCount;
        }

        void OnRenderTab(DTInspectorNode node)
        {
            int idx = node.Index - 1;

            if (idx >= 0 && idx < Target.MaterialCount)
            {
                CGMaterialSettingsEx mat = Target.MaterialSettings[idx];
                EditorGUI.BeginChangeCheck();

                bool matSwapUv = EditorGUILayout.Toggle("Swap UV", mat.SwapUV);
                if (matSwapUv != mat.SwapUV)
                {
                    Undo.RegisterCompleteObjectUndo(Target, "Modify Swap UV");
                    mat.SwapUV = matSwapUv;
                }

                CGKeepAspectMode cgKeepAspectMode = (CGKeepAspectMode)EditorGUILayout.EnumPopup("Keep Aspect", mat.KeepAspect);
                if (cgKeepAspectMode != mat.KeepAspect)
                {
                    Undo.RegisterCompleteObjectUndo(Target, "Modify Keep Aspect");
                    mat.KeepAspect = cgKeepAspectMode;
                }

                Vector2 matUvOffset = EditorGUILayout.Vector2Field("UV Offset", mat.UVOffset);
                if (matUvOffset != mat.UVOffset)
                {
                    Undo.RegisterCompleteObjectUndo(Target, "Modify UV Offset");
                    mat.UVOffset = matUvOffset;
                }

                Vector2 matUvScale = EditorGUILayout.Vector2Field("UV Scale", mat.UVScale);
                if (matUvScale != mat.UVScale)
                {
                    Undo.RegisterCompleteObjectUndo(Target, "Modify UV Scale");
                    mat.UVScale = matUvScale;
                }

                Target.SetMaterial(idx, EditorGUILayout.ObjectField("Material", Target.GetMaterial(idx), typeof(Material), true) as Material);

                if (Target.MaterialCount > 1 && GUILayout.Button("Remove"))
                {
                    Target.RemoveMaterial(idx);
                    node.Delete();
                    ensureMaterialTabs();
                    GUIUtility.ExitGUI();
                }
                if (EditorGUI.EndChangeCheck())
                {
                    Target.Dirty = true;
                    EditorUtility.SetDirty(Target);
                }
            }
        }

        void CBAddMaterial()
        {
            if (DTGUI.IsLayout)
                showAddButton = Node.FindTabBarAt("Default").SelectedIndex == 0;
            if (showAddButton)
            {
                if (GUILayout.Button("Add Material Group"))
                {
                    Target.AddMaterial();
                    ensureMaterialTabs();
                    GUIUtility.ExitGUI();
                }
            }

        }

        protected override void OnCustomInspectorGUI()
        {
            base.OnCustomInspectorGUI();
            if (matcount != Target.MaterialCount)
                ensureMaterialTabs();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildVolumeMeshEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildVolumeSpotsEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: ba3517e1babdd03478ed6bded8b06b79
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevToolsEditor.Extensions;
using UnityEditorInternal;
using FluffyUnderware.Curvy;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(BuildVolumeSpots))]
    public class BuildVolumeSpotsEditor : CGModuleEditor<BuildVolumeSpots>
    {
        ReorderableList mGroupItemsList;
        CGBoundsGroup mCurrentGroup;

        private DTGroupNode distributionGroupNode;
        private DTGroupNode rotationGroupNode;
        private DTGroupNode translationGroupNode;
        private DTGroupNode scaleGroupNode;

        private readonly GUIContent uniformScalingLabel = new GUIContent("Scale");
        private readonly GUIContent itemsNumberLabel = new GUIContent("    Items #");
        private readonly GUIContent emptyLabel1 = new GUIContent("");
        private readonly GUIContent emptyLabel2 = new GUIContent("");
        private readonly GUIContent emptyLabel3 = new GUIContent("");

        protected override void OnEnable()
        {
            base.OnEnable();
            HasDebugVisuals = true;
        }

        public override void OnModuleSceneDebugGUI()
        {
            CGSpots data = Target.SimulatedSpots;
            if (data)
            {
                Handles.matrix = Target.Generator.transform.localToWorldMatrix;
                for (int i = 0; i < data.Spots.Count; i++)
                {
                    Quaternion Q = data.Spots.Array[i].Rotation * Quaternion.Euler(-90, 0, 0);
#if UNITY_5_6_OR_NEWER
                    Handles.ArrowHandleCap(0, data.Spots.Array[i].Position, Q, 2, EventType.Repaint);
#else
                    Handles.ArrowCap(0, data.Points[i].Position, Q, 2);
#endif

                    Handles.Label(data.Spots.Array[i].Position, data.Spots.Array[i].Index.ToString(), EditorStyles.whiteBoldLabel);
                }
                Handles.matrix = Matrix4x4.identity;
            }
        }

        protected override void OnReadNodes()
        {
            base.OnReadNodes();
            ensureGroupTabs();

            //Used to subdivide nicely the diplayed fields within groups
            distributionGroupNode = new DTGroupNode("Distribution");

            rotationGroupNode = new DTGroupNode("Rotation");
            rotationGroupNode.Expanded = false;
            translationGroupNode = new DTGroupNode("Translation");
            translationGroupNode.Expanded = false;
            scaleGroupNode = new DTGroupNode("Scale");
            scaleGroupNode.Expanded = false;
        }

        void ensureGroupTabs()
        {
            DTGroupNode tabbar = Node.FindTabBarAt("Default");
            for (int i = 0; i < Target.GroupCount; i++)
            {
                string tabName = string.Format("{0}:{1}", i, Target.Groups[i].Name);
                if (tabbar.Count <= i + 2)
                    tabbar.AddTab(tabName, OnRenderTab);
                else
                {
                    tabbar[i + 2].Name = tabName;
                    tabbar[i + 2].GUIContent.text = tabName;
                }
            }
            for (int i = tabbar.Count - 1; i > Target.GroupCount + 1; i--)
                tabbar[i].Delete();


        }

        void OnRenderTab(DTInspectorNode node)
        {
            int grpIdx = node.Index - 2;

            if (grpIdx >= 0 && grpIdx < Target.GroupCount)
            {

                SerializedProperty pGroup = serializedObject.FindProperty(string.Format("m_Groups.Array.data[{0}]", grpIdx));
                if (pGroup != null)
                {

                    CGBoundsGroup boundsGroup = Target.Groups[grpIdx];
                    SerializedProperty pItems = pGroup.FindPropertyRelative("m_Items");
                    if (pItems != null)
                    {

                        if (mCurrentGroup != null && mCurrentGroup != boundsGroup)
                            mGroupItemsList = null;
                        if (mGroupItemsList == null)
                        {
                            mCurrentGroup = boundsGroup;
                            mGroupItemsList = new ReorderableList(pItems.serializedObject, pItems);
                            mGroupItemsList.draggable = true;
                            mGroupItemsList.drawHeaderCallback = (Rect Rect) => { EditorGUI.LabelField(Rect, "Items"); };
                            mGroupItemsList.drawElementCallback = (Rect rect, int index, bool isActive, bool isFocused) =>
                            {
                                #region ---

                                SerializedProperty prop = pItems.FindPropertyRelative(string.Format("Array.data[{0}]", index));
                                SerializedProperty pIndex = prop.FindPropertyRelative("Index");

                                rect.height = EditorGUIUtility.singleLineHeight;
                                EditorGUI.LabelField(new Rect(rect.x, rect.y, 30, rect.height), "#" + index.ToString() + ":");

                                GUIContent[] boundNames = Target.BoundsNames;
                                int[] boundIndices = Target.BoundsIndices;
                                if (boundNames.Length == 0)
                                    pIndex.intValue = EditorGUI.IntField(GetSelectorDrawArea(rect), "", pIndex.intValue);
                                else
                                    EditorGUI.IntPopup(GetSelectorDrawArea(rect), pIndex, boundNames, boundIndices, emptyLabel1);

                                if (boundsGroup.RandomizeItems && index >= boundsGroup.FirstRepeating && index <= boundsGroup.LastRepeating)
                                    EditorGUI.PropertyField(GetWeightDrawArea(rect), prop.FindPropertyRelative("m_Weight"), emptyLabel2);
                                #endregion
                            };

                            mGroupItemsList.onAddCallback = (ReorderableList l) =>
                            {
                                boundsGroup.Items.Insert(Mathf.Clamp(l.index + 1, 0, boundsGroup.ItemCount), new CGBoundsGroupItem());
                                boundsGroup.LastRepeating++;
                                Target.Dirty = true;
                                EditorUtility.SetDirty(Target);
                            };
                            mGroupItemsList.onRemoveCallback = (ReorderableList l) =>
                            {
                                boundsGroup.Items.RemoveAt(l.index);
                                boundsGroup.LastRepeating--;
                                Target.Dirty = true;
                                EditorUtility.SetDirty(Target);
                            };
                        }

                        mGroupItemsList.DoLayoutList();

                        RenderSectionHeader(distributionGroupNode);
                        if (distributionGroupNode.ContentVisible)
                        {
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_RandomizeItems"));
                            if (boundsGroup.RandomizeItems)
                                EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_RepeatingItems"), itemsNumberLabel);
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_KeepTogether"));
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_SpaceBefore"));
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_SpaceAfter"));
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_CrossBase"));
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_IgnoreModuleCrossBase"));
                        }
                        RenderSectionFooter(distributionGroupNode);
                        NeedRepaint |= distributionGroupNode.NeedRepaint;

                        RenderSectionHeader(translationGroupNode);
                        if (translationGroupNode.ContentVisible)
                        {
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_RelativeTranslation"));
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_TranslationX"));//, XTranslationContent);
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_TranslationY"));//, YTranslationContent);
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_TranslationZ"));//, ZTranslationContent);
                        }
                        RenderSectionFooter(translationGroupNode);
                        NeedRepaint |= translationGroupNode.NeedRepaint;

                        RenderSectionHeader(rotationGroupNode);
                        if (rotationGroupNode.ContentVisible)
                        {
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_RotationMode"));
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_RotationX"));//, XRotationContent);
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_RotationY"));//, YRotationContent);
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_RotationZ"));//, ZRotationContent);
                        }
                        RenderSectionFooter(rotationGroupNode);
                        NeedRepaint |= rotationGroupNode.NeedRepaint;

                        RenderSectionHeader(scaleGroupNode);
                        if (scaleGroupNode.ContentVisible)
                        {
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_UniformScaling"));//, XScaleContent);
                            if (boundsGroup.UniformScaling)
                            {
                                EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_ScaleX"), uniformScalingLabel);
                            }
                            else
                            {
                                EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_ScaleX"));//, XScaleContent);
                                EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_ScaleY"));//, YScaleContent);
                                EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_ScaleZ"));//, ZScaleContent);
                            }
                        }
                        RenderSectionFooter(scaleGroupNode);
                        NeedRepaint |= scaleGroupNode.NeedRepaint;
                    }
                }
            }
        }

        void RenderSectionHeader(DTGroupNode node)
        {
            GUILayout.Space(10);
            Rect controlRect = EditorGUILayout.GetControlRect(false, 16);
            bool toggleState = node.Expanded;
            DTInspectorNodeDefaultRenderer.RenderHeader(controlRect, 0, String.Empty, node.GUIContent, ref toggleState);
            node.Expanded = toggleState;
            EditorGUILayout.BeginFadeGroup(node.ExpandedFaded);
            //BUG if indentation is activated, mouse detection on the FloatRegion parameters gets fucked up
            //EditorGUI.indentLevel = EditorGUI.indentLevel + 1;
        }

        void RenderSectionFooter(DTGroupNode node)
        {
            //BUG if indentation is activated, mouse detection on the FloatRegion parameters gets fucked up
            //EditorGUI.indentLevel = EditorGUI.indentLevel - 1;
            EditorGUILayout.EndFadeGroup();
        }

        protected override void SetupArrayEx(DTFieldNode node, DevTools.ArrayExAttribute attribute)
        {
            switch (node.Name)
            {
                case "m_Groups":
                    node.ArrayEx.drawHeaderCallback = (Rect Rect) => { EditorGUI.LabelField(Rect, "Groups"); };
                    node.ArrayEx.drawElementCallback = OnGroupElementGUI;
                    node.ArrayEx.onAddCallback = (ReorderableList l) =>
                    {
                        //TODO unify this code with the one in BuildVolumeSpot.AddGroup()

                        //Creates a group
                        CGBoundsGroup cgBoundsGroup = new CGBoundsGroup("Group");

                        ////Adds the first item from input module if any.
                        //if (Target.InBounds)
                        //{
                        //    List<CGGameObject> inGameObjects = Target.InBounds.GetAllData<CGGameObject>();
                        //    if (inGameObjects.Count != 0)
                        //    {
                        //        CGBoundsGroupItem cgBoundsGroupItem = new CGBoundsGroupItem();
                        //        cgBoundsGroup.Items.Add(cgBoundsGroupItem);
                        //    }
                        //}

                        //Always add an input
                        cgBoundsGroup.Items.Add(new CGBoundsGroupItem());

                        //Adds the group
                        Target.Groups.Insert(Mathf.Clamp(l.index + 1, 0, Target.GroupCount), cgBoundsGroup);

                        Target.LastRepeating++;
                        EditorUtility.SetDirty(Target);
                        ensureGroupTabs();
                    };
                    node.ArrayEx.onRemoveCallback = (ReorderableList l) =>
                    {
                        mGroupItemsList = null;
                        Target.Groups.RemoveAt(l.index);
                        Target.LastRepeating--;
                        EditorUtility.SetDirty(Target);

                        //node[1+l.index].Delete();
                        ensureGroupTabs();
                        GUIUtility.ExitGUI();
                    };
                    node.ArrayEx.onReorderCallback = (ReorderableList l) =>
                    {
                        ensureGroupTabs();
                        GUIUtility.ExitGUI();
                    };
                    break;
            }
        }

        void OnGroupElementGUI(Rect rect, int index, bool isActive, bool isFocused)
        {
            bool fix = (index < Target.FirstRepeating || index > Target.LastRepeating);

            if (fix)
                DTHandles.DrawSolidRectangleWithOutline(rect, new Color(0, 0, 0.5f, 0.2f), new Color(0, 0, 0, 0));

            SerializedProperty prop = serializedObject.FindProperty(string.Format("m_Groups.Array.data[{0}]", index));
            if (prop != null)
            {
                SerializedProperty pName = prop.FindPropertyRelative("m_Name");
                SerializedProperty pRepeatingOrder = serializedObject.FindProperty("m_RepeatingOrder");

                rect.height = EditorGUIUtility.singleLineHeight;
                EditorGUI.LabelField(new Rect(rect.x, rect.y, 30, rect.height), "#" + index.ToString() + ":");

                EditorGUI.BeginChangeCheck();
                pName.stringValue = EditorGUI.TextField(GetSelectorDrawArea(rect), "", pName.stringValue);
                if (EditorGUI.EndChangeCheck())
                {
                    DTGroupNode tab = Node.FindTabBarAt("Default");
                    if (tab && tab.Count > index + 2)
                    {
                        tab[index + 2].Name = string.Format("{0}:{1}", index, pName.stringValue);
                        tab[index + 2].GUIContent.text = string.Format("{0}:{1}", index, pName.stringValue);
                    }
                }

                if (!fix && pRepeatingOrder.intValue == (int)CurvyRepeatingOrderEnum.Random)
                    EditorGUI.PropertyField(GetWeightDrawArea(rect), prop.FindPropertyRelative("m_Weight"), emptyLabel3);
            }
        }

        protected override void OnCustomInspectorGUIBefore()
        {
            base.OnCustomInspectorGUIBefore();
            EditorGUILayout.HelpBox("Spots: " + Target.Count.ToString(), MessageType.Info);
        }

        private static Rect GetSelectorDrawArea(Rect rect)
        {
            Rect itemSelectorDrawArea = new Rect(rect);
            itemSelectorDrawArea.x += 30;
            itemSelectorDrawArea.y += 1;
            itemSelectorDrawArea.width = rect.width / 2 - 50;
            return itemSelectorDrawArea;
        }

        private static Rect GetWeightDrawArea(Rect rect)
        {
            Rect weightDrawArea = new Rect(rect);
            weightDrawArea.x += rect.width / 2 - 10;
            weightDrawArea.y += 1;
            weightDrawArea.width = rect.width / 2;
            return weightDrawArea;
        }
    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildVolumeSpotsEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ConformPathEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1b6b2bda946d97f4091098f7f032f604
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(ConformPath))]
    public class ConformPathEditor : CGModuleEditor<ConformPath>
    {

    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ConformPathEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/CreateGameObjectEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f5b8ec7e389706a4aa211345824992e9
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevToolsEditor;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(CreateGameObject))]
    public class CreateGameObjectEditor : CGModuleEditor<CreateGameObject>
    {
        protected override void OnReadNodes()
        {
            base.OnReadNodes();
            Node.FindTabBarAt("Default").AddTab("Export", OnExportTab);
        }

        void OnExportTab(DTInspectorNode node)
        {
            GUI.enabled = Target.GameObjects.Count > 0;
            if (GUILayout.Button("Save To Scene"))
                Target.SaveToScene();
            GUI.enabled = true;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/CreateGameObjectEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/CreateMeshEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 86844bb464cc3bb4db7570a1e838dbe3
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevToolsEditor;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(CreateMesh))]
    public class CreateMeshEditor : CGModuleEditor<CreateMesh>
    {
        public override void OnModuleDebugGUI()
        {
            base.OnModuleDebugGUI();
            if (Target)
            {
                EditorGUILayout.LabelField("Meshes: " + Target.MeshCount.ToString());
                EditorGUILayout.LabelField("Vertices: " + Target.VertexCount.ToString());
            }
        }

        protected override void OnReadNodes()
        {
            base.OnReadNodes();
            Node.FindTabBarAt("Default").AddTab("Export", onExportTab);
        }

        void onExportTab(DTInspectorNode node)
        {
            GUI.enabled = Target.MeshCount > 0;

            if (GUILayout.Button(new GUIContent("Save To Scene", "Creates a GameObject, outside of the generator, containing a copy of the generated mesh(es)")))
            {
                Target.SaveToScene();
            }
            if (GUILayout.Button(new GUIContent("Save To Assets", "Saves a copy of the generated mesh(es) as Asset(s)")))
            {
                Target.SaveToAsset();
            }
            if (GUILayout.Button(new GUIContent("Save To Both (Prefab Compatible)", "Saves a copy of the generated mesh(es) as Asset(s), then creates a GameObject, outside of the generator, referencing those mesh assets. This way the created GameObject can be made part of a prefab without issues")))
            {
                Target.SaveToSceneAndAsset();
            }

            GUI.enabled = true;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/CreateMeshEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/CreatePathLineRendererEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e23df703953ef014db32b2b9fdd05f64
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(CreatePathLineRenderer))]
    public class CreatePathLineRendererEditor : CGModuleEditor<CreatePathLineRenderer>
    {

        protected override void OnCustomInspectorGUIBefore()
        {
            base.OnCustomInspectorGUIBefore();
            EditorGUILayout.HelpBox("Please edit parameters in inspector!", MessageType.Info);
            if (GUILayout.Button("Select Inspector"))
                Selection.activeGameObject = Target.gameObject;
        }

    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/CreatePathLineRendererEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/DebugRasterizedPathEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b947cab6e199c084498c2905219851e6
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevToolsEditor;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(DebugRasterizedPath))]
    public class DebugRasterizedPathEditor : CGModuleEditor<DebugRasterizedPath>
    {

        protected override void OnEnable()
        {
            base.OnEnable();
            HasDebugVisuals = true;
            ShowDebugVisuals = true;
        }

        // Scene View GUI - Called only if the module is initialized and configured
        //public override void OnModuleSceneGUI() {}

        // Scene View Debug GUI - Called only when Show Debug Visuals is activated
        public override void OnModuleSceneDebugGUI()
        {
            if (Target.ShowNormals || Target.ShowOrientation)
            {
                CGPath path = Target.InPath.GetData<CGPath>(out bool isDisposable);
                if (path)
                {
                    Color gizmoOrientationColor = CurvyGlobalManager.GizmoOrientationColor;
                    Color gizmoTangentColor = CurvySplineSegment.GizmoTangentColor;

                    if (Target.ShowOrientation)
                    {
                        DTHandles.PushHandlesColor(gizmoOrientationColor);

                        for (int i = 0; i < path.Count; i++)
                            Handles.DrawLine(path.Positions.Array[i], path.Positions.Array[i] + path.Directions.Array[i] * 2);

                        DTHandles.PopHandlesColor();
                    }

                    if (Target.ShowNormals)
                    {
                        DTHandles.PushHandlesColor(gizmoTangentColor);

                        for (int i = 0; i < path.Count; i++)
                            Handles.DrawLine(path.Positions.Array[i], path.Positions.Array[i] + path.Normals.Array[i] * 2);

                        DTHandles.PopHandlesColor();
                    }
                }
                if (isDisposable)
                    path.Dispose();
            }
        }

        public override void OnModuleDebugGUI()
        {
            CGPath path = Target.InPath.GetData<CGPath>(out bool isDisposable);
            if (path)
            {
                EditorGUILayout.LabelField("VertexCount: " + path.Count.ToString());
            }
            if (isDisposable)
                path.Dispose();
        }

        // Inspector Debug GUI - Called only when Show Debug Values is activated
        //public override void OnModuleDebugGUI() {}

        protected override void OnCustomInspectorGUI()
        {
            DebugVMeshEditor.CheckGeneratorDebugMode(Target);
            base.OnCustomInspectorGUI();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/DebugRasterizedPathEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/DebugVMeshEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 5f5d4bf9eab46c54a858a95a4e04b83b
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.Curvy.Generator.Modules;
using System.Linq;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(DebugVMesh))]
    public class DebugVMeshEditor : CGModuleEditor<DebugVMesh>
    {

        protected override void OnEnable()
        {
            base.OnEnable();
            HasDebugVisuals = true;
            ShowDebugVisuals = true;
        }

        public override void OnModuleSceneDebugGUI()
        {
            CGVMesh vmesh = Target.InData.GetData<CGVMesh>(out bool isDisposable);
            if (vmesh)
            {
                Handles.matrix = Target.Generator.transform.localToWorldMatrix;
                if (Target.ShowVertices)
                    CGEditorUtility.SceneGUIPlot(vmesh.Vertices.Array, vmesh.Vertices.Count, 0.1f, Color.gray);

                if (Target.ShowVertexID)
                {
                    string[] labels = Enumerable.Range(0, vmesh.Count).Select(i => i.ToString()).ToArray();
                    CGEditorUtility.SceneGUILabels(vmesh.Vertices.Array, vmesh.Vertices.Count, labels, Color.black, Vector2.zero);
                }
                if (Target.ShowUV && vmesh.HasUV)
                {
                    string[] labels = Enumerable.Range(0, vmesh.UVs.Count - 1).Select(i => string.Format("({0:0.##},{1:0.##})", vmesh.UVs.Array[i].x, vmesh.UVs.Array[i].y)).ToArray();
                    CGEditorUtility.SceneGUILabels(vmesh.Vertices.Array, vmesh.Vertices.Count, labels, Color.black, Vector2.zero);
                }
                Handles.matrix = Matrix4x4.identity;
            }
            if (isDisposable)
                vmesh.Dispose();
        }

        public override void OnModuleDebugGUI()
        {
            CGVMesh vmesh = Target.InData.GetData<CGVMesh>(out bool isDisposable);
            if (vmesh)
            {
                EditorGUILayout.LabelField("VertexCount: " + vmesh.Count.ToString());
            }
            if (isDisposable)
                vmesh.Dispose();
        }

        protected override void OnCustomInspectorGUI()
        {
            CheckGeneratorDebugMode(Target);
            base.OnCustomInspectorGUI();
        }

        /// <summary>
        /// Clears all existing UI messages and adds one if the generator debug mode is not active
        /// </summary>
        internal static void CheckGeneratorDebugMode(CGModule module)
        {
            module.UIMessages.Clear();
            if (module.Generator.ShowDebug == false)
                module.UIMessages.Add("To display the debug information, activate the Generator's Debug mode either via its toolbar, or its inspector");
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/DebugVMeshEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/DebugVolumeEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 332a17315cf8b0346aea0b8019a9f00f
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.Curvy.Generator.Modules;
using System.Linq;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(DebugVolume))]
    public class DebugVolumeEditor : CGModuleEditor<DebugVolume>
    {

        protected override void OnEnable()
        {
            base.OnEnable();
            HasDebugVisuals = true;
            ShowDebugVisuals = true;
        }

        protected override void OnReadNodes()
        {
            base.OnReadNodes();
            Node.FindTabBarAt("Default").AddTab("Cross Groups", OnCrossGroupTab);
        }

        public override void OnModuleSceneDebugGUI()
        {
            base.OnModuleSceneDebugGUI();
            CGVolume vol = Target.InData.GetData<CGVolume>(out bool isDisposable);
            if (vol)
            {
                Handles.matrix = Target.Generator.transform.localToWorldMatrix;

                if (Target.ShowPathSamples)
                {
                    CGEditorUtility.SceneGUIPlot(vol.Positions.Array, vol.Positions.Count, 0.1f, Target.PathColor);
                    if (Target.ShowIndex)
                    {
                        string[] labels = Enumerable.Range(0, vol.Count).Select(i => i.ToString()).ToArray();
                        CGEditorUtility.SceneGUILabels(vol.Positions.Array, vol.Positions.Count, labels, Color.black, Vector2.zero);
                    }

                    if (Target.ShowNormals)
                    {
                        DTHandles.PushHandlesColor(Target.NormalColor);

                        for (int i = 0; i < vol.Count; i++)
                            Handles.DrawLine(vol.Positions.Array[i], vol.Positions.Array[i] + vol.Normals.Array[i] * 2);

                        DTHandles.PopHandlesColor();
                    }
                }
                if (Target.ShowCrossSamples)
                {
                    int vtLo = Target.LimitCross.From * vol.CrossSize;
                    int vtHi = vtLo + vol.CrossSize;
                    if (!Target.LimitCross.SimpleValue)
                    {
                        vtLo = Target.LimitCross.Low * vol.CrossSize;
                        vtHi = (Target.LimitCross.High + 1) * vol.CrossSize;
                    }

                    vtLo = Mathf.Clamp(vtLo, 0, vol.VertexCount);
                    vtHi = Mathf.Clamp(vtHi, vtLo, vol.VertexCount);
                    var range = vol.Vertices.Array.Skip(vtLo).Take(vtHi - vtLo).ToArray();
                    CGEditorUtility.SceneGUIPlot(range, range.Length, 0.1f, Color.white);

                    if (Target.ShowIndex)
                    {
                        string[] labels = Enumerable.Range(vtLo, vtHi).Select(i => i.ToString()).ToArray();
                        CGEditorUtility.SceneGUILabels(range, range.Length, labels, Color.black, Vector2.zero);
                    }

                    if (Target.ShowMap)
                    {
                        string[] labels = Enumerable.Range(vtLo, vtHi).Select(i => DTMath.SnapPrecision(vol.CrossCustomValues.Array[i], 3).ToString()).ToArray();
                        CGEditorUtility.SceneGUILabels(range, range.Length, labels, new Color(1, 0, 1), new Vector2(10, 20));
                    }

                    if (Target.ShowNormals)
                    {
                        DTHandles.PushHandlesColor(Target.NormalColor);

                        for (int i = vtLo; i < vtHi; i++)
                            Handles.DrawLine(vol.Vertices.Array[i], vol.Vertices.Array[i] + vol.VertexNormals.Array[i] * 2);

                        DTHandles.PopHandlesColor();
                    }
                }
                if (Target.Interpolate)
                {
                    Vector3 pos;
                    Vector3 tan;
                    Vector3 up;
                    vol.InterpolateVolume(Target.InterpolatePathF, Target.InterpolateCrossF, out pos, out tan, out up);
#if UNITY_5_6_OR_NEWER
                    Handles.ConeHandleCap(0, pos, Quaternion.LookRotation(up, tan), 1f, EventType.Repaint);
#else
                    Handles.ConeCap(0, pos, Quaternion.LookRotation(up,tan), 1f);
#endif
                }
                Handles.matrix = Matrix4x4.identity;

                if (isDisposable)
                    vol.Dispose();
            }
        }

        public override void OnModuleDebugGUI()
        {
            CGVolume vol = Target.InData.GetData<CGVolume>(out bool isDisposable);
            if (vol)
            {
                EditorGUILayout.LabelField("VertexCount: " + vol.VertexCount.ToString());
            }
            if (isDisposable)
                vol.Dispose();
        }

        void OnCrossGroupTab(DTInspectorNode node)
        {
            CGVolume vol = Target.InData.GetData<CGVolume>(out bool isDisposable);
            if (vol)
            {
                GUILayout.Label("MaterialGroup.Patch: (MaterialID) Patch Details", EditorStyles.boldLabel);
                for (int i = 0; i < vol.CrossMaterialGroups.Count; i++)
                {
                    for (int p = 0; p < vol.CrossMaterialGroups[i].Patches.Count; p++)
                        GUILayout.Label(string.Format("{0}.{1}: (Mat:{2}) {3}", i, p, vol.CrossMaterialGroups[i].MaterialID, vol.CrossMaterialGroups[i].Patches[p].ToString()));
                }
            }
            if (isDisposable)
                vol.Dispose();
        }

        protected override void OnCustomInspectorGUI()
        {
            DebugVMeshEditor.CheckGeneratorDebugMode(Target);
            base.OnCustomInspectorGUI();
        }

    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/DebugVolumeEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/DeformMeshEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 876c0f57076046442ad41d8487345baa
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEditor;
using FluffyUnderware.Curvy.Generator.Modules;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(DeformMesh))]
    public class DeformMeshEditor : CGModuleEditor<DeformMesh>
    {

        // Scene View GUI - Called only if the module is initialized and configured
        //public override void OnModuleSceneGUI() {}

        // Scene View Debug GUI - Called only when Show Debug Visuals is activated
        //public override void OnModuleSceneDebugGUI() {}

        // Inspector Debug GUI - Called only when Show Debug Values is activated
        //public override void OnModuleDebugGUI() {}

    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/DeformMeshEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/GameObjectToMeshEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a65f5e84bb3e07347ac89a2b08a71877
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(GameObjectToMesh))]
    public class GameObjectToMeshEditor : CGModuleEditor<GameObjectToMesh>
    {

        // Scene View GUI - Called only if the module is initialized and configured
        //public override void OnModuleSceneGUI() {}

        // Scene View Debug GUI - Called only when Show Debug Visuals is activated
        //public override void OnModuleSceneDebugGUI() {}

        // Inspector Debug GUI - Called only when Show Debug Values is activated
        //public override void OnModuleDebugGUI() {}

    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/GameObjectToMeshEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputGameObjectEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 9d4c717ece1291b428da067095f4b11e
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevToolsEditor;
using UnityEditorInternal;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(InputGameObject))]
    public class InputGameObjectsEditor : CGModuleEditor<InputGameObject>
    {
        int selectedIndex;

        protected override void SetupArrayEx(DTFieldNode node, DevTools.ArrayExAttribute attribute)
        {
            node.ArrayEx.drawElementCallback = onGameObjectGUI;
            node.ArrayEx.onSelectCallback = (ReorderableList l) => { selectedIndex = l.index; };
            node.ArrayEx.onAddCallback = (ReorderableList l) =>
            {
                Target.GameObjects.Insert(Mathf.Clamp(l.index + 1, 0, Target.GameObjects.Count), new CGGameObjectProperties());
                EditorUtility.SetDirty(Target);
            };
        }



        void onGameObjectGUI(Rect rect, int index, bool isActive, bool isFocused)
        {
            SerializedProperty prop = serializedObject.FindProperty(string.Format("m_GameObjects.Array.data[{0}]", index));
            if (prop != null)
            {
                rect.height = EditorGUIUtility.singleLineHeight;
                rect.y += 1;

                SerializedProperty mshProp = prop.FindPropertyRelative("m_Object");
                mshProp.objectReferenceValue = EditorGUI.ObjectField(rect, mshProp.objectReferenceValue, typeof(GameObject), true);
            }
        }


        void OnPropertiesGUI()
        {
            SerializedProperty prop = serializedObject.FindProperty(string.Format("m_GameObjects.Array.data[{0}]", selectedIndex));
            if (prop != null)
            {
                EditorGUILayout.PropertyField(prop.FindPropertyRelative("m_Translation"));
                EditorGUILayout.PropertyField(prop.FindPropertyRelative("m_Rotation"));
                EditorGUILayout.PropertyField(prop.FindPropertyRelative("m_Scale"));
            }
        }

        protected override void OnCustomInspectorGUI()
        {
            base.OnCustomInspectorGUI();
            if (Target && selectedIndex < Target.GameObjects.Count && Target.GameObjects[selectedIndex].Object)
            {
                GUILayout.Space(5);
                bool open = true;
                CurvyGUI.Foldout(ref open, "Properties");
                OnPropertiesGUI();
            }
        }

    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputGameObjectEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputMeshEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c127229c77cce034395d42ebc04baf85
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevToolsEditor;
using UnityEditorInternal;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(InputMesh))]
    public class InputMeshEditor : CGModuleEditor<InputMesh>
    {
        int selectedIndex;

        protected override void SetupArrayEx(DTFieldNode node, DevTools.ArrayExAttribute attribute)
        {
            node.ArrayEx.drawElementCallback = OnMeshGUI;
            node.ArrayEx.onSelectCallback = (ReorderableList l) => { selectedIndex = l.index; };
            node.ArrayEx.onAddCallback = (ReorderableList l) =>
            {
                Target.Meshes.Insert(Mathf.Clamp(l.index + 1, 0, Target.Meshes.Count), new CGMeshProperties());
                EditorUtility.SetDirty(Target);
            };
        }



        void OnMeshGUI(Rect rect, int index, bool isActive, bool isFocused)
        {
            SerializedProperty prop = serializedObject.FindProperty(string.Format("m_Meshes.Array.data[{0}]", index));
            if (prop != null)
            {
                rect.height = EditorGUIUtility.singleLineHeight;
                rect.y += 1;
                rect.width -= 100;
                SerializedProperty mshProp = prop.FindPropertyRelative("m_Mesh");
                mshProp.objectReferenceValue = EditorGUI.ObjectField(rect, mshProp.objectReferenceValue, typeof(Mesh), false);

                rect.x += rect.width;
                EditorGUI.LabelField(rect, getFormattedMeshInfo(mshProp.objectReferenceValue as Mesh), DTStyles.HtmlLabel);
            }
        }

        void OnPropertiesGUI()
        {
            SerializedProperty prop = serializedObject.FindProperty(string.Format("m_Meshes.Array.data[{0}]", selectedIndex));
            if (prop != null)
            {
                SerializedProperty matProp = prop.FindPropertyRelative("m_Material");
                if (matProp != null)
                {
                    ReorderableList l = new ReorderableList(serializedObject, matProp, true, true, false, false);
                    l.drawHeaderCallback = (Rect rect) => { GUI.Label(rect, "Materials for " + Target.Meshes[selectedIndex].Mesh.name); };
                    l.drawElementCallback = (Rect rect, int index, bool isActive, bool isFocused) =>
                    {
                        rect.height = EditorGUIUtility.singleLineHeight;
                        SerializedProperty pMat = prop.FindPropertyRelative(string.Format("m_Material.Array.data[{0}]", index));
                        pMat.objectReferenceValue = EditorGUI.ObjectField(rect, pMat.objectReferenceValue, typeof(Material), false);
                    };
                    l.DoLayoutList();
                }
                EditorGUILayout.PropertyField(prop.FindPropertyRelative("m_Translation"));
                EditorGUILayout.PropertyField(prop.FindPropertyRelative("m_Rotation"));
                EditorGUILayout.PropertyField(prop.FindPropertyRelative("m_Scale"));
            }
        }

        protected override void OnCustomInspectorGUI()
        {
            base.OnCustomInspectorGUI();
            if (Target && selectedIndex < Target.Meshes.Count && Target.Meshes[selectedIndex].Mesh)
            {
                GUILayout.Space(5);
                bool open = true;
                CurvyGUI.Foldout(ref open, "Properties");
                OnPropertiesGUI();
            }
        }

        string getFormattedMeshInfo(Mesh mesh)
        {
            if (mesh)
            {
                string has = "<color=#008000>";
                string hasnt = "<color=#800000>";
                string close = "</color>";
                //OPTIM this code calls mesh's properties, just to get their length. Those properties do copy an array, every frame! A solution might be to store their length (or the boolean) in CGMeshProperties
                string norm = (mesh.normals.Length > 0) ? has : hasnt;
                string tan = (mesh.tangents.Length > 0) ? has : hasnt;
                string uv = (mesh.uv.Length > 0) ? has : hasnt;
                string uv2 = (mesh.uv2.Length > 0) ? has : hasnt;
                return string.Format("{1}Nor{0} {2}Tan{0} {3}UV{0} {4}UV2{0}", close, norm, tan, uv, uv2);
            }
            else return "";
        }
    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputMeshEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputSplinePathEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 128e3e284da92124aafc1d1c6f295d51
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(InputSplinePath))]
    public class InputSplinePathEditor : CGModuleEditor<InputSplinePath>
    {

    }


}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputSplinePathEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputSplineShapeEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b4c453ed3cd5e1d47b5a49f02cc592d3
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.Curvy;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(InputSplineShape))]
    public class InputSplineShapeEditor : CGModuleEditor<InputSplineShape>
    {

        protected override void OnEnable()
        {
            base.OnEnable();
            EndIPE();
        }

        internal override void BeginIPE()
        {
            Target.Shape.ShowGizmos = true;

            if (Target.Shape.ControlPointCount > 0)
            {
                Selection.activeObject = Target.Shape.ControlPointsList[0];


                SceneView scn = SceneView.lastActiveSceneView;
                if (scn != null)
                {
                    Transform t = Target.Shape.transform;
                    scn.size = Target.Shape.Bounds.extents.magnitude * 1.5f;
                    scn.FixNegativeSize();
                    scn.LookAt(t.position + t.forward, Quaternion.LookRotation(t.forward, Vector3.up));
                }

                SceneView.RepaintAll();
            }
        }


        /// <summary>
        /// Called for the IPE Target when the module should TRS it's IPE editor to the given values
        /// </summary>
        internal override void OnIPESetTRS(Vector3 position, Quaternion rotation, Vector3 scale)
        {
            if (Target && Target.Shape)
            {
                Target.Shape.transform.localPosition = position;
                Target.Shape.transform.localRotation = rotation;
                Target.Shape.transform.localScale = scale;
            }
        }

        internal override void EndIPE()
        {

        }



    }


}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputSplineShapeEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputSpotsEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: aacae595af62b6b41904baca420e0d2e
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;
using UnityEditorInternal;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(InputSpots))]
    public class InputSpotsEditor : CGModuleEditor<InputSpots>
    {

        protected override void SetupArrayEx(DevToolsEditor.DTFieldNode node, DevTools.ArrayExAttribute attribute)
        {
            base.SetupArrayEx(node, attribute);
            node.ArrayEx.elementHeight *= 4;
            node.ArrayEx.drawElementCallback = OnSpotGUI;
            node.ArrayEx.onAddCallback = (ReorderableList l) =>
            {
                int spotsCount = Target.Spots.Count;

                //value of -1 means nothing selected previously
                var selectedIndex = l.index;
                //when deleting all entries, while having element 0 selected, l.index would be equal to 0, so to handle this:
                selectedIndex = selectedIndex < spotsCount ? selectedIndex : -1;

                CGSpot newSpot;
                int insertionIndex;
                if (selectedIndex < 0)
                {
                    newSpot = new CGSpot(0, Vector3.zero, Quaternion.identity, Vector3.one);
                    insertionIndex = Mathf.Max(spotsCount - 1, 0);
                }
                else
                {
                    newSpot = Target.Spots[selectedIndex];
                    insertionIndex = selectedIndex;
                }

                Target.Spots.Insert(insertionIndex, newSpot);
                EditorUtility.SetDirty(Target);
            };
        }


        void OnSpotGUI(Rect rect, int index, bool isActive, bool isFocused)
        {
            SerializedProperty prop = serializedObject.FindProperty(string.Format("m_Spots.Array.data[{0}]", index.ToString()));
            rect.height = EditorGUIUtility.singleLineHeight;
            if (prop != null)
            {
                EditorGUIUtility.labelWidth = 40;
                Rect r = new Rect(rect);
                GUI.Label(new Rect(r.x, r.y, 30, r.height), "#" + index.ToString());
                EditorGUI.PropertyField(new Rect(r.x + 30, r.y, 115, r.height), prop.FindPropertyRelative("m_Index"));

                EditorGUIUtility.labelWidth = 55;
                r.y += r.height + 1;
                EditorGUI.PropertyField(r, prop.FindPropertyRelative("m_Position"));
                r.y += r.height + 1;
                EditorGUI.PropertyField(r, prop.FindPropertyRelative("m_Rotation"));
                r.y += r.height + 1;
                EditorGUI.PropertyField(r, prop.FindPropertyRelative("m_Scale"));
                if (serializedObject.ApplyModifiedProperties())
                    Target.Dirty = true;
            }
        }

        Vector2 scroll;


        public override void OnInspectorGUI()
        {
            scroll = EditorGUILayout.BeginScrollView(scroll, GUILayout.Height(210));
            base.OnInspectorGUI();
            EditorGUILayout.EndScrollView();
            if (GUILayout.Button("Clear") && EditorUtility.DisplayDialog("Clear List", "Are you sure?", "Yes", "No"))
                Target.Spots.Clear();
        }

    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputSpotsEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputTransformSpotsEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c3be363d24b936045a35d0cee3cd81aa
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;
using UnityEditorInternal;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(InputTransformSpots))]
    public class InputTransformSpotsEditor : CGModuleEditor<InputTransformSpots>
    {
        protected override void SetupArrayEx(DevToolsEditor.DTFieldNode node, DevTools.ArrayExAttribute attribute)
        {
            base.SetupArrayEx(node, attribute);
            node.ArrayEx.elementHeight *= 2;
            node.ArrayEx.drawElementCallback = OnSpotGUI;
            node.ArrayEx.onAddCallback = (ReorderableList l) =>
            {
                int spotsCount = Target.TransformSpots.Count;

                //value of -1 means nothing selected previously
                var selectedIndex = l.index;
                //when deleting all entries, while having element 0 selected, l.index would be equal to 0, so to handle this:
                selectedIndex = selectedIndex < spotsCount ? selectedIndex : -1;

                InputTransformSpots.TransformSpot newSpot;
                int insertionIndex;
                if (selectedIndex < 0)
                {
                    newSpot = new InputTransformSpots.TransformSpot();
                    insertionIndex = Mathf.Max(spotsCount - 1, 0);
                }
                else
                {
                    newSpot = Target.TransformSpots[selectedIndex];
                    insertionIndex = selectedIndex;
                }

                Target.TransformSpots.Insert(insertionIndex, newSpot);
                EditorUtility.SetDirty(Target);
            };
        }


        void OnSpotGUI(Rect rect, int index, bool isActive, bool isFocused)
        {
            SerializedProperty prop = serializedObject.FindProperty(string.Format("transformSpots.Array.data[{0}]", index.ToString()));
            rect.height = EditorGUIUtility.singleLineHeight;
            if (prop != null)
            {
                EditorGUIUtility.labelWidth = 40;
                Rect r = new Rect(rect);
                GUI.Label(new Rect(r.x, r.y, 30, r.height), "#" + index.ToString());
                EditorGUI.PropertyField(new Rect(r.x + 30, r.y, 115, r.height), prop.FindPropertyRelative("index"));

                EditorGUIUtility.labelWidth = 55;
                r.y += r.height + 1;
                EditorGUI.PropertyField(r, prop.FindPropertyRelative("transform"));
                if (serializedObject.ApplyModifiedProperties())
                    Target.Dirty = true;
            }
        }

        Vector2 scroll;


        public override void OnInspectorGUI()
        {
            scroll = EditorGUILayout.BeginScrollView(scroll, GUILayout.Height(210));
            base.OnInspectorGUI();
            EditorGUILayout.EndScrollView();
            if (GUILayout.Button("Clear") && EditorUtility.DisplayDialog("Clear List", "Are you sure?", "Yes", "No"))
                Target.TransformSpots.Clear();
        }

    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputTransformSpotsEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/MixShapesEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 46b6e4aba8f7b00449969382092fa0d5
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator.Modules;
using System.Collections.Generic;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(ModifierMixShapes))]
    public class ModifierMixShapesEditor : CGModuleEditor<ModifierMixShapes>
    {
    }




}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/MixShapesEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierMixPathsEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7c356fb19bdfc11478de97cfb65c6b24
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator.Modules;
using System.Collections.Generic;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(ModifierMixPaths))]
    public class ModifierMixPathsEditor : CGModuleEditor<ModifierMixPaths>
    {
    }




}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierMixPathsEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierPathRelativeTranslationEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6dd872e6ca32ec243b1377d13ab1c075
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEditor;
using FluffyUnderware.Curvy.Generator.Modules;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(ModifierPathRelativeTranslation))]
    public class ModifierPathRelativeTranslationEditor : CGModuleEditor<ModifierPathRelativeTranslation>
    {

        // Scene View GUI - Called only if the module is initialized and configured
        //public override void OnModuleSceneGUI() {}

        // Scene View Debug GUI - Called only when Show Debug Visuals is activated
        //public override void OnModuleSceneDebugGUI() {}

        // Inspector Debug GUI - Called only when Show Debug Values is activated
        //public override void OnModuleDebugGUI() {}

    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierPathRelativeTranslationEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierTRSMeshEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 2aca7d5fc73d5784a88c56b1c7c60b00
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(ModifierTRSMesh))]
    public class ModifierTRSMeshEditor : CGModuleEditor<ModifierTRSMesh>
    {

    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierTRSMeshEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierTRSPathEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 8112efb25a3080b4eb194e5815cf5465
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator.Modules;
using System.Collections.Generic;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(ModifierTRSPath))]
    public class ModifierTRSPathEditor : CGModuleEditor<ModifierTRSPath>
    {
    }




}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierTRSPathEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierTRSShapeEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 995de8b354016994286bf1a9a9e1979c
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(ModifierTRSShape))]
    public class ModifierTRSShapeEditor : CGModuleEditor<ModifierTRSShape>
    {

    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierTRSShapeEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierVariableMixShapesEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c416b73776f822f42a39e134ce855b96
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEditor;
using FluffyUnderware.Curvy.Generator.Modules;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(ModifierVariableMixShapes))]
    public class ModifierVariableMixShapesEditor : CGModuleEditor<ModifierVariableMixShapes>
    {
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierVariableMixShapesEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/NoteEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7d0032aeab6fa1c499d5711ded39d964
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator.Modules;
using System.Collections.Generic;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(Note))]
    public class NoteEditor : CGModuleEditor<Note>
    {
        /*
        // Skip Label
        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
            serializedObject.UpdateIfDirtyOrScript();
            EditorGUILayout.PropertyField(serializedObject.FindProperty("m_Text"), new GUIContent(""));
            serializedObject.ApplyModifiedProperties();
                

        }
         */
    }




}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/NoteEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CanvasSelection.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e3a1be3eec3ac794e8bb30df7860a875
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.DevToolsEditor;
using JetBrains.Annotations;

namespace FluffyUnderware.CurvyEditor.Generator
{
    public class CanvasSelection
    {
        public List<CGModule> SelectedModules = new List<CGModule>();

        public CGModuleLink SelectedLink { get; private set; }
        public CGModule SelectedModule
        {
            get { return (SelectedModules.Count > 0) ? SelectedModules[0] : null; }
        }

        //todo unused, remove it
        public CGGraph Parent;

        /// <summary>
        /// Returns a new array with the <see cref="SelectedLink"/> if any, otherwise <see cref="SelectedModules"/>
        /// </summary>
        public object[] SelectedObjects
        {
            get
            {
                if (SelectedLink != null)
                    return new object[1] { SelectedLink };
                return SelectedModules.ToArray();
            }
        }

        /// <summary>
        /// Empties list and adds into it the <see cref="SelectedLink"/> if any, otherwise <see cref="SelectedModules"/>
        /// </summary>
        public void FillWithSelectedObjects(List<object> list)
        {
            list.Clear();
            if (SelectedLink != null)
                list.Add(SelectedLink);
            else
                list.AddRange(SelectedModules);
        }

        public CanvasSelection(CGGraph parent)
        {
            Parent = parent;
        }

        public void Clear()
        {
            SelectedLink = null;
            SelectedModules.Clear();
            if (CurvyProject.Instance.CGSynchronizeSelection)
                DTSelection.Clear();
        }

        /// <summary>
        /// Selects nothing (null), a link or one or more modules
        /// </summary>
        /// <param name="mod"></param>
        [Obsolete("Use SetSelectionTo, or Clear, depending on your needs")]
        public void Select(params object[] objects)
        {
            Clear();
            if (objects == null || objects.Length == 0)
                return;
            if (objects[0] is List<CGModule>)
                objects = ((List<CGModule>)objects[0]).ToArray();
            if (objects[0] is CGModuleLink)
                SelectedLink = (CGModuleLink)objects[0];
            else
            {
                List<Component> cmp = new List<Component>();
                foreach (object o in objects)
                    if (o is CGModule)
                    {
                        SelectedModules.Add((CGModule)o);
                        cmp.Add((CGModule)o);
                    }

                if (CurvyProject.Instance.CGSynchronizeSelection)
                    DTSelection.SetGameObjects(cmp.ToArray());
            }

        }

        public void SetSelectionTo([NotNull] CGModuleLink link)
        {
            Clear();
            SelectedLink = link;
        }

        public void SetSelectionTo([NotNull] CGModule module)
        {
            SetSelectionTo(new[] { module });
        }

        public void SetSelectionTo([NotNull] IEnumerable<CGModule> modules)
        {
            bool modulesSelectionChanged = modules.SequenceEqual(SelectedModules) == false;

            Clear();

            SelectedModules.AddRange(modules);

            if (modulesSelectionChanged && CurvyProject.Instance.CGSynchronizeSelection)
                DTSelection.SetGameObjects(modules.Select(m => m as Component).ToArray());
        }

        /// <summary>
        /// Adds or removes a module from the selection
        /// </summary>
        // Todo this code does not handle selection synchronisation. fix this before rehabilitating the method if needed
        [Obsolete("Use SetSelectionTo, or Clear, depending on your needs")]
        public void MultiSelectModule(CGModule mod)
        {
            if (mod == null)
                return;
            if (SelectedModules.Contains(mod))
                SelectedModules.Remove(mod);
            else
                SelectedModules.Add(mod);

            //todo why is this nt handling  if (CurvyProject.Instance.CGSynchronizeSelection)

        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CanvasSelection.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CanvasState.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e7b2f43090b47ae4cb2bce3016056f9c
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.DevToolsEditor.Data;

namespace FluffyUnderware.CurvyEditor.Generator
{
    internal class CanvasState
    {
        readonly CGGraph Parent;
        public CanvasSelection Sel { get { return Parent.Sel; } }
        public CanvasUI UI { get { return Parent.UI; } }
        Event EV { get { return Event.current; } }


        public CanvasState(CGGraph parent)
        {
            Parent = parent;
        }


        /// <summary>
        /// The module the mouse is hovering
        /// </summary>
        //todo this and IsMouseOverModule should be tied
        public CGModule MouseOverModule;


        /// <summary>
        /// Storing Event.current.mousePosition (in Canvasspace!)
        /// </summary>
        public Vector2 MousePosition;

        #region Scrolling



        /// <summary>
        /// Canvas scrolling state
        /// </summary>
        [Obsolete("Use ScrollValue, ScrollTarget, ScrollSpeed or IsScrollValueAnimating")]
        public AnimVector2 Scroll = new AnimVector2();

        private Vector2 scrollValue;

        /// <summary>
        /// Setting ScrollValue will stop any ongoing animation
        /// </summary>
        public Vector2 ScrollValue
        {
            get => scrollValue;
            set
            {
                value.x = Mathf.Max(0f, value.x);
                value.y = Mathf.Max(0f, value.y);

                scrollValue = value;
                ScrollTarget = value;
                ScrollSpeed = 0;
            }
        }

        public Vector2 ScrollTarget { get; private set; }
        public float ScrollSpeed { get; private set; }
        public bool IsScrollValueAnimating => ScrollTarget != ScrollValue;

        public void SetScrollTarget(Vector2 target, float speed)
        {
            target.x = Mathf.Max(0f, target.x);
            target.y = Mathf.Max(0f, target.y);

            ScrollTarget = target;
            ScrollSpeed = speed;
        }

        public void UpdateScrollingAnimation(double time)
        {
            scrollValue = Vector2.MoveTowards(scrollValue, ScrollTarget, (float)(ScrollSpeed * time));
        }

        #endregion

        /// <summary>
        /// Left/Top offset of Canvas from window
        /// </summary>
        public Vector2 ClientRectOffset;

        /// <summary>
        /// Whether the mouse is hovering over a module or not
        /// </summary>
        //todo this and MouseOverModule should be tied
        public bool IsMouseOverModule { get; private set; }

        public bool IsMouseOverCanvas
        {
            get
            {
                return ViewPort.Contains(MousePosition);
            }
        }
        /// <summary>
        /// Gets the canvas' scrollview size in window space
        /// </summary>
        public Rect ClientRect { get; private set; }
        /// <summary>
        /// Gets the total canvas size
        /// </summary>
        public Rect CanvasRect { get; private set; }

        /// <summary>
        /// Gets the visible rect of the canvas
        /// </summary>
        public Rect ViewPort
        {
            get
            {
                return new Rect(CanvasRect.x + ScrollValue.x, CanvasRect.y + ScrollValue.y, ClientRect.width, ClientRect.height);
            }
        }

        public Vector2 ViewPortMousePosition
        {
            get
            {
                return MousePosition + ClientRectOffset - ViewPort.min;
            }
        }

        public void SetClientRect(float xOffset, float yOffset, float xspace = 0, float yspace = 0)
        {
            ClientRectOffset = new Vector2(xOffset, yOffset);
            ClientRect = new Rect(ClientRectOffset.x, ClientRectOffset.y, (Parent.position.width - ClientRectOffset.x - xspace), (Parent.position.height - ClientRectOffset.y - yspace));

        }

        /// <summary>
        /// Grows the canvas to include the rect
        /// </summary>
        /// <param name="r">a rect in canvas space</param>
        public void EnlargeCanvasFor(Rect r)
        {
            //if (CurvyGUI.IsLayout)
            CanvasRect = CanvasRect.Include(r);
        }

        public void BeginGUI()
        {
            if (EV.isMouse || EV.type == EventType.DragUpdated || EV.type == EventType.DragExited)
                MousePosition = EV.mousePosition;

            //if (EV.type != EventType.Repaint && EV.type != EventType.Layout)
            //    Debug.Log("BeginGUI()  " + EV.type + "  " + IsMouseOverCanvas);

            if (IsMouseOverCanvas)
                //mouse events
                switch (EV.type)
                {
                    case EventType.MouseDrag:
                        if (!IsDragging)
                        {
                            if (IsMouseOverModule)
                                StartModuleDrag();
                            else
                                StartSelectionRectangleDrag();
                        }
                        break;
                    case EventType.MouseMove:
                    case EventType.MouseUp:
                        //ending drag is done in EventType.MouseMove to handle cases where the drag is finished while the mouse is out of the window, meaning that the MouseUp event is not catched
                        if (IsModuleDrag)
                            EndModuleDrag();
                        if (EV.type == EventType.MouseUp)
                        {
                            if (EV.button == 1)
                                UI.ContextMenu();
                        }
                        break;
                    case EventType.MouseDown:
                        if (IsCanvasDrag == false && EV.button == 2)
                            StartCanvasDrag(false);
                        break;
                }

            //keyboard events
            switch (EV.type)
            {
                case EventType.KeyDown:
                    if (IsCanvasDrag == false && EV.keyCode == KeyCode.Space)
                        StartCanvasDrag(true);
                    break;
                case EventType.KeyUp:
                    if (IsCanvasDrag && isKeyboardCanvasDrag && EV.keyCode == KeyCode.Space)
                        EndCanvasDrag();
                    break;
            }

            if (EV.type != EventType.Layout)
                IsMouseOverModule = false;

            if (IsCanvasDrag)
                EditorGUIUtility.AddCursorRect(ViewPort, MouseCursor.Pan);
        }

        /// <summary>
        /// Processing of Events AFTER Module Window drawing (Beware! Window dragging eats up most events!)
        /// </summary>
        public void EndGUI()
        {
            //if (EV.type != EventType.Repaint && EV.type != EventType.Layout)
            //    Debug.Log("EndGUI()  " + EV.type + "  " + IsMouseOverCanvas);

            if (IsMouseOverCanvas)
                //mouse events
                switch (EV.type)
                {
                    case EventType.MouseDrag:
                        // Drag canvas (i.e. change scroll offset)
                        if (IsCanvasDrag)
                        {
                            ScrollValue -= EV.delta;
                        }
                        break;
                    case EventType.MouseMove:
                    case EventType.MouseUp:
                        if (EV.type == EventType.MouseUp)
                        {
                            if (EV.button == 0 && !IsDragging)
                            {
                                if (Sel.SelectedLink && !MouseOverLink(Sel.SelectedLink)
                                    || (Sel.SelectedModule && !MouseOverModule))
                                    Sel.Clear();
                            }

                            // Multi Selection
                            if (IsSelectionRectDrag)
                                EndSelectionRectangleDrag();

                            Parent.StatusBar.Clear();
                        }

                        //ending drag is done in EventType.MouseMove to handle cases where the drag is finished while the mouse is out of the window, meaning that the MouseUp event is not caught
                        {
                            if (IsLinkDrag)
                                EndLinkDrag();

                            // Multi Selection
                            if (IsSelectionRectDrag)
                                CancelSelectionRectangleDrag();

                            if (IsCanvasDrag && isKeyboardCanvasDrag == false)
                                EndCanvasDrag();
                        }
                        break;
                    case EventType.DragUpdated:
                        UI.HandleDragDropProgress();
                        break;
                    case EventType.DragPerform:
                        UI.HandleDragDropDone();
                        break;
                }

            //keyboard events
            switch (EV.type)
            {
                case EventType.KeyDown:
                    switch (EV.keyCode)
                    {
                        case KeyCode.Delete:
                            CanvasUI.DeleteSelection(UI);
                            break;
                        case KeyCode.A:
                            if (EV.control)
                                CanvasUI.SelectAll(UI);
                            break;
                        case KeyCode.C:
                            if (EV.control)
                                CanvasUI.CopySelection(UI);
                            break;
                        case KeyCode.V:
                            if (EV.control)
                                CanvasUI.PastSelection(UI);
                            break;
                        case KeyCode.X:
                            if (EV.control)
                                CanvasUI.CutSelection(UI);
                            break;
                        case KeyCode.D:
                            if (EV.control)
                            {
                                CanvasUI.CopySelection(UI);
                                CanvasUI.PastSelection(UI);
                            }
                            break;
                    }
                    break;
            }
        }

        public void ViewPortRegisterWindow(CGModule module)
        {
            Rect winRect = module.Properties.Dimensions;
            EnlargeCanvasFor(winRect);

            if (!IsMouseOverModule && EV.type != EventType.Layout)
            {
                IsMouseOverModule = winRect.Contains(EV.mousePosition);
                MouseOverModule = (IsMouseOverModule) ? module : null;
            }
        }

        /// <summary>
        /// Sets the Canvas Rectangle so that it includes all the given modules
        /// </summary>
        public void ComputeCanvasRectangle(List<CGModule> modules)
        {
            CanvasRect = new Rect(0, 0, 0, 0);
            foreach (CGModule mod in modules)
                if (mod != null)
                    ViewPortRegisterWindow(mod);
        }

        public void FocusSelection()
        {
            CGModule selectedModule = Sel.SelectedModule;
            if (selectedModule)
            {
                Vector2 scrollDelta = GetFocusDelta(selectedModule);
                SetScrollTarget(ScrollValue + scrollDelta, Mathf.Max(60f, scrollDelta.magnitude * 4f));
            }
        }

        /// <summary>
        /// Returns the translation the viewport needs to do to focus on the given module
        /// </summary>
        /// <param name="targetModule">The module to focus on</param>

        public Vector2 GetFocusDelta(CGModule targetModule)
        {
            Rect focusedDimensions = targetModule.Properties.Dimensions;

            Rect viewPort = ViewPort;

            //add a margin, to include the module's highlight in the screen
            const float xMargin = 5;
            const float yMargin = 5;
            focusedDimensions.x -= xMargin;
            focusedDimensions.y -= yMargin;
            //the + 17 is to take into account the pixels taken by the scroll bar. I am always assuming the scroll bar is visible. An improvement is to check if they are actually there or not.
            focusedDimensions.width += 2 * xMargin + 17;
            focusedDimensions.height += 2 * yMargin + 17;

            //clamp the focused rectangle to what can be possibly seen within the viewport
            focusedDimensions.width = Mathf.Min(focusedDimensions.width, viewPort.width);
            focusedDimensions.height = Mathf.Min(focusedDimensions.height, viewPort.height);

            //clamp the focused rectangle to the canvas dimensions
            focusedDimensions.xMax = Math.Min(focusedDimensions.xMax, CanvasRect.width);
            focusedDimensions.yMax = Math.Min(focusedDimensions.yMax, CanvasRect.height);
            focusedDimensions.xMin = Math.Max(focusedDimensions.xMin, CanvasRect.x);
            focusedDimensions.yMin = Math.Max(focusedDimensions.yMin, CanvasRect.y);


            Vector2 delta = Vector2.zero;
            if (focusedDimensions.xMax > viewPort.xMax)
                delta.x = focusedDimensions.xMax - viewPort.xMax;
            else if (focusedDimensions.xMin < viewPort.xMin)
                delta.x = focusedDimensions.xMin - viewPort.xMin;

            if (focusedDimensions.yMax > viewPort.yMax)
                delta.y = focusedDimensions.yMax - viewPort.yMax;
            else if (focusedDimensions.yMin < viewPort.yMin)
                delta.y = focusedDimensions.yMin - viewPort.yMin;
            return delta;
        }

        public bool MouseOverLink(CGModuleLink link)
        {
            if (link == null)
                return false;

            CGModuleOutputSlot outSlot = Parent.Generator.ModulesByID[link.ModuleID].GetOutputSlot(link.SlotName);
            CGModuleInputSlot inSlot = Parent.Generator.ModulesByID[link.TargetModuleID].GetInputSlot(link.TargetSlotName);

            Vector3 startPosition = outSlot.Origin;
            Vector3 endPosition = inSlot.Origin;

            CGGraph.GetLinkBezierTangents(
                startPosition,
                endPosition,
                out Vector2 startTangent,
                out Vector2 endTangent);

            return HandleUtility.DistancePointBezier(EV.mousePosition, startPosition, endPosition, startTangent, endTangent) <= CGGraph.LinkSelectionDistance;
        }


        #region Drag handling

        /// <summary>
        /// Gets whether the user is currently dragging anything (Canvas, Module, Link, etc..)
        /// </summary>
        public bool IsDragging
        {
            get { return IsCanvasDrag || IsModuleDrag || IsLinkDrag || IsSelectionRectDrag; }
        }

        #region CanvasDrag

        public bool IsCanvasDrag;
        /// <summary>
        /// Was the Canvas drag initiated by the keyboard or the mouse?
        /// </summary>
        private bool isKeyboardCanvasDrag;

        private void StartCanvasDrag(bool isKeyboardInitiated)
        {
            IsCanvasDrag = true;
            isKeyboardCanvasDrag = isKeyboardInitiated;
        }

        private void EndCanvasDrag()
        {
            IsCanvasDrag = false;
        }

        #endregion
        #region Module Drag

        public bool IsModuleDrag;

        private void StartModuleDrag()
        {
            IsModuleDrag = true;
        }

        private void EndModuleDrag()
        {
            IsModuleDrag = false;
        }

        #endregion

        //The rest of the code handling links dragging is in CGGraph.cs
        #region Link Drag


        public CGModuleOutputSlot LinkDragFrom;

        /// <summary>
        /// Gets whether a link is currently dragged
        /// </summary>
        public bool IsLinkDrag
        {
            get { return LinkDragFrom != null; }
        }

        public CGModuleOutputSlot AutoConnectFrom;

        private void EndLinkDrag()
        {
            if (EV.control)
            {
                AutoConnectFrom = LinkDragFrom;
                UI.AddModuleQuickmenu(LinkDragFrom);
            }

            LinkDragFrom = null;
        }

        //The rest of the code handling links dragging is in CGGraph.cs


        #endregion

        #region Selection Rectangle Drag

        public bool IsSelectionRectDrag;

        /// <summary>
        /// Starting position of selection drag
        /// </summary>
        public Vector2 SelectionRectStart;

        private void StartSelectionRectangleDrag()
        {
            IsSelectionRectDrag = true;
            SelectionRectStart = ViewPortMousePosition;
        }

        public void HandleMultiSelection()
        {
            Rect selectionRect = new Rect().SetBetween(SelectionRectStart, ViewPortMousePosition);
            selectionRect.position -= ClientRectOffset - ViewPort.position;

            Sel.SetSelectionTo(Parent.Modules.Where(m => selectionRect.Overlaps(m.Properties.Dimensions, true)).ToList());
        }

        private void EndSelectionRectangleDrag()
        {
            HandleMultiSelection();
            IsSelectionRectDrag = false;
        }
        private void CancelSelectionRectangleDrag()
        {
            IsSelectionRectDrag = false;
        }

        #endregion

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CanvasState.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CanvasUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6ce3f6137153735498d55b2fce2ad997
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.Reflection;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevTools;
using Object = UnityEngine.Object;

namespace FluffyUnderware.CurvyEditor.Generator
{


    public class CanvasUI
    {
        public static CGClipboard Clipboard = new CGClipboard();
        readonly CGGraph Parent;
        /// <summary>
        /// Gets ModuleInfo->Module Type mapping
        /// </summary>
        SortedDictionary<ModuleInfoAttribute, System.Type> TypeByModuleInfo = new SortedDictionary<ModuleInfoAttribute, System.Type>();
        /// <summary>
        /// Gets Modules that accept a certain input data type
        /// </summary>
        readonly Dictionary<System.Type, List<ModuleInfoAttribute>> ModuleInfoByInput = new Dictionary<System.Type, List<ModuleInfoAttribute>>();

        /// <summary>
        /// Used to get InputSlotInfo from (ModuleInfoAttribute,InputType) couples
        /// </summary>
        readonly Dictionary<ModuleInfoAttribute, Dictionary<Type, InputSlotInfo>> inputSlotInfoByModuleInfoAndInputType = new Dictionary<ModuleInfoAttribute, Dictionary<Type, InputSlotInfo>>();
        readonly SortedDictionary<string, string> TemplatesByMenuName = new SortedDictionary<string, string>();

        CanvasSelection Sel { get { return Parent.Sel; } }
        CanvasState Canvas { get { return Parent.Canvas; } }

        public CanvasUI(CGGraph parent)
        {
            Parent = parent;
            LoadData();
        }

        public void AddModuleQuickmenu(CGModuleOutputSlot forOutputSlot)
        {
            GenericMenu mnu = new GenericMenu();
            List<ModuleInfoAttribute> matches;
            System.Type outType = forOutputSlot.OutputInfo.DataType;
            while (typeof(CGData).IsAssignableFrom(outType) && outType != typeof(CGData))
            {

                if (ModuleInfoByInput.TryGetValue(outType, out matches))
                {
                    foreach (ModuleInfoAttribute mi in matches)
                    {
                        InputSlotInfo si = inputSlotInfoByModuleInfoAndInputType[mi][outType];
                        if (CGModuleInputSlot.AreInputAndOutputSlotsCompatible(si, typeof(IOnRequestProcessing).IsAssignableFrom(TypeByModuleInfo[mi]), forOutputSlot.OutputInfo, forOutputSlot.OnRequestModule != null))
                            mnu.AddItem(new GUIContent(mi.MenuName), false, CTXOnAddAndConnectModule, mi);
                    }
                    mnu.ShowAsContext();
                }
                outType = outType.BaseType;
            }
        }



        void AddMenuItem(GenericMenu mnu, string item, GenericMenu.MenuFunction2 func, object userData, bool enabled = true)
        {
            if (enabled)
                mnu.AddItem(new GUIContent(item), false, func, userData);
            else
                mnu.AddDisabledItem(new GUIContent(item));
        }

        void AddMenuItem(GenericMenu mnu, string item, GenericMenu.MenuFunction func, bool enabled = true)
        {
            if (enabled)
                mnu.AddItem(new GUIContent(item), false, func);
            else
                mnu.AddDisabledItem(new GUIContent(item));
        }

        public void ContextMenu()
        {
            GenericMenu mnu = new GenericMenu();
            // Add/<Modules>
            List<ModuleInfoAttribute> miNames = new List<ModuleInfoAttribute>(TypeByModuleInfo.Keys);

            foreach (ModuleInfoAttribute mi in miNames)
                AddMenuItem(mnu, "Add/" + mi.MenuName, CTXOnAddModule, mi);
            // Add/<Templates>


            foreach (string tplName in TemplatesByMenuName.Keys)
                AddMenuItem(mnu, "Add Template/" + tplName, CTXOnAddTemplate, tplName);

            mnu.AddSeparator("");
            AddMenuItem(mnu, "Reset", CTXOnReset, Sel.SelectedModules.Count > 0);
            mnu.AddSeparator("");
            AddMenuItem(mnu, "Cut", () => CutSelection(this), Sel.SelectedModules.Count > 0);
            AddMenuItem(mnu, "Copy", () => CopySelection(this), Sel.SelectedModules.Count > 0);
            AddMenuItem(mnu, "Paste", () => PastSelection(this), !Clipboard.Empty);
            mnu.AddSeparator("");
            AddMenuItem(mnu, "Delete", () => DeleteSelection(this), Sel.SelectedModules.Count > 0 || Sel.SelectedLink != null);
            mnu.AddSeparator("");
            AddMenuItem(mnu, "Select all", () => SelectAll(this));
            mnu.ShowAsContext();
        }

        void CTXOnReset()
        {
            foreach (CGModule mod in Sel.SelectedModules)
                mod.Reset();
        }

        void CTXOnAddModule(object userData)
        {
            ModuleInfoAttribute mi = (ModuleInfoAttribute)userData;
            CGModule mod = AddModule(TypeByModuleInfo[mi]);
            mod.Properties.Dimensions = mod.Properties.Dimensions.SetPosition(Canvas.MousePosition);
        }

        void CTXOnAddAndConnectModule(object userData)
        {
            if (!Canvas.AutoConnectFrom)
                return;

            ModuleInfoAttribute mi = (ModuleInfoAttribute)userData;
            CGModule mod = AddModule(TypeByModuleInfo[mi]);

            mod.Properties.Dimensions = mod.Properties.Dimensions.SetPosition(Canvas.MousePosition);

            foreach (CGModuleInputSlot inputSlot in mod.Input)
                if (inputSlot.CanLinkTo(Canvas.AutoConnectFrom))
                {
                    Canvas.AutoConnectFrom.LinkTo(inputSlot);
                    return;
                }

        }

        void CTXOnAddTemplate(object userData)
        {
            string tplPath;
            if (TemplatesByMenuName.TryGetValue((string)userData, out tplPath))
                CGEditorUtility.LoadTemplate(Parent.Generator, tplPath, Canvas.MousePosition);
        }

        public CGModule AddModule(System.Type type)
        {
            CGModule mod = Parent.Generator.AddModule(type);
            Undo.RegisterCreatedObjectUndo(mod, "Create Module");
            return mod;
        }

        /// <summary>
        /// Deletes a link or one or more modules (Undo-Aware!)
        /// </summary>
        /// <param name="objects"></param>
        public void Delete(params object[] objects)
        {
            if (objects == null || objects.Length == 0)
                return;
            if (objects[0] is CGModuleLink)
                DeleteLink((CGModuleLink)objects[0]);
            else
                foreach (CGModule m in objects)
                    m.Delete();
        }

        public void DeleteLink(CGModuleLink link)
        {
            CGModuleOutputSlot sOut = Parent.Generator.GetModule(link.ModuleID, true).OutputByName[link.SlotName];
            CGModuleInputSlot sIn = Parent.Generator.GetModule(link.TargetModuleID, true).InputByName[link.TargetSlotName];
            sOut.UnlinkFrom(sIn);
        }

        public void LoadData()
        {
            // Build TypeByModuleInfo and ModuleInfoByInput dictionaries
            TypeByModuleInfo.Clear();
            ModuleInfoByInput.Clear();
            inputSlotInfoByModuleInfoAndInputType.Clear();
            TypeByModuleInfo = new SortedDictionary<ModuleInfoAttribute, System.Type>(typeof(CGModule).GetAllTypesWithAttribute<ModuleInfoAttribute>());

            foreach (KeyValuePair<ModuleInfoAttribute, Type> kv in TypeByModuleInfo)
            {
                Type moduleType = kv.Value;
                ModuleInfoAttribute moduleInfoAttribute = kv.Key;

                FieldInfo[] fields = moduleType.GetFields(BindingFlags.Public | BindingFlags.Instance);
                foreach (FieldInfo fieldInfo in fields)
                    if (fieldInfo.FieldType == typeof(CGModuleInputSlot))
                    {
                        object[] slotAttrib = fieldInfo.GetCustomAttributes(typeof(InputSlotInfo), true);
                        if (slotAttrib.Length > 0)
                        {
                            InputSlotInfo inputSlotInfo = (InputSlotInfo)slotAttrib[0];
                            List<ModuleInfoAttribute> moduleInfoAttributes;
                            for (int x = 0; x < inputSlotInfo.DataTypes.Length; x++)
                            {
                                Type dataType = inputSlotInfo.DataTypes[x];
                                if (!ModuleInfoByInput.TryGetValue(dataType, out moduleInfoAttributes))
                                {
                                    moduleInfoAttributes = new List<ModuleInfoAttribute>();
                                    ModuleInfoByInput.Add(dataType, moduleInfoAttributes);
                                }

                                moduleInfoAttributes.Add(moduleInfoAttribute);

                                if (inputSlotInfoByModuleInfoAndInputType.ContainsKey(moduleInfoAttribute) == false)
                                    inputSlotInfoByModuleInfoAndInputType[moduleInfoAttribute] = new Dictionary<Type, InputSlotInfo>();
                                if (inputSlotInfoByModuleInfoAndInputType[moduleInfoAttribute].ContainsKey(dataType) == false)
                                    inputSlotInfoByModuleInfoAndInputType[moduleInfoAttribute][dataType] = inputSlotInfo;
                            }
                        }
                    }
            }
            // load Templates
            ReloadTemplates();
        }

        /// <summary>
        /// Reloads the available templates from the prefabs in the Templates folder
        /// </summary>
        public void ReloadTemplates()
        {
            TemplatesByMenuName.Clear();
            string[] baseFolders;
            if (AssetDatabase.IsValidFolder("Assets/" + CurvyProject.Instance.CustomizationRootPath + CurvyProject.RELPATH_CGTEMPLATES))
                baseFolders = new string[2] { "Assets/" + CurvyEditorUtility.GetPackagePath("CG Templates"), "Assets/" + CurvyProject.Instance.CustomizationRootPath + CurvyProject.RELPATH_CGTEMPLATES };
            else
                baseFolders = new string[1] { "Assets/" + CurvyEditorUtility.GetPackagePath("CG Templates") };

            string[] prefabs = AssetDatabase.FindAssets("t:gameobject", baseFolders);

            foreach (string guid in prefabs)
            {
                string path = AssetDatabase.GUIDToAssetPath(guid);
                // Store under a unique menu name
                string name = AssetDatabase.LoadAssetAtPath(path, typeof(Transform)).name;
                string menuPath = System.IO.Path.GetDirectoryName(path).Replace(System.IO.Path.DirectorySeparatorChar.ToString(), "/");
                foreach (string s in baseFolders)
                    menuPath = menuPath.TrimStart(s);
                menuPath = menuPath.TrimStart('/');

                string menuName = string.IsNullOrEmpty(menuPath)
                    ? name
                    : menuPath + "/" + name;
                int i = 0;
                while (TemplatesByMenuName.ContainsKey((i == 0)
                    ? menuName
                    : menuName + i.ToString()))
                    i++;
                TemplatesByMenuName.Add((i == 0)
                    ? menuName
                    : menuName + i.ToString(), path);
            }
        }

        public void HandleDragDropProgress()
        {
            DragAndDrop.visualMode = DragAndDropVisualMode.Generic;
        }

        public void HandleDragDropDone()
        {
            Vector2 mousePosition = Event.current.mousePosition;

            foreach (Object @object in DragAndDrop.objectReferences)
            {
                CGModule module = null;
                if (@object is GameObject gameObject)
                {
                    CurvySpline spline = gameObject.GetComponent<CurvySpline>();
                    if (spline)
                    {
                        CurvyShape shape = gameObject.GetComponent<CurvyShape>();
                        if (shape)
                        {
                            InputSplineShape inputModule = Parent.Generator.AddModule<InputSplineShape>();
                            inputModule.Shape = spline;
                            module = inputModule;
                        }
                        else
                        {
                            InputSplinePath inputModule = Parent.Generator.AddModule<InputSplinePath>();
                            inputModule.Spline = spline;
                            module = inputModule;
                        }
                    }
                    else
                    {
                        InputGameObject inputModule = Parent.Generator.AddModule<InputGameObject>();
                        inputModule.GameObjects.Add(new CGGameObjectProperties(gameObject));
                        module = inputModule;
                    }

                }
                else if (@object is Mesh mesh)
                {
                    InputMesh inputModule = Parent.Generator.AddModule<InputMesh>();
                    inputModule.Meshes.Add(new CGMeshProperties(mesh));
                    module = inputModule;
                }

                if (module)
                {
                    module.Properties.Dimensions.position = mousePosition;
                    module.Properties.Dimensions.xMin -= module.Properties.MinWidth / 2;
                    mousePosition.y += module.Properties.Dimensions.height;
                }
            }

            DragAndDrop.AcceptDrag();
        }

        #region shortcut/contextual menu shared commands

        public static void SelectAll(CanvasUI ui)
        {
            ui.Sel.SetSelectionTo(ui.Parent.Modules);
        }

        public static void DeleteSelection(CanvasUI ui)
        {
            ui.Delete(ui.Sel.SelectedObjects);
            ui.Sel.Clear();
        }

        public static void CopySelection(CanvasUI ui)
        {
            Clipboard.CopyModules(ui.Sel.SelectedModules);
        }
        public static void CutSelection(CanvasUI ui)
        {
            Clipboard.CutModules(ui.Sel.SelectedModules);
        }
        public static void PastSelection(CanvasUI ui)
        {
            // relative position between modules were kept, but take current mouse position as reference!
            Vector2 off = ui.Canvas.MousePosition - Clipboard.Modules[0].Properties.Dimensions.position;
            ui.Sel.SetSelectionTo(Clipboard.PasteModules(ui.Parent.Generator, off));
        }

        #endregion
    }

    public class CGClipboard
    {
        public enum ClipboardMode
        {
            Cut,
            Copy
        }

        public ClipboardMode Mode = ClipboardMode.Copy;

        public List<CGModule> Modules = new List<CGModule>();


        public bool Empty { get { return Modules.Count == 0; } }

        public CurvyGenerator ParentGenerator
        {
            get
            {
                return (Modules.Count > 0) ? Modules[0].Generator : null;
            }
        }

        public void CutModules(IList<CGModule> modules)
        {
            Mode = ClipboardMode.Cut;
            copyInternal(modules);
        }

        public void CopyModules(IList<CGModule> modules)
        {
            Mode = ClipboardMode.Copy;
            copyInternal(modules);
        }

        public void Clear()
        {
            Modules.Clear();

        }

        /// <summary>
        /// Paste all Clipboard modules
        /// </summary>
        /// <param name="target">the generator to paste to</param>
        /// <param name="positionOffset">Canvas offset to use</param>
        /// <returns>the new modules</returns>
        public List<CGModule> PasteModules(CurvyGenerator target, Vector2 positionOffset)
        {
            List<CGModule> res = CGEditorUtility.CopyModules(Modules, target, positionOffset);
            if (Mode == ClipboardMode.Cut)
                foreach (CGModule mod in Modules)
                    ParentGenerator.DeleteModule(mod);
            Clear();

            return res;
        }

        void copyInternal(IList<CGModule> modules)
        {
            Modules.Clear();
            Modules.AddRange(modules);
        }


    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CanvasUI.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CGEditorUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a3160a5daacc00349af244daf1e13e36
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Utils;
using System.Reflection;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.DevToolsEditor.Extensions;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevTools;
using FluffyUnderware.Curvy;
using System.IO;

namespace FluffyUnderware.CurvyEditor.Generator
{
    public static class CGEditorUtility
    {

        static List<CGModuleOutputSlot> findOutputSlots(CurvyGenerator generator, bool includeOnRequestProcessing, System.Type filterSlotDataType = null)
        {
            List<CGModule> modules = generator.GetModules(includeOnRequestProcessing);
            List<CGModuleOutputSlot> res = new List<CGModuleOutputSlot>();
            foreach (CGModule mod in modules)
                res.AddRange(mod.GetOutputSlots(filterSlotDataType));
            return res;
        }

        public static void ShowOutputSlotsMenu(GenericMenu.MenuFunction2 func, System.Type filterSlotDataType = null)
        {
            GenericMenu mnu = new GenericMenu();
            CurvyGenerator[] generators = Component.FindObjectsOfType<CurvyGenerator>();

            mnu.AddItem(new GUIContent("none"), false, func, null);

            foreach (CurvyGenerator gen in generators)
            {
                List<CGModuleOutputSlot> slots = findOutputSlots(gen, false, filterSlotDataType);
                foreach (CGModuleOutputSlot slot in slots)
                    mnu.AddItem(new GUIContent(gen.name + "/" + slot.Module.ModuleName + "/" + slot.Info.DisplayName), false, func, slot);
            }

            mnu.ShowAsContext();
        }

        public static List<CGModule> CopyModules(IList<CGModule> sourceModules, CurvyGenerator target, Vector2 canvasPosition)
        {
            List<CGModule> res = new List<CGModule>();

            Dictionary<int, int> IDMapping = new Dictionary<int, int>();


            // I. Copy Module, store mapping from old to new ID
            foreach (CGModule mod in sourceModules)
            {
                int oldID = mod.UniqueID;
                // Duplicate module GameObject and parent it to the target Generator, also ensure a unique module name and module id
                CGModule newMod = mod.CopyTo(target);
                res.Add(newMod);
                IDMapping.Add(oldID, newMod.UniqueID);
                newMod.Properties.Dimensions.position += canvasPosition;

                // ! Handle managed Resources !
                /*
                var resourceFields = DTUtility.GetFieldsWithAttribute(mod.GetType(), typeof(CGResourceManagerAttribute), BindingFlags.Instance | BindingFlags.NonPublic);
                foreach (var fi in resourceFields)
                {
                    var v = fi.GetValue(mod) as Component;
                    // Managed?
                    if (v != null && v.transform.parent == mod.transform)
                    {
                        var newV = v.DuplicateGameObject(newMod.transform);
                        if (newV != null)
                            fi.SetValue(newMod, newV);
                    }
                }*/
                //newMod.renameManagedResourcesINTERNAL();

            }
            // II. Update Links to use the new IDs
            for (int m = 0; m < res.Count; m++)
            {
                CGModule mod = res[m];
                int newID = mod.UniqueID;

                for (int i = mod.InputLinks.Count - 1; i >= 0; i--)
                {
                    // if target module was copied as well, change both IDs
                    int newTargetID;
                    if (IDMapping.TryGetValue(mod.InputLinks[i].TargetModuleID, out newTargetID))
                    {
                        mod.InputLinks[i].SetModuleIDIINTERNAL(newID, newTargetID);
                    }
                    else // otherwise delete link
                        mod.InputLinks.RemoveAt(i);
                }
                for (int i = mod.OutputLinks.Count - 1; i >= 0; i--)
                {
                    // if target module was copied as well, change both IDs
                    int newTargetID;
                    if (IDMapping.TryGetValue(mod.OutputLinks[i].TargetModuleID, out newTargetID))
                    {
                        mod.OutputLinks[i].SetModuleIDIINTERNAL(newID, newTargetID);
                    }
                    else // otherwise delete link
                        mod.OutputLinks.RemoveAt(i);
                }
                mod.ReInitializeLinkedSlots();
            }


            /// III. Reinitialize target generator
            target.Initialize(true);

            return res;
        }

        public static bool CreateTemplate(IList<CGModule> modules, string absFilePath)
        {
            if (!Directory.Exists(Path.GetDirectoryName(absFilePath)))
            {
                Directory.CreateDirectory(Path.GetDirectoryName(absFilePath));

            }
            // Convert absolute to relative path
            absFilePath = absFilePath.Replace(Application.dataPath, "Assets");
            if (modules.Count == 0 || string.IsNullOrEmpty(absFilePath))
                return false;

            CurvyGenerator assetGenerator = CurvyGenerator.Create();
            assetGenerator.name = Path.GetFileNameWithoutExtension(absFilePath);
            CopyModules(modules, assetGenerator, Vector2.zero);
            foreach (CGModule mod in assetGenerator.Modules)
                mod.OnTemplateCreated();
            assetGenerator.ArrangeModules();
            PrefabUtility.SaveAsPrefabAsset(assetGenerator.gameObject, absFilePath);
            GameObject.DestroyImmediate(assetGenerator.gameObject);
            AssetDatabase.Refresh();
            return true;

        }

        public static List<CGModule> LoadTemplate(CurvyGenerator generator, string path, Vector2 canvasPosition)
        {
            CurvyGenerator srcGen = AssetDatabase.LoadAssetAtPath(path, typeof(CurvyGenerator)) as CurvyGenerator;
            if (srcGen)
                return CGEditorUtility.CopyModules(srcGen.Modules, generator, canvasPosition);
            else
                return null;
        }

        public static void SetModulesExpandedState(bool expanded, params CGModule[] modules)
        {
            foreach (CGModule mod in modules)
                mod.Properties.Expanded.target = expanded;
        }

        public static void SceneGUIPlot(Vector3[] vertices, int verticesCount, float size, Color col)
        {
            DTHandles.PushHandlesColor(col);
            for (int index = 0; index < verticesCount; index++)
            {
                Vector3 v = vertices[index];
                Handles.CubeHandleCap(0, v, Quaternion.identity, size * HandleUtility.GetHandleSize(v), EventType.Repaint);
            }

            DTHandles.PopHandlesColor();
        }
        
        [Obsolete("Use the other overload or make a copy of this method")]
        public static void SceneGUIPlot(IList<Vector3> vertices, float size, Color col)
        {
            DTHandles.PushHandlesColor(col);
            for (int index = 0; index < vertices.Count; index++)
            {
                Vector3 v = vertices[index];
                Handles.CubeHandleCap(0, v, Quaternion.identity, size * HandleUtility.GetHandleSize(v), EventType.Repaint);
            }

            DTHandles.PopHandlesColor();
        }

        public static void SceneGUILabels(Vector3[] vertices, int verticesCount, IList<string> labels, Color col, Vector2 offset)
        {
            Dictionary<Vector3, string> labelsByPos = new Dictionary<Vector3, string>();
            int ub = Mathf.Min(verticesCount, labels.Count);

            for (int i = 0; i < ub; i++)
            {
                string val;
                if (labelsByPos.TryGetValue(vertices[i], out val))
                    labelsByPos[vertices[i]] = val + "," + labels[i];
                else
                    labelsByPos.Add(vertices[i], labels[i]);
            }

            GUIStyle style = new GUIStyle(EditorStyles.boldLabel);
            style.normal.textColor = col;
            foreach (KeyValuePair<Vector3, string> kv in labelsByPos)
                Handles.Label(DTHandles.TranslateByPixel(kv.Key, offset), kv.Value, style);

        }
        
        [Obsolete("Use the other overload or make a copy of this method")]
        public static void SceneGUILabels(IList<Vector3> vertices, IList<string> labels, Color col, Vector2 offset)
        {
            Dictionary<Vector3, string> labelsByPos = new Dictionary<Vector3, string>();
            int ub = Mathf.Min(vertices.Count, labels.Count);

            for (int i = 0; i < ub; i++)
            {
                string val;
                if (labelsByPos.TryGetValue(vertices[i], out val))
                    labelsByPos[vertices[i]] = val + "," + labels[i];
                else
                    labelsByPos.Add(vertices[i], labels[i]);
            }

            GUIStyle style = new GUIStyle(EditorStyles.boldLabel);
            style.normal.textColor = col;
            foreach (KeyValuePair<Vector3, string> kv in labelsByPos)
                Handles.Label(DTHandles.TranslateByPixel(kv.Key, offset), kv.Value, style);

        }

        public static void SceneGUIPoly(IEnumerable<Vector3> vertices, Color col)
        {
            DTHandles.PushHandlesColor(col);

            Handles.DrawPolyLine(vertices as Vector3[]);
            DTHandles.PopHandlesColor();
        }


    }


}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CGEditorUtility.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CGGraph.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c4d6374fae71341468322075901f0d3b
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevToolsEditor.Extensions;
using FluffyUnderware.Curvy.Generator;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.DevToolsEditor;
using UnityEditor.AnimatedValues;
using FluffyUnderware.DevTools;
using System.Reflection;
using JetBrains.Annotations;
using UnityEditor.Experimental.SceneManagement;
using UnityEditor.SceneManagement;
using UnityEngine.Assertions;
using UnityEngine.SceneManagement;

namespace FluffyUnderware.CurvyEditor.Generator
{
    public class CGGraph : EditorWindow
    {

        #region ### Static Properties ###

        public static CGModuleEditorBase InPlaceEditTarget;
        public static CGModuleEditorBase InPlaceEditInitiatedBy;

        /// <summary>
        /// Initiates an IPE session or terminates it
        /// </summary>
        public static void SetIPE(IExternalInput target = null, CGModuleEditorBase initiatedBy = null)
        {

            if (InPlaceEditTarget != null)
                InPlaceEditTarget.EndIPE();

            InPlaceEditInitiatedBy = initiatedBy;

            if (target != null)
            {
                InPlaceEditTarget = initiatedBy.Graph.GetModuleEditor((CGModule)target);

                if (SceneView.currentDrawingSceneView)
                    SceneView.currentDrawingSceneView.Focus();

                SyncIPE();
                InPlaceEditTarget.BeginIPE();
            }
        }

        /// <summary>
        /// Sets IPE target's TRS
        /// </summary>
        public static void SyncIPE()
        {
            if (InPlaceEditInitiatedBy != null && InPlaceEditTarget != null)
            {
                Vector3 pos;
                Quaternion rot;
                Vector3 scl;
                InPlaceEditInitiatedBy.OnIPEGetTRS(out pos, out rot, out scl);
                InPlaceEditTarget.OnIPESetTRS(pos, rot, scl);
            }
        }


        #endregion

        public CurvyGenerator Generator;
        public Dictionary<CGModule, CGModuleEditorBase> ModuleEditors = new Dictionary<CGModule, CGModuleEditorBase>();
        public Dictionary<System.Type, Color> TypeColors = new Dictionary<System.Type, Color>();


        List<CGModule> mModules;
        public List<CGModule> Modules
        {
            get
            {
                if (mModules == null)
                    mModules = new List<CGModule>(Generator.Modules.ToArray());
                return mModules;
            }
            set
            {
                mModules = value;
            }
        }

        internal CanvasState Canvas;
        public CanvasSelection Sel;
        internal CanvasUI UI;
        // Statusbar
        public DTStatusbar StatusBar = new DTStatusbar();
        const int mStatusbarHeight = 20;
        int mModuleCount;
        bool mDoRepaint;
        /// <summary>
        /// True if the user clicked on the Reorder button
        /// </summary>
        bool mDoReorder;
        readonly AnimBool mShowDebug = new AnimBool();

        Event EV { get { return Event.current; } }
        public bool LMB { get { return EV.type == EventType.MouseDown && EV.button == 0; } }
        public bool RMB { get { return EV.type == EventType.MouseDown && EV.button == 1; } }




        CGModule editTitleModule;

        void OnSelectionChange()
        {
            CurvyGenerator gen = null;
            List<CGModule> mod = DTSelection.GetAllAs<CGModule>();
            if (mod.Count > 0)
                gen = mod[0].Generator;
            if (gen == null)
                gen = DTSelection.GetAs<CurvyGenerator>();
            if (gen != null && (Generator == null || gen != Generator))
            {
                Initialize(gen);
                Repaint();
            }
            else
                if (mod.Count > 0 && CurvyProject.Instance.CGSynchronizeSelection)
            {
                Sel.SetSelectionTo(mod);
                Canvas.FocusSelection();
                Repaint();
            }

            //OnSelectionChange is called when a selected module is deleted (from the hierarchy for example)
            Sel.SelectedModules.RemoveAll(m => m == null);
        }

        internal static CGGraph Open(CurvyGenerator generator)
        {
            generator.Initialize(true);
            CGGraph win = EditorWindow.GetWindow<CGGraph>("", true);
            win.Initialize(generator);
            win.wantsMouseMove = true;
            win.autoRepaintOnSceneChange = true;
            return win;
        }

        public void Initialize(CurvyGenerator generator)
        {
            destroyEditors();
            if (generator)
            {
                mShowDebug.speed = 3;
                mShowDebug.value = generator.ShowDebug;
                mShowDebug.valueChanged.RemoveAllListeners();
                mShowDebug.valueChanged.AddListener(Repaint);
#if UNITY_5_0 || UNITY_4_6
                title=generator.name;
#else
                titleContent.text = generator.name;
#endif
                Generator = generator;
                Generator.ArrangeModules();
                Sel.Clear();
                Show();
                if (Generator.Modules.Count == 0)
                    StatusBar.SetInfo("Welcome to the Curvy Generator! Right click or drag a CurvySpline on the canvas to get started!", "", 10);
                else
                    StatusBar.SetMessage(Generator.Modules.Count.ToString() + " modules loaded!", "", MessageType.None, 3);
            }
        }

        void OnDestroy()
        {
            destroyEditors();
            Resources.UnloadUnusedAssets();
        }

        void OnDisable()
        {
            SceneView.duringSceneGui -= OnSceneGUI;

            EditorApplication.playModeStateChanged -= OnPlayModeStateChanged;
            EditorApplication.pauseStateChanged -= onPauseStateChanged;
            SetIPE();
            EditorApplication.update -= onUpdate;
            Undo.undoRedoPerformed -= OnUndoRedo;
        }

        void OnEnable()
        {
            Canvas = new CanvasState(this);
            UI = new CanvasUI(this);
            Sel = new CanvasSelection(this);
            loadTypeColors();
            SceneView.duringSceneGui -= OnSceneGUI;
            SceneView.duringSceneGui += OnSceneGUI;

            EditorApplication.playModeStateChanged -= OnPlayModeStateChanged;
            EditorApplication.pauseStateChanged -= onPauseStateChanged;
            EditorApplication.playModeStateChanged += OnPlayModeStateChanged;
            EditorApplication.pauseStateChanged += onPauseStateChanged;
            EditorApplication.update -= onUpdate;
            EditorApplication.update += onUpdate;

            autoRepaintOnSceneChange = true;
            wantsMouseMove = true;
            Undo.undoRedoPerformed -= OnUndoRedo;
            Undo.undoRedoPerformed += OnUndoRedo;
        }

        void OnUndoRedo()
        {
            if (Generator)
            {
                if (mModuleCount != Generator.GetComponentsInChildren<CGModule>().Length)
                {
                    Generator.Initialize(true);
                    Generator.Initialize(false);
                    Initialize(Generator);
                }
            }
        }

        double? previousEditorTimeSinceStartup;

        void onUpdate()
        {
            double timeSinceStartup = EditorApplication.timeSinceStartup;
            double editorDeltaTime = previousEditorTimeSinceStartup.HasValue == false ? 0 : timeSinceStartup - previousEditorTimeSinceStartup.Value;
            previousEditorTimeSinceStartup = timeSinceStartup;

            Canvas.UpdateScrollingAnimation(editorDeltaTime);

            /* THIS CAUSES NullRefException when rendering ReorderableList's:
            if (EditorApplication.isCompiling)
            {
                var eds = new List<CGModuleEditorBase>(ModuleEditors.Values);
                for (int i = eds.Count - 1; i >= 0; i--)
                    Editor.DestroyImmediate(eds[i]);
                ModuleEditors.Clear();
            }*/
        }

        void OnPlayModeStateChanged(PlayModeStateChange state)
        {
            OnStateChanged();
        }

        void onPauseStateChanged(PauseState state)
        {
            OnStateChanged();
        }

        void OnStateChanged()
        {
            destroyEditors();
            if (!Generator && Selection.activeGameObject)
            {
                Initialize(Selection.activeGameObject.GetComponent<CurvyGenerator>());
                Repaint();
            }
        }

        void OnSceneGUI(SceneView sceneView)
        {
            if (!Generator)
                return;
            for (int i = 0; i < Modules.Count; i++)
            {
                CGModule mod = Modules[i];
                if (mod != null && mod.IsInitialized && mod.IsConfigured && mod.Active)
                {
                    CGModuleEditorBase ed = GetModuleEditor(mod);
                    ed.OnModuleSceneGUI();
                    if (Generator.ShowDebug && ed.ShowDebugVisuals)
                        ed.OnModuleSceneDebugGUI();
                }
            }
        }

        Vector2 deltaAccu;

        private List<object> selectedObjectsCache1 = new List<object>();
        private List<object> selectedObjectsCache2 = new List<object>();

        void OnGUI()
        {

            mDoRepaint = false;
            if (!Generator)
                return;
            if (!Generator.IsInitialized)
            {
                Generator.Initialize();
            }


            Modules = new List<CGModule>(Generator.Modules.ToArray());
            mModuleCount = Modules.Count; // store count to be checked in window GUI

            if (!Application.isPlaying && !Generator.IsInitialized)
                Repaint();

            DrawToolbar();
            Canvas.SetClientRect(0, GUILayoutUtility.GetLastRect().yMax, 0, mStatusbarHeight);

            // Scrollable Canvas
            if (Canvas.IsScrollValueAnimating)
                GUI.BeginScrollView(Canvas.ClientRect, Canvas.ScrollValue, Canvas.CanvasRect);
            else
                Canvas.ScrollValue = GUI.BeginScrollView(Canvas.ClientRect, Canvas.ScrollValue, Canvas.CanvasRect);


            // render background
            DTGUI.PushColor(Color.black.SkinAwareColor(true));
            GUI.Box(Canvas.ViewPort, "");
            DTGUI.PopColor();

#if CURVY_DEBUG

            GUILayout.BeginArea(Canvas.ViewPort);
            GUILayout.Label("Canvas ClientRect: " + Canvas.ClientRect);
            GUILayout.Label("Canvas Rect: " + Canvas.CanvasRect);
            GUILayout.Label("Canvas Scroll: " + $" {Canvas.ScrollValue}/{Canvas.ScrollTarget} Speed {Canvas.ScrollSpeed}");
            GUILayout.Label("Canvas ViewPort: " + Canvas.ViewPort);

            GUILayout.Label("Mouse: " + EV.mousePosition);
            //GUILayout.Label("IsWindowDrag: " + Canvas.IsWindowDrag);
            GUILayout.Label("IsSelectionDrag: " + Canvas.IsSelectionRectDrag);
            GUILayout.Label("IsLinkDrag: " + Canvas.IsLinkDrag);
            GUILayout.Label("IsCanvasDrag: " + Canvas.IsCanvasDrag);
            GUILayout.Label("IsModuleDrag: " + Canvas.IsModuleDrag);
            GUILayout.Label("MouseOverModule: " + Canvas.MouseOverModule);
            GUILayout.Label("MouseOverCanvas: " + Canvas.IsMouseOverCanvas);
            GUILayout.Label("SelectedLink: " + Sel.SelectedLink);
            GUILayout.Label("Selected Module: " + Sel.SelectedModule);
            GUILayout.EndArea();
#endif

            if (CurvyProject.Instance.CGShowHelp)
            {
                Rect r = new Rect(Canvas.ViewPort);
                r.x = r.width - 230;
                r.y = 10;
                r.width = 220;
                r.height = 240;

                GUILayout.BeginArea(r, GUI.skin.box);
                GUI.Label(new Rect(10, -2, r.width, r.height),
@"<b>General:</b>

  <b>RMB</b>               Contextual menu
  <b>MMB/Space</b> Drag canvas
  <b>Alt</b>                   Hold to snap to grid
  <b>Del</b>                  Delete selection


<b>Add Modules:</b>

  - <b>Drag & Drop</b> objects (mesh,
      spline, prefab,...) to create
      associated input module
  - Through the <b>contextual menu</b>
  - Hold <b>Ctrl</b> while releasing a
      link to create & connect", DTStyles.HtmlLabel);

                GUILayout.EndArea();
            }

            DrawLinks();

            // Init and early catch some events
            Canvas.BeginGUI();

            DrawModules();

            Canvas.EndGUI();

            // Draw Selection

            DTGUI.PushBackgroundColor(Color.white);//.SkinAwareColor());
            foreach (CGModule mod in Sel.SelectedModules)
            {
                Rect selectionHighlightRectangle = mod.Properties.Dimensions.ScaleBy(2);
#pragma warning disable 162
                {
                    selectionHighlightRectangle.x -= 1;
                    selectionHighlightRectangle.y -= 1;
                    selectionHighlightRectangle.width += 2;
                    selectionHighlightRectangle.height += 1;
                }
#pragma warning restore 162
                GUI.Box(selectionHighlightRectangle, "", CurvyStyles.RoundRectangle);
            }
            DTGUI.PopBackgroundColor();

            // Keep dragged Module in view and handle multiselection move
            if (Canvas.IsModuleDrag && !DTGUI.IsLayout)
            {
                CGModule selectedModule = Canvas.Sel.SelectedModule;

#if CURVY_SANITY_CHECKS_PRIVATE
                if (selectedModule == null)
                    Debug.LogError($"Custom assertion is false: selectedModule != null");
#endif
                Vector2 mouseDelta = EV.delta;
                deltaAccu += EV.delta;
                if (EV.alt)
                {
                    mouseDelta = deltaAccu.Snap(CurvyProject.Instance.CGGraphSnapping);
                    if (mouseDelta == deltaAccu)
                        mouseDelta = Vector2.zero;
                }
                if (Sel.SelectedModules.Count > 1)
                {
                    foreach (CGModule mod in Sel.SelectedModules)
                    {
                        mod.Properties.Dimensions.position += mouseDelta;
                    }
                    if (!EV.alt || mouseDelta != Vector2.zero)
                        deltaAccu = Vector2.zero;
                }
                CGModule focusedModule;
                if (Canvas.MouseOverModule && Sel.SelectedModules.Contains(Canvas.MouseOverModule))
                    focusedModule = Canvas.MouseOverModule;
                else
                    focusedModule = selectedModule;

                if (focusedModule)
                {
                    Vector2 scrollDelta = Canvas.GetFocusDelta(focusedModule);
                    Canvas.SetScrollTarget(Canvas.ScrollValue + scrollDelta, Mathf.Max(60f, scrollDelta.magnitude * 20f));
                }
            }

            // Linking in progress?
            if (Canvas.IsLinkDrag)
            {
                Texture2D linkstyle = (Canvas.LinkDragFrom.OnRequestModule != null) ? CurvyStyles.RequestLineTexture : CurvyStyles.LineTexture;
                Vector2 startPosition = Canvas.LinkDragFrom.Origin;
                Vector2 endPosition = EV.mousePosition;

                CGGraph.GetLinkBezierTangents(
                    startPosition,
                    endPosition,
                    out Vector2 startTangent,
                    out Vector2 endTangent);

                Handles.DrawBezier(startPosition, endPosition, startTangent, endTangent, Color.white, linkstyle, 2);
            }

            GUI.EndScrollView(true);

            // Selection
            if (Canvas.IsSelectionRectDrag)
                DrawSelectionRect();

            // Statusbar
            DrawStatusbar();

            // IPE
            SyncIPE();

            bool selectionHasChanged;
            {
                Canvas.Sel.FillWithSelectedObjects(selectedObjectsCache1);
                selectionHasChanged = selectedObjectsCache1.SequenceEqual(selectedObjectsCache2);
                //swap both lists
                (selectedObjectsCache2, selectedObjectsCache1) = (selectedObjectsCache1, selectedObjectsCache2);
            }

            mDoRepaint = mDoRepaint || Canvas.IsCanvasDrag || Canvas.IsLinkDrag || Canvas.IsSelectionRectDrag || EV.type == EventType.MouseMove || mShowDebug.isAnimating || Canvas.IsScrollValueAnimating || selectionHasChanged;


            // Disable Title edit mode?
            if (editTitleModule != null)
            {
                if ((EV.isKey && (EV.keyCode == KeyCode.Escape || EV.keyCode == KeyCode.Return)) ||
                    Sel.SelectedModule != editTitleModule
                    )
                {
                    editTitleModule = null;
                    //GUI.FocusControl("");
                    mDoRepaint = true;
                }
            }

            if (mDoReorder)
                Generator.ReorderModules();
            if (mDoRepaint)
                Repaint();
        }



        void DrawModules()
        {
            //TODO at some point this method should be reworked to distinguish between what should be called when Event.current.type == EventType.Layout and what should be called otherwise
            const int refreshHighlightSize = 9;

            //When modules are culled, they are not rendered (duh) and thus their height is not updated. This is ok as long as the height is constant. When there is some module expanding/collapsing, the height should change. In those cases, we disable the culling (for all modules for implementation simplicity sake, could be optimized) so the height is updated, so that the modules reordering code can work based on the actual height, and not the preculling one, which was leading to bad reordering results.
            bool animationIsHappening = mShowDebug.isAnimating || Modules.Exists(m => m.Properties.Expanded.isAnimating);

            CGModule curSel = Sel.SelectedModule;
            // Begin drawing Module Windows
            BeginWindows();
            for (int i = 0; i < Modules.Count; i++)
            {
                CGModule mod = Modules[i];
                if (mod != null)
                {
                    mod.Properties.Dimensions.width = Mathf.Max(mod.Properties.Dimensions.width, mod.Properties.MinWidth);

                    //This is based on the condition at which mod.Properties.Expanded.target is modified in OnModuleWindowCB
                    bool autoModuleDetailsWillMakeModuleAnimate = DTGUI.IsLayout && CurvyProject.Instance.CGAutoModuleDetails && mod.Properties.Expanded.target != (mod == curSel);

                    // Render title
                    string title = mod.ModuleName;
                    if (!mod.IsConfigured)
                        title = string.Format("<color={0}>{1}</color>", new Color(1, 0.2f, 0.2f).SkinAwareColor().ToHtml(), mod.ModuleName);
                    //"<color=#ff3333>" + mod.ModuleName + "</color>"; 
                    else if (mod is IOnRequestProcessing)
                        title = string.Format("<color={0}>{1}</color>", CurvyStyles.IOnRequestProcessingTitleColor.SkinAwareColor().ToHtml(), mod.ModuleName);

#if CURVY_DEBUG
                    title = mod.UniqueID + ":" + title;
#endif

                    // the actual window
                    Vector2 oldPos = mod.Properties.Dimensions.position;

                    bool shouldDraw;
                    {
                        //Ok, shit gets complicated here. The idea was to not draw modules that are out of the screen, but for reasons I don't fully grasp, the height can be 0, which fucks up the boundaries test.
                        //The height is set to 0 in the line just before calling GUILayout.Window, with the apparent goal for that method to update the height, but this update does not happen all the time. It happens when the OnGUI method is called following an Event of type Repaint, but does not happen when is called following an Event of type Layout.
                        //And if you remove the code setting height to 0, the height of the module is not updated correctly
                        if (mod.Properties.Dimensions.height == 0 || animationIsHappening || autoModuleDetailsWillMakeModuleAnimate)
                            shouldDraw = true;
                        else
                        {
                            Rect testedBoundaries = mod.Properties.Dimensions.ScaleBy(refreshHighlightSize);
                            shouldDraw = Canvas.ViewPort.Contains(testedBoundaries.min) || Canvas.ViewPort.Overlaps(testedBoundaries);
                        }
                    }

                    Rect newWindowRect;
                    if (shouldDraw)
                    {
                        mod.Properties.Dimensions.height = 0; // will be set by GUILayout.Window
                        newWindowRect = GUILayout.Window(i, mod.Properties.Dimensions, OnModuleWindowCB, title, CurvyStyles.ModuleWindow);
                    }
                    else
                    {
                        UpdateLinks(mod);
                        newWindowRect = mod.Properties.Dimensions;
                    }

                    if (!Application.isPlaying && oldPos != newWindowRect.position)
                        EditorSceneManager.MarkAllScenesDirty();

                    if (Sel.SelectedModules.Count > 1) // Multi-Module move in OnGUI()
                    {
                        mod.Properties.Dimensions = newWindowRect.SetPosition(oldPos);
                    }
                    else
                    {
                        if (EV.alt && Canvas.IsModuleDrag && Sel.SelectedModule == mod)
                            newWindowRect.position = newWindowRect.position.Snap(CurvyProject.Instance.CGGraphSnapping);
                        mod.Properties.Dimensions = newWindowRect;
                    }



                    // Debugging
                    double lastUpdateDelta = (System.DateTime.Now - mod.DEBUG_LastUpdateTime).TotalMilliseconds;
                    if (lastUpdateDelta < 1500)
                    {
                        float alpha = Mathf.SmoothStep(1, 0, (float)lastUpdateDelta / 1500f);
                        DTGUI.PushBackgroundColor(new Color(0, 1, 0, alpha));
                        GUI.Box(mod.Properties.Dimensions.ScaleBy(refreshHighlightSize), "", CurvyStyles.GlowBox);
                        DTGUI.PopBackgroundColor();
                        Repaint();
                    }

                }
            }
            EndWindows();

            //update canvas rect to include any possible module's rectangle change (position and size)
            if (EV.type != EventType.Layout)
                //The following line is ignored in EventType.Layout, because the call to GUILayout.Window in that event, call on which we rely on to give us the correct module's rectangle, does not update the height. Maybe because that method is not supposed to be called in event layout, and maybe supposed to be called only in event repaint, but I am not going to do such drastic changes to this code now. This is a fight for another time
                Canvas.ComputeCanvasRectangle(Modules);

            //focus selection
            if (Sel.SelectedModule != curSel)
                Canvas.FocusSelection();
        }

        void DrawSelectionRect()
        {
            Vector2 p = Canvas.SelectionRectStart;
            Vector2 p2 = Canvas.ViewPortMousePosition;
            Vector3[] verts = new Vector3[4]
            {
                new Vector3(p.x,p.y,0),
                new Vector3(p2.x,p.y,0),
                new Vector3(p2.x,p2.y,0),
                new Vector3(p.x,p2.y,0)
            };
            Handles.DrawSolidRectangleWithOutline(verts, new Color(.5f, .5f, .5f, 0.1f), Color.white);
        }

        void OnModuleWindowCB(int id)
        {
            // something happened in the meantime?
            if (id >= Modules.Count || mModuleCount != Modules.Count)
                return;
            CGModule mod = Modules[id];

            //if (EV.type != EventType.Repaint && EV.type != EventType.Layout)
            //    Debug.Log("OnModuleWindowCB()  " + EV.type + "  " + Canvas.IsMouseOverCanvas);
            if (EV.type == EventType.MouseDown && EV.button != 2 && !Sel.SelectedModules.Contains(mod)
                /*&& Canvas.IsCanvasDrag == false && Canvas.IsLinkDrag == false*/)
                Sel.SetSelectionTo(Modules[id]);

            Rect winRect = mod.Properties.Dimensions;

            // Draw Title Buttons
            // Enabled
            EditorGUI.BeginChangeCheck();
            mod.Active = GUI.Toggle(new Rect(2, 2, 16, 16), mod.Active, "");
            if (EditorGUI.EndChangeCheck())
                EditorUtility.SetDirty(Generator);

            //Edit Title & Color
            if (editTitleModule == mod)
            {
                GUI.SetNextControlName("editTitle" + id.ToString());
                mod.ModuleName = GUI.TextField(new Rect(30, 5, winRect.width - 120, 16), mod.ModuleName);
                mod.Properties.BackgroundColor = EditorGUI.ColorField(new Rect(winRect.width - 70, 5, 32, 16), mod.Properties.BackgroundColor);
            }


            if (GUI.Button(new Rect(winRect.width - 32, 6, 16, 16), new GUIContent(CurvyStyles.EditTexture, "Rename"), CurvyStyles.BorderlessButton))
            {
                editTitleModule = mod;
                //is this needed?
                Sel.SetSelectionTo(mod);
                EditorGUI.FocusTextInControl("editTitle" + id.ToString());
            }

            // Help
            if (GUI.Button(new Rect(winRect.width - 16, 6, 16, 16), new GUIContent(CurvyStyles.HelpTexture, "Help"), CurvyStyles.BorderlessButton))
            {
                string url = DTUtility.GetHelpUrl(mod);
                if (!string.IsNullOrEmpty(url))
                    Application.OpenURL(url);
            }


            // Check errors
            if (mod.CircularReferenceError)
                EditorGUILayout.HelpBox("Circular Reference", MessageType.Error);
            // Draw Slots
            DTGUI.PushColor(mod.Properties.BackgroundColor.SkinAwareColor(true));
            GUILayout.Space(1);
            EditorGUILayout.BeginVertical(CurvyStyles.ModuleWindowSlotBackground);
            DTGUI.PopColor();
            UpdateLinks(mod);
            OnModuleWindowSlotGUI(mod);
            EditorGUILayout.EndVertical();

            CGModuleEditorBase ed = GetModuleEditor(mod);

            if (ed && ed.target != null)
            {

                if (EditorGUILayout.BeginFadeGroup(mShowDebug.faded))
                    ed.OnInspectorDebugGUIINTERNAL(Repaint);
                EditorGUILayout.EndFadeGroup();

                // Draw Module Options

                //I don't see the need for this, but I am not familiar enough with CG editor's code to feel confident to remove it
                mod.Properties.Expanded.valueChanged.RemoveListener(Repaint);
                mod.Properties.Expanded.valueChanged.AddListener(Repaint);

                if (!CurvyProject.Instance.CGAutoModuleDetails)
                    mod.Properties.Expanded.target = GUILayout.Toggle(mod.Properties.Expanded.target, new GUIContent(mod.Properties.Expanded.target ? CurvyStyles.CollapseTexture : CurvyStyles.ExpandTexture, "Show Details"), CurvyStyles.ShowDetailsButton);

                // === Module Details ===
                // Handle Auto-Folding
                if (DTGUI.IsLayout && CurvyProject.Instance.CGAutoModuleDetails)
                    mod.Properties.Expanded.target = (mod == Sel.SelectedModule);

                if (EditorGUILayout.BeginFadeGroup(mod.Properties.Expanded.faded))
                {
                    EditorGUIUtility.labelWidth = (mod.Properties.LabelWidth);
                    // Draw Inspectors using Modules Background color
                    DTGUI.PushColor(ed.Target.Properties.BackgroundColor.SkinAwareColor(true));
                    EditorGUILayout.BeginVertical(CurvyStyles.ModuleWindowBackground);
                    DTGUI.PopColor();

                    ed.RenderGUI(true);
                    if (ed.NeedRepaint)
                        mDoRepaint = true;
                    GUILayout.Space(2);
                    EditorGUILayout.EndVertical();
                }
                EditorGUILayout.EndFadeGroup();


            }

            // Make it dragable
            GUI.DragWindow(new Rect(0, 0, winRect.width, CurvyStyles.ModuleWindowTitleHeight));

        }

        void OnModuleWindowSlotGUI(CGModule module)
        {

            int i = 0;

            while (module.Input.Count > i || module.Output.Count > i)
            {
                GUILayout.BeginHorizontal();

                if (module.Input.Count > i)
                {
                    CGModuleInputSlot slot = module.Input[i];
                    Color linkDataTypeColor = getTypeColor(slot.Info.DataTypes);
                    if (Canvas.IsLinkDrag && !slot.CanLinkTo(Canvas.LinkDragFrom))
                        linkDataTypeColor = new Color(0.2f, 0.2f, 0.2f).SkinAwareColor(true);
                    DTGUI.PushColor(linkDataTypeColor);
                    GUILayout.Box("<", CurvyStyles.Slot);
                    DTGUI.PopColor();
                    string postfix = "";
                    if (slot.Info.Array && slot.Info.ArrayType == SlotInfo.SlotArrayType.Normal)
                        postfix = (slot.LastDataCountINTERNAL > 0) ? "[" + slot.LastDataCountINTERNAL.ToString() + "]" : "[]";
                    GUILayout.Label(new GUIContent(ObjectNames.NicifyVariableName(slot.Info.DisplayName) + postfix, slot.Info.Tooltip), CurvyStyles.GetSlotLabelStyle(slot));

                    // LinkDrag?
                    if (Canvas.IsLinkDrag)
                    {
                        // If ending drag over dropzone, create static link
                        if (EV.type == EventType.MouseUp && slot.DropZone.Contains(EV.mousePosition) && slot.CanLinkTo(Canvas.LinkDragFrom))
                            finishLink(slot);
                    }
                    // Clicking on Dropzone to pick existing link
                    else if (LMB && slot.Count == 1 && slot.DropZone.Contains(EV.mousePosition))
                    {
                        CGModuleOutputSlot linkedOutSlot = slot.SourceSlot();
                        linkedOutSlot.UnlinkFrom(slot);
                        EditorUtility.SetDirty(slot.Module);
                        startLinkDrag(linkedOutSlot);
                        GUIUtility.ExitGUI();
                    }
                }

                if (module.Output.Count > i)
                {
                    CGModuleOutputSlot slot = module.Output[i];
                    string postfix = "";
                    if (slot.Info.Array && slot.Info.ArrayType == SlotInfo.SlotArrayType.Normal)
                        postfix = (slot.Data != null && slot.Data.Length > 1) ? "[" + slot.Data.Length.ToString() + "]" : "";

                    GUILayout.Label(new GUIContent(ObjectNames.NicifyVariableName(slot.Info.DisplayName) + postfix, slot.Info.Tooltip), CurvyStyles.GetSlotLabelStyle(slot));
                    DTGUI.PushColor(getTypeColor(slot.Info.DataTypes));
                    GUILayout.Box(">", CurvyStyles.Slot);
                    DTGUI.PopColor();
                    // Debug
                    /*
                    if (Generator.ShowDebug)
                    {
                        GUI.enabled = slot.Data != null && slot.Data.Length>0;
                        if (GUILayout.Button(new GUIContent(CurvyStyles.DebugTexture, "Show Dump"), CurvyStyles.SmallButton, GUILayout.Width(16), GUILayout.Height(16)))
                            DTDebugWindow.Open(slot.Data[0].GetType().Name + ":", slot.Data[0].ToDumpString());
                        GUI.enabled = true;
                    }
                    */
                    // Start Linking?
                    if (LMB && !Canvas.IsSelectionRectDrag && slot.DropZone.Contains(EV.mousePosition))
                    {
                        startLinkDrag(slot);
                    }

                }
                GUILayout.EndHorizontal();
                i++;
            }


        }

        void DrawToolbar()
        {
            GUILayout.BeginHorizontal(CurvyStyles.Toolbar);
            // Clear
            if (GUILayout.Button(new GUIContent(CurvyStyles.DeleteTexture, "Clear modules"), EditorStyles.miniButton) && EditorUtility.DisplayDialog("Clear", "Clear graph?", "Yes", "No"))
            {
                Sel.Clear();
                Generator.Clear();
                Repaint();
                GUIUtility.ExitGUI();
            }

            GUILayout.Space(10);

            // clear outputs
            if (GUILayout.Button(new GUIContent(CurvyStyles.DeleteBTexture, "Clear output"), EditorStyles.miniButton))
            {
                bool associatedPrefabWasModified;
                if (Generator.DeleteAllOutputManagedResources(out associatedPrefabWasModified) && Application.isPlaying == false)
                    if (PrefabStageUtility.GetPrefabStage(Generator.gameObject) == null) //if not editing the prefab in prefab mode
                        EditorSceneManager.MarkSceneDirty(SceneManager.GetActiveScene());

                if (associatedPrefabWasModified)
                    EditorUtility.DisplayDialog("Prefab asset modified", "The prefab asset associated with the prefab instance containing this Curvy Generator was modified.\n\nThis was done in order to allow the operation you initiated (Clear Output). You might need to apply the operation again.", "Ok");
            }

            // save resources to scene
            if (GUILayout.Button(new GUIContent(CurvyStyles.SaveResourcesTexture, "Save output to scene"), EditorStyles.miniButton))
            {
                Generator.SaveAllOutputManagedResources();
            }

            GUILayout.Space(10);

            // Refresh
            if (GUILayout.Button(new GUIContent(CurvyStyles.RefreshTexture, "Refresh"), EditorStyles.miniButton, GUILayout.ExpandWidth(false)) && !DTGUI.IsLayout)
            {
                Modules = null;
                Generator.Refresh(true);
                Repaint();
                GUIUtility.ExitGUI();
            }

            // reorder
            mDoReorder = GUILayout.Button(new GUIContent(CurvyStyles.ReorderTexture, "Reorder modules"), EditorStyles.miniButton, GUILayout.ExpandWidth(false)) && !DTGUI.IsLayout;

            // Debug
            EditorGUI.BeginChangeCheck();
            mShowDebug.target = GUILayout.Toggle(mShowDebug.target, new GUIContent(CurvyStyles.DebugTexture, "Debug"), EditorStyles.miniButton);
            if (EditorGUI.EndChangeCheck())
            {
                Generator.ShowDebug = mShowDebug.target;
                SceneView.RepaintAll();
            }

            GUILayout.Space(10);


            // Expanded/Collapsed actions
            CurvyProject.Instance.CGAutoModuleDetails = GUILayout.Toggle(CurvyProject.Instance.CGAutoModuleDetails, new GUIContent(CurvyStyles.CGAutoFoldTexture, "Auto-Expand selected module"), EditorStyles.miniButton);
            if (GUILayout.Button(new GUIContent(CurvyStyles.ExpandTexture, "Expand all"), EditorStyles.miniButton))
                CGEditorUtility.SetModulesExpandedState(true, Generator.Modules.ToArray());
            if (GUILayout.Button(new GUIContent(CurvyStyles.CollapseTexture, "Collapse all"), EditorStyles.miniButton))
                CGEditorUtility.SetModulesExpandedState(false, Generator.Modules.ToArray());
            // Sync Selection
            CurvyProject.Instance.CGSynchronizeSelection = GUILayout.Toggle(CurvyProject.Instance.CGSynchronizeSelection, new GUIContent(CurvyStyles.SynchronizeTexture, "Synchronize Selection"), EditorStyles.miniButton);

            // Save Template
            GUILayout.Space(10);
            GUI.enabled = Sel.SelectedModule != null;
            if (GUILayout.Button(new GUIContent(CurvyStyles.AddTemplateTexture, "Save Selection as Template"), EditorStyles.miniButton))
                TemplateWizard.Open(Sel.SelectedModules, UI);

            GUI.enabled = true;
            GUILayout.FlexibleSpace();
            GUILayout.Label(new GUIContent(CurvyStyles.TexGridSnap, "Snap Grid Size\n(Hold Alt while dragging to snap)"));
            CurvyProject.Instance.CGGraphSnapping = (int)GUILayout.HorizontalSlider(CurvyProject.Instance.CGGraphSnapping, 1, 20, GUILayout.Width(60));
            GUILayout.Label(CurvyProject.Instance.CGGraphSnapping.ToString(), GUILayout.Width(20));
            CurvyProject.Instance.CGShowHelp = GUILayout.Toggle(CurvyProject.Instance.CGShowHelp, new GUIContent(CurvyStyles.HelpTexture, "Show Help"), EditorStyles.miniButton, GUILayout.Height(20));
            GUILayout.EndHorizontal();
        }

        void DrawStatusbar()
        {
            Rect r = new Rect(-1, position.height - mStatusbarHeight, 201, mStatusbarHeight - 1);
            // Performance
            EditorGUI.HelpBox(r, string.Format("Exec. Time (Avg): {0:0.###} ms", Generator.DEBUG_ExecutionTime.AverageMS), MessageType.None);
            // Message
            if (StatusBar.Render(new Rect(200, position.height - mStatusbarHeight, position.width, mStatusbarHeight - 1)))
                mDoRepaint = true;
        }

        void loadTypeColors()
        {
            TypeColors.Clear();

            IEnumerable<Type> loadedTypes = TypeCache.GetTypesDerivedFrom(typeof(CGData));
            foreach (Type t in loadedTypes)
            {
                object[] ai = t.GetCustomAttributes(typeof(CGDataInfoAttribute), true);
                if (ai.Length > 0)
                {
                    TypeColors.Add(t, ((CGDataInfoAttribute)ai[0]).Color);
                }
            }
        }

        public void destroyEditors()
        {
            List<CGModuleEditorBase> ed = new List<CGModuleEditorBase>(ModuleEditors.Values);
            for (int i = ed.Count - 1; i >= 0; i--)
                DestroyImmediate(ed[i]);
            ModuleEditors.Clear();
            InPlaceEditTarget = null;
            InPlaceEditInitiatedBy = null;
        }

        internal CGModuleEditorBase GetModuleEditor([NotNull] CGModule module)
        {
            CGModuleEditorBase ed;
            if (!ModuleEditors.TryGetValue(module, out ed))
            {
                ed = Editor.CreateEditor(module) as CGModuleEditorBase;
                if (ed)
                {
                    ed.Graph = this;
                    ModuleEditors.Add(module, ed);
                }
                else
                    DTLog.LogError("[Curvy] Curvy Generator: Missing editor script for module '" + module.GetType().Name + "' !", module);
            }

            return ed;
        }

        Color getTypeColor(System.Type[] type)
        {
            Color c = Color.white; ;
            if (type.Length == 1)
                TypeColors.TryGetValue(type[0], out c);

            return c;//.SkinAwareColor();
        }

        #region Links

        public const int LinkSelectionDistance = 6;

        /// <summary>
        /// Given a link's start and end positions, you get the Bezier tangents of the link at those positions
        /// </summary>
        public static void GetLinkBezierTangents(Vector2 startPosition, Vector2 endPosition, out Vector2 startTangent, out Vector2 endTangent)
        {
            float deltaX = Mathf.Abs(endPosition.x - startPosition.x);
            float deltaY = Mathf.Abs(endPosition.y - startPosition.y);

            float xInfluence = deltaX / 2;
            //when there is a big delta in y, a small delta in x, and multiple links going to the same module, the links are too close to distinguish. I "bump" the links (by increasing the tangent) in those cases so that they are distinguishable near the modules.
            float yInfluence = 100f * Mathf.Min(1000f, deltaY) / 1000f;

            Vector2 tangent = new Vector2(xInfluence + yInfluence, 0);
            startTangent = startPosition + tangent;
            endTangent = endPosition - tangent;
        }

        void DrawLinks()
        {
            Rect r = new Rect();

            foreach (CGModule mod in Modules)
            {
                //Debug.Log(mod.name + ":" + mod.Properties.Dimensions.yMin+" to "+mod.Properties.Dimensions.yMax);
                if (mod.OutputByName != null)
                {
                    foreach (CGModuleOutputSlot slotOut in mod.OutputByName.Values)
                    {
                        Vector2 startPosition = slotOut.Origin;
                        foreach (CGModuleSlot slotIn in slotOut.LinkedSlots)
                        {
                            Vector2 endPosition = slotIn.Origin;

                            r.Set(startPosition.x, startPosition.y, endPosition.x - startPosition.x, endPosition.y - startPosition.y);
                            // draw only visible lines
                            if (Canvas.ViewPort.Overlaps(r, true))
                            {
                                GetLinkBezierTangents(
                                        startPosition,
                                        endPosition,
                                        out Vector2 startTangent,
                                        out Vector2 endTangent);

                                if (EV.type == EventType.Repaint)
                                {
                                    float w = (Sel.SelectedLink != null && Sel.SelectedLink.IsBetween(slotOut, slotIn)) ? 7 : 2;

                                    Color slotColor = getTypeColor(slotOut.Info.DataTypes);


                                    if (!((CGModuleInputSlot)slotIn).InputInfo.RequestDataOnly && slotIn.OnRequestModule == null)
                                    {
                                        Handles.DrawBezier(startPosition,
                                            endPosition,
                                            startTangent,
                                            endTangent,
                                            slotColor,
                                            CurvyStyles.LineTexture,
                                            w);
                                    }
                                    else
                                    {
                                        //draw two parallel lines
                                        Vector2 yOff = new Vector3(0, 2);
                                        Handles.DrawBezier(startPosition + yOff,
                                            endPosition + yOff,
                                            startTangent + yOff,
                                            endTangent + yOff,
                                            slotColor,
                                            CurvyStyles.LineTexture,
                                            w);

                                        yOff = new Vector3(0, -2);
                                        Handles.DrawBezier(startPosition + yOff,
                                            endPosition + yOff,
                                            startTangent + yOff,
                                            endTangent + yOff,
                                            slotColor,
                                            CurvyStyles.LineTexture,
                                            w);
                                    }
                                }

                                if (LMB && HandleUtility.DistancePointBezier(EV.mousePosition, startPosition, endPosition, startTangent, endTangent) <= LinkSelectionDistance)
                                {
                                    Sel.SetSelectionTo(slotOut.Module.GetOutputLink((CGModuleOutputSlot)slotOut, (CGModuleInputSlot)slotIn));
                                }
                            }
                        }
                    }
                }
            }

        }

        void UpdateLinks(CGModule module)
        {

            int i = 0;
            float slotDropZoneHeight = 18;

            while (module.Input.Count > i || module.Output.Count > i)
            {
                float y = CurvyStyles.ModuleWindowTitleHeight + slotDropZoneHeight * i;

                if (module.Input.Count > i)
                {
                    CGModuleInputSlot slot = module.Input[i];
                    slot.DropZone = new Rect(0, y, module.Properties.Dimensions.width / 2, slotDropZoneHeight);
                    slot.Origin = new Vector2(module.Properties.Dimensions.xMin, module.Properties.Dimensions.yMin + y + slotDropZoneHeight / 2);
                }

                if (module.Output.Count > i)
                {
                    CGModuleOutputSlot slot = module.Output[i];
                    slot.DropZone = new Rect(module.Properties.Dimensions.width / 2, y, module.Properties.Dimensions.width / 2, slotDropZoneHeight);
                    slot.Origin = new Vector2(module.Properties.Dimensions.xMax, module.Properties.Dimensions.yMin + y + slotDropZoneHeight / 2);
                }
                i++;
            }
        }

        #endregion

        #region ### Actions ###

        void startLinkDrag(CGModuleSlot slot)
        {
            Sel.Clear();
            Canvas.LinkDragFrom = (CGModuleOutputSlot)slot;
            StatusBar.SetMessage("Hold <b><Ctrl></b> to quickly create & connect a module");
        }

        void finishLink(CGModuleInputSlot target)
        {
            StatusBar.Clear();
            Canvas.LinkDragFrom.LinkTo(target);
            EditorUtility.SetDirty(target.Module);
            if (!DTGUI.IsLayout)
                GUIUtility.ExitGUI();
        }
        #endregion



    }


}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CGGraph.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CGModuleEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 2952921a87141e144bafce916291be32
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevToolsEditor.Extensions;
using FluffyUnderware.Curvy;
using System.Collections.Generic;
using System;
using FluffyUnderware.DevToolsEditor;
using UnityEditor.AnimatedValues;
using UnityEngine.Events;
using FluffyUnderware.DevTools;
using Object = UnityEngine.Object;

namespace FluffyUnderware.CurvyEditor.Generator
{
    public class CGModuleEditorBase : CurvyEditorBase<CGModule>
    {
        public CGGraph Graph { get; internal set; }

        public AnimBool ShowDebugStats { get; set; }
        public bool ShowDebugVisuals { get; set; }
        protected bool HasDebugVisuals;

        protected override void OnEnable()
        {
            base.OnEnable();
            ShowDebugStats = new AnimBool(true);
            ShowDebugStats.speed = 3;
            HasDebugVisuals = false;
            EndIPE();
        }

        /// <summary>
        /// Called by the graph when an IPE session starts
        /// </summary>
        internal virtual void BeginIPE()
        {
        }

        /// <summary>
        /// Called by the graph when an IPE session ends
        /// </summary>
        internal virtual void EndIPE()
        {
        }

        /// <summary>
        /// Called for the IPE Target when the module should TRS it's IPE editor to the given values
        /// </summary>
        internal virtual void OnIPESetTRS(Vector3 position, Quaternion rotation, Vector3 scale) { }

        /// <summary>
        /// Called for the IPE initiator to get the TRS values for the target
        /// </summary>
        internal virtual void OnIPEGetTRS(out Vector3 position, out Quaternion rotation, out Vector3 scale)
        {
            position = Vector3.zero;
            rotation = Quaternion.identity;
            scale = Vector3.one;
        }


        /// <summary>
        /// Scene View GUI
        /// </summary>
        /// <remarks>Called only if the module is initialized and configured</remarks>
        public virtual void OnModuleSceneGUI()
        {
        }

        /// <summary>
        /// Scene View Debug GUI
        /// </summary>
        /// <remarks>Called only when Show Debug Visuals is activated</remarks>
        public virtual void OnModuleSceneDebugGUI()
        {
        }
        /// <summary>
        /// Inspector Debug GUI
        /// </summary>
        /// <remarks>Called only when Show Debug Values is activated </remarks>
        public virtual void OnModuleDebugGUI()
        {
        }

        protected override void OnCustomInspectorGUI()
        {
            base.OnCustomInspectorGUI();
            for (int m = 0; m < Target.UIMessages.Count; m++)
                EditorGUILayout.HelpBox(Target.UIMessages[m], MessageType.Warning);
        }

        protected override void OnReadNodes()
        {
            base.OnReadNodes();
        }

        public override void OnInspectorGUI()
        {
            //With the new prefab system (Unity 2018.3) prefabs don't show inspector, and when opening prefab editor, its objects are of type PrefabAssetType.NotAPrefab, so no way to know if its from prefab or not?

            if (Target)
            {
                if (!Target.IsInitialized)
                {
                    Target.Initialize();
                }
                DTGroupNode slotSection;

                if (DTGUI.IsLayout && IsInsideInspector && Target.Input != null && Target.Output != null && (Target.Input.Count > 0 || Target.Output.Count > 0) && !Node.FindNode("Slots", out slotSection))
                {
                    Node.AddSection("Slots", OnShowSlots).SortOrder = 99999;
                    Node.Sort();
                }

                if (GUILayout.Button(new GUIContent(CurvyStyles.OpenGraphTexture, "Edit Graph")) && Target.Generator)
                {
                    CGGraph win = CGGraph.Open(Target.Generator);
                    win.Sel.SetSelectionTo(Target);
                    win.Canvas.FocusSelection();
                }

                base.OnInspectorGUI();



            }
        }

        void OnShowSlots(DTInspectorNode node)
        {
            if (Target)
            {
                List<CGModuleInputSlot> inSlots = Target.Input;
                List<CGModuleOutputSlot> outSlots = Target.Output;

                EditorGUILayout.BeginVertical(GUI.skin.box);

                if (inSlots.Count > 0)
                {
                    EditorGUILayout.LabelField("Input", EditorStyles.boldLabel);
                    showSlots(inSlots);
                }

                if (outSlots.Count > 0)
                {
                    EditorGUILayout.LabelField("Output", EditorStyles.boldLabel);
                    showSlots(outSlots);
                }
                EditorGUILayout.EndVertical();
                GUILayout.Space(10);

            }
        }

        void showSlots<T>(List<T> slots) where T : CGModuleSlot
        {
            foreach (CGModuleSlot slot in slots)
            {
                List<CGModule> linked = slot.GetLinkedModules();
                if (linked.Count > 1)
                {
                    for (int i = 0; i < linked.Count; i++)
                    {
                        Object sel = EditorGUILayout.ObjectField((i == 0) ? slot.Info.DisplayName : " ", linked[i], typeof(CGModule), true);
                        if (sel != linked[i])
                            DTLog.Log("[Curvy] Linking modules from the inspector isn't supported yet! Use the Graph editor instead!", Target);
                    }
                }
                else
                {
                    CGModule lm = (linked.Count == 0) ? null : linked[0];
                    Object sel = EditorGUILayout.ObjectField(slot.Info.DisplayName, lm, typeof(CGModule), true);
                    if (sel != lm)
                        DTLog.Log("[Curvy] Linking modules from the inspector isn't supported yet! Use the Graph editor instead!", Target);
                }
            }
        }


        public void OnInspectorDebugGUIINTERNAL(UnityAction onChange)
        {
            if (Target)
            {
                ShowDebugStats.valueChanged.RemoveListener(onChange);
                ShowDebugStats.valueChanged.AddListener(onChange);
                GUILayout.BeginHorizontal(CurvyStyles.Toolbar);

                ShowDebugStats.target = GUILayout.Toggle(ShowDebugStats.target, new GUIContent(CurvyStyles.DebugTexture, "Show Values"), EditorStyles.toolbarButton);

                if (HasDebugVisuals)
                {
                    EditorGUI.BeginChangeCheck();
                    ShowDebugVisuals = GUILayout.Toggle(ShowDebugVisuals, new GUIContent(CurvyStyles.DebugSceneViewTexture, "Visualize"), EditorStyles.toolbarButton);
                    if (EditorGUI.EndChangeCheck())
                        SceneView.RepaintAll();
                }
                else
                    ShowDebugVisuals = false;
                GUILayout.FlexibleSpace();
                GUILayout.Label(string.Format("{0:0.###} ms", Target.DEBUG_ExecutionTime.AverageMS));
                GUILayout.Label(string.Format("{0:0} %", Target.DEBUG_ExecutionTime.AverageMS / Target.Generator.DEBUG_ExecutionTime.AverageMS * 100));
                GUILayout.EndHorizontal();
                GUILayout.Space(2);

                if (EditorGUILayout.BeginFadeGroup(ShowDebugStats.faded))
                {
                    OnModuleDebugGUI();
                }
                EditorGUILayout.EndFadeGroup();
            }
        }



        void CBSeedOptions()
        {
            if (!Target.RandomizeSeed)
            {
                Rect r = EditorGUILayout.GetControlRect(true, 16, EditorStyles.numberField, null);
                r.width -= 16;
                EditorGUI.PropertyField(r, serializedObject.FindProperty("m_Seed"));
                r.x += r.width;
                r.width = 16;
                if (GUI.Button(r, new GUIContent(CurvyStyles.RndSeedTexture, "Randomize now!"), CurvyStyles.ImageButton))
                {
                    Target.Seed = unchecked((int)System.DateTime.Now.Ticks);
                    Target.Generator.Refresh();
                }
            }
        }


    }

    public class CGModuleEditor<T> : CGModuleEditorBase where T : CGModule
    {
        public new T Target
        {
            get
            {
                return target as T;
            }
        }


    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CGModuleEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CGResourceEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 91cf6d920c15d7e44acdac5c2e58ad1a
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.Curvy;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevToolsEditor;

namespace FluffyUnderware.CurvyEditor.Generator
{

    public static class CGResourceEditorHandler
    {
        static readonly Dictionary<string, System.Type> Editors = new Dictionary<string, System.Type>();

        internal static CGResourceEditor GetEditor(string resourceName, Component resource)
        {
            if (Editors.Count == 0)
                loadEditors();
            if (Editors.ContainsKey(resourceName))
            {
                return (CGResourceEditor)System.Activator.CreateInstance(Editors[resourceName], (object)resource);
            }
            return null;
        }

        static void loadEditors()
        {
            Editors.Clear();
            TypeCache.TypeCollection types = TypeCache.GetTypesWithAttribute<ResourceEditorAttribute>();
            foreach (Type T in types)
            {
                object[] at = T.GetCustomAttributes(typeof(ResourceEditorAttribute), true);
                Editors.Add(((ResourceEditorAttribute)at[0]).ResourceName, T);
            }
        }
    }

    public class CGResourceEditor
    {
        protected Component Resource { get; private set; }

        public CGResourceEditor() { }

        public CGResourceEditor(Component resource)
        {
            Resource = resource;
        }

        /// <summary>
        /// Resource GUI
        /// </summary>
        /// <returns>true if changes were made</returns>
        public virtual bool OnGUI() { return false; }

        public static implicit operator bool(CGResourceEditor a)
        {
            return !object.ReferenceEquals(a, null);
        }
    }

    [ResourceEditor("Mesh")]
    public class CGMeshResourceGUI : CGResourceEditor
    {

        public CGMeshResourceGUI(Component resource) : base(resource)
        {
        }


    }

    [ResourceEditor("Spline")]
    public class CGSplineResourceGUI : CGResourceEditor
    {

        public CGSplineResourceGUI(Component resource)
            : base(resource)
        {
        }
    }

    [ResourceEditor("Shape")]
    public class CGShapeResourceGUI : CGResourceEditor
    {
        CurvyShape2D mCurrentShape;
        readonly string[] mMenuNames;
        int mSelection;
        bool mFreeform;

        public CGShapeResourceGUI(Component resource) : base(resource)
        {
            mCurrentShape = resource.GetComponent<CurvyShape2D>();
            mMenuNames = CurvyShape.GetShapesMenuNames((mCurrentShape) ? mCurrentShape.GetType() : null, out mSelection, true).ToArray();
            mFreeform = (mCurrentShape == null);
        }

        public override bool OnGUI()
        {
            bool dirty = false;

            bool b = GUILayout.Toggle(mFreeform, "Freeform");
            if (b != mFreeform)
            {
                if (b)
                {
                    mCurrentShape.Spline.ShowGizmos = true;
                    mCurrentShape.Delete();
                    mCurrentShape = null;
                    mFreeform = b;

                }
                else if (EditorUtility.DisplayDialog("Warning", "The current shape will be irreversible replaced. Are you sure?", "Ok", "Cancel"))
                {
                    if (DTUtility.DoesPrefabStatusAllowDeletion(Resource.gameObject.gameObject, out string errorMessage))
                    {
                        mFreeform = b;
                        mCurrentShape = (CurvyShape2D)Resource.gameObject.AddComponent(CurvyShape.GetShapeType(mMenuNames[mSelection]));
                        mCurrentShape.Dirty = true;
                    }
                    else
                    {
                        EditorUtility.DisplayDialog($"Cannot delete Game Object '{Resource.gameObject.name}'", errorMessage, "Ok");
                    }
                }

            }
            if (!mFreeform)
            {
                int sel = EditorGUILayout.Popup(mSelection, mMenuNames);
                if (sel != mSelection)
                {
                    if (DTUtility.DoesPrefabStatusAllowDeletion(Resource.gameObject, out string errorMessage))
                    {
                        mSelection = sel;
                        dirty = true;
                        if (mCurrentShape)
                            mCurrentShape.Delete();
                        mCurrentShape = (CurvyShape2D)Resource.gameObject.AddComponent(CurvyShape.GetShapeType(mMenuNames[mSelection]));
                        mCurrentShape.Dirty = true;
                    }
                    else
                    {
                        EditorUtility.DisplayDialog($"Cannot delete Game Object '{Resource.gameObject.name}'", errorMessage, "Ok");
                    }
                }
                if (mCurrentShape)
                {
                    using (SerializedObject so = new SerializedObject(mCurrentShape))
                    {
                        SerializedProperty prop = so.GetIterator();

                        bool enterChildren = true;

                        while (prop.NextVisible(enterChildren))
                        {
                            switch (prop.name)
                            {
                                case "m_Script":
                                case "InspectorFoldout":
                                case "m_Plane":
                                    //case "m_Persistent":
                                    break;
                                default:
                                    EditorGUILayout.PropertyField(prop);
                                    break;
                            }
                            enterChildren = false;
                        }
                        dirty = dirty || so.ApplyModifiedProperties();
                    }
                }
            }

            return dirty;
        }
    }

    [System.AttributeUsage(System.AttributeTargets.Class)]
    public class ResourceEditorAttribute : System.Attribute
    {
        public readonly string ResourceName;

        public ResourceEditorAttribute(string resName)
        {
            ResourceName = resName;
        }
    }


}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CGResourceEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CurvyGeneratorEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1bc2fddee027afa438e389e26eb163dc
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections;
using FluffyUnderware.Curvy.Generator;
using System.Collections.Generic;
using FluffyUnderware.DevToolsEditor.Extensions;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.CurvyEditor.Generator
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(CurvyGenerator))]
    public class CurvyGeneratorEditor : CurvyEditorBase<CurvyGenerator>
    {
        protected override void OnCustomInspectorGUI()
        {
            GUILayout.Space(5);
            if (Target)
                EditorGUILayout.HelpBox("# of Modules: " + Target.Modules.Count.ToString(), MessageType.Info);
        }

        public override void OnInspectorGUI()
        {
            //With the new prefab system (Unity 2018.3) prefabs don't show inspector, and when opening prefab editor, its objects are of type PrefabAssetType.NotAPrefab, so no way to know if its from prefab or not?

            GUILayout.BeginHorizontal(GUILayout.Height(24));
            if (GUILayout.Button(new GUIContent(CurvyStyles.OpenGraphTexture, "Edit Graph")))
                CGGraph.Open(Target);

            if (GUILayout.Button(new GUIContent(CurvyStyles.DeleteTexture, "Clear Graph"), GUILayout.ExpandWidth(false), GUILayout.ExpandHeight(true)) && EditorUtility.DisplayDialog("Clear", "Clear graph?", "Yes", "No"))
                Target.Clear();
            GUILayout.EndHorizontal();

            base.OnInspectorGUI();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CurvyGeneratorEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/MetaCGOptionsEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 352a72fc4de23574f851e54f2adb3971
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif
using UnityEngine;
using UnityEditor;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.Curvy;
using UnityEngine.Assertions;

namespace FluffyUnderware.CurvyEditor
{
    [CustomEditor(typeof(MetaCGOptions))]
    [CanEditMultipleObjects]
    public class MetaCGOptionsEditor : DTEditor<MetaCGOptions>
    {

        [DrawGizmo(GizmoType.Active | GizmoType.NonSelected | GizmoType.InSelectionHierarchy)]
        static void MetaGizmoDrawer(MetaCGOptions data, GizmoType context)
        {
            if (data.Spline == null)
                return;

            if (CurvyGlobalManager.ShowMetadataGizmo && data.Spline.ShowGizmos)
            {
                if (data.CorrectedHardEdge)
                {
                    Vector3 position = data.ControlPoint.transform.position;
#pragma warning disable CS0618
                    CurvyGizmo.PointLabel(position, "^", OrientationAxisEnum.Down);
#pragma warning restore CS0618
                }
                if (data.Spline.Dirty == false && data.MaterialID != 0)
                {
                    Vector3 position = data.Spline.ToWorldPosition(data.ControlPoint.Interpolate(0.5f));
#pragma warning disable CS0618
                    CurvyGizmo.PointLabel(position, data.MaterialID.ToString(), OrientationAxisEnum.Forward);
#pragma warning restore CS0618
                }
            }
        }

        void CBSetFirstU()
        {
#if CONTRACTS_FULL
            Contract.Requires(Target.ControlPoint.Spline != null);
#endif
            if (!Target.CorrectedUVEdge && GUILayout.Button("Set U from neighbours"))
            {
                CurvySplineSegment targetControlPoint = Target.ControlPoint;
                CurvySpline targetSpline = targetControlPoint.Spline;

                float uValue;
                if (targetSpline.IsControlPointVisible(targetControlPoint))
                {
                    if (targetSpline.Count == 0)
                        uValue = 0;
                    else
                    {
                        //TODO this implementation has a lot in common with SplineInputModuleBase.CalculateExtendedUV. I am sure there is some duplicated code between these two, and there might be bugs due to those two implementations calculating U differently in some cases

                        CurvySplineSegment previousUWithDefinedCp;
                        CurvySpline curvySpline = Target.Spline;
                        {
                            CurvySplineSegment currentCp = curvySpline.GetPreviousControlPoint(targetControlPoint);
                            if (currentCp == null || targetControlPoint == curvySpline.FirstVisibleControlPoint)
                                previousUWithDefinedCp = targetControlPoint;
                            else
                            {
                                while (currentCp != curvySpline.FirstVisibleControlPoint)
                                {
                                    MetaCGOptions currentCpOptions = currentCp.GetMetadata<MetaCGOptions>(true);
                                    if (currentCpOptions.CorrectedUVEdge || currentCpOptions.ExplicitU)
                                        break;
                                    currentCp = curvySpline.GetPreviousControlPoint(currentCp);
                                }
                                previousUWithDefinedCp = currentCp;
                            }

                        }
                        MetaCGOptions previousDefinedOptions = previousUWithDefinedCp.GetMetadata<MetaCGOptions>(true);

                        CurvySplineSegment nextCpWithDefinedU;
                        {

                            CurvySplineSegment currentCp = curvySpline.GetNextControlPoint(targetControlPoint);
                            if (currentCp == null || targetControlPoint == curvySpline.LastVisibleControlPoint)
                                nextCpWithDefinedU = targetControlPoint;
                            else
                            {
                                while (currentCp != curvySpline.LastVisibleControlPoint)
                                {
                                    MetaCGOptions currentCpOptions = currentCp.GetMetadata<MetaCGOptions>(true);
                                    if (currentCpOptions.CorrectedUVEdge || currentCpOptions.ExplicitU)
                                        break;
                                    currentCp = curvySpline.GetNextControlPoint(currentCp);
                                }

                                nextCpWithDefinedU = currentCp;
                            }
                        }
                        if (curvySpline.Closed && nextCpWithDefinedU == curvySpline.LastVisibleControlPoint)
                            nextCpWithDefinedU = curvySpline.GetPreviousControlPoint(nextCpWithDefinedU);
                        MetaCGOptions nextDefinedOptions = nextCpWithDefinedU.GetMetadata<MetaCGOptions>(true);

                        float frag = (targetControlPoint.Distance - previousUWithDefinedCp.Distance) / (nextCpWithDefinedU.Distance - previousUWithDefinedCp.Distance);
#if CURVY_SANITY_CHECKS
                        Assert.IsFalse(float.IsNaN(frag));
#endif

                        float startingU = (previousUWithDefinedCp == targetControlPoint) ? 0 : previousDefinedOptions.GetDefinedSecondU(0);
                        float endingU = (nextCpWithDefinedU == targetControlPoint) ? 1 : nextDefinedOptions.GetDefinedFirstU(1);
                        uValue = Mathf.Lerp(startingU, endingU, frag);
                    }

                }
                else
                    uValue = 0;

                Target.FirstU = uValue;


                EditorUtility.SetDirty(target);
            }
        }
    }


}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/MetaCGOptionsEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/CurvyControllerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 3952319cbfad670488083249e69f8d33
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.Controllers;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.DevTools;
using UnityEngine.Assertions;

namespace FluffyUnderware.CurvyEditor.Controllers
{

    public class CurvyControllerEditor<T> : CurvyEditorBase<T> where T : CurvyController
    {
        protected override void OnEnable()
        {
            EditorApplication.playModeStateChanged += OnPlayModeStateChanged;
            base.OnEnable();
        }

        protected override void OnDisable()
        {
            EditorApplication.playModeStateChanged -= OnPlayModeStateChanged;
            base.OnDisable();
            if (Application.isPlaying == false)
                if (Target)
                Target.Stop();
        }

        void OnPlayModeStateChanged(PlayModeStateChange state)
        {
            OnStateChanged();
        }

        void OnStateChanged()
        {
            if (Application.isPlaying == false)
                Target.Stop();

        }

        protected override void OnReadNodes()
        {
            DTGroupNode node = Node.AddSection("Preview", ShowPreviewButtons);
            node.Expanded = false;
            node.SortOrder = 5000;
        }


        /// <summary>
        /// Show the preview buttons
        /// </summary>
        protected void ShowPreviewButtons(DTInspectorNode node)
        {
            GUILayout.BeginHorizontal();
            GUI.enabled = !Application.isPlaying;

            bool isPlayingOrPaused = Target.PlayState == CurvyController.CurvyControllerState.Playing || Target.PlayState == CurvyController.CurvyControllerState.Paused;

            //TODO it would be nice to have two different icons, one for Play and one for Pause
            if (GUILayout.Toggle(isPlayingOrPaused, new GUIContent(CurvyStyles.TexPlay, "Play/Pause in Editor"), GUI.skin.button) != isPlayingOrPaused)
            {

                switch (Target.PlayState)
                {
                    case CurvyController.CurvyControllerState.Paused:
                    case CurvyController.CurvyControllerState.Stopped:
                        Target.Play();
                        break;
                    case CurvyController.CurvyControllerState.Playing:
                        Target.Pause();
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
            if (GUILayout.Button(new GUIContent(CurvyStyles.TexStop, "Stop/Reset")))
            {
                Target.Stop();
            }
            GUI.enabled = true;
            GUILayout.EndHorizontal();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/CurvyControllerEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/MoveModeDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: bc870c7e0be8b8a42bb5579d77bfa8e3
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using FluffyUnderware.Curvy.Controllers;
using UnityEngine;
using UnityEditor;

namespace FluffyUnderware.CurvyEditor.Controllers
{
    [CustomPropertyDrawer(typeof(CurvyController.MoveModeEnum))]
    public class MoveModeDrawer : PropertyDrawer
    {
        readonly GUIContent[] options = new[] { new GUIContent("Relative", "Speed is expressed as spline lengths per second"), new GUIContent("Absolute", "Speed is expressed as world units per second") };
        readonly GUIStyle guiStyle = EditorStyles.popup;

        override public void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            EditorGUI.BeginProperty(position, label, property);
            property.intValue = EditorGUI.Popup(position, label, property.intValue, options, guiStyle);
            EditorGUI.EndProperty();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/MoveModeDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/OnPositionReachedSettingsDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 85be52f98941fdb4a95eec748bb89ba7
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

#region

using System;
using System.Collections.Generic;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.Controllers;
using FluffyUnderware.DevTools.Extensions;
using UnityEditor;
using UnityEngine;

#endregion

namespace FluffyUnderware.CurvyEditor.Controllers
{
    [CustomPropertyDrawer(typeof(OnPositionReachedSettings))]
    public class OnPositionReachedSettingsDrawer : PropertyDrawer
    {
        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            OnPositionReachedSettings onPositionReachedSettings;
            {
                object value = fieldInfo.GetValue(property.serializedObject.targetObject);
                if (value.GetType().IsArrayOrList())
                {
                    int startIndex = property.propertyPath.LastIndexOf('[');
                    int endIndex = property.propertyPath.LastIndexOf(']');
                    int index = Convert.ToInt32(property.propertyPath.Substring(startIndex + 1, endIndex - startIndex - 1));
                    onPositionReachedSettings = ((List<OnPositionReachedSettings>)value)[index];
                }
                else
                {
                    onPositionReachedSettings = (OnPositionReachedSettings)value;
                }
            }

            return GetPropertyHeight(property, onPositionReachedSettings);
        }

        public static float GetPropertyHeight(SerializedProperty property, OnPositionReachedSettings onPositionReachedSettings)
        {
            if (property.isExpanded == false)
                return EditorGUIUtility.singleLineHeight;

            return 190 + Math.Max(0, onPositionReachedSettings.Event.GetPersistentEventCount() - 1) * 47;
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            SerializedProperty nameProperty = property.FindPropertyRelative(nameof(OnPositionReachedSettings.Name));
            SerializedProperty colorProperty = property.FindPropertyRelative(nameof(OnPositionReachedSettings.GizmoColor));
            SerializedProperty eventProperty = property.FindPropertyRelative(nameof(OnPositionReachedSettings.Event));
            SerializedProperty positionProperty = property.FindPropertyRelative(nameof(OnPositionReachedSettings.Position));
            SerializedProperty positionModeProperty = property.FindPropertyRelative(nameof(OnPositionReachedSettings.PositionMode));
            SerializedProperty triggeringDirectionsProperty = property.FindPropertyRelative(nameof(OnPositionReachedSettings.TriggeringDirections));

            float fieldHeight = EditorGUIUtility.singleLineHeight;
            float fieldMarginHeight = EditorGUIUtility.standardVerticalSpacing;

            // Using BeginProperty / EndProperty on the parent property means that
            // prefab override logic works on the entire property.
            EditorGUI.BeginProperty(position, label, property);

            string labelString;
            {
                if (property.isExpanded)
                    labelString = $"{nameProperty.stringValue}";
                else
                {
                    string positionModeEnumName;
                    {
                        bool positionModeParseSucceeded = Enum.TryParse(positionModeProperty.enumNames[positionModeProperty.enumValueIndex], out CurvyPositionMode positionMode);
                        positionModeEnumName = positionModeParseSucceeded ? CurvyPositionModeDrawer.GetDisplayName(positionMode) : positionModeProperty.enumDisplayNames[positionModeProperty.enumValueIndex];
                    }

                    labelString = $"{nameProperty.stringValue} (Position: {positionModeEnumName} {positionProperty.floatValue} - Direction: {triggeringDirectionsProperty.enumDisplayNames[triggeringDirectionsProperty.enumValueIndex]})";
                }
            }
            int indent = EditorGUI.indentLevel;
            EditorGUI.indentLevel = indent + 1;

            property.isExpanded = EditorGUI.Foldout(
                new Rect(position.x,
                    position.y,
                    position.width,
                    EditorGUIUtility.singleLineHeight),
                property.isExpanded,
                labelString);

            if (property.isExpanded)
            {
                float yCoordinate = position.y;

                EditorGUI.indentLevel = indent + 1;

                yCoordinate += fieldHeight + fieldMarginHeight;

                Rect nameRect = new Rect(position.x,
                    yCoordinate,
                    position.width - 75,
                    fieldHeight);
                Rect colorRect = new Rect(position.x + position.width - 70,
                    yCoordinate,
                    70,
                    fieldHeight);

                yCoordinate += fieldHeight + fieldMarginHeight;
                Rect positionRect = new Rect(position.x,
                    yCoordinate,
                    position.width - 115,
                    fieldHeight);
                Rect positionModeRect = new Rect(position.x + position.width - 110,
                    yCoordinate,
                    110,
                    fieldHeight);

                yCoordinate += fieldHeight + fieldMarginHeight;
                Rect directionRect = new Rect(position.x,
                    yCoordinate,
                    position.width,
                    fieldHeight);

                yCoordinate += fieldHeight + fieldMarginHeight;
                Rect eventRect = new Rect(position.x,
                    yCoordinate,
                    position.width,
                    position.height - 70);
                eventRect = EditorGUI.IndentedRect(eventRect);

                EditorGUI.PropertyField(nameRect, nameProperty);
                EditorGUI.PropertyField(colorRect, colorProperty, GUIContent.none);
                EditorGUI.PropertyField(eventRect, eventProperty, GUIContent.none);
                EditorGUI.PropertyField(positionRect, positionProperty);
                EditorGUI.PropertyField(positionModeRect, positionModeProperty, GUIContent.none);
                EditorGUI.PropertyField(directionRect, triggeringDirectionsProperty);

            }
            EditorGUI.indentLevel = indent;


            EditorGUI.EndProperty();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/OnPositionReachedSettingsDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/PathControllerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 709467389ecf3f446bda424d4e6fc7a7
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Controllers;

namespace FluffyUnderware.CurvyEditor.Controllers
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(PathController), true)]
    public class PathControllerEditor : CurvyControllerEditor<PathController>
    {
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/PathControllerEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/SplineControllerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e3d05319f569b3242a40cd95655a6a80
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using System.Collections;
using FluffyUnderware.Curvy;
using FluffyUnderware.CurvyEditor;
using FluffyUnderware.Curvy.Controllers;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevToolsEditor;

namespace FluffyUnderware.CurvyEditor.Controllers
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(SplineController), true)]
    public class SplineControllerEditor : CurvyControllerEditor<SplineController>
    {
        protected override void SetupArrayEx(DTFieldNode node, ArrayExAttribute attribute)
        {
            base.SetupArrayEx(node, attribute);

            float ArrayExElementHeightCallback(int index)
            {
                if (index >= node.serializedProperty.arraySize)
                    // this case happens due to this regression:  https://issuetracker.unity3d.com/issues/reorderablelist-dot-elementheightcallback-is-invoked-when-list-has-no-element
                    return 0;

                return OnPositionReachedSettingsDrawer.GetPropertyHeight(
                    node.serializedProperty.GetArrayElementAtIndex(index),
                    ((SplineController)target).OnPositionReachedList[index]);
            }

            node.ArrayEx.elementHeightCallback = ArrayExElementHeightCallback;
        }

        protected override void OnSceneGUI()
        {
            base.OnSceneGUI();

            CurvySpline spline;

            if (Target != null && (spline = Target.Spline) != null)
            {
                for (int index = 0; index < Target.OnPositionReachedList.Count; index++)
                {
                    OnPositionReachedSettings settings = Target.OnPositionReachedList[index];
                    DTHandles.PushHandlesColor(settings.GizmoColor);

                    Vector3 position;
                    {
                        switch (settings.PositionMode)
                        {
                            case CurvyPositionMode.Relative:
                                position = spline.Interpolate(settings.Position, Space.World);
                                break;
                            case CurvyPositionMode.WorldUnits:
                                position = spline.InterpolateByDistance(settings.Position, Space.World);
                                break;
                            default:
                                throw new ArgumentOutOfRangeException();
                        }
                    }

                    EditorGUI.BeginChangeCheck();

                    float handleSize = HandleUtility.GetHandleSize(position) * .2f;
                    Vector3 newPosition = Handles.FreeMoveHandle(position,
#if UNITY_2022_1_OR_NEWER == false
                        Quaternion.identity,
#endif
                        handleSize,
                        Vector3.one * 0.5f, //couldn't figure out what value to put here. I put the same value as the example in the documentation
                        Handles.SphereHandleCap);

                    if (EditorGUI.EndChangeCheck())
                    {
                        Undo.RecordObject(Target, "Modify Custom Event Position");
                        float nearestTf = spline.GetNearestPointTF(newPosition, Space.World);
                        switch (settings.PositionMode)
                        {
                            case CurvyPositionMode.Relative:
                                settings.Position = nearestTf;
                                break;
                            case CurvyPositionMode.WorldUnits:
                                settings.Position = spline.TFToDistance(nearestTf);
                                break;
                            default:
                                throw new ArgumentOutOfRangeException();
                        }
                    }

                    //draw label
                    {
                        Color textColor = new Color(
                            settings.GizmoColor.r * 0.2f,
                            settings.GizmoColor.g * 0.2f,
                            settings.GizmoColor.b * 0.2f,
                            1);

                        GUIStyle guiStyle = CurvyStyles.ControllerCustomEventStyle;
                        lock (guiStyle)
                        {
                            guiStyle.normal.textColor = textColor;

                            //inlined version of CurvyGizmo.PointLabel(newPosition, settings.Name, OrientationAxisEnum.Up, handleSize * 4, guiStyle);
                            //I did the inline because CurvyGizmo.PointLabel has an issue with 2021.2, and I have a hack in that method to avoid the issue. The problem is the hack is counter-productive when the method is called from a OnSceneGUI method
                            Vector3 labelPosition = newPosition;
                            string label = settings.Name;

                            //ugly shit to bypass the joke that is style.alignment. Tried to bypass the issue by using style.CalcSize(new GUIContent(label)) to manually place the labels. No luck with that
                            while (label.Length <= 5)
                                label = $" {label} ";

                            labelPosition -= Camera.current.transform.right * (handleSize * 4) * 0.1f;
                            labelPosition += Camera.current.transform.up * (handleSize * 4) * 0.1f;
                            labelPosition += Camera.current.transform.up * (handleSize * 4) * 0.3f;

                            Handles.Label(labelPosition, label, guiStyle);
                        }
                    }

                    //direction handles
                    {
                        //optim if needed
                        float tf = settings.PositionMode == CurvyPositionMode.Relative ? settings.Position : spline.DistanceToTF(settings.Position);
                        Vector3 forward = spline.GetTangent(tf, Space.World);
                        Vector3 backward = -spline.GetTangent(tf * (1f - 0.001f), Space.World); //todo not the best way to compute the backward tangent, but it is a decent one for now. Enhance this if needed once you rework tangents computing code

                        if (settings.TriggeringDirections != TriggeringDirections.Backward)
                            DTHandles.ArrowCap(newPosition, forward, Camera.current.transform.forward, settings.GizmoColor, .7f, .1f, .3f, .4f, handleSize * 2);
                        if (settings.TriggeringDirections != TriggeringDirections.Forward)
                            DTHandles.ArrowCap(newPosition, backward, Camera.current.transform.forward, settings.GizmoColor, .7f, .1f, .3f, .4f, handleSize * 2);
                    }
                    DTHandles.PopHandlesColor();
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/SplineControllerEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/VolumeControllerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c857adf1af41cc34896f8a078cd9ea11
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Controllers;

namespace FluffyUnderware.CurvyEditor.Controllers
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(VolumeController), true)]
    public class VolumeControllerEditor : CurvyControllerEditor<VolumeController>
    {
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/VolumeControllerEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyConnectionEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 512f7156b64ad1843b880b394f7bd408
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.Curvy;
using FluffyUnderware.DevToolsEditor;
using UnityEditor;
using UnityEngine;
using UnityEngine.Assertions;

namespace FluffyUnderware.CurvyEditor
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(CurvyConnection))]
    public class CurvyConnectionEditor : CurvyEditorBase<CurvyConnection>
    {
        /// <summary>
        /// the gui style used in drawing the gizmo's label
        /// </summary>
        private GUIStyle sceneGuiLabelStyle;
        /// <summary>
        /// Used in the inspector, to avoid the margins added by Unity when subdivising a space
        /// </summary>
        private GUIStyle noMarginsStyle;

        private GUIStyle highlightedItemStyle;

        GUIContent selectCpContent;
        GUIContent removeFromConnectionContent;
        GUIContent controlPointTitleContent;
        GUIContent syncPositionTitleContent;
        GUIContent syncPositionContent;
        GUIContent syncRotationTitleContent;
        GUIContent syncRotationContent;
        GUIContent noSyncPresetContent;
        GUIContent positionSyncPresetContent;
        GUIContent rotationSyncPresetContent;
        GUIContent fullSyncPresetContent;

        private GUIContent splineTitleContent;
        private GUIContent endControlPointTitleContent;
        private GUIContent followUpTitleContent;
        private GUIContent headingDirectionTitleContent;

        GUIContent splineStartDirectionContent;
        GUIContent emptyContent;
        GUIContent noDirectionContent;
        GUIContent splineEndDirectionContent;
        GUIContent automaticDirectionContent;
        GUIContent directionUnavailableContent;

        [DrawGizmo(GizmoType.Active | GizmoType.NonSelected | GizmoType.InSelectionHierarchy)]
        private static void ConnectionGizmoDrawer(CurvyConnection connection, GizmoType context)
        {
            if (CurvyGlobalManager.ShowConnectionsGizmo)
            {
                Gizmos.color = connection.GetGizmoColor();

                foreach (CurvySplineSegment cp in connection.ControlPointsList)
                {
                    if (cp.Spline.ShowGizmos)
                    {
                        //optim avoid drawing gizmo multiple times if cps have the same positin
                        Vector3 position = cp.transform.position;
                        float handleSize = HandleUtility.GetHandleSize(position);
                        Gizmos.DrawWireSphere(position, handleSize * CurvyGlobalManager.GizmoControlPointSize * 1.1f);
                    }
                }
            }
        }


        protected override void OnEnable()
        {
            base.OnEnable();
            sceneGuiLabelStyle = new GUIStyle();
            noMarginsStyle = new GUIStyle();
            noMarginsStyle.margin = new RectOffset();
            highlightedItemStyle = new GUIStyle();
            highlightedItemStyle.normal.background = new Texture2D(1, 1);
            highlightedItemStyle.normal.background.SetPixel(0, 0, new Color(62 / 255f, 125 / 255f, 231 / 255f));
            highlightedItemStyle.normal.background.Apply();

            selectCpContent = new GUIContent("Select", "Select the Control Point");
            removeFromConnectionContent = new GUIContent(CurvyStyles.DeleteSmallTexture, "Remove the Control Point from this Connection");
            controlPointTitleContent = new GUIContent("Control Point", "The name of the Control Point. You can select it or remove it from the connection");
            syncPositionTitleContent = new GUIContent("Sync Position", "Synchronize the Control Point's position with the connection's");
            syncPositionContent = new GUIContent("", "Synchronize the Control Point's position with the connection's");
            syncRotationTitleContent = new GUIContent("Sync Rotation", "Synchronize the Control Point's rotation with the connection's");
            syncRotationContent = new GUIContent("", "Synchronize the Control Point's rotation with the connection's");
            noSyncPresetContent = new GUIContent(CurvyStyles.TexConnection, "No synchronization");
            positionSyncPresetContent = new GUIContent(CurvyStyles.TexConnectionPos, "Position only");
            rotationSyncPresetContent = new GUIContent(CurvyStyles.TexConnectionRot, "Rotation only");
            fullSyncPresetContent = new GUIContent(CurvyStyles.TexConnectionFull, "Position and rotation");

            splineTitleContent = new GUIContent("Spline", "The open spline for which the Follow-Up will be defined");
            endControlPointTitleContent = new GUIContent("Control Point", "The spline's end that will have a Follow-Up, either its first or last visible Control Point");
            followUpTitleContent = new GUIContent("Follow-Up", "The Control Point that will act as the continuity of the spline's end");
            headingDirectionTitleContent = new GUIContent("Heading Direction", "In which direction the Follow-Up should continue on");

            splineStartDirectionContent = new GUIContent("To spline's start", "The Follow-Up segment continues towards its spline's start");
            emptyContent = new GUIContent("");
            noDirectionContent = new GUIContent("Nowhere", "There is no continuity for the Follow-Up");
            splineEndDirectionContent = new GUIContent("To spline's end", "The Follow-Up segment continues towards its spline's end");
            automaticDirectionContent = new GUIContent("Automatic", "Automatically selects the best option");
            directionUnavailableContent = new GUIContent("---", "Select a Follow-Up first");
        }

        public new void OnSceneGUI()
        {
            if (SceneView.currentDrawingSceneView.camera && Target)
            {
                int cpsCount = Target.ControlPointsList.Count;
                if (cpsCount > 0)
                {
                    sceneGuiLabelStyle.normal.textColor = Target.GetGizmoColor();

                    int syncedCPsCount = 0;
                    for (int i = 0; i < cpsCount; i++)
                    {
                        CurvySplineSegment controlPoint = Target.ControlPointsList[i];

                        int lineIndex;
                        if (controlPoint.ConnectionSyncPosition)
                        {
                            lineIndex = syncedCPsCount;
                            syncedCPsCount++;
                        }
                        else
                            lineIndex = 0;

                        Handles.Label(DTHandles.TranslateByPixel(controlPoint.transform.position, 12, -12 * (1 + lineIndex)), controlPoint.ToString(), sceneGuiLabelStyle);
                    }
                }
            }
        }

        protected override void OnReadNodes()
        {
            //If ControlPointsGui is no more called first, make sure the undoing code in it is moved to the right place
            Node.AddSection("Control Point Options", ControlPointsGui);
            Node.AddSection("Follow-Up", FollowUpGui);
            Node.AddSection("Connection Options", ConnectionGui);
        }

        private static float GetNodeWidth(DTInspectorNode node)
        {
            return EditorGUIUtility.currentViewWidth - 2 * node.Level * 15 /*value of EditorGUI.indent*/;
        }

        void ControlPointsGui(DTInspectorNode node)
        {
            const string undoingOperationLabel = "Connection Modification";
            Undo.RecordObject(Target, undoingOperationLabel);
            Undo.RecordObjects(Target.ControlPointsList.Select(o => (UnityEngine.Object)o).ToArray(), undoingOperationLabel);
            Undo.RecordObjects(Target.ControlPointsList.Select(o => (UnityEngine.Object)o.transform).ToArray(), undoingOperationLabel);

            float drawingWidth = GetNodeWidth(node);
            float column1Width = drawingWidth * 16 / 32;
            float column2Width = drawingWidth * 8 / 32;
            float column3Width = drawingWidth * 8 / 32;

            //header           
            {
                EditorGUILayout.BeginHorizontal();
                PositionGuiElements(() => GUILayout.Label(controlPointTitleContent, EditorStyles.boldLabel), column1Width, false);
                PositionGuiElements(() => GUILayout.Label(syncPositionTitleContent, EditorStyles.boldLabel), column2Width);
                PositionGuiElements(() => GUILayout.Label(syncRotationTitleContent, EditorStyles.boldLabel), column3Width);
                EditorGUILayout.EndHorizontal();
            }

            //Items
            for (int index = 0; index < Target.ControlPointsList.Count; index++)
            {
                CurvySplineSegment item = Target.ControlPointsList[index];

                bool itemIsSelected = item.gameObject == Selection.activeGameObject;
                EditorGUILayout.BeginHorizontal(itemIsSelected
                    ? highlightedItemStyle
                    : GUIStyle.none);

                {
                    PositionGuiElements(() =>
                                        {
                                            bool clicked = GUILayout.Button(item.ToString(), itemIsSelected
                                                ? EditorStyles.whiteLabel
                                                : EditorStyles.label, GUILayout.MinWidth(column1Width * 0.6f));

                                            if (GUILayout.Button(selectCpContent, GUILayout.MinWidth(50)))
                                                clicked = true;

                                            if (clicked)
                                                DTSelection.SetGameObjects(item);

                                            if (GUILayout.Button(removeFromConnectionContent, CurvyStyles.ImageButton, GUILayout.MinWidth(20), GUILayout.MinHeight(18)))
                                            {
                                                item.Disconnect();
                                                CurvyProject.Instance.ScanConnections();
                                                GUIUtility.ExitGUI();
                                            }
                                        }, column1Width, false);
                }

                {
                    PositionGuiElements(() =>
                                        {
                                            bool oldValue = item.ConnectionSyncPosition;
                                            item.ConnectionSyncPosition = GUILayout.Toggle(oldValue, syncPositionContent);
                                            if (item.ConnectionSyncPosition != oldValue)
                                                item.Connection.SetSynchronisationPositionAndRotation(item.Connection.transform.position, item.Connection.transform.rotation);
                                        }, column2Width);
                    PositionGuiElements(() =>
                                        {
                                            bool oldValue = item.ConnectionSyncRotation;
                                            item.ConnectionSyncRotation = GUILayout.Toggle(oldValue, syncRotationContent);
                                            if (item.ConnectionSyncRotation != oldValue)
                                                item.Connection.SetSynchronisationPositionAndRotation(item.Connection.transform.position, item.Connection.transform.rotation);
                                        }, column3Width);
                }

                EditorGUILayout.EndHorizontal();
            }

            //Presets
            {
                EditorGUILayout.BeginHorizontal();
                GUILayout.Label("Synchronization Presets", EditorStyles.boldLabel);
                EditorGUILayout.EndHorizontal();


                EditorGUILayout.BeginHorizontal(GUILayout.Width(drawingWidth));
                bool syncPosition = false;
                bool syncRotation = false;
                bool buttonClicked = false;
                if (GUILayout.Button(noSyncPresetContent))
                {
                    syncPosition = false;
                    syncRotation = false;
                    buttonClicked = true;
                }

                if (GUILayout.Button(positionSyncPresetContent))
                {
                    syncPosition = true;
                    syncRotation = false;
                    buttonClicked = true;
                }

                if (GUILayout.Button(rotationSyncPresetContent))
                {
                    syncPosition = false;
                    syncRotation = true;
                    buttonClicked = true;
                }

                if (GUILayout.Button(fullSyncPresetContent))
                {
                    syncPosition = true;
                    syncRotation = true;
                    buttonClicked = true;
                }

                if (buttonClicked && Target.ControlPointsList.Any())
                {
                    foreach (CurvySplineSegment controlPoint in Target.ControlPointsList)
                    {
                        controlPoint.ConnectionSyncPosition = syncPosition;
                        controlPoint.ConnectionSyncRotation = syncRotation;
                    }

                    Target.SetSynchronisationPositionAndRotation(Target.transform.position, Target.transform.rotation);
                    Target.AutoSetFollowUp();
                }

                EditorGUILayout.EndHorizontal();
            }
        }

        private void PositionGuiElements(Action guiElementsDrawer, float elementsTotalWidth, bool spaceBefore = true, bool spaceAfter = true)
        {
            EditorGUILayout.BeginHorizontal(noMarginsStyle, GUILayout.Width(elementsTotalWidth));
            if (spaceBefore)
                GUILayout.FlexibleSpace();
            guiElementsDrawer();
            if (spaceAfter)
                GUILayout.FlexibleSpace();
            EditorGUILayout.EndHorizontal();
        }

        void FollowUpGui(DTInspectorNode node)
        {
            float drawingWidth = GetNodeWidth(node);
            float column1Width = drawingWidth * 2 / 10;
            float column2Width = drawingWidth * 2 / 10;
            float column3Width = drawingWidth * 3 / 10;
            float column4Width = drawingWidth * 3 / 10;

            bool hasCpWhichCanHaveFollowUp = Target.ControlPointsList.Any(item => item.Spline && item.Spline.CanControlPointHaveFollowUp(item));

            if (hasCpWhichCanHaveFollowUp)
            {
                //header           
                {
                    EditorGUILayout.BeginHorizontal();
                    PositionGuiElements(() => GUILayout.Label(splineTitleContent, EditorStyles.boldLabel, GUILayout.MaxWidth(column1Width)), column1Width);
                    PositionGuiElements(() => GUILayout.Label(endControlPointTitleContent, EditorStyles.boldLabel, GUILayout.MaxWidth(column2Width)), column2Width);
                    PositionGuiElements(() => GUILayout.Label(followUpTitleContent, EditorStyles.boldLabel), column3Width);
                    PositionGuiElements(() => GUILayout.Label(headingDirectionTitleContent, EditorStyles.boldLabel), column4Width);
                    EditorGUILayout.EndHorizontal();
                }

                for (int index = 0; index < Target.ControlPointsList.Count; index++)
                {
                    CurvySplineSegment item = Target.ControlPointsList[index];
                    if (item.Spline && item.Spline.CanControlPointHaveFollowUp(item))
                    {
                        EditorGUILayout.BeginHorizontal();

                        PositionGuiElements(() =>
                            GUILayout.Label(item.Spline.name, GUILayout.MaxWidth(column1Width)), column1Width);
                        PositionGuiElements(() =>
                            GUILayout.Label(String.Format("{0} ({1})", item.name, item.IsLastControlPoint
                                                ? "Last CP"
                                                : "First CP"), GUILayout.MaxWidth(column2Width)), column2Width);
                        PositionGuiElements(() =>
                            {
                                List<CurvySplineSegment> possibleTargets = (from cp in Target.ControlPointsList where cp != item select cp).ToList();
                                int popUpIndex;
                                {
                                    if (item.FollowUp == null)
                                        popUpIndex = 0;
                                    else
                                    {
                                        int followUpIndex = possibleTargets.IndexOf(item.FollowUp);
#if CURVY_SANITY_CHECKS
                                        Assert.IsTrue(followUpIndex != -1);
#endif
                                        popUpIndex = followUpIndex + 1;
                                    }
                                }

                                List<string> popUpContent;
                                {
                                    popUpContent = (from cp in possibleTargets select cp.ToString()).ToList();
                                    popUpContent.Insert(0, "No Follow-Up");
                                }

                                EditorGUI.BeginChangeCheck();

                                popUpIndex = EditorGUILayout.Popup(popUpIndex, popUpContent.ToArray(), GUILayout.MaxWidth(column3Width));

                                if (EditorGUI.EndChangeCheck())
                                {
                                    item.SetFollowUp(popUpIndex == 0
                                        ? null
                                        : possibleTargets[popUpIndex - 1]);
                                }
                            }, column3Width);

                        PositionGuiElements(() =>
                                            {
                                                CurvySplineSegment itemFollowUp = item.FollowUp;
                                                if (itemFollowUp)
                                                {
                                                    int popUpIndex = (int)item.FollowUpHeading + 1;
#if CURVY_SANITY_CHECKS
                                                    Assert.IsTrue((int)ConnectionHeadingEnum.Minus == -1);
                                                    Assert.IsTrue((int)ConnectionHeadingEnum.Sharp == 0);
                                                    Assert.IsTrue((int)ConnectionHeadingEnum.Plus == 1);
                                                    Assert.IsTrue((int)ConnectionHeadingEnum.Auto == 2);
#endif

                                                    GUIContent[] popUpContent =
                                                                        {
                                    CurvySplineSegment.CanFollowUpHeadToStart(itemFollowUp)
                                        ? splineStartDirectionContent
                                        : emptyContent,
                                    noDirectionContent,
                                    CurvySplineSegment.CanFollowUpHeadToEnd(itemFollowUp)
                                        ? splineEndDirectionContent
                                        : emptyContent,
                                    automaticDirectionContent
                                                    };
                                                    EditorGUI.BeginChangeCheck();
                                                    popUpIndex = EditorGUILayout.Popup(popUpIndex, popUpContent.ToArray(), GUILayout.MaxWidth(column4Width));
                                                    if (EditorGUI.EndChangeCheck())
                                                        item.FollowUpHeading = (ConnectionHeadingEnum)(popUpIndex - 1);
                                                }
                                                else
                                                    GUILayout.Label(directionUnavailableContent);
                                            }, column4Width);

                        EditorGUILayout.EndHorizontal();
                    }
                }
            }
            else
                GUILayout.Label("You should connect the first or last Control Point of an open spline to be able to setup Follow-Ups");
        }

        void ConnectionGui(DTInspectorNode node)
        {
            float drawingWidth = GetNodeWidth(node);

            if (GUILayout.Button("Delete Connection", GUILayout.Width(drawingWidth)))
            {
                Target.Delete();
                GUIUtility.ExitGUI();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyConnectionEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyEditorBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7e36bb3df4d2e75438de2de819b17da8
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.DevTools;
using FluffyUnderware.Curvy;
using System.Collections.Generic;


namespace FluffyUnderware.CurvyEditor
{
    public class CurvyEditorBase<T> : DTEditor<T> where T:MonoBehaviour
    {
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyEditorBase.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyEditorUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 0352d3a03998f41468aeff206517dd0e
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using System.IO;
using FluffyUnderware.Curvy;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.DevTools;
using JetBrains.Annotations;
using Application = UnityEngine.Application;

namespace FluffyUnderware.CurvyEditor
{

    public static class CurvyEditorUtility
    {
        public static void SendBugReport()
        {
            string par = string.Format("@Operating System@={0}&@Unity Version@={1}&@Curvy Version@={2}", SystemInfo.operatingSystem, Application.unityVersion, CurvySpline.VERSION);
            Application.OpenURL(CurvySpline.WEBROOT + "bugreport?" + par.Replace(" ", "%20"));
        }

        public static void GenerateAssemblyDefinitions()
        {
            string curvyRootPath = GetCurvyRootPath();
            if (String.IsNullOrEmpty(curvyRootPath))
            {
                DTLog.LogError("[Curvy] Assembly Definitions generation aborted, couldn't locate the installation folder");
            }
            else
            {
                string curvyRootPathAbsolute = Application.dataPath + "/" + curvyRootPath;
                DirectoryInfo parentInfo = Directory.GetParent(curvyRootPathAbsolute).Parent;
                string assetsParentDirectory = parentInfo.FullName;
                string toolbuddyDirectory = parentInfo.Parent.FullName;

                GenerateAssemblyDefinition($"{assetsParentDirectory}/Arrays Pooling/ToolBuddy.ArraysPooling.asmdef",
                    @"
{
	""name"":""ToolBuddy.ArraysPooling""
}");

                GenerateAssemblyDefinition($"{toolbuddyDirectory}/Dependencies/Vector Graphics/ToolBuddy.Dependencies.VectorGraphics.asmdef",
                    @"
{
	""name"":""ToolBuddy.Dependencies.VectorGraphics""
}");

                GenerateAssemblyDefinition($"{toolbuddyDirectory}/Dependencies/DevTools/FluffyUnderware.DevTools.asmdef",
                    @"
{
	""name"":""FluffyUnderware.DevTools""
}");

                GenerateAssemblyDefinition($"{toolbuddyDirectory}/Dependencies/LibTessDotNet/LibTessDotNet.asmdef",
                @"
{
	""name"":""LibTessDotNet"",
    ""references"":[
        ""ToolBuddy.ArraysPooling""
    ],
    ""includePlatforms"":[],
    ""excludePlatforms"":[]
}");

                GenerateAssemblyDefinition($"{toolbuddyDirectory}/Dependencies/DevTools/Editor/FlufyUnderware.DevTools.Editor.asmdef",
                @"
{
    ""name"":""FluffyUnderware.DevTools.Editor"",
    ""references"":[
        ""ToolBuddy.ArraysPooling"",
        ""FluffyUnderware.DevTools""
    ],
    ""includePlatforms"":[
        ""Editor""
    ],
    ""excludePlatforms"":[]
}");

                GenerateAssemblyDefinition($"{assetsParentDirectory}/Curvy/ToolBuddy.Curvy.asmdef",
                @"
{
    ""name"":""ToolBuddy.Curvy"",
    ""references"":[
        ""ToolBuddy.ArraysPooling"",
        ""ToolBuddy.Dependencies.VectorGraphics"",
        ""FluffyUnderware.DevTools"",
        ""LibTessDotNet""
    ],
    ""includePlatforms"":[],
    ""excludePlatforms"":[]
}");

                GenerateAssemblyDefinition($"{assetsParentDirectory}/Curvy/Editor/ToolBuddy.Curvy.Editor.asmdef",
                @"
{
    ""name"":""ToolBuddy.Curvy.Editor"",
    ""references"":[
        ""ToolBuddy.ArraysPooling"",
        ""ToolBuddy.Curvy"",
        ""FluffyUnderware.DevTools"",
        ""FluffyUnderware.DevTools.Editor"",
        ""LibTessDotNet""
    ],
    ""includePlatforms"":[
        ""Editor""
    ],
    ""excludePlatforms"":[]
}");

                GenerateAssemblyDefinition($"{assetsParentDirectory}/Curvy Examples/ToolBuddy.Curvy.Examples.asmdef",
                @"
{
    ""name"":""ToolBuddy.Curvy.Examples"",
    ""references"":[
        ""ToolBuddy.ArraysPooling"",
        ""FluffyUnderware.DevTools"",
        ""ToolBuddy.Curvy""
    ],
    ""includePlatforms"":[],
    ""excludePlatforms"":[]
}");

                GenerateAssemblyDefinition($"{assetsParentDirectory}/Curvy Examples/Editor/ToolBuddy.Curvy.Examples.Editor.asmdef",
                @"
{
    ""name"":""ToolBuddy.Curvy.Examples.Editor"",
    ""references"":[
        ""ToolBuddy.ArraysPooling"",
        ""FluffyUnderware.DevTools"",
        ""FluffyUnderware.DevTools.Editor"",
        ""ToolBuddy.Curvy"",
        ""ToolBuddy.Curvy.Editor"",
        ""ToolBuddy.Curvy.Examples""
    ],
    ""includePlatforms"":[
        ""Editor""
    ],
    ""excludePlatforms"":[]
}");

                AssetDatabase.Refresh();
            }
        }

        private static void GenerateAssemblyDefinition(string filePath, string fileContent)
        {
            DirectoryInfo directory = Directory.GetParent(filePath);
            if (Directory.Exists(directory.FullName) == false)
                EditorUtility.DisplayDialog("Missing directory",
                    String.Format("Could not find the directory '{0}', file generation will be skipped", directory.FullName), "Continue");
            else if (!File.Exists(filePath) || EditorUtility.DisplayDialog("Replace File?", String.Format("The file '{0}' already exists! Replace it?", filePath), "Yes", "No"))
                using (StreamWriter streamWriter = File.CreateText(filePath))
                {
                    streamWriter.WriteLine(fileContent);
                }
        }


        /// <summary>
        /// Converts a path/file relative to Curvy's root path to the real path, e.g. "ReadMe.txt" gives "Curvy/ReadMe.txt"
        /// </summary>
        /// <param name="relativePath">a path/file inside the Curvy package, WITHOUT the leading Curvy</param>
        /// <returns>the real path, relative to Assets</returns>
        public static string GetPackagePath(string relativePath)
        {
            return GetCurvyRootPath() + relativePath.TrimStart('/', '\\');
        }
        /// <summary>
        /// Converts a path/file relative to Curvy's root path to the real absolute path
        /// </summary>
        /// <param name="relativePath">a path/file inside the Curvy package, WITHOUT the leading Curvy</param>
        /// <returns>the absolute system path</returns>
        public static string GetPackagePathAbsolute(string relativePath)
        {
            return Application.dataPath + "/" + GetPackagePath(relativePath);
        }

        /// <summary>
        /// Gets the Curvy folder relative path, e.g. "Plugins/Curvy/" by default
        /// </summary>
        /// <returns></returns>
        public static string GetCurvyRootPath()
        {
            // Quick check for the regular path
            if (File.Exists(Application.dataPath + "/Plugins/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySpline.cs"))
                return "Plugins/ToolBuddy/Assets/Curvy/";


            // Still no luck? Do a project search
            string[] guid = AssetDatabase.FindAssets("curvyspline_private"); //FindAssets("curvyspline") returns also files other than CurvySpline.cs
            if (guid.Length == 0)
            {
                DTLog.LogError("[Curvy] Unable to locate CurvySpline_private.cs in the project! Is the Curvy package fully imported?");
                return null;
            }
            else
                return AssetDatabase.GUIDToAssetPath(guid[0]).TrimStart("Assets/").TrimEnd("Scripts/Splines/CurvySpline_private.cs");
        }

        /// <summary>
        /// Gets the Curvy folder absolute path, i.e. Application.dataPath+"/"+CurvyEditorUtility.GetCurvyRootPath()
        /// </summary>
        /// <returns></returns>
        public static string GetCurvyRootPathAbsolute()
        {
            return Application.dataPath + "/" + GetCurvyRootPath();
        }
    }

    public static class CurvyGizmo
    {
        /// <summary>
        /// Displays a label next to a point. The relative position of the label compared to the point is defined by <paramref name="direction"/>
        /// </summary>
#if CURVY_SANITY_CHECKS_PRIVATE
        [Obsolete("Do not call this method from a method not having the DrawGizmo attribute until the issue with Unity 2021.2 is fixed")]
#endif
        public static void PointLabel(Vector3 pointPosition, String label, OrientationAxisEnum direction, float? handleSize = null, [CanBeNull] GUIStyle style = null)
        {
#if UNITY_2021_2_0 || UNITY_2021_2_1 || UNITY_2021_2_2 || UNITY_2021_2_3 || UNITY_2021_2_4 || UNITY_2021_2_5 || UNITY_2021_2_6 || UNITY_2021_2_7 || UNITY_2021_2_8 || UNITY_2021_2_9 || UNITY_2021_2_10 || UNITY_2021_2_11
            //workaround to this issue: https://issuetracker.unity3d.com/issues/handles-dot-label-does-not-appear-in-the-supposed-place
            //the issue seems to not happen when this method is called from a OnGui method.
            pointPosition = DTHandles.TranslateByPixel(pointPosition, -53, 23);
#endif
            //ugly shit to bypass the joke that is style.alignment. Tried to bypass the issue by using style.CalcSize(new GUIContent(label)) to manually place the labels. No luck with that
            while (label.Length <= 5)
                label = $" {label} ";

            if (handleSize.HasValue == false)
                handleSize = HandleUtility.GetHandleSize(pointPosition);

            style = style ?? CurvyStyles.GizmoText;

            pointPosition -= Camera.current.transform.right * handleSize.Value * 0.1f;
            pointPosition += Camera.current.transform.up * handleSize.Value * 0.1f;
            Vector3 labelPosition;
            switch (direction)
            {
                case OrientationAxisEnum.Up:
                    //style.alignment = TextAnchor.LowerCenter;
                    labelPosition = pointPosition;
                    labelPosition += Camera.current.transform.up * handleSize.Value * 0.3f;
                    break;
                case OrientationAxisEnum.Down:
                    //style.alignment = TextAnchor.UpperCenter;
                    labelPosition = pointPosition;
                    labelPosition -= Camera.current.transform.up * handleSize.Value * 0.3f;
                    break;
                case OrientationAxisEnum.Right:
                    //style.alignment = TextAnchor.MiddleLeft;
                    labelPosition = pointPosition;
                    labelPosition += Camera.current.transform.right * handleSize.Value * 0.4f;
                    break;
                case OrientationAxisEnum.Left:
                    //style.alignment = TextAnchor.MiddleRight;
                    labelPosition = pointPosition;
                    labelPosition -= Camera.current.transform.right * handleSize.Value * 0.45f;
                    break;
                case OrientationAxisEnum.Forward:
                case OrientationAxisEnum.Backward:
                    //style.alignment = TextAnchor.MiddleCenter;
                    labelPosition = pointPosition;
                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(direction), direction, null);
            }

            Handles.Label(labelPosition, label, style);
        }
    }
    public static class CurvyGUI
    {

        #region ### GUI Controls ###

        public static bool Foldout(ref bool state, string text) { return Foldout(ref state, new GUIContent(text), null); }
        public static bool Foldout(ref bool state, string text, string helpURL) { return Foldout(ref state, new GUIContent(text), helpURL); }

        public static bool Foldout(ref bool state, GUIContent content, string helpURL, bool hierarchyMode = true)
        {
            Rect controlRect = GUILayoutUtility.GetRect(content, CurvyStyles.Foldout);
            bool isInsideInspector = DTInspectorNode.IsInsideInspector;
            int xOffset = isInsideInspector ? 12 : -2;
            controlRect.x -= xOffset;
            controlRect.width += (isInsideInspector ? 0 : 1);

            int indentLevel = DTInspectorNodeDefaultRenderer.RenderHeader(controlRect, xOffset, helpURL, content, ref state);

            EditorGUI.indentLevel = indentLevel;

            return state;
        }

        #endregion

    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyEditorUtility.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyMenu.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e881cd4f4b87e7646b55f627032e4ec0
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.Components;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.CurvyEditor.Generator;
using FluffyUnderware.Curvy.Controllers;
using FluffyUnderware.Curvy.Shapes;
using FluffyUnderware.DevToolsEditor;

namespace FluffyUnderware.CurvyEditor
{

    public static class CurvyMenu
    {
        #region ### Tools Menu ###
        #endregion

        #region ### GameObject Menu ###

        [MenuItem("GameObject/Curvy/Spline", false, 0)]
        public static void CreateCurvySpline(MenuCommand cmd)
        {
            CurvySpline spline = Create<CurvySpline>(cmd);
            ApplyIncrementalNameToSpline(spline);
        }

        [MenuItem("GameObject/Curvy/UI Spline", false, 1)]
        public static void CreateCurvyUISpline(MenuCommand cmd)
        {
            GameObject parent = cmd.context as GameObject;
            if (!parent || parent.GetComponentInParent<Canvas>() == null)
            {
                Canvas cv = GameObject.FindObjectOfType<Canvas>();
                if (cv)
                    parent = cv.gameObject;
                else
                    parent = new GameObject("Canvas", typeof(Canvas));
            }

            GameObject[] selectedGameObjects = Selection.gameObjects;
            if (selectedGameObjects.Length > 0 && cmd.context == selectedGameObjects[0])
                Selection.activeObject = null;

            CurvyUISpline uiSpline;
            {
                const string gameObjectName = "UI Spline";
                uiSpline = CurvyUISpline.CreateUISpline(gameObjectName);
                GameObjectUtility.SetParentAndAlign(uiSpline.gameObject, parent as GameObject);
                Undo.RegisterCreatedObjectUndo(uiSpline.gameObject, "Create " + gameObjectName);
            }

            DTSelection.AddGameObjects(uiSpline);
        }

        [MenuItem("GameObject/Curvy/Generator", false, 5)]
        public static void CreateCG(MenuCommand cmd)
        {
            CurvyGenerator generator = Create<CurvyGenerator>(cmd);
            ApplyIncrementalNameToGenerator(generator);

        }

        [MenuItem("GameObject/Curvy/Controllers/Spline", false, 10)]
        public static void CreateSplineController(MenuCommand cmd) => Create<SplineController>(cmd);

        [MenuItem("GameObject/Curvy/Controllers/CG Path", false, 12)]
        public static void CreatePathController(MenuCommand cmd) => Create<PathController>(cmd);

        [MenuItem("GameObject/Curvy/Controllers/CG Volume", false, 13)]
        public static void CreateVolumeController(MenuCommand cmd) => Create<VolumeController>(cmd);

        [MenuItem("GameObject/Curvy/Controllers/UI Text Spline", false, 14)]
        public static void CreateUITextSplineController(MenuCommand cmd) => Create<UITextSplineController>(cmd);

        [MenuItem("GameObject/" + CurvyLineRenderer.ComponentPath, false, 14)]
        public static void CreateCurvyLineRenderer(MenuCommand cmd) => Create<CurvyLineRenderer>(cmd);

        [MenuItem("GameObject/" + CurvySplineToEdgeCollider2D.ComponentPath, false, 14)]
        public static void CreateCurvySplineToEdgeCollider2D(MenuCommand cmd) => Create<CurvySplineToEdgeCollider2D>(cmd);

        [MenuItem("GameObject/Curvy/Shapes/Circle", false, 14)]
        public static void CreateCSCircle(MenuCommand cmd) => Create<CSCircle>(cmd);

        [MenuItem("GameObject/Curvy/Shapes/Pie", false, 14)]
        public static void CreateCSPie(MenuCommand cmd) => Create<CSPie>(cmd);

        [MenuItem("GameObject/Curvy/Shapes/Rectangle", false, 14)]
        public static void CreateCSRectangle(MenuCommand cmd) => Create<CSRectangle>(cmd);

        [MenuItem("GameObject/Curvy/Shapes/Rounded Rectangle", false, 14)]
        public static void CreateCSRoundedRectangle(MenuCommand cmd) => Create<CSRoundedRectangle>(cmd);

        [MenuItem("GameObject/Curvy/Shapes/Spiral", false, 14)]
        public static void CreateCSSpiral(MenuCommand cmd) => Create<CSSpiral>(cmd);

        [MenuItem("GameObject/Curvy/Shapes/Star", false, 14)]
        public static void CreateCSStar(MenuCommand cmd) => Create<CSStar>(cmd);

        [MenuItem("GameObject/Curvy/Misc/Nearest Spline Point", false, 14)]
        public static void CreateNearestSplinePoint(MenuCommand cmd) => Create<NearestSplinePoint>(cmd);

        [MenuItem("GameObject/Curvy/Misc/Curvy GL Renderer", false, 14)]
        public static void CreateCurvyGLRenderer(MenuCommand cmd) => Create<CurvyGLRenderer>(cmd);


        private static T Create<T>(MenuCommand cmd) where T : MonoBehaviour
        {
            GameObject[] selectedGameObjects = Selection.gameObjects;
            if (selectedGameObjects.Length > 0 && cmd.context == selectedGameObjects[0])
                Selection.activeObject = null;
            T createdObject = CreateCurvyObjectAsChild<T>(cmd.context, typeof(T).Name);
            DTSelection.AddGameObjects(createdObject);
            return createdObject;
        }

        #endregion

        #region ### Project window Create Menu ###

        [MenuItem("Assets/Create/Curvy/CG Module")]
        public static void CreatePCGModule()
        {
            ModuleWizard.Open();
        }

        [MenuItem("Assets/Create/Curvy/Shape")]
        public static void CreateShape()
        {
            ShapeWizard.Open();
        }

        #endregion

        public static T CreateCurvyObject<T>(Object parent, string name) where T : MonoBehaviour
        {
            GameObject go = parent as GameObject;
            if (go == null)
            {
                go = new GameObject(name);
                Undo.RegisterCreatedObjectUndo(go, "Create " + name);
            }

            T obj = go.AddComponent<T>();
            Undo.RegisterCreatedObjectUndo(obj, "Create " + name);

            return obj;
        }

        public static T CreateCurvyObjectAsChild<T>(Object parent, string name) where T : MonoBehaviour
        {
            GameObject go = new GameObject(name);
            T obj = go.AddComponent<T>();
            GameObjectUtility.SetParentAndAlign(go, parent as GameObject);
            Undo.RegisterCreatedObjectUndo(go, "Create " + name);

            return obj;
        }

        /// <summary>
        /// Rename the given spline to "Curvy Spline number_of_existing_splines"
        /// </summary>
        public static void ApplyIncrementalNameToSpline(CurvySpline spline)
        {
            ApplyIncrementalName(spline, "Curvy Spline");
        }

        /// <summary>
        /// Rename the given generator to "Curvy Generator number_of_existing_generators"
        /// </summary>
        public static void ApplyIncrementalNameToGenerator(CurvyGenerator generator)
        {
            ApplyIncrementalName(generator, "Curvy Generator");
        }

        /// <summary>
        /// Rename the given component to "<paramref name="baseName"/> number_of_existing_components_of_type_T"
        /// </summary>
        public static void ApplyIncrementalName<T>(T component, string baseName) where T : Component
        {
            component.name = $"{baseName} {Object.FindObjectsOfType<T>().Length}";
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyMenu.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyPositionModeDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7c344282607d5504190915d0f7a2c163
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using FluffyUnderware.Curvy;
using UnityEngine;
using UnityEditor;

namespace FluffyUnderware.CurvyEditor.Controllers
{
    [CustomPropertyDrawer(typeof(CurvyPositionMode))]
    public class CurvyPositionModeDrawer : PropertyDrawer
    {
        private const string Relative = "Relative";
        private const string Absolute = "Absolute";

        readonly GUIContent[] options = new[]
        {
            new GUIContent(Relative,
                "Position is expressed as a fraction of a spline: 0 meaning the spline start, 1 meaning the spline end."),
            new GUIContent(Absolute,
                "Position is expressed as world units")
        };
        readonly GUIStyle guiStyle = EditorStyles.popup;

        override public void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            EditorGUI.BeginProperty(position, label, property);
            property.intValue = EditorGUI.Popup(position, label, property.intValue, options, guiStyle);
            EditorGUI.EndProperty();
        }

        /// <summary>
        /// Gets the display name associated with a specific CurvyPositionMode value
        /// </summary>
        public static string GetDisplayName(CurvyPositionMode positionMode)
        {
            string displayName;
            
            switch (positionMode)
            {
                case CurvyPositionMode.Relative:
                    displayName = Relative;
                    break;
                case CurvyPositionMode.WorldUnits:
                    displayName = Absolute;
                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(positionMode), positionMode, null);
            }

            return displayName;

        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyPositionModeDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyProject.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6827729ab53799b47807d90abc775dbe
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevToolsEditor;
using System.Collections.Generic;

namespace FluffyUnderware.CurvyEditor
{
    public class CurvyProject : DTProject
    {
        public const string NAME = "Curvy";
        public const string RELPATH_SHAPEWIZARDSCRIPTS = "/Shapes";
        public const string RELPATH_CGMODULEWIZARDSCRIPTS = "/Generator Modules";
        public const string RELPATH_CGMODULEWIZARDEDITORSCRIPTS = "/Generator Modules/Editor";
        public const string RELPATH_CGTEMPLATES = "/Generator Templates";

        public static CurvyProject Instance
        {
            get
            {
                return (CurvyProject)DT.Project(NAME);
            }
        }

        #region ### Persistent Settings ###
        // DESIGN those settings are a mess: some are public fields, other properties of which the setter updates the editor preferences, and finally others ae part of CurvyGlobalManager (see CurvyProject.LoadPreferences to have a listing of them all). Shouldn't all of those settings be treated similarly?

        // Settings from Preferences window not stored in CurvyGlobalManager

        public bool SnapValuePrecision = true;
        /// <summary>
        /// If enabled and the spline has Restrict To 2D enabled, dots are shown instead of the default move handles
        /// </summary>
        public bool UseTiny2DHandles = false;
        /// <summary>
        /// Should the spline's text gizmos fade if the spline is too small on the screen
        /// </summary>
        public bool AutoFadeLabels = true;
        public bool ShowGlobalToolbar = true;
        public bool ShowHints = true;
        public bool EnableMetrics = true;
        public bool EnableAnnouncements = true;

        // Settings made in the toolbar or somewhere else

        bool mCGAutoModuleDetails = false;
        public bool CGAutoModuleDetails
        {
            get { return mCGAutoModuleDetails; }
            set
            {
                if (mCGAutoModuleDetails != value)
                {
                    mCGAutoModuleDetails = value;
                    SetEditorPrefs("CGAutoModuleDetails", mCGAutoModuleDetails);
                }
            }
        }

        bool mCGSynchronizeSelection = true;
        public bool CGSynchronizeSelection
        {
            get { return mCGSynchronizeSelection; }
            set
            {
                if (mCGSynchronizeSelection != value)
                {
                    mCGSynchronizeSelection = value;
                    SetEditorPrefs("CGSynchronizeSelection", mCGSynchronizeSelection);
                }
            }
        }

        bool mCGShowHelp = true;
        public bool CGShowHelp
        {
            get { return mCGShowHelp; }
            set
            {
                if (mCGShowHelp != value)
                {
                    mCGShowHelp = value;
                    SetEditorPrefs("CGShowHelp", mCGShowHelp);
                }
            }
        }

        int mCGGraphSnapping = 5;
        /// <summary>
        /// The size of the grid used for snapping when dragging a module in Curvy Generator Graph
        /// </summary>
        public int CGGraphSnapping
        {
            get { return mCGGraphSnapping; }
            set
            {
                int v = Mathf.Max(1, value);
                if (mCGGraphSnapping != v)
                {
                    mCGGraphSnapping = v;
                    SetEditorPrefs("CGGraphSnapping", mCGGraphSnapping);
                }
            }
        }

        string mCustomizationRootPath = "Packages/Curvy Customization";
        public string CustomizationRootPath
        {
            get
            {
                return mCustomizationRootPath;
            }
            set
            {
                if (mCustomizationRootPath != value)
                {
                    mCustomizationRootPath = value;
                    SetEditorPrefs("CustomizationRootPath", mCustomizationRootPath);
                }
            }
        }

        CurvyBezierModeEnum mBezierMode = CurvyBezierModeEnum.Direction | CurvyBezierModeEnum.Length;
        public CurvyBezierModeEnum BezierMode
        {
            get { return mBezierMode; }
            set
            {
                if (mBezierMode != value)
                {
                    mBezierMode = value;
                    SetEditorPrefs("BezierMode", mBezierMode);
                }
            }
        }

        CurvyAdvBezierModeEnum mAdvBezierMode = CurvyAdvBezierModeEnum.Direction | CurvyAdvBezierModeEnum.Length;
        public CurvyAdvBezierModeEnum AdvBezierMode
        {
            get { return mAdvBezierMode; }
            set
            {
                if (mAdvBezierMode != value)
                {
                    mAdvBezierMode = value;
                    SetEditorPrefs("AdvBezierMode", mAdvBezierMode);
                }
            }
        }

        bool mShowAboutOnLoad = true;
        public bool ShowAboutOnLoad
        {
            get
            {
                return mShowAboutOnLoad;
            }
            set
            {
                if (mShowAboutOnLoad != value)
                    mShowAboutOnLoad = value;
                SetEditorPrefs("ShowAboutOnLoad", mShowAboutOnLoad);
            }
        }

        #endregion





        static Vector2 scroll;
        static readonly bool[] foldouts = new bool[4] { true, true, true, true };
        readonly List<int> mShowConIconObjects = new List<int>();


        public CurvyProject()
            : base(NAME, CurvySpline.VERSION)
        {
            Resource = CurvyResource.Instance;
            Undo.undoRedoPerformed -= OnUndoRedo;
            Undo.undoRedoPerformed += OnUndoRedo;
            EditorApplication.update -= OnUpdate;
            EditorApplication.update += OnUpdate;
            EditorApplication.update += checkLaunch;
            EditorApplication.hierarchyChanged -= ScanConnections;
            EditorApplication.hierarchyChanged += ScanConnections;
            EditorApplication.hierarchyWindowItemOnGUI -= OnHierarchyWindowItemOnGUI;
            EditorApplication.hierarchyWindowItemOnGUI += OnHierarchyWindowItemOnGUI;
            ScanConnections();
        }

        /// <summary>
        /// Rebuilds the list of GameObject that needs to show a connection icon in the hierarchy window
        /// </summary>
        /// <remarks>Usually there is no need to call this manually</remarks>
        public void ScanConnections()
        {
            int old = mShowConIconObjects.Count;
            mShowConIconObjects.Clear();

            CurvyConnection[] o = GameObject.FindObjectsOfType<CurvyConnection>();
            foreach (CurvyConnection con in o)
            {
                foreach (CurvySplineSegment cp in con.ControlPointsList)
                {
                    if (cp != null && cp.gameObject != null)
                        // see comment in CurvyConnection.DoUpdate to know more about when cp.gameObject can be null
                        mShowConIconObjects.Add(cp.gameObject.GetInstanceID());
                }
            }

            if (old != mShowConIconObjects.Count)
                EditorApplication.RepaintHierarchyWindow();
        }

        void OnHierarchyWindowItemOnGUI(int instanceid, Rect selectionrect)
        {
            if (mShowConIconObjects.Contains(instanceid))
            {
                GUI.DrawTexture(new Rect(selectionrect.xMax - 14, selectionrect.yMin + 4, 10, 10), CurvyStyles.HierarchyConnectionTexture);
            }
        }

        void checkLaunch()
        {
            EditorApplication.update -= checkLaunch;
            if (ShowAboutOnLoad)
                AboutWindow.Open();
        }

        void OnUpdate()
        {

            // check if a deleted Curvy object defines a new object to select
            if (EditorApplication.isPlayingOrWillChangePlaymode)
                CurvySpline._newSelectionInstanceIDINTERNAL = 0;

            if (CurvySpline._newSelectionInstanceIDINTERNAL != 0)
            {
                Object o = EditorUtility.InstanceIDToObject(CurvySpline._newSelectionInstanceIDINTERNAL);
                if (o != null && o is Component)
                    DTSelection.SetGameObjects((Component)o);
                CurvySpline._newSelectionInstanceIDINTERNAL = 0;
            }
        }

        void OnUndoRedo()
        {
            List<CurvySpline> splines = DTSelection.GetAllAs<CurvySpline>();
            List<CurvySplineSegment> cps = DTSelection.GetAllAs<CurvySplineSegment>();
            foreach (CurvySplineSegment cp in cps)
            {
                CurvySpline curvySpline = cp.transform.parent
                    ? cp.transform.parent.GetComponent<CurvySpline>()
                    : cp.Spline;
                if (curvySpline && !splines.Contains(curvySpline))
                    splines.Add(curvySpline);
            }

            foreach (CurvySpline spl in splines)
            {
                spl.SyncSplineFromHierarchy();
                //spl.SetDirtyAll(SplineDirtyingType.Everything, true); is already done in spl.SyncSplineFromHierarchy();
                spl.Refresh();
            }
        }



        public override void ResetPreferences()
        {
            //reset only settings that are settable through the Preferences window

            base.ResetPreferences();
            CurvyGlobalManager.DefaultInterpolation = CurvyInterpolation.CatmullRom;
            CurvyGlobalManager.DefaultGizmoColor = CurvyGlobalManager.DefaultDefaultGizmoColor;
            CurvyGlobalManager.DefaultGizmoSelectionColor = CurvyGlobalManager.DefaultDefaultGizmoSelectionColor;
            CurvyGlobalManager.GizmoControlPointSize = 0.15f;
            CurvyGlobalManager.GizmoOrientationLength = 1f;
            CurvyGlobalManager.GizmoOrientationColor = CurvyGlobalManager.DefaultGizmoOrientationColor;
            CurvyGlobalManager.SceneViewResolution = 0.5f;
            CurvyGlobalManager.HideManager = false;
            CurvyGlobalManager.SplineLayer = 0;
            CurvyGlobalManager.SaveGeneratorOutputs = true;

            CustomizationRootPath = "Packages/Curvy Customization";
            SnapValuePrecision = true;
            UseTiny2DHandles = false;
            AutoFadeLabels = true;
            ShowGlobalToolbar = true;
            EnableMetrics = true;
            EnableAnnouncements = true;
            ShowHints = true;

            ToolbarMode = DTToolbarMode.Full;
            ToolbarOrientation = DTToolbarOrientation.Left;

            DT._UseSnapValuePrecision = SnapValuePrecision;
            DTToolbarItem._StatusBar.Visible = ShowHints;
        }

        public override void LoadPreferences()
        {
            if (GetEditorPrefs("Version", "PreDT") == "PreDT")
            {
                DeletePreDTSettings();
                SavePreferences();
            }
            base.LoadPreferences();
            CurvyGlobalManager.DefaultInterpolation = GetEditorPrefs("DefaultInterpolation", CurvyGlobalManager.DefaultInterpolation);
            CurvyGlobalManager.DefaultGizmoColor = GetEditorPrefs("GizmoColor", CurvyGlobalManager.DefaultGizmoColor);
            CurvyGlobalManager.DefaultGizmoSelectionColor = GetEditorPrefs("GizmoSelectionColor", CurvyGlobalManager.DefaultGizmoSelectionColor);
            CurvyGlobalManager.GizmoControlPointSize = GetEditorPrefs("GizmoControlPointSize", CurvyGlobalManager.GizmoControlPointSize);
            CurvyGlobalManager.GizmoOrientationLength = GetEditorPrefs("GizmoOrientationLength", CurvyGlobalManager.GizmoOrientationLength);
            CurvyGlobalManager.GizmoOrientationColor = GetEditorPrefs("GizmoOrientationColor", CurvyGlobalManager.GizmoOrientationColor);
            CurvyGlobalManager.Gizmos = GetEditorPrefs("Gizmos", CurvyGlobalManager.Gizmos);
            CurvyGlobalManager.SceneViewResolution = Mathf.Clamp01(GetEditorPrefs("SceneViewResolution", CurvyGlobalManager.SceneViewResolution));
            CurvyGlobalManager.HideManager = GetEditorPrefs("HideManager", CurvyGlobalManager.HideManager);
            CurvyGlobalManager.SplineLayer = GetEditorPrefs("SplineLayer", CurvyGlobalManager.SplineLayer);
            CurvyGlobalManager.SaveGeneratorOutputs = GetEditorPrefs("SaveGeneratorOutputs", CurvyGlobalManager.SaveGeneratorOutputs);

            mCustomizationRootPath = GetEditorPrefs("CustomizationRootPath", mCustomizationRootPath);
            SnapValuePrecision = GetEditorPrefs("SnapValuePrecision", true);
            UseTiny2DHandles = GetEditorPrefs("UseTiny2DHandles", UseTiny2DHandles);
            AutoFadeLabels = GetEditorPrefs("AutoFadeLabels", AutoFadeLabels);
            ShowGlobalToolbar = GetEditorPrefs("ShowGlobalToolbar", ShowGlobalToolbar);
            EnableMetrics = GetEditorPrefs("EnableMetrics", true);
            EnableAnnouncements = GetEditorPrefs("EnableAnnouncements", true);
            ShowHints = GetEditorPrefs("ShowHints", ShowHints);

            CurvyGlobalManager.SaveRuntimeSettings();

            mCGAutoModuleDetails = GetEditorPrefs("CGAutoModuleDetails", mCGAutoModuleDetails);
            mCGSynchronizeSelection = GetEditorPrefs("CGSynchronizeSelection", mCGSynchronizeSelection);
            mCGShowHelp = GetEditorPrefs("CGShowHelp", mCGShowHelp);
            mCGGraphSnapping = GetEditorPrefs("CGGraphSnapping", mCGGraphSnapping);
            mBezierMode = GetEditorPrefs("BezierMode", mBezierMode);
            mAdvBezierMode = GetEditorPrefs("AdvBezierMode", mAdvBezierMode);
            mShowAboutOnLoad = GetEditorPrefs("ShowAboutOnLoad", mShowAboutOnLoad);

            DT._UseSnapValuePrecision = SnapValuePrecision;
            DTToolbarItem._StatusBar.Visible = ShowHints;
        }

        public override void SavePreferences()
        {
            base.SavePreferences();
            SetEditorPrefs("DefaultInterpolation", CurvyGlobalManager.DefaultInterpolation);
            SetEditorPrefs("GizmoColor", CurvyGlobalManager.DefaultGizmoColor);
            SetEditorPrefs("GizmoSelectionColor", CurvyGlobalManager.DefaultGizmoSelectionColor);
            SetEditorPrefs("GizmoControlPointSize", CurvyGlobalManager.GizmoControlPointSize);
            SetEditorPrefs("GizmoOrientationLength", CurvyGlobalManager.GizmoOrientationLength);
            SetEditorPrefs("GizmoOrientationColor", CurvyGlobalManager.GizmoOrientationColor);
            SetEditorPrefs("Gizmos", CurvyGlobalManager.Gizmos);
            SetEditorPrefs("SnapValuePrecision", SnapValuePrecision);
            SetEditorPrefs("EnableAnnouncements", EnableAnnouncements);
            SetEditorPrefs("EnableMetrics", EnableMetrics);
            SetEditorPrefs("SceneViewResolution", CurvyGlobalManager.SceneViewResolution);
            SetEditorPrefs("HideManager", CurvyGlobalManager.HideManager);
            SetEditorPrefs("UseTiny2DHandles", UseTiny2DHandles);
            SetEditorPrefs("AutoFadeLabels", AutoFadeLabels);
            SetEditorPrefs("ShowGlobalToolbar", ShowGlobalToolbar);
            SetEditorPrefs("ShowHints", ShowHints);
            SetEditorPrefs("SplineLayer", CurvyGlobalManager.SplineLayer);
            SetEditorPrefs("SaveGeneratorOutputs", CurvyGlobalManager.SaveGeneratorOutputs);
            SetEditorPrefs("CustomizationRootPath", mCustomizationRootPath);

            CurvyGlobalManager.SaveRuntimeSettings();
            DT._UseSnapValuePrecision = SnapValuePrecision;
            DTToolbarItem._StatusBar.Visible = ShowHints;
        }

        protected override void UpgradePreferences(string oldVersion)
        {
            base.UpgradePreferences(oldVersion);
            // Ensure that About Window will be shown after upgrade
            DeleteEditorPrefs("ShowAboutOnLoad");
            if (oldVersion == "2.0.0")
            {
                if (GetEditorPrefs("GizmoOrientationLength", CurvyGlobalManager.GizmoOrientationLength) == 4)
                    DeleteEditorPrefs("GizmoOrientationLength");
            }

        }

        void DeletePreDTSettings()
        {
            DTLog.Log("[Curvy] Removing old preferences");
            EditorPrefs.DeleteKey("Curvy_GizmoColor");
            EditorPrefs.DeleteKey("Curvy_GizmoSelectionColor");
            EditorPrefs.DeleteKey("Curvy_ControlPointSize");
            EditorPrefs.DeleteKey("Curvy_OrientationLength");
            EditorPrefs.DeleteKey("Curvy_Gizmos");
            EditorPrefs.DeleteKey("Curvy_ToolbarLabels");
            EditorPrefs.DeleteKey("Curvy_ToolbarOrientation");
            EditorPrefs.DeleteKey("Curvy_ShowShapeWizardUndoWarning");
            EditorPrefs.DeleteKey("Curvy_KeyBindings");
        }

        #region Settings window

        /// <summary>
        /// The name of the settings entry of Curvy
        /// </summary>
        const string SettingsEntryName = "Curvy";

        /// <summary>
        /// The class used by Unity 2018.3 and newer to provide Curvy's preferences window
        /// </summary>
        public class CurvySettingsProvider : SettingsProvider
        {

            public CurvySettingsProvider(SettingsScope scopes, IEnumerable<string> keywords = null)
                : base(GetPreferencesPath(), scopes, keywords)
            { }

            public override void OnGUI(string searchContext)
            {
                PreferencesGUI();
            }

            /// <summary>
            /// The settings path for Curvy's Settings
            /// </summary>
            public static string GetPreferencesPath()
            {
                return "Preferences/" + SettingsEntryName;
            }
        }

        [SettingsProvider]
        static SettingsProvider MyNewPrefCode()
        {
            return new CurvySettingsProvider(SettingsScope.User);
        }

        public static void PreferencesGUI()
        {
            scroll = EditorGUILayout.BeginScrollView(scroll);
            CurvyGlobalManager.DefaultInterpolation = (CurvyInterpolation)EditorGUILayout.EnumPopup("Default Spline Type", CurvyGlobalManager.DefaultInterpolation);
            CurvyGlobalManager.SplineLayer = EditorGUILayout.LayerField(new GUIContent("Default Spline Layer", "Layer to use for splines and Control Points"), CurvyGlobalManager.SplineLayer);

            CurvyGlobalManager.SaveGeneratorOutputs = EditorGUILayout.Toggle(new GUIContent("Save Generator Outputs", "Whether the output of Curvy Generators should be saved in the scene file.\nDisable this option to reduce the size of scene files. This might increase the saving time for complex scenes.\nThis option applies only on generators that are enabled and have Auto Refresh set to true"), CurvyGlobalManager.SaveGeneratorOutputs);

            Instance.SnapValuePrecision = EditorGUILayout.Toggle(new GUIContent("Snap Value Precision", "Round inspector values"), Instance.SnapValuePrecision);

            CurvyGlobalManager.HideManager = EditorGUILayout.Toggle(new GUIContent("Hide _CurvyGlobal_", "Hide the global manager in Hierarchy?"), CurvyGlobalManager.HideManager);

            Instance.EnableAnnouncements = EditorGUILayout.Toggle(new GUIContent("Enable Announcements", "Display announcements from Curvy's developers"), Instance.EnableAnnouncements);

            Instance.EnableMetrics = EditorGUILayout.Toggle(new GUIContent("Enable Metrics", "Send metrics to Curvy's developers. This includes data such as the Unity version, Curvy version, etc... Keeping this enabled helps us a lot maintaining Curvy"), Instance.EnableMetrics);

            {
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.TextField(new GUIContent("Customization Root Path", "Base Path for custom Curvy extensions"), Instance.CustomizationRootPath);
                if (GUILayout.Button(new GUIContent("<", "Select"), GUILayout.ExpandWidth(false)))
                {
                    string path = EditorUtility.OpenFolderPanel("Customization Root Path", Application.dataPath, "");
                    if (!string.IsNullOrEmpty(path))
                        Instance.CustomizationRootPath = path.Replace(Application.dataPath + "/", "");
                }
                EditorGUILayout.EndHorizontal();
            }
            CurvyGlobalManager.SceneViewResolution = EditorGUILayout.Slider(new GUIContent("SceneView Resolution", "Lower values results in faster SceneView drawing"), CurvyGlobalManager.SceneViewResolution, 0, 1);

            foldouts[0] = EditorGUILayout.Foldout(foldouts[0], "Gizmo", CurvyStyles.Foldout);
            if (foldouts[0])
            {
                CurvyGlobalManager.DefaultGizmoColor = EditorGUILayout.ColorField("Spline color", CurvyGlobalManager.DefaultGizmoColor);
                CurvyGlobalManager.DefaultGizmoSelectionColor = EditorGUILayout.ColorField("Spline Selection color", CurvyGlobalManager.DefaultGizmoSelectionColor);
                CurvyGlobalManager.GizmoControlPointSize = EditorGUILayout.FloatField("Control Point Size", CurvyGlobalManager.GizmoControlPointSize);
                CurvyGlobalManager.GizmoOrientationLength = EditorGUILayout.FloatField(new GUIContent("Orientation Length", "Orientation gizmo size"), CurvyGlobalManager.GizmoOrientationLength);
                CurvyGlobalManager.GizmoOrientationColor = EditorGUILayout.ColorField(new GUIContent("Orientation Color", "Orientation gizmo color"), CurvyGlobalManager.GizmoOrientationColor);
                Instance.UseTiny2DHandles = EditorGUILayout.Toggle(new GUIContent("Use Tiny 2D Handles", "If enabled and the spline has Restrict To 2D enabled, dots are shown instead of the default move handles"), Instance.UseTiny2DHandles);
                Instance.AutoFadeLabels = EditorGUILayout.Toggle(new GUIContent("Auto Fade Labels", "Should the spline's text gizmos fade if the spline is too small on the screen"), Instance.AutoFadeLabels);
            }

            foldouts[1] = EditorGUILayout.Foldout(foldouts[1], "UI", CurvyStyles.Foldout);
            if (foldouts[1])
            {
                Instance.ShowGlobalToolbar = EditorGUILayout.Toggle(new GUIContent("Show Global Toolbar", "Always show Curvy Toolbar"), Instance.ShowGlobalToolbar);
                Instance.ToolbarMode = (DTToolbarMode)EditorGUILayout.EnumPopup(new GUIContent("Toolbar Labels", "Defines Toolbar Display Mode"), Instance.ToolbarMode);
                Instance.ToolbarOrientation = (DTToolbarOrientation)EditorGUILayout.EnumPopup(new GUIContent("Toolbar Orientation", "Defines Toolbar Position"), Instance.ToolbarOrientation);
                Instance.ShowHints = EditorGUILayout.Toggle(new GUIContent("Show Hints", "Show hints, at the bottom of scene view, about the usage of some Curvy editor tools"), Instance.ShowHints);
            }

            foldouts[2] = EditorGUILayout.Foldout(foldouts[2], "Shortcuts", CurvyStyles.Foldout);
            if (foldouts[2])
            {
                List<EditorKeyBinding> keys = Instance.GetProjectBindings();
                foreach (EditorKeyBinding binding in keys)
                {
                    if (binding.OnPreferencesGUI()) // save changed bindings
                    {
                        Instance.SetEditorPrefs(binding.Name, binding.ToPrefsString());
                    }
                    GUILayout.Space(2);
                    GUILayout.Box("", GUILayout.Height(1), GUILayout.ExpandWidth(true));
                    GUILayout.Space(2);
                }
            }
            if (GUILayout.Button("Reset to defaults"))
            {
                Instance.ResetPreferences();

                List<EditorKeyBinding> keys = Instance.GetProjectBindings();
                foreach (EditorKeyBinding binding in keys)
                    Instance.DeleteEditorPrefs(binding.Name);
            }

            EditorGUILayout.EndScrollView();

            if (GUI.changed)
            {
                Instance.SavePreferences();
                DT.ReInitialize(false);
            }

        }

        #endregion
    }

    /// <summary>
    /// Class for loading image resources
    /// </summary>
    public class CurvyResource : DTResource
    {
        static CurvyResource _Instance;
        public static CurvyResource Instance
        {
            get
            {
                if (_Instance == null)
                    _Instance = new CurvyResource();
                return _Instance;
            }
        }

        public CurvyResource()
        {
            ResourceDLL = FindResourceDLL("CurvyEditorIcons");
            ResourceNamespace = "";//Assets.Curvy.Editor.Resources.";
        }

        private const string fallbackPackedString = "missing,16,16";

        public static Texture2D Load(string packedString)
        {
            Texture2D tex = Instance.LoadPacked(packedString);
            if (tex == null)
            {
                DTLog.LogError("Loading texture from packed string failed: " + packedString);
                return Instance.LoadPacked(fallbackPackedString);
            }

            return tex;
        }




    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyProject.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyPropertyDrawers.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f92c1064c99953f48bee8ba7373405a0
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using UnityEditor;
using System.Reflection;
using System;
using System.Collections.Generic;
using FluffyUnderware.CurvyEditor;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.CurvyEditor.Generator;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.CurvyEditor
{

    #region ### CG related ###


    //[CustomPropertyDrawer(typeof(CGSpot))]
    public class CGSpotPropertyDrawer : PropertyDrawer
    {

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            base.OnGUI(position, property, label);
            //  property.f
        }
    }

    [CustomPropertyDrawer(typeof(CGResourceCollectionManagerAttribute))]
    public class CGResourceCollectionManagerPropertyDrawer : DTPropertyDrawer<CGResourceCollectionManagerAttribute>
    {

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            Rect mControlRect = position;
            CGResourceManagerAttribute A = (CGResourceManagerAttribute)attribute;
            ICGResourceCollection lst = this.GetPropertySourceField<ICGResourceCollection>(property);

            label = EditorGUI.BeginProperty(position, label, property);

            if (lst != null)
            {
                if (lst.Count > 0)
                    label.text += string.Format("[{0}]", lst.Count);
                EditorGUI.PrefixLabel(mControlRect, label);
                mControlRect.x = (A.ReadOnly) ? mControlRect.xMax - 60 : mControlRect.xMax - 82;
                mControlRect.width = 60;

                if (GUI.Button(mControlRect, new GUIContent("Select", CurvyStyles.SelectTexture, "Select")))
                    DTSelection.SetGameObjects(lst.ItemsArray);
            }
        }
    }

    [CustomPropertyDrawer(typeof(CGResourceManagerAttribute), true)]
    public class CGResourceManagerPropertyDrawer : DTPropertyDrawer<CGResourceManagerAttribute>
    {

        CGResourceEditor ResourceEditor;



        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            Rect mControlRect = position;
            label = EditorGUI.BeginProperty(position, label, property);
            CGResourceManagerAttribute A = (CGResourceManagerAttribute)attribute;
            CGModule module = (CGModule)property.serializedObject.targetObject;
            Component res = (Component)property.objectReferenceValue;
            if (res)
            {
                Transform parent = res.transform.parent;
                bool managed = (parent != null && parent.transform == module.transform);
                if (managed)
                {
                    EditorGUI.PrefixLabel(mControlRect, label);
                    mControlRect.x = (A.ReadOnly) ? mControlRect.xMax - 60 : mControlRect.xMax - 82;
                    mControlRect.width = 60;
                    if (GUI.Button(mControlRect, new GUIContent("Select", CurvyStyles.SelectTexture, "Select"), CurvyStyles.SmallButton))
                        Selection.activeObject = property.objectReferenceValue;
                    if (!A.ReadOnly)
                    {
                        mControlRect.x += mControlRect.width + 2;
                        mControlRect.width = 20;
                        if (GUI.Button(mControlRect, new GUIContent(CurvyStyles.DeleteSmallTexture, "Delete resource"), CurvyStyles.SmallButton))
                        {
                            if (EditorUtility.DisplayDialog("Delete resource", "This will permanently delete the resource! This operation cannot be undone. Proceed?", "Yes", "No"))
                            {
                                if (DTUtility.DoesPrefabStatusAllowDeletion(res.gameObject, out string errorMessage))
                                {
                                    module.DeleteManagedResource(A.ResourceName, res);
                                    property.objectReferenceValue = null;
                                    ResourceEditor = null;
                                }
                                else
                                {
                                    EditorUtility.DisplayDialog($"Cannot delete Game Object '{res.name}'", errorMessage, "Ok");
                                }
                            }
                        }
                    }

                    if (property.objectReferenceValue != null)
                    {
                        //if (!ResourceEditor)
                        ResourceEditor = CGResourceEditorHandler.GetEditor(A.ResourceName, res);

                        if (ResourceEditor && ResourceEditor.OnGUI())
                        {
                            // TODO: Refresh using new value not always working!
                            module.Invoke("OnValidate", 0);
                            module.Dirty = true;
                            module.Generator.Invoke("Update", 1f);
                        }
                    }
                }
                else
                {
                    mControlRect.width -= 20;
                    EditorGUI.PropertyField(mControlRect, property, label);
                    mControlRect.x += mControlRect.width + 2;
                    mControlRect.width = 20;
                    if (GUI.Button(mControlRect, new GUIContent(CurvyStyles.ClearSmallTexture, "Unset")))
                    {
                        property.objectReferenceValue = null;
                        ResourceEditor = null;
                    }


                }
            }
            else
            {
                mControlRect.width -= 20;
                EditorGUI.PropertyField(mControlRect, property, label);
                mControlRect.x = mControlRect.xMax + 2;
                mControlRect.width = 20;
                if (GUI.Button(mControlRect, new GUIContent(CurvyStyles.AddSmallTexture, "Add Managed")))
                {
                    // Call AddResource to create and name the resource
                    property.objectReferenceValue = module.AddManagedResource(A.ResourceName);
                }
            }


            EditorGUI.EndProperty();
        }


    }

    [CustomPropertyDrawer(typeof(CGDataReferenceSelectorAttribute))]
    public class CGDataReferenceSelectorPropertyDrawer : DTPropertyDrawer<CGDataReferenceSelectorAttribute>
    {
        SerializedProperty CurrentProp;

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            return (GetPropertySourceField<CGDataReference>(property).HasValue) ? base.GetPropertyHeight(property, label) : base.GetPropertyHeight(property, label) * 2;
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            CGDataReferenceSelectorAttribute attrib = (CGDataReferenceSelectorAttribute)attribute;
            CurrentProp = property;
            CGDataReference field = GetPropertySourceField<CGDataReference>(property);

            EditorGUI.PrefixLabel(position, label);

            position.x += EditorGUIUtility.labelWidth;
            position.width -= EditorGUIUtility.labelWidth;

            Rect r = new Rect(position);
            if (field.Module != null)
                r.width -= 30;

            string btnLabel = (field.Module) ? string.Format("{0}.{1}", field.Module.ModuleName, field.SlotName) : "None";
            string btnTT = (field.Module && field.Module.Generator) ? string.Format("{0}.{1}.{2}", field.Module.Generator.name, field.Module.ModuleName, field.SlotName) : "Click to choose";
            if (GUI.Button(r, new GUIContent(btnLabel, btnTT)))
            {
                CGEditorUtility.ShowOutputSlotsMenu(OnMenu, attrib.DataType);
            }
            if (field.Module != null)
            {
                r.width = 30;
                r.x = position.xMax - 30;
                if (GUI.Button(r, new GUIContent(CurvyStyles.SelectTexture, "Select")))
                    EditorGUIUtility.PingObject(field.Module);
            }
            else
            {
                EditorGUILayout.HelpBox(string.Format("Missing source of type {0}", attrib.DataType.Name), MessageType.Error);
            }

        }

        void OnMenu(object userData)
        {
            CGModuleOutputSlot slot = userData as CGModuleOutputSlot;
            CGDataReference field = GetPropertySourceField<CGDataReference>(CurrentProp);
            if (slot == null)
                field.Clear();
            else
                field.setINTERNAL(slot.Module, slot.Info.Name);

            CurrentProp.serializedObject.ApplyModifiedProperties();
        }
    }
    #endregion
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyPropertyDrawers.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyShapeEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 61903b8dd726e2c4db1cea2f22789984
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy;
using FluffyUnderware.DevToolsEditor;

namespace FluffyUnderware.CurvyEditor
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(CurvyShape), true)]
    public class CurvyShapeEditor : CurvyEditorBase<CurvyShape>
    {

        int mSelection;
        public bool ShowOnly2DShapes = false;
        public bool ShowPersistent;

        protected override void OnEnable()
        {
            base.OnEnable();
        }

        protected override void OnReadNodes()
        {

            DTFieldNode node;
            if (Node.FindNodeAt("m_Plane", out node))
                node.SortOrder = 0;
        }

        bool ShowShapeSelector()
        {
            EditorGUI.BeginChangeCheck();
            string[] menuNames = CurvyShape.GetShapesMenuNames(Target.GetType(), out mSelection, ShowOnly2DShapes).ToArray();

            mSelection = EditorGUILayout.Popup("Shape Type", mSelection, menuNames);
            if (EditorGUI.EndChangeCheck())
            {
                Target.Replace(menuNames[mSelection]);
                GUIUtility.ExitGUI();
                return true;
            }
            else return false;
        }

        /// <summary>
        /// Shows inspector for embedding into other GUI code.
        /// </summary>
        /// <returns>True if the shape script was changed</returns>
        public bool OnEmbeddedGUI()
        {
            bool changed = ShowShapeSelector();
            base.OnInspectorGUI();
            return changed;
        }


        public override void OnInspectorGUI()
        {
            // TODO: CONDITIONAL
            //HideFields("Persistent");
            ShowShapeSelector();
            base.OnInspectorGUI();
            //HideFields();
        }

    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyShapeEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvySplineAlignWizard.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 31a0ac75cca5dd74980eadede000d609
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections;
using System.Collections.Generic;
using FluffyUnderware.Curvy;

namespace FluffyUnderware.CurvyEditor
{
    public class CurvySplineAlignWizard : EditorWindow
    {
        CurvySpline Spline;
        float StartOffset = 0;
        float EndOffset = 0;
        float Step;
        bool UseWorldUnits = false;
        bool SetPosition = true;
        bool SetOrientation = true;
        int OrientationType = 0;

        int selcount;

        Vector3[] pos = new Vector3[0];
        Vector3[] up = new Vector3[0];
        Vector3[] tan = new Vector3[0];

        static public void Create()
        {
            CurvySplineAlignWizard win = GetWindow<CurvySplineAlignWizard>(true, "Align Transforms to spline", true);
            win.Init(Selection.activeGameObject.GetComponent<CurvySpline>());
            win.maxSize = new Vector2(400, 205);
            win.minSize = win.maxSize;
            Selection.activeTransform = null;
            SceneView.duringSceneGui -= win.Preview;
            SceneView.duringSceneGui += win.Preview;
        }

        private void OnDestroy()
        {
            SceneView.duringSceneGui -= Preview;
        }

        private void OnFocus()
        {
            SceneView.duringSceneGui -= Preview;
            SceneView.duringSceneGui += Preview;
        }

        void OnSelectionChange()
        {
            if (Selection.activeGameObject)
            {
                CurvySpline spl = Selection.activeGameObject.GetComponent<CurvySpline>();
                if (spl)
                    Init(spl);
            }
            Repaint();
        }

        void Init(CurvySpline spline)
        {
            Spline = spline;
        }

        void OnGUI()
        {
            selcount = (Selection.transforms != null) ? Selection.transforms.Length : 0;

            GUILayout.Label("Spline '" + Spline.name + "': Length=" + string.Format("{0:0.00}", new object[] { Spline.Length }) + " / Selected: " + selcount.ToString() + " transforms");
            GUILayout.Label("Select Transforms and hit Apply!", EditorStyles.boldLabel);

            StartOffset = EditorGUILayout.FloatField("Offset: Start", StartOffset);
            EndOffset = EditorGUILayout.FloatField("Offset: End", EndOffset);
            EditorGUILayout.BeginHorizontal();
            Step = EditorGUILayout.FloatField("Step", Step);
            if (GUILayout.Button("Auto"))
                SetAutoStep();
            EditorGUILayout.EndHorizontal();
            UseWorldUnits = EditorGUILayout.Toggle("Use World Units", UseWorldUnits);

            SetPosition = EditorGUILayout.Toggle("Set Position", SetPosition);
            SetOrientation = EditorGUILayout.Toggle("Set Orientation", SetOrientation);
            if (SetOrientation)
            {
                EditorGUILayout.BeginHorizontal();
                OrientationType = GUILayout.SelectionGrid(OrientationType, new GUIContent[] { new GUIContent("Up-Vector", "Rotate to match Up-Vectors"), new GUIContent("Tangent", "Rotate to match Tangent") }, 2);
                EditorGUILayout.EndHorizontal();
            }
            if (GUILayout.Button("Apply"))
                DoAlign();
            GUI.enabled = true;
            Calculate();
            if (SceneView.lastActiveSceneView)
                SceneView.lastActiveSceneView.Repaint();
        }

        void SetAutoStep()
        {
            if (selcount == 0) return;
            float len = (UseWorldUnits) ? Spline.Length - StartOffset - EndOffset : 1 - StartOffset - EndOffset;
            if (selcount > 1)
                Step = len / (selcount - 1);
            else
                Step = len / (selcount - 1);
        }

        void Calculate()
        {
            if (selcount == 0) return;
            pos = new Vector3[selcount];
            up = new Vector3[selcount];
            tan = new Vector3[selcount];

            for (int i = 0; i < selcount; i++)
            {
                //OPTIM use InterpolateAndGetTangent
                pos[i] = (UseWorldUnits) ? Spline.InterpolateByDistance(StartOffset + Step * i) : Spline.Interpolate(StartOffset + Step * i);
                up[i] = (UseWorldUnits) ? Spline.GetOrientationUpFast(Spline.DistanceToTF(StartOffset + Step * i)) : Spline.GetOrientationUpFast(StartOffset + Step * i);
                tan[i] = (UseWorldUnits) ? Spline.GetTangentByDistance(StartOffset + Step * i) : Spline.GetTangent(StartOffset + Step * i);
            }
        }

        void DoAlign()
        {
            if (selcount == 0) return;
            List<Transform> trans = new List<Transform>(Selection.transforms);
            trans.Sort((a, b) => string.Compare(a.name, b.name));

            Undo.RecordObjects(trans.ToArray(), "Align To Spline");

            for (int i = 0; i < selcount; i++)
            {
                if (SetPosition)
                    trans[i].position = pos[i];
                if (SetOrientation)
                {
                    switch (OrientationType)
                    {
                        case 0:
                            trans[i].rotation = Quaternion.LookRotation(tan[i], up[i]);
                            break;
                        case 1:
                            trans[i].rotation = Quaternion.LookRotation(up[i], tan[i]);
                            break;
                    }
                }
            }
        }


        void Preview(SceneView sceneView)
        {
            Handles.color = Color.blue;
            for (int i = 0; i < pos.Length; i++)
            {
                Vector3 rv = (OrientationType == 0) ? up[i] : tan[i];
#if UNITY_5_6_OR_NEWER
                Handles.ArrowHandleCap(0, pos[i], (rv != Vector3.zero) ? Quaternion.LookRotation(rv) : Quaternion.identity, 2, EventType.Repaint);
#else
                Handles.ArrowCap(0, pos[i], (rv != Vector3.zero) ? Quaternion.LookRotation(rv) : Quaternion.identity, 2);
#endif
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvySplineAlignWizard.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvySplineEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 8d791e8a79d284f4cb5b575bdbb0616e
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.CurvyEditor
{
    [CustomEditor(typeof(CurvySpline)), CanEditMultipleObjects]
    public class CurvySplineEditor : CurvyEditorBase<CurvySpline>
    {



        SerializedProperty tT;
        SerializedProperty tC;
        SerializedProperty tB;

        private static readonly GUIStyle GuiStyle = new GUIStyle();

        [DrawGizmo(GizmoType.Active | GizmoType.NonSelected | GizmoType.InSelectionHierarchy)]
        static void DrawTextGizmos(CurvySpline spline, GizmoType context)
        {

            bool drawLabels = CurvyGlobalManager.ShowLabelsGizmo && spline.ShowGizmos;
            bool drawRelativeDistance = CurvyGlobalManager.ShowRelativeDistancesGizmo && spline.ShowGizmos;
            bool drawTF = CurvyGlobalManager.ShowTFsGizmo && spline.ShowGizmos;

            if ((drawTF || drawRelativeDistance || drawLabels) == false)
                return;

            if (spline.Dirty)
                return;

            Bounds splineBounds = spline.Bounds;
            Camera camera = Camera.current;

            float alpha;
            {
                if (CurvyProject.Instance.AutoFadeLabels)
                {
                    Matrix4x4 m = spline.transform.localToWorldMatrix;
                    Vector2 min = new Vector2(float.MaxValue, float.MaxValue);
                    Vector2 max = new Vector2(float.MinValue, float.MinValue);
                    int height = Screen.height;

                    for (int index = 0; index < spline.Count; index++)
                    {
                        CurvySplineSegment curvySplineSegment = spline[index];
                        Vector2 segmentMin = new Vector2(float.MaxValue, float.MaxValue);
                        Vector2 segmentMax = new Vector2(float.MinValue, float.MinValue);
                        for (var i = 0; i < curvySplineSegment.Approximation.Length; i++)
                        {
                            // World space 
                            Vector3 p = m.MultiplyPoint3x4(curvySplineSegment.Approximation[i]);
                            // GUI space 
                            p = camera.WorldToScreenPoint(p, Camera.MonoOrStereoscopicEye.Mono);
                            p.y = height - p.y;

                            segmentMin.x = Mathf.Min(segmentMin.x, p.x);
                            segmentMin.y = Mathf.Min(segmentMin.y, p.y);
                            segmentMax.x = Mathf.Max(segmentMax.x, p.x);
                            segmentMax.y = Mathf.Max(segmentMax.y, p.y);
                        }

                        min.x = Mathf.Min(min.x, segmentMin.x);
                        min.y = Mathf.Min(min.y, segmentMin.y);
                        max.x = Mathf.Max(max.x, segmentMax.x);
                        max.y = Mathf.Max(max.y, segmentMax.y);
                    }

                    Rect screenBounds = Rect.MinMaxRect(min.x, min.y, max.x, max.y);
                    float maxBoundLength = Mathf.Max(screenBounds.width / Screen.width, screenBounds.height / Screen.height);
                    alpha = Mathf.Clamp01((maxBoundLength - 0.02f) / (0.07f - 0.02f));
                }
                else
                    alpha = 1;
            }

            Color color = spline.GizmoColor * 1.3f;

            bool isSplineClosed = spline.Closed;
            float handleSizeMultiplier = 0.08f;
            Quaternion cameraRotation = Camera.current.transform.rotation;

            lock (GuiStyle)
            {

                GuiStyle.fontSize = 11;
                GuiStyle.alignment = TextAnchor.MiddleCenter;

                if (drawTF && alpha != 0)
                {
                    GuiStyle.normal.textColor = Handles.color = new Color(color.r * 0.85f, color.g * 0.85f, color.b * 0.85f + 0.15f, alpha);

                    //first point and last point for closed splines
                    {
                        Vector3 worldPoint = spline.Interpolate(0, Space.World);
                        float handleSize = HandleUtility.GetHandleSize(worldPoint);
                        DrawPointHandle(worldPoint, handleSize * handleSizeMultiplier, cameraRotation);
#pragma warning disable CS0618
                        CurvyGizmo.PointLabel(worldPoint, $"TF : {(spline.Closed ? "0 / 1" : "0")}",
#pragma warning restore CS0618
                            OrientationAxisEnum.Right, handleSize, GuiStyle);
                    }

                    for (int i = 1; i <= (isSplineClosed ? 9 : 10); i++)
                    {
                        float tf = (float)i / 10;
                        Vector3 worldPoint = spline.Interpolate(tf, Space.World);
                        float handleSize = HandleUtility.GetHandleSize(worldPoint);
                        DrawPointHandle(worldPoint, handleSize * handleSizeMultiplier, cameraRotation);
#pragma warning disable CS0618
                        CurvyGizmo.PointLabel(worldPoint, $"TF : {tf}", OrientationAxisEnum.Right, handleSize, GuiStyle);
#pragma warning restore CS0618
                    }
                }

                if (drawRelativeDistance && alpha != 0)
                {
                    GuiStyle.normal.textColor = Handles.color = new Color(color.r * 0.85f, color.g * 0.85f + 0.15f, color.b * 0.85f, alpha);

                    //first point and last point for closed splines
                    {
                        Vector3 worldPoint = spline.InterpolateByDistance(0, Space.World);
                        float handleSize = HandleUtility.GetHandleSize(worldPoint);
                        DrawPointHandle(worldPoint, handleSize * handleSizeMultiplier, cameraRotation);
#pragma warning disable CS0618
                        CurvyGizmo.PointLabel(worldPoint, $"RD : {(spline.Closed ? "0 / 1" : "0")}", OrientationAxisEnum.Left, handleSize, GuiStyle);
#pragma warning restore CS0618
                    }

                    for (int i = 1; i <= (isSplineClosed ? 9 : 10); i++)
                    {
                        float relativeDistance = (float)i / 10;
                        Vector3 worldPoint = spline.InterpolateByDistance(spline.Length * relativeDistance, Space.World);
                        float handleSize = HandleUtility.GetHandleSize(worldPoint);
                        DrawPointHandle(worldPoint, handleSize * handleSizeMultiplier, cameraRotation);
#pragma warning disable CS0618
                        CurvyGizmo.PointLabel(worldPoint, $"RD : {relativeDistance}", OrientationAxisEnum.Left, handleSize, GuiStyle);
#pragma warning restore CS0618
                    }
                }

                if (drawLabels)
                {
                    GuiStyle.normal.textColor = color;
#pragma warning disable CS0618
                    CurvyGizmo.PointLabel(splineBounds.center, spline.name, OrientationAxisEnum.Down, null, GuiStyle);
#pragma warning restore CS0618

                    if (alpha != 0)
                    {
                        GuiStyle.normal.textColor = new Color(color.r * 0.85f + 0.15f, color.g * 0.85f, color.b * 0.85f, alpha);
                        foreach (CurvySplineSegment cp in spline.ControlPointsList)
#pragma warning disable CS0618
                            CurvyGizmo.PointLabel(cp.transform.position, cp.name, OrientationAxisEnum.Up, null, GuiStyle);
#pragma warning restore CS0618
                    }
                }
            }
        }

        private static void DrawPointHandle(Vector3 worldPoint, float handleSize, Quaternion cameraRotation)
        {
            Vector3 axis1 = cameraRotation * Vector3.right;
            Vector3 axis2 = cameraRotation * Vector3.up;
            Handles.DrawLine(worldPoint + axis1 * handleSize, worldPoint + axis1 * -handleSize
#if UNITY_2020_2_OR_NEWER
                , 1.5f
#endif
);
            Handles.DrawLine(worldPoint + axis2 * handleSize, worldPoint + axis2 * -handleSize
#if UNITY_2020_2_OR_NEWER
                , 1.5f
#endif
            );

            //Handles.DrawWireDisc(worldPoint, cameraRotation * Vector3.forward, handleSize);
        }

        [DrawGizmo(GizmoType.Active | GizmoType.NonSelected | GizmoType.InSelectionHierarchy)]
        static void DrawBSplineGizmo(CurvySpline spline, GizmoType context)
        {
            if (spline.Interpolation == CurvyInterpolation.BSpline)
            {
                Handles.color = spline.GizmoColor * 0.9f;
                foreach (CurvySplineSegment cp in spline.ControlPointsList)
                    if (spline.IsControlPointASegment(cp))
                        Handles.DrawDottedLine(cp.transform.position, spline.GetNextControlPoint(cp).transform.position, 4);
            }
        }

        protected override void OnEnable()
        {
            base.OnEnable();

            tT = serializedObject.FindProperty("m_Tension");
            tC = serializedObject.FindProperty("m_Continuity");
            tB = serializedObject.FindProperty("m_Bias");
        }

        protected override void OnSceneGUI()
        {
            base.OnSceneGUI();

            // Bounds
            bool targetIsNotNull = Target != null;
            if (targetIsNotNull && Target.IsInitialized && CurvyGlobalManager.ShowBoundsGizmo)
            {
                DTHandles.PushHandlesColor(new Color(0.3f, 0, 0));
                DTHandles.WireCubeCap(Target.Bounds.center, Target.Bounds.size);
                DTHandles.PopHandlesColor();
            }

            // Snap Transform
            if (targetIsNotNull && DT._UseSnapValuePrecision)
            {
                Target.transform.localPosition = DTMath.SnapPrecision(Target.transform.localPosition, 3);
                Target.transform.localEulerAngles = DTMath.SnapPrecision(Target.transform.localEulerAngles, 3);
            }



        }



        void TCBOptionsGUI()
        {
            if (Target.Interpolation == CurvyInterpolation.TCB)
            {
                EditorGUILayout.BeginHorizontal();
                if (GUILayout.Button(new GUIContent("Set Catmul", "Set TCB to match Catmul Rom")))
                {
                    tT.floatValue = 0; tC.floatValue = 0; tB.floatValue = 0;
                }
                if (GUILayout.Button(new GUIContent("Set Cubic", "Set TCB to match Simple Cubic")))
                {
                    tT.floatValue = -1; tC.floatValue = 0; tB.floatValue = 0;
                }
                if (GUILayout.Button(new GUIContent("Set Linear", "Set TCB to match Linear")))
                {
                    tT.floatValue = 0; tC.floatValue = -1; tB.floatValue = 0;
                }
                EditorGUILayout.EndHorizontal();
            }
        }

        void ShowGizmoGUI()
        {
            EditorGUILayout.PropertyField(serializedObject.FindProperty(nameof(CurvySpline.ShowGizmos)));
        }
        void CheckGizmoColor()
        {
            if (Target.GizmoColor.a.Approximately(0f))
                EditorGUILayout.HelpBox("Color is transparent (alpha value set to 0).", MessageType.Warning);
        }
        void CheckGizmoSelectionColor()
        {
            if (Target.GizmoSelectionColor.a.Approximately(0f))
                EditorGUILayout.HelpBox("Active Color is transparent (alpha value set to 0).", MessageType.Warning);
        }

        void CBCheck2DPlanar()
        {
            if (Target.RestrictTo2D && Target.IsPlanar(Target.Restricted2DPlane) == false)
            {
                EditorGUILayout.HelpBox("The spline isn't restricted to the selected plane. Click the button below to correct this.", MessageType.Warning);
                if (GUILayout.Button("Make planar"))
                    Target.MakePlanar(Target.Restricted2DPlane);
            }
        }

        protected override void OnCustomInspectorGUI()
        {
            base.OnCustomInspectorGUI();
            GUILayout.Space(5);
            if (Target.ControlPointsList.Count == 0)
                EditorGUILayout.HelpBox("To add Control Points to your curve, please use the Toolbar in the SceneView window", MessageType.Warning);
            if (Target.IsInitialized == false)
                EditorGUILayout.HelpBox("Spline is not initialized", MessageType.Info);
            else if (Target.Dirty)
                EditorGUILayout.HelpBox("Spline is dirty", MessageType.Info);
            else
                EditorGUILayout.HelpBox("Control Points: " + Target.ControlPointCount.ToString() +
                                       "\nSegments: " + Target.Count.ToString() +
                                       "\nLength: " + Target.Length.ToString() +
                                       "\nCache Points: " + Target.CacheSize.ToString()
                                       , MessageType.Info);

        }



    }


}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvySplineEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvySplineSegmentEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c238a26e5ac20834c8a9281b887c4922
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.CurvyEditor;
using FluffyUnderware.Curvy;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevToolsEditor.Extensions;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.CurvyEditor.UI;
using System.Linq;
using UnityEditorInternal;
using FluffyUnderware.DevTools;
using Object = UnityEngine.Object;

namespace FluffyUnderware.CurvyEditor
{
    [CustomEditor(typeof(CurvySplineSegment)), CanEditMultipleObjects]
    public class CurvySplineSegmentEditor : CurvyEditorBase<CurvySplineSegment>
    {
        public static float SmoothingOffset = 0.3f;

        SerializedProperty tT0;
        SerializedProperty tB0;
        SerializedProperty tC0;
        SerializedProperty tT1;
        SerializedProperty tB1;
        SerializedProperty tC1;
        SerializedProperty tOT;
        SerializedProperty tOB;
        SerializedProperty tOC;


        Quaternion mBezierRot;

        EditorKeyBinding hkToggleBezierAutoHandles;

        CurvyConnectionEditor mConnectionEditor;

        [DrawGizmo(GizmoType.Active | GizmoType.NonSelected | GizmoType.InSelectionHierarchy)]
        private static void DrawOrientationAnchorGizmo(CurvySplineSegment controlPoint, GizmoType context)
        {
            CurvySpline spline = controlPoint.Spline;
            if (CurvyGlobalManager.ShowOrientationAnchorsGizmo && spline.ShowGizmos && spline.IsControlPointAnOrientationAnchor(controlPoint))
            {
                Handles.color = spline.GizmoColor * 1.1f;
                Camera camera = Camera.current;
                Vector3 xAxis = -camera.transform.right;
                Vector3 yAxis = -camera.transform.up;
                Vector3 zAxis = -camera.transform.forward;

                Vector3 cpPosition = controlPoint.transform.position;
                float handleSize = HandleUtility.GetHandleSize(cpPosition);

                float outerRadius = handleSize * 0.12f;
                float innerRadius = outerRadius * 0.7f;

                Vector3 anchorPosition = controlPoint.transform.position + yAxis * handleSize * 0.3f;

                //englobing circle
                Handles.DrawWireDisc(anchorPosition, zAxis, outerRadius);

                Vector3 neckPosition = anchorPosition - yAxis * innerRadius * 0.7f;
                //head
                float headSize = outerRadius * 0.1f;
                Handles.DrawSolidDisc(neckPosition - headSize * yAxis, zAxis, headSize);

                //trunk
                Handles.DrawLine(neckPosition, anchorPosition + yAxis * innerRadius);

                //arms
                Vector3 armsVerticalPosition = anchorPosition - yAxis * innerRadius * 0.25f;
                float armsLength = innerRadius * 0.6f;
                Handles.DrawLine(armsVerticalPosition - xAxis * armsLength, armsVerticalPosition + xAxis * armsLength);

                //feet
                float arcStartAngle = Mathf.Deg2Rad * -80f;
                Handles.DrawWireArc(anchorPosition, zAxis, xAxis * Mathf.Sin(arcStartAngle) + yAxis * Mathf.Cos(arcStartAngle), 160, innerRadius);
            }
        }

        protected override void OnEnable()
        {
            base.OnEnable();
            hkToggleBezierAutoHandles = CurvyProject.Instance.RegisterKeyBinding(new EditorKeyBinding("Bezier: Toggle AutoHandles", "", KeyCode.H));

            tT0 = serializedObject.FindProperty("m_StartTension");
            tC0 = serializedObject.FindProperty("m_StartContinuity");
            tB0 = serializedObject.FindProperty("m_StartBias");
            tT1 = serializedObject.FindProperty("m_EndTension");
            tC1 = serializedObject.FindProperty("m_EndContinuity");
            tB1 = serializedObject.FindProperty("m_EndBias");
            tOT = serializedObject.FindProperty("m_OverrideGlobalTension");
            tOC = serializedObject.FindProperty("m_OverrideGlobalContinuity");
            tOB = serializedObject.FindProperty("m_OverrideGlobalBias");

            EditorApplication.hierarchyWindowItemOnGUI -= OnHierarchyWindowItemOnGUI;
            EditorApplication.hierarchyWindowItemOnGUI += OnHierarchyWindowItemOnGUI;

            mBezierRot = Quaternion.identity;
        }



        protected override void OnDisable()
        {
            base.OnDisable();
            Editor.DestroyImmediate(mConnectionEditor);
            EditorApplication.hierarchyWindowItemOnGUI -= OnHierarchyWindowItemOnGUI;
            // just in case
            Tools.hidden = false;
        }

        protected override void OnReadNodes()
        {
            if (!mConnectionEditor)
            {
                // ensure all selected CPs join a single connection. Otherwise don't show Connections Inspector
                if (!serializedObject.FindProperty("m_Connection").hasMultipleDifferentValues && Target.Connection != null)
                {
                    mConnectionEditor = (CurvyConnectionEditor)Editor.CreateEditor(Target.Connection, typeof(CurvyConnectionEditor));
                    DTGroupNode sec = Node.AddSection("Connection", ConnectionGUI);
                    if (sec)
                    {
                        sec.SortOrder = 1;
                        sec.HelpURL = CurvySpline.DOCLINK + "curvyconnection";
                    }
                }
            }
        }

        void checkHotkeys()
        {
            if (Target && Target.Spline && Target.Spline.Interpolation == CurvyInterpolation.Bezier && hkToggleBezierAutoHandles.IsTriggered(Event.current))
                DTSelection.GetAllAs<CurvySplineSegment>().ForEach((CurvySplineSegment seg) => { seg.AutoHandles = !seg.AutoHandles; });
        }

        protected override void OnSceneGUI()
        {
            base.OnSceneGUI();

            // Bounds
            if (CurvyGlobalManager.ShowBoundsGizmo)
            {
                DTHandles.PushHandlesColor(Color.gray);
                DTHandles.WireCubeCap(Target.Bounds.center, Target.Bounds.size);
                DTHandles.PopHandlesColor();
            }
            checkHotkeys();
            if (Target.Spline && Target.Spline.RestrictTo2D && Tools.current == Tool.Move && !SceneView.currentDrawingSceneView.in2DMode)
            {
                Tools.hidden = true;
                Vector3 handlePos = (Tools.handlePosition != Target.transform.position) ? DTSelection.GetPosition() : Tools.handlePosition;
                Vector3 delta;
                EditorGUI.BeginChangeCheck();


                if (CurvyProject.Instance.UseTiny2DHandles)
                    delta = DTHandles.TinyHandle2D(GUIUtility.GetControlID(GetHashCode(), FocusType.Passive), handlePos, Target.Spline.transform.rotation, 1) - handlePos;
                else
                    delta = DTHandles.PositionHandle2D(GUIUtility.GetControlID(GetHashCode(), FocusType.Passive), handlePos, Target.Spline.transform.rotation, 1, (int)Target.Spline.Restricted2DPlane) - handlePos;

                if (EditorGUI.EndChangeCheck())
                {
                    foreach (Transform t in Selection.transforms)
                    {
                        Undo.ClearUndo(t);
                        Undo.RecordObject(t, "Move");
                        t.position += delta;
                    }
                }
            }
            else
                Tools.hidden = false;


            // Bezier-Handles
            if (Target.Spline && Target.Spline.Interpolation == CurvyInterpolation.Bezier && !Target.AutoHandles)
            {
                float positionHandleSize = .6f;
                float cubeSize = CurvyGlobalManager.GizmoControlPointSize * 0.6f;

                bool hasSynchronizedHandles;
                {
                    CurvyBezierModeEnum mode = CurvyProject.Instance.BezierMode;
                    bool syncDirections = (mode & CurvyBezierModeEnum.Direction) == CurvyBezierModeEnum.Direction;
                    bool syncLengths = (mode & CurvyBezierModeEnum.Length) == CurvyBezierModeEnum.Length;
                    bool syncConnectedCPs = (mode & CurvyBezierModeEnum.Connections) == CurvyBezierModeEnum.Connections;

                    hasSynchronizedHandles =
                        syncConnectedCPs
                        && (syncDirections || syncLengths)
                        && Target.Connection
                        && Target.Connection.ControlPointsList.Any(cp => cp != Target);
                }

                #region --- Bezier Rotation Handling ---
                if (Tools.current == Tool.Rotate)
                {
                    Event e = Event.current;
                    if (e.shift && DTHandles.MouseOverSceneView)
                    {
                        Tools.hidden = true;
                        DTToolbarItem._StatusBar.Set("BezierRotate");
                        // This looks good, but then diff down below isn't working like intended:
                        //mBezierRot = Quaternion.LookRotation(Vector3.Cross(Target.HandleIn, Target.GetOrientationUpFast(0)), Target.GetOrientationUpFast(0));
                        Quaternion newRot = Handles.RotationHandle(mBezierRot, Target.transform.position);
                        if (newRot != mBezierRot)
                        {
                            Quaternion diff = Quaternion.Inverse(mBezierRot) * newRot;
                            mBezierRot = newRot;
                            CurvyBezierModeEnum mode = CurvyProject.Instance.BezierMode;

                            //Undo handling
                            {
                                string undoingOperationLabel = "Rotate Handles";
                                Undo.RecordObject(Target, undoingOperationLabel);
                                if (hasSynchronizedHandles)
                                    Undo.RecordObjects(
                                        Target.Connection.ControlPointsList.Where(cp => cp != Target).Select(cp => (Object)cp).ToArray()
                                        , undoingOperationLabel);
                            }

                            Target.SetBezierHandleIn(diff * Target.HandleIn, Space.Self, mode);
                            Target.SetBezierHandleOut(diff * Target.HandleOut, Space.Self, mode);
                            EditorUtility.SetDirty(Target);
                        }

                    }
                    else
                    {
                        DTToolbarItem._StatusBar.Set("Hold <b>[Shift]</b> to rotate Handles", "BezierRotate");
                        Tools.hidden = false;
                    }
                }
                else
                    DTToolbarItem._StatusBar.Set("BezierRotate");
                #endregion

                #region --- Bezier Movement Handling ---
                //Belongs to Constraint Length:
                //Vector3 handleOut = Target.HandleOutPosition;
                //Vector3 handleIn = Target.HandleInPosition;

                EditorGUI.BeginChangeCheck();
                Vector3 pOut;
                Vector3 pIn;
                bool chgOut = false;
                bool chgIn = false;
                if (Target.Spline.RestrictTo2D)
                {

                    Quaternion r = (Tools.pivotRotation == PivotRotation.Global) ? Target.Spline.transform.localRotation : Target.Spline.transform.rotation;
                    Handles.color = Color.yellow;
                    pIn = Target.HandleInPosition;
                    pIn = DTHandles.TinyHandle2D(GUIUtility.GetControlID(FocusType.Passive), pIn, r, cubeSize, Handles.CubeHandleCap);

                    if (!CurvyProject.Instance.UseTiny2DHandles)
                        pIn = DTHandles.PositionHandle2D(GUIUtility.GetControlID(FocusType.Passive), pIn, r, positionHandleSize, (int)Target.Spline.Restricted2DPlane);
                    chgIn = Target.HandleInPosition != pIn;
                    Handles.color = Color.green;
                    pOut = Target.HandleOutPosition;
                    pOut = DTHandles.TinyHandle2D(GUIUtility.GetControlID(FocusType.Passive), pOut, r, cubeSize, Handles.CubeHandleCap);

                    if (!CurvyProject.Instance.UseTiny2DHandles)
                        pOut = DTHandles.PositionHandle2D(GUIUtility.GetControlID(FocusType.Passive), pOut, r, positionHandleSize, (int)Target.Spline.Restricted2DPlane);

                    chgOut = Target.HandleOutPosition != pOut;

                }
                else
                {
                    Color handlesGizmoAdditionalColor = Target.Spline.GizmoSelectionColor * 0.4f;

                    pIn = DTHandles.PositionHandle(
                        GUIUtility.GetControlID(GetHashCode(), FocusType.Passive),
                        GUIUtility.GetControlID(GetHashCode(), FocusType.Passive),
                        GUIUtility.GetControlID(GetHashCode(), FocusType.Passive),
                        Target.HandleInPosition, Tools.handleRotation, positionHandleSize,
                        0.2f, handlesGizmoAdditionalColor);
                    chgIn = Target.HandleInPosition != pIn;
                    DTHandles.PushHandlesColor(Color.yellow);
                    Handles.CubeHandleCap(0, pIn, Quaternion.identity, HandleUtility.GetHandleSize(pIn) * cubeSize, EventType.Repaint);
                    DTHandles.PopHandlesColor();

                    pOut = DTHandles.PositionHandle(
                        GUIUtility.GetControlID(GetHashCode(), FocusType.Passive),
                        GUIUtility.GetControlID(GetHashCode(), FocusType.Passive),
                        GUIUtility.GetControlID(GetHashCode(), FocusType.Passive),
                        Target.HandleOutPosition, Tools.handleRotation, positionHandleSize,
                        0.2f, handlesGizmoAdditionalColor);
                    chgOut = Target.HandleOutPosition != pOut;
                    DTHandles.PushHandlesColor(Color.green);
                    Handles.CubeHandleCap(0, pOut, Quaternion.identity, HandleUtility.GetHandleSize(pOut) * cubeSize, EventType.Repaint);

                    DTHandles.PopHandlesColor();
                }

                Handles.color = Color.yellow;
                Handles.DrawLine(pIn, Target.transform.position);
                Handles.color = Color.green;
                Handles.DrawLine(pOut, Target.transform.position);


                if (chgOut || chgIn)
                {
                    //Undo handling
                    {
                        const string undoingOperationLabel = "Move Handle";
                        Undo.RecordObject(Target, undoingOperationLabel);
                        if (hasSynchronizedHandles)
                            Undo.RecordObjects(
                                Target.Connection.ControlPointsList.Where(cp => cp != Target).Select(cp => (Object)cp).ToArray()
                                , undoingOperationLabel);
                    }

                    if (chgOut)
                    {
                        Target.SetBezierHandleOut(pOut, Space.World, CurvyProject.Instance.BezierMode);
                        Target.HandleOut = DTMath.SnapPrecision(Target.HandleOut, 3);
                    }
                    else
                    {
                        Target.SetBezierHandleIn(pIn, Space.World, CurvyProject.Instance.BezierMode);
                        Target.HandleIn = DTMath.SnapPrecision(Target.HandleIn, 3);
                    }
                }

                if (EditorGUI.EndChangeCheck())
                {
                    EditorUtility.SetDirty(Target);
                    Target.Spline.SetDirty(Target, SplineDirtyingType.Everything);
                    /*
                    var lcons = CurvyProject.Instance.FindItem<TBCPLengthConstraint>();
                    if (lcons.On && Target.Spline.Length > lcons.MaxSplineLength)
                    {
                        Target.HandleOutPosition = handleOut;
                        Target.HandleInPosition = handleIn;
                        Target.SetDirty();
                    }
                     */
                }
                #endregion


            }
            if (mConnectionEditor)
                mConnectionEditor.OnSceneGUI();
            // Snap Transform
            if (Target && DT._UseSnapValuePrecision)
            {
                Target.transform.localPosition = DTMath.SnapPrecision(Target.transform.localPosition, 3);
                Target.transform.localEulerAngles = DTMath.SnapPrecision(Target.transform.localEulerAngles, 3);
                //Target.TTransform.FromTransform(Target.transform);
            }
        }

        void OnHierarchyWindowItemOnGUI(int instanceid, Rect selectionrect)
        {
            GameObject obj = EditorUtility.InstanceIDToObject(instanceid) as GameObject;
            if (obj && obj == Selection.activeObject)
                checkHotkeys();
        }


        void TCBOptionsGUI()
        {
            if (Target.Spline && Target.Spline.Interpolation == CurvyInterpolation.TCB)
            {
                if (tOT.boolValue || tOC.boolValue || tOB.boolValue)
                {
                    EditorGUILayout.BeginHorizontal();

                    if (GUILayout.Button("Set Catmul"))
                    {
                        tT0.floatValue = 0; tC0.floatValue = 0; tB0.floatValue = 0;
                        tT1.floatValue = 0; tC1.floatValue = 0; tB1.floatValue = 0;
                    }
                    if (GUILayout.Button("Set Cubic"))
                    {
                        tT0.floatValue = -1; tC0.floatValue = 0; tB0.floatValue = 0;
                        tT1.floatValue = -1; tC1.floatValue = 0; tB1.floatValue = 0;
                    }
                    if (GUILayout.Button("Set Linear"))
                    {
                        tT0.floatValue = 0; tC0.floatValue = -1; tB0.floatValue = 0;
                        tT1.floatValue = 0; tC1.floatValue = -1; tB1.floatValue = 0;
                    }
                    EditorGUILayout.EndHorizontal();
                }
            }
        }

        void ConnectionGUI(DTInspectorNode node)
        {
            if (mConnectionEditor != null && Target.Connection != null)
            {
                EditorGUILayout.BeginHorizontal();
                Target.Connection.name = EditorGUILayout.TextField("Name", Target.Connection.name);
                if (GUILayout.Button(new GUIContent("Select", "Select the Connection GameObject")))
                    DTSelection.SetGameObjects(Target.Connection);
                EditorGUILayout.EndHorizontal();
                mConnectionEditor.OnInspectorGUI();

            }
        }

        protected override void OnCustomInspectorGUI()
        {

            GUILayout.Space(5);

            CurvySpline spline = Target.Spline;

            if (spline && spline.IsInitialized && spline.Dirty == false)
            {
                EditorGUILayout.HelpBox(
                    "Control Point Distance: " + Target.Distance +
                    "\nSpline Length: " + spline.Length +
                    "\nControl Point Relative Distance: " + (Target.Distance / spline.Length) + " (= Distance / Length)" +
                    "\nControl Point TF: " + Target.TF +
                    "\nSegment Length: " + Target.Length +
                    "\nSegment Cache Points: " + Target.CacheSize, MessageType.Info);
            }
            else
                EditorGUILayout.HelpBox("No parent spline or parent spline not ready", MessageType.Info);

            checkHotkeys();
        }


        public override void OnInspectorGUI()
        {
            if (mConnectionEditor && mConnectionEditor.Target == null)//This happens when deleting a connection from the CurvySplineSegment inspector, and then re-adding a connection while still showing the same inspector
                mConnectionEditor = null;

            if (Target && Target.Connection && mConnectionEditor == null)
                ReadNodes();
            base.OnInspectorGUI();
        }

        void CBBakeOrientation()
        {
            if (Target && !Target.AutoBakeOrientation && Target.Spline && Target.ApproximationUp.Length > 0
                && GUILayout.Button("Bake Orientation to Transform"))
            {
#if UNITY_EDITOR
                Undo.RecordObject(Target.transform, "Bake Orientation");
#endif
                Target.BakeOrientationToTransform();
            }
            GUI.enabled = true;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvySplineSegmentEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyStyles.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e66ce90e46fc2b144b0e3b7a8c1b7d88
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Text;
using FluffyUnderware.CurvyEditor;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.DevToolsEditor.Extensions;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevToolsEditor;

namespace FluffyUnderware.CurvyEditor
{
    public static class CurvyStyles
    {
        public static GUIStyle GizmoText
        {
            get
            {
                if (gizmoText == null)
                {
                    gizmoText = new GUIStyle();
                    gizmoText.fixedHeight = 15;
                    gizmoText.alignment = TextAnchor.MiddleCenter;
                    //gizmoText.fixedWidth = label.Length * 10;
                    //gizmoText.padding = new RectOffset(0,0,0,0);
                    //gizmoText.margin = new RectOffset(0,0,0,0);
                    //gizmoText.border = new RectOffset(0,0,0,0);
                    //gizmoText.overflow = new RectOffset(0,0,0,0);
                    //gizmoText.contentOffset = Vector2.zero;
                    Texture2D backgroundTexture = new Texture2D(1, 1);
                    backgroundTexture.SetPixel(0, 0, new Color(1, 1, 1, 0.3f));
                    backgroundTexture.Apply();
                    backgroundTexture.hideFlags = HideFlags.DontSave;
                    gizmoText.normal.background = backgroundTexture;
                }
                return gizmoText;
            }
        }
        static GUIStyle gizmoText;

        public static GUIStyle ControllerCustomEventStyle
        {
            get
            {
                if (controllerCustomEventStyle == null)
                {
                    controllerCustomEventStyle = new GUIStyle();
                    controllerCustomEventStyle.fixedHeight = 15;
                    controllerCustomEventStyle.alignment = TextAnchor.MiddleCenter;
                    //gizmoText.fixedWidth = label.Length * 10;
                    //gizmoText.padding = new RectOffset(0,0,0,0);
                    //gizmoText.margin = new RectOffset(0,0,0,0);
                    //gizmoText.border = new RectOffset(0,0,0,0);
                    //gizmoText.overflow = new RectOffset(0,0,0,0);
                    //gizmoText.contentOffset = Vector2.zero;
                    Texture2D backgroundTexture = new Texture2D(1, 1);
                    backgroundTexture.SetPixel(0, 0, new Color(1, 1, 1, 0.3f));
                    backgroundTexture.Apply();
                    backgroundTexture.hideFlags = HideFlags.DontSave;
                    controllerCustomEventStyle.normal.background = backgroundTexture;
                }
                return controllerCustomEventStyle;
            }
        }

        static GUIStyle controllerCustomEventStyle;

        #region ### Buttons ###
        public static GUIStyle BorderlessButton
        {
            get
            {
                if (mBorderlessButton == null)
                {
                    mBorderlessButton = new GUIStyle(GUI.skin.label);
                    mBorderlessButton.padding = new RectOffset(-1, 3, -1, -1);
                    mBorderlessButton.imagePosition = ImagePosition.ImageOnly;
                }
                return mBorderlessButton;
            }
        }
        static GUIStyle mBorderlessButton;

        public static GUIStyle SmallButton
        {
            get
            {
                if (mSmallButton == null)
                {
                    mSmallButton = new GUIStyle(EditorStyles.miniButton);
                    mSmallButton.margin = new RectOffset(0, 0, 0, 0);
                    mSmallButton.padding = new RectOffset(1, 1, -1, -1);
                    //mSmallButton.imagePosition = ImagePosition.ImageOnly;
                }
                return mSmallButton;
            }
        }
        static GUIStyle mSmallButton;

        public static GUIStyle ImageButton
        {
            get
            {
                if (mImageButton == null)
                {
                    mImageButton = new GUIStyle(GUI.skin.button);
                    mImageButton.padding = new RectOffset(-1, -1, -1, -1);
                    mImageButton.imagePosition = ImagePosition.ImageOnly;
                }
                return mImageButton;
            }
        }
        static GUIStyle mImageButton;

        #endregion

        #region ### Misc ###

        public static GUIStyle Foldout
        {
            get
            {
                if (mFoldout == null)
                {
                    mFoldout = new GUIStyle(EditorStyles.foldout);
                    mFoldout.fontStyle = FontStyle.Bold;
                    mFoldout.margin.top += 2;
                    mFoldout.margin.bottom += 4;

                }
                return mFoldout;
            }
        }
        static GUIStyle mFoldout;

        public static GUIStyle HelpBox
        {
            get
            {
                if (mHelpBox == null)
                {
                    mHelpBox = new GUIStyle(GUI.skin.GetStyle("HelpBox"));
                    mHelpBox.richText = true;
                }
                return mHelpBox;
            }
        }
        static GUIStyle mHelpBox;

        public static GUIStyle Toolbar
        {
            get
            {
                if (mToolbar == null)
                {
                    mToolbar = new GUIStyle(EditorStyles.toolbar);
                    mToolbar.fixedHeight = 0;
                    mToolbar.padding = new RectOffset(6, 6, 4, 4);
                }
                return mToolbar;
            }
        }
        public static GUIStyle mToolbar;

        public static GUIStyle RoundRectangle
        {
            get
            {
                if (mRoundRectangle == null)
                {
                    mRoundRectangle = new GUIStyle();
                    mRoundRectangle.normal.background = CurvyResource.Load("roundrectangle,16,16");
                    mRoundRectangle.border = new RectOffset(6, 6, 6, 6);
                    mRoundRectangle.overflow = new RectOffset(1, 0, 0, 1);
                }
                return mRoundRectangle;
            }
        }
        static GUIStyle mRoundRectangle;

        public static GUIStyle ToolbarItem
        {
            get
            {
                if (mToolbarItem == null)
                {
                    mToolbarItem = new GUIStyle(GUI.skin.button);
                    mToolbarItem.alignment = TextAnchor.MiddleLeft;
                    mToolbarItem.padding.top = 4;
                    mToolbarItem.padding.bottom = 2;
                }
                return mToolbarItem;
            }
        }
        static GUIStyle mToolbarItem;

        #endregion

        #region ### CG Colors ###

        public static Color IOnRequestProcessingTitleColor
        {
            get
            {
                if (EditorGUIUtility.isProSkin) return new Color(0.2f, 0.7f, 0.2f);
                else return new Color(0.1f, 0.5f, 0.1f);
            }
        }

        public static Color IOnRequestProcessingSlotColor
        {
            get
            {
                if (EditorGUIUtility.isProSkin) return new Color(0.2f, 0.7f, 0.2f);
                else return new Color(0.1f, 0.5f, 0.1f);
            }
        }

        #endregion

        #region ### CG Module Window ###
        public static int ModuleWindowTitleHeight = 26;

        public static GUIStyle ModuleWindow
        {
            get
            {
                if (mModuleWindow == null)
                {
                    mModuleWindow = new GUIStyle(GUI.skin.window);
                    mModuleWindow.normal.background = TexModuleWindow;
                    mModuleWindow.onNormal.background = TexModuleWindow1;
                    mModuleWindow.border = new RectOffset(10, 12, 24, 13);
                    mModuleWindow.padding = new RectOffset(0, 0, 24, 6);
                    mModuleWindow.contentOffset = new Vector2(0, -18);
#pragma warning disable 162
                    mModuleWindow.overflow = new RectOffset(10, 11, 8, 11);
#pragma warning restore 162
                    mModuleWindow.richText = true;
                }
                return mModuleWindow;
            }
        }
        static GUIStyle mModuleWindow;

        public static GUIStyle ModuleWindowSlotBackground
        {
            get
            {
                if (mModuleWindowSlotBackground == null)
                {
                    mModuleWindowSlotBackground = new GUIStyle(GUI.skin.box);
                    mModuleWindowSlotBackground.padding = new RectOffset(1, 1, 1, 1);
                    mModuleWindowSlotBackground.margin = new RectOffset(1, 1, 0, 0);
                }
                return mModuleWindowSlotBackground;
            }
        }
        static GUIStyle mModuleWindowSlotBackground;

        public static GUIStyle ModuleWindowBackground
        {
            get
            {
                if (mModuleWindowBackground == null)
                {
                    mModuleWindowBackground = new GUIStyle(GUI.skin.box);
                    mModuleWindowBackground.padding = new RectOffset(1, 1, 1, 1);
                    mModuleWindowBackground.margin = new RectOffset(1, 1, 5, 0);

                }
                return mModuleWindowBackground;
            }
        }
        static GUIStyle mModuleWindowBackground;


        public static Texture2D HelpTexture
        {
            get
            {
                if (mHelpTexture == null)
                    // mHelpTexture=(Texture2D)EditorGUIUtility.Load("icons/_Help.png");
                    // mHelpTexture = CurvyResource.Load("help12,12,12");
                    mHelpTexture = CurvyResource.Load(GetTextureFilename("help12", 12, 12));
                return mHelpTexture;
            }
        }
        static Texture2D mHelpTexture;

        public static Texture2D EditTexture
        {
            get
            {
                if (mEditTexture == null)
                    // mEditTexture = CurvyResource.Load("editsmall,12,12");
                    mEditTexture = CurvyResource.Load(GetTextureFilename("editsmall", 12, 12));
                return mEditTexture;
            }
        }
        static Texture2D mEditTexture;


        public static GUIStyle GlowBox
        {
            get
            {
                if (mGlowBox == null)
                {
                    mGlowBox = new GUIStyle();
                    mGlowBox.normal.background = CurvyResource.Load("glowbox,26,26");
                    mGlowBox.border = new RectOffset(11, 11, 11, 11);
                    mGlowBox.overflow = new RectOffset(1, 0, 0, 1);
                }
                return mGlowBox;
            }
        }
        static GUIStyle mGlowBox;


        public static GUIStyle ShowDetailsButton
        {
            get
            {
                if (showDetailsButton == null)
                {
                    showDetailsButton = new GUIStyle(EditorStyles.toolbarButton);
                    showDetailsButton.margin.left = 2;
                    showDetailsButton.margin.right = 1;
                }
                return showDetailsButton;
            }
        }
        static GUIStyle showDetailsButton;

        #endregion

        #region ### CG Slots ###

        public static GUIStyle Slot
        {
            get
            {
                if (mSlot == null)
                {
                    mSlot = new GUIStyle();
                    mSlot.normal.background = EditorGUIUtility.whiteTexture;
                    mSlot.fixedHeight = 17;
                    mSlot.fixedWidth = 17;
                    mSlot.normal.textColor = new Color(0, 0, 0, 0.6f);
                    mSlot.alignment = TextAnchor.MiddleCenter;
                    mSlot.contentOffset = new Vector2(-1f, -1f);
                }
                return mSlot;
            }
        }
        static GUIStyle mSlot;

        public static GUIStyle GetSlotLabelStyle(CGModuleSlot slot)
        {
            GUIStyle st = new GUIStyle();
            st.fixedHeight = 18;
            // Linked Slots => Bold
            // OnRequestProcessing => Green
            // Optional => Italic
            st.fontStyle = (slot.IsLinked) ? FontStyle.Bold : FontStyle.Normal;
            st.normal.textColor = new Color(1, 1, 1, 0.6f).SkinAwareColor();

            CGModuleInputSlot inputSlot = (slot as CGModuleInputSlot);

            if (inputSlot)
            {
                InputSlotInfo myInfo = inputSlot.InputInfo;
                if (myInfo.Optional)
                {
                    st.fontStyle = (st.fontStyle == FontStyle.Bold) ? st.fontStyle = FontStyle.BoldAndItalic : FontStyle.Italic;
                }
                if (inputSlot.Module is IOnRequestProcessing || myInfo.RequestDataOnly)
                    st.normal.textColor = IOnRequestProcessingSlotColor.SkinAwareColor();
                st.alignment = TextAnchor.MiddleLeft;
                st.margin.left = 2;
            }
            else
            {
                if (slot.Module is IOnRequestProcessing)
                    st.normal.textColor = IOnRequestProcessingSlotColor.SkinAwareColor();
                st.alignment = TextAnchor.MiddleRight;
                st.margin.right = 2;

            }

            st.padding.bottom = 3;

            return st;
        }



        #endregion

        #region ### Textures ###

        public static string GetTextureFilename(string name, int width, int height, string darkskinPostfix = "_dark", string ligthskinPostfix = "_light")
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(name);
            sb.Append(EditorGUIUtility.isProSkin ? darkskinPostfix : ligthskinPostfix);
            sb.Append(",");
            sb.Append(width);
            sb.Append(",");
            sb.Append(height);

            string filename = sb.ToString();
            return filename;
        }

        public static Texture2D TexModuleWindow
        {
            get
            {
                if (mTexModuleWindow == null)
                {
                    mTexModuleWindow = CurvyResource.Load((EditorGUIUtility.isProSkin) ? "cgwindowdark,64,64" : "cgwindowlight,64,64");
                    //mTexModuleWindow.hideFlags = HideFlags.DontSave;
                }
                return mTexModuleWindow;
            }
        }
        static Texture2D mTexModuleWindow;

        public static Texture2D TexModuleWindow1
        {
            get
            {
                if (mTexModuleWindow1 == null)
                {
                    mTexModuleWindow1 = CurvyResource.Load((EditorGUIUtility.isProSkin) ? "cgwindowdark1,64,64" : "cgwindowlight1,64,64");
                    //mTexModuleWindow1.hideFlags = HideFlags.DontSave;
                }
                return mTexModuleWindow1;
            }
        }
        static Texture2D mTexModuleWindow1;

        public static Texture2D TexGridSnap
        {
            get
            {
                if (mTexGridSnap == null)
                {
                    mTexGridSnap = CurvyResource.Load(GetTextureFilename("cggridstep", 16, 16));
                    //mTexGridSnap.hideFlags = HideFlags.DontSave;
                }
                return mTexGridSnap;
            }
        }
        static Texture2D mTexGridSnap;

        public static Texture2D TexPlay
        {
            get
            {
                if (mTexPlay == null)
                {
                    mTexPlay = CurvyResource.Load("play,24,24");
                    //mTexPlay.hideFlags=HideFlags.DontSave;
                }
                return mTexPlay;
            }
        }
        static Texture2D mTexPlay;

        public static Texture2D TexStop
        {
            get
            {
                if (mTexStop == null)
                {
                    mTexStop = CurvyResource.Load("stop,24,24");
                    //mTexStop.hideFlags=HideFlags.DontSave;
                }
                return mTexStop;
            }
        }
        static Texture2D mTexStop;

        public static Texture2D TexLogoBig
        {
            get
            {
                if (mTexLogoBig == null)
                {
                    // mTexLogoBig = CurvyResource.Load( (EditorGUIUtility.isProSkin) ? "curvylogo_light,436,160" : "curvylogo_dark,436,160");
                    mTexLogoBig = CurvyResource.Load(GetTextureFilename("curvylogo", 436, 160));
                    //mTexLogoBig.hideFlags = HideFlags.DontSave;
                }
                return mTexLogoBig;
            }
        }
        static Texture2D mTexLogoBig;

        public static Texture2D TexLogoSmall
        {
            get
            {
                if (mTexLogoSmall == null)
                {
                    mTexLogoSmall = CurvyResource.Load(GetTextureFilename("curvylogo_small", 178, 124));
                }
                return mTexLogoSmall;
            }
        }
        static Texture2D mTexLogoSmall;

        public static Texture2D TexConnection
        {
            get
            {
                if (mTexConnection == null)
                {
                    // mTexConnection = CurvyResource.Load("connection,24,24");
                    mTexConnection = CurvyResource.Load(GetTextureFilename("connection", 24, 24));
                    //mTexConnection.hideFlags = HideFlags.DontSave;
                }
                return mTexConnection;
            }
        }
        static Texture2D mTexConnection;

        public static Texture2D TexConnectionPos
        {
            get
            {
                if (mTexConnectionPos == null)
                {
                    // mTexConnectionPos = CurvyResource.Load("connectionpos,24,24");
                    mTexConnectionPos = CurvyResource.Load(GetTextureFilename("connectionpos", 24, 24));
                    //mTexConnectionPos.hideFlags = HideFlags.DontSave;
                }
                return mTexConnectionPos;
            }
        }
        static Texture2D mTexConnectionPos;

        public static Texture2D TexConnectionRot
        {
            get
            {
                if (mTexConnectionRot == null)
                {
                    // mTexConnectionRot = CurvyResource.Load("connectionrot,24,24");
                    mTexConnectionRot = CurvyResource.Load(GetTextureFilename("connectionrot", 24, 24));
                    //mTexConnectionRot.hideFlags = HideFlags.DontSave;
                }
                return mTexConnectionRot;
            }
        }
        static Texture2D mTexConnectionRot;

        public static Texture2D TexConnectionFull
        {
            get
            {
                if (mTexConnectionFull == null)
                {
                    // mTexConnectionFull = CurvyResource.Load("connectionfull,24,24");
                    mTexConnectionFull = CurvyResource.Load(GetTextureFilename("connectionfull", 24, 24));
                    //mTexConnectionFull.hideFlags = HideFlags.DontSave;
                }
                return mTexConnectionFull;
            }
        }
        static Texture2D mTexConnectionFull;

        public static Texture2D HierarchyConnectionTexture
        {
            get
            {
                if (mHierarchyConnectionTexture == null)
                {
                    mHierarchyConnectionTexture = CurvyResource.Load("connectionsmall,12,12");
                    // mHierarchyConnectionTexture = CurvyResource.Load (GetTextureFilename ("connectionsmall", 12, 12));
                    //mHierarchyConnectionTexture.hideFlags = HideFlags.DontSave;
                }
                return mHierarchyConnectionTexture;
            }
        }
        static Texture2D mHierarchyConnectionTexture;

        public static Texture2D RndSeedTexture
        {
            get
            {
                if (mRndSeedTexture == null)
                {
                    mRndSeedTexture = CurvyResource.Load("rndseed,12,12");
                    // mRndSeedTexture = CurvyResource.Load (GetTextureFilename ("rndseed", 12, 12));
                    // mRndSeedTexture.hideFlags = HideFlags.DontSave;
                }
                return mRndSeedTexture;
            }
        }
        static Texture2D mRndSeedTexture;

        public static Texture2D DeleteTexture
        {
            get
            {
                if (mDeleteTexture == null)
                {
                    // mDeleteTexture = CurvyResource.Load("delete16,16,16");
                    mDeleteTexture = CurvyResource.Load(GetTextureFilename("delete16", 16, 16));
                    //mDeleteTexture.hideFlags = HideFlags.DontSave;
                }
                return mDeleteTexture;
            }
        }
        static Texture2D mDeleteTexture;

        public static Texture2D DeleteBTexture
        {
            get
            {
                if (deleteBTexture == null)
                {
                    // mDeleteTexture = CurvyResource.Load("delete16,16,16");
                    deleteBTexture = CurvyResource.Load(GetTextureFilename("deleteB16", 16, 16));
                    //mDeleteTexture.hideFlags = HideFlags.DontSave;
                }
                return deleteBTexture;
            }
        }
        static Texture2D deleteBTexture;

        public static Texture2D SaveResourcesTexture
        {
            get
            {
                if (saveResourcesTexture == null)
                {
                    saveResourcesTexture = CurvyResource.Load(GetTextureFilename("save_resources", 16, 16));
                }
                return saveResourcesTexture;
            }
        }
        static Texture2D saveResourcesTexture;

        public static Texture2D RefreshTexture
        {
            get
            {
                if (mRefreshTexture == null)
                {
                    // mRefreshTexture = CurvyResource.Load("reload,16,16");
                    mRefreshTexture = CurvyResource.Load(GetTextureFilename("reload", 16, 16));
                    //mRefreshTexture.hideFlags = HideFlags.DontSave;
                }
                return mRefreshTexture;
            }
        }
        static Texture2D mRefreshTexture;

        public static Texture2D ReorderTexture
        {
            get
            {
                if (mReorderTexture == null)
                {
                    mReorderTexture = CurvyResource.Load(GetTextureFilename("reorder", 16, 16));
                }
                return mReorderTexture;
            }
        }
        static Texture2D mReorderTexture;

        public static Texture2D CGAutoFoldTexture
        {
            get
            {
                if (mCGAutoFoldTexture == null)
                {
                    // mCGAutoFoldTexture = CurvyResource.Load("autofold,16,16");
                    mCGAutoFoldTexture = CurvyResource.Load(GetTextureFilename("autofold", 16, 16));
                    //mCGAutoFoldTexture.hideFlags = HideFlags.DontSave;
                }
                return mCGAutoFoldTexture;
            }
        }
        static Texture2D mCGAutoFoldTexture;

        public static Texture2D AddTemplateTexture
        {
            get
            {
                if (mAddTemplateTexture == null)
                {
                    // mAddTemplateTexture = CurvyResource.Load("addCGTemplate,16,16");
                    mAddTemplateTexture = CurvyResource.Load(GetTextureFilename("addCGTemplate", 16, 16));
                    //mAddTemplateTexture.hideFlags = HideFlags.DontSave;
                }
                return mAddTemplateTexture;
            }
        }
        static Texture2D mAddTemplateTexture;

        public static Texture2D DebugTexture
        {
            get
            {
                if (mDebugTexture == null)
                {
                    // mDebugTexture = CurvyResource.Load("debug,16,16");
                    mDebugTexture = CurvyResource.Load(GetTextureFilename("debug", 16, 16));
                    //mDebugTexture.hideFlags = HideFlags.DontSave;
                }
                return mDebugTexture;
            }
        }
        static Texture2D mDebugTexture;

        public static Texture2D DebugSceneViewTexture
        {
            get
            {
                return (EditorGUIUtility.isProSkin) ?
                    EditorGUIUtility.IconContent("d_UnityEditor.SceneView").image as Texture2D :
                    EditorGUIUtility.IconContent("UnityEditor.SceneView").image as Texture2D;
            }
        }

        public static Texture2D LineTexture
        {
            get
            {
                if (mLineTexture == null)
                {
                    mLineTexture = new Texture2D(1, 2);
                    Color c = Color.white;//.SkinAwareColor();
                    Color ca = new Color(c.r, c.g, c.b, 0);
                    mLineTexture.SetPixels(new Color[] { ca, c });
                    //mLineTexture.hideFlags = HideFlags.DontSave;
                    mLineTexture.Apply();
                }
                return mLineTexture;
            }
        }
        static Texture2D mLineTexture;

        public static Texture2D RequestLineTexture
        {
            get
            {
                if (mRequestLineTexture == null)
                {
                    mRequestLineTexture = new Texture2D(2, 2);
                    Color c = Color.white;
                    Color ca = new Color(c.r, c.g, c.b, 0);
                    mRequestLineTexture.SetPixels(new Color[] { ca, Color.black, c, Color.black });
                    //mRequestLineTexture.hideFlags = HideFlags.DontSave;
                    mRequestLineTexture.Apply();
                }
                return mRequestLineTexture;
            }
        }
        static Texture2D mRequestLineTexture;

        public static Texture2D InspectorTexture
        {
            get
            {
                return EditorGUIUtility.IconContent("d_UnityEditor.InspectorWindow").image as Texture2D;
            }
        }

        public static Texture2D ExpandTexture
        {
            get
            {
                if (mExpandTexture == null)
                {
                    // mExpandTexture = CurvyResource.Load("expand16,16,16");
                    mExpandTexture = CurvyResource.Load(GetTextureFilename("expand16", 16, 16));
                    //mExpandTexture.hideFlags = HideFlags.DontSave;
                }
                return mExpandTexture;
            }
        }
        static Texture2D mExpandTexture;

        public static Texture2D SynchronizeTexture
        {
            get
            {
                if (mSynchronizeTexture == null)
                {
                    // mSynchronizeTexture = CurvyResource.Load("synchronize,16,16");
                    mSynchronizeTexture = CurvyResource.Load(GetTextureFilename("synchronize", 16, 16));
                    //mSynchronizeTexture.hideFlags = HideFlags.DontSave;
                }
                return mSynchronizeTexture;
            }
        }
        static Texture2D mSynchronizeTexture;

        public static Texture2D CollapseTexture
        {
            get
            {
                if (mCollapseTexture == null)
                {
                    // mCollapseTexture = CurvyResource.Load("collapse16,16,16");
                    mCollapseTexture = CurvyResource.Load(GetTextureFilename("collapse16", 16, 16));
                    //mCollapseTexture.hideFlags = HideFlags.DontSave;
                }
                return mCollapseTexture;
            }
        }
        static Texture2D mCollapseTexture;

        public static Texture2D OpenGraphTexture
        {
            get
            {
                if (mOpenGraphTexture == null)
                {
                    // mOpenGraphTexture = CurvyResource.Load("opengraph,24,24");
                    mOpenGraphTexture = CurvyResource.Load(GetTextureFilename("opengraph", 24, 24));
                    //mOpenGraphTexture.hideFlags = HideFlags.DontSave;
                }
                return mOpenGraphTexture;
            }
        }
        static Texture2D mOpenGraphTexture;

        public static Texture2D DeleteSmallTexture
        {
            get
            {
                if (mDeleteSmallTexture == null)
                {
                    // mDeleteSmallTexture = CurvyResource.Load ("deletesmall,12,12");
                    mDeleteSmallTexture = CurvyResource.Load(GetTextureFilename("deletesmall", 12, 12));
                    //mDeleteSmallTexture.hideFlags = HideFlags.DontSave;
                }
                return mDeleteSmallTexture;
            }
        }
        static Texture2D mDeleteSmallTexture;

        public static Texture2D ClearSmallTexture
        {
            get
            {
                if (mClearSmallTexture == null)
                {
                    // mClearSmallTexture = CurvyResource.Load ("clearsmall,12,12");
                    mClearSmallTexture = CurvyResource.Load(GetTextureFilename("clearsmall", 12, 12));
                    //mClearSmallTexture.hideFlags = HideFlags.DontSave;
                }
                return mClearSmallTexture;
            }
        }
        static Texture2D mClearSmallTexture;

        public static Texture2D SelectTexture
        {
            get
            {
                if (mSelectTexture == null)
                {
                    // mSelectTexture = CurvyResource.Load("selectsmall,12,12");
                    mSelectTexture = CurvyResource.Load(GetTextureFilename("selectsmall", 12, 12));
                    //mSelectTexture.hideFlags = HideFlags.DontSave;
                }
                return mSelectTexture;
            }
        }
        static Texture2D mSelectTexture;

        public static Texture2D AddSmallTexture
        {
            get
            {
                if (mAddSmallTexture == null)
                {
                    // mAddSmallTexture = CurvyResource.Load("addsmall,12,12");
                    mAddSmallTexture = CurvyResource.Load(GetTextureFilename("addsmall", 12, 12));
                    // mAddSmallTexture.hideFlags = HideFlags.DontSave;
                }
                return mAddSmallTexture;
            }
        }
        static Texture2D mAddSmallTexture;

        #region --- Toolbar Icons ---



        public static Texture2D IconPrefs
        {
            get
            {
                if (mIconPrefs == null)
                {
                    mIconPrefs = CurvyResource.Load("prefs,24,24");
                    mIconPrefs.hideFlags = HideFlags.DontSave;
                }
                return mIconPrefs;
            }
        }
        static Texture2D mIconPrefs;

        public static Texture2D IconAbout
        {
            get
            {
                if (mIconAbout == null)
                {
                    mIconAbout = CurvyResource.Load("about,24,24");
                    mIconAbout.hideFlags = HideFlags.DontSave;
                }
                return mIconAbout;
            }
        }
        static Texture2D mIconAbout;

        public static Texture2D IconAsmdef
        {
            get
            {
                if (mIconAsmdef == null)
                {
                    mIconAsmdef = CurvyResource.Load("asmdef,24,24");
                    mIconAsmdef.hideFlags = HideFlags.DontSave;
                }
                return mIconAsmdef;
            }
        }
        static Texture2D mIconAsmdef;

        public static Texture2D IconHelp
        {
            get
            {
                if (mIconHelp == null)
                {
                    mIconHelp = CurvyResource.Load("help,24,24");
                    mIconHelp.hideFlags = HideFlags.DontSave;
                }
                return mIconHelp;
            }
        }
        static Texture2D mIconHelp;

        public static Texture2D IconWWW
        {
            get
            {
                if (mIconWWW == null)
                {
                    mIconWWW = CurvyResource.Load("web,24,24");
                    mIconWWW.hideFlags = HideFlags.DontSave;
                }
                return mIconWWW;
            }
        }
        static Texture2D mIconWWW;

        public static Texture2D IconBugReporter
        {
            get
            {
                if (mIconBugReporter == null)
                {
                    mIconBugReporter = CurvyResource.Load("bugreport,24,24");
                    mIconBugReporter.hideFlags = HideFlags.DontSave;
                }
                return mIconBugReporter;
            }
        }
        static Texture2D mIconBugReporter;

        public static Texture2D IconNewShape
        {
            get
            {
                if (mIconNewShape == null)
                {
                    mIconNewShape = CurvyResource.Load("shapewizard,24,24");
                    mIconNewShape.hideFlags = HideFlags.DontSave;
                }
                return mIconNewShape;
            }
        }
        static Texture2D mIconNewShape;

        public static Texture2D IconNewGroup
        {
            get
            {
                if (mIconNewGroup == null)
                {
                    mIconNewGroup = CurvyResource.Load("group,24,24");
                    mIconNewGroup.hideFlags = HideFlags.DontSave;
                }
                return mIconNewGroup;
            }
        }
        static Texture2D mIconNewGroup;

        public static Texture2D IconNewCG
        {
            get
            {
                if (mIconNewCG == null)
                {
                    mIconNewCG = CurvyResource.Load(GetTextureFilename("opengraph", 24, 24));
                    mIconNewCG.hideFlags = HideFlags.DontSave;
                }
                return mIconNewCG;
            }
        }
        static Texture2D mIconNewCG;


        public static Texture2D IconCP
        {
            get
            {
                if (mIconCP == null)
                {
                    mIconCP = CurvyResource.Load("singlecp,24,24");
                    mIconCP.hideFlags = HideFlags.DontSave;
                }
                return mIconCP;
            }
        }
        static Texture2D mIconCP;

        public static Texture2D IconCPOff
        {
            get
            {
                if (mIconCPOff == null)
                {
                    mIconCPOff = CurvyResource.Load("singlecp_off,24,24");
                    mIconCPOff.hideFlags = HideFlags.DontSave;
                }
                return mIconCPOff;
            }
        }
        static Texture2D mIconCPOff;

        public static Texture2D IconRaycast
        {
            get
            {
                if (mIconRaycast == null)
                {
                    mIconRaycast = CurvyResource.Load("raycast,24,24");
                    mIconRaycast.hideFlags = HideFlags.DontSave;
                }
                return mIconRaycast;
            }
        }
        static Texture2D mIconRaycast;

        public static Texture2D IconRaycastOff
        {
            get
            {
                if (mIconRaycastOff == null)
                {
                    mIconRaycastOff = CurvyResource.Load("raycast_off,24,24");
                    mIconRaycastOff.hideFlags = HideFlags.DontSave;
                }
                return mIconRaycastOff;
            }
        }
        static Texture2D mIconRaycastOff;

        public static Texture2D IconSubdivide
        {
            get
            {
                if (mIconSubdivide == null)
                {
                    mIconSubdivide = CurvyResource.Load("subdivide,24,24");
                    mIconSubdivide.hideFlags = HideFlags.DontSave;
                }
                return mIconSubdivide;
            }
        }
        static Texture2D mIconSubdivide;

        public static Texture2D IconSimplify
        {
            get
            {
                if (mIconSimplify == null)
                {
                    mIconSimplify = CurvyResource.Load("simplify,24,24");
                    mIconSimplify.hideFlags = HideFlags.DontSave;
                }
                return mIconSimplify;
            }
        }
        static Texture2D mIconSimplify;

        public static Texture2D IconEqualize
        {
            get
            {
                if (mIconEqualize == null)
                {
                    mIconEqualize = CurvyResource.Load("equalize,24,24");
                    mIconEqualize.hideFlags = HideFlags.DontSave;
                }
                return mIconEqualize;
            }
        }
        static Texture2D mIconEqualize;

        public static Texture2D IconMeshExport
        {
            get
            {
                if (mIconMeshExport == null)
                {
                    mIconMeshExport = CurvyResource.Load("exportmesh,24,24");
                    mIconMeshExport.hideFlags = HideFlags.DontSave;
                }
                return mIconMeshExport;
            }
        }
        static Texture2D mIconMeshExport;

        public static Texture2D IconSyncFromHierarchy
        {
            get
            {
                if (mIconSyncFromHierarchy == null)
                {
                    mIconSyncFromHierarchy = CurvyResource.Load("syncfromhierarchy,24,24");
                    mIconSyncFromHierarchy.hideFlags = HideFlags.DontSave;
                }
                return mIconSyncFromHierarchy;
            }
        }
        static Texture2D mIconSyncFromHierarchy;

        public static Texture2D IconSelectContainingConnections
        {
            get
            {
                if (mIconSelectContainingConnections == null)
                {
                    mIconSelectContainingConnections = CurvyResource.Load("containingcon,24,24");
                    mIconSelectContainingConnections.hideFlags = HideFlags.DontSave;
                }
                return mIconSelectContainingConnections;
            }
        }
        static Texture2D mIconSelectContainingConnections;

        public static Texture2D IconAxisXY
        {
            get
            {
                if (mIconAxisXY == null)
                {
                    mIconAxisXY = CurvyResource.Load("axisxy,24,24");
                    mIconAxisXY.hideFlags = HideFlags.DontSave;
                }
                return mIconAxisXY;
            }
        }
        static Texture2D mIconAxisXY;

        public static Texture2D IconAxisXZ
        {
            get
            {
                if (mIconAxisXZ == null)
                {
                    mIconAxisXZ = CurvyResource.Load("axisxz,24,24");
                    mIconAxisXZ.hideFlags = HideFlags.DontSave;
                }
                return mIconAxisXZ;
            }
        }
        static Texture2D mIconAxisXZ;

        public static Texture2D IconAxisYZ
        {
            get
            {
                if (mIconAxisYZ == null)
                {
                    mIconAxisYZ = CurvyResource.Load("axisyz,24,24");
                    mIconAxisYZ.hideFlags = HideFlags.DontSave;
                }
                return mIconAxisYZ;
            }
        }
        static Texture2D mIconAxisYZ;

        public static Texture2D IconView
        {
            get
            {
                if (iconView == null)
                {
                    iconView = CurvyResource.Load("view,24,24");
                    iconView.hideFlags = HideFlags.DontSave;
                }
                return iconView;
            }
        }
        static Texture2D iconView;

        #endregion

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyStyles.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyToolbar.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 9754d38a59ed87e4e8f29f32d66c699c
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using FluffyUnderware.DevToolsEditor;
using UnityEditor;
using FluffyUnderware.Curvy;
using FluffyUnderware.DevTools.Extensions;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.Curvy.Shapes;
using FluffyUnderware.Curvy.Generator;
using System.Linq;
using FluffyUnderware.Curvy.Controllers;
using FluffyUnderware.CurvyEditor.Generator;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevTools;
using UnityEngine.Assertions;
using Object = UnityEngine.Object;

namespace FluffyUnderware.CurvyEditor.UI
{
    [ToolbarItem(10, "Curvy", "Options", "Curvy Options", "curvyicon_dark,24,24", "curvyicon_light,24,24")]
    public class TBOptions : DTToolbarToggleButton
    {

        public override string StatusBarInfo { get { return "Open Curvy Options menu"; } }


        public override void RenderClientArea(Rect r)
        {
            base.RenderClientArea(r);
            SetElementSize(ref r, 32, 32);
            if (GUI.Button(r, new GUIContent(CurvyStyles.IconPrefs, "Preferences")))
            {
                DT.OpenPreferencesWindow(CurvyProject.CurvySettingsProvider.GetPreferencesPath());
                On = false;
            }
            Advance(ref r);
            if (GUI.Button(r, new GUIContent(CurvyStyles.IconAsmdef, "Generate Assembly Definitions")))
            {
                CurvyEditorUtility.GenerateAssemblyDefinitions();
                On = false;
            }
            Advance(ref r);
            if (GUI.Button(r, new GUIContent(CurvyStyles.IconHelp, "Online Manual")))
            {
                AboutWindow.OpenDocs();
                On = false;
            }
            Advance(ref r);
            if (GUI.Button(r, new GUIContent(CurvyStyles.IconWWW, "Curvy Website")))
            {
                AboutWindow.OpenWeb();
                On = false;
            }
            Advance(ref r);
            if (GUI.Button(r, new GUIContent(CurvyStyles.IconBugReporter, "Report Bug")))
            {
                CurvyEditorUtility.SendBugReport();
                On = false;
            }
            Advance(ref r);
            if (GUI.Button(r, new GUIContent(CurvyStyles.IconAbout, "About Curvy")))
                AboutWindow.Open();



        }

        public override void OnSelectionChange()
        {
            Visible = CurvyProject.Instance.ShowGlobalToolbar || DTSelection.HasComponent<CurvySpline, CurvySplineSegment, CurvyController, CurvyGenerator>(true);
        }

    }

    [ToolbarItem(12, "Curvy", "View", "View Settings", "viewsettings,24,24")]
    public class TBViewSetttings : DTToolbarToggleButton
    {
        public override string StatusBarInfo { get { return "Set Curvy Scene View visibility"; } }



        public override void OnSelectionChange()
        {
            Visible = CurvyProject.Instance.ShowGlobalToolbar || DTSelection.HasComponent<CurvySpline, CurvySplineSegment, CurvyController, CurvyGenerator>(true);
        }

        public override void RenderClientArea(Rect r)
        {
            base.RenderClientArea(r);
            bool b;
            bool v;

            Background(r, 134, 230);
            SetElementSize(ref r, 134, 19);

            EditorGUI.BeginChangeCheck();
            b = (CurvyGlobalManager.Gizmos == CurvySplineGizmos.None);
            b = GUI.Toggle(r, b, "None");
            if (b)
                CurvyGlobalManager.Gizmos = CurvySplineGizmos.None;
            // Curve
            AdvanceBelow(ref r);
            b = CurvyGlobalManager.ShowCurveGizmo;
            v = GUI.Toggle(r, b, "Curve");
            if (b != v)
                CurvyGlobalManager.ShowCurveGizmo = v;
            // Connection
            AdvanceBelow(ref r);
            b = CurvyGlobalManager.ShowConnectionsGizmo;
            v = GUI.Toggle(r, b, "Connections");
            if (b != v)
                CurvyGlobalManager.ShowConnectionsGizmo = v;
            // Orientation Anchor
            AdvanceBelow(ref r);
            b = CurvyGlobalManager.ShowOrientationAnchorsGizmo;
            v = GUI.Toggle(r, b, "Orientation Anchors");
            if (b != v)
                CurvyGlobalManager.ShowOrientationAnchorsGizmo = v;
            // Approximation
            AdvanceBelow(ref r);
            b = CurvyGlobalManager.ShowApproximationGizmo;
            v = GUI.Toggle(r, b, "Approximations");
            if (b != v)
                CurvyGlobalManager.ShowApproximationGizmo = v;
            // Orientation
            AdvanceBelow(ref r);
            b = CurvyGlobalManager.ShowOrientationGizmo;
            v = GUI.Toggle(r, b, "Orientation");
            if (b != v)
                CurvyGlobalManager.ShowOrientationGizmo = v;
            // Tangents
            AdvanceBelow(ref r);
            b = CurvyGlobalManager.ShowTangentsGizmo;
            v = GUI.Toggle(r, b, "Tangents");
            if (b != v)
                CurvyGlobalManager.ShowTangentsGizmo = v;
            // TF
            AdvanceBelow(ref r);
            b = CurvyGlobalManager.ShowTFsGizmo;
            v = GUI.Toggle(r, b, "TF");
            if (b != v)
                CurvyGlobalManager.ShowTFsGizmo = v;
            // Distance
            AdvanceBelow(ref r);
            b = CurvyGlobalManager.ShowRelativeDistancesGizmo;
            v = GUI.Toggle(r, b, "Relative Distances");
            if (b != v)
                CurvyGlobalManager.ShowRelativeDistancesGizmo = v;
            // UserValues
            AdvanceBelow(ref r);
            b = CurvyGlobalManager.ShowMetadataGizmo;
            v = GUI.Toggle(r, b, "Metadata");
            if (b != v)
                CurvyGlobalManager.ShowMetadataGizmo = v;
            // Labels
            AdvanceBelow(ref r);
            b = CurvyGlobalManager.ShowLabelsGizmo;
            v = GUI.Toggle(r, b, "Labels");
            if (b != v)
                CurvyGlobalManager.ShowLabelsGizmo = v;
            // Bounds
            AdvanceBelow(ref r);
            b = CurvyGlobalManager.ShowBoundsGizmo;
            v = GUI.Toggle(r, b, "Bounds");
            if (b != v)
                CurvyGlobalManager.ShowBoundsGizmo = v;

            if (EditorGUI.EndChangeCheck())
                CurvyProject.Instance.SavePreferences();
        }

    }

    [ToolbarItem(30, "Curvy", "Create", "Create", "add,24,24")]
    public class TBNewMenu : DTToolbarToggleButton
    {
        public override string StatusBarInfo { get { return "Create"; } }


        public override void RenderClientArea(Rect r)
        {
            base.RenderClientArea(r);
            SetElementSize(ref r, 32, 32);
            if (GUI.Button(r, new GUIContent(CurvyStyles.IconNewShape, "Shape")))
            {
                CurvyMenu.CreateCurvySpline(new MenuCommand(Selection.activeGameObject));
                Project.FindItem<TBSplineSetShape>().OnClick();

                On = false;
            }
            Advance(ref r);
            if (GUI.Button(r, new GUIContent(CurvyStyles.IconNewCG, "Generator")))
            {
                CurvyGenerator cg = new GameObject("Curvy Generator", typeof(CurvyGenerator)).GetComponent<CurvyGenerator>();
                CurvyMenu.ApplyIncrementalNameToGenerator(cg);
                Undo.RegisterCreatedObjectUndo(cg.gameObject, "Create Generator");
                if (cg)
                {
                    GameObject parent = DTSelection.GetGameObject(false);
                    if (parent != null)
                    {
                        Undo.SetTransformParent(cg.transform, parent.transform, "Create Generator");
                        cg.transform.localPosition = Vector3.zero;
                        cg.transform.localRotation = Quaternion.identity;
                        cg.transform.localScale = Vector3.one;
                    }
                    // if a spline is selected, create an Input module
                    if (DTSelection.HasComponent<CurvySpline>())
                    {
                        InputSplinePath mod = cg.AddModule<InputSplinePath>();
                        mod.Spline = DTSelection.GetAs<CurvySpline>();
                    }
                    DTSelection.SetGameObjects(cg);
                    CGGraph.Open(cg);
                }
                On = false;
            }
        }

        public override void OnSelectionChange()
        {
            Visible = CurvyProject.Instance.ShowGlobalToolbar || DTSelection.HasComponent<CurvySpline, CurvySplineSegment, CurvyController, CurvyGenerator>(true);
        }

    }

    [ToolbarItem(32, "Curvy", "Draw Spline", "Draw Splines", "draw,24,24")]
    public class TBDrawControlPoints : DTToolbarToggleButton
    {
        private enum RayCastPlane
        {
            Undefinded,
            LocalXY,
            GlobalXY,
            LocalYZ,
            GlobalYZ,
            LocalXZ,
            GlobalXZ,
            ViewPlane
        }

        private RayCastPlane rayCastPlane = RayCastPlane.LocalXZ;

        public override string StatusBarInfo { get { return "Create splines and Control Points"; } }

        enum ModeEnum
        {
            None = 0,
            Add = 1,
            Pick = 2,

        }

        ModeEnum Mode = ModeEnum.None;

        CurvySplineSegment selectedCP;
        CurvySpline selectedSpline;

        public TBDrawControlPoints()
        {
            KeyBindings.Add(new EditorKeyBinding("Toggle Draw Mode", "", KeyCode.Space));
        }



        public override void HandleEvents(Event e)
        {
            base.HandleEvents(e);
            if (On && DTHandles.MouseOverSceneView)
            {
                Mode = ModeEnum.None;
                if (e.control && !e.alt) // Prevent that Panning (CTRL+ALT+LMB) creates CP'S
                {
                    Mode = ModeEnum.Add;
                    if (e.shift)
                        Mode |= ModeEnum.Pick;
                }

                if (e.type == EventType.MouseDown)
                {
                    if (Mode.HasFlag(ModeEnum.Add))
                    {
                        addCP(e.mousePosition, Mode.HasFlag(ModeEnum.Pick), e.button == 1);
                        DTGUI.UseEvent(GetHashCode(), e);
                    }

                }
                if (Mode.HasFlag(ModeEnum.Add))
                {
                    string bLmbBAddControlPointBRmbBAddSmartConnect =
                        "<b>[LMB] on empty space:</b> Add Control Point\n" +
                        "<b>[LMB] on first Control Point:</b> Close/Open the spline\n" +
                        "<b>[RMB] on empty space:</b> Add & Connect to new spline\n" +
                        "<b>[RMB] on segment:</b> Add & Connect to existing spline";

                    if (Mode.HasFlag(ModeEnum.Pick))
                    {
                        //<b>[LMB On first Control Point]</b> Close/Open the spline
                        _StatusBar.Set(bLmbBAddControlPointBRmbBAddSmartConnect, "DrawMode");
                    }
                    else
                        _StatusBar.Set($"{bLmbBAddControlPointBRmbBAddSmartConnect}\n<b>[Shift]</b> Raycast", "DrawMode");
                }
                else
                    _StatusBar.Set("Hold <b>[Ctrl]</b> to add Control Points", "DrawMode");
            }
            else
                _StatusBar.Clear("DrawMode");
        }

        public override void RenderClientArea(Rect r)
        {
            base.RenderClientArea(r);

            bool raycastAgainstGeometry = Mode.HasFlag(ModeEnum.Pick);

            SetElementSize(ref r, 32, 32);

            if (raycastAgainstGeometry)
            {

            }
            else if (SceneView.currentDrawingSceneView.in2DMode)
            {
                rayCastPlane = RayCastPlane.GlobalXY;
            }
            else if (selectedSpline != null && selectedSpline.RestrictTo2D)
            {
                switch (selectedSpline.Restricted2DPlane)
                {
                    case CurvyPlane.XY:
                        rayCastPlane = RayCastPlane.LocalXY;
                        break;
                    case CurvyPlane.XZ:
                        rayCastPlane = RayCastPlane.LocalXZ;
                        break;
                    case CurvyPlane.YZ:
                        rayCastPlane = RayCastPlane.LocalYZ;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
            else
            {
                if (GUI.Toggle(r,
                    rayCastPlane == RayCastPlane.ViewPlane,
                    new GUIContent(CurvyStyles.IconView, "Use view plane"), GUI.skin.button))
                    rayCastPlane = RayCastPlane.ViewPlane;
                Advance(ref r);

                if (GUI.Toggle(r,
                    rayCastPlane == RayCastPlane.GlobalXY || rayCastPlane == RayCastPlane.LocalXY,
                    new GUIContent(CurvyStyles.IconAxisXY, "Use XY plane"), GUI.skin.button))
                    rayCastPlane = Tools.pivotRotation == PivotRotation.Local ? RayCastPlane.LocalXY : RayCastPlane.GlobalXY;
                Advance(ref r);

                if (GUI.Toggle(r,
                    rayCastPlane == RayCastPlane.GlobalXZ || rayCastPlane == RayCastPlane.LocalXZ,
                    new GUIContent(CurvyStyles.IconAxisXZ, "Use XZ plane"), GUI.skin.button))
                    rayCastPlane = Tools.pivotRotation == PivotRotation.Local ? RayCastPlane.LocalXZ : RayCastPlane.GlobalXZ;
                Advance(ref r);

                if (GUI.Toggle(r,
                    rayCastPlane == RayCastPlane.GlobalYZ || rayCastPlane == RayCastPlane.LocalYZ,
                    new GUIContent(CurvyStyles.IconAxisYZ, "Use YZ plane"), GUI.skin.button))
                    rayCastPlane = Tools.pivotRotation == PivotRotation.Local ? RayCastPlane.LocalYZ : RayCastPlane.GlobalYZ;
                Advance(ref r);
            }

            SetElementSize(ref r, 24, 24);
            r.y += 4;
            GUI.DrawTexture(r, Mode.HasFlag(ModeEnum.Add) ? CurvyStyles.IconCP : CurvyStyles.IconCPOff);

            Advance(ref r);
            GUI.DrawTexture(r, raycastAgainstGeometry ? CurvyStyles.IconRaycast : CurvyStyles.IconRaycastOff);
        }

        bool pickScenePoint(Vector2 mousePos, bool castAgainstGeometry, CurvySpline referenceSpline, CurvySplineSegment referenceCP, out Vector3 pickedPoint)
        {
            Ray mouseRay = HandleUtility.GUIPointToWorldRay(mousePos);
            Vector3 referencePosition = ((referenceCP != null) ? referenceCP.transform : referenceSpline.transform).position;

            pickedPoint = Vector3.zero;
            bool didPickAPoint = false;

            if (castAgainstGeometry && Physics.Raycast(mouseRay, out RaycastHit hit))
            {
                pickedPoint = hit.point;
                didPickAPoint = true;
            }
            else
            {
                Plane plane;
                switch (rayCastPlane)
                {
                    case RayCastPlane.LocalXY:
                        plane = new Plane(referenceSpline.transform.forward, referencePosition);
                        break;
                    case RayCastPlane.GlobalXY:
                        plane = new Plane(Vector3.forward, referencePosition);
                        break;
                    case RayCastPlane.LocalYZ:
                        plane = new Plane(referenceSpline.transform.right, referencePosition);
                        break;
                    case RayCastPlane.GlobalYZ:
                        plane = new Plane(Vector3.right, referencePosition);
                        break;
                    case RayCastPlane.LocalXZ:
                        plane = new Plane(referenceSpline.transform.up, referencePosition);
                        break;
                    case RayCastPlane.GlobalXZ:
                        plane = new Plane(Vector3.up, referencePosition);
                        break;
                    case RayCastPlane.ViewPlane:
                        plane = new Plane(SceneView.currentDrawingSceneView.camera.transform.forward, referencePosition);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }


                float hitDistance;
                if (plane.Raycast(mouseRay, out hitDistance))
                {
                    pickedPoint = mouseRay.GetPoint(hitDistance);
                    didPickAPoint = true;
                }
                //fallback: this can happen if you select xy plane but scene view is orthogonal and set to yz. Meaning that all rays are parallel to xy plane. We use the same logic than in RayCastPlane.ViewPlane as a fallback
                else if (new Plane(SceneView.currentDrawingSceneView.camera.transform.forward, referencePosition).Raycast(mouseRay, out hitDistance))
                {
                    pickedPoint = mouseRay.GetPoint(hitDistance);
                    didPickAPoint = true;
                }
            }

            if (didPickAPoint == false)
                DTLog.LogWarning("[Curvy] Draw Splines tool: could not pick a valid position. Please raise a bug report.");

            return didPickAPoint;
        }

        void addCP(Vector2 cursor, bool castRay, bool connectNew)
        {
            const string undoingOperationLabel = "Add ControlPoint";

            Func<CurvySpline, CurvySplineSegment, Vector3, CurvySplineSegment> insertControlPoint =
                (spline, current, worldPos) =>
                {
                    CurvySplineSegment seg = spline.InsertAfter(current, worldPos, false, Space.World);
                    Undo.RegisterCreatedObjectUndo(seg.gameObject, undoingOperationLabel);
                    return seg;
                };


            if (selectedSpline) //selecp the last cp if none selected
            {
                if (!selectedCP && selectedSpline.ControlPointCount > 0)
                    selectedCP = selectedSpline.ControlPointsList[selectedSpline.ControlPointCount - 1];
            }
            else //create a spline if none selected
            {
                selectedSpline = CurvySpline.Create();

                //Restricted2DPlane
                switch (rayCastPlane)
                {
                    case RayCastPlane.ViewPlane:
                    case RayCastPlane.LocalXY:
                    case RayCastPlane.GlobalXY:
                        selectedSpline.Restricted2DPlane = CurvyPlane.XY;
                        break;
                    case RayCastPlane.LocalYZ:
                    case RayCastPlane.GlobalYZ:
                        selectedSpline.Restricted2DPlane = CurvyPlane.YZ;
                        break;
                    case RayCastPlane.LocalXZ:
                    case RayCastPlane.GlobalXZ:
                        selectedSpline.Restricted2DPlane = CurvyPlane.XZ;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }

                CurvyMenu.ApplyIncrementalNameToSpline(selectedSpline);

                Undo.RegisterCreatedObjectUndo(selectedSpline.gameObject, undoingOperationLabel);

                Transform parent = DTSelection.GetAs<Transform>();
                selectedSpline.transform.SetParent(parent);
                if (parent == null)
                    selectedSpline.transform.position = HandleUtility.GUIPointToWorldRay(cursor).GetPoint(10);
            }

            // Pick a point to add the CP at
            Vector3 pickedPoint;
            if (!pickScenePoint(cursor, castRay, selectedSpline, selectedCP, out pickedPoint))
                return;

            CurvySplineSegment pickedControlPoint;
            {
                GameObject pickedGameObject = HandleUtility.PickGameObject(cursor, false);
                pickedControlPoint = pickedGameObject ? pickedGameObject.GetComponent<CurvySplineSegment>() : null;
            }

            CurvySplineSegment newCP;
            // Connect by creating a new spline with 2 CP, the first "over" selectedCP, the second at the desired new position
            // OR connect to existing CP
            if (connectNew && selectedCP)
            {
                CurvySplineSegment cpToConnect;//To connect with the selected cp

                // if mouse is over an existing CP, connect to this (if possible)
                // if we picked a target cp, it may be a pick on it's segment, so check distance to CP
                if (pickedControlPoint)
                {
                    Plane plane = new Plane(SceneView.currentDrawingSceneView.camera.transform.forward, pickedControlPoint.transform.position);
                    Ray ray = HandleUtility.GUIPointToWorldRay(cursor);
                    float dist;
                    if (plane.Raycast(ray, out dist))
                    {
                        //Setting connectedCp
                        {
                            Vector3 hit = ray.GetPoint(dist);
                            if ((hit - pickedControlPoint.transform.position).magnitude <= HandleUtility.GetHandleSize(hit) * CurvyGlobalManager.GizmoControlPointSize)
                            {
                                cpToConnect = pickedControlPoint;
                            }
                            else
                            {
                                if (pickedControlPoint.Spline.Dirty)
                                    pickedControlPoint.Spline.Refresh();

                                Vector3 position = pickedControlPoint.Interpolate(pickedControlPoint.GetNearestPointF(hit, Space.World), Space.World);
                                cpToConnect = insertControlPoint(pickedControlPoint.Spline, pickedControlPoint, position);
                            }
                        }
                        newCP = insertControlPoint(selectedSpline, selectedCP, cpToConnect.transform.position);
                        selectedCP = newCP;
                    }
                    else
                        newCP = cpToConnect = null;
                }
                else
                    newCP = cpToConnect = null;

                if (!cpToConnect)
                {
                    CurvySpline newSpline = CurvySpline.Create(selectedSpline);
                    CurvyMenu.ApplyIncrementalNameToSpline(newSpline);

                    Undo.RegisterCreatedObjectUndo(newSpline.gameObject, undoingOperationLabel);

                    newSpline.Closed = false;
                    cpToConnect = insertControlPoint(newSpline, null, selectedCP.transform.position);
                    newCP = insertControlPoint(newSpline, cpToConnect, pickedPoint);
                    selectedSpline = newSpline;
                }

                {
#if CURVY_SANITY_CHECKS
                    Assert.IsFalse((selectedCP.Connection != cpToConnect.Connection) && (selectedCP.Connection != null && cpToConnect.Connection != null), "Both Control Points should not have different non null connections");
#endif
                    CurvySplineSegment connectionSourceCp;
                    CurvySplineSegment connectionDestinationCp;
                    if (selectedCP.Connection != null)
                    {
                        connectionSourceCp = selectedCP;
                        connectionDestinationCp = cpToConnect;
                    }
                    else
                    {
                        if (cpToConnect.Connection == null)
                        {
                            CurvyConnection.Create(cpToConnect, selectedCP);

                            cpToConnect.Connection.SetSynchronisationPositionAndRotation(cpToConnect.transform.position, cpToConnect.transform.rotation);
                            cpToConnect.ConnectionSyncPosition = true;
                            cpToConnect.ConnectionSyncRotation = true;
                            cpToConnect.FollowUpHeading = ConnectionHeadingEnum.Auto;
                        }

                        connectionSourceCp = cpToConnect;
                        connectionDestinationCp = selectedCP;
                    }

                    CurvyConnection connection = connectionSourceCp.Connection;
                    Undo.RecordObject(connection, undoingOperationLabel);
                    if (connection.ControlPointsList.Contains(connectionDestinationCp) == false)
                        connection.AddControlPoints(connectionDestinationCp);
                    connectionDestinationCp.ConnectionSyncPosition = connectionSourceCp.ConnectionSyncPosition;
                    connectionDestinationCp.ConnectionSyncRotation = connectionSourceCp.ConnectionSyncRotation;
                    connectionDestinationCp.FollowUpHeading = ConnectionHeadingEnum.Auto;
                    connection.SetSynchronisationPositionAndRotation(connection.transform.position, connection.transform.rotation);
                }
            }
            else
            {
                if (selectedSpline.Count >= 1 && pickedControlPoint == selectedSpline.FirstSegment)
                {
                    Undo.RecordObject(selectedSpline, undoingOperationLabel);
                    selectedSpline.Closed = !selectedSpline.Closed;
                    newCP = selectedSpline.Closed ? selectedSpline.LastSegment : selectedSpline.LastVisibleControlPoint;
                }
                else
                    newCP = insertControlPoint(selectedSpline, selectedCP, pickedPoint);
            }

            DTSelection.SetGameObjects(newCP);
        }

        public override void OnSelectionChange()
        {
            Visible = CurvyProject.Instance.ShowGlobalToolbar || DTSelection.HasComponent<CurvySpline, CurvySplineSegment, CurvyController, CurvyGenerator>(true);
            // Ensure we have a spline and a CP. If a spline is selected, choose the last CP
            selectedCP = DTSelection.GetAs<CurvySplineSegment>();
            selectedSpline = (selectedCP) ? selectedCP.Spline : DTSelection.GetAs<CurvySpline>();

        }
    }

    [ToolbarItem(35, "Curvy", "Import/Export", "Import or export splines", "importexport_dark,24,24", "importexport_light,24,24")]
    public class TBImportExport : DTToolbarButton
    {
        public override string StatusBarInfo { get { return "Import or export splines to/from various formats"; } }

        public TBImportExport()
        {
            KeyBindings.Add(new EditorKeyBinding("Import/Export", ""));
        }

        public override void OnClick()
        {
            ImportExportWizard.Open();
        }

        public override void OnSelectionChange()
        {
            Visible = CurvyProject.Instance.ShowGlobalToolbar;
        }
    }

    [ToolbarItem(100, "Curvy", "Select Parent", "", "selectparent,24,24")]
    public class TBSelectParent : DTToolbarButton
    {
        public override string StatusBarInfo { get { return "Select parent spline(s)"; } }

        public TBSelectParent()
        {
            KeyBindings.Add(new EditorKeyBinding("Select Parent", "", KeyCode.Backslash));
        }

        public override void OnClick()
        {
            base.OnClick();
            List<CurvySplineSegment> cps = DTSelection.GetAllAs<CurvySplineSegment>();
            List<CurvySpline> parents = new List<CurvySpline>();
            foreach (CurvySplineSegment cp in cps)
                if (cp.Spline && !parents.Contains(cp.Spline))
                    parents.Add(cp.Spline);

            DTSelection.SetGameObjects(parents.ToArray());
        }

        public override void OnSelectionChange()
        {
            Visible = DTSelection.HasComponent<CurvySplineSegment>(true);
        }
    }

    [ToolbarItem(101, "Curvy", "Select Children", "", "selectchilds,24,24")]
    public class TBSelectAllChildren : DTToolbarButton
    {
        public override string StatusBarInfo { get { return "Select Control Points"; } }

        public TBSelectAllChildren()
        {
            KeyBindings.Add(new EditorKeyBinding("Select Children", "", KeyCode.Backslash, true));
        }

        public override void OnClick()
        {
            base.OnClick();
            List<CurvySpline> splines = DTSelection.GetAllAs<CurvySpline>();
            List<CurvySplineSegment> cps = DTSelection.GetAllAs<CurvySplineSegment>();
            foreach (CurvySplineSegment cp in cps)
                if (cp.Spline && !splines.Contains(cp.Spline))
                    splines.Add(cp.Spline);
            List<CurvySplineSegment> res = new List<CurvySplineSegment>();
            foreach (CurvySpline spl in splines)
                res.AddRange(spl.ControlPointsList);

            DTSelection.SetGameObjects(res.ToArray());
        }

        public override void OnSelectionChange()
        {
            base.OnSelectionChange();
            Visible = DTSelection.HasComponent<CurvySpline, CurvySplineSegment>(true);
        }


    }

    [ToolbarItem(105, "Curvy", "Previous", "Select Previous", "prev,24,24")]
    public class TBCPPrevious : DTToolbarButton
    {
        public override string StatusBarInfo { get { return "Select previous Control Point"; } }

        public TBCPPrevious()
        {
            KeyBindings.Add(new EditorKeyBinding("Select Previous", "", KeyCode.Tab, true));
        }

        public override void OnClick()
        {
            base.OnClick();
            CurvySplineSegment cp = DTSelection.GetAs<CurvySplineSegment>();
            if (cp && cp.Spline)
                DTSelection.SetGameObjects(cp.Spline.ControlPointsList[(int)Mathf.Repeat(cp.Spline.GetControlPointIndex(cp) - 1, cp.Spline.ControlPointCount)]);
            else
            {
                CurvySpline spl = DTSelection.GetAs<CurvySpline>();
                if (spl && spl.ControlPointCount > 0)
                    DTSelection.SetGameObjects(spl.ControlPointsList[spl.ControlPointCount - 1]);
            }

        }

        public override void OnSelectionChange()
        {
            Visible = DTSelection.HasComponent<CurvySplineSegment>() || DTSelection.HasComponent<CurvySpline>();
        }
    }

    [ToolbarItem(106, "Curvy", "Next", "Select Next", "next,24,24")]
    public class TBCPNext : DTToolbarButton
    {
        public override string StatusBarInfo { get { return "Select next Control Point"; } }

        public TBCPNext()
        {
            KeyBindings.Add(new EditorKeyBinding("Select Next", "", KeyCode.Tab));
        }

        public override void OnClick()
        {
            base.OnClick();
            CurvySplineSegment cp = DTSelection.GetAs<CurvySplineSegment>(false);
            if (cp && cp.Spline)
                DTSelection.SetGameObjects(cp.Spline.ControlPointsList[(int)Mathf.Repeat(cp.Spline.GetControlPointIndex(cp) + 1, cp.Spline.ControlPointCount)]);
            else
            {
                CurvySpline spl = DTSelection.GetAs<CurvySpline>();
                if (spl && spl.ControlPointCount > 0)
                    DTSelection.SetGameObjects(spl.ControlPointsList[0]);
            }

        }

        public override void OnSelectionChange()
        {
            Visible = DTSelection.HasComponent<CurvySplineSegment>() || DTSelection.HasComponent<CurvySpline>();
        }
    }

    [ToolbarItem(120, "Curvy", "Next connected", "Toggle between connected CP", "nextcon,24,24")]
    public class TBCPNextConnected : DTToolbarButton
    {
        public override string StatusBarInfo { get { return "Select next Control Point being part of this connection"; } }

        public TBCPNextConnected()
        {
            KeyBindings.Add(new EditorKeyBinding("Toggle Connection", "", KeyCode.C));
        }

        public override void OnClick()
        {
            base.OnClick();
            CurvySplineSegment cp = DTSelection.GetAs<CurvySplineSegment>();
            if (cp)
            {
                int idx = (int)Mathf.Repeat(cp.Connection.ControlPointsList.IndexOf(cp) + 1, cp.Connection.ControlPointsList.Count);
                DTSelection.SetGameObjects(cp.Connection.ControlPointsList[idx]);
            }

        }

        public override void OnSelectionChange()
        {
            CurvySplineSegment cp = DTSelection.GetAs<CurvySplineSegment>();
            Visible = (cp != null && cp.Connection != null && cp.Connection.ControlPointsList.Count > 1);
        }


    }

    [ToolbarItem(140, "Curvy", "Sync Direction", "Synchronise direction of Bezier handles", "beziersyncdir,24,24")]
    public class TBCPBezierModeDirection : DTToolbarToggleButton
    {
        public override string StatusBarInfo { get { return "Mirror Bezier Handles Direction"; } }

        public TBCPBezierModeDirection()
        {
            KeyBindings.Add(new EditorKeyBinding("Bezier: Sync Dir", "Sync Handles Direction", KeyCode.B));
        }

        public override bool On
        {
            get
            {
                return ((CurvyProject)Project).BezierMode.HasFlag(CurvyBezierModeEnum.Direction);
            }
            set
            {
                ((CurvyProject)Project).BezierMode = ((CurvyProject)Project).BezierMode.Set(CurvyBezierModeEnum.Direction, value);
            }
        }


        public override void OnOtherItemClicked(DTToolbarItem other) { } // IMPORTANT!


        public override void OnSelectionChange()
        {
            base.OnSelectionChange();
            CurvySplineSegment cp = DTSelection.GetAs<CurvySplineSegment>();
            Visible = (cp && cp.Spline && cp.Spline.Interpolation == CurvyInterpolation.Bezier);
        }
    }

    [ToolbarItem(141, "Curvy", "Sync Length", "Synchronise length of Bezier handles", "beziersynclen,24,24")]
    public class TBCPBezierModeLength : DTToolbarToggleButton
    {
        public override string StatusBarInfo { get { return "Mirror Bezier Handles Size"; } }

        public TBCPBezierModeLength()
        {
            KeyBindings.Add(new EditorKeyBinding("Bezier: Sync Len", "Sync Handles Length", KeyCode.N));
        }

        public override bool On
        {
            get
            {
                return ((CurvyProject)Project).BezierMode.HasFlag(CurvyBezierModeEnum.Length);
            }
            set
            {
                ((CurvyProject)Project).BezierMode = ((CurvyProject)Project).BezierMode.Set(CurvyBezierModeEnum.Length, value);
            }
        }

        public override void OnOtherItemClicked(DTToolbarItem other) { } // IMPORTANT!

        public override void OnSelectionChange()
        {
            base.OnSelectionChange();
            CurvySplineSegment cp = DTSelection.GetAs<CurvySplineSegment>();
            Visible = (cp && cp.Spline && cp.Spline.Interpolation == CurvyInterpolation.Bezier);
        }
    }

    [ToolbarItem(142, "Curvy", "Sync Connection", "Synchronise Bezier handles in a Connection", "beziersynccon,24,24")]
    public class TBCPBezierModeConnections : DTToolbarToggleButton
    {
        public override string StatusBarInfo { get { return "Apply 'Sync Handles Length' and 'Sync Handles Direction' on connected Control Points as well"; } }

        public TBCPBezierModeConnections()
        {
            KeyBindings.Add(new EditorKeyBinding("Bezier: Sync Con", "Sync connected CP' handles", KeyCode.M));
        }

        public override bool On
        {
            get
            {
                return ((CurvyProject)Project).BezierMode.HasFlag(CurvyBezierModeEnum.Connections);
            }
            set
            {
                ((CurvyProject)Project).BezierMode = ((CurvyProject)Project).BezierMode.Set(CurvyBezierModeEnum.Connections, value);
            }
        }

        public override void OnOtherItemClicked(DTToolbarItem other) { } // IMPORTANT!

        public override void OnSelectionChange()
        {
            base.OnSelectionChange();
            CurvySplineSegment cp = DTSelection.GetAs<CurvySplineSegment>();
            Visible = (cp && cp.Spline && cp.Spline.Interpolation == CurvyInterpolation.Bezier);
        }
    }

    [ToolbarItem(160, "Curvy", "Shift", "Shift on curve", "shiftcp,24,24")]
    public class TBCPShift : DTToolbarToggleButton
    {
        CurvySplineSegment selCP;

        float mMin;
        float mMax;
        float mShift;

        public override string StatusBarInfo
        {
            get
            {
                return "Shifts the Control Point toward the previous or next Control Point";
            }
        }

        Vector3 getLocalPos()
        {
            CurvySpline curvySpline = selCP.Spline;
            Vector3 result;
            if (mShift >= 0)
            {
                if (curvySpline.IsControlPointASegment(selCP))
                    result = selCP.Interpolate(mShift);
                else
                {
                    CurvySplineSegment previousSegment = curvySpline.GetPreviousSegment(selCP);
                    result = previousSegment ? previousSegment.Interpolate(1) : selCP.transform.localPosition;
                }
            }
            else
            {
                CurvySplineSegment previousSegment = curvySpline.GetPreviousSegment(selCP);
                result = previousSegment ? previousSegment.Interpolate(1 + mShift) : selCP.transform.localPosition;
            }

            return result;
        }

        public override void OnSceneGUI()
        {
            if (On && selCP && selCP.Spline)
            {
                Vector3 pos = selCP.Spline.transform.TransformPoint(getLocalPos());
                DTHandles.PushHandlesColor(CurvyGlobalManager.DefaultGizmoSelectionColor);
#if UNITY_5_6_OR_NEWER
                Handles.SphereHandleCap(0, pos, Quaternion.identity, HandleUtility.GetHandleSize(pos) * CurvyGlobalManager.GizmoControlPointSize, EventType.Repaint);
#else
                Handles.SphereCap(0, pos, Quaternion.identity, HandleUtility.GetHandleSize(pos)*CurvyGlobalManager.GizmoControlPointSize);
#endif
                DTHandles.PopHandlesColor();
            }
        }

        public override void RenderClientArea(Rect r)
        {
            base.RenderClientArea(r);

            Background(r, 80, 32);
            SetElementSize(ref r, 80, 32);


            //Slider
            r.y += 8;
            mShift = GUI.HorizontalSlider(r, mShift, mMin, mMax);

            //Ok button
            Advance(ref r);
            r.width = 32;
            r.y -= 8;
            if (GUI.Button(r, "Ok"))
            {
                Undo.RecordObject(selCP.transform, "Shift Control Point");
                selCP.SetLocalPosition(getLocalPos());
                mShift = 0;
                On = false;
            }
        }



        public override void OnSelectionChange()
        {
            base.OnSelectionChange();
            selCP = DTSelection.GetAs<CurvySplineSegment>(false);
            Visible = selCP != null && selCP.Spline && selCP.Spline.IsControlPointVisible(selCP);
            if (Visible)
            {
                CurvySpline curvySpline = selCP.Spline;
                mMin = curvySpline.GetPreviousSegment(selCP) ? -0.9f : 0;
                mMax = curvySpline.IsControlPointASegment(selCP) ? 0.9f : 0;
                mShift = 0;
            }
        }
    }

    [ToolbarItem(161, "Curvy", "Set 1.", "Set as first Control Point", "setfirstcp,24,24")]
    public class TBCPSetFirst : DTToolbarButton
    {
        public override string StatusBarInfo { get { return "Make this Control Point the first of the spline"; } }

        public TBCPSetFirst()
        {
            KeyBindings.Add(new EditorKeyBinding("Set 1. CP", ""));
        }

        public override void OnClick()
        {
            base.OnClick();
            CurvySplineSegment cp = DTSelection.GetAs<CurvySplineSegment>();
            if (cp && cp.Spline)
            {
                Undo.RegisterFullObjectHierarchyUndo(cp.Spline, "Set first CP");
                cp.Spline.SetFirstControlPoint(cp);
            }
        }

        public override void OnSelectionChange()
        {
            base.OnSelectionChange();
            CurvySplineSegment cp = DTSelection.GetAs<CurvySplineSegment>();
            Visible = (cp != null);
            Enabled = Visible && cp.Spline && cp.Spline.GetControlPointIndex(cp) > 0;
        }
    }

    [ToolbarItem(162, "Curvy", "Join", "Join Splines", "join,24,24")]
    public class TBCPJoin : DTToolbarButton
    {
        public override string StatusBarInfo
        {
            get
            {
                return mInfo;
            }
        }

        string mInfo;

        public TBCPJoin()
        {
            KeyBindings.Add(new EditorKeyBinding("Join Spline", "Join two splines"));
        }


        public override void OnClick()
        {
            base.OnClick();
            CurvySpline source = DTSelection.GetAs<CurvySpline>();
            CurvySplineSegment destCP = DTSelection.GetAs<CurvySplineSegment>();
            int selIdx = destCP.Spline.GetControlPointIndex(destCP) + source.ControlPointCount + 1;
            source.JoinWith(destCP);
            DTSelection.SetGameObjects(destCP.Spline.ControlPointsList[Mathf.Min(destCP.Spline.ControlPointCount - 1, selIdx)]);
        }

        public override void OnSelectionChange()
        {
            CurvySpline source = DTSelection.GetAs<CurvySpline>();
            CurvySplineSegment destCP = DTSelection.GetAs<CurvySplineSegment>();
            Visible = source && destCP && destCP.Spline && source != destCP.Spline;
            mInfo = (Visible) ? string.Format("Insert all Control Points of <b>{0}</b> after <b>{1}</b>", source.name, destCP.ToString()) : "";
        }


    }

    [ToolbarItem(163, "Curvy", "Split", "Split spline at selection", "split,24,24")]
    public class TBCPSplit : DTToolbarButton
    {
        public override string StatusBarInfo { get { return "Split current Spline and make this Control Point the first of a new spline"; } }

        public TBCPSplit()
        {
            KeyBindings.Add(new EditorKeyBinding("Split Spline", "Split spline at selection"));
        }

        public override void OnClick()
        {
            base.OnClick();
            CurvySplineSegment cp = DTSelection.GetAs<CurvySplineSegment>();
            DTSelection.SetGameObjects(cp.Spline.Split(cp));
        }

        public override void OnSelectionChange()
        {
            CurvySplineSegment cp = DTSelection.GetAs<CurvySplineSegment>();
            Visible = cp && cp.Spline && cp.Spline.IsControlPointASegment(cp) && (cp.Spline.FirstSegment != cp);
        }
    }

    [ToolbarItem(165, "Curvy", "Connect", "Create a connection", "connectionpos_dark,24,24", "connectionpos_light,24,24")]
    public class TBCPConnect : DTToolbarButton
    {
        public override string StatusBarInfo { get { return "Add a connection"; } }

        public TBCPConnect()
        {
            KeyBindings.Add(new EditorKeyBinding("Connect", "Create connection"));
        }

        public override void OnClick()
        {
            List<CurvySplineSegment> selected = DTSelection.GetAllAs<CurvySplineSegment>();
            CurvySplineSegment[] unconnected = (from cp in selected
                                                where !cp.Connection
                                                select cp).ToArray();

            if (unconnected.Length > 0)
            {
                CurvyConnection con = (from cp in selected
                                       where cp.Connection != null
                                       select cp.Connection).FirstOrDefault();

                if (con == null)
                {
                    con = CurvyConnection.Create(unconnected); // Undo inside
                    //con.AddControlPoints(unconnected); // Undo inside
                    //con.AutoSetFollowUp();
                }
                else
                    con.AddControlPoints(unconnected); // Undo inside
            }
            /*
            if (unconnected.Length == 2)
            {
                var source = unconnected[1];
                var dest = unconnected[0];
                source.ConnectTo(dest, (source.transform.position == dest.transform.position), false);
            }
            else
            {
                if (con == null)
                {
                    con = CurvyConnection.Create(); // Undo inside
                }
                con.AddControlPoints(unconnected); // Undo inside
            }
            */
            foreach (CurvySplineSegment cp in unconnected)
                EditorUtility.SetDirty(cp);

            CurvyProject.Instance.ScanConnections();

            //EditorApplication.RepaintHierarchyWindow();
        }

        public override void OnSelectionChange()
        {
            List<CurvySplineSegment> selected = DTSelection.GetAllAs<CurvySplineSegment>();
            List<CurvySplineSegment> unconnected = (from cp in selected
                                                    where !cp.Connection
                                                    select cp).ToList();

            Visible = (unconnected.Count > 0);
            /*
                      (unconnected.Count==1 ||
                      unconnected.Count>2 ||
                      (selected.Count == 2 && selected[0].CanConnectTo(selected[1])));
              */
        }
    }
    /*
    [ToolbarItem(180, "Curvy", "Limit Len", "Constraint max. Spline length", "constraintlength,24,24")]
    public class TBCPLengthConstraint : DTToolbarToggleButton
    {
        public float MaxSplineLength;
        CurvySpline Spline;

        public TBCPLengthConstraint()
        {
            KeyBindings.Add(new EditorKeyBinding("Constraint Length", "Spline: Constraint Length"));
        }
        Vector3[] storedPosPrev = new Vector3[0];
        Vector3[] storedPos = new Vector3[0];


        void StorePos()
        {
            storedPosPrev = storedPos;
            storedPos = new Vector3[Selection.transforms.Length];
            for (int i = 0; i < storedPos.Length; i++)
                storedPos[i] = Selection.transforms[i].position;
        }
        void RestorePos()
        {
            Debug.Log("Restore");
            for (int i = 0; i < storedPosPrev.Length; i++)
                Selection.transforms[i].position = storedPosPrev[i];
        }

        public override void RenderClientArea(Rect r)
        {
            base.RenderClientArea(r);
            SetElementSize(ref r, 84, 22);
            Background(r, 84, 22);
            r.width = 60;
            MaxSplineLength = EditorGUI.FloatField(r, MaxSplineLength);
            r.x += 62;
            r.width = 22;
            if (GUI.Button(r, "<"))
            {
                var cp = DTSelection.GetAs<CurvySplineSegment>();
                if (cp)
                    MaxSplineLength = cp.Spline.Length;
            }
        }

        public override void OnSelectionChange()
        {
            var cp = DTSelection.GetAs<CurvySplineSegment>();
            Visible = cp != null;
            Spline = (cp) ? cp.Spline : null;
        }

        public override void OnSceneGUI()
        {
            base.OnSceneGUI();

            if (On && Spline)
            {
                if (Spline.Length > MaxSplineLength)
                {
                    RestorePos();
                    Spline.SetDirtyAll();
                    Spline.Refresh();
                }
                else
                    StorePos();
            }

        }
    }
    */
    [ToolbarItem(190, "Curvy", "Camera Project", "Project camera", "camproject,24,24")]
    public class TBCPCameraProject : DTToolbarToggleButton
    {
        public override string StatusBarInfo { get { return "Raycast and move Control Points"; } }

        List<CurvySplineSegment> mCPSelection;

        public TBCPCameraProject()
        {
        }

        public override void RenderClientArea(Rect r)
        {
            base.RenderClientArea(r);
            SetElementSize(ref r, 32, 32);

            if (GUI.Button(r, "OK"))
            {
                foreach (CurvySplineSegment cp in mCPSelection)
                {
                    RaycastHit hit;
                    if (Physics.Raycast(new Ray(cp.transform.position, SceneView.currentDrawingSceneView.camera.transform.forward), out hit))
                    {
                        Undo.RecordObject(cp.transform, "Project Control Points");
                        cp.transform.position = hit.point;
                    }
                }

                On = false;
            }
        }

        public override void OnSceneGUI()
        {
            base.OnSceneGUI();
            if (On && SceneView.currentDrawingSceneView != null)
            {
                DTHandles.PushHandlesColor(Color.red);
                foreach (CurvySplineSegment cp in mCPSelection)
                {
                    RaycastHit hit;
                    if (Physics.Raycast(new Ray(cp.transform.position, SceneView.currentDrawingSceneView.camera.transform.forward), out hit))
                    {
                        Handles.DrawDottedLine(cp.transform.position, hit.point, 2);
#if UNITY_5_6_OR_NEWER
                        Handles.SphereHandleCap(0, hit.point, Quaternion.identity, HandleUtility.GetHandleSize(hit.point) * 0.1f, EventType.Repaint);
#else
                        Handles.SphereCap(0, hit.point, Quaternion.identity, HandleUtility.GetHandleSize(hit.point)*0.1f);
#endif
                    }
                }
                DTHandles.PopHandlesColor();
            }
        }

        public override void OnSelectionChange()
        {
            mCPSelection = DTSelection.GetAllAs<CurvySplineSegment>();
            Visible = mCPSelection.Count > 0;
            if (!Visible)
                On = false;
        }

        public override void HandleEvents(Event e)
        {
            base.HandleEvents(e);
            if (On)
                _StatusBar.Set("Click <b>OK</b> to apply the preview changes", "CameraProject");
            else
                _StatusBar.Clear("CameraProject");
        }
    }

    [ToolbarItem(200, "Curvy", "CPTools", "Control Point Tools", "tools,24,24")]
    public class TBCPTools : DTToolbarToggleButton
    {
        public override string StatusBarInfo { get { return "Open Control Point Tools menu"; } }

        public class SplineRange
        {
            public CurvySpline Spline;
            public CurvySplineSegment Low;
            public CurvySplineSegment High;

            public bool CanSubdivide
            {
                get { return Low && High && (High.Spline.GetControlPointIndex(High) - Low.Spline.GetControlPointIndex(Low) > 0); }
            }

            public bool CanSimplify
            {
                get { return Low && High && (High.Spline.GetControlPointIndex(High) - Low.Spline.GetControlPointIndex(Low) > 1); }
            }

            public SplineRange(CurvySpline spline)
            {
                Spline = spline;
                Low = null;
                High = null;
            }

            public void AddCP(CurvySplineSegment cp)
            {
                if (Low == null || Low.Spline.GetControlPointIndex(Low) > cp.Spline.GetControlPointIndex(cp))
                    Low = cp;
                if (High == null || High.Spline.GetControlPointIndex(High) < cp.Spline.GetControlPointIndex(cp))
                    High = cp;
            }
        }

        List<CurvySplineSegment> mCPSelection;
        readonly Dictionary<CurvySpline, SplineRange> mSplineRanges = new Dictionary<CurvySpline, SplineRange>();

        public bool CanSubdivide
        {
            get
            {
                foreach (SplineRange sr in mSplineRanges.Values)
                    if (sr.CanSubdivide)
                        return true;
                return false;
            }
        }

        public bool CanSimplify
        {
            get
            {
                foreach (SplineRange sr in mSplineRanges.Values)
                    if (sr.CanSimplify)
                        return true;
                return false;
            }
        }



        public override void RenderClientArea(Rect r)
        {
            base.RenderClientArea(r);
            SetElementSize(ref r, 32, 32);
            GUI.enabled = CanSubdivide;
            if (GUI.Button(r, new GUIContent(CurvyStyles.IconSubdivide, "Subdivide")))
                Subdivide();
            Advance(ref r);

            GUI.enabled = CanSimplify;
            if (GUI.Button(r, new GUIContent(CurvyStyles.IconSimplify, "Simplify")))
                Simplify();
            Advance(ref r);
            if (GUI.Button(r, new GUIContent(CurvyStyles.IconEqualize, "Equalize")))
                Equalize();
            GUI.enabled = true;
        }

        public override void OnSelectionChange()
        {
            mCPSelection = DTSelection.GetAllAs<CurvySplineSegment>().Where(cp => cp.Spline != null).ToList();
            getRange();
            Visible = mCPSelection.Count > 1;
            if (!Visible)
                On = false;
        }

        void Subdivide()
        {
            foreach (SplineRange sr in mSplineRanges.Values)
                if (sr.CanSubdivide)
                    sr.Spline.Subdivide(sr.Low, sr.High);
        }

        void Simplify()
        {
            foreach (SplineRange sr in mSplineRanges.Values)
                if (sr.CanSimplify)
                    sr.Spline.Simplify(sr.Low, sr.High);
        }

        void Equalize()
        {
            foreach (SplineRange sr in mSplineRanges.Values)
                if (sr.CanSimplify)
                    sr.Spline.Equalize(sr.Low, sr.High);
        }

        void getRange()
        {
            mSplineRanges.Clear();
            foreach (CurvySplineSegment cp in mCPSelection)
            {
                SplineRange sr;
                if (!mSplineRanges.TryGetValue(cp.Spline, out sr))
                {
                    sr = new SplineRange(cp.Spline);
                    mSplineRanges.Add(cp.Spline, sr);
                }

                sr.AddCP(cp);
            }
        }
    }

    [ToolbarItem(120, "Curvy", "Set Pivot", "", "centerpivot,24,24")]
    public class TBSplineSetPivot : DTToolbarToggleButton
    {
        public override string StatusBarInfo { get { return "Set center/pivot point"; } }

        float pivotX;
        float pivotY;
        float pivotZ;

        public override void OnSelectionChange()
        {
            Visible = DTSelection.HasComponent<CurvySpline>(true);
        }

        public override void RenderClientArea(Rect r)
        {
            base.RenderClientArea(r);

            Background(r, 182, 187);
            SetElementSize(ref r, 180, 185);

            EditorGUIUtility.labelWidth = 20;
            GUILayout.BeginArea(new Rect(r));

            GUILayout.Label("X/Y", EditorStyles.boldLabel);
            for (int y = -1; y <= 1; y++)
            {
                GUILayout.BeginHorizontal();
                for (int x = -1; x <= 1; x++)
                {
                    DTGUI.PushBackgroundColor((x == pivotX && y == pivotY) ? Color.red : GUI.backgroundColor);
                    if (GUILayout.Button("", GUILayout.Width(20)))
                    {
                        pivotX = x;
                        pivotY = y;
                    }

                    DTGUI.PopBackgroundColor();
                }

                if (y == -1)
                {
                    GUILayout.Space(20);
                    pivotX = EditorGUILayout.FloatField("X", pivotX);
                }
                else if (y == 0)
                {
                    GUILayout.Space(20);
                    pivotY = EditorGUILayout.FloatField("Y", pivotY);
                }

                GUILayout.EndVertical();
            }

            GUILayout.Label("Z/Y", EditorStyles.boldLabel);
            for (int y = -1; y <= 1; y++)
            {
                GUILayout.BeginHorizontal();
                for (int z = -1; z <= 1; z++)
                {
                    DTGUI.PushBackgroundColor((y == pivotY && z == pivotZ) ? Color.red : GUI.backgroundColor);
                    if (GUILayout.Button("", GUILayout.Width(20)))
                    {
                        pivotY = y;
                        pivotZ = z;
                    }

                    DTGUI.PopBackgroundColor();
                }

                if (y == -1)
                {
                    GUILayout.Space(20);
                    pivotZ = EditorGUILayout.FloatField("Z", pivotZ);
                }
                else if (y == 0)
                {
                    GUILayout.Space(20);
                    pivotY = EditorGUILayout.FloatField("Y", pivotY);
                }

                GUILayout.EndVertical();
            }

            if (GUILayout.Button("Apply"))
            {
                SetPivot();
                On = false;
            }
            GUILayout.EndArea();
        }

        public override void OnSceneGUI()
        {
            if (On)
            {
                List<CurvySpline> splines = DTSelection.GetAllAs<CurvySpline>();
                foreach (CurvySpline spl in splines)
                {

                    Vector3 p = spl.SetPivot(pivotX, pivotY, pivotZ, true);
                    DTHandles.PushHandlesColor(new Color(0.3f, 0, 0));
                    DTHandles.BoundsCap(spl.Bounds);
                    Handles.SphereHandleCap(0, p, Quaternion.identity, HandleUtility.GetHandleSize(p) * .1f, EventType.Repaint);
                    DTHandles.PopHandlesColor();
                }
            }
        }



        void SetPivot()
        {
            List<CurvySpline> splines = DTSelection.GetAllAs<CurvySpline>();
            foreach (CurvySpline spl in splines)
                spl.SetPivot(pivotX, pivotY, pivotZ);
        }

    }

    [ToolbarItem(122, "Curvy", "Flip", "Flip spline direction", "flip,24,24")]
    public class TBSplineFlip : DTToolbarButton
    {
        public override string StatusBarInfo { get { return "Invert all Control Points, making the spline direction flip"; } }

        public TBSplineFlip()
        {
            KeyBindings.Add(new EditorKeyBinding("Flip", "Flip spline direction"));
        }

        public override void OnClick()
        {
            List<CurvySpline> splines = DTSelection.GetAllAs<CurvySpline>();
            foreach (CurvySpline spline in splines)
            {
                spline.Flip();
            }
        }

        public override void OnSelectionChange()
        {
            Visible = DTSelection.HasComponent<CurvySpline>(true);
        }
    }

    [ToolbarItem(124, "Curvy", "Normalize", "Normalize scale", "normalize,24,24")]
    public class TBSplineNormalize : DTToolbarButton
    {
        public override string StatusBarInfo { get { return "Apply transform scale to Control Points and reset scale to 1"; } }

        public TBSplineNormalize()
        {
            KeyBindings.Add(new EditorKeyBinding("Normalize", "Normalize spline"));
        }

        public override void OnClick()
        {
            List<CurvySpline> splines = DTSelection.GetAllAs<CurvySpline>();
            foreach (CurvySpline spline in splines)
            {
                spline.Normalize();
            }
        }

        public override void OnSelectionChange()
        {
            Visible = DTSelection.HasComponent<CurvySpline>(true);
        }
    }

    [ToolbarItem(124, "Curvy", "Shape", "Apply a shape", "shapewizard,24,24")]
    public class TBSplineSetShape : DTToolbarToggleButton
    {
        public override string StatusBarInfo { get { return "Apply a shape. <b><color=#ff0000>WARNING: THIS CAN'T BE UNDONE!</color></b>"; } }

        Vector2 scroll;
        readonly float winHeight = 120;

        public override void RenderClientArea(Rect r)
        {
            base.RenderClientArea(r);
            CurvySpline spline;
            CurvyShape shape = DTSelection.GetAs<CurvyShape>();
            if (shape == null && (spline = DTSelection.GetAs<CurvySpline>()))
            {
                shape = spline.gameObject.AddComponent<CSCircle>();
                shape.Dirty = true;
                shape.Refresh();
            }

            if (shape != null)
            {
                CurvyShapeEditor ShapeEditor = Editor.CreateEditor(shape, typeof(CurvyShapeEditor)) as CurvyShapeEditor;
                if (ShapeEditor != null)
                {
                    FocusedItem = this;
                    ShapeEditor.ShowOnly2DShapes = false;
                    ShapeEditor.ShowPersistent = true;

                    Background(r, 300, winHeight);
                    SetElementSize(ref r, 300, winHeight);

                    GUILayout.BeginArea(r);
                    scroll = GUILayout.BeginScrollView(scroll, GUILayout.Height(winHeight - 25));

                    ShapeEditor.OnEmbeddedGUI();

                    GUILayout.EndScrollView();
                    GUILayout.EndArea();

                    r.y += winHeight - 20;
                    r.height = 20;

                    if (GUI.Button(r, "Close"))
                    {
                        On = false;
                    }

                    Editor.DestroyImmediate(ShapeEditor);
                }
            }
        }

        public override void OnSelectionChange()
        {
            Visible = DTSelection.HasComponent<CurvySpline>();
            scroll = Vector2.zero;
        }
    }

    [ToolbarItem(200, "Curvy", "Tools", "Spline Tools", "tools,24,24")]
    public class TBSplineTools : DTToolbarToggleButton
    {

        public override string StatusBarInfo { get { return "Open Spline Tools menu"; } }


        public override void RenderClientArea(Rect r)
        {
            base.RenderClientArea(r);
            SetElementSize(ref r, 32, 32);
            if (GUI.Button(r, new GUIContent(CurvyStyles.IconMeshExport, "Spline to Mesh")))
            {
                CurvySplineExportWizard.Create();
                On = false;
            }
            Advance(ref r);
            if (GUI.Button(r, new GUIContent(CurvyStyles.IconSyncFromHierarchy, "Sync from Hierarchy")))
            {
                List<CurvySpline> sel = DTSelection.GetAllAs<CurvySpline>();
                foreach (CurvySpline spl in sel)
                {
                    spl.SyncSplineFromHierarchy();
                    spl.ApplyControlPointsNames();
                    spl.Refresh();
                    On = false;
                }
            }
            Advance(ref r);
            if (GUI.Button(r, new GUIContent(CurvyStyles.IconSelectContainingConnections, "Select connections connecting only CPs within the selected spline(s)")))
            {
                List<CurvySpline> sel = DTSelection.GetAllAs<CurvySpline>();
                DTSelection.SetGameObjects(CurvyGlobalManager.Instance.GetContainingConnections(sel.ToArray()));
            }
        }

        public override void OnSelectionChange()
        {
            Visible = DTSelection.HasComponent<CurvySpline>(true);
        }
    }

    [ToolbarItem(190, "Curvy", "Edit", "Open CG Editor", "opengraph_dark,24,24", "opengraph_light,24,24")]
    public class TBPCGOpenGraph : DTToolbarButton
    {
        public override string StatusBarInfo { get { return "Open Curvy Generator Editor"; } }

        public override void OnClick()
        {
            base.OnClick();
            CurvyGenerator pcg = DTSelection.GetAs<CurvyGenerator>();
            if (pcg)
                FluffyUnderware.CurvyEditor.Generator.CGGraph.Open(pcg);

        }

        public override void OnSelectionChange()
        {
            Visible = DTSelection.HasComponent<CurvyGenerator>();
        }
    }



}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyToolbar.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyUISplineEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 5644cbd38589c924bbec85a9b6e94296
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.CurvyEditor
{
    [CustomEditor(typeof(CurvyUISpline)), CanEditMultipleObjects]
    public class CurvyUISplineEditor : CurvySplineEditor { }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyUISplineEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/GLCurvyRendererEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 87651198517c52f488f2ce77fa2a87cc
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.Curvy.Components;
using UnityEditor;
using FluffyUnderware.Curvy;
using UnityEditorInternal;
using System.Collections.Generic;

namespace FluffyUnderware.CurvyEditor.Components
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(CurvyGLRenderer))]
    public class GLCurvyRendererEditor : DTEditor<CurvyGLRenderer>
    {
        bool ShowWarning;

        protected override void OnEnable()
        {
            base.OnEnable();
            ShowWarning = Target.GetComponent<Camera>() == null;
        }

        protected override void SetupArrayEx(DTFieldNode node, DevTools.ArrayExAttribute attribute)
        {
            node.ArrayEx.elementHeight = 23;
            node.ArrayEx.drawElementCallback = drawSlot;
        }


        void drawSlot(Rect rect, int index, bool isActive, bool isFocused)
        {
            GLSlotData slot = Target.Splines[index];
            Rect r = new Rect(rect);
            r.height = 19;
            r.width = rect.width - 60;
            r.y += 2;
            slot.Spline = EditorGUI.ObjectField(r, slot.Spline, typeof(CurvySpline), true) as CurvySpline;
            r.x += r.width + 2;
            r.width = 50;
            slot.LineColor = EditorGUI.ColorField(r, slot.LineColor);

            // Separator
            if (index > 0)
            {
                DTHandles.PushHandlesColor(new Color(0.1f, 0.1f, 0.1f));
                Handles.DrawLine(new Vector2(rect.xMin - 5, rect.yMin), new Vector2(rect.xMax + 4, rect.yMin));
                DTHandles.PopHandlesColor();
            }
        }

        List<CurvySpline> getDragAndDropSplines()
        {
            List<CurvySpline> res = new List<CurvySpline>();
            if (DragAndDrop.objectReferences.Length > 0)
            {
                foreach (Object o in DragAndDrop.objectReferences)
                {
                    if (o is GameObject)
                    {
                        CurvySpline spl = ((GameObject)o).GetComponent<CurvySpline>();
                        if (spl)
                            res.Add(spl);
                    }
                }
            }
            return res;
        }

        public override void OnInspectorGUI()
        {
            if (ShowWarning)
            {
                EditorGUILayout.HelpBox("This component needs a GameObject with a camera component present!", MessageType.Error);
                return;
            }
            GUILayout.Box(new GUIContent("Drag & Drop Splines here!"), EditorStyles.miniButton, GUILayout.Height(32));
            Rect r = GUILayoutUtility.GetLastRect();

            base.OnInspectorGUI();

            Event ev = Event.current;
            switch (ev.type)
            {
                case EventType.DragUpdated:
                    if (r.Contains(ev.mousePosition))
                    {
                        DragAndDrop.visualMode = (getDragAndDropSplines().Count > 0) ? DragAndDropVisualMode.Copy : DragAndDropVisualMode.Rejected;
                    }
                    break;
                case EventType.DragPerform:
                    List<CurvySpline> splinesToAdd = getDragAndDropSplines();
                    Undo.RecordObject(Target, "Add Spline to list");
                    foreach (CurvySpline spl in splinesToAdd)
                        Target.Splines.Add(new GLSlotData() { Spline = spl });
                    break;
            }
        }

    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/GLCurvyRendererEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Network/AnnouncementsFetcher.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: ea4054ab90f68be449240e4ee9a0b03e
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

//#define CURVY_SHOW_ALL_ANNOUNCEMENTS

using System;
using System.Linq;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using UnityEngine;
using UnityEditor;
using UnityEngine.Networking;

namespace FluffyUnderware.CurvyEditor.Network
{
    /// <summary>
    /// Fetches announcements from server and display them if not previously displayed
    /// </summary>
    [InitializeOnLoad]
    class AnnouncementsFetcher
    {
        [Serializable]
        class Announcement
        {
#pragma warning disable 0649
            public string Id;
            public string Title;
            public string Content;
#pragma warning restore 0649
        }

        private UnityWebRequest WebRequest { get; set; }

        static AnnouncementsFetcher()
        {
            if (CurvyProject.Instance.EnableAnnouncements == false)
                return;

            const string preferenceName = "LastFetchedAnnouncementDate";
            int lastFetchedAnnouncementDate = CurvyProject.Instance.GetEditorPrefs(preferenceName, 17522856);// is the number of hours in the DateTime equivalent to the 1th of January 2000
            int utcNowHours = (int)(DateTime.UtcNow.Ticks / (10000L * 1000L * 3600L));
            int deltaHours = utcNowHours - lastFetchedAnnouncementDate;
#if CURVY_SHOW_ALL_ANNOUNCEMENTS == false
            if (deltaHours > 24)
#endif
            {
                new AnnouncementsFetcher().Fetch();
                CurvyProject.Instance.SetEditorPrefs(preferenceName, utcNowHours);
            }
#if CURVY_DEBUG
        else
            Debug.Log("Ignored news fetching: " + deltaHours);
#endif
        }

        private void Fetch()
        {
            string url = "https://announcements.curvyeditor.com/?version=" + CurvySpline.VERSION;

#if CURVY_DEBUG
        Debug.Log(url);
#endif

            WebRequest = UnityWebRequest.Get(url);
            WebRequest.SendWebRequest();
            EditorApplication.update += CheckWebRequest;
        }

        void CheckWebRequest()
        {
            if (WebRequest.isDone)
            {
                EditorApplication.update -= CheckWebRequest;
#if UNITY_2020_2_OR_NEWER
                if (WebRequest.result != UnityWebRequest.Result.ConnectionError
                    && WebRequest.result != UnityWebRequest.Result.ProtocolError)
#elif UNITY_2017_1_OR_NEWER
                if (WebRequest.isNetworkError == false 
                    && WebRequest.isHttpError == false)
#else
                if (WebRequest.isError == false)
#endif
                {
                    string downloadHandlerText = WebRequest.downloadHandler.text;
                    WebRequest.Dispose();
#if CURVY_DEBUG
                Debug.Log("Received: " + downloadHandlerText);
#endif
                    if (String.IsNullOrEmpty(downloadHandlerText) == false)
                        ProcessAnnouncements(downloadHandlerText);
                }
                else
                {
                    WebRequest.Dispose();
#if CURVY_DEBUG
                Debug.LogError("Error: " + WebRequest.error);
#endif
                }
            }
        }

        private static void ProcessAnnouncements(string responseText)
        {
            const string preferenceName = "ProcessedAnnouncements";
            try
            {
                SerializableArray<Announcement> announcements = JsonUtility.FromJson<SerializableArray<Announcement>>(responseText);
                string[] shownAnnouncements = CurvyProject.Instance.GetEditorPrefs(preferenceName);
                var reversedAnnouncements = announcements.Array.Reverse();//Reversed so that the first announcement's window is shown first
                int newsIndex = 0;
                foreach (Announcement announcement in reversedAnnouncements)
                {
#if CURVY_SHOW_ALL_ANNOUNCEMENTS == false
                    if (shownAnnouncements.Contains(announcement.Id) == false)
#endif
                    {
                        AnnouncementWindow.Open(announcement.Title, announcement.Content, new Vector2(newsIndex * 20, newsIndex * 20));
                        DTLog.Log(String.Format("[Curvy] Announcement: {0}: {1}", announcement.Title, announcement.Content));
                        newsIndex++;
                        CurvyProject.Instance.SetEditorPrefs(preferenceName, shownAnnouncements.Add(announcement.Id));
                    }
#if CURVY_DEBUG
                else
                    Debug.Log("Already shown announcement " + announcement.Id);

#endif
                }
            }

#if CURVY_DEBUG
        catch (ArgumentException e)// exception can be thrown by JsonUtility.FromJson
        {
            Debug.LogException(e);
        }
#else
            catch (ArgumentException)// exception can be thrown by JsonUtility.FromJson
            {
            }
#endif

        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Network/AnnouncementsFetcher.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Network/AnnouncementWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e3a7d0835f56139489a740ad8d5d5cb4
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;

namespace FluffyUnderware.CurvyEditor.Network
{
    /// <summary>
    /// Window used to display announcements sent by Curvy's announcements' server
    /// </summary>
    public class AnnouncementWindow : EditorWindow
    {
        private string content;
        private Vector2 scrollViewPosition = new Vector2(0, 0);

        /// <summary>
        /// Opens an announcement window
        /// </summary>
        public static AnnouncementWindow Open(string title, string content, Vector2 positionShift)
        {
            AnnouncementWindow window = CreateWindow<AnnouncementWindow>(title);
            window.content = content;

            Rect announcementWindowPosition;
            {
                announcementWindowPosition = window.position;
                announcementWindowPosition.x = 100;
                announcementWindowPosition.y = 50;
                announcementWindowPosition.width = 650;
                announcementWindowPosition.height = 280f;
                announcementWindowPosition.x += positionShift.x;
                announcementWindowPosition.y += positionShift.y;
            }
            window.position = announcementWindowPosition;

            window.minSize = new Vector2(announcementWindowPosition.width, announcementWindowPosition.height);

            return window;
        }

        void OnGUI()
        {
            GUIStyle labelStyle = new GUIStyle(EditorStyles.label);
            labelStyle.alignment = TextAnchor.UpperLeft;
            labelStyle.fontSize = 22;
            labelStyle.richText = true;

            GUILayout.BeginVertical();

            GUILayout.Space(20);

            GUILayout.BeginHorizontal();
            GUILayout.FlexibleSpace();
            GUILayout.Label(new GUIContent(CurvyStyles.TexLogoSmall));
            GUILayout.FlexibleSpace();
            GUILayout.EndHorizontal();

            GUILayout.Space(20);

            GUILayout.BeginHorizontal();
            GUILayout.Space(20);
            GUILayout.FlexibleSpace();
            GUILayout.Label(titleContent.text, labelStyle);
            GUILayout.FlexibleSpace();
            GUILayout.Space(20);
            GUILayout.EndHorizontal();

            GUILayout.Space(30);

            labelStyle.wordWrap = true;
            labelStyle.fontSize = 14;

            scrollViewPosition = GUILayout.BeginScrollView(scrollViewPosition);
            GUILayout.BeginHorizontal();
            GUILayout.Space(20);
            GUILayout.FlexibleSpace();
            GUILayout.Label(content, labelStyle);
            float mainTextHeight = GUILayoutUtility.GetLastRect().height;
            GUILayout.FlexibleSpace();
            GUILayout.Space(20);
            GUILayout.EndHorizontal();
            GUILayout.EndScrollView();

            GUILayout.EndVertical();

            float recommendedHeight = 230f + mainTextHeight;
            if (recommendedHeight > position.height && Event.current.type == EventType.Repaint)
            {
                float limitedRecommendedHeight = Mathf.Min(recommendedHeight, 600f);
                position.Set(position.x, position.y, position.width, limitedRecommendedHeight);
                minSize = new Vector2(position.width, limitedRecommendedHeight);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Network/AnnouncementWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Network/Metrics.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: cf54dece49395bd4f98a89a96730ad1f
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Linq;
using FluffyUnderware.Curvy;
using FluffyUnderware.DevTools.Extensions;
using UnityEditor;
using UnityEngine;
using UnityEngine.Networking;

namespace FluffyUnderware.CurvyEditor.Network
{
    /// <summary>
    /// Sends metrics to Curvy's server about version usage of Curvy, Unity and Scripting
    /// </summary>
    [InitializeOnLoad]
    class Metrics
    {
        private UnityWebRequest WebRequest { get; set; }

        private static string CurvyVersion
        {
            get { return CurvySpline.VERSION; }
        }

        private static string UnityVersion
        {
            get { return Application.unityVersion; }
        }

        private static string ScriptingRuntimeVersion
        {
            get
            {
                return "Latest";
            }
        }

        static Metrics()
        {
            if (CurvyProject.Instance.EnableMetrics == false)
                return;

            const string preferenceName = "TrackedVersions";
            string[] trackedVersions = CurvyProject.Instance.GetEditorPrefs(preferenceName);
            string version_id = String.Format("{0}_{1}_{2}", CurvyVersion, UnityVersion, ScriptingRuntimeVersion);
            if (trackedVersions.Contains(version_id) == false)
            {
                new Metrics().Send(trackedVersions.Any() == false);
                CurvyProject.Instance.SetEditorPrefs(preferenceName, trackedVersions.Add(version_id));
            }
        }

        /// <summary>
        /// Sends metrics to Curvy's server about version usage of Curvy, Unity and Scripting
        /// </summary>
        void Send(bool isFirstTime)
        {
            string url = "https://analytics.curvyeditor.com/piwik.php?" +
                         "idsite=1" +
                         "&rec=1" +
                         "&apiv=1" +
                         "&rand=" + new System.Random().Next(0, 1000000).ToString("000000") +
                         "&dimension1=" + CurvyVersion +
                         "&dimension2=" + UnityVersion +
                         "&dimension3=" + ScriptingRuntimeVersion +
                         "&dimension4=" + isFirstTime +
                         "&_id=" + SystemInfo.deviceUniqueIdentifier.Substring(0, 16) +
                         "&action_name=Curvy_Splines";



#if CURVY_DEBUG
            Debug.Log(url);
#endif
            WebRequest = UnityWebRequest.Get(url);
            WebRequest.SendWebRequest();
            EditorApplication.update += CheckWebRequest;
        }

        void CheckWebRequest()
        {
            if (WebRequest.isDone)
            {
                EditorApplication.update -= CheckWebRequest;

#if CURVY_DEBUG
                if (WebRequest.isNetworkError || WebRequest.isHttpError)
                {
                    Debug.LogError("Error: " + WebRequest.error);
                }
                else
                {
                    Debug.Log("Received: " + WebRequest.downloadHandler.text);
                }
#endif

                WebRequest.Dispose();

            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Network/Metrics.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Pools/ArrayPoolsSettingsEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 51f1a803398f82843a5dc227536fbba7
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Pools;
using ToolBuddy.Pooling.Pools;
using UnityEditor;
using UnityEngine;

namespace FluffyUnderware.DevToolsEditor
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(ArrayPoolsSettings))]
    public class ArrayPoolsSettingsEditor : Editor
    {
        private ArrayPoolUsageData CGSpotUsageData;
        private ArrayPoolUsageData Int32UsageData;
        private ArrayPoolUsageData SingleUsageData;
        private ArrayPoolUsageData Vector2UsageData;
        private ArrayPoolUsageData Vector3UsageData;
        private ArrayPoolUsageData Vector4UsageData;


        private SerializedProperty vector2Capacity;
        private SerializedProperty vector3Capacity;
        private SerializedProperty vector4Capacity;
        private SerializedProperty intCapacity;
        private SerializedProperty floatCapacity;
        private SerializedProperty cgSpotCapacity;
        private SerializedProperty logAllocations;

        void OnEnable()
        {
            vector2Capacity = serializedObject.FindProperty("vector2Capacity");
            vector3Capacity = serializedObject.FindProperty("vector3Capacity");
            vector4Capacity = serializedObject.FindProperty("vector4Capacity");
            intCapacity = serializedObject.FindProperty("intCapacity");
            floatCapacity = serializedObject.FindProperty("floatCapacity");
            cgSpotCapacity = serializedObject.FindProperty("cgSpotCapacity");
            logAllocations = serializedObject.FindProperty("logAllocations");
        }


        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            //bool needRepaint = Vector2UsageData != ArrayPools.Vector2.UsageData
            //              || Vector3UsageData != ArrayPools.Vector3.UsageData
            //              || Vector4UsageData != ArrayPools.Vector4.UsageData
            //              || Int32UsageData != ArrayPools.Int32.UsageData
            //              || SingleUsageData != ArrayPools.Single.UsageData
            //              || CGSpotUsageData != ArrayPools.CGSpot.UsageData;

            EditorGUILayout.PropertyField(vector2Capacity);
            DisplayUsageData(nameof(Vector2), Vector2UsageData = ArrayPools.Vector2.UsageData);
            EditorGUILayout.Space();

            EditorGUILayout.PropertyField(vector3Capacity);
            DisplayUsageData(nameof(Vector3), Vector3UsageData = ArrayPools.Vector3.UsageData);
            EditorGUILayout.Space();

            EditorGUILayout.PropertyField(vector4Capacity);
            DisplayUsageData(nameof(Vector4), Vector4UsageData = ArrayPools.Vector4.UsageData);
            EditorGUILayout.Space();

            EditorGUILayout.PropertyField(intCapacity);
            DisplayUsageData("int", Int32UsageData = ArrayPools.Int32.UsageData);
            EditorGUILayout.Space();

            EditorGUILayout.PropertyField(floatCapacity);
            DisplayUsageData("float", SingleUsageData = ArrayPools.Single.UsageData);
            EditorGUILayout.Space();

            EditorGUILayout.PropertyField(cgSpotCapacity);
            DisplayUsageData(nameof(CGSpot), CGSpotUsageData = ArrayPools.CGSpot.UsageData);
            EditorGUILayout.Space();

            EditorGUILayout.PropertyField(logAllocations);

            serializedObject.ApplyModifiedProperties();

            //This was done to avoid repainting when nothing changed, but it doesn't seem to work when pools' usage changes in edit mode
            //if (needRepaint)
            Repaint();
        }

        private static void DisplayUsageData(string name, ArrayPoolUsageData usageData)
        {
            EditorGUILayout.LabelField("Available data:");

            EditorGUI.ProgressBar(
                EditorGUILayout.GetControlRect(false, GUILayout.Height(20)),
                usageData.ElementsCount / (float)usageData.ElementsCapacity,
                $"Elements: {usageData.ElementsCount:0,0} / {usageData.ElementsCapacity:0,0}\tArrays: {usageData.ArraysCount}");
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Pools/ArrayPoolsSettingsEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Wizards/CurvySplineExportWizard.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 12840e845e696084abe192ed5b6c47b0
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.Utils;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.Curvy.Pools;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.DevTools;
using FluffyUnderware.Curvy.ThirdParty.LibTessDotNet;

namespace FluffyUnderware.CurvyEditor
{
    /// <summary>
    /// Wizard to export one or more splines to a mesh
    /// </summary>
    public class CurvySplineExportWizard : EditorWindow
    {
        const int CLOSEDSHAPE = 0;
        const int VERTEXLINE = 1;
        const string Title = "Spline to Mesh";

        // SOURCES
        public List<SplinePolyLine> Curves = new List<SplinePolyLine>();
        public WindingRule Winding = WindingRule.EvenOdd;
        public string TriangulationMessage = string.Empty;

        bool refreshNow = true;
        public int Mode;
        public Material Mat;
        public Vector2 UVOffset = Vector2.zero;
        public Vector2 UVTiling = Vector2.one;

        public bool UV2;
        public string MeshName = "CurvyMeshExport";

        public CurvySplineGizmos GizmoState;

        public GameObject previewGO;
        public MeshFilter previewMeshFilter;
        public MeshRenderer previewMeshRenderer;

        public Vector2 scroll;
        readonly HashSet<CurvySpline> splines = new HashSet<CurvySpline>();

        Mesh previewMesh
        {
            get
            {
                return previewMeshFilter.sharedMesh;
            }
            set
            {
                previewMeshFilter.sharedMesh = value;
            }
        }

        static public void Create()
        {
            CurvySplineExportWizard win = GetWindow<CurvySplineExportWizard>(true, Title, true);
            win.Init(Selection.activeGameObject.GetComponent<CurvySpline>());
            win.minSize = new Vector2(500, 390);
            SceneView.duringSceneGui -= win.Preview;
            SceneView.duringSceneGui += win.Preview;
        }

        void OnEnable()
        {
            nSplines = new DTGroupNode("Splines") { HelpURL = CurvySpline.DOCLINK + "exportwizard" };
            nTexture = new DTGroupNode("Texture");
            nExport = new DTGroupNode("Export");

            GizmoState = CurvyGlobalManager.Gizmos;
            CurvyGlobalManager.Gizmos = CurvySplineGizmos.Curve;



            if (!previewGO)
            {
                previewGO = new GameObject("ExportPreview");
                previewGO.hideFlags = HideFlags.HideAndDontSave;
                previewMeshRenderer = previewGO.AddComponent<MeshRenderer>();
                previewMeshFilter = previewGO.AddComponent<MeshFilter>();
                if (!Mat)
                {
                    Mat = CurvyUtility.GetDefaultMaterial();
                }
                previewMeshRenderer.material = Mat;
            }
        }

        void OnDisable()
        {
            CurvyGlobalManager.Gizmos = GizmoState;
        }

        void OnDestroy()
        {
            SceneView.duringSceneGui -= Preview;
            foreach (SplinePolyLine crv in Curves)
                UnhookSpline(crv.Spline);
            Curves.Clear();
            SceneView.RepaintAll();
            GameObject.DestroyImmediate(previewGO);
        }

        void OnFocus()
        {
            SceneView.duringSceneGui -= Preview;
            SceneView.duringSceneGui += Preview;
        }

        void Init(CurvySpline spline)
        {
            Curves.Add(new SplinePolyLine(spline));
            HookSpline(spline);
        }


        Mesh clonePreviewMesh()
        {
            Mesh msh = new Mesh();
            
            Vector3[] previewMeshVertices = previewMesh.vertices;
            msh.vertices = previewMeshVertices;
            
            int[] previewMeshTriangles = previewMesh.triangles;
            msh.triangles = previewMeshTriangles;
            
            Vector2[] previewMeshUV = previewMesh.uv;
            msh.uv = previewMeshUV;
            
            Vector2[] previewMeshUV2 = previewMesh.uv2;
            msh.uv2 = previewMeshUV2;
            
            msh.RecalculateNormals();
            msh.RecalculateBounds();

            ArrayPools.Vector3.Free(previewMeshVertices);
            ArrayPools.Int32.Free(previewMeshTriangles);
            ArrayPools.Vector2.Free(previewMeshUV);
            ArrayPools.Vector2.Free(previewMeshUV2);
            return msh;
        }

        void OnSourceRefresh(CurvySplineEventArgs e)
        {
            refreshNow = true;
        }

        void HookSpline(CurvySpline spline)
        {
            if (!spline) return;
            spline.OnRefresh.AddListenerOnce(OnSourceRefresh);
            splines.Add(spline);
        }

        void UnhookSpline(CurvySpline spline)
        {
            if (!spline) return;
            spline.OnRefresh.RemoveListener(OnSourceRefresh);
            splines.Remove(spline);
        }

        readonly IDTInspectorNodeRenderer GUIRenderer = new DTInspectorNodeDefaultRenderer();
        private DTGroupNode nSplines;
        private DTGroupNode nTexture;
        private DTGroupNode nExport;
        bool mNeedRepaint;

        void OnGUI()
        {

            DTInspectorNode.IsInsideInspector = false;
            if (Curves.Count == 0)
                return;


            Mode = GUILayout.SelectionGrid(Mode, new GUIContent[]
                    {
                        new GUIContent("Closed Shape","Export a closed shape with triangles"),
                        new GUIContent("Vertex Line","Export a vertex line")
                    }, 2);



            if (!string.IsNullOrEmpty(TriangulationMessage) && !TriangulationMessage.Contains("Angle must be >0"))
                EditorGUILayout.HelpBox(TriangulationMessage, MessageType.Error);

            scroll = EditorGUILayout.BeginScrollView(scroll);

            // OUTLINE
            GUIRenderer.RenderSectionHeader(nSplines);
            if (nSplines.ContentVisible)
            {
                Winding = (WindingRule)EditorGUILayout.EnumPopup("Winding", Winding, GUILayout.Width(285));
                GUILayout.BeginHorizontal();
                GUILayout.Label(new GUIContent("Spline", "Note: Curves from a SplineGroup needs to be connected!"), EditorStyles.boldLabel, GUILayout.Width(140));
                GUILayout.Label("Vertex Generation", EditorStyles.boldLabel, GUILayout.Width(160));
                GUILayout.Label("Orientation", EditorStyles.boldLabel);
                GUILayout.EndHorizontal();
                CurveGUI(Curves[0]);
                if (Mode == CLOSEDSHAPE)
                {

                    for (int i = 1; i < Curves.Count; i++)
                    {
                        CurveGUI(Curves[i]);
                    }
                    if (GUILayout.Button(CurvyStyles.AddSmallTexture, GUILayout.ExpandWidth(false)))
                        Curves.Add(new SplinePolyLine(null));
                }
            }

            mNeedRepaint = mNeedRepaint || nSplines.NeedRepaint;
            GUIRenderer.RenderSectionFooter(nSplines);

            // TEXTURING
            GUIRenderer.RenderSectionHeader(nTexture);
            if (nTexture.ContentVisible)
            {
                Mat = (Material)EditorGUILayout.ObjectField("Material", Mat, typeof(Material), true, GUILayout.Width(285));
                UVTiling = EditorGUILayout.Vector2Field("Tiling", UVTiling, GUILayout.Width(285));
                UVOffset = EditorGUILayout.Vector2Field("Offset", UVOffset, GUILayout.Width(285));

            }
            GUIRenderer.RenderSectionFooter(nTexture);
            mNeedRepaint = mNeedRepaint || nTexture.NeedRepaint;
            // EXPORT
            GUIRenderer.RenderSectionHeader(nExport);
            if (nExport.ContentVisible)
            {
                MeshName = EditorGUILayout.TextField("Mesh Name", MeshName, GUILayout.Width(285));
                UV2 = EditorGUILayout.Toggle("Add UV2", UV2);

                GUILayout.BeginHorizontal();

                if (GUILayout.Button("Save as Asset"))
                {
                    string path = EditorUtility.SaveFilePanelInProject("Save Mesh", MeshName + ".asset", "asset", "Choose a file location");
                    if (!string.IsNullOrEmpty(path))
                    {
                        Mesh msh = clonePreviewMesh();
                        if (msh)
                        {
                            msh.name = MeshName;
                            AssetDatabase.DeleteAsset(path);
                            AssetDatabase.CreateAsset(msh, path);
                            AssetDatabase.SaveAssets();
                            AssetDatabase.Refresh();
                            DTLog.Log("[Curvy] Export: Mesh Asset saved!");
                        }
                    }
                }

                if (GUILayout.Button("Create GameObject"))
                {
                    Mesh msh = clonePreviewMesh();
                    if (msh)
                    {
                        msh.name = MeshName;
                        GameObject go = new GameObject(MeshName, typeof(MeshRenderer), typeof(MeshFilter));
                        go.GetComponent<MeshFilter>().sharedMesh = msh;
                        go.GetComponent<MeshRenderer>().sharedMaterial = Mat;
                        Selection.activeGameObject = go;
                        DTLog.Log("[Curvy] Export: GameObject created!");
                    }
                    else
                        DTLog.LogWarning("[Curvy] Export: Unable to triangulate spline!");

                }
                GUILayout.EndHorizontal();

            }
            GUIRenderer.RenderSectionFooter(nExport);
            mNeedRepaint = mNeedRepaint || nExport.NeedRepaint;
            EditorGUILayout.EndScrollView();
            refreshNow = refreshNow || GUI.changed;
            if (mNeedRepaint)
            {
                Repaint();
                mNeedRepaint = false;
            }
        }

        void CurveGUI(SplinePolyLine curve)
        {
            GUILayout.BeginHorizontal();
            CurvySpline o = curve.Spline;
            curve.Spline = (CurvySpline)EditorGUILayout.ObjectField(curve.Spline, typeof(CurvySpline), true, GUILayout.Width(140));

            if (o != curve.Spline)
            {
                UnhookSpline(o);
            }
            HookSpline(curve.Spline);

            curve.VertexMode = (SplinePolyLine.VertexCalculation)EditorGUILayout.EnumPopup(curve.VertexMode, GUILayout.Width(140));
            GUILayout.Space(20);
            curve.Orientation = (ContourOrientation)EditorGUILayout.EnumPopup(curve.Orientation);
            if (GUILayout.Button(new GUIContent(CurvyStyles.DeleteSmallTexture, "Remove"), GUILayout.ExpandWidth(false)))
            {
                if (curve.Spline)
                    UnhookSpline(curve.Spline);
                Curves.Remove(curve);
                refreshNow = true;
                GUIUtility.ExitGUI();
            }
            switch (curve.VertexMode)
            {
                case SplinePolyLine.VertexCalculation.ByAngle:
                    GUILayout.EndHorizontal();
                    GUILayout.BeginHorizontal();
                    GUILayout.Space(150);
                    float lw = EditorGUIUtility.labelWidth;
                    EditorGUIUtility.labelWidth = 40;
                    curve.Angle = Mathf.Max(0, EditorGUILayout.FloatField("Angle", curve.Angle, GUILayout.Width(140)));
                    EditorGUIUtility.labelWidth = 60;
                    GUILayout.Space(20);
                    curve.Distance = EditorGUILayout.FloatField("Min. Dist.", curve.Distance, GUILayout.Width(150));
                    EditorGUIUtility.labelWidth = lw;
                    if (curve.Angle == 0)
                    {
                        GUILayout.EndHorizontal();
                        GUILayout.BeginHorizontal();
                        GUILayout.Space(140);
                        EditorGUILayout.HelpBox("Angle must be >0", MessageType.Error);
                    }
                    break;
            }
            GUILayout.EndHorizontal();



        }

        void Update()
        {
            if (Curves.Count == 0)
            {
                Close();
                return;
            }

            refreshNow = refreshNow || splines.Any(splineBase => splineBase.GlobalCoordinatesChangedThisFrame);

            if (refreshNow)
            {
                previewMeshRenderer.sharedMaterial = Mat;
                refreshNow = false;
                Spline2Mesh s2m = new Spline2Mesh();
                foreach (SplinePolyLine c in Curves)
                    if (c.Spline != null)
                        s2m.Lines.Add(c);

                s2m.Winding = Winding;
                s2m.VertexLineOnly = (Mode == VERTEXLINE);

                s2m.UVOffset = UVOffset;
                s2m.UVTiling = UVTiling;
                s2m.UV2 = UV2;
                s2m.MeshName = MeshName;
                Mesh m;
                s2m.Apply(out m);
                previewMesh = m;

                TriangulationMessage = s2m.Error;
                string sTitle;
                if (previewMesh)
                {
                    if (previewMesh.triangles.Length > 0)
                        sTitle = string.Format("{2} ({0} Vertices, {1} Triangles)", previewMeshFilter.sharedMesh.vertexCount, previewMeshFilter.sharedMesh.triangles.Length / 3, Title);
                    else
                        sTitle = string.Format("{1} ({0} Vertices)", previewMeshFilter.sharedMesh.vertexCount, Title);
                }
                else
                    sTitle = Title;

#if UNITY_5_0 || UNITY_4_6
                title=sTitle;
#else
                titleContent = new GUIContent(sTitle);
#endif
                SceneView.RepaintAll();
            }
        }

        void Preview(SceneView sceneView)
        {

            if (!previewMesh)
                return;

            Vector3[] vts = previewMesh.vertices;
            int[] tris = new int[0];
            if (Mode != VERTEXLINE)
                tris = previewMesh.triangles;
            Handles.color = Color.green;
            Handles.matrix = Matrix4x4.TRS(new Vector3(0, 0, 0), Quaternion.identity, Vector3.one);
            for (int i = 0; i < tris.Length; i += 3)
                Handles.DrawPolyLine(vts[tris[i]], vts[tris[i + 1]], vts[tris[i + 2]], vts[tris[i]]);

            Handles.color = Color.gray;
            for (int i = 0; i < vts.Length; i++)
            {
#if UNITY_5_6_OR_NEWER
                Handles.CubeHandleCap(0, vts[i], Quaternion.identity, HandleUtility.GetHandleSize(vts[i]) * 0.07f, EventType.Repaint);
#else
                Handles.CubeCap(0, vts[i], Quaternion.identity, HandleUtility.GetHandleSize(vts[i]) * 0.07f);
#endif
            }
            ArrayPools.Vector3.Free(vts);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Wizards/CurvySplineExportWizard.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Wizards/ImportExportWizard.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 5db77d2b5ae492649a8d4d7750fb10fe
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.ImportExport;
using FluffyUnderware.DevToolsEditor;
using JetBrains.Annotations;
using UnityEditor;
using UnityEngine;

namespace FluffyUnderware.CurvyEditor
{
    /// <summary>
    /// A window that allows exporting and importing splines as Json files
    /// </summary>
    public class ImportExportWizard : EditorWindow
    {
        /// <summary>
        /// Json version of the imported or exported splines
        /// </summary>
        private string serializedText = string.Empty;

        /// <summary>
        /// serializedText copy that iqs used in the UI display. Truncated if too long to avoid Unity error.
        /// </summary>
        private string displayedSerializedText = string.Empty;
        /// <summary>
        /// Defines if which coordinates should be read/written
        /// </summary>
        private CurvySerializationSpace coordinateSpace = CurvySerializationSpace.Global;

        private FileFormat fileFormat = FileFormat.JSON;

        private Vector2 scrollingPosition;

        private IDTInspectorNodeRenderer GUIRenderer;
        private DTGroupNode configurationGroup;
        private DTGroupNode actionsGroup;
        private DTGroupNode advancedActionsGroup;

        static public void Open()
        {
            ImportExportWizard win = GetWindow<ImportExportWizard>(true, "Import/Export splines");
            win.minSize = new Vector2(350, 340);
        }

        private void OnDisable()
        {
            DTSelection.OnSelectionChange -= Repaint;
        }

        private void OnEnable()
        {
            const string docLinkId = "import_export";

            GUIRenderer = new DTInspectorNodeDefaultRenderer();

            configurationGroup = new DTGroupNode("Configuration") { HelpURL = CurvySpline.DOCLINK + docLinkId };
            actionsGroup = new DTGroupNode("Actions") { HelpURL = CurvySpline.DOCLINK + docLinkId };
            advancedActionsGroup = new DTGroupNode("Advanced Actions") { HelpURL = CurvySpline.DOCLINK + docLinkId };

            DTSelection.OnSelectionChange += Repaint;
        }

        private void OnGUI()
        {
            List<CurvySpline> selectedSplines = Selection.GetFiltered(typeof(CurvySpline), SelectionMode.ExcludePrefab).Where(o => o != null).Select(o => (CurvySpline)o).ToList();

            //actions
            bool export = false;
            bool import = false;
            bool readFromSelection = false;
            bool writeToSelection = false;
            bool readFromFile = false;
            bool writeToFile = false;
            string editedString = null;

            //Display window and read user commands
            {
                GUI.skin.label.wordWrap = true;
                GUILayout.Label("This window allows you to import/export splines from/to JSON text.");

                DTInspectorNode.IsInsideInspector = false;

                //Configuration
                GUIRenderer.RenderSectionHeader(configurationGroup);
                if (configurationGroup.ContentVisible)
                {
                    coordinateSpace = (CurvySerializationSpace)EditorGUILayout.EnumPopup("Coordinate space to use", coordinateSpace, GUILayout.Width(280));

                    var oldFileFormat = fileFormat;

                    fileFormat = (FileFormat)EditorGUILayout.EnumPopup("Format", fileFormat, GUILayout.Width(280));

                    if (fileFormat != oldFileFormat)
                        OnFileFormatChanged();

                }
                GUIRenderer.RenderSectionFooter(configurationGroup);


                //Actions
                GUIRenderer.RenderSectionHeader(actionsGroup);
                if (actionsGroup.ContentVisible)
                {
                    switch (fileFormat)
                    {
                        case FileFormat.JSON:
                            GUI.enabled = selectedSplines.Count > 0;
                            export = GUILayout.Button("Export selected spline(s)");

                            GUI.enabled = true;
                            import = GUILayout.Button("Import");
                            break;
                        case FileFormat.SVG:
                            GUI.enabled = true;
                            import = GUILayout.Button("Import");
                            break;
                        default:
                            throw new ArgumentOutOfRangeException();
                    }

                }
                GUIRenderer.RenderSectionFooter(actionsGroup);


                //Advanced actions
                GUIRenderer.RenderSectionHeader(advancedActionsGroup);
                if (advancedActionsGroup.ContentVisible)
                {

                    switch (fileFormat)
                    {
                        case FileFormat.JSON:
                            GUI.enabled = selectedSplines.Count > 0;
                            readFromSelection = GUILayout.Button("Read selected spline(s)");

                            GUI.enabled = true;
                            readFromFile = GUILayout.Button("Read from file");

                            GUI.enabled = string.IsNullOrEmpty(serializedText) == false;
                            writeToSelection = GUILayout.Button("Write new spline(s)");

                            writeToFile = GUILayout.Button("Write to file");
                            break;
                        case FileFormat.SVG:
                            GUI.enabled = true;
                            readFromFile = GUILayout.Button("Read from file");

                            GUI.enabled = string.IsNullOrEmpty(serializedText) == false;
                            writeToSelection = GUILayout.Button("Write new spline(s)");

                            writeToFile = GUILayout.Button("Write to file");
                            break;
                        default:
                            throw new ArgumentOutOfRangeException();
                    }

                    GUI.enabled = true;
                    scrollingPosition = EditorGUILayout.BeginScrollView(scrollingPosition, GUILayout.MaxHeight(position.height - 100));
                    EditorGUI.BeginChangeCheck();
                    string modifiedString = EditorGUILayout.TextArea(displayedSerializedText, EditorStyles.textArea, GUILayout.ExpandHeight(true));
                    if (GUI.changed)
                        editedString = modifiedString;
                    EditorGUI.EndChangeCheck();
                    EditorGUILayout.EndScrollView();
                }
                GUIRenderer.RenderSectionFooter(advancedActionsGroup);
                GUILayout.Space(5);

                if (configurationGroup.NeedRepaint || actionsGroup.NeedRepaint || advancedActionsGroup.NeedRepaint)
                    Repaint();

                if (readFromFile || readFromSelection)
                    GUI.FocusControl(null); //Keeping the focus prevents the textfield from refreshing
            }

            if (export)
            {
                readFromSelection = true;
                writeToFile = true;
            }

            if (import)
            {
                readFromFile = true;
                writeToSelection = true;
            }

            ProcessCommands(selectedSplines, readFromSelection, readFromFile, editedString, writeToSelection, writeToFile);
        }


        private void OnFileFormatChanged()
        {
            serializedText = string.Empty;
            displayedSerializedText = string.Empty;
            scrollingPosition = Vector2.zero;
        }


        private void ProcessCommands([NotNull] List<CurvySpline> selectedSplines, bool readFromSelection, bool readFromFile, [CanBeNull] string editedString, bool writeToSelection, bool writeToFile)
        {
            string fileExtension = fileFormat.ToString().ToLowerInvariant();

            if (readFromSelection || readFromFile || editedString != null)
            {
                if (readFromSelection || readFromFile)
                {
                    string raw;
                    {
                        if (readFromSelection)
                        {
                            if (selectedSplines.Count > 0)
                                switch (fileFormat)
                                {
                                    case FileFormat.JSON:
                                        raw = SplineJsonConverter.SplinesToJson(selectedSplines, coordinateSpace);
                                        break;
                                    default:
                                        throw new ArgumentOutOfRangeException();
                                }
                            else
                                throw new InvalidOperationException("Serialize Button should not be clickable when something other than splines is selected");
                        }
                        else
                        {
                            string fileToLoadFullName = EditorUtility.OpenFilePanel("Select file to load", Application.dataPath, fileExtension);
                            if (String.IsNullOrEmpty(fileToLoadFullName))//Happens when user cancel the file selecting window
                                raw = displayedSerializedText;
                            else
                                raw = File.ReadAllText(fileToLoadFullName);
                        }
                    }

                    serializedText = raw;
                }
                else
                    serializedText = editedString;

                displayedSerializedText = serializedText;
            }

            if (writeToSelection && string.IsNullOrEmpty(serializedText) == false)
            {
                CurvySpline[] splines;
                switch (fileFormat)
                {
                    case FileFormat.JSON:
                        splines = SplineJsonConverter.JsonToSplines(serializedText, coordinateSpace);
                        break;
                    case FileFormat.SVG:
                        splines = SplineSvgConverter.SvgToSplines(serializedText, coordinateSpace);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }

                foreach (CurvySpline spline in splines)
                {
                    Undo.RegisterCreatedObjectUndo(spline.gameObject, "Deserialize");
                    spline.transform.SetParent(Selection.activeTransform, coordinateSpace == CurvySerializationSpace.Global);
                }
            }
            else if (writeToFile)
            {
                string file = EditorUtility.SaveFilePanel(
                    "Save to...",
                    Application.dataPath,
                    String.Format(
                        "Splines_{0}.{1}",
                        DateTime.Now.ToString("yyyy-MMMM-dd HH_mm"),
                        fileExtension),
                    fileExtension);
                if (!string.IsNullOrEmpty(file))
                {
                    File.WriteAllText(file, serializedText);
                    AssetDatabase.Refresh();
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Wizards/ImportExportWizard.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Wizards/ModuleWizard.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1d8030feb811c6a4c89e6f6d8c60b4c7
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.IO;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.CurvyEditor.Generator
{
    public class ModuleWizard : EditorWindow
    {
        
        string mModuleClassName = string.Empty;
        string mModuleMenuName = string.Empty;
        string mModuleName = string.Empty;
        string mModuleDescription = string.Empty;
        readonly string mModuleScriptPath = CurvyProject.Instance.CustomizationRootPath + CurvyProject.RELPATH_CGMODULEWIZARDSCRIPTS;
        readonly string mModuleEditorScriptPath = CurvyProject.Instance.CustomizationRootPath + CurvyProject.RELPATH_CGMODULEWIZARDEDITORSCRIPTS;

        bool mNeedFocus = true;

        string ScriptTemplate
        {
            get 
            {
                return CurvyEditorUtility.GetPackagePathAbsolute("ClassTemplates/CGModuleTemplate.txt"); 
            }

        }
        string EditorScriptTemplate
        {
            get
            {
                return CurvyEditorUtility.GetPackagePathAbsolute("ClassTemplates/CGModuleEditorTemplate.txt");
            }
        }

        string ModuleFileName
        {
            get
            {
                return Application.dataPath+"/"+mModuleScriptPath.TrimEnd('/','\\') + "/" + mModuleClassName + ".cs";
            }
        }

        string ModuleEditorFileName
        {
            get
            {
                return Application.dataPath + "/" + mModuleEditorScriptPath.TrimEnd('/', '\\') + "/" + mModuleClassName + "Editor.cs";
            }
        }

        public static void Open()
        {
            ModuleWizard win=EditorWindow.GetWindow<ModuleWizard>(true, "Create CG Module");
            win.minSize = new Vector2(500, 120);
            
        }

        void OnGUI()
        {
            EditorGUI.BeginChangeCheck();
            GUI.SetNextControlName("ClassName");
            mModuleClassName = EditorGUILayout.TextField(new GUIContent("Class Name","C# class name"), mModuleClassName);
            

            if (EditorGUI.EndChangeCheck())
            {
                mModuleName = ObjectNames.NicifyVariableName(mModuleClassName);
                mModuleMenuName = "Custom/" + mModuleName;
            }
            mModuleName = EditorGUILayout.TextField(new GUIContent("Module Name","The default module instance name"), mModuleName);
            mModuleMenuName = EditorGUILayout.TextField(new GUIContent("Menu Name","Name to show in the CG menu"), mModuleMenuName);
            
            EditorGUILayout.PrefixLabel("Description");
            mModuleDescription = EditorGUILayout.TextArea(mModuleDescription);

            GUI.enabled = !string.IsNullOrEmpty(mModuleScriptPath) &&
                          !string.IsNullOrEmpty(mModuleEditorScriptPath) &&
                          !string.IsNullOrEmpty(mModuleClassName) &&
                          !string.IsNullOrEmpty(mModuleMenuName) &&
                          !string.IsNullOrEmpty(mModuleName);
            if (GUILayout.Button("Create"))
                CreateModule();

            GUI.enabled = true;

            if (mNeedFocus)
            {
                EditorGUI.FocusTextInControl("ClassName");
                mNeedFocus = false;
            }
                
        }

        void CreateModule()
        {
            if (!File.Exists(ScriptTemplate)){
                DTLog.LogError("[Curvy] Missing Module Template file '"+ScriptTemplate+"'!");
                return;
            }
            if (!File.Exists(EditorScriptTemplate))
            {
                DTLog.LogError("[Curvy] Missing Module Template file '" + EditorScriptTemplate + "'!");
                return;
            }

            // Script
            string template = File.ReadAllText(ScriptTemplate);
            if (!string.IsNullOrEmpty(template))
            {
                Directory.CreateDirectory(Path.GetDirectoryName(ModuleFileName));
                StreamWriter stream = File.CreateText(ModuleFileName);
                stream.Write(replaceVars(template));
                stream.Close();

            }
            else
            {
                DTLog.LogError("[Curvy] Unable to load template file");
                return;
            }
            // Editor Script
            template = File.ReadAllText(EditorScriptTemplate);
            if (!string.IsNullOrEmpty(template))
            {
                Directory.CreateDirectory(Path.GetDirectoryName(ModuleEditorFileName));
                StreamWriter stream = File.CreateText(ModuleEditorFileName);
                stream.Write(replaceVars(template));
                stream.Close();
            }
            else
            {
                DTLog.LogError("[Curvy] Unable to load editor template file");
                return;
            }
            AssetDatabase.Refresh();
            Close();
            EditorUtility.DisplayDialog("CG Module Wizard", "Scripts successfully created!", "OK");
            
            Selection.objects = new Object[2]
            {
                AssetDatabase.LoadMainAssetAtPath(ModuleFileName.Replace(Application.dataPath,"Assets")),
                AssetDatabase.LoadMainAssetAtPath(ModuleEditorFileName.Replace(Application.dataPath,"Assets"))
            };
        }

        string replaceVars(string template)
        {
            return template.Replace("%MENUNAME%", mModuleMenuName)
                           .Replace("%MODULENAME%", mModuleName)
                           .Replace("%DESCRIPTION%", mModuleDescription)
                           .Replace("%CLASSNAME%", mModuleClassName);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Wizards/ModuleWizard.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Wizards/ShapeWizard.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e5b35d5b423028e43b3216a28619b644
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.IO;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.CurvyEditor
{
    public class ShapeWizard : EditorWindow
    {

        string mShapeClassName = "CS";
        string mShapeMenuName = "Custom/";
        bool mShapeIs2D = true;
        bool mNeedFocus=true;

        string mShapeParent = "CurvyShape";
        readonly string mShapeScriptPath = CurvyProject.Instance.CustomizationRootPath + CurvyProject.RELPATH_SHAPEWIZARDSCRIPTS;

        string ScriptTemplate
        {
            get
            {
                return CurvyEditorUtility.GetPackagePathAbsolute("ClassTemplates/ShapeTemplate.txt"); 
            }
        }

        string ShapeFileName
        {
            get
            {
                return Application.dataPath + "/" + mShapeScriptPath.TrimEnd('/', '\\') + "/" + mShapeClassName + ".cs";
            }
        }

       
        public static void Open()
        {
            ShapeWizard win = EditorWindow.GetWindow<ShapeWizard>(true, "Create Shape");
            win.minSize = new Vector2(500, 60);
        }

        void OnGUI()
        {
            EditorGUI.BeginChangeCheck();
            GUI.SetNextControlName("ClassName");
            mShapeClassName = EditorGUILayout.TextField("Class Name", mShapeClassName);
            
            if (EditorGUI.EndChangeCheck())
            {
                mShapeMenuName = "Custom/"+ObjectNames.NicifyVariableName(mShapeClassName.TrimStart("CS"));
            }
            
            mShapeMenuName = EditorGUILayout.TextField("Menu Name", mShapeMenuName);
            mShapeIs2D = EditorGUILayout.Toggle("Is 2D", mShapeIs2D);

            GUI.enabled = !string.IsNullOrEmpty(mShapeScriptPath) &&
                          !string.IsNullOrEmpty(mShapeClassName) &&
                          !string.IsNullOrEmpty(mShapeMenuName);
            if (GUILayout.Button("Create"))
            {
                CreateShape();
            }
            GUI.enabled = true;


            if (mNeedFocus)
            {
                EditorGUI.FocusTextInControl("ClassName");
                mNeedFocus = false;
            }

        }

        void CreateShape()
        {
            if (!File.Exists(ScriptTemplate))
            {
                DTLog.LogError("[Curvy] Missing Shape Template file '" + ScriptTemplate + "'!");
                return;
            }

            mShapeParent = (mShapeIs2D) ? "CurvyShape2D" : "CurvyShape";

            // Script
            string template = File.ReadAllText(ScriptTemplate);
            if (!string.IsNullOrEmpty(template))
            {
                Directory.CreateDirectory(Path.GetDirectoryName(ShapeFileName));
                StreamWriter stream = File.CreateText(ShapeFileName);
                stream.Write(replaceVars(template));
                stream.Close();

            }
            else
            {
                DTLog.LogError("[Curvy] Unable to load template file");
                return;
            }
           
            AssetDatabase.Refresh();
            Close();
            EditorUtility.DisplayDialog("Shape Script Wizard", "Script successfully created!", "OK");
            Selection.activeObject = AssetDatabase.LoadMainAssetAtPath("Assets/"+mShapeScriptPath + "/" + mShapeClassName + ".cs");
        }

        string replaceVars(string template)
        {
            return template.Replace("%MENUNAME%", mShapeMenuName)
                           .Replace("%CLASSNAME%", mShapeClassName)
                           .Replace("%PARENT%",mShapeParent)
                           .Replace("%IS2D%",mShapeIs2D.ToString().ToLower());
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Wizards/ShapeWizard.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Wizards/TemplateWizard.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 296620d129d476c4cbbbf16821c2a5ce
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using FluffyUnderware.CurvyEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.CurvyEditor.Generator;

namespace FluffyUnderware.CurvyEditor.Generator
{
    public class TemplateWizard : EditorWindow
    {
        string mName;
        List<CGModule> mModules;
        private CanvasUI canvasUI;

        public static void Open(List<CGModule> modules, CanvasUI canvasUI)
        {
            if (modules == null || modules.Count == 0)
                return;
            TemplateWizard win = EditorWindow.GetWindow<TemplateWizard>(true, "Save Template");
            win.minSize = new Vector2(300, 90);
            win.maxSize = win.minSize;
            win.mName = "";
            win.mModules = modules;
            win.canvasUI = canvasUI;
        }

        void OnGUI()
        {
            EditorGUILayout.HelpBox("Only Managed Resources will be saved!", MessageType.Warning);
            GUI.SetNextControlName("TPLWIZ_txtName");
            mName = EditorGUILayout.TextField("Template Menu Name", mName).TrimStart('/');

            

            EditorGUILayout.BeginHorizontal();
            GUI.enabled = (!string.IsNullOrEmpty(mName));
            if (GUILayout.Button("Save"))
            {
                Save();
                Close();
            }
            GUI.enabled = true;
            if (GUILayout.Button("Cancel"))
                Close();
            EditorGUILayout.EndHorizontal();

            if (GUI.GetNameOfFocusedControl() == "")
                EditorGUI.FocusTextInControl("TPLWIZ_txtName");
        }

        void Save()
        {
            string absFolder = Application.dataPath + "/" + CurvyProject.Instance.CustomizationRootPath + CurvyProject.RELPATH_CGTEMPLATES;
            string file = absFolder + "/" + mName + ".prefab";
            if (!System.IO.File.Exists(file) || EditorUtility.DisplayDialog("Replace File?", "The file already exists! Replace it?", "Yes", "No"))
            {
                if (CGEditorUtility.CreateTemplate(mModules, file))
                {
                    EditorUtility.DisplayDialog("Save Generator Template", "Template successfully saved!", "Ok");
                    if (canvasUI != null)
                        canvasUI.ReloadTemplates();
                }
            }

        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Wizards/TemplateWizard.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/ClipboardHandler.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: fc604c1a18b9fa14da6b9d0f985e87e0
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using UnityEditor;
using System;
using FluffyUnderware.DevTools.Extensions;

namespace FluffyUnderware.DevToolsEditor
{
    public interface IDTClipboardHandler
    {
        void Copy(object value);
        object Paste(object data);
        bool CanPasteFrom(Type clipboardType);
    }

    public class DTVector2Clipboard : IDTClipboardHandler
    {

        public void Copy(object value)
        {
            DT.ClipBoardSet(value);
            EditorGUIUtility.systemCopyBuffer = value.GetType().Name;
        }

        public object Paste(object data)
        {
            if (data is Vector2)
                return (Vector2)data;
            else if (data is Vector3)
                return new Vector2(((Vector3)data).x, ((Vector3)data).y);
            else if (data is Vector4)
                return new Vector2(((Vector4)data).x, ((Vector4)data).y);

            return Vector2.zero;
        }

        public bool CanPasteFrom(Type clipboardType)
        {
            return (clipboardType.Matches(typeof(Vector2), typeof(Vector3), typeof(Vector4)));
        }

    }

    public class DTVector3Clipboard : IDTClipboardHandler
    {

        public void Copy(object value)
        {
            DT.ClipBoardSet(value);
            EditorGUIUtility.systemCopyBuffer = value.GetType().Name;
        }

        public object Paste(object data)
        {
            if (data is Vector3)
                return (Vector3)data;
            else if (data is Vector4)
                return new Vector3(((Vector4)data).x, ((Vector4)data).y, ((Vector4)data).z);

            return Vector2.zero;
        }

        public bool CanPasteFrom(Type clipboardType)
        {
            return (clipboardType.Matches(typeof(Vector3), typeof(Vector4)));
        }


    }

    public class DTAnimationCurveClipboard : IDTClipboardHandler
    {
        public void Copy(object value)
        {
            DT.ClipBoardSet(value);
        }

        public object Paste(object data)
        {
            AnimationCurve clp=(AnimationCurve)data;
            AnimationCurve curve=new AnimationCurve(clp.keys);
            curve.preWrapMode = clp.preWrapMode;
            curve.postWrapMode = clp.postWrapMode;
            return curve;
        }

        public bool CanPasteFrom(Type clipboardType)
        {
            return clipboardType == typeof(AnimationCurve);
        }
    }
    
    
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/ClipboardHandler.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/Components/ComponentPoolEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 007dc0ff09c5d97478ad4fe856644878
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.DevToolsEditor
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(ComponentPool))]
    public class ComponentPoolEditor : DTEditor<ComponentPool>
    {
        protected override void OnCustomInspectorGUIBefore()
        {
            PoolManagerEditor.showBar(Target);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/Components/ComponentPoolEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/Components/PoolManagerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 2f1bf8d1bfc7bd84d88dbc07008b45ef
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.DevToolsEditor
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(PoolManager))]
    public class PoolManagerEditor : DTEditor<PoolManager>
    {

        protected override void OnReadNodes()
        {
            Node.AddSection("Type Pools", typePoolsGUI);
        }



        void typePoolsGUI(DTInspectorNode node)
        {

            foreach (KeyValuePair<Type, IPool> kv in Target.TypePools)
            {
                showBar(kv.Value);
            }
        }


        public static void showBar(IPool pool)
        {
            Rect r = EditorGUILayout.GetControlRect(false, GUILayout.Height(20));
            float hi = Mathf.Max(pool.Count, pool.Settings.Threshold);
            Color c = Color.green;
            if (pool.Count < pool.Settings.MinItems)
                c = Color.yellow;
            else if (pool.Count > pool.Settings.Threshold)
                c = Color.red;
            DTGUI.PushContentColor(c);
            string s = pool.Identifier;
            if (!string.IsNullOrEmpty(s))
            {
                int i = s.IndexOf(",", StringComparison.Ordinal);
                if (i > 0)
                    s = pool.Identifier.Substring(0, i);
            }
            EditorGUI.ProgressBar(r, pool.Count / hi, s + ":" + pool.Count.ToString());
            DTGUI.PopContentColor();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/Components/PoolManagerEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/Components/PrefabPoolEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 034101b2c8b1d0647afbae54cbffb340
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.DevToolsEditor
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(PrefabPool), true)]
    public class PrefabPoolEditor : DTEditor<PrefabPool>
    {
        protected override void OnCustomInspectorGUIBefore()
        {
            PoolManagerEditor.showBar(Target);
        }


    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/Components/PrefabPoolEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DT.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 9ae275390dd4915458afdfbc1948f159
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using UnityEditor;
using System;
using System.Collections;
using System.Linq;
using System.Collections.Generic;
using FluffyUnderware.DevTools.Extensions;
using System.Reflection;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.DevToolsEditor
{
    [InitializeOnLoad]
    public static class DT
    {
        const char editorPreferencesArraySeparator = ';';

        public const string VERSION = "1.0.3";
        /// <summary>
        /// Global override for float precision rounding (e.g. DTPropertyAttribute.Precision)
        /// </summary>
        public static bool _UseSnapValuePrecision;


        public delegate void Callback();

        public static List<DTProject> Projects
        {
            get
            {
                return mProjects.Values.ToList();
            }
        }

        public static DTProject Project(string identifier)
        {
            DTProject prj;
            if (!mProjects.TryGetValue(identifier, out prj))
            {
                LoadProjects();
                if (!mProjects.TryGetValue(identifier, out prj))
                    DTLog.LogError("[DevTools] Unable to find project '" + identifier + "' !");
            }

            return prj;
        }

        static object mClipboardData;
        static readonly Dictionary<Type, IDTClipboardHandler> mClipboardHandlers = new Dictionary<Type, IDTClipboardHandler>();
        static readonly Dictionary<string, DTProject> mProjects = new Dictionary<string, DTProject>();

        static bool _compiling;

        static DT()
        {
            EditorApplication.update += delayedInitialize;
            EditorApplication.update -= compileCheck;
            EditorApplication.update += compileCheck;

        }

        public static void Clear()
        {
            foreach (DTProject prj in DT.Projects)
                prj.Clear();
            DT.Projects.Clear();
        }

        public static void ReInitialize(bool loadProjects = true)
        {
            if (loadProjects)
                LoadProjects();

            DTToolbar.Initialize();
            HandleProjectsKeyBindings();
        }

        static void delayedInitialize()
        {
            EditorApplication.update -= delayedInitialize;
            LoadPreferences();
            DTSelection.Initialize();
            ReInitialize();
            // Register Clipboard-Handlers
            RegisterClipboardType(typeof(Vector2), new DTVector2Clipboard());
            RegisterClipboardType(typeof(Vector3), new DTVector3Clipboard());
            RegisterClipboardType(typeof(AnimationCurve), new DTAnimationCurveClipboard());
        }

        static void compileCheck()
        {
            if (!_compiling)
            {
                _compiling = EditorApplication.isCompiling;
                if (_compiling)
                    Clear();
            }
            else
                _compiling = EditorApplication.isCompiling;
        }

        #region ### Clipboard ###
        public static void RegisterClipboardType(Type dataType, IDTClipboardHandler handler, bool overwriteExisting = false)
        {
            if (mClipboardHandlers.ContainsKey(dataType))
            {
                if (overwriteExisting)
                    mClipboardHandlers[dataType] = handler;
            }
            else
                mClipboardHandlers.Add(dataType, handler);
        }

        public static void ClipboardCopy(object data)
        {
            Type dataType = data.GetType();
            IDTClipboardHandler handler;
            if (mClipboardHandlers.TryGetValue(dataType, out handler))
            {
                handler.Copy(data);
            }
            else
                DTLog.LogError("[DevTools] No ClipboardHandler for data type '" + data.GetType().Name + "' found!");
        }

        public static T ClipboardPaste<T>()
        {
            IDTClipboardHandler handler;
            if (mClipboardData != null && mClipboardHandlers.TryGetValue(typeof(T), out handler))
            {
                if (handler.CanPasteFrom(mClipboardData.GetType()))
                {
                    return (T)handler.Paste(mClipboardData);
                }
            }
            return default;
        }

        public static bool ClipboardCanPasteTo<T>()
        {
            IDTClipboardHandler handler;
            if (mClipboardData != null && mClipboardHandlers.TryGetValue(typeof(T), out handler))
            {
                return handler.CanPasteFrom(mClipboardData.GetType());
            }
            return false;
        }

        internal static void ClipBoardSet(object data)
        {
            mClipboardData = data;
        }

        #endregion

        #region ### Project Management ###

        static void LoadProjects()
        {
            mProjects.Clear();
            TypeCache.TypeCollection types = TypeCache.GetTypesDerivedFrom(typeof(DTProject));
            foreach (Type t in types)
            {
                DTProject newProject = (DTProject)Activator.CreateInstance(t);
                mProjects.Add(newProject.Identifier, newProject);
            }
        }

        static void HandleProjectsKeyBindings()
        {
            foreach (DTProject prj in Projects)
                if (!prj.CheckKeyBindingNamesAreUnique())
                    return;
                else
                    prj.LoadKeyBindingRemappings();
        }

        #endregion

        #region ### EditorPrefs-Helpers ###

        static void LoadPreferences()
        {
            // Upgrade?
            string ver = GetEditorPrefs("FluffyUnderware.DevTools.Version", VERSION);
            if (ver != VERSION)
            {
                UpgradeDevTools(ver);
                SavePreferences();
            }
        }

        static void SavePreferences()
        {
            SetEditorPrefs("FluffyUnderware.DevTools.Version", VERSION);
        }

        /// <summary>
        /// Add code to handle upgrading (delete old pref-keys etc...) here
        /// </summary>
        /// <param name="oldVersion">the version stored in the EditorPrefs</param>
        static void UpgradeDevTools(string oldVersion)
        {
            DTLog.Log("[DevTools] Upgrading settings from " + oldVersion + " to " + VERSION);
        }

        public static void SetEditorPrefs<T>(string key, T value)
        {
            Type tt = typeof(T);
            if (tt.IsEnum)
            {
                EditorPrefs.SetInt(key, Convert.ToInt32(Enum.Parse(typeof(T), value.ToString()) as Enum));
            }
            else if (tt.IsArray)
            {
                var list = (IList)value;
                string[] array = new string[list.Count];
                for (int i = 0; i < array.Length; i++)
                {
                    array[i] = list[i].ToString();
                    if(array[i].Contains(editorPreferencesArraySeparator))
                        throw new ArgumentException(String.Format("value should not have any element containing a {0} character",editorPreferencesArraySeparator));
                }
                SetEditorPrefs(key, String.Join(editorPreferencesArraySeparator.ToString(), array));
            }
            else if (tt.Matches(typeof(int), typeof(Int32)))
                EditorPrefs.SetInt(key, (value as int?).Value);
            else if (tt == typeof(string))
                EditorPrefs.SetString(key, (value as string));
            else if (tt == typeof(float))
                EditorPrefs.SetFloat(key, (value as float?).Value);
            else if (tt == typeof(bool))
                EditorPrefs.SetBool(key, (value as bool?).Value);
            else if (tt == typeof(Color))
                EditorPrefs.SetString(key, (value as Color?).Value.ToHtml());
            else
                DTLog.LogError("[DevTools] SetEditorPrefs: Unsupported datatype: " + tt.Name);
        }

        public static T GetEditorPrefs<T>(string key, T defaultValue)
        {
            if (EditorPrefs.HasKey(key))
            {
                Type tt = typeof(T);
                try
                {
                    if (tt.IsEnum || tt.Matches(typeof(int), typeof(Int32)))
                    {
                        return (T)(object)EditorPrefs.GetInt(key, (int)(object)defaultValue);
                    }
                    else if (tt.IsArray)
                    {
                        throw new System.NotImplementedException();
                    }
                    else if (tt == typeof(string))
                        return (T)(object)EditorPrefs.GetString(key, defaultValue.ToString());
                    else if (tt == typeof(float))
                        return (T)(object)EditorPrefs.GetFloat(key, (float)(object)defaultValue);
                    else if (tt == typeof(bool))
                        return (T)(object)EditorPrefs.GetBool(key, (bool)(object)defaultValue);
                    else if (tt == typeof(Color))
                        return (T)(object)EditorPrefs.GetString(key, ((Color)(object)defaultValue).ToHtml()).ColorFromHtml();
                    else
                        DTLog.LogError("[DevTools] SetEditorPrefs: Unsupported datatype: " + tt.Name);
                }
                catch (Exception e)
                {
                    Debug.LogException(e);
                    return defaultValue;
                }
            }
            return defaultValue;
        }

        public static string[] GetEditorPrefs(string key)
        {
            string arrayString = GetEditorPrefs(key, String.Empty);
            return String.IsNullOrEmpty(arrayString) ? new string[0] : arrayString.Split(editorPreferencesArraySeparator);
        }

        #endregion

        #region ### Utilities ###

        /// <summary>
        /// Opens Unity's preferences window
        /// </summary>
        public static void OpenPreferencesWindow()
        {
            SettingsService.OpenUserPreferences();
        }

        /// <summary>
        /// Opens Unity's preferences window at a specific path. The path should be the same than the one of the associated <see cref="SettingsProvider"/>
        /// </summary>
        public static void OpenPreferencesWindow(string settingsPath)
        {
            SettingsService.OpenUserPreferences(settingsPath);
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DT.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTDebugWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e278c12763ea71f4fbb47021df15a348
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using UnityEditor;

namespace FluffyUnderware.DevToolsEditor
{
    public class DTDebugWindow : EditorWindow
    {
        string Label;
        public string Text
        {
            get { return string.Join("", texts); }
            set
            {
                int size = Mathf.FloorToInt(value.Length / 16382);
                texts = new string[size];
                for (int i = 0; i < size; i++)
                {
                    texts[i] = value.Substring(i * 16382, 16382);
                }
            }
        }
        Vector2 scroll;

        string[] texts;

        GUIStyle stHtmlArea;

        public static void Open(string label, string text, string windowName="Debug Dump")
        {
            DTDebugWindow win = EditorWindow.GetWindow<DTDebugWindow>(true, windowName);
            win.Label = label;
            win.Text = text;
        }

        void OnGUI()
        {
            if (stHtmlArea == null)
            {
                stHtmlArea = new GUIStyle(EditorStyles.textArea);
                stHtmlArea.richText = true;
            }
            GUILayout.Label(Label, EditorStyles.boldLabel);
            scroll = GUILayout.BeginScrollView(scroll);
            for (int i=0;i<texts.Length;i++)
                if (i==texts.Length-1)
                    GUILayout.TextArea(texts[i],stHtmlArea,GUILayout.ExpandHeight(true));
                else
                    GUILayout.TextArea(texts[i], stHtmlArea);
            GUILayout.EndScrollView();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTDebugWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 74ac27c5ac9d99c4d8071cdcc6c7c3aa
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using System.Collections.Generic;
using UnityEditor;
using FluffyUnderware.DevToolsEditor.Extensions;
using FluffyUnderware.DevTools;
using System;
using UnityEditorInternal;
using UnityEditor.AnimatedValues;
using UnityEngine.Events;
using Object = UnityEngine.Object;

namespace FluffyUnderware.DevToolsEditor
{
    public class DTEditor<T> : Editor where T : UnityEngine.Object
    {
        #region ### Public Properties ###

        /// <summary>
        /// Target Script
        /// </summary>
        public virtual T Target
        {
            get
            {
                return (target != null) ? target as T : null;
            }
        }

        /// <summary>
        /// Whether the target is currently selected or not
        /// </summary>
        public bool TargetIsActive
        {
            get
            {
                if (target is MonoBehaviour)
                    return (target != null && ((MonoBehaviour)target).transform == Selection.activeTransform);
                else
                    return true;
            }
        }

        /// <summary>
        /// Whether the target is part of a prefab
        /// </summary>
        /// <remarks>Has issues with the new prefab system. See the comments in the code that assigns IsPrefab's value to know more about this</remarks>
        // TODO Has issues with the new prefab system. See the comments in the code that assigns IsPrefab's value to know more about this
        [Obsolete("Will get removed in the next major version. Use Unity's PrefabUtility to know if this.Target is part of a prefab")]
        public bool IsPrefab { get; private set; }

        public bool IsInsideInspector { get; private set; }


        /// <summary>
        /// The Root node of all inspector fields
        /// </summary>
        public DTGroupNode Node
        {
            get
            {
                return mRootNode;
            }
        }

        /// <summary>
        /// The renderer used to render inspector fields
        /// </summary>
        public IDTInspectorNodeRenderer NodeRenderer
        {
            get
            {
                return mNodeRenderer;
            }
            set
            {
                mNodeRenderer = value;
            }
        }
        /// <summary>
        /// Whether the inspector needs a repaint
        /// </summary>
        public bool NeedRepaint { get; set; }

        #endregion


        DTGroupNode mRootNode;
        IDTInspectorNodeRenderer mNodeRenderer = new DTInspectorNodeDefaultRenderer();
        bool mEnterChildren;

        #region ### Public Methods ###




        #endregion


        #region ### Protected Methods (override to change inspector appearance) ###

        protected virtual void OnEnable()
        {
            if (mRootNode == null)
                mRootNode = new DTGroupNode("Root");
            Undo.undoRedoPerformed -= OnUndoRedo;
            Undo.undoRedoPerformed += OnUndoRedo;
#pragma warning disable 618
            if (target != null)
            {
                PrefabAssetType prefabAssetType = PrefabUtility.GetPrefabAssetType(target);
                //BUG in the new prefab system, an instantiated prefab will have IsPrefab == true, while the documentation of the PrefabUtility.GetPrefabAssetType says otherwise. But is fixing this worth it knowing that IsPrefab is not used in Curvy when using the new prefab system?
                IsPrefab = prefabAssetType == PrefabAssetType.Regular || prefabAssetType == PrefabAssetType.Variant;
            }
            else
                IsPrefab = false;
#pragma warning restore 618
        }

        protected virtual void OnDisable()
        {
            if (mRootNode != null)
                mRootNode.Clear();
            Undo.undoRedoPerformed -= OnUndoRedo;
        }

        protected virtual void OnReadNodes()
        {
        }

        protected virtual void OnSceneGUI()
        {
        }

        public override void OnInspectorGUI()
        {
            RenderGUI(false);
        }

        public void RenderGUI(bool embedded = false)
        {
            if (Target == null)
                return;
#if UNITY_5_6_OR_NEWER
            serializedObject.UpdateIfRequiredOrScript();
#else
            serializedObject.UpdateIfDirtyOrScript();
#endif

            if (Node.Count == 0)
                ReadNodes();

            NeedRepaint = false;

            if (mRootNode)
            {
                DTInspectorNode.IsInsideInspector = !embedded;
                IsInsideInspector = !embedded;
                OnCustomInspectorGUIBefore();
                renderNode(mRootNode);
                OnCustomInspectorGUI();
            }
            if (serializedObject.ApplyModifiedProperties())
                OnModified();

            GUI.SetNextControlName("");

            if (NeedRepaint)
                Repaint();
        }

        protected virtual void OnModified()
        {
        }

        // <summary>
        /// Add custom GUI code here, rendered before the default inspector
        /// </summary>
        protected virtual void OnCustomInspectorGUIBefore()
        {
        }

        /// <summary>
        /// Add custom GUI code here, rendered after the default inspector
        /// </summary>
        protected virtual void OnCustomInspectorGUI()
        {
        }

        /// <summary>
        /// Called to initialize a ReorderableList. Override to add custom behaviour
        /// </summary>
        /// <param name="node">field node</param>
        /// <param name="attribute">ArrayEx attribute of the field</param>
        protected virtual void SetupArrayEx(DTFieldNode node, ArrayExAttribute attribute)
        {
            // Defaults
            if (attribute.ShowHeader)
            {
                node.ArrayEx.drawHeaderCallback = (Rect r) =>
                {
                    EditorGUI.LabelField(r, node.GUIContent);
                    if (attribute.DropTarget)
                    {
                        Event ev = Event.current;
                        switch (ev.type)
                        {
                            case EventType.DragUpdated:
                                if (r.Contains(ev.mousePosition))
                                {
                                    Type fieldType = node.serializedProperty.GetFieldType();
                                    //bug? this code is called when dragging a game object over the list of Input Spots, but not the list of Input Game Objects. Why? Both have the ArrayExAttribute with ShowHeader being true
                                    bool allowed = DragAndDrop.objectReferences.Length > 0 && DTEditorUtility.DragDropTypeMatch(fieldType);
                                    DragAndDrop.visualMode = allowed ? DragAndDropVisualMode.Copy : DragAndDropVisualMode.Rejected;
                                }
                                break;
                            case EventType.DragPerform:
                                if (r.Contains(ev.mousePosition))
                                {
                                    Object[] objs = DTEditorUtility.DragDropGetObjectsOfType(node.serializedProperty.GetFieldType());

                                    foreach (Object o in objs)
                                    {
                                        int idx = node.serializedProperty.arraySize;
                                        node.serializedProperty.InsertArrayElementAtIndex(idx);
                                        node.serializedProperty.GetArrayElementAtIndex(idx).objectReferenceValue = o;
                                    }
                                    node.serializedObject.ApplyModifiedProperties();
                                }
                                break;
                        }
                    }
                };
            }

            node.ArrayEx.drawElementCallback = (Rect r, int index, bool isActive, bool isFocused) =>
            {
                SerializedProperty e = node.ArrayEx.serializedProperty.GetArrayElementAtIndex(index);
                if (e != null)
                    EditorGUI.PropertyField(r, e);
            };
        }

        /// <summary>
        /// Called when UndoRedo occured
        /// </summary>
        public virtual void OnUndoRedo()
        {
        }

        #endregion


        /// <summary>
        /// builds node tree and process parsing attributes
        /// </summary>
        public void ReadNodes()
        {
            DTGroupNode._serializedObject = serializedObject;
            SerializedProperty iterator = serializedObject.GetIterator();
            mRootNode.Clear();
            mEnterChildren = true;

            DTGroupNode baseNode = mRootNode;
            DTGroupNode parentNode = baseNode;
            Stack<string> propertyPathStack = new Stack<string>();
            Stack<DTGroupNode> baseNodeStack = new Stack<DTGroupNode>();
            bool resetParent = false;

            while (iterator.NextVisible(mEnterChildren))
            {
                mEnterChildren = false;
                if (iterator.name != "m_Script" && iterator.name != "InspectorFoldout")
                {
                    // handle baseNode resetting (AsGroup etc...)
                    while (propertyPathStack.Count > 0 && !iterator.propertyPath.StartsWith(propertyPathStack.Peek()))
                    {
                        propertyPathStack.Pop();
                        baseNode = baseNodeStack.Pop();
                        parentNode = baseNode;
                    }


                    DTFieldNode fieldNode = new DTFieldNode(iterator);

                    // get group parsing attributes 
                    List<Attribute> groupParseAttribs = iterator.GetAttributes(typeof(IDTGroupParsingAttribute));
                    groupParseAttribs.Sort();
                    // get field parsing attributes
                    List<Attribute> parsingAttributes = iterator.GetAttributes(typeof(IDTFieldParsingAttribute));

                    foreach (IDTGroupParsingAttribute ga in groupParseAttribs)
                    {

                        if (ga is TabAttribute)
                        {
                            TabAttribute tabA = (TabAttribute)ga;
                            parentNode = baseNode.EnsurePath(tabA.Path, false);

                            if (!string.IsNullOrEmpty(tabA.TabBarName) && !string.IsNullOrEmpty(tabA.TabName))
                            {
                                if (!parentNode[tabA.TabBarName])
                                    parentNode = (DTGroupNode)parentNode.Add(new DTGroupNode(tabA.TabBarName, null, DTInspectorNode.RenderAsEnum.TabBar));
                                else
                                    parentNode = (DTGroupNode)parentNode[tabA.TabBarName];
                                if (!parentNode[tabA.TabName])
                                    parentNode = (DTGroupNode)parentNode.Add(new DTGroupNode(tabA.TabName, iterator, DTInspectorNode.RenderAsEnum.Tab));
                                else
                                    parentNode = (DTGroupNode)parentNode[tabA.TabName];
                                if (tabA.Sort != 100)
                                    parentNode.SortOrder = tabA.Sort;
                            }
                            else
                                DTLog.LogWarningFormat(Target, "[DevTools] Skipping [Tab] on '{0}' because Path is missing TabBar or Tab!", iterator.propertyPath);

                        }
                        else if (ga is SectionAttribute)
                        {
                            SectionAttribute sectionA = (SectionAttribute)ga;
                            parentNode = createGroup(baseNode, sectionA.Path, iterator);
                            if (sectionA.Sort != 100)
                                parentNode.SortOrder = sectionA.Sort;
                        }
                        else if (ga is AsGroupAttribute)
                        {
                            AsGroupAttribute asGroupA = (AsGroupAttribute)ga;
                            propertyPathStack.Push(fieldNode.SerializedPropertyPath);
                            baseNodeStack.Push(baseNode);
                            parentNode = createGroup((asGroupA.PathIsAbsolute) ? baseNode : parentNode, (asGroupA.Path == null) ? fieldNode.Name : asGroupA.Path + "/" + fieldNode.Name, iterator);
                            baseNode = parentNode;

                        }
                        else if (ga is GroupAttribute)
                        {
                            GroupAttribute groupA = (GroupAttribute)ga;
                            parentNode = createGroup(baseNode, groupA.Path, iterator);
                            if (groupA.Sort != 100)
                                parentNode.SortOrder = groupA.Sort;
                            resetParent = true;
                        }
                    }

                    foreach (IDTFieldParsingAttribute pa in parsingAttributes)
                    {
                        if (pa is Hide)
                        {
                            fieldNode.Visible = false;
                            fieldNode.ContentVisible = false;
                            mEnterChildren = false;
                        }
                        else if (pa is AsGroupAttribute || pa is Inline)
                        {
                            fieldNode.Visible = false;
                            fieldNode.ContentVisible = false;
                            mEnterChildren = true;

                        }
                        else if (pa is ArrayExAttribute)
                        {
                            ArrayExAttribute arrayA = (ArrayExAttribute)pa;
                            fieldNode.ArrayEx = new ReorderableList(serializedObject, iterator, arrayA.Draggable, arrayA.ShowHeader, arrayA.ShowAdd, arrayA.ShowDelete);
                            SetupArrayEx(fieldNode, arrayA);
                        }
                        else if (pa is SortOrderAttribute)
                        {
                            fieldNode.SortOrder = ((SortOrderAttribute)pa).Sort;
                        }

                    }

                    parentNode.Add(fieldNode);
                    if (resetParent)
                    {
                        parentNode = parentNode.Parent as DTGroupNode;
                        resetParent = false;
                    }
                }
            }
            OnReadNodes();
            Node.Sort();
        }

        /// <summary>
        /// Renders the node tree and process rendering attributes
        /// </summary>
        /// <param name="node"></param>
        void renderNode(DTInspectorNode node)
        {
            if (serializedObject == null)
                return;
            bool guistate = GUI.enabled;
            DTInspectorNode item;
            for (int i = 0; i < node.Items.Count; i++)
            {
                item = node[i];
                item.serializedObject = serializedObject;

                if (item.Disabled)
                    GUI.enabled = false;
                if (item is DTFieldNode)
                {

                    DTFieldNode field = (DTFieldNode)item;

                    field.serializedProperty = serializedObject.FindProperty(field.SerializedPropertyPath);
                    if (field.serializedProperty == null)
                        return;
                    field.Calculate();

                    if (field.Visible)
                    {
                        foreach (ActionAttribute act in item.Actions)
                            if (act.Position == ActionAttribute.ActionPositionEnum.Above)
                                NodeRenderer.RenderAction(item, act, this, Target);

                        if (field.ArrayEx != null)
                        {
                            field.ArrayEx.serializedProperty = field.serializedProperty;
                            field.ArrayEx.DoLayoutList();
                        }
                        else
                        {
                            NodeRenderer.RenderField(field);
                            field.raiseOnRender();
                        }

                        foreach (ActionAttribute act in item.Actions)
                            if (act.Position == ActionAttribute.ActionPositionEnum.Below)
                                NodeRenderer.RenderAction(item, act, this, Target);
                    }

                }
                else if (item is DTGroupNode)
                {
                    DTGroupNode group = (DTGroupNode)item;
                    group.Calculate();

                    if (group.Visible)
                    {
                        foreach (ActionAttribute act in item.Actions)
                            if (act.Position == ActionAttribute.ActionPositionEnum.Above)
                                NodeRenderer.RenderAction(item, act, this, Target);

                        if (group.Disabled)
                            GUI.enabled = false;

                        switch (item.RenderAs)
                        {
                            case DTInspectorNode.RenderAsEnum.Section:
                                NodeRenderer.RenderSectionHeader(group);
                                if (group.ContentVisible)
                                {
                                    renderNode(group);
                                    group.raiseOnRender();
                                }
                                NodeRenderer.RenderSectionFooter(group);
                                break;
                            case DTInspectorNode.RenderAsEnum.TabBar:
                                NodeRenderer.RenderTabBarHeader(group, (group.MaxItemsPerRow == -1) ? group.Items.Count : group.MaxItemsPerRow);
                                if (group.SelectedIndex > -1)
                                {
                                    renderNode(group[group.SelectedIndex]);
                                    group[group.SelectedIndex].raiseOnRender();
                                }
                                NodeRenderer.RenderTabBarFooter(group);
                                break;
                            default:
                                if (group.ContentVisible)
                                    renderNode(group);
                                break;
                        }

                        foreach (ActionAttribute act in item.Actions)
                            if (act.Position == ActionAttribute.ActionPositionEnum.Below)
                                NodeRenderer.RenderAction(item, act, this, Target);

                    }

                }
                GUI.enabled = guistate;
                if (item.NeedRepaint)
                {
                    item.NeedRepaint = false;
                    NeedRepaint = true;
                }
            }
        }

        /// <summary>
        /// Creates a parent group for a field, creating the path if neccessary
        /// </summary>
        /// <param name="baseNode">"root" the path is applied to</param>
        /// <param name="path">node path</param>
        /// <param name="forProperty">field property the parent node is for</param>
        /// <returns></returns>
        DTGroupNode createGroup(DTGroupNode baseNode, string path, SerializedProperty forProperty)
        {
            DTGroupNode node = baseNode.EnsurePath(path, false, forProperty);
            return node;
        }



    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTEditorClasses.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c82ecfa39ebfe4a4984a5602b822ca2d
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using UnityEditor;
using System;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevToolsEditor.Extensions;
using System.Collections.Generic;
using UnityEditor.AnimatedValues;
using UnityEditorInternal;

namespace FluffyUnderware.DevToolsEditor
{
    public delegate void DTInspectorNodeEvent(DTInspectorNode e);

    /// <summary>
    /// Base Node class
    /// </summary>
    public class DTInspectorNode : IComparable
    {
        public static bool IsInsideInspector { get; set; }
        public event DTInspectorNodeEvent OnNodeRender;

        public enum RenderAsEnum { Invisible, Section, TabBar, Tab, Field };
        /// <summary>
        /// How to render this node
        /// </summary>
        public RenderAsEnum RenderAs = RenderAsEnum.Field;
        /// <summary>
        /// Gets a list of actions of this node
        /// </summary>
        public List<ActionAttribute> Actions = new List<ActionAttribute>();
        /// <summary>
        /// Parent node
        /// </summary>
        public DTInspectorNode Parent;
        /// <summary>
        /// Child nodes
        /// </summary>
        public List<DTInspectorNode> Items = new List<DTInspectorNode>();
        /// <summary>
        /// Gets the number of child nodes
        /// </summary>
        public int Count { get { return Items.Count; } }
        /// <summary>
        /// Gets all attributes for this node
        /// </summary>
        public List<Attribute> Attributes;
        /// <summary>
        /// Node name
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Whether the node is expanded/visible or not
        /// </summary>
        public virtual bool Expanded { get; set; }
        /// <summary>
        /// Whether this node needs a repaint
        /// </summary>
        public virtual bool NeedRepaint { get; set; }
        /// <summary>
        /// Whether child nodes are visible or not
        /// </summary>
        public virtual bool ContentVisible
        {
            get { return mContentVisible; }
            set { mContentVisible = value; }
        }

        /// <summary>
        /// Whether this node is visible or not
        /// </summary>
        public virtual bool Visible
        {
            get { return mVisible; }
            set { mVisible = value; }
        }
        /// <summary>
        /// Whether this node is disabled or not
        /// </summary>
        public virtual bool Disabled { get; set; }
        /// <summary>
        /// The serializedObject currently processed
        /// </summary>
        public SerializedObject serializedObject { get; set; }
        /// <summary>
        /// Label/Icon/Tooltip of this node
        /// </summary>
        public GUIContent GUIContent { get; set; }
        /// <summary>
        /// The absolute Path of this node
        /// </summary>
        public string Path
        {
            get
            {
                return (Parent) ? Parent.Path + "/" + Name : Name;
            }
        }
        /// <summary>
        /// The nesting Level of this node
        /// </summary>
        public int Level { get; private set; }
        /// <summary>
        /// Sort order
        /// </summary>
        public int SortOrder { get; set; }

        /// <summary>
        /// Gets a child node by it's index
        /// </summary>
        /// <param name="index">index of the child</param>
        /// <returns>a node or null</returns>
        public DTInspectorNode this[int index]
        {
            get
            {
                return Items[index];
            }
        }
        /// <summary>
        /// Gets a child node by it's name
        /// </summary>
        /// <param name="name">name of the child</param>
        /// <returns>a node or null</returns>
        public DTInspectorNode this[string name]
        {
            get
            {
                return Items.Find(x => x.Name.Equals(name, StringComparison.CurrentCultureIgnoreCase));
            }
        }

        public int Index { get; protected set; }



        bool mContentVisible = true;
        bool mVisible = true;


        protected DTInspectorNode(string name)
        {
            SortOrder = 100;
            Name = name;
        }

        public virtual int CompareTo(object obj)
        {
            DTInspectorNode other = (DTInspectorNode)obj;
            int c = SortOrder.CompareTo(other.SortOrder);
            return (c != 0) ? c : Index.CompareTo(other.Index);
        }
        /// <summary>
        /// Clear everything the node contains
        /// </summary>
        public virtual void Clear()
        {
            for (int i = 0; i < Items.Count; i++)
                Items[i].Clear();
            Items.Clear();
        }

        public virtual DTInspectorNode Add(DTInspectorNode node)
        {
            if (node != null)
            {
                Items.Add(node);
                node.Index = Items.IndexOf(node);
                node.Parent = this;
                node.Level = node.Parent.Level + 1;
            }
            return node;
        }

        public virtual void Calculate(bool firstRun = false) { }

        public void Delete()
        {
            foreach (DTInspectorNode it in Items)
                it.Delete();
            if (Parent)
            {
                Parent.Items.Remove(this);
                Parent.Sort(); // to reset Index
            }
            Parent = null;
        }

        /// <summary>
        /// Get a certain attribute
        /// </summary>
        /// <typeparam name="T">Type of the attribute</typeparam>
        /// <returns>the attribute or null</returns>
        public T GetAttribute<T>() where T : Attribute
        {
            return Attributes.Find(x => x.GetType().IsAssignableFrom(typeof(T))) as T;
        }

        /// <summary>
        /// Gets all attributes
        /// </summary>
        /// <typeparam name="T">Type of the attribute</typeparam>
        /// <returns>all attributes</returns>
        public T[] GetAllAttributes<T>() where T : Attribute
        {
            List<Attribute> res = Attributes.FindAll(x => x.GetType().IsAssignableFrom(typeof(T)));
            T[] r = new T[res.Count];
            for (int i = 0; i < res.Count; i++)
                r[i] = (T)res[i];
            return r;
        }

        public static implicit operator bool(DTInspectorNode a)
        {
            return !object.ReferenceEquals(a, null);
        }

        /// <summary>
        /// Search for a node at a specific path
        /// </summary>
        /// <typeparam name="T">Type of the node in question</typeparam>
        /// <param name="name">Path and Name of the node in question</param>
        /// <param name="node">The search result or null</param>
        /// <returns>true if found</returns>
        public bool FindNodeAt<T>(string pathAndName, out T node) where T : DTInspectorNode
        {
            string[] p = pathAndName.Split('/');
            node = null;
            DTInspectorNode N = this;
            for (int i = 0; i < p.Length; i++)
            {
                N = N[p[i]];
                if (N == null)
                    return false;
            }
            node = N as T;
            return node != null;
        }

        /// <summary>
        /// Search all child nodes for a node of the given type with a certain name
        /// </summary>
        /// <typeparam name="T">Type of the node in question</typeparam>
        /// <param name="name">Name of the node in question</param>
        /// <param name="node">The search result or null</param>
        /// <returns>true if found</returns>
        public bool FindNode<T>(string name, out T node) where T : DTInspectorNode
        {
            node = this[name] as T;
            if (node != null)
                return true;
            else
            {
                foreach (DTInspectorNode it in Items)
                    if (it.FindNode(name, out node))
                        return true;
            }
            return false;
        }
        /// <summary>
        /// Sort child nodes
        /// </summary>
        public void Sort()
        {
            Items.Sort();

            foreach (DTInspectorNode it in Items)
            {
                it.Index = Items.IndexOf(it);
                if (it is DTGroupNode)
                    it.Sort();
            }
        }

        internal void raiseOnRender()
        {
            if (OnNodeRender != null)
                OnNodeRender(this);
        }

    }

    /// <summary>
    /// Field Node class
    /// </summary>
    public class DTFieldNode : DTInspectorNode
    {
        public string SerializedPropertyPath;
        public SerializedProperty serializedProperty { get; set; }
        public bool IncludeChildren { get; set; }
        public ReorderableList ArrayEx { get; set; }
        public string Tooltip { get; set; }
        public string HelpURL { get; set; }

        public DTFieldNode(SerializedProperty property) : base(property.name)
        {
            RenderAs = RenderAsEnum.Field;
            SerializedPropertyPath = property.propertyPath;
            Attributes = property.GetAttributes(typeof(IDTFieldRenderAttribute));
            Attributes.Sort();
            GUIContent = new GUIContent(ObjectNames.NicifyVariableName(Name));
            Calculate(true);
        }

        public override void Calculate(bool firstRun = false)
        {
            IncludeChildren = true;
            Visible = true;
            Disabled = false;
            Actions.Clear();
            foreach (IDTFieldRenderAttribute a in Attributes)
            {
                if (a is Hide || a is AsGroupAttribute)
                {
                    Visible = false;
                    ContentVisible = false;
                    IncludeChildren = false;
                }
                else if (a is Inline)
                {
                    Visible = false;
                    IncludeChildren = true;
                }

                else if (serializedProperty != null)
                {
                    if (a is FieldConditionAttribute)
                    {
                        FieldConditionAttribute condA = (FieldConditionAttribute)a;
                        bool met = condA.ConditionMet(serializedProperty.serializedObject.targetObject);

                        switch (condA.Action)
                        {
                            case ConditionalAttribute.ActionEnum.Show:
                                Visible = met;
                                break;
                            case ConditionalAttribute.ActionEnum.Hide:
                                Visible = !met;
                                break;
                            case ConditionalAttribute.ActionEnum.Enable:
                                Disabled = !met;
                                break;
                            case ConditionalAttribute.ActionEnum.Disable:
                                Disabled = met;
                                break;
                            default:
                                if (met)
                                    Actions.Add(condA);
                                break;
                        }

                    }
                    else if (a is FieldActionAttribute)
                    {
                        Actions.Add((FieldActionAttribute)a);
                    }
                }
            }

        }



    }

    /// <summary>
    /// Group node class
    /// </summary>
    public class DTGroupNode : DTInspectorNode
    {

        static internal SerializedObject _serializedObject;

        public override bool Expanded
        {
            get
            {
                return mState.target;
            }
            set
            {

                if (mState.target != value)
                {
                    mState.target = value;
                    if (serializedObject != null)
                        DTPersistentState.SetBool(serializedObject.targetObject.GetInstanceID().ToString() + Path, value);
                    NeedRepaint = true;
                }
            }
        }

        public float ExpandedFaded
        {
            get
            {
                return mState.faded;
            }
        }

        public override bool ContentVisible
        {
            get
            {
                return base.ContentVisible && ExpandedFaded != 0;
            }
            set
            {
                base.ContentVisible = value;
            }
        }

        public override bool NeedRepaint
        {
            get
            {
                return mState.isAnimating;
            }
        }

        public string HelpURL { get; set; }
        public bool Fixed { get; set; }




        #region --- Tab Bar Properties ---

        public int SelectedIndex
        {
            get
            {
                return Count > 0 ? Mathf.Clamp(mSelectedItem, 0, Count - 1) : -1;
            }
            set
            {
                mSelectedItem = Count > 0 ? Mathf.Clamp(value, 0, Count - 1) : -1;
            }
        }

        public DTInspectorNode SelectedItem
        {
            get
            {
                return (SelectedIndex != -1) ? Items[SelectedIndex] : null;
            }
            set
            {
                SelectedIndex = (value == null) ? -1 : value.Index;
            }
        }

        public int MaxItemsPerRow { get; set; }

        #endregion

        readonly AnimBool mState = new AnimBool(true);
        int mSelectedItem = -1;

        public DTGroupNode(string name, SerializedProperty forProperty = null, RenderAsEnum renderAs = RenderAsEnum.Section) : base(name)
        {
            RenderAs = renderAs;
            MaxItemsPerRow = -1;
            if (forProperty != null)
            {
                Attributes = forProperty.GetAttributes(typeof(IDTGroupRenderAttribute));
                Attributes.Sort();
                Calculate(true);
            }
            else
            {
                Attributes = new List<Attribute>();
                GUIContent = new GUIContent(ObjectNames.NicifyVariableName(Name));
            }

        }

        public override void Calculate(bool firstRun = false)
        {
            Actions.Clear();
            foreach (IDTGroupRenderAttribute a in Attributes)
            {
                if (a is GroupAttribute)
                {
                    GroupAttribute groupA = (GroupAttribute)a;
                    if (groupA.Invisible)
                        RenderAs = RenderAsEnum.Invisible;
                    if (firstRun)
                    {
                        mState.value = groupA.Expanded;
                        getAdditionalGroupParams(groupA);
                    }
                }
                else if (serializedObject != null)
                {
                    if (a is GroupConditionAttribute)
                    {
                        GroupConditionAttribute condA = (GroupConditionAttribute)a;
                        bool met = condA.ConditionMet(serializedObject.targetObject);

                        switch (condA.Action)
                        {
                            case ConditionalAttribute.ActionEnum.Show:
                                Visible = met;
                                break;
                            case ConditionalAttribute.ActionEnum.Hide:
                                Visible = !met;
                                break;
                            case ConditionalAttribute.ActionEnum.Enable:
                                Disabled = !met;
                                break;
                            case ConditionalAttribute.ActionEnum.Disable:
                                Disabled = met;
                                break;
                            default:
                                if (met)
                                    Actions.Add(condA);
                                break;
                        }

                    }
                    else if (a is GroupActionAttribute)
                    {
                        Actions.Add((GroupActionAttribute)a);
                    }
                }
            }
        }

        void getAdditionalGroupParams(GroupAttribute a)
        {
            if (a == null)
            {
                GUIContent = new GUIContent(ObjectNames.NicifyVariableName(Name));
            }
            else
            {
                GUIContent = new GUIContent(a.Label ?? ObjectNames.NicifyVariableName(Name), a.Tooltip);
                HelpURL = a.HelpURL;
            }
        }

        public DTGroupNode EnsurePath(string path, bool includesName = false, SerializedProperty forProperty = null)
        {
            DTGroupNode node = this;
            if (!string.IsNullOrEmpty(path))
            {
                string[] p = path.Split('/');
                int hi = (includesName) ? p.Length - 1 : p.Length;
                for (int i = 0; i < hi; i++)
                {
                    DTGroupNode sub = node[p[i]] as DTGroupNode;
                    if (sub == null)
                    {
                        if (forProperty != null && i == hi - 1)
                            sub = new DTGroupNode(p[i], forProperty);
                        else
                            sub = new DTGroupNode(p[i]);
                        node.Add(sub);
                    }
                    node = sub;
                }
            }
            return node;
        }

        public GUIContent[] GetItemsGUIContent()
        {
            GUIContent[] res = new GUIContent[Count];
            for (int i = 0; i < Count; i++)
                res[i] = this[i].GUIContent;
            return res;
        }

        public DTGroupNode FindTabBarAt(string nameAndPath)
        {
            DTGroupNode node;
            if (FindNodeAt(nameAndPath, out node))
                if (node.RenderAs == RenderAsEnum.TabBar)
                    return node;
            return null;
        }

        public override DTInspectorNode Add(DTInspectorNode node)
        {
            node = base.Add(node);
            DTGroupNode grp = node as DTGroupNode;
            if (grp != null && _serializedObject != null && _serializedObject.targetObject != null)
                grp.mState.value = DTPersistentState.GetBool(_serializedObject.targetObject.GetInstanceID().ToString() + grp.Path, grp.mState.value);

            return node;
        }

        public DTGroupNode AddSection(string name, DTInspectorNodeEvent func)
        {
            DTInspectorNode item = this[name];
            if (item)
            {
                if (item.RenderAs != RenderAsEnum.Section)
                    return null;
            }
            else
            {
                item = new DTGroupNode(name, null, RenderAsEnum.Section);
                Add(item);
                item.OnNodeRender += func;
            }
            return item as DTGroupNode;
        }

        public DTGroupNode AddTab(string name, DTInspectorNodeEvent func)
        {
            if (RenderAs == RenderAsEnum.TabBar)
            {
                DTInspectorNode item = this[name];
                if (item)
                {
                    if (item.RenderAs != RenderAsEnum.Tab)
                        return null;
                }
                else
                {
                    item = new DTGroupNode(name, null, RenderAsEnum.Tab);
                    Add(item);
                    item.OnNodeRender += func;
                }
                return item as DTGroupNode;
            }
            return null;
        }


    }



    public static class DTPersistentState
    {
        static readonly Dictionary<string, bool> _states = new Dictionary<string, bool>();


        public static bool GetBool(string ident, bool defaultState = true)
        {

            bool res;
            if (!_states.TryGetValue(ident, out res))
            {
                res = defaultState;
                _states.Add(ident, defaultState);
            }
            return res;
        }

        public static void SetBool(string ident, bool state)
        {
            if (!_states.ContainsKey(ident))
                _states.Add(ident, state);
            else
                _states[ident] = state;
        }

    }

    #region ### Renderer ###

    public interface IDTInspectorNodeRenderer
    {
        void RenderTabBarHeader(DTGroupNode node, int maxItemsPerRow);
        void RenderTabBarFooter(DTGroupNode node);
        void RenderSectionHeader(DTGroupNode node);
        void RenderSectionFooter(DTGroupNode node);
        void RenderField(DTFieldNode node);
        void RenderAction(DTInspectorNode node, ActionAttribute action, System.Object editorObject, System.Object targetObject);
    }

    public class DTInspectorNodeDefaultRenderer : IDTInspectorNodeRenderer
    {


        public static Texture HelpIcon
        {
            get
            {
                if (mHelpIcon == null)
                    mHelpIcon = (Texture)EditorGUIUtility.Load("icons/_Help.png");
                return mHelpIcon;
            }
        }
        static Texture mHelpIcon;
        public static GUIStyle BoldFoldout
        {
            get
            {
                if (mBoldFoldout == null)
                {
                    mBoldFoldout = new GUIStyle(EditorStyles.foldout);
                    mBoldFoldout.fontStyle = FontStyle.Bold;
                    mBoldFoldout.margin.top += 2;
                    mBoldFoldout.margin.bottom += 4;

                }
                return mBoldFoldout;
            }
        }
        static GUIStyle mBoldFoldout;

        public static GUIStyle TabbarButton
        {
            get
            {
                if (mTabbarButton == null)
                {
                    mTabbarButton = new GUIStyle(EditorStyles.toolbarButton);
                    mTabbarButton.alignment = TextAnchor.MiddleCenter;

                    GUIStyle skinButton = GUI.skin.button;
                    RectOffset skinButtonPadding = skinButton.padding;
                    RectOffset skinButtonMargin = skinButton.margin;
                    RectOffset skinButtonBorder = skinButton.border;
                    RectOffset skinButtonOverflow = skinButton.overflow;

                    mTabbarButton.padding = new RectOffset(skinButtonPadding.left, skinButtonPadding.right, skinButtonPadding.top, skinButtonPadding.bottom);
                    mTabbarButton.margin = new RectOffset(skinButtonMargin.left, skinButtonMargin.right, skinButtonMargin.top, skinButtonMargin.bottom);
                    mTabbarButton.border = new RectOffset(skinButtonBorder.left, skinButtonBorder.right, skinButtonBorder.top, skinButtonBorder.bottom);
                    mTabbarButton.overflow = new RectOffset(skinButtonOverflow.left, skinButtonOverflow.right, skinButtonOverflow.top, skinButtonOverflow.bottom);
                }

                return mTabbarButton;
            }
        }
        static GUIStyle mTabbarButton;

        public virtual void RenderAction(DTInspectorNode node, ActionAttribute action, System.Object editorObject, System.Object targetObject)
        {
            switch (action.Action)
            {
                case ActionAttribute.ActionEnum.ShowInfo:
                    EditorGUILayout.HelpBox(action.ActionData as string, MessageType.Info);
                    return;
                case ActionAttribute.ActionEnum.ShowWarning:
                    EditorGUILayout.HelpBox(action.ActionData as string, MessageType.Warning);
                    return;
                case ActionAttribute.ActionEnum.ShowError:
                    EditorGUILayout.HelpBox(action.ActionData as string, MessageType.Error);
                    return;
                case ActionAttribute.ActionEnum.Callback:
                    action.Callback(editorObject);
                    return;
            }
        }

        public virtual void RenderField(DTFieldNode node)
        {
            EditorGUILayout.PropertyField(node.serializedProperty, node.IncludeChildren);
        }

        public virtual void RenderSectionHeader(DTGroupNode node)
        {
            GUILayout.Space(10);

            string helpUrl = node.HelpURL;

            Rect controlRect = EditorGUILayout.GetControlRect(false, 16);
            int xOffset = (node.Level <= 1 && DTInspectorNode.IsInsideInspector) ? 12 : 0;
            controlRect.x -= xOffset;

            bool toggleState = node.Expanded;
            int indentLevel = RenderHeader(controlRect, xOffset, helpUrl, node.GUIContent, ref toggleState);

            node.Expanded = toggleState;
            EditorGUILayout.BeginFadeGroup(node.ExpandedFaded);
            EditorGUI.indentLevel = (node.Level <= 1) ? indentLevel : indentLevel + 1;
        }

#pragma warning disable 162
#pragma warning disable 429
        private static readonly Color SectionHeaderBackgroundColor = new Color(1f, 1f, 1f);
#pragma warning restore 429
#pragma warning restore 162
        public static int RenderHeader(Rect controlRect, int xOffset, string helpUrl, GUIContent toggleGuiContent, ref bool toggleState)
        {
            int indentLevel = EditorGUI.indentLevel;
            EditorGUI.indentLevel = Mathf.Max(0, indentLevel - 1);
            controlRect = EditorGUI.IndentedRect(controlRect);
            DTGUI.PushColor(SectionHeaderBackgroundColor);
            const int additionalHeight = 4;
            Rect boxRectangle = new Rect(controlRect.x, controlRect.y - 2, controlRect.width + xOffset + 1, controlRect.height + additionalHeight);
            GUI.Box(boxRectangle, "", GUI.skin.box);
            DTHandles.DrawOutline(boxRectangle, Color.black);
            DTGUI.PopColor();

            Rect expandClickableArea = new Rect(controlRect);
            bool hasHelp = !string.IsNullOrEmpty(helpUrl);
            if (hasHelp)
                expandClickableArea.width -= 12;

            toggleState = GUI.Toggle(expandClickableArea, toggleState, toggleGuiContent, BoldFoldout);
            if (hasHelp)
            {
                if (GUI.Button(new Rect(boxRectangle.xMax - 20, boxRectangle.y + 3, 16, 16)
                    , new GUIContent(HelpIcon, "Help"), new GUIStyle()))
                    Application.OpenURL(helpUrl);
            }

            GUILayout.Space(additionalHeight);
            return indentLevel;
        }

        public virtual void RenderSectionFooter(DTGroupNode node)
        {
            if (node.Level > 1)
                EditorGUI.indentLevel--;
            EditorGUILayout.EndFadeGroup();
        }

        public virtual void RenderTabBarHeader(DTGroupNode node, int maxItemsPerRow)
        {
            GUILayout.Space(4);

            int s = GUILayout.SelectionGrid(node.SelectedIndex, node.GetItemsGUIContent(), Mathf.Min(node.Count, maxItemsPerRow), TabbarButton);
            if (s != node.SelectedIndex)
            {
                node.SelectedIndex = s;
                GUIUtility.keyboardControl = 0;
            }
            Color c = GUI.color;
            if (!EditorGUIUtility.isProSkin)
                GUI.color = new Color(c.r, c.g, c.b, 0.5f);

            GUILayout.BeginVertical(GUI.skin.box);
            GUI.color = c;
        }

        public virtual void RenderTabBarFooter(DTGroupNode node)
        {
            GUILayout.EndVertical();
        }

    }

    #endregion
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTEditorClasses.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTEditorUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7d1ee7bd8bdd696409b8ed1a10163e05
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using System.Reflection;
using System.Collections.Generic;
using FluffyUnderware.DevTools.Extensions;
using System.Collections;
using Object = UnityEngine.Object;

namespace FluffyUnderware.DevToolsEditor
{
    public static class DTEditorUtility
    {
        public static Camera ActiveCamera
        {
            get
            {
                return (SceneView.currentDrawingSceneView) ? SceneView.currentDrawingSceneView.camera : Camera.current;
            }
        }

        public static bool DragDropTypeMatch(System.Type type)
        {
            foreach (Object go in DragAndDrop.objectReferences)
            {
                if (go is GameObject)
                {
                    if (type.IsSubclassOf(typeof(Component)) == false)
                        return false;
                    if (((GameObject)go).GetComponent(type) == null)
                        return false;
                }

                else if (go.GetType() != type)
                    return false;
            }

            return true;
        }

        public static bool DragDropTypeMatch<T>() where T : Object
        {
            return DragDropTypeMatch(typeof(T));
        }

        public static Object[] DragDropGetObjectsOfType(System.Type type)
        {
            if (type.IsArrayOrList())
                return new Object[0];
            List<Object> res = new List<Object>();
            foreach (Object o in DragAndDrop.objectReferences)
            {
                if (o.GetType() == type)
                    res.Add(o);
                else if (o is GameObject)
                {
                    Component f = ((GameObject)o).GetComponent(type);
                    if (f != null)
                        res.Add(f);
                }
            }
            return res.ToArray();
        }

        public static T CreateAsset<T>() where T : ScriptableObject
        {
            T asset = ScriptableObject.CreateInstance<T>();
            ProjectWindowUtil.CreateAsset(asset, "New " + typeof(T).Name + ".asset");
            AssetDatabase.SaveAssets();
            return asset;
        }

        public static void ToggleSceneViewGizmos(bool gizmosOn)
        {
            ToggleSceneViewGizmos(gizmosOn, new string[0]);
        }

        public static void ToggleSceneViewGizmos(bool gizmosOn, params string[] scriptClasses)
        {
            int val = gizmosOn ? 1 : 0;
            List<string> classes = new List<string>(scriptClasses);
            Assembly asm = Assembly.GetAssembly(typeof(Editor));
            System.Type type = asm.GetType("UnityEditor.AnnotationUtility");
            if (type != null)
            {
                MethodInfo getAnnotations = type.GetMethod("GetAnnotations", BindingFlags.Static | BindingFlags.NonPublic);
                if (getAnnotations != null)
                {
                    MethodInfo setGizmoEnabled = type.GetMethod("SetGizmoEnabled", BindingFlags.Static | BindingFlags.NonPublic);
                    if (setGizmoEnabled != null)
                    {
                        MethodInfo setIconEnabled = type.GetMethod("SetIconEnabled", BindingFlags.Static | BindingFlags.NonPublic);
                        if (setIconEnabled != null)
                        {
                            object annotations = getAnnotations.Invoke(null, null);
                            foreach (object annotation in (IEnumerable)annotations)
                            {
                                Type annotationType = annotation.GetType();
                                FieldInfo classIdField = annotationType.GetField("classID", BindingFlags.Public | BindingFlags.Instance);
                                FieldInfo scriptClassField = annotationType.GetField("scriptClass", BindingFlags.Public | BindingFlags.Instance);
                                if (classIdField != null && scriptClassField != null)
                                {
                                    int classId = (int)classIdField.GetValue(annotation);
                                    string scriptClass = (string)scriptClassField.GetValue(annotation);
                                    if (classes.Count == 0 || classes.Contains(scriptClass))
                                    {
                                        setGizmoEnabled.Invoke(null, new object[] { classId, scriptClass, val });
                                        setIconEnabled.Invoke(null, new object[] { classId, scriptClass, val });
                                    }
                                }
                            }
                        }
                        else
                            Debug.LogError("Couldn't find method SetIconEnabled in type " + type.FullName);
                    }
                    else
                        Debug.LogError("Couldn't find method SetGizmoEnabled in type " + type.FullName);
                }
                else
                    Debug.LogError("Couldn't find method GetAnnotations in type " + type.FullName);
            }
            else
                Debug.LogError("Couldn't find type UnityEditor.AnnotationUtility in assembly " + asm.FullName);
        }

        public static List<T> LoadPrefabsContaining<T>(string path) where T : UnityEngine.Component
        {
            List<T> res = new List<T>();

            string[] gos = AssetDatabase.FindAssets("t:gameobject", new string[] { path });
            foreach (string id in gos)
            {
                GameObject go = AssetDatabase.LoadAssetAtPath<GameObject>(AssetDatabase.GUIDToAssetPath(id));
                T cmp = go.GetComponent<T>();
                if (cmp != null)
                    res.Add(cmp);
            }
            return res;
        }

    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTEditorUtility.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTGUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: ef286eb30f9728447bb8584e9a582119
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

namespace FluffyUnderware.DevToolsEditor
{
    public static class DTGUI
    {
        static readonly Stack<Color> _BGColorStack = new Stack<Color>();
        static readonly Stack<Color> _ColorStack = new Stack<Color>();
        static readonly Stack<Color> _ContentColorStack = new Stack<Color>();
        

        #region --- Colors ---

        public static void PushColor(Color col)
        {
            _ColorStack.Push(GUI.color);
            GUI.color = col;
        }

        public static void PopColor() 
        {
            GUI.color = _ColorStack.Pop();
        }

        public static void PushBackgroundColor(Color col)
        {
            _BGColorStack.Push(GUI.color);
            GUI.color = col;
        }

        public static void PopBackgroundColor()
        {
            GUI.color = _BGColorStack.Pop();
        }

        public static void PushContentColor(Color col)
        {
            _ContentColorStack.Push(GUI.contentColor);
            GUI.contentColor = col;
        }

        public static void PopContentColor()
        {
            GUI.contentColor = _ContentColorStack.Pop();
        }

       

        #endregion
        
        #region --- Events ---

        public static bool IsClick
        {
            get
            {
                return (Event.current!=null && Event.current.type == EventType.MouseDown && Event.current.button == 0);
            }
        }
        public static bool IsContextClick
        {
            get
            {
                return (Event.current != null && Event.current.type == EventType.MouseDown && Event.current.button == 1);
            }
        }

        public static bool IsLayout { get { return Event.current != null && Event.current.type == EventType.Layout; } }
        public static bool IsRepaint { get { return Event.current != null && Event.current.type == EventType.Repaint; } }

        public static Vector2 MousePosition
        {
            get
            {
                return (Event.current != null) ? Event.current.mousePosition : Vector2.zero;
            }
        }

        public static void UseEvent(int hashcode, Event e)
        {
            int controlID = GUIUtility.GetControlID(hashcode, FocusType.Passive);
            GUIUtility.hotControl = controlID;
            e.Use();
            GUIUtility.hotControl = 0;

        }

        #endregion

        #region --- Controls ---

        public static void HtmlHelpBox(string message, MessageType type = MessageType.None)
        {
            GUIContent c;
            switch (type)
            {
                case MessageType.Info:
                    c = EditorGUIUtility.IconContent("console.infoicon");
                    break;
                case MessageType.Warning:
                    c = EditorGUIUtility.IconContent("console.warningicon");
                    break;
                case MessageType.Error:
                    c = EditorGUIUtility.IconContent("console.erroricon");
                    break;
                default:
                    c = new GUIContent();
                    break;
            }
            c.text=message;
            GUILayout.Label(c, DTStyles.HtmlHelpBox);
        }

        public static Vector2 CompactVector2Field(Rect position, Vector2 value)
        {
            float labelWidth = 13f;

            float num2 = (position.width - 2) / 2f;
            Rect position2 = new Rect(position);
            position2.width = num2;
            float labelWidth2 = EditorGUIUtility.labelWidth;
            int indentLevel = EditorGUI.indentLevel;
            EditorGUIUtility.labelWidth = labelWidth;
            EditorGUI.indentLevel = 0;
            value.x = EditorGUI.FloatField(position2, "X", value.x);
            position2.x += num2 + 2f;
            value.y = EditorGUI.FloatField(position2, "Y", value.y);
            
            EditorGUIUtility.labelWidth = labelWidth2;
            EditorGUI.indentLevel = indentLevel;

            return value;
        }

        public static Vector3 CompactVector3Field(Rect position, Vector3 value)
        {
            float labelWidth = 13f;
            float num2 = (position.width - 4) / 3f;
            Rect position2 = new Rect(position);
            position2.width = num2;
            float labelWidth2 = EditorGUIUtility.labelWidth;
            int indentLevel = EditorGUI.indentLevel;
            EditorGUIUtility.labelWidth = labelWidth;
            EditorGUI.indentLevel = 0;
            value.x = EditorGUI.FloatField(position2, "X", value.x);
            position2.x += num2 + 2f;
            value.y = EditorGUI.FloatField(position2, "Y", value.y);
            position2.x += num2 + 2f;
            value.z = EditorGUI.FloatField(position2, "Z", value.z);

            EditorGUIUtility.labelWidth = labelWidth2;
            EditorGUI.indentLevel = indentLevel;

            return value;
        }

        public static bool LinkButton(Rect position, GUIContent content, ref bool repaint)
        {
            if (position.Contains(DTGUI.MousePosition))
                repaint = true;
            return GUI.Button(position, content, DTStyles.HtmlLinkLabel);
        }

        #endregion

        public static float LabelWidth(string label)
        {
            return LabelWidth(new GUIContent(label));
        }
        public static float LabelWidth(GUIContent label)
        {
            return EditorStyles.label.CalcSize(label).x;
        }

        public static Rect FromTo(this Vector2 start, Vector2 end)
        {
            Rect result = new Rect(start.x, start.y, end.x - start.x, end.y - start.y);
            if (result.width < 0f)
            {
                result.x += result.width;
                result.width = -result.width;
            }
            if (result.height < 0f)
            {
                result.y += result.height;
                result.height = -result.height;
            }
            return result;
        }
    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTGUI.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTHandles.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f6a1d31433dbd4e43934fdeedb24a25b
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

namespace FluffyUnderware.DevToolsEditor
{
    public static class DTHandles
    {
        public static class SnapSettings
        {
            private static float s_MoveSnapX;
            private static float s_MoveSnapY;
            private static float s_MoveSnapZ;
            private static float s_ScaleSnap;
            private static float s_RotationSnap;
            private static bool s_Initialized;

            private static void Initialize()
            {
                if (!s_Initialized)
                {
                    s_MoveSnapX = EditorPrefs.GetFloat("MoveSnapX", 1f);
                    s_MoveSnapY = EditorPrefs.GetFloat("MoveSnapY", 1f);
                    s_MoveSnapZ = EditorPrefs.GetFloat("MoveSnapZ", 1f);
                    s_ScaleSnap = EditorPrefs.GetFloat("ScaleSnap", 0.1f);
                    s_RotationSnap = EditorPrefs.GetFloat("RotationSnap", 15f);
                    s_Initialized = true;
                }
            }

            public static Vector3 Move
            {
                get { return new Vector3(MoveX, MoveY, MoveZ); }
            }
            public static float MoveX
            {
                get { Initialize(); return s_MoveSnapX; }
            }
            public static float MoveY
            {
                get { Initialize(); return s_MoveSnapY; }
            }
            public static float MoveZ
            {
                get { Initialize(); return s_MoveSnapZ; }
            }
            public static float Rotation
            {
                get { Initialize(); return s_RotationSnap; }
            }
            public static float ScaleSnap
            {
                get { Initialize(); return s_ScaleSnap; }
            }
        }

        public static bool MouseOverSceneView
        {
            get
            {
                return (SceneView.currentDrawingSceneView != null && Event.current != null) && SceneView.currentDrawingSceneView.position.Contains(GUIUtility.GUIToScreenPoint(Event.current.mousePosition));
            }
        }

        public static bool SceneViewIsSelected
        {
            get
            {
                return SceneView.focusedWindow == SceneView.currentDrawingSceneView;
            }
        }

        static readonly Stack<Color> mHandlesColorstack = new Stack<Color>();

        public static void PushHandlesColor(Color col)
        {
            mHandlesColorstack.Push(GUI.color);
            Handles.color = col;
        }

        public static void PopHandlesColor()
        {
            Handles.color = mHandlesColorstack.Pop();
        }

        static readonly Stack<Matrix4x4> mHandlesMatrixstack = new Stack<Matrix4x4>();

        public static void PushMatrix(Matrix4x4 matrix)
        {
            mHandlesMatrixstack.Push(matrix);
            Handles.matrix = matrix;
        }

        public static void PopMatrix()
        {
            Handles.matrix = mHandlesMatrixstack.Pop();
        }


        public static void LabelIcon(Vector3 position, string text, Color labelColor)
        {
            GUIStyle iconStyle = GUI.skin.button;
            iconStyle.normal.textColor = labelColor;
            Handles.Label(position, text, iconStyle);
        }

        public static bool Button(int id, Vector3 position, Quaternion direction, float size, float pickSize, bool useHandleSize, Handles.CapFunction capFunc, Color hoverCol, out bool isHovering)
        {
            Event current = Event.current;
            isHovering = false;
            if (useHandleSize)
            {
                float s = HandleUtility.GetHandleSize(position);
                size *= s;
                pickSize *= s;
            }
            switch (current.GetTypeForControl(id))
            {
                case EventType.MouseDown:
                    if (HandleUtility.nearestControl == id)
                    {
                        GUIUtility.hotControl = id;
                        current.Use();
                    }
                    break;
                case EventType.MouseUp:
                    if ((current.button == 0 || current.button == 2) && GUIUtility.hotControl == id)
                    {
                        GUIUtility.hotControl = 0;
                        current.Use();
                        if (HandleUtility.nearestControl == id)
                        {
                            return true;
                        }
                    }
                    break;
                case EventType.MouseMove:
                    if ((HandleUtility.nearestControl == id && current.button == 0) || (GUIUtility.keyboardControl == id && current.button == 2))
                    {
                        HandleUtility.Repaint();
                    }
                    break;
                case EventType.Repaint:
                    {
                        Color color = Handles.color;
                        if (HandleUtility.nearestControl == id && GUI.enabled)
                        {
                            isHovering = true;
                            Handles.color = hoverCol;
                        }

                        capFunc(id, position, Quaternion.identity, size, EventType.Repaint);
                        Handles.color = color;
                        break;
                    }
                case EventType.Layout:
                    if (GUI.enabled)
                    {
                        HandleUtility.AddControl(id, HandleUtility.DistanceToCircle(position, pickSize));
                    }
                    break;
            }
            return false;
        }

        public static bool PositionHandle(Vector3 position, Quaternion rotation, out Vector3 delta)
        {
            Vector3 p = Handles.PositionHandle(position, rotation);
            delta = p - position;
            return delta != Vector3.zero;
        }

        public static bool RotationHandle(Vector3 position, Quaternion rotation, out Quaternion newRotation)
        {
            newRotation = Handles.RotationHandle(rotation, position);
            return (newRotation != rotation);
        }

        static Vector2 s_StartMousePosition;
        static Vector2 s_CurrentMousePosition;
        static float s_StartScale;

        public static bool ScaleSlider(float scale, Vector3 position, Vector3 direction, Quaternion rotation, float length, float size, float snap, out float delta)
        {
            int id = GUIUtility.GetControlID("ScaleSliderHash".GetHashCode(), FocusType.Keyboard);
            float newScale = scale;
            Event current = Event.current;
            switch (current.GetTypeForControl(id))
            {
                case EventType.MouseDown:
                    if ((HandleUtility.nearestControl == id && current.button == 0) || (GUIUtility.keyboardControl == id && current.button == 2))
                    {
                        GUIUtility.keyboardControl = id;
                        GUIUtility.hotControl = id;
                        s_CurrentMousePosition = (s_StartMousePosition = current.mousePosition);
                        s_StartScale = scale;
                        current.Use();
                        EditorGUIUtility.SetWantsMouseJumping(1);
                    }
                    break;
                case EventType.MouseUp:
                    if (GUIUtility.hotControl == id && (current.button == 0 || current.button == 2))
                    {
                        GUIUtility.hotControl = 0;
                        current.Use();
                        EditorGUIUtility.SetWantsMouseJumping(0);
                    }
                    break;
                case EventType.MouseDrag:
                    if (GUIUtility.hotControl == id)
                    {
                        s_CurrentMousePosition += current.delta;
                        float num = 1f + HandleUtility.CalcLineTranslation(s_StartMousePosition, s_CurrentMousePosition, position, direction) * 0.1f;
                        num = Handles.SnapValue(num, snap);
                        newScale = s_StartScale * num;
                        GUI.changed = true;
                        current.Use();
                    }
                    break;
                case EventType.Repaint:
                    {
                        Color color = Color.white;
                        if (id == GUIUtility.keyboardControl)
                        {
                            color = Handles.color;
                            Handles.color = Handles.selectedColor;
                        }
                        //float num2 = size;
                        //if (GUIUtility.hotControl == id)
                        //{
                        //    num2 = size * scale / s_StartScale;
                        //}
                        Handles.CubeHandleCap(id, position + direction * length, rotation, HandleUtility.GetHandleSize(position) * size, EventType.Repaint);

                        Handles.DrawLine(position, position + direction * length);
                        if (id == GUIUtility.keyboardControl)
                        {
                            Handles.color = color;
                        }
                        break;
                    }
                case EventType.Layout:
                    HandleUtility.AddControl(id, HandleUtility.DistanceToLine(position, position + direction * length));
                    HandleUtility.AddControl(id, HandleUtility.DistanceToCircle(position + direction * length, size));
                    break;
            }
            delta = newScale - scale;

            return (scale != newScale);
        }

        public static Quaternion RotationHandle(Quaternion rotation, Vector3 position, float size)
        {
            Color staticColor = new Color(0.5f, 0.5f, 0.5f, 0f);
            float staticBlend = 0.6f;
            float handleSize = HandleUtility.GetHandleSize(position) * size;
            Color color = Handles.color;
            bool flag = !Tools.hidden && EditorApplication.isPlaying && ContainsStatic(Selection.gameObjects);
            Handles.color = ((!flag) ? Handles.xAxisColor : Color.Lerp(Handles.xAxisColor, staticColor, staticBlend));
            rotation = Handles.Disc(rotation, position, rotation * Vector3.right, handleSize, true, SnapSettings.Rotation);
            Handles.color = ((!flag) ? Handles.yAxisColor : Color.Lerp(Handles.yAxisColor, staticColor, staticBlend));
            rotation = Handles.Disc(rotation, position, rotation * Vector3.up, handleSize, true, SnapSettings.Rotation);
            Handles.color = ((!flag) ? Handles.zAxisColor : Color.Lerp(Handles.zAxisColor, staticColor, staticBlend));
            rotation = Handles.Disc(rotation, position, rotation * Vector3.forward, handleSize, true, SnapSettings.Rotation);
            if (!flag)
            {
                Handles.color = Handles.centerColor;
                rotation = Handles.Disc(rotation, position, Camera.current.transform.forward, handleSize * 1.1f, false, 0f);
                rotation = Handles.FreeRotateHandle(rotation, position, handleSize);
            }
            Handles.color = color;
            return rotation;
        }

        /// <summary>
        /// Draws a 3D position handle
        /// </summary>
        /// <returns>The updated position</returns>
        /// <seealso cref="GUIUtility.GetControlID(int,FocusType)"/>
        public static Vector3 PositionHandle(int controlId1, int controlId2, int controlId3, Vector3 position, Quaternion rotation, float handleSize, float rectangleToSliderRatio = 0.15f, Color additionalColor = new Color())
        {
            float sliderSize = HandleUtility.GetHandleSize(position) * handleSize;
            float rectangleSize = sliderSize * rectangleToSliderRatio;

            Vector3 snap = SnapSettings.Move;

            Vector3 axis1 = rotation * Vector3.right;
            Vector3 axis2 = rotation * Vector3.up;
            Vector3 axis3 = rotation * Vector3.forward;
            Color axis1Color = new Color(0.9f, 0.3f, 0.1f) + additionalColor;
            Color axis2Color = new Color(0.6f, 0.9f, 0.3f) + additionalColor;
            Color axis3Color = new Color(0.2f, 0.4f, 0.9f) + additionalColor;

            Vector3 updatedPosition = position;

            Handles.color = axis1Color;
            updatedPosition += Handles.Slider(position, axis1, sliderSize, Handles.ArrowHandleCap, snap.x) - position;
            updatedPosition += Handles.Slider2D(controlId1, position, rectangleSize * (axis3 + axis2), Vector3.Cross(axis3, axis2), axis2, axis3, rectangleSize, Handles.RectangleHandleCap, new Vector2(snap.y, snap.z)) - position;

            Handles.color = axis2Color;
            updatedPosition += Handles.Slider(position, axis2, sliderSize, Handles.ArrowHandleCap, snap.y) - position;
            updatedPosition += Handles.Slider2D(controlId2, position, rectangleSize * (axis1 + axis3), Vector3.Cross(axis1, axis3), axis3, axis1, rectangleSize, Handles.RectangleHandleCap, new Vector2(snap.z, snap.x)) - position;

            Handles.color = axis3Color;
            updatedPosition += Handles.Slider(position, axis3, sliderSize, Handles.ArrowHandleCap, snap.z) - position;
            updatedPosition += Handles.Slider2D(controlId3, position, rectangleSize * (axis1 + axis2), Vector3.Cross(axis1, axis2), axis2, axis1, rectangleSize, Handles.RectangleHandleCap, new Vector2(snap.y, snap.x)) - position;

            return updatedPosition;
        }

        /// <summary>
        /// Draws a 2D position handle
        /// </summary>
        /// <param name="size"></param>
        /// <param name="plane">0 for XY, 1 for XZ and 2 for YZ</param>
        /// <param name="controlId"><see cref="GUIUtility.GetControlID(int,FocusType)"/></param>
        /// <param name="position"></param>
        /// <param name="rotation"></param>
        /// <returns>The updated position</returns>
        public static Vector3 PositionHandle2D(int controlId, Vector3 position, Quaternion rotation, float size, int plane = 0)
        {
            float sliderSize = HandleUtility.GetHandleSize(position) * size;
            float rectSize = sliderSize * 0.15f;

            Vector3 snap = SnapSettings.Move;

            Vector3 axis1;
            Vector3 axis2;
            Color axis1Color;
            Color axis2Color;
            Color planeColor;
            {
                Color xColor = new Color(0.9f, 0.3f, 0.1f);
                Color yColor = new Color(0.6f, 0.9f, 0.3f);
                Color zColor = new Color(0.2f, 0.4f, 0.9f);

                switch (plane)
                {
                    //XY
                    case 0:
                        axis1 = rotation * Vector3.right;
                        axis2 = rotation * Vector3.up;
                        axis1Color = xColor;
                        axis2Color = yColor;
                        planeColor = zColor;
                        break;
                    //XZ
                    case 1:
                        axis1 = rotation * Vector3.right;
                        axis2 = rotation * Vector3.forward;
                        axis1Color = xColor;
                        axis2Color = zColor;
                        planeColor = yColor;
                        break;
                    //YZ
                    case 2:
                        axis1 = rotation * Vector3.up;
                        axis2 = rotation * Vector3.forward;
                        axis1Color = yColor;
                        axis2Color = zColor;
                        planeColor = xColor;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException(nameof(plane));
                }
            }

            Vector3 updatedPosition = position;

            Handles.color = axis1Color;
            updatedPosition += Handles.Slider(position, axis1, sliderSize, Handles.ArrowHandleCap, snap.x) - position;

            Handles.color = axis2Color;
            updatedPosition += Handles.Slider(position, axis2, sliderSize, Handles.ArrowHandleCap, snap.y) - position;

            Handles.color = planeColor;
            updatedPosition += Handles.Slider2D(controlId, position, rectSize * (axis1 + axis2), Vector3.Cross(axis1, axis2), axis2, axis1, rectSize, Handles.RectangleHandleCap, new Vector2(snap.x, snap.y)) - position;

            return updatedPosition;
        }

        public static Vector3 TinyHandle2D(int id, Vector3 position, Quaternion rotation, float size, Handles.CapFunction func = null)
        {
            return TinyHandle2D(id, position, rotation * Vector3.forward, rotation * Vector3.up, rotation * Vector3.right, size, func);
        }

        public static Vector3 TinyHandle2D(int id, Transform transform, float size, Handles.CapFunction func = null)
        {
            return TinyHandle2D(id, transform.position, transform.forward, transform.up, transform.right, size, func);
        }

        public static Vector3 TinyHandle2D(int id, Vector3 pos, Vector3 forward, Vector3 up, Vector3 right, float size, Handles.CapFunction func = null)
        {
            return Handles.Slider2D(id, pos, forward, up, right, HandleUtility.GetHandleSize(pos) * size, func, SnapSettings.Move);
        }

        public static void DrawSolidRectangleWithOutline(Vector2 center, Vector2 extends, Color backgroundColor, Color outlineColor)
        {
            DrawSolidRectangleWithOutline(new Rect(center.x - extends.x / 2, center.y - extends.y / 2, extends.x, extends.y), backgroundColor, outlineColor);
        }

        public static void DrawSolidRectangleWithOutline(Rect r, Color backgroundColor, Color outlineColor)
        {
            Vector3[] verts = new Vector3[4]
            {
                new Vector3(r.xMin,r.yMin,0),
                new Vector3(r.xMax,r.yMin,0),
                new Vector3(r.xMax,r.yMax,0),
                new Vector3(r.xMin,r.yMax,0)
            };
            Handles.DrawSolidRectangleWithOutline(verts, backgroundColor, outlineColor);
        }

        public static void DrawOutline(Rect r, Color outlineColor)
        {
            DrawSolidRectangleWithOutline(r, new Color(0, 0, 0, 0), outlineColor);
        }

        public static void WireCubeCap(Vector3 position, Vector3 size)
        {
            Vector3 half = size / 2;
            // draw front
            Handles.DrawLine(position + new Vector3(-half.x, -half.y, half.z), position + new Vector3(half.x, -half.y, half.z));
            Handles.DrawLine(position + new Vector3(-half.x, -half.y, half.z), position + new Vector3(-half.x, half.y, half.z));
            Handles.DrawLine(position + new Vector3(half.x, half.y, half.z), position + new Vector3(half.x, -half.y, half.z));
            Handles.DrawLine(position + new Vector3(half.x, half.y, half.z), position + new Vector3(-half.x, half.y, half.z));
            // draw back
            Handles.DrawLine(position + new Vector3(-half.x, -half.y, -half.z), position + new Vector3(half.x, -half.y, -half.z));
            Handles.DrawLine(position + new Vector3(-half.x, -half.y, -half.z), position + new Vector3(-half.x, half.y, -half.z));
            Handles.DrawLine(position + new Vector3(half.x, half.y, -half.z), position + new Vector3(half.x, -half.y, -half.z));
            Handles.DrawLine(position + new Vector3(half.x, half.y, -half.z), position + new Vector3(-half.x, half.y, -half.z));
            // draw corners
            Handles.DrawLine(position + new Vector3(-half.x, -half.y, -half.z), position + new Vector3(-half.x, -half.y, half.z));
            Handles.DrawLine(position + new Vector3(half.x, -half.y, -half.z), position + new Vector3(half.x, -half.y, half.z));
            Handles.DrawLine(position + new Vector3(-half.x, half.y, -half.z), position + new Vector3(-half.x, half.y, half.z));
            Handles.DrawLine(position + new Vector3(half.x, half.y, -half.z), position + new Vector3(half.x, half.y, half.z));
        }

        public static void ArrowCap(Vector3 position, Vector3 direction, Color outlineColor, float length, float lineWidth = 0.4f, float headWidth = 1f, float headRatio = 0.3f, bool useHandleSize = true)
        {
            float size = (useHandleSize) ? HandleUtility.GetHandleSize(position) : 1;

            ArrowCap(position, direction, Vector3.up, outlineColor, length, lineWidth, headWidth, headRatio, size);
        }

        public static void ArrowCap(Vector3 position, Vector3 direction, Vector3 upDirection, Color outlineColor, float length, float lineWidth, float headWidth, float headRatio, float sizeMultiplier)
        {
            Vector3[] arrow = new Vector3[8];
            Vector3 start = position;
            length *= sizeMultiplier;
            Vector3 end = position + direction * length;

            Vector3 right = Vector3.Cross(upDirection, direction).normalized;

            float hh = length * headRatio;
            Vector3 rlw2 = right * lineWidth / 2 * sizeMultiplier;
            Vector3 rhw2 = right * headWidth / 2 * sizeMultiplier;
            arrow[0] = start - rlw2;
            arrow[1] = end - direction * hh - rlw2;
            arrow[2] = end - direction * hh - rhw2;
            arrow[3] = end;
            arrow[4] = end - direction * hh + rhw2;
            arrow[5] = end - direction * hh + rlw2;
            arrow[6] = start + rlw2;
            arrow[7] = arrow[0];

            Handles.DrawAAConvexPolygon(arrow[2], arrow[3], arrow[4]);
            Handles.DrawAAConvexPolygon(arrow[0], arrow[1], arrow[5], arrow[6]);
            if (Handles.color != outlineColor)
            {
                Color c = Handles.color;
                Handles.color = outlineColor;
                Handles.DrawAAPolyLine(arrow);
                Handles.color = c;
            }
        }

        public static void BoundsCap(Bounds b)
        {
            WireCubeCap(b.center, b.size);
        }

        public static Vector3 TranslateByPixel(Vector3 position, float x, float y)
        {
            return TranslateByPixel(position, new Vector3(x, y));
        }
        public static Vector3 TranslateByPixel(Vector3 position, Vector3 translateBy)
        {
            Camera cam = SceneView.currentDrawingSceneView.camera;
            if (cam)
                return cam.ScreenToWorldPoint(cam.WorldToScreenPoint(position) + translateBy);
            else
                return position;
        }

        public static Vector3 TranslateAligned(Vector3 position, GUIContent content, TextAlignment alignment = TextAlignment.Center, GUIStyle style = null)
        {
            if (style == null)
                style = EditorStyles.label;
            float w = style.CalcSize(content).x;
            switch (alignment)
            {
                case TextAlignment.Center:
                    return TranslateByPixel(position, new Vector3(-w / 2, 0, 0));
                case TextAlignment.Right:
                    return TranslateByPixel(position, new Vector3(w / 2, 0, 0));
                default:
                    return position;
            }

        }

        static bool ContainsStatic(GameObject[] objects)
        {
            if (objects == null || objects.Length == 0)
            {
                return false;
            }
            for (int i = 0; i < objects.Length; i++)
            {
                if (objects[i] != null && objects[i].isStatic)
                {
                    return true;
                }
            }
            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTHandles.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTProject.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f699006303cd07e4fb52f3fd516ad100
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System;
using FluffyUnderware.DevTools;


namespace FluffyUnderware.DevToolsEditor
{
    public abstract class DTProject : IComparable
    {
        public string Identifier { get; private set; }
        public string Version { get; private set; }
        public DTResource Resource { get; protected set; }
        [Obsolete("Assumed to be always true")]
        public bool ShowToolbarInAllSceneViews = false;

        public DTToolbarOrientation ToolbarOrientation
        {
            get { return mTBOrientation; }
            set
            {
                if (mTBOrientation != value)
                {
                    mTBOrientation = value;
                    if (!string.IsNullOrEmpty(Identifier))
                    {
                        SetEditorPrefs("ToolbarOrientation", ToolbarOrientation);
                    }
                    else
                        DTLog.LogError("[DevTools] Project " + this.GetType().Name + "missing identifier!");
                    DTToolbar.RecalcItemSize = true;
                }
            }
        }
        public DTToolbarMode ToolbarMode
        {
            get { return mTBMode; }
            set
            {
                if (mTBMode != value)
                {
                    mTBMode = value;
                    if (!string.IsNullOrEmpty(Identifier))
                    {
                        SetEditorPrefs("ToolbarMode", ToolbarMode);
                    }
                    else
                        DTLog.LogError("[DevTools] Project " + this.GetType().Name + "missing identifier!");
                    DTToolbar.RecalcItemSize = true;
                }
            }
        }

        readonly Dictionary<string, EditorKeyBinding> AdditionalKeyBindings = new Dictionary<string, EditorKeyBinding>();
        internal List<DTToolbarItem> ToolbarItems = new List<DTToolbarItem>();
        
        static DTToolbarOrientation mTBOrientation = DTToolbarOrientation.Left;
        static DTToolbarMode mTBMode = DTToolbarMode.Full;

        protected DTProject(string identifier, string version)
        {
            Identifier = identifier;
            Version = version;
            LoadPreferences();
        }

        internal void Clear()
        {
            ToolbarItems.Clear();
            AdditionalKeyBindings.Clear();
        }

        public virtual void ResetPreferences()
        {
        }
       
        public virtual void LoadPreferences() 
        {
            if (!string.IsNullOrEmpty(Identifier))
            {
                // Upgrade?
                string ver=GetEditorPrefs("Version", Version);
                if (string.Compare(ver, Version)==-1)// (ver != Version)
                {
                    UpgradePreferences(ver);
                    SetEditorPrefs("Version", Version);
                }
                 
                mTBMode=GetEditorPrefs("ToolbarMode", ToolbarMode);
                mTBOrientation=GetEditorPrefs("ToolbarOrientation", ToolbarOrientation);

            } else
                DTLog.LogError("[DevTools] Project "+this.GetType().Name+"missing identifier!");
        }

        public virtual void SavePreferences()
        {
            if (!string.IsNullOrEmpty(Identifier))
            {
                SetEditorPrefs("Version",Version);
                SetEditorPrefs("ToolbarMode", ToolbarMode);
                SetEditorPrefs("ToolbarOrientation", ToolbarOrientation);
            } else
                DTLog.LogError("[DevTools] Project " + this.GetType().Name + "missing identifier!");
        }

        public List<EditorKeyBinding> GetProjectBindings()
        {
            List<EditorKeyBinding> res = new List<EditorKeyBinding>();
            foreach (DTToolbarItem item in ToolbarItems)
                foreach (EditorKeyBinding binding in item.KeyBindings)
                    if (binding.ShowInPrefs)
                        res.Add(binding);
            res.AddRange(AdditionalKeyBindings.Values);
            res.Sort();
            return res;
        }

        public EditorKeyBinding RegisterKeyBinding(EditorKeyBinding binding)
        {
            EditorKeyBinding b;
            if (AdditionalKeyBindings.TryGetValue(binding.Name,out b))
                return b;
            else {
                setKeyBindingFromPrefs(binding,false);
                AdditionalKeyBindings.Add(binding.Name, binding);
                return binding;
            }
        }

        /// <summary>
        ///  For all EditorKeyBindings registered to ToolbarItems of this project, check if Name is unique
        /// </summary>
        /// <returns></returns>
        internal bool CheckKeyBindingNamesAreUnique()
        {
            
            Dictionary<string, object> dict = new Dictionary<string, object>();
            object exist;
             foreach (DTToolbarItem item in ToolbarItems)
                foreach (EditorKeyBinding binding in item.KeyBindings)
                {
                    if (dict.TryGetValue(binding.Name, out exist)){
                        DTLog.LogError(string.Format("[DevTools] KeyBindings need unique names! ({0} and {1}",item.GetType().Name,exist.GetType().Name));
                        return false;
                    } else
                        dict.Add(binding.Name,item);
                }
            
            return true;
        }

        void setKeyBindingFromPrefs(EditorKeyBinding binding, bool removePrefsIfEqual=true)
        {
            string newBindString = GetEditorPrefs(binding.Name, "");
            if (!string.IsNullOrEmpty(newBindString) ){
                // Same binding? Then remove prefs setting
                if (removePrefsIfEqual && newBindString == binding.ToPrefsString())
                    DeleteEditorPrefs(binding.Name);
                else // load and set new binding
                    binding.Set(newBindString);
            }
        }

        /// <summary>
        /// For all EditorKeyBindings registered to ToolbarItems of this project, manage remappings stored in EditorPrefs
        /// </summary>
        internal void LoadKeyBindingRemappings()
        {
            // Toolbars
            foreach (DTToolbarItem item in ToolbarItems)
                for (int i=0;i<item.KeyBindings.Count;i++)
                    setKeyBindingFromPrefs(item.KeyBindings[i]);
        }

        protected virtual void UpgradePreferences(string oldVersion)
        {
            DTLog.Log(string.Format("[{0}] Upgrading project settings from {1} to {2}", Identifier, oldVersion, Version));
        }

        public void SetEditorPrefs<T>(string key, T value)
        {
            DT.SetEditorPrefs(Identifier + "." + key, value);
        }

        public T GetEditorPrefs<T>(string key, T defaultValue)
        {
            return DT.GetEditorPrefs(Identifier + "." + key, defaultValue);
        }

        public string[] GetEditorPrefs(string key)
        {
            return DT.GetEditorPrefs(Identifier + "." + key);
        }

        public bool HasEditorPrefs(string key)
        {
            return EditorPrefs.HasKey(Identifier + "." + key);
        }

        public void DeleteEditorPrefs(string key)
        {
            EditorPrefs.DeleteKey(Identifier + "." + key);
        }

        public T FindItem<T>() where T:DTToolbarItem
        {
            Type t = typeof(T);
            for (int i = 0; i < ToolbarItems.Count; i++)
                if (ToolbarItems[i].GetType() == t)
                    return (T)ToolbarItems[i];
            return null;
        }

        internal void SetRadioGroupState(DTToolbarRadioButton active)
        {
            for (int i = 0; i < ToolbarItems.Count; i++)
            {
                DTToolbarRadioButton rad = ToolbarItems[i] as DTToolbarRadioButton;
                if (rad && rad.RadioGroup.Equals(active.RadioGroup, StringComparison.CurrentCultureIgnoreCase))
                    rad.mOn = (rad == active);
            }
        }

        public int CompareTo(object obj)
        {
            DTProject other = (DTProject)obj;
            return Identifier.CompareTo(other.Identifier);
        }

       

    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTProject.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTResource.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 4e7542226fdb3e8458d6dd939f67c79e
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using System.Reflection;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;

namespace FluffyUnderware.DevToolsEditor
{
    /// <summary>
    /// Class for loading image resources
    /// </summary>
    public abstract class DTResource
    {
        public Assembly ResourceDLL;
        public string ResourceNamespace = string.Empty;

        /// <summary>
        /// Load an image defined by a packed string either from the Resource DLL or the Editor/Resources folder
        /// </summary>
        /// <param name="packedstring">string formed name (including namespace),width,height. E.g. "Assets/Editor/myIcon,16,16"</param>
        /// <returns>a Texture</returns>
        public virtual Texture2D LoadPacked(string packedstring,Assembly assembly=null, string resourcePath="")
        {
            if (!string.IsNullOrEmpty(packedstring))
            {
                string[] s = packedstring.Split(',');
                if (s.Length == 3)
                {
                    try
                    {
                        int w = int.Parse(s[1], System.Globalization.CultureInfo.InvariantCulture);
                        int h = int.Parse(s[2], System.Globalization.CultureInfo.InvariantCulture);
                        return Load(s[0], w, h, assembly, resourcePath);
                    }
                    catch (Exception e) { Debug.LogException(e);}
                }
            }
            return null;
        }
        
        /// <summary>
        /// Load an image either from a Resource DLL or the Editor/Resources folder
        /// </summary>
        /// <param name="assembly">the resource DLL assembly</param>
        /// <param name="resourcePath">the resource path(namespace)</param>
        /// <param name="resourceName">name of the resource file (without extension)</param>
        /// <param name="width">width of the image (can be omitted when loading from texture file)</param>
        /// <param name="height">height of the image (can be omitted when loading from texture file)</param>
        /// <returns>a Texture</returns>
        public virtual Texture2D Load(string resourceName, int width=0, int height=0,Assembly assembly=null, string resourcePath="")
        {
            if (assembly == null)
                assembly = ResourceDLL;
            if (string.IsNullOrEmpty(resourcePath))
                resourcePath = ResourceNamespace;

            Texture2D texture = null;
            if (string.IsNullOrEmpty(System.IO.Path.GetExtension(resourceName)))
                resourceName += ".png";
            
            //if (!resourcePath.EndsWith("."))
            //    resourcePath += ".";

            if (assembly != null)
            {
                using (System.IO.Stream myStream = assembly.GetManifestResourceStream(resourcePath + resourceName))
                {
                    if (myStream != null)
                    {
                        texture = new Texture2D(width, height, TextureFormat.ARGB32, false);
                        texture.LoadImage(ReadToEnd(myStream));
                        if (texture != null)
                        {
                            //texture.hideFlags = HideFlags.DontSave;
                            return texture;
                        }
                    }
                }
            }

            // Try from file sys:
            texture = (Texture2D)Resources.Load($"Editor/{System.IO.Path.GetFileNameWithoutExtension(resourceName)}");

            if (texture == null)
            {
                DTLog.LogWarning("Missing resource: " + resourcePath + resourceName);
            }
            //else
            //    texture.hideFlags = HideFlags.DontSave;
                
            
            


            return texture;

            
        }

        protected static byte[] ReadToEnd(System.IO.Stream stream)
        {
            long originalPosition = stream.Position;
            stream.Position = 0;

            try
            {
                byte[] readBuffer = new byte[4096];

                int totalBytesRead = 0;
                int bytesRead;

                while ((bytesRead = stream.Read(readBuffer, totalBytesRead, readBuffer.Length - totalBytesRead)) > 0)
                {
                    totalBytesRead += bytesRead;

                    if (totalBytesRead == readBuffer.Length)
                    {
                        int nextByte = stream.ReadByte();
                        if (nextByte != -1)
                        {
                            byte[] temp = new byte[readBuffer.Length * 2];
                            System.Buffer.BlockCopy(readBuffer, 0, temp, 0, readBuffer.Length);
                            System.Buffer.SetByte(temp, totalBytesRead, (byte)nextByte);
                            readBuffer = temp;
                            totalBytesRead++;
                        }
                    }
                }

                byte[] buffer = readBuffer;
                if (readBuffer.Length != totalBytesRead)
                {
                    buffer = new byte[totalBytesRead];
                    System.Buffer.BlockCopy(readBuffer, 0, buffer, 0, totalBytesRead);
                }
                return buffer;
            }
            finally
            {
                stream.Position = originalPosition;
            }
        }

        public static Assembly FindResourceDLL(string name)
        {
            //BUG will return the wrong dll if there is another dll that starts with the same name
            return TypeExt.GetLoadedAssemblies().FirstOrDefault(asm => asm.FullName.StartsWith(name));
        }
    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTResource.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTSceneView.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 97953e54a2c2482449099d6d8dfb2de4
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using FluffyUnderware.DevTools.Extensions;
using System;

namespace FluffyUnderware.DevToolsEditor
{
#if UNITY_2021_2_OR_NEWER
    [Obsolete("Now that SceneView has a OnSceneGUI method, there is seemingly no need to use DTSceneView which implements its own OnSceneGUI. It might even conflict with SceneView.OnSceneGUI")]
#endif
    public class DTSceneView : SceneView
    {

        #region ### Serialized fields ###
        #endregion

        #region ### Public Properties ###

        public bool In2DMode
        {
            get { return in2DMode; }
            set
            {
                in2DMode = value;
            }
        }

        public SceneViewState State
        {
            get
            {
                return mStateField.GetValue(this) as SceneViewState;
            }
            set
            {
                mStateField.SetValue(this, value);
            }
        }

        #endregion

        #region ### Privates Fields ###

        FieldInfo mStateField;

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        public override void OnEnable()
        {
            base.OnEnable();
            getInternals();
            SceneView.duringSceneGui += onScene;
        }

        public override void OnDisable()
        {
            SceneView.duringSceneGui -= onScene;
            base.OnDisable();
        }

        /*! \endcond */
        #endregion

        #region ### Public Static Methods ###
        #endregion

        #region ### Public Methods ###

#if UNITY_2021_2_OR_NEWER
        protected new virtual void OnSceneGUI()
#else
        protected virtual void OnSceneGUI()
#endif
        {
        }

        #endregion

        #region ### Privates & Internals ###
        /*! \cond PRIVATE */

        void onScene(SceneView view)
        {
            if (EditorApplication.isCompiling)
            {
                SceneView.duringSceneGui -= onScene;
                Close();
                GUIUtility.ExitGUI();
            }
            if (view == this)
                OnSceneGUI();
        }

        void getInternals()
        {
            mStateField = GetType().FieldByName("m_SceneViewState", true, true);
        }



        /*! \endcond */
        #endregion

    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTSceneView.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTSelection.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: cb2b7daa166196847886162a590328f2
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.DevTools.Extensions;

namespace FluffyUnderware.DevToolsEditor
{
    public static class DTSelection
    {
        static GameObject mCurrentGameObject;
        static int mCurrentGameObjectsCount;

        public static event DT.Callback OnSelectionChange;

        internal static bool MuteEvents { get; set; }

        public static int Count
        {
            get { return mCurrentGameObjectsCount; }
        }

        internal static void Initialize()
        {
            EditorApplication.update -= checkSelection;
            //TODO listen on Selection.selectionChanged instead?
            EditorApplication.update += checkSelection;

        }

        public static bool HasComponent<T>(bool allowMultiSelection = false) where T : Component
        {
            if (allowMultiSelection)
                return mCurrentGameObjectsCount >= 1 && getSelection<T>().Count > 0;
            else
                return mCurrentGameObjectsCount == 1 && mCurrentGameObject != null && mCurrentGameObject.GetComponent(typeof(T)) != null;
        }

        public static bool HasComponent<T, T1>(bool allowMultiSelection = false) where T : Component where T1 : Component
        {
            return HasComponent<T>(allowMultiSelection) ||
                   HasComponent<T1>(allowMultiSelection);
        }

        public static bool HasComponent<T, T1, T2>(bool allowMultiSelection = false)
            where T : Component
            where T1 : Component
            where T2 : Component
        {
            return HasComponent<T>(allowMultiSelection) ||
                   HasComponent<T1>(allowMultiSelection) ||
                   HasComponent<T2>(allowMultiSelection);
        }

        public static bool HasComponent<T, T1, T2, T3>(bool allowMultiSelection = false)
            where T : Component
            where T1 : Component
            where T2 : Component
            where T3 : Component
        {
            return HasComponent<T>(allowMultiSelection) ||
                   HasComponent<T1>(allowMultiSelection) ||
                   HasComponent<T2>(allowMultiSelection) ||
                   HasComponent<T3>(allowMultiSelection);
        }

        public static bool HasComponent<T, T1, T2, T3, T4>(bool allowMultiSelection = false)
            where T : Component
            where T1 : Component
            where T2 : Component
            where T3 : Component
            where T4 : Component
        {
            return HasComponent<T>(allowMultiSelection) ||
                   HasComponent<T1>(allowMultiSelection) ||
                   HasComponent<T2>(allowMultiSelection) ||
                   HasComponent<T3>(allowMultiSelection) ||
                   HasComponent<T4>(allowMultiSelection);
        }

        public static T GetAs<T>(bool allowMultiSelection = false) where T : Component
        {
            List<T> ar = getSelection<T>();
            if (ar.Count == 1 || (ar.Count > 0 && allowMultiSelection))
                return (T)ar[0];
            else
                return null;
        }

        public static List<T> GetAllAs<T>() where T : Component
        {
            return getSelection<T>();
        }

        public static GameObject GetGameObject(bool allowMultiSelection = false)
        {
            GameObject[] selectedGameObjects = Selection.gameObjects;
            if (selectedGameObjects.Length == 1 || (selectedGameObjects.Length > 1 && allowMultiSelection))
                return Selection.activeGameObject;
            else
                return null;
        }

        public static Vector3 GetPosition()
        {
            Vector3 p = Vector3.zero;
            List<Transform> tt = DTSelection.GetAllAs<Transform>();
            if (tt.Count > 0)
            {
                for (int i = 0; i < tt.Count; i++)
                    p += tt[i].position;

                p /= tt.Count;
            }
            return p;
        }

        static List<T> getSelection<T>() where T : Component
        {
            Object[] S = Selection.GetFiltered(typeof(T), SelectionMode.TopLevel | SelectionMode.ExcludePrefab | SelectionMode.Editable);
            List<T> L = new List<T>();
            foreach (Object O in S)
                if (O != null)
                {
                    if (Selection.activeTransform == ((Component)O).transform)
                        L.Insert(0, (T)O);
                    else
                        L.Add((T)O);
                }
            return L;
        }

        public static void Clear()
        {
            Selection.objects = new Object[0];
            mCurrentGameObject = null;
            mCurrentGameObjectsCount = 0;
            raiseOnSelectionChange();
        }

        public static void Set(params Object[] objects)
        {
            if (objects.Length > 0)
            {
                Selection.objects = objects;
                mCurrentGameObject = Selection.activeGameObject;
                mCurrentGameObjectsCount = Selection.gameObjects.Length;
                raiseOnSelectionChange();
            }
            else
                Clear();
        }

        public static void AddGameObjects(params Component[] objects)
        {
            List<GameObject> gl = new List<GameObject>(objects.Length);
            foreach (Component c in objects)
                if (c != null && c.gameObject != null && !gl.Contains(c.gameObject) && !Selection.Contains(c))
                    gl.Add(c.gameObject);
            if (gl.Count > 0)
            {
                GameObject[] cur = Selection.gameObjects;
                Selection.objects = cur.AddRange(gl.ToArray());
            }
        }

        public static void SetGameObjects(params Component[] objects)
        {
            if (objects.Length > 0)
            {
                List<GameObject> gl = new List<GameObject>(objects.Length);
                foreach (Component c in objects)
                    if (c != null && c.gameObject != null && !gl.Contains(c.gameObject))
                        gl.Add(c.gameObject);
                Selection.objects = gl.ToArray();
                mCurrentGameObject = Selection.activeGameObject;
                mCurrentGameObjectsCount = Selection.gameObjects.Length;
                raiseOnSelectionChange();
            }
            else
                Clear();
        }

        static void checkSelection()
        {
            GameObject[] selectedGameObjects = Selection.gameObjects;
            if (!MuteEvents && Selection.activeGameObject != mCurrentGameObject || mCurrentGameObjectsCount != selectedGameObjects.Length)
            {
                mCurrentGameObject = Selection.activeGameObject;
                mCurrentGameObjectsCount = selectedGameObjects.Length;
                raiseOnSelectionChange();
            }
        }

        static void raiseOnSelectionChange()
        {
            if (OnSelectionChange != null)
                OnSelectionChange();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTSelection.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTStatusbar.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 0e51fd46e878d264ead8664f69a93db9
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevToolsEditor.Extensions;

namespace FluffyUnderware.DevToolsEditor
{
    public class DTStatusbar
    {
        string mSourceIdent;
        string mStatusBarMessage;
        MessageType mStatusBarMessageType;
        float mStatusBarMessageDelay;
        double mStatusBarMessageLastTime;

        GUIStyle mMessageStyle;
        public GUIStyle MessageStyle
        {
            get
            {
                if (mMessageStyle == null)
                {
                    mMessageStyle = GetStyle();
                }
                return mMessageStyle;
            }
            set
            {
                mMessageStyle = value;
            }
        }

        public bool Visible = true;


        protected virtual GUIStyle GetStyle()
        {
            GUIStyle st=new GUIStyle(GUI.skin.GetStyle("HelpBox"));
            st.richText = true;
            return st;
        }

        protected virtual void GetColors()
        {
            switch (mStatusBarMessageType)
            {
                case MessageType.Error:
                    GUI.contentColor = Color.white;
                    GUI.backgroundColor = Color.red.SkinAwareColor();
                    break;
                case MessageType.Warning:
                    GUI.contentColor = Color.white;
                    GUI.backgroundColor = Color.yellow.SkinAwareColor();
                    break;
                case MessageType.Info:
                    GUI.contentColor = Color.yellow;
                    break;
                default:
                    GUI.contentColor = Color.white;
                    break;
            }

            
        }

        public void Clear(string source="")
        {
            if (source == mSourceIdent || string.IsNullOrEmpty(mSourceIdent))
            {
                mStatusBarMessage = "";
                mStatusBarMessageType = MessageType.None;
                mStatusBarMessageDelay = 0;
                mStatusBarMessageLastTime = EditorApplication.timeSinceStartup;
                mSourceIdent = "";
            }

        }

        public void Set(string text, string source="",float delay = 0)
        {
            SetMessage(text, source,MessageType.None, delay);
        }

        public void SetError(string text, string source = "", float delay = 0)
        {
            SetMessage(text,source, MessageType.Error, delay);
        }

        public void SetInfo(string text, string source = "", float delay = 0)
        {
            SetMessage(text, source,MessageType.Info, delay);
        }

        public void SetWarning(string text, string source = "", float delay = 0)
        {
            SetMessage(text, source,MessageType.Warning, delay);
        }

        public void SetMessage(string msg = "", string source="",MessageType type = MessageType.None, float delay = 0)
        {
                mStatusBarMessage = msg;
                mStatusBarMessageType = type;
                mStatusBarMessageDelay = delay;
                mStatusBarMessageLastTime = EditorApplication.timeSinceStartup;
                mSourceIdent = source;
        }

        /// <summary>
        /// Renders the StatusBar
        /// </summary>
        /// <param name="renderingZone">the rect to use</param>
        /// <param name="style">(Optional) A style to override the default style</param>
        /// <param name="fit">Allow the <paramref name="renderingZone"/> to be modified to fit the text to render</param>
        /// <returns>true if you should do a repaint (i.e. a color fade is in progress)</returns>
        public bool Render(Rect renderingZone, GUIStyle style=null, bool fit=false)
        {
            if (!Visible || string.IsNullOrEmpty(mStatusBarMessage))
                return false;
            
            Color c = GUI.contentColor;
            //Color bc = GUI.backgroundColor;
            GetColors();
            GUI.contentColor = GUI.contentColor.Fade(mStatusBarMessageLastTime, mStatusBarMessageDelay, 1);
            bool repaint = (EditorApplication.timeSinceStartup-mStatusBarMessageDelay<mStatusBarMessageLastTime);
            if (fit)
            {
                Vector2 calcSize = EditorStyles.label.CalcSize(new GUIContent(mStatusBarMessage));
                float w=calcSize.x + 20;
                renderingZone.x += (renderingZone.width - w) / 2;
                renderingZone.width = w;
                float h = calcSize.y;
                renderingZone.y += renderingZone.height - h;
                renderingZone.height = h;
            }

            EditorGUI.LabelField(renderingZone, mStatusBarMessage, style==null ? MessageStyle:style);
            GUI.contentColor = c;
            //GUI.backgroundColor = bc;
            return repaint;
        }
    }


}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTStatusbar.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTStyles.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7eda549546892154681be2d439a3445b
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevToolsEditor.Extensions;

namespace FluffyUnderware.DevToolsEditor
{
    public static class DTStyles
    {

        public static GUIStyle BackdropHtmlLabel
        {
            get
            {
                if (mBackdropHtmlLabel == null)
                {
                    mBackdropHtmlLabel = new GUIStyle();//GUI.skin.GetStyle("HelpBox"));
                    mBackdropHtmlLabel.alignment = TextAnchor.MiddleCenter;
                    Texture2D bgTex = new Texture2D(1, 1);
                    bgTex.SetPixel(0, 0, new Color(1, 1, 1, 0.3f));
                    bgTex.Apply();
                    bgTex.hideFlags = HideFlags.DontSave;
                    mBackdropHtmlLabel.padding = new RectOffset(1, 2, 0, 0);
                    mBackdropHtmlLabel.normal.background = bgTex;
                    mBackdropHtmlLabel.richText = true;
                }
                return mBackdropHtmlLabel;
            }
        }
        static GUIStyle mBackdropHtmlLabel;

        static GUIStyle mTBButton;
        public static GUIStyle TBButton
        {
            get
            {
                if (mTBButton == null)
                { 
                    mTBButton = new GUIStyle(GUI.skin.button);
                    mTBButton.alignment = TextAnchor.MiddleLeft;
                    mTBButton.padding.top = 4;
                    mTBButton.padding.bottom = 2;
                }
            
                return mTBButton;
            }
        }

        static GUIStyle mTBBackground;
        public static GUIStyle TBBackground
        {
            get
            {
                if (mTBBackground == null)
                {
                    mTBBackground = new GUIStyle(GUI.skin.textArea);
                }
                return mTBBackground;
            }
        }

        static GUIStyle mHtmlHelpBox;
        public static GUIStyle HtmlHelpBox
        {
            get
            {
                if (mHtmlHelpBox == null)
                {
                    mHtmlHelpBox= new GUIStyle(GUI.skin.GetStyle("HelpBox"));
                    mHtmlHelpBox.richText = true;
                    return mHtmlHelpBox;
                }
                return mHtmlHelpBox;
            }
        }

        static GUIStyle mHtmlLabel;
        public static GUIStyle HtmlLabel
        {
            get
            {
                if (mHtmlLabel == null)
                {
                    mHtmlLabel = new GUIStyle(GUI.skin.label);
                    mHtmlLabel.richText = true;
                    return mHtmlLabel;
                }
                return mHtmlLabel;
            }
        }

        static GUIStyle mHtmlLinkLabel;
        public static GUIStyle HtmlLinkLabel
        {
            get
            {
                if (mHtmlLinkLabel == null)
                {
                    mHtmlLinkLabel = new GUIStyle(EditorStyles.label);
                    mHtmlLinkLabel.richText = true;
                    int h = (int)mHtmlLinkLabel.lineHeight;
                    mHtmlLinkLabel.normal.background = new Texture2D(1, h);
                    Color lineCol = new Color(.44f, .57f, .79f);
                    for (int i = 0; i < h; i++)
                        mHtmlLinkLabel.normal.background.SetPixel(0, i, (i==3) ? lineCol : new Color(0,0,0,0));
                    
                    mHtmlLinkLabel.normal.background.Apply();
                    
                    mHtmlLinkLabel.hover.background = mHtmlLinkLabel.normal.background;
                    mHtmlLinkLabel.hover.textColor = new Color(.44f, .57f, .79f);
                    return mHtmlLinkLabel;
                }
                return mHtmlLinkLabel;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTStyles.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTToolbar.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 5d3bf3b884967a3469804e83d059b658
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System;
using System.Linq;
using System.Reflection;
using FluffyUnderware.DevTools.Extensions;

namespace FluffyUnderware.DevToolsEditor
{
    public static class DTToolbar
    {
        const int ITEMSPACE = 10;
        const int PROJECTSPACE = 20;

        public static bool RecalcItemSize = true;
        public static bool MouseOverToolbarElement { get; private set; }

        static Vector2[] _MaxItemDimension = new Vector2[4]; // each Orientation has it's own max. Dimension
        /// <summary>
        /// Starting position for each side
        /// </summary>
        static Rect[] _InitialRects;
        /// <summary>
        /// Last item position for each side
        /// </summary>
        static Rect[] _ItemRect;

        static Event _handleEvent;

        internal static void Initialize()
        {
            RecalcItemSize = true;
            _handleEvent = null;
            loadItems();
            DTSelection.OnSelectionChange -= OnSelectionChange;
            DTSelection.OnSelectionChange += OnSelectionChange;
            SceneView.duringSceneGui -= Render;
            SceneView.duringSceneGui += Render;
            EditorApplication.hierarchyWindowItemOnGUI -= onHierarchy;
            EditorApplication.hierarchyWindowItemOnGUI += onHierarchy;
            EditorApplication.update -= onUpdate;
            EditorApplication.update += onUpdate;

        }


        static void loadItems()
        {
            foreach (DTProject prj in DT.Projects)
                prj.ToolbarItems.Clear();

            TypeCache.TypeCollection toolbarItemTypes = TypeCache.GetTypesDerivedFrom(typeof(DTToolbarItem));
            toolbarItemTypes.Intersect(TypeCache.GetTypesWithAttribute<ToolbarItemAttribute>()).ForEach(type => Activator.CreateInstance(type));

            foreach (DTProject prj in DT.Projects)
                prj.ToolbarItems.Sort();
        }

        static void OnSelectionChange()
        {
            foreach (DTProject project in DT.Projects)
                foreach (DTToolbarItem item in project.ToolbarItems)
                    item.OnSelectionChange();

            RecalcItemSize = true;
        }

        static void onHierarchy(int instanceID, Rect selectionRect)
        {
            if (Selection.instanceIDs.Contains(instanceID))
                _handleEvent = new Event(Event.current);
        }

        static void onUpdate()
        {
            if (Event.current != null || _handleEvent != null)
            {
                DTSelection.MuteEvents = true;
                foreach (DTProject project in DT.Projects)
                    foreach (DTToolbarItem item in project.ToolbarItems)
                    {
                        if (_handleEvent != null && item.Visible && item.Enabled)
                            item.HandleEvents(_handleEvent);
                        if (Event.current != null && item.Visible && item.Enabled)
                            item.HandleEvents(Event.current);
                    }
                DTSelection.MuteEvents = false;
            }
            _handleEvent = null;
        }


        static Rect getStatusBarRect()
        {
            Vector2 v = GUIUtility.GUIToScreenPoint(Vector2.zero);
            Rect r = SceneView.currentDrawingSceneView.position;
            // If SceneView is on another monitor, r.x doesn't start at 0, but GUIToScreenPoint gives the offset
            r.x -= v.x;
            r.y = _ItemRect[(int)DTToolbarOrientation.Bottom].y - 25;
            r.height = 20;

            return r;
        }

        public static bool detailOpen;

        static void Render(SceneView view)
        {
            Event ev = Event.current;
            MouseOverToolbarElement = false;
            // Only let certain hotkeys pass
            if (!EditorGUIUtility.editingTextField)
            {
                GUIUtility.keyboardControl = GUIUtility.GetControlID(FocusType.Passive);
            }

            List<DTProject> projects = DT.Projects;
            projects.Sort();

            Handles.BeginGUI();
            GUI.skin = null; // to ensure light-skin is used if set in preferences (or not Pro)
            // Get largest item for each side
            if (RecalcItemSize)
                calcMaxItemDimension();

            // Get starting position for each side
            _InitialRects = getInitialItemRect();
            _ItemRect = new Rect[4];
            _InitialRects.CopyTo(_ItemRect, 0);

            DTToolbarItem lastItem = null;
            DTSelection.MuteEvents = true;

            DTToolbarItem hovering = null;

            foreach (DTProject project in projects)
            {
                int side = (int)project.ToolbarOrientation;
                if (lastItem && lastItem.Project.ToolbarOrientation != project.ToolbarOrientation)
                    lastItem = null;
                List<DTToolbarItem> items = project.ToolbarItems;

                // Render items
                for (int i = 0; i < items.Count; i++)
                {
                    if (items[i].Visible)
                    {
                        Vector2 itemSize = items[i].GetItemSize(); // size of current item
                        _ItemRect[side] = advanceItemRect(lastItem, items[i], itemSize); // advance by using the last itemRect and the new(current) size

                        items[i].mItemRect = _ItemRect[side]; // Store current item rect


                        if (items[i].Enabled)
                        {
                            Handles.EndGUI();
                            EditorKeyBinding.BindingsEnabled = false;
                            if (items[i].mItemRect.Contains(DTGUI.MousePosition))
                            {
                                hovering = items[i];
                                MouseOverToolbarElement = true;
                            }
                            items[i].OnSceneGUI();

                            EditorKeyBinding.BindingsEnabled = true;
                            Handles.BeginGUI();
                        }
                        GUI.enabled = items[i].Enabled;
                        items[i].Render(_ItemRect[side]);

                        GUI.enabled = true;
                        if (ev != null && items[i].Enabled && (DTToolbarItem.FocusedItem == null || DTToolbarItem.FocusedItem == items[i]))
                            items[i].HandleEvents(ev);

                        lastItem = items[i];
                    }
                }
            }
            DTSelection.MuteEvents = false;
            detailOpen = false;
            // Render items client area (Note: itemRect contains the last rendered item, a.k.a. a way to get the number of rows/cols needed
            foreach (DTProject project in projects)
            {
                List<DTToolbarItem> items = project.ToolbarItems;
                for (int i = 0; i < items.Count; i++)
                {
                    if (items[i].Visible && items[i].ShowClientArea)
                    {
                        detailOpen = true;
                        Rect clientRect = items[i].mItemRect;
                        int side = (int)project.ToolbarOrientation;
                        switch (project.ToolbarOrientation)
                        {
                            case DTToolbarOrientation.Left:
                                clientRect.x = _ItemRect[side].x + _MaxItemDimension[side].x + 5;
                                break;
                            case DTToolbarOrientation.Right:
                                clientRect.x = _ItemRect[side].x - 5;
                                break;
                            case DTToolbarOrientation.Top:
                                clientRect.y = _ItemRect[side].y + _MaxItemDimension[side].y + 5;
                                break;
                            case DTToolbarOrientation.Bottom:
                                clientRect.y = _ItemRect[side].y - 5;
                                break;
                        }
                        if (clientRect.width > 0 && clientRect.height > 0)
                        {
                            items[i].mBackgroundRects.Clear();
                            MouseOverToolbarElement = MouseOverToolbarElement || clientRect.Contains(DTGUI.MousePosition);
                            EditorKeyBinding.BindingsEnabled = false;
                            items[i].RenderClientArea(clientRect);
                            EditorKeyBinding.BindingsEnabled = true;
                            if (DTGUI.IsClick)
                                foreach (Rect r in items[i].mBackgroundRects)
                                    if (r.Contains(ev.mousePosition))
                                        DTGUI.UseEvent(items[i].GetHashCode(), ev);
                        }
                    }
                }
            }

            // Handle statusbar info when hovering over an item
            if (hovering != null)
                DTToolbarItem._StatusBar.Set(hovering.StatusBarInfo, "Info");
            else
                DTToolbarItem._StatusBar.Clear("Info");

            // Render Statusbar
            DTToolbarItem._StatusBar.Render(getStatusBarRect(), null, true);

            Handles.EndGUI();

        }

        static Rect[] getInitialItemRect()
        {
            Rect[] res = new Rect[4];
            for (int side = 0; side < 4; side++)
            {
                Rect r = new Rect();
                switch (side)
                {
                    case (int)DTToolbarOrientation.Left:
                        r.x = 5; r.y = 10;
                        break;
                    case (int)DTToolbarOrientation.Right:
                        r.x = SceneView.currentDrawingSceneView.position.width - 10 - _MaxItemDimension[side].x;
                        r.y = 115;
                        break;
                    case (int)DTToolbarOrientation.Top:
                        float lft = _MaxItemDimension[(int)DTToolbarOrientation.Left].x;
                        r.x = 5; r.y = 10;
                        if (lft > 0)
                            r.x += 10 + lft;
                        break;
                    default: // Bottom
                        lft = _MaxItemDimension[(int)DTToolbarOrientation.Left].x;
                        r.x = 5; r.y = SceneView.currentDrawingSceneView.position.height - _MaxItemDimension[side].y - 30;
                        if (lft > 0)
                            r.x += 10 + lft;
                        break;
                }
                res[side] = r;
            }

            return res;
        }

        static Rect advanceItemRect(DTToolbarItem lastItem, DTToolbarItem newItem, Vector2 newItemSize)
        {
            Rect itemRect;
            float space = 0;
            int side = (int)newItem.Project.ToolbarOrientation;

            if (lastItem != null)
            {
                itemRect = lastItem.mItemRect;
                if (lastItem.Project != newItem.Project)
                    space = PROJECTSPACE;
                else
                    space = (newItem.Order - lastItem.Order >= 10) ? ITEMSPACE : 0;
            }
            else
                itemRect = _InitialRects[side];

            switch (newItem.Project.ToolbarOrientation)
            {
                case DTToolbarOrientation.Left:
                    itemRect.y += itemRect.height + 3 + space;
                    if (itemRect.y + newItemSize.y > SceneView.currentDrawingSceneView.position.height - 30)
                    {
                        itemRect.y = 10;
                        itemRect.x += _MaxItemDimension[(int)DTToolbarOrientation.Left].x + 5;
                    }
                    itemRect.width = _MaxItemDimension[(int)DTToolbarOrientation.Left].x;
                    itemRect.height = newItemSize.y;
                    break;
                case DTToolbarOrientation.Right:
                    itemRect.y += itemRect.height + 3 + space;
                    if (itemRect.y + newItemSize.y > SceneView.currentDrawingSceneView.position.height - 30)
                    {
                        itemRect.y = 10;
                        itemRect.x -= _MaxItemDimension[(int)DTToolbarOrientation.Right].x + 5;
                    }
                    itemRect.width = _MaxItemDimension[(int)DTToolbarOrientation.Right].x;
                    itemRect.height = newItemSize.y;
                    break;
                case DTToolbarOrientation.Top:
                    itemRect.x += 3 + itemRect.width + space;
                    if (itemRect.x + newItemSize.x > SceneView.currentDrawingSceneView.position.width - _MaxItemDimension[(int)DTToolbarOrientation.Left].x - _MaxItemDimension[(int)DTToolbarOrientation.Right].x)
                    {
                        itemRect.x = _InitialRects[(int)DTToolbarOrientation.Top].x;
                        itemRect.y += _MaxItemDimension[(int)DTToolbarOrientation.Top].y + 5;
                    }
                    itemRect.width = _MaxItemDimension[(int)DTToolbarOrientation.Top].x;
                    itemRect.height = newItemSize.y;
                    break;
                case DTToolbarOrientation.Bottom:
                    itemRect.x += 3 + itemRect.width + space;
                    if (itemRect.x + newItemSize.x > SceneView.currentDrawingSceneView.position.width - _MaxItemDimension[(int)DTToolbarOrientation.Left].x - _MaxItemDimension[(int)DTToolbarOrientation.Right].x)
                    {
                        itemRect.x = _InitialRects[(int)DTToolbarOrientation.Top].x;
                        itemRect.y -= _MaxItemDimension[(int)DTToolbarOrientation.Bottom].y + 5;
                    }
                    itemRect.width = _MaxItemDimension[(int)DTToolbarOrientation.Bottom].x;
                    itemRect.height = newItemSize.y;
                    break;

            }
            return itemRect;
        }

        /// <summary>
        /// For each side, find the item with the largest dimensions
        /// </summary>
        static void calcMaxItemDimension()
        {
            RecalcItemSize = false;
            _MaxItemDimension = new Vector2[4];
            int side;
            foreach (DTProject prj in DT.Projects)
            {
                side = (int)prj.ToolbarOrientation;
                foreach (DTToolbarItem item in prj.ToolbarItems)
                    if (item.Visible)
                        _MaxItemDimension[side] = Vector2.Max(_MaxItemDimension[side], item.GetItemSize());
            }
        }


        internal static void SetRadioGroupState(DTToolbarRadioButton active)
        {
            active.Project.SetRadioGroupState(active);
        }
    }

    public enum DTToolbarMode : int
    {
        Text = 1,
        Icon = 2,
        Full = 15,
    }

    public enum DTToolbarOrientation : int
    {
        Left = 0,
        Right = 1,
        Top = 2,
        Bottom = 3
    }

    public class DTToolbarStatus : DTStatusbar
    {

        protected override void GetColors()
        {
            GUI.contentColor = new Color(0, 0, 0, 0.75f);
        }
        protected override GUIStyle GetStyle()
        {
            GUIStyle style = base.GetStyle();
            style.alignment = TextAnchor.MiddleCenter;
            Texture2D bgTex = new Texture2D(1, 1);
            bgTex.SetPixel(0, 0, new Color(1, 1, 1, 0.5f));
            bgTex.Apply();
            bgTex.hideFlags = HideFlags.DontSave;
            style.normal.background = bgTex;
            return style;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTToolbar.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTToolbarItem.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c805355f5c0010740a0af2f9d9173e01
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using UnityEditor;
using System;
using FluffyUnderware.DevTools;
using System.Collections.Generic;

namespace FluffyUnderware.DevToolsEditor
{

    public abstract class DTToolbarItem : IComparable
    {
        /// <summary>
        /// If set, disables event processing for all other items.
        /// </summary>
        public static DTToolbarItem FocusedItem { get; set; }
        public Texture2D Icon
        {
            get
            {
                if (mIcon==null && !string.IsNullOrEmpty(mIconPackedString) && Project.Resource!=null)
                    mIcon = Project.Resource.LoadPacked(mIconPackedString);
                return mIcon;
            }
            set
            {
                if (mIcon != value)
                    mIcon = value;
            }
        }

        public string Label { get; set; }
        public string Tooltip { get; set; }
        public DTProject Project { get; set; }
        public int Order { get; set; }

        public static DTToolbarStatus _StatusBar = new DTToolbarStatus();

        public List<EditorKeyBinding> KeyBindings
        {
            get { return mKeyBindings;}
        }

        public GUIStyle Style
        {
            get { return DTStyles.TBButton; }
        }

        public GUIContent Content
        {
            get
            {
                string keyTT = (KeyBindings.Count>0) ? KeyBindings[0].ToTooltipString() : string.Empty;

                switch (Project.ToolbarMode)
                {
                    case DTToolbarMode.Icon:
                        if (Icon != null)
                            return new GUIContent(Icon, $"{Tooltip} {keyTT}");
                        else // fallback to "Text"
                            return new GUIContent(Label, $"{Tooltip} {keyTT}");
                    case DTToolbarMode.Text:
                        return new GUIContent(Label, $"{Tooltip} {keyTT}");
                    default:
                        return new GUIContent(Label, Icon, $"{Tooltip} {keyTT}");
                }
            }
        }

        public bool Visible
        {
            get { return mVisible; }
            set
            {
                if (mVisible != value)
                    mVisible=value;
            }
        }

        public bool Enabled
        {
            get { return mEnabled; }
            set
            {
                if (mEnabled != value)
                    mEnabled = value;
            }
        }

        public virtual bool ShowClientArea
        {
            get { return mShowClientArea; }
            set
            {
                if (mShowClientArea != value)
                    mShowClientArea = value;
            }
        }

        public bool IsMouseOver
        {
            get
            {
                return mItemRect.Contains(DTGUI.MousePosition);
            }
        }

        public virtual string StatusBarInfo
        {
            get { return string.Empty; }
        }

        bool mVisible = true;
        bool mEnabled = true;
        bool mShowClientArea;
        readonly string mIconPackedString;
        Texture2D mIcon;
        readonly List<EditorKeyBinding> mKeyBindings = new List<EditorKeyBinding>();

        static DTToolbarItem _lastClickedItem;

        internal Rect mItemRect;
        internal List<Rect> mBackgroundRects = new List<Rect>();

        protected DTToolbarItem()
        {
            object[] attribs = this.GetType().GetCustomAttributes(typeof(ToolbarItemAttribute), true);
            if (attribs.Length > 0)
            {
                ToolbarItemAttribute a=(ToolbarItemAttribute)attribs[0];
                Project = DT.Project(a.Project);
                Project.ToolbarItems.Add(this);
                Label = a.Label;
                Tooltip = a.Tooltip;
                if (!string.IsNullOrEmpty(a.Icon))
                {
                    mIconPackedString = (!EditorGUIUtility.isProSkin && !string.IsNullOrEmpty(a.IconLightSkin)) ? a.IconLightSkin : a.Icon;
                }
                Order = a.Order;
                OnSelectionChange();
            }
        }


        #region ### Events ###

        public virtual void OnClick()
        {
            if (_lastClickedItem!=null && _lastClickedItem!=this)
                _lastClickedItem.OnOtherItemClicked(this);
            _lastClickedItem = this;
        }

        public virtual void OnSelectionChange()
        {
        }

        public virtual void OnOtherItemClicked(DTToolbarItem other)
        {
        }


        #endregion

        /// <summary>
        /// Renders the item (button etc.) itself inside a Handles.BeginGUI()/Handles.EndGUI() block
        /// </summary>
        /// <param name="r">area to use</param>
        public virtual void Render(Rect r)
        {
        }

        /// <summary>
        /// Renders an item's client area (if ShowClientArea==true) inside a Handles.BeginGUI()/Handles.EndGUI() block
        /// </summary>
        /// <param name="r">initial Rect with x/y set to starting position</param>
        public virtual void RenderClientArea(Rect r)
        {
        }

        /// <summary>
        /// Regular OnSceneGUI call. Place preview etc. here
        /// </summary>
        public virtual void OnSceneGUI()
        {
        }

        /// <summary>
        /// Returns the size of the item
        /// </summary>
        /// <returns>the size the item needs</returns>
        public virtual Vector2 GetItemSize()
        {
            return Style.CalcSize(Content);
        }

        public virtual void HandleEvents(Event e)
        {
            if (KeyBindings.Count > 0 && KeyBindings[0].IsTriggered(e))
                OnClick();
        }



        #region ### GUI Orientation Helpers ###

        /// <summary>
        /// Changes the rect to properly place an GUI control with a certain width and height.
        /// </summary>
        /// <remarks>Call this before the first GUI control, but after Background()</remarks>
        /// <param name="r"></param>
        /// <param name="width"></param>
        /// <param name="height"></param>
        protected void SetElementSize(ref Rect r, float width, float height)
        {
            r.width = width;
            r.height = height;
            switch (Project.ToolbarOrientation)
            {
                case DTToolbarOrientation.Right:
                    r.x -= r.width;
                    break;
                case DTToolbarOrientation.Bottom:
                    r.y-=r.height;
                    break;
            }


            //SmallLineAdjust(ref r,height);
            Rect scene=SceneView.currentDrawingSceneView.position;

            if (r.xMax > scene.width)
                r.xMin = scene.width - r.width;
            if (r.yMax > scene.height)
                r.yMin = scene.height - r.height;
        }

        /// <summary>
        /// Draws a background, taking only position from the rect
        /// </summary>
        /// <param name="r"></param>
        /// <param name="width"></param>
        /// <param name="height"></param>
        /// <param name="guiStyle"></param>
        protected void Background(Rect r, float width, float height,GUIStyle guiStyle=null)
        {
            mBackgroundRects.Add(r);
            if (guiStyle == null)
                guiStyle = DTStyles.TBBackground;
            r.y -= 1;
            r.x -= 1;
            r.width = width + 2;
            r.height = height + 2;
            switch (Project.ToolbarOrientation)
            {
                case DTToolbarOrientation.Right:
                    r.x-=width;
                    break;
                case DTToolbarOrientation.Bottom:
                    r.y -= height;
                    break;
            }


            GUI.Box(r, "", guiStyle);

        }

        /// <summary>
        /// Advance the rect to a new line, respecting Toolbar Orientation
        /// </summary>
        protected void Advance(ref Rect r) { Advance(ref r, r.height); }
        /// <summary>
        /// Advance the rect to a new line, respecting Toolbar Orientation
        /// </summary>
        protected void Advance(ref Rect r, float lastLineHeight)
        {
            switch (Project.ToolbarOrientation)
            {
                case DTToolbarOrientation.Bottom:
                    r.y -= lastLineHeight + 5;
                    break;
                case DTToolbarOrientation.Left:
                    r.x += r.width + 2;
                    break;
                case DTToolbarOrientation.Right:
                    r.x -= r.width + 2;
                    break;
                default: // Top
                    r.y += lastLineHeight + 5;
                    break;
            }
        }

        /// <summary>
        /// Advance the rect to a new line below (or above) the existing rect, depending on Toolbar Orientation
        /// </summary>
        protected void AdvanceBelow(ref Rect r) { AdvanceBelow(ref r, r.height); }
        /// <summary>
        /// Advance the rect to a new line below (or above) the existing rect, depending on Toolbar Orientation
        /// </summary>
        protected void AdvanceBelow(ref Rect r, float lastLineHeight)
        {
            switch (Project.ToolbarOrientation)
            {
                case DTToolbarOrientation.Bottom:
                    r.y -= lastLineHeight;
                    break;
                default:
                    r.y += lastLineHeight;
                    break;
            }
        }

        #endregion

        public int CompareTo(object obj)
        {
            DTToolbarItem other = (DTToolbarItem)obj;

            if (Order == other.Order)
                return Label.CompareTo(other.Label);
            else
                return Order.CompareTo(other.Order);
        }

        public static implicit operator bool(DTToolbarItem a)
        {
            return !object.ReferenceEquals(a, null);
        }
    }

    [AttributeUsage(AttributeTargets.Class,AllowMultiple=false)]
    public class ToolbarItemAttribute : Attribute
    {
        public readonly string Project;
        public readonly int Order;
        public readonly string Label;
        public readonly string Tooltip;
        public readonly string Icon;
        public readonly string IconLightSkin;

        public ToolbarItemAttribute(int order, string project, string label, string tooltip = "", string icon = "",string iconLight="") : this(project,label,tooltip,icon,iconLight,order)
        {
        }

        public ToolbarItemAttribute(string project, string label, string tooltip = "", string icon = "", string iconLight="", int order = 0)
        {
            Project = project;
            Label = label;
            Tooltip = tooltip;
            Icon = icon;
            IconLightSkin = iconLight;
            Order = order;
        }
    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/DTToolbarItem.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/EditorData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6ab6be8bc89cf594f8be7d642df90bf5
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using UnityEditor;
using UnityEditor.AnimatedValues;
using UnityEngine.Events;

namespace FluffyUnderware.DevToolsEditor.Data{
    [System.Serializable]
    public class AnimVector2 : BaseAnimValue<Vector2>
    {
        [SerializeField]
        private Vector3 m_Value;
        public AnimVector2()
            : base(Vector2.zero)
        {
        }
        public AnimVector2(Vector3 value)
            : base(value)
        {
        }
        public AnimVector2(Vector2 value, UnityAction callback)
            : base(value, callback)
        {
        }
        protected override Vector2 GetValue()
        {
            this.m_Value = Vector2.Lerp(base.start, base.target, base.lerpPosition);
            return this.m_Value;
        }

        public override string ToString()
        {
            return $"{value} / {target}. Speed {speed}. Lerp {lerpPosition}";
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/EditorData.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/EditorKeyDefinition.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 97a419ac824222d41b8a477f5151f56a
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System;


namespace FluffyUnderware.DevToolsEditor
{
    [System.Serializable]
    public class EditorKeyBinding : IComparable
    {
        public static bool BindingsEnabled = true;

        public enum MouseButtonEnum
        {
            None = -1,
            Click = 0,
            RClick = 1,
            MClick = 2,
        }

        public string Name;
        public string Description;
        public KeyCode Key;
        public bool Shift;
        public bool Control;
        public bool Alt;
        public bool Command;
        public MouseButtonEnum MouseButton;

        public bool ShowInPrefs = true;
        
        public EditorKeyBinding(string name, string description, KeyCode defKey = KeyCode.None, bool defShift = false, bool defControl = false, bool defAlt = false, bool defCommand = false, MouseButtonEnum defMouseButton = MouseButtonEnum.None)
        {
            Set(name, description, defKey, defShift, defControl, defAlt, defCommand, defMouseButton);
        }

        /// <summary>
        /// Creates a binding from it's serialized string from the user preferences
        /// </summary>
        public EditorKeyBinding(string bindingString)
        {
            Set(bindingString);
        }

        /// <summary>
        /// Set the binding from it's serialized string from the user preferences
        /// </summary>
        public void Set(string bindingString)
        {
            string[] s = bindingString.Split(',');
            if (s.Length < 6) return;
            Name = s[0];
            Key = (KeyCode)System.Enum.Parse(typeof(KeyCode), s[1]);
            Shift = bool.Parse(s[2]);
            Control = bool.Parse(s[3]);
            Alt = bool.Parse(s[4]);
            Command = bool.Parse(s[5]);
            MouseButton = (MouseButtonEnum)System.Enum.Parse(typeof(MouseButtonEnum), s[6]);
        }

        public void Set(string name, string description, KeyCode defKey = KeyCode.None, bool defShift = false, bool defControl = false, bool defAlt = false, bool defCommand = false, MouseButtonEnum defMouseButton = MouseButtonEnum.None)
        {
            Name = name;
            Description = description;
            Key = defKey;
            Shift = defShift;
            Control = defControl;
            Alt = defAlt;
            Command = defCommand;
            MouseButton = defMouseButton;
        }
       

        public bool IsTriggered(Event e=null)
        {
            
            if (!BindingsEnabled)
                return false;
            
            if (e == null)
                e = Event.current;
            if ((e.type == EventType.MouseDown && e.button == (int)MouseButton) ||
                (e.type == EventType.KeyDown && Key != KeyCode.None && e.keyCode == Key))
                return (e.shift == Shift &&
                        e.control == Control &&
                        e.alt == Alt &&
                        e.command == Command);
            else
                return false;
        }

        public bool OnPreferencesGUI()
        {
            EditorGUI.BeginChangeCheck();
            Key = (KeyCode)EditorGUILayout.EnumPopup(new GUIContent(Name), Key);
            EditorGUILayout.BeginHorizontal();
            GUILayout.FlexibleSpace();
            Shift = GUILayout.Toggle(Shift, "Shift");
            Control = GUILayout.Toggle(Control, "Ctrl");
            Alt = GUILayout.Toggle(Alt, "Alt");
            Command = GUILayout.Toggle(Command, "Cmd");
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.BeginHorizontal();
            GUILayout.FlexibleSpace();
            MouseButton = (MouseButtonEnum)EditorGUILayout.EnumPopup(MouseButton);
            EditorGUILayout.EndHorizontal();
            return EditorGUI.EndChangeCheck();
        }

        public string ToTooltipString()
        {
            if (Key == KeyCode.None && MouseButton==MouseButtonEnum.None)
                return string.Empty;

            List<string> s = new List<string>();
            if (Control)
                s.Add("Ctrl");
            if (Alt)
                s.Add("Alt");
            if (Shift)
                s.Add("Shift");
            if (Command)
                s.Add("Cmd");
            
            string res = string.Join("-", s.ToArray());
            if (res.Length > 0)
                res += "-";

            if (Key != KeyCode.None)
                return "(" + res + Key.ToString() + ")";
            else
                return "(" + res + MouseButton.ToString() + ")";
        }

        public string ToPrefsString()
        {
            return Name + "," + ((int)Key).ToString() + "," + Shift.ToString() + "," + Control.ToString() + "," + Alt.ToString() + "," + Command.ToString() + "," + ((int)MouseButton).ToString();
        }

        public int CompareTo(object obj)
        {
            return Name.CompareTo(((EditorKeyBinding)obj).Name);
        }

        public override bool Equals(object obj)
        {
            EditorKeyBinding o = (EditorKeyBinding)obj;
            return (Name == o.Name &&
                    Key == o.Key &&
                    Shift == o.Shift &&
                    Control == o.Control &&
                    Alt == o.Alt &&
                    Command == o.Command &&
                    MouseButton == o.MouseButton);
        }
        public override int GetHashCode()
        {
            return Name.GetHashCode() ^ Key.GetHashCode() ^ Shift.GetHashCode() ^ Control.GetHashCode() ^ Alt.GetHashCode() ^ Command.GetHashCode() ^ MouseButton.GetHashCode();
        }
        
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/EditorKeyDefinition.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/Extensions/EditorExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 21c52a1cbd7d1274f95e82c253456bda
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Reflection;
using System.Collections.Generic;
using FluffyUnderware.DevTools.Extensions;
using Object = UnityEngine.Object;
using System;
using System.Collections;



namespace FluffyUnderware.DevToolsEditor.Extensions
{

    public static class ColorEditorExt
    {

        public static Color SkinAwareColor(this Color c, bool subtle = false)
        {
            if (EditorGUIUtility.isProSkin)
                return c;
            else
            {



                if (subtle)
                    return Color.Lerp(c, Color.white,
                        0.9f);
                else
                {
                    if (c == Color.white)
                        return Color.black;
                    else if (c == Color.black)
                        return Color.white;
                    else
                    {
                        float br = c.Brightness();
                        if (br > 0.9)
                            return Color.Lerp(c, Color.black, 0.7f);
                        else
                            return Color.Lerp(c, Color.black, 0.2f);
                    }
                }
            }
        }

        public static float Brightness(this Color c)
        {
            return 0.299f * c.r + 0.587f * c.g + 0.114f * c.b;
        }

        public static Color Fade(this Color c, double startTime, double stayTime, float fadeSpeed)
        {
            double d = EditorApplication.timeSinceStartup - startTime;
            if (stayTime == 0 || d < stayTime)
                return c;
            else
                return new Color(c.r, c.g, c.b, 1 - Mathf.Clamp01((float)(d - stayTime) / Mathf.Max(0, 0001f, fadeSpeed)));
        }
    }

    public static class SerializePropertyExt
    {

        public static GUIContent GetContent(this SerializedProperty property, string label, string tooltip)
        {
            if (string.IsNullOrEmpty(label))
                label = property.displayName;
            return new GUIContent(label, tooltip);
        }

        public static List<System.Attribute> GetAttributes(this SerializedProperty property, params System.Type[] ofType)
        {
            List<System.Attribute> res = new List<System.Attribute>();
            Type objType = property.GetObjectType();
            if (objType != null)
            {
                FieldInfo fi = objType.FieldByName(property.name, true, true);

                if (fi != null)
                {
                    object[] attribs = fi.GetCustomAttributes(true);
                    foreach (System.Attribute a in attribs)
                    {

                        if (ofType.Length == 0)
                            res.Add(a);
                        else
                        {
                            Type at = a.GetType();
                            foreach (Type t in ofType)
                                if (t.IsAssignableFrom(at))
                                {
                                    res.Add(a);
                                    break;
                                }
                        }
                    }
                }
            }
            return res;
        }

        /// <summary>
        /// Gets the objec type the property is a children of.
        /// </summary>
        public static Type GetObjectType(this SerializedProperty property)
        {
            Type baseType = property.serializedObject.targetObject.GetType();
            if (property.depth > 0)
            {
                string[] path = property.Path();
                FieldInfo fi;
                for (int i = 0; i < path.Length - 1; i++)
                {
                    fi = baseType.GetField(path[i], BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                    if (fi == null)
                        return null;
                    baseType = fi.FieldType;
                }
            }
            return baseType;
        }

        /// <summary>
        /// Gets the field type
        /// </summary>
        public static Type GetFieldType(this SerializedProperty property)
        {
            Type parentType = GetObjectType(property);
            FieldInfo fi = parentType.FieldByName(property.name, true, true);
            if (fi != null)
            {
                Type tt = fi.FieldType;
                if (tt.IsGenericType && tt.GetGenericTypeDefinition() == typeof(List<>))
                {
                    return tt.GetGenericArguments()[0];
                }
                if (fi.FieldType.IsArray)
                    return fi.FieldType.GetElementType();
                else
                    return fi.FieldType;
            }
            else
                return null;
        }

        public static string[] Path(this SerializedProperty property)
        {
            return property.propertyPath.Split('.');
        }

        public static SerializedProperty Parent(this SerializedProperty property)
        {
            string[] path = property.propertyPath.Split('.');
            if (path.Length > 1)
                return property.serializedObject.FindProperty(path[path.Length - 2]);
            else
                return property;
        }

        public static object GetParentObject(this SerializedProperty prop)
        {
            string path = prop.propertyPath.Replace(".Array.data[", "[");
            object obj = prop.serializedObject.targetObject;
            string[] elements = path.Split('.');
            for (int i = 0; i < elements.Length - 1; i++)
            {
                string element = elements[i];
                if (element.Contains("["))
                {
                    string elementName = element.Substring(0, element.IndexOf("["));
                    int index = Convert.ToInt32(element.Substring(element.IndexOf("[")).Replace("[", "").Replace("]", ""));
                    obj = getValue(obj, elementName, index);
                }
                else
                {
                    obj = getValue(obj, element);
                }
            }
            return obj;
        }

        static object getValue(object source, string name)
        {
            if (source == null)
                return null;
            Type type = source.GetType();
            FieldInfo f = type.GetField(name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance);
            if (f == null)
            {
                PropertyInfo p = type.GetProperty(name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
                if (p == null)
                    return null;
                return p.GetValue(source, null);
            }
            return f.GetValue(source);
        }

        static object getValue(object source, string name, int index)
        {
            IEnumerable enumerable = getValue(source, name) as IEnumerable;
            IEnumerator enm = enumerable.GetEnumerator();
            while (index-- >= 0)
                enm.MoveNext();
            return enm.Current;
        }


        public static SerializedProperty Root(this SerializedProperty property)
        {
            string[] path = property.propertyPath.Split('.');
            if (path.Length > 0)
                return property.serializedObject.FindProperty(path[0]);
            else
                return property;
        }
    }

    public static class RectEditorExt
    {
        public static Rect ShiftXBy(this Rect r, float x)
        {
            r.x += x;
            r.width -= x;
            return new Rect(r);
        }

        public static Rect WithoutLabel(this Rect r)
        {
            return r.ShiftXBy(EditorGUIUtility.labelWidth);
        }
    }






}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/Extensions/EditorExtensions.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/PropertyDrawers.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1bc4fb38a6e10f34c8923621b5f349d7
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

#if UNITY_5_4 || UNITY_5_3 || UNITY_5_2 || UNITY_5_1 || UNITY_5_0
#define UNITY_PRE_5_5
#endif
using System;
using UnityEngine;
using UnityEditor;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevToolsEditor.Extensions;
using System.Reflection;
using System.Collections.Generic;
using System.Linq;
using System.Collections;
using MinAttribute = FluffyUnderware.DevTools.MinAttribute;

namespace FluffyUnderware.DevToolsEditor
{
    public class DTPropertyDrawer<T> : PropertyDrawer where T : DTPropertyAttribute
    {

        /// <summary>
        /// Gets the attribute
        /// </summary>
        protected T Attribute
        {
            get { return attribute as T; }
        }

        /// <summary>
        /// Gets some common attribute options
        /// </summary>
        protected AttributeOptionsFlags Options
        {
            get { return Attribute.Options; }
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            if (!string.IsNullOrEmpty(Attribute.Label))
                label.text = Attribute.Label;
            label.tooltip = Attribute.Tooltip;
        }

        protected void PushCustomColors()
        {
            if (!string.IsNullOrEmpty(Attribute.Color))
                DTGUI.PushColor(Attribute.Color.ColorFromHtml());
        }

        protected void PopCustomColors()
        {
            if (!string.IsNullOrEmpty(Attribute.Color))
                DTGUI.PopColor();
        }

        protected MemberInfo GetMemberInfo(SerializedProperty property, string fieldOrPropertyName, out object parent)
        {
            parent = property.GetParentObject();
            Type parentType = parent.GetType();
            FieldInfo fi = parentType.FieldByName(fieldOrPropertyName, true, true);
            if (fi != null)
                return fi;
            else
            {
                PropertyInfo pi = parentType.PropertyByName(fieldOrPropertyName, true, true);
                if (pi != null)
                    return pi;
                else
                {
                    DTLog.LogError(parentType.Name + ": Field or Property '" + fieldOrPropertyName + "' not found!", property.serializedObject.targetObject);
                    return null;
                }
            }
        }

        /// <summary>
        /// Get a value from a field or property of the serialized object by it's name
        /// </summary>
        /// <typeparam name="U">datatype to retrieve</typeparam>
        /// <param name="property">a serialized property from the object in question</param>
        /// <param name="fieldOrPropertyName">name of the field or property</param>
        /// <returns>the value of the field or property</returns>
        protected U GetMemberValue<U>(SerializedProperty property, string fieldOrPropertyName)
        {
            object parent;
            object o = null;
            MemberInfo mi = GetMemberInfo(property, fieldOrPropertyName, out parent);
            if (mi != null)
            {
                if (mi is FieldInfo)
                    o = ((FieldInfo)mi).GetValue(parent);
                else
                    o = ((PropertyInfo)mi).GetValue(parent, null);
            }

            Type oT = o.GetType();
            Type rT = typeof(U);
            if (oT == rT)
                return (U)o;
            else if (oT == typeof(int) && rT == typeof(float))
                return (U)System.Convert.ChangeType(o, rT, System.Globalization.CultureInfo.InvariantCulture);
            else
                return default;
        }

        protected object GetParent(SerializedProperty prop)
        {
            string path = prop.propertyPath.Replace(".Array.data[", "[");
            object obj = prop.serializedObject.targetObject;
            string[] elements = path.Split('.');
            foreach (string element in elements.Take(elements.Length - 1))
            {
                if (element.Contains("["))
                {
                    string elementName = element.Substring(0, element.IndexOf("["));
                    int index = System.Convert.ToInt32(element.Substring(element.IndexOf("[")).Replace("[", "").Replace("]", ""));
                    obj = GetValue(obj, elementName, index);
                }
                else
                {
                    obj = GetValue(obj, element);
                }
            }
            return obj;
        }

        object GetValue(object source, string name)
        {
            if (source == null)
                return null;
            Type type = source.GetType();
            FieldInfo f = type.FieldByName(name, true, true);
            if (f == null)
            {
                PropertyInfo p = type.PropertyByName(name, true, true);
                if (p == null)
                    return null;
                return p.GetValue(source, null);
            }
            return f.GetValue(source);
        }

        object GetValue(object source, string name, int index)
        {
            IEnumerable enumerable = GetValue(source, name) as IEnumerable;
            IEnumerator enm = enumerable.GetEnumerator();
            while (index-- >= 0)
                enm.MoveNext();
            return enm.Current;
        }

        protected U GetPropertySourceField<U>(SerializedProperty property)
        {
            return (U)fieldInfo.GetValue(GetParent(property));
            /*
            var instance = property.serializedObject.targetObject;
            var t = instance.GetType();
            FieldInfo fi = null;
            while (fi == null && t != null)
            {
                fi = t.GetField(property.propertyPath, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
                if (fi == null)
                    t = t.BaseType;
            }
            return (fi != null) ? (U)fi.GetValue(instance) : default(U);
            */
        }
    }

    [CustomPropertyDrawer(typeof(LabelAttribute))]
    public class LabelAttributePropertyDrawer : DTPropertyDrawer<LabelAttribute>
    {
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            base.OnGUI(position, property, label);
            EditorGUI.PropertyField(position, property, label);
        }
    }

    [CustomPropertyDrawer(typeof(ToggleButtonAttribute))]
    public class ToggleButtonAttributePropertyDrawer : DTPropertyDrawer<ToggleButtonAttribute>
    {
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            base.OnGUI(position, property, label);
            if (property.propertyType != SerializedPropertyType.Boolean)
                DTLog.LogError("[DevTools] - [ToggleButton] only valid for boolean fields!", property.serializedObject.targetObject);
            else
            {
                EditorGUI.BeginChangeCheck();
                GUIStyle st = GUI.skin.button;

                bool v = GUI.Toggle(position, property.boolValue, label, st);
                if (EditorGUI.EndChangeCheck())
                    property.boolValue = v;
            }
        }
    }

    [CustomPropertyDrawer(typeof(LayerAttribute))]
    public class LayerPropertyDrawer : DTPropertyDrawer<LayerAttribute>
    {
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            EditorGUI.BeginProperty(position, GUIContent.none, property);
            position = EditorGUI.PrefixLabel(position, GUIUtility.GetControlID(FocusType.Passive), label);
            property.intValue = EditorGUI.LayerField(position, property.intValue);
            EditorGUI.EndProperty();
        }
    }

    [CustomPropertyDrawer(typeof(TagAttribute))]
    public class TagPropertyDrawer : DTPropertyDrawer<TagAttribute>
    {
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            EditorGUI.BeginProperty(position, GUIContent.none, property);
            position = EditorGUI.PrefixLabel(position, GUIUtility.GetControlID(FocusType.Passive), label);
            property.stringValue = EditorGUI.TagField(position, property.stringValue);
            EditorGUI.EndProperty();
        }
    }

    [CustomPropertyDrawer(typeof(VectorExAttribute))]
    public class VectorExPropertyDrawer : DTPropertyDrawer<VectorExAttribute>
    {
        private static readonly GUIContent CopyButtonGuiContent = new GUIContent("C", "Copy");
        private static readonly GUIContent PasteButtonGuiContent = new GUIContent("P", "Past");
        private static readonly GUIContent SetZeroButtonGuiContent = new GUIContent("0", "Set to zero");
        private static readonly GUIContent SetOneButtonGuiContent = new GUIContent("1", "Set to one");
        private static readonly GUIContent NegateButtonGuiContent = new GUIContent("~", "Negate");

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            float h;
            if (Options.HasFlag(AttributeOptionsFlags.Compact) || EditorGUIUtility.wideMode)
                h = base.GetPropertyHeight(property, label);
            else
                h = base.GetPropertyHeight(property, label) * 2;
            return h;
        }


        public static void DoGUI(Rect position, SerializedProperty property, DTPropertyAttribute attribute, GUIContent label, AttributeOptionsFlags flags, VectorExPropertyDrawer drawer = null)
        {
            if (property.propertyType != SerializedPropertyType.Vector2 && property.propertyType != SerializedPropertyType.Vector3 && property.propertyType != SerializedPropertyType.Quaternion)
                DTLog.LogError("[DevTools] - [VectorEx] only valid for Vector and Quaternion fields!", property.serializedObject.targetObject);
            else
            {

                int buttons = 0;
                if (flags.HasFlag(AttributeOptionsFlags.Clipboard))
                    buttons += 2;
                if (flags.HasFlag(AttributeOptionsFlags.One))
                    buttons++;
                if (flags.HasFlag(AttributeOptionsFlags.Zero))
                    buttons++;
                if (flags.HasFlag(AttributeOptionsFlags.Negate))
                    buttons++;

                int buttonWidth = 21;
                int interButtonSpace = 1;
                int buttonsWidth = buttons * buttonWidth + Math.Max(0, buttons - 1) * interButtonSpace;

                Rect buttonsRectangle = new Rect();
                buttonsRectangle.x = position.x + position.width - buttonsWidth;
                buttonsRectangle.y = position.y;
                buttonsRectangle.width = buttonWidth;
                buttonsRectangle.height = EditorGUIUtility.singleLineHeight;

                Rect r = position.WithoutLabel();
                r.width -= buttonsWidth;

                if (flags.HasFlag(AttributeOptionsFlags.Compact) || EditorGUIUtility.wideMode)
                {
                    if (drawer != null)
                        drawer.PushCustomColors();
                    EditorGUI.PrefixLabel(position, label);

                    if (property.propertyType == SerializedPropertyType.Vector2)
                    {
                        EditorGUI.BeginChangeCheck();
                        Vector2 v = DTGUI.CompactVector2Field(r, property.vector2Value);
                        if (EditorGUI.EndChangeCheck())
                            property.vector2Value = DT._UseSnapValuePrecision ? DTMath.SnapPrecision(v, attribute.Precision) : v;
                    }
                    else if (property.propertyType == SerializedPropertyType.Vector3)
                    {
                        EditorGUI.BeginChangeCheck();
                        Vector3 v = DTGUI.CompactVector3Field(r, property.vector3Value);
                        if (EditorGUI.EndChangeCheck())
                            property.vector3Value = DT._UseSnapValuePrecision ? DTMath.SnapPrecision(v, attribute.Precision) : v;
                    }
                    else if (property.propertyType == SerializedPropertyType.Quaternion)
                    {
                        EditorGUI.BeginChangeCheck();
                        Vector3 v = DTGUI.CompactVector3Field(r, DT._UseSnapValuePrecision ? DTMath.SnapPrecision(property.quaternionValue.eulerAngles, attribute.Precision) : property.quaternionValue.eulerAngles);
                        if (EditorGUI.EndChangeCheck())
                            property.quaternionValue = Quaternion.Euler(v);
                    }
                    if (drawer != null)
                        drawer.PopCustomColors();

                }
                else
                {
                    EditorGUI.BeginChangeCheck();
                    if (drawer != null)
                        drawer.PushCustomColors();

#pragma warning disable 162
                    position.y -= 2;
#pragma warning restore 162

                    EditorGUI.PropertyField(position, property, label);
                    if (drawer != null)
                        drawer.PopCustomColors();
                    if (EditorGUI.EndChangeCheck() && DT._UseSnapValuePrecision)
                    {
                        if (property.propertyType == SerializedPropertyType.Vector2)
                            property.vector2Value = DTMath.SnapPrecision(property.vector2Value, attribute.Precision);
                        else if (property.propertyType == SerializedPropertyType.Vector3)
                            property.vector3Value = DTMath.SnapPrecision(property.vector3Value, attribute.Precision);
                    }
                }

                if (flags.HasFlag(AttributeOptionsFlags.Clipboard))
                {
                    if (GUI.Button(buttonsRectangle, CopyButtonGuiContent, EditorStyles.miniButton))
                        if (property.propertyType == SerializedPropertyType.Vector2)
                            DT.ClipboardCopy(property.vector2Value);
                        else if (property.propertyType == SerializedPropertyType.Vector3)
                            DT.ClipboardCopy(property.vector3Value);
                    buttonsRectangle.x += buttonWidth + interButtonSpace;
                    // Can Paste?
                    if (property.propertyType == SerializedPropertyType.Vector2)
                        GUI.enabled = DT.ClipboardCanPasteTo<Vector2>();
                    else if (property.propertyType == SerializedPropertyType.Vector3)
                        GUI.enabled = DT.ClipboardCanPasteTo<Vector3>();

                    if (GUI.Button(buttonsRectangle, PasteButtonGuiContent, EditorStyles.miniButton))
                        if (property.propertyType == SerializedPropertyType.Vector2)
                            property.vector2Value = DT.ClipboardPaste<Vector2>();
                        else if (property.propertyType == SerializedPropertyType.Vector3)
                            property.vector3Value = DT.ClipboardPaste<Vector3>();
                    GUI.enabled = true;
                    buttonsRectangle.x += buttonWidth + interButtonSpace;
                }
                if (flags.HasFlag(AttributeOptionsFlags.Zero))
                {
                    if (GUI.Button(buttonsRectangle, SetZeroButtonGuiContent, EditorStyles.miniButton))
                        if (property.propertyType == SerializedPropertyType.Vector2)
                            property.vector2Value = Vector2.zero;
                        else if (property.propertyType == SerializedPropertyType.Vector3)
                            property.vector3Value = Vector3.zero;
                    buttonsRectangle.x += buttonWidth + interButtonSpace;
                }
                if (flags.HasFlag(AttributeOptionsFlags.One))
                {
                    if (GUI.Button(buttonsRectangle, SetOneButtonGuiContent, EditorStyles.miniButton))
                        if (property.propertyType == SerializedPropertyType.Vector2)
                            property.vector2Value = Vector2.one;
                        else if (property.propertyType == SerializedPropertyType.Vector3)
                            property.vector3Value = Vector3.one;
                    buttonsRectangle.x += buttonWidth + interButtonSpace;
                }
                if (flags.HasFlag(AttributeOptionsFlags.Negate))
                {
                    if (GUI.Button(buttonsRectangle, NegateButtonGuiContent, EditorStyles.miniButton))
                        if (property.propertyType == SerializedPropertyType.Vector2)
                            property.vector2Value *= -1;
                        else if (property.propertyType == SerializedPropertyType.Vector3)
                            property.vector3Value *= -1;
                    buttonsRectangle.x += buttonWidth + interButtonSpace;
                }

            }

        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            base.OnGUI(position, property, label);
            DoGUI(position, property, Attribute, label, Options, this);
        }
    }

    [CustomPropertyDrawer(typeof(AnimationCurveExAttribute))]
    public class AnimationCurveExPropertyDrawer : DTPropertyDrawer<AnimationCurveExAttribute>
    {

        public override void OnGUI(Rect propertyRectangle, SerializedProperty property, GUIContent label)
        {
            base.OnGUI(propertyRectangle, property, label);
            if (property.propertyType != SerializedPropertyType.AnimationCurve)
                DTLog.LogError("[DevTools] - [AnimationCurvEx] only valid for AnimationCurve fields!", property.serializedObject.targetObject);
            else
            {
                int buttons = 0;
                if (Options.HasFlag(AttributeOptionsFlags.Clipboard))
                    buttons += 2;

                int buttonWidth = 21;
                int interButtonSpace = 1;
                int buttonsWidth = buttons * buttonWidth + Math.Max(0, buttons - 1) * interButtonSpace;

                Rect buttonsRectangle = new Rect();
                buttonsRectangle.x = propertyRectangle.x + propertyRectangle.width - buttonsWidth;
                buttonsRectangle.y = propertyRectangle.y;
                buttonsRectangle.width = buttonWidth;
                buttonsRectangle.height = EditorGUIUtility.singleLineHeight;

                propertyRectangle.width -= buttonsWidth;

                EditorGUI.PropertyField(propertyRectangle, property, label);
                // Buttons
                if (Options.HasFlag(AttributeOptionsFlags.Clipboard))
                {
                    if (GUI.Button(buttonsRectangle, "C", EditorStyles.miniButton))
                        DT.ClipboardCopy(property.animationCurveValue);
                    buttonsRectangle.x += buttonWidth + interButtonSpace;
                    GUI.enabled = DT.ClipboardCanPasteTo<AnimationCurve>();
                    if (GUI.Button(buttonsRectangle, "P", EditorStyles.miniButton))
                        property.animationCurveValue = DT.ClipboardPaste<AnimationCurve>();
                    GUI.enabled = true;
                }
            }
        }
    }



    [CustomPropertyDrawer(typeof(RangeExAttribute))]
    public class RangeExPropertyDrawer : DTPropertyDrawer<RangeExAttribute>
    {
        float minV;
        float maxV;

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            base.OnGUI(position, property, label);


            minV = Attribute.MinValue;
            maxV = Attribute.MaxValue;

            if (!string.IsNullOrEmpty(Attribute.MinFieldOrPropertyName))
            {
                minV = GetMemberValue<float>(property, Attribute.MinFieldOrPropertyName);
            }

            if (!string.IsNullOrEmpty(Attribute.MaxFieldOrPropertyName))
            {
                maxV = GetMemberValue<float>(property, Attribute.MaxFieldOrPropertyName);
            }

            if (minV > maxV)
            {
                (maxV, minV) = (minV, maxV);
            }

            // GUI
            PushCustomColors();
            EditorGUI.BeginChangeCheck();
            if (Attribute.Slider)
            {
                switch (property.propertyType)
                {
                    case SerializedPropertyType.Float:
                        EditorGUI.Slider(position, property, minV, maxV, label);
                        break;
                    case SerializedPropertyType.Integer:
                        EditorGUI.IntSlider(position, property, (int)minV, (int)maxV, label);
                        break;
                }

            }
            else
                EditorGUI.PropertyField(position, property, label);

            if (EditorGUI.EndChangeCheck())
            {
                // Clamp
                switch (property.propertyType)
                {
                    case SerializedPropertyType.Float:
                        if (DT._UseSnapValuePrecision && Attribute.Precision > -1)
                            property.floatValue = DTMath.SnapPrecision(property.floatValue, Attribute.Precision);
                        if (property.floatValue < minV || property.floatValue > maxV)
                            property.floatValue = Mathf.Clamp(property.floatValue, minV, maxV);
                        break;
                    case SerializedPropertyType.Integer:
                        if (property.intValue < minV || property.intValue > maxV)
                            property.intValue = Mathf.Clamp(property.intValue, (int)minV, (int)maxV);
                        break;
                }
            }
            PopCustomColors();
            label.tooltip = "";
        }
    }

    [CustomPropertyDrawer(typeof(FluffyUnderware.DevTools.MinMaxAttribute))]
    public class MinMaxPropertyDrawer : DTPropertyDrawer<FluffyUnderware.DevTools.MinMaxAttribute>
    {
        float lBound;
        float uBound;

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            base.OnGUI(position, property, label);

            lBound = Attribute.Min;
            uBound = Attribute.Max;
            // Get maxV serialized
            string[] path = property.Path();
            path[path.Length - 1] = Attribute.MaxValueField;
            SerializedProperty pMaxV = property.serializedObject.FindProperty(string.Join(".", path));

            if (!string.IsNullOrEmpty(Attribute.MinBoundFieldOrPropertyName))
            {
                lBound = GetMemberValue<float>(property, Attribute.MinBoundFieldOrPropertyName);
            }

            if (!string.IsNullOrEmpty(Attribute.MaxBoundFieldOrPropertyName))
            {
                uBound = GetMemberValue<float>(property, Attribute.MaxBoundFieldOrPropertyName);
            }

            if (lBound > uBound)
            {
                (uBound, lBound) = (lBound, uBound);
            }

            float minV = 0;
            float maxV = 0;

            // GUI
            EditorGUI.BeginChangeCheck();


            switch (property.propertyType)
            {
                case SerializedPropertyType.Float:
                    minV = property.floatValue;
                    maxV = pMaxV.floatValue;
#if UNITY_PRE_5_5
                    EditorGUI.MinMaxSlider(label, position, ref minV, ref maxV, lBound, uBound);
#else
                    EditorGUI.MinMaxSlider(position, label, ref minV, ref maxV, lBound, uBound);
#endif
                    break;
                case SerializedPropertyType.Integer:
                    minV = property.intValue;
                    maxV = pMaxV.intValue;
#if UNITY_PRE_5_5
                    EditorGUI.MinMaxSlider(label, position, ref minV, ref maxV, lBound, uBound);
#else
                    EditorGUI.MinMaxSlider(position, label, ref minV, ref maxV, lBound, uBound);
#endif
                    break;
            }

            if (EditorGUI.EndChangeCheck())
            {
                // Clamp
                switch (property.propertyType)
                {
                    case SerializedPropertyType.Float:
                        if (DT._UseSnapValuePrecision && Attribute.Precision > -1)
                            property.floatValue = Mathf.Max(lBound, DTMath.SnapPrecision(minV, Attribute.Precision));
                        pMaxV.floatValue = Mathf.Min(uBound, DTMath.SnapPrecision(maxV, Attribute.Precision));
                        break;
                    case SerializedPropertyType.Integer:
                        property.intValue = (int)minV;
                        pMaxV.intValue = (int)maxV;
                        break;
                }

            }
            label.tooltip = "";
        }

    }

    [CustomPropertyDrawer(typeof(MinAttribute), true)]
    public class MinPropertyDrawer : DTPropertyDrawer<MinAttribute>
    {
        protected float minV;

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            base.OnGUI(position, property, label);

            // GUI
            EditorGUI.PropertyField(position, property, label);


            minV = Attribute.MinValue;

            if (!string.IsNullOrEmpty(Attribute.MinFieldOrPropertyName))
            {
                minV = GetMemberValue<float>(property, Attribute.MinFieldOrPropertyName);
            }

            // Clamp
            switch (property.propertyType)
            {
                case SerializedPropertyType.Float:
                    if (DT._UseSnapValuePrecision && Attribute.Precision > -1)
                        property.floatValue = DTMath.SnapPrecision(property.floatValue, Attribute.Precision);
                    if (property.floatValue < minV)
                        property.floatValue = minV;
                    break;
                case SerializedPropertyType.Integer:
                    if (property.intValue < minV)
                        property.intValue = (int)minV;
                    break;
            }
            label.tooltip = "";
        }

    }

    [CustomPropertyDrawer(typeof(MaxAttribute))]
    public class MaxPropertyDrawer : DTPropertyDrawer<MaxAttribute>
    {
        protected float maxV;

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            base.OnGUI(position, property, label);

            // GUI
            EditorGUI.PropertyField(position, property, label);


            maxV = Attribute.MaxValue;

            if (!string.IsNullOrEmpty(Attribute.MaxFieldOrPropertyName))
            {
                maxV = GetMemberValue<float>(property, Attribute.MaxFieldOrPropertyName);
            }

            // Clamp and snap
            switch (property.propertyType)
            {
                case SerializedPropertyType.Float:
                    if (DT._UseSnapValuePrecision && Attribute.Precision > -1)
                        property.floatValue = DTMath.SnapPrecision(property.floatValue, Attribute.Precision);
                    if (property.floatValue > maxV)
                        property.floatValue = maxV;

                    break;
                case SerializedPropertyType.Integer:
                    if (property.intValue > maxV)
                        property.intValue = (int)maxV;
                    break;
            }
            label.tooltip = "";
        }

    }

    [CustomPropertyDrawer(typeof(PathSelectorAttribute))]
    public class PathSelectorDrawer : DTPropertyDrawer<PathSelectorAttribute>
    {
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            base.OnGUI(position, property, label);
            if (property.propertyType == SerializedPropertyType.String)
            {
                position.width -= 20;
                property.stringValue = EditorGUI.TextField(position, label, property.stringValue);
                position.xMin = position.xMax;
                position.width = 20;
                if (GUI.Button(position, "..", EditorStyles.miniButton))
                {
                    string v = string.Empty;
                    switch (Attribute.Mode)
                    {
                        case PathSelectorAttribute.DialogMode.OpenFile:
                            v = EditorUtility.OpenFilePanel(Attribute.Title, Attribute.Directory, Attribute.Extension);
                            break;
                        case PathSelectorAttribute.DialogMode.OpenFolder:
                            v = EditorUtility.OpenFolderPanel(Attribute.Title, Attribute.Directory, Attribute.DefaultName);
                            break;
                        case PathSelectorAttribute.DialogMode.CreateFile:
                            v = EditorUtility.SaveFilePanel(Attribute.Title, Attribute.Directory, Attribute.DefaultName, Attribute.Extension);
                            break;
                    }
                    if (!string.IsNullOrEmpty(v))
                        property.stringValue = v;
                }
            }
            else
                DTLog.LogError("[DevTools] PropertyAttribute [FileSelector] only works on string fields!", property.serializedObject.targetObject);
        }
    }

    [CustomPropertyDrawer(typeof(EnumFlagAttribute))]
    public class EnumFlagDrawer : DTPropertyDrawer<EnumFlagAttribute>
    {
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {

            System.Enum targetEnum = GetPropertySourceField<System.Enum>(property);

            EditorGUI.BeginProperty(position, label, property);
            System.Enum enumNew = EditorGUI.EnumFlagsField(position, label, targetEnum);
            property.intValue = (int)System.Convert.ChangeType(enumNew, targetEnum.GetType(), System.Globalization.CultureInfo.InvariantCulture);
            EditorGUI.EndProperty();
        }
    }

    [CustomPropertyDrawer(typeof(EnumSelectionGridAttribute))]
    public class EnumSelectionGridDrawer : DTPropertyDrawer<EnumSelectionGridAttribute>
    {
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            if (property.propertyType == SerializedPropertyType.Enum)
            {
                string[] names = property.enumDisplayNames;

                EditorGUI.PrefixLabel(position, label);
                position = position.WithoutLabel();
                EditorGUI.BeginChangeCheck();
                int v = GUI.SelectionGrid(position, property.enumValueIndex, names, names.Length);
                if (EditorGUI.EndChangeCheck())
                    property.enumValueIndex = v;
            }
            else
                DTLog.LogError("[DevTools] PropertyAttribute [SelectionGrid] only works on Enum fields!", property.serializedObject.targetObject);
        }
    }

    [CustomPropertyDrawer(typeof(ObjectSelectorAttribute))]
    public class ObjectSelectorDrawer : DTPropertyDrawer<ObjectSelectorAttribute>
    {
    }

    [CustomPropertyDrawer(typeof(FloatRegionAttribute))]
    public class FloatRegionPropertyDrawer : DTPropertyDrawer<FloatRegionAttribute>
    {
        PropertyInfo mPI;
        object mObject;
        SerializedProperty ppFrom;
        SerializedProperty ppTo;
        SerializedProperty ppSimpleValue;
        RegionOptions<float> mOptions;

        bool compact
        {
            get
            {
                return ((EditorGUIUtility.wideMode && Options == AttributeOptionsFlags.None) ||
                        ((Options & AttributeOptionsFlags.Compact) == AttributeOptionsFlags.Compact ||
                          (Options & AttributeOptionsFlags.FullCompact) == AttributeOptionsFlags.FullCompact
                        )
                        );
            }
        }

        bool minmax
        {
            get
            {
                return (Attribute.UseSlider && !ppSimpleValue.boolValue &&
                        mOptions.ClampFrom == DTValueClamping.Range && mOptions.ClampTo == DTValueClamping.Range &&
                        mOptions.FromMin == mOptions.ToMin && mOptions.FromMax == mOptions.ToMax);
            }
        }

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            Init(property);
            float h = base.GetPropertyHeight(property, label);
            if (!compact)
            {
                if (!Attribute.RegionIsOptional || !ppSimpleValue.boolValue || minmax)
                    h = (h + EditorGUIUtility.standardVerticalSpacing) * 2;
            }

            return h;
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            base.OnGUI(position, property, label);
            Init(property);
            Rect r = new Rect(position);
            r.height = EditorGUIUtility.singleLineHeight;

            if (minmax)
            {
                doMinmax(r, label, Attribute.RegionIsOptional);
            }
            else if (compact)
            {
                doCompact(r, label, new GUIContent(mOptions.LabelTo), Attribute.RegionIsOptional);
            }
            else
            {
                doRegular(r, label);
            }

            label.tooltip = "";
        }

        void doMinmax(Rect r, GUIContent label, bool showOptional)
        {
            float l = ppFrom.floatValue;
            float u = ppTo.floatValue;

            Rect r2 = new Rect(r);

            if (showOptional)
                r2.width -= 16;

            EditorGUI.BeginChangeCheck();
#if UNITY_PRE_5_5
            EditorGUI.MinMaxSlider(label, r2, ref l, ref u, mOptions.FromMin, mOptions.FromMax);
#else
            EditorGUI.MinMaxSlider(r2, label, ref l, ref u, mOptions.FromMin, mOptions.FromMax);
#endif
            if (EditorGUI.EndChangeCheck())
            {
                ppFrom.floatValue = l;
                validateFrom();
                ppTo.floatValue = u;
                validateTo();
            }
            if (showOptional)
            {
                ppSimpleValue.boolValue = !EditorGUI.Toggle(new Rect(r.xMax - 16, r.y, 16, r.height), new GUIContent("", mOptions.OptionalTooltip), !ppSimpleValue.boolValue);
            }
            if (!compact)
            {
                r.y += r.height + EditorGUIUtility.standardVerticalSpacing;
                doCompact(r, new GUIContent(mOptions.LabelFrom), new GUIContent(mOptions.LabelTo), false);
            }
        }

        void doCompact(Rect r, GUIContent label, GUIContent labelTo, bool showOptional, bool fullLine = false)
        {
            float lw = EditorGUIUtility.labelWidth;
            float fw = EditorGUIUtility.fieldWidth;
            Rect r2 = new Rect(r);
            bool showTo = !showOptional || !ppSimpleValue.boolValue;
            float showToLabelWidth = DTGUI.LabelWidth(labelTo);

            float chkWidth = showOptional ? 16 : 0;
            if (fullLine)
            {
                EditorGUIUtility.labelWidth = DTGUI.LabelWidth(label);
                lw = EditorGUIUtility.labelWidth;
            }

            r2.width = (r.width - lw - chkWidth - showToLabelWidth) / 2;

            // From
            r.width = lw + r2.width;
            EditorGUI.BeginChangeCheck();
            EditorGUI.PropertyField(r, ppFrom, label);
            if (EditorGUI.EndChangeCheck())
                validateFrom();

            r.x += r.width;

            // "To" may be optional
            if (showOptional)
            {
                ppSimpleValue.boolValue = !EditorGUI.Toggle(new Rect(r.x, r.y, 16, r.height), new GUIContent("", mOptions.OptionalTooltip), !ppSimpleValue.boolValue);
                r.x += 16;
            }
            // Show "To"?

            if (showTo)
            {
                EditorGUI.BeginChangeCheck();
                EditorGUIUtility.labelWidth = showToLabelWidth;
                r.width = r2.width + showToLabelWidth;
                ppTo.floatValue = EditorGUI.FloatField(r, labelTo, ppTo.floatValue);
                if (EditorGUI.EndChangeCheck())
                    validateTo();

            }

            EditorGUIUtility.labelWidth = lw;
            EditorGUIUtility.fieldWidth = fw;
        }

        void doRegular(Rect r, GUIContent label)
        {
            // From
            Rect rF = new Rect(r);
            if (Attribute.RegionIsOptional)
                rF.width -= 16;
            EditorGUI.BeginProperty(rF, label, ppFrom);
            EditorGUI.BeginChangeCheck();
            if (Attribute.UseSlider && mOptions.ClampFrom == DTValueClamping.Range)
                ppFrom.floatValue = EditorGUI.Slider(rF, label, ppFrom.floatValue, mOptions.FromMin, mOptions.FromMax);
            else
                ppFrom.floatValue = EditorGUI.FloatField(rF, label, ppFrom.floatValue);
            if (EditorGUI.EndChangeCheck())
                validateFrom();
            EditorGUI.EndProperty();
            // Perhaps To is optional
            if (Attribute.RegionIsOptional)
                ppSimpleValue.boolValue = !EditorGUI.Toggle(new Rect(rF.x + rF.width + 1, rF.y, 16, rF.height), new GUIContent("", mOptions.OptionalTooltip), !ppSimpleValue.boolValue);

            // To
            if (!Attribute.RegionIsOptional || !ppSimpleValue.boolValue)
            {
                r.y += r.height + EditorGUIUtility.standardVerticalSpacing;
                label.text = mOptions.LabelTo;
                EditorGUI.BeginProperty(r, label, ppTo);
                EditorGUI.BeginChangeCheck();
                if (Attribute.UseSlider && mOptions.ClampTo == DTValueClamping.Range)
                    ppTo.floatValue = EditorGUI.Slider(r, label, ppTo.floatValue, mOptions.ToMin, mOptions.ToMax);
                else
                    ppTo.floatValue = EditorGUI.FloatField(r, label, ppTo.floatValue);
                if (EditorGUI.EndChangeCheck())
                    validateTo();
                EditorGUI.EndProperty();
            }
        }

        void validateFrom()
        {
            ppFrom.floatValue = DTMath.SnapPrecision(ppFrom.floatValue, Attribute.Precision);
            switch (mOptions.ClampFrom)
            {
                case DTValueClamping.Min:
                    ppFrom.floatValue = Mathf.Max(mOptions.FromMin, ppFrom.floatValue);
                    break;
                case DTValueClamping.Max:
                    ppFrom.floatValue = Mathf.Min(mOptions.FromMax, ppFrom.floatValue);
                    break;
                case DTValueClamping.Range:
                    ppFrom.floatValue = Mathf.Clamp(ppFrom.floatValue, mOptions.FromMin, mOptions.FromMax);
                    if (minmax)
                        ppFrom.floatValue = Mathf.Min(ppFrom.floatValue, ppTo.floatValue);
                    break;
            }
        }

        void validateTo()
        {
            ppTo.floatValue = DTMath.SnapPrecision(ppTo.floatValue, Attribute.Precision);
            switch (mOptions.ClampTo)
            {
                case DTValueClamping.Min:
                    ppTo.floatValue = Mathf.Max(mOptions.ToMin, ppTo.floatValue);
                    break;
                case DTValueClamping.Max:
                    ppTo.floatValue = Mathf.Min(mOptions.ToMax, ppTo.floatValue);
                    break;
                case DTValueClamping.Range:
                    ppTo.floatValue = Mathf.Clamp(ppTo.floatValue, mOptions.ToMin, mOptions.ToMax);
                    if (minmax)
                        ppTo.floatValue = Mathf.Max(ppTo.floatValue, ppFrom.floatValue);
                    break;
            }
        }

        void Init(SerializedProperty property)
        {
            try
            {
                mObject = property.GetParentObject();
                if (mPI == null && !string.IsNullOrEmpty(Attribute.RegionOptionsPropertyName))
                    mPI = mObject.GetType().PropertyByName(Attribute.RegionOptionsPropertyName, true, true);

                if (mPI != null)
                    mOptions = (RegionOptions<float>)mPI.GetValue(mObject, null);
                else
                    mOptions = RegionOptions<float>.Default;
            }
            catch (System.Exception e)
            {
                DTLog.LogError("[DevTools] FloatRegionPropertyDrawer: Unable to find property '" + Attribute.RegionOptionsPropertyName + "'! (" + e.ToString() + ")", property.serializedObject.targetObject);
            }
            ppFrom = property.FindPropertyRelative("From");
            ppTo = property.FindPropertyRelative("To");
            ppSimpleValue = property.FindPropertyRelative("SimpleValue");
            if (minmax)
                ppSimpleValue.boolValue = false;

        }
    }

    [CustomPropertyDrawer(typeof(IntRegionAttribute))]
    public class IntRegionPropertyDrawer : DTPropertyDrawer<IntRegionAttribute>
    {
        PropertyInfo mPI;
        object mObject;
        SerializedProperty ppFrom;
        SerializedProperty ppTo;
        SerializedProperty ppSimpleValue;
        RegionOptions<int> mOptions;

        bool compact
        {
            get
            {
                return (EditorGUIUtility.wideMode ||
                        ((Options & AttributeOptionsFlags.Compact) == AttributeOptionsFlags.Compact ||
                          (Options & AttributeOptionsFlags.FullCompact) == AttributeOptionsFlags.FullCompact
                        )
                        );
            }
        }

        bool minmax
        {
            get
            {
                return (Attribute.UseSlider && !Attribute.RegionIsOptional &&
                        mOptions.ClampFrom == DTValueClamping.Range && mOptions.ClampTo == DTValueClamping.Range &&
                        mOptions.FromMin == mOptions.ToMin && mOptions.FromMax == mOptions.ToMax);
            }
        }

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            Init(property);
            float h = base.GetPropertyHeight(property, label);
            if (!compact)
            {
                if (!Attribute.RegionIsOptional || !ppSimpleValue.boolValue || minmax)
                    h = (h + EditorGUIUtility.standardVerticalSpacing) * 2;
            }

            return h;
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            base.OnGUI(position, property, label);
            Init(property);
            Rect r = new Rect(position);
            r.height = EditorGUIUtility.singleLineHeight;

            if (minmax)
            {
                doMinmax(r, label, Attribute.RegionIsOptional);
            }
            else if (compact)
            {
                doCompact(r, label, new GUIContent(mOptions.LabelTo), Attribute.RegionIsOptional);
            }
            else
            {
                doRegular(r, label);
            }

            label.tooltip = "";
        }

        void doMinmax(Rect r, GUIContent label, bool showOptional)
        {
            float l = ppFrom.intValue;
            float u = ppTo.intValue;

            Rect r2 = new Rect(r);

            if (showOptional)
                r2.width -= 16;

            EditorGUI.BeginChangeCheck();
#if UNITY_PRE_5_5
            EditorGUI.MinMaxSlider(label, r2, ref l, ref u, mOptions.FromMin, mOptions.FromMax);
#else
            EditorGUI.MinMaxSlider(r2, label, ref l, ref u, mOptions.FromMin, mOptions.FromMax);
#endif
            if (EditorGUI.EndChangeCheck())
            {
                ppFrom.intValue = (int)l;
                validateFrom();
                ppTo.intValue = (int)u;
                validateTo();
            }
            if (showOptional)
            {
                ppSimpleValue.boolValue = !EditorGUI.Toggle(new Rect(r.xMax - 16, r.y, 16, r.height), new GUIContent("", mOptions.OptionalTooltip), !ppSimpleValue.boolValue);
            }
            if (!compact)
            {
                r.y += r.height + EditorGUIUtility.standardVerticalSpacing;
                doCompact(r, new GUIContent(mOptions.LabelFrom), new GUIContent(mOptions.LabelTo), false);
            }
        }

        void doCompact(Rect r, GUIContent label, GUIContent labelTo, bool showOptional, bool fullLine = false)
        {
            float lw = EditorGUIUtility.labelWidth;
            float fw = EditorGUIUtility.fieldWidth;
            Rect r2 = new Rect(r);
            bool showTo = !showOptional || !ppSimpleValue.boolValue;
            float showToLabelWidth = DTGUI.LabelWidth(labelTo);

            float chkWidth = showOptional ? 16 : 0;
            if (fullLine)
            {
                EditorGUIUtility.labelWidth = DTGUI.LabelWidth(label);
                lw = EditorGUIUtility.labelWidth;
            }

            r2.width = (r.width - lw - chkWidth - showToLabelWidth) / 2;

            // From
            r.width = lw + r2.width;
            EditorGUI.BeginChangeCheck();
            EditorGUI.PropertyField(r, ppFrom, label);
            if (EditorGUI.EndChangeCheck())
                validateFrom();

            r.x += r.width;

            // "To" may be optional
            if (showOptional)
            {
                ppSimpleValue.boolValue = !EditorGUI.Toggle(new Rect(r.x, r.y, 16, r.height), new GUIContent("", mOptions.OptionalTooltip), !ppSimpleValue.boolValue);
                r.x += 16;
            }
            // Show "To"?

            if (showTo)
            {
                EditorGUI.BeginChangeCheck();
                EditorGUIUtility.labelWidth = showToLabelWidth;
                r.width = r2.width + showToLabelWidth;
                ppTo.intValue = EditorGUI.IntField(r, labelTo, ppTo.intValue);
                if (EditorGUI.EndChangeCheck())
                    validateTo();

            }

            EditorGUIUtility.labelWidth = lw;
            EditorGUIUtility.fieldWidth = fw;
        }

        void doRegular(Rect r, GUIContent label)
        {
            // From
            Rect rF = new Rect(r);
            if (Attribute.RegionIsOptional)
                rF.width -= 16;
            EditorGUI.BeginProperty(rF, label, ppFrom);
            EditorGUI.BeginChangeCheck();
            if (Attribute.UseSlider && mOptions.ClampFrom == DTValueClamping.Range)
                ppFrom.intValue = EditorGUI.IntSlider(rF, label, ppFrom.intValue, mOptions.FromMin, mOptions.FromMax);
            else
                ppFrom.intValue = EditorGUI.IntField(rF, label, ppFrom.intValue);
            if (EditorGUI.EndChangeCheck())
                validateFrom();
            EditorGUI.EndProperty();
            // Perhaps To is optional
            if (Attribute.RegionIsOptional)
                ppSimpleValue.boolValue = !EditorGUI.Toggle(new Rect(rF.x + rF.width, rF.y, 16, rF.height), new GUIContent("", mOptions.OptionalTooltip), !ppSimpleValue.boolValue);

            // To
            if (!Attribute.RegionIsOptional || !ppSimpleValue.boolValue)
            {
                r.y += r.height + EditorGUIUtility.standardVerticalSpacing;
                label.text = mOptions.LabelTo;
                EditorGUI.BeginProperty(r, label, ppTo);
                EditorGUI.BeginChangeCheck();
                if (Attribute.UseSlider && mOptions.ClampTo == DTValueClamping.Range)
                    ppTo.intValue = EditorGUI.IntSlider(r, label, ppTo.intValue, mOptions.ToMin, mOptions.ToMax);
                else
                    ppTo.intValue = EditorGUI.IntField(r, label, ppTo.intValue);
                if (EditorGUI.EndChangeCheck())
                    validateTo();
                EditorGUI.EndProperty();
            }
        }

        void validateFrom()
        {
            switch (mOptions.ClampFrom)
            {
                case DTValueClamping.Min:
                    ppFrom.intValue = Mathf.Max(mOptions.FromMin, ppFrom.intValue);
                    break;
                case DTValueClamping.Max:
                    ppFrom.intValue = Mathf.Min(mOptions.FromMax, ppFrom.intValue);
                    break;
                case DTValueClamping.Range:
                    ppFrom.intValue = Mathf.Clamp(ppFrom.intValue, mOptions.FromMin, mOptions.FromMax);
                    if (minmax)
                        ppFrom.intValue = Mathf.Min(ppFrom.intValue, ppTo.intValue);
                    break;
            }
        }

        void validateTo()
        {
            switch (mOptions.ClampTo)
            {
                case DTValueClamping.Min:
                    ppTo.intValue = Mathf.Max(mOptions.ToMin, ppTo.intValue);
                    break;
                case DTValueClamping.Max:
                    ppTo.intValue = Mathf.Min(mOptions.ToMax, ppTo.intValue);
                    break;
                case DTValueClamping.Range:
                    ppTo.intValue = Mathf.Clamp(ppTo.intValue, mOptions.ToMin, mOptions.ToMax);
                    if (minmax)
                        ppTo.intValue = Mathf.Max(ppTo.intValue, ppFrom.intValue);
                    break;
            }
        }

        void Init(SerializedProperty property)
        {
            try
            {
                mObject = property.GetParentObject();
                if (mPI == null && !string.IsNullOrEmpty(Attribute.RegionOptionsPropertyName))
                    mPI = mObject.GetType().PropertyByName(Attribute.RegionOptionsPropertyName, true, true);

                if (mPI != null)
                    mOptions = (RegionOptions<int>)mPI.GetValue(mObject, null);
                else
                    mOptions = RegionOptions<int>.Default;
            }
            catch (System.Exception e)
            {
                DTLog.LogError("[DevTools] IntRegionPropertyDrawer: Unable to find property '" + Attribute.RegionOptionsPropertyName + "'! (" + e.ToString() + ")", property.serializedObject.targetObject);
            }
            ppFrom = property.FindPropertyRelative("From");
            ppTo = property.FindPropertyRelative("To");
            ppSimpleValue = property.FindPropertyRelative("SimpleValue");

        }
    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/PropertyDrawers.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/ToolbarItemTypes/DTToolbarButton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 23190dcdedb51a74c914b829d6473b8c
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using UnityEditor;

namespace FluffyUnderware.DevToolsEditor
{

    public class DTToolbarButton : DTToolbarItem
    {

        public override void Render(Rect r)
        {
            if (GUI.Button(r, Content,DTStyles.TBButton))
                OnClick();
        }
    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/ToolbarItemTypes/DTToolbarButton.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/ToolbarItemTypes/DTToolbarRadioButton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d892a9daccfb1d04ba11b0f7ecb26c70
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using UnityEditor;

namespace FluffyUnderware.DevToolsEditor
{

    public class DTToolbarRadioButton : DTToolbarToggleButton
    {
        public string RadioGroup = string.Empty;

        protected bool AllOffAllowed {get; set;}

        public override bool On
        {
            get
            {
                return base.On;
            }
            set
            {
                if (mOn!=value)
                {
                    if (value == true)
                        DTToolbar.SetRadioGroupState(this);
                    else if (AllOffAllowed)
                    {
                        mOn = false;
                        OnClick();
                    }
                }
                
            }
        }

        public override bool ShowClientArea
        {
            get
            {
                return On;
            }

        }

        public DTToolbarRadioButton(string radioGroupName, bool defaultOn=false)
        {
            RadioGroup = radioGroupName;
            AllOffAllowed = false;
            mOn = defaultOn;
        }

        
    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/ToolbarItemTypes/DTToolbarRadioButton.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/ToolbarItemTypes/DTToolbarRadioOffButton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 41cca5920ca067a40b4b73d4db3f20e5
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using UnityEditor;

namespace FluffyUnderware.DevToolsEditor
{

    public class DTToolbarRadioOffButton : DTToolbarRadioButton
    {

        public override bool On
        {
            get
            {
                return base.On;
            }
            set
            {
                if (mOn != value)
                {
                    if (value == true)
                        DTToolbar.SetRadioGroupState(this);
                    else if (AllOffAllowed)
                    {
                        mOn = false;
                        OnClick();
                    }
                }

            }
        }

        public override bool ShowClientArea
        {
            get
            {
                return On;
            }

        }

        public DTToolbarRadioOffButton(string radioGroupName, bool defaultOn=false)
            : base(radioGroupName,defaultOn)
        {
            AllOffAllowed = true;
        }


    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/ToolbarItemTypes/DTToolbarRadioOffButton.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/ToolbarItemTypes/DTToolbarToggleButton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 53c6546eb43ea874e92c8a7b1a7ef015
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using UnityEditor;

namespace FluffyUnderware.DevToolsEditor
{

    public class DTToolbarToggleButton : DTToolbarItem
    {

        public virtual bool On
        {
            get { return mOn; }
            set
            {
                if (mOn != value)
                {
                    mOn = value;
                    if (!mOn && FocusedItem == this)
                        FocusedItem = null;
                }
            }
        }

        internal bool mOn;

        public override bool ShowClientArea
        {
            get
            {
                return On;
            }
            
        }

        public override void OnOtherItemClicked(DTToolbarItem other)
        {
            base.OnOtherItemClicked(other);
            On = false;
        }

        public override void OnClick()
        {
            base.OnClick();
            On = !On;
        }

        public override void Render(Rect r)
        {
            bool b = GUI.Toggle(r, On, Content, DTStyles.TBButton);
            if (b!=On)
                OnClick();
        }

        
    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/DevTools/Editor/ToolbarItemTypes/DTToolbarToggleButton.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/UiRoundedCorners/ImageWithIndependentRoundedCornersInspector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 2364a6676566e7842a1a053d02d5ec5b
# ASMDEF: Nobi.UiRoundedCorners.Editor.dll
# ---
using UnityEditor;
using UnityEngine.UI;

namespace Nobi.UiRoundedCorners.Editor {
    [CustomEditor(typeof(ImageWithIndependentRoundedCorners))]
    public class ImageWithIndependentRoundedCornersInspector : UnityEditor.Editor {
        private ImageWithIndependentRoundedCorners script;

        private void OnEnable() {
            script = (ImageWithIndependentRoundedCorners)target;
        }

        public override void OnInspectorGUI() {
            base.OnInspectorGUI();

            if (!script.TryGetComponent<MaskableGraphic>(out var _)) {
                EditorGUILayout.HelpBox("This script requires an MaskableGraphic (Image or RawImage) component on the same gameobject", MessageType.Warning);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/UiRoundedCorners/ImageWithIndependentRoundedCornersInspector.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/UiRoundedCorners/ImageWithRoundedCornersInspector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 2b7cf3ef8317dd04eaff6d4b44a16520
# ASMDEF: Nobi.UiRoundedCorners.Editor.dll
# ---
using UnityEditor;
using UnityEngine.UI;

namespace Nobi.UiRoundedCorners.Editor {
    [CustomEditor(typeof(ImageWithRoundedCorners))]
    public class ImageWithRoundedCornersInspector : UnityEditor.Editor {
        private ImageWithRoundedCorners script;

        private void OnEnable() {
            script = (ImageWithRoundedCorners)target;
        }

        public override void OnInspectorGUI() {
            base.OnInspectorGUI();

            if (!script.TryGetComponent<MaskableGraphic>(out var _)) {
                EditorGUILayout.HelpBox("This script requires an MaskableGraphic (Image or RawImage) component on the same gameobject", MessageType.Warning);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/UiRoundedCorners/ImageWithRoundedCornersInspector.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/AllIn13DEffectConfig.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 9e56d697165908f4a802d77da51b7913
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using UnityEngine.Rendering;
using static AllIn13DShader.EffectsExtraData;

namespace AllIn13DShader
{
	[System.Serializable]
	public class AllIn13DEffectConfig
	{
		public string effectName;
		public string displayName;
		public string group;
		
		public int keywordPropertyIndex;
		public string keywordPropertyName;

		public string effectDrawerID;
		public string dependentOnEffect;
		public string incompatibleWithEffectID;
		public string docURL;
		public MessageByKeywords[] customMessages;

		//public List<string> keywords;
		public List<EffectKeywordData> keywords;
		public string[] keywordsDisplayNames;
		public List<EffectProperty> effectProperties;

		public string disabledKeyword;

		public EffectConfigType effectConfigType;

		public AllIn13DEffectConfig(
			string displayName, string propertyName, int propertyIndex, EffectConfigType effectConfigType,
			EffectAttributeData data, EffectsExtraData effectsExtraData)
		{
			this.displayName = displayName;
			this.keywordPropertyName = propertyName;
			this.keywordPropertyIndex = propertyIndex;
			this.effectConfigType = effectConfigType;

			this.effectName = data.effectID;
			this.group = data.groupID;
			this.effectDrawerID = data.drawerID;
			this.dependentOnEffect = data.dependentEffectID;
			this.incompatibleWithEffectID = data.incompatibleWithEffectID;

			EffectsExtraData.ExtraData extraData = effectsExtraData.GetExtraDataByEffectID(effectName);
			if(extraData != null)
			{
				this.docURL = extraData.docURL;
				this.customMessages = extraData.customMessages;
			}

			this.keywords = new List<EffectKeywordData>();
			this.effectProperties = new List<EffectProperty>();
			this.keywordsDisplayNames = new string[0];
		}

		public void AddKeyword(EffectKeywordData kw)
		{
			keywords.Add(kw);
		}

		public void AddKeywords(EffectKeywordData[] kws)
		{
			keywords.AddRange(kws);
		}

		public void Setup()
		{
			for(int i = 0; i < keywords.Count; i++)
			{
				ArrayUtility.Add(ref keywordsDisplayNames, keywords[i].displayName);
			}
		}

		public EffectProperty FindEffectPropertyByIndex(int propertyIndex)
		{
			EffectProperty res = null;

			for (int i = 0; i < effectProperties.Count; i++)
			{
				if (effectProperties[i].propertyIndex == propertyIndex)
				{
					res = effectProperties[i];
					break;
				}
			}

			return res;
		}

		public EffectProperty FindEffectPropertyByName(string propertyName)
		{
			EffectProperty res = null;

			for(int i = 0; i < effectProperties.Count; i++)
			{
				if (effectProperties[i].propertyName == propertyName)
				{
					res = effectProperties[i];
					break;
				}
			}

			return res;
		}

		public EffectProperty CreateEffectProperty(int propertyIndex, string propertyName, string displayName, EffectPropertyAttributeData data)
		{
			EffectProperty res = new EffectProperty(this, propertyIndex, propertyName, displayName, data.keywordsOp, data.allowReset);
			effectProperties.Add(res);

			for (int i = 0; i < data.keywords.Count; i++)
			{
				res.AddKeyword(data.keywords[i]);
			}

			for(int i = 0; i < data.incompatibleWithKws.Count; i++)
			{
				res.AddIncompatibleKeyword(data.incompatibleWithKws[i]);
			}

			res.AddPropertyKeywords(data.propertyKeywords);

			return res;
		}

		public string GetCustomMessage(Material targetMat)
		{
			string res = string.Empty;

			if(customMessages != null && customMessages.Length > 0)
			{	
				for(int i = 0; i < customMessages.Length; i++)
				{
					MessageByKeywords customMessage = customMessages[i];

					if (customMessage.IsMessageEnabled(targetMat))
					{
						res = customMessage.message;
						break;
					}
				}
			}

			return res;
		}

		public static bool IsEffectEnabled(AllIn13DEffectConfig effectConfig, AllIn13DShaderInspectorReferences references)
		{
			int selectedIndex = 0;
			return IsEffectEnabled(effectConfig, ref selectedIndex, references);
		}

		public static bool IsEffectEnabled(AllIn13DEffectConfig effectConfig, ref int selectedIndex, AllIn13DShaderInspectorReferences references)
		{
			selectedIndex = 0;

			LocalKeyword[] enabledKeywords = references.targetMat.enabledKeywords;
			bool res = false;

			if (effectConfig.keywords.Count == 1)
			{
				for (int i = 0; i < enabledKeywords.Length; i++)
				{
					if (enabledKeywords[i].name == effectConfig.keywords[0].keyword)
					{
						res = true;
						selectedIndex = i;
						break;
					}
				}
			}
			else
			{
				for (int i = 0; i < effectConfig.keywords.Count; i++)
				{
					string keywordToCheck = effectConfig.keywords[i].keyword;
					for (int j = 0; j < enabledKeywords.Length; j++)
					{
						if (enabledKeywords[j].name == keywordToCheck && i > 0)
						{
							res = true;
							break;
						}
					}

					if (res)
					{
						selectedIndex = i;
						break;
					}
				}
			}

			return res;
		}


		public static void ResetProperty(MaterialProperty targetProperty, AllIn13DShaderInspectorReferences references)
		{
			if (references.originalMaterialCopy == null) references.originalMaterialCopy = new Material(references.targetMat.shader);
			if (targetProperty.propertyType == ShaderPropertyType.Float || targetProperty.propertyType == ShaderPropertyType.Range)
			{
				targetProperty.floatValue = references.originalMaterialCopy.GetFloat(targetProperty.name);
			}
			else if (targetProperty.propertyType == ShaderPropertyType.Vector)
			{
				targetProperty.vectorValue = references.originalMaterialCopy.GetVector(targetProperty.name);
			}
			else if (targetProperty.propertyType == ShaderPropertyType.Color)
			{
				targetProperty.colorValue = references.originalMaterialCopy.GetColor(targetProperty.name);
			}
			else if (targetProperty.propertyType == ShaderPropertyType.Texture)
			{
				targetProperty.textureValue = references.originalMaterialCopy.GetTexture(targetProperty.name);
			}
		}

		public static void EnableEffect(AllIn13DEffectConfig effectConfig, AllIn13DShaderInspectorReferences references)
		{
			for (int i = 0; i < effectConfig.keywords.Count; i++)
			{
				string kw = effectConfig.keywords[i].keyword;
				references.targetMat.EnableKeyword(kw);
			}
		}

		public static void EnableEffectToggle(AllIn13DEffectConfig effectConfig, AllIn13DShaderInspectorReferences references)
		{
			references.targetMat.EnableKeyword(effectConfig.keywords[0].keyword);
			references.matProperties[effectConfig.keywordPropertyIndex].floatValue = 1f;
		}

		public static void DisableEffectToggle(AllIn13DEffectConfig effectConfig, AllIn13DShaderInspectorReferences references)
		{
			references.targetMat.DisableKeyword(effectConfig.keywords[0].keyword);
			references.matProperties[effectConfig.keywordPropertyIndex].floatValue = 0f;
		}

		public static void EnableEffectByIndex(AllIn13DEffectConfig effectConfig, int index, AllIn13DShaderInspectorReferences references)
		{
			DisableEffect(effectConfig, references);
			string kwToEnable = effectConfig.keywords[index].keyword;

			references.targetMat.EnableKeyword(kwToEnable);
		}

		public static void DisableEffect(AllIn13DEffectConfig effectConfig, AllIn13DShaderInspectorReferences references)
		{
			for (int i = 0; i < effectConfig.keywords.Count; i++)
			{
				string kw = effectConfig.keywords[i].keyword;

				references.targetMat.DisableKeyword(kw);
			}
		}

		public string[] GetPropertyNames()
		{
			string[] res = new string[effectProperties.Count];

			for(int i = 0; i < effectProperties.Count; i++)
			{
				res[i] = $"{effectProperties[i].displayName} ({effectProperties[i].propertyName})";
 			}

			return res;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/AllIn13DEffectConfig.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/AllIn13DShaderConfig.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7ac8fcdac0e79974c8d61e1de5dc57ed
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public static class AllIn13DShaderConfig
	{
		//Default Material Name
		public const string MATERIAL_NAME_DEFAULT = "AllIn13DMaterial.mat";

		public static Texture GetInspectorImage()
		{
			Texture res = null;

			res = EditorUtils.FindAsset<Texture>("AllIn13dShaderCustomEditorHeader");

			return res;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/AllIn13DShaderConfig.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/AllIn13DShaderInspectorReferences.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 42ff15ffadcc8ae42982fa48192469ea
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class AllIn13DShaderInspectorReferences
	{
		public MaterialProperty[] matProperties;
		public string[] oldKeyWords;

		public Material targetMat;
		public Material originalMaterialCopy;

		public MaterialEditor editorMat;

		//Styles
		private const int bigFontSize = 16, smallFontSize = 11;
		public GUIStyle propertiesStyle, bigLabelStyle, smallLabelStyle, toggleButtonStyle, tabButtonStyle;

		//Outline Effect
		public AllIn13DEffectConfig outlineEffectConfig;

		//Cast Shadows Effect
		public AllIn13DEffectConfig castShadowsEffectConfig;

		//Shaders
		public Shader shStandard;
		public Shader shStandardNoShadowCaster;
		public Shader shOutline;
		public Shader shOutlineNoShadowCaster;

		public AllIn13DShaderInspectorReferences()
		{
			propertiesStyle = new GUIStyle(EditorStyles.helpBox);
			propertiesStyle.margin = new RectOffset(0, 0, 0, 0);

			bigLabelStyle = new GUIStyle(EditorStyles.boldLabel);
			bigLabelStyle.fontSize = bigFontSize;

			smallLabelStyle = new GUIStyle(EditorStyles.boldLabel);
			smallLabelStyle.fontSize = smallFontSize;

			toggleButtonStyle = new GUIStyle(GUI.skin.button) { alignment = TextAnchor.MiddleCenter, richText = true };

			tabButtonStyle = new GUIStyle(GUI.skin.button) { fontSize = 10 };

			shStandard = Shader.Find("AllIn13DShader/AllIn13DShader");
			shOutline = Shader.Find("AllIn13DShader/AllIn13DShaderOutline");

			shStandardNoShadowCaster = Shader.Find("AllIn13DShader/AllIn13DShader_NoShadowCaster");
			shOutlineNoShadowCaster = Shader.Find("AllIn13DShader/AllIn13DShaderOutline_NoShadowCaster");
		}

		public void Setup(MaterialEditor materialEditor, MaterialProperty[] properties)
		{
			this.editorMat = materialEditor;
			this.targetMat = (Material)materialEditor.target;
			this.matProperties = properties;

			if(this.originalMaterialCopy == null)
			{
				this.originalMaterialCopy = new Material(targetMat.shader);
			}
		}

		public void SetOutlineEffect(PropertiesConfig propertiesConfig)
		{
			this.outlineEffectConfig = propertiesConfig.FindEffectConfigByID("OUTLINETYPE");
		}

		public void SetCastShadowsEffect(PropertiesConfig propertiesConfig)
		{
			this.castShadowsEffectConfig = propertiesConfig.FindEffectConfigByID("CAST_SHADOWS_ON");
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/AllIn13DShaderInspectorReferences.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Constants.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 233adf119f33cfb40b410b4336a90123
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.IO;

namespace AllIn13DShader
{
	public static class Constants
	{
		public const string EFFECT_ATTRIBUTE_PREFIX = "Effect(";
		public const string EFFECT_PROPERTY_ATTRIBUTE_PREFIX = "EffectProperty(";
		public const string HEADER_PREFIX = "Header(";
		public const string SINGLE_PROPERTY_ATTRIBUTE = "SingleProperty";
		public const string ADVANCED_PROPERTY_ATTRIBUTE = "AdvancedProperty";


		public const string SHADER_ROOT = "AllIn13DShader";

		public static string[] SHADERS_NAMES = new string[]
		{
			"AllIn13DShader",
			"AllIn13DShader_NoShadowCaster",
			"AllIn13DShaderOutline_NoShadowCaster",
			"AllIn13DShaderOutline",
		};

		public static string MAIN_SHADER_NAME
		{
			get
			{
				return SHADERS_NAMES[0];
			}
		}

		public static string SHADER_FULL_NAME_ALLIN13D
		{
			get
			{
				return SHADER_ROOT + "/" + MAIN_SHADER_NAME;
			}
		}

		public static string SHADER_FULL_NAME_ALLIN13D_OUTLINE
		{
			get
			{
				return SHADER_ROOT + "/" + SHADERS_NAMES[1];
			}
		}

		//Version
		public static string VERSION = "1.0";

		//Paths
		public static string SHADERS_FOLDER_PATH = Path.Combine(GlobalConfiguration.instance.RootPluginPath, "Shaders");/*"Assets/AllIn13DShader/Shaders";*/
		public static string SHADERS_PROPERTIES_FOLDER_PATH = /*"Assets/AllIn13DShader/Editor"*/Path.Combine(GlobalConfiguration.instance.RootPluginPath, "Editor");
		public static string TEMPLATES_FOLDER = Path.Combine(SHADERS_PROPERTIES_FOLDER_PATH, "Templates");

		//
		public const string KEYWORD_NONE = "NONE";

		//Special Properties
		public const string MATPROPERTY_RENDERING_MODE = "_RenderPreset";
		public const string MATPROPERTY_BLEND_SRC = "_BlendSrc";
		public const string MATPROPERTY_BLEND_DST = "_BlendDst";

		//Drawers IDs
		public const string GENERAL_EFFECT_DRAWER_ID = "GENERAL_EFFECT_DRAWER";
		public const string TRIPLANAR_EFFECT_DRAWER_ID = "TRIPLANAR_EFFECT_DRAWER";
		public const string COLOR_RAMP_EFFECT_DRAWER_ID = "COLOR_RAMP_EFFECT_DRAWER";
		public const string OUTLINE_DRAWER_ID = "OUTLINE_DRAWER_ID";
		public const string TEXTURE_BLENDING_EFFECT_DRAWER_ID = "TEXTURE_BLENDING_EFFECT_DRAWER";

		//Regex
		public const string REGEX_EFFECT = @"\(EffectID#([\w\s]+),.*GroupID#([\w\s]+)(?:,.*AllowReset#([\w\s]+))?(?:,.*DependentOn#([\w\s]+))?(?:,.*IncompatibleWith#([\w\s]+))?(?:,.*Doc#([\w\s\\\.]+))?(?:,.*CustomDrawer#([\w\s]+))?\)";
		public const string REGEX_EFFECT_PROPERTY = @"EffectProperty\((.*)\)";
		//public const string REGEX_EFFECT_PROOPERTY_COMPLETE = @"EffectProperty\(ParentEffect# ([\w\s]+), Keywords\((.*)\)\)";
		public const string REGEX_EFFECT_PROOPERTY_COMPLETE = @"EffectProperty\(ParentEffect# ([\w\s]+)(?:,.*KeywordsOp# ([\w]+))?(?:,.*IncompatibleWithKws\(([\w]+)\))?, Keywords\((.*)\), AllowReset# ([\w]+)\)";
		public const string REGEX_PARENT_EFFECT_KEYWORDS = @".*\((.*)\)";
		public const string REGEX_KEYWORDS_ENUM = @"KeywordEnum\((.*)\)";

		//Editor Prefs Keys
		public const string LAST_TIME_SHADER_PROPERTIES_REBUILT_KEY = "AllIn13DShader_RebuiltTime";
		public const string LAST_RENDER_PIPELINE_CHECKED_KEY = "AllIn13DShader_LastRenderPipeline";
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Constants.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/CustomEditors/AllIn13DShaderComponentCustomEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 445b6f2ff4b09ff4993b2516859d0467
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System;
using System.Collections.Generic;
using System.IO;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;

namespace AllIn13DShader
{
	[CustomEditor(typeof(AllIn13DShaderComponent))]
	[CanEditMultipleObjects]
	public class AllIn13DShaderComponentCustomEditor : Editor
	{
		private PropertiesConfigCollection propertiesConfigCollection;
		private GlobalConfiguration globalConfiguration;
		private Texture imageInspector;

		private void RefreshReferences()
		{
			propertiesConfigCollection = EditorUtils.FindAsset<ScriptableObject>("PropertiesConfigCollection") as PropertiesConfigCollection;
			if(propertiesConfigCollection == null)
			{
				propertiesConfigCollection = PropertiesConfigCreator.CreateConfig();
			}

			globalConfiguration = EditorUtils.FindAssetByName<GlobalConfiguration>("GlobalConfiguration");
		}

		private void OnEnable()
		{
			if (!Application.isPlaying)
			{
				RefreshReferences();

				bool isValidComponents = CheckSelectedComponents();
				if (!isValidComponents)
				{
					EditorUtility.DisplayDialog("Missing Renderer", "Some of the selected game objects have no Renderer component. AllIn13DShaderComponent will be removed", "Ok");
					return;
				}

				CheckMaterialReference();
			}
		}

		public override void OnInspectorGUI()
		{
			bool saveAssets = false;

			serializedObject.Update();

			DrawHeaderImage();

			EditorGUI.BeginDisabledGroup(Application.isPlaying);
			if(GUILayout.Button("Deactivate All Effects"))
			{
				ExecuteActionAfterCheck(DeactivateAllEffects);
				saveAssets = true;
			}

			if (GUILayout.Button("New Clean Material"))
			{
				ExecuteActionAfterCheck(NewCleanMaterial);
			}

			if(GUILayout.Button("Create New Material With Same Properties (SEE DOC)"))
			{
				ExecuteActionAfterCheck(MakeCopyMaterial);
			}

			if(GUILayout.Button("Save Material To Folder (SEE DOC)"))
			{
				ExecuteActionAfterCheck(SaveMaterialToFolder);
			}

			if(GUILayout.Button("Apply Material To All Children"))
			{
				ExecuteActionAfterCheck(ApplyMaterialToAllChildren);
			}

			if (GUILayout.Button("Render Material To Image"))
			{
				ExecuteActionAfterCheck(RenderMaterialToImage);
			}
			EditorGUI.EndDisabledGroup();

			serializedObject.ApplyModifiedProperties();


			if (saveAssets)
			{
				AssetDatabase.SaveAssets();
				EditorSceneManager.SaveOpenScenes();
				AssetDatabase.Refresh();
			}

			EditorGUILayout.Space();
			EditorUtils.DrawThinLine();

			if (GUILayout.Button("Remove Component"))
			{
				RemoveComponent();
			}

			if(GUILayout.Button("Remove Component and Material"))
			{
				RemoveComponentAndMaterial();
			}
		}

		private void DrawHeaderImage()
		{
			if(imageInspector == null) imageInspector = AllIn13DShaderConfig.GetInspectorImage();
			Rect rect = EditorGUILayout.GetControlRect(GUILayout.Height(32));
			GUI.DrawTexture(rect, imageInspector, ScaleMode.ScaleToFit, true);
		}

		private void CheckMaterialReference()
		{
			for (int i = 0; i < targets.Length; i++)
			{
				AllIn13DShaderComponent allIn13DShaderComponent = (AllIn13DShaderComponent)targets[i];

				Material currMaterial = allIn13DShaderComponent.currMaterial;
				if (currMaterial == null || !propertiesConfigCollection.IsAllIn3DShaderMaterial(currMaterial))
				{
					Shader shader = propertiesConfigCollection.shaderPropertiesConfig[0].shader;

					Material oldMaterial = allIn13DShaderComponent.currMaterial;
					allIn13DShaderComponent.NewCleanMaterial(shader, globalConfiguration.defaultPreset);

					MaterialConverterTool.ApplyConversion(oldMaterial, allIn13DShaderComponent.currMaterial);
				}
			}

			EditorUtils.SetDirtyCurrentScene();
		}

		private void DeactivateAllEffects()
		{
			bool successOperation = true;
			bool selectedComponentsAreValid = CheckSelectedComponents();

			for (int i = 0; i < targets.Length; i++)
			{
				AllIn13DShaderComponent allIn13DShaderComponent = (AllIn13DShaderComponent)targets[i];
				successOperation = successOperation && allIn13DShaderComponent.CheckValidComponent();

				Material mat = allIn13DShaderComponent.currMaterial;
				PropertiesConfig propertiesConfig = propertiesConfigCollection.FindPropertiesConfigByShader(mat.shader);

				List<AllIn13DEffectConfig> effects = propertiesConfig.GetAllEffects();

				for (int j = 0; j < effects.Count; j++)
				{
					mat.SetFloat(effects[j].keywordPropertyName, 0f);
				}

				EditorUtility.SetDirty(allIn13DShaderComponent);
				EditorUtility.SetDirty(mat);
			}
		}

		private void NewCleanMaterial()
		{
			for (int i = 0; i < targets.Length; i++)
			{
				AllIn13DShaderComponent allIn13DShaderComponent = (AllIn13DShaderComponent)targets[i];
				
				Shader shader = propertiesConfigCollection.shaderPropertiesConfig[0].shader;
				allIn13DShaderComponent.NewCleanMaterial(shader, globalConfiguration.defaultPreset);
			}
		}

		public void MakeCopyMaterial()
		{
			for (int i = 0; i < targets.Length; i++)
			{
				AllIn13DShaderComponent allIn13DShaderComponent = (AllIn13DShaderComponent)targets[i];
				
				Renderer currRenderer = allIn13DShaderComponent.currRenderer;
				Material currMat = currRenderer.sharedMaterial;

				string materialName = "MAT_" + allIn13DShaderComponent.gameObject.name;
				Material copy = new Material(currMat);
				copy.name = materialName;

				currRenderer.sharedMaterial = copy;

				EditorUtility.SetDirty(allIn13DShaderComponent);
			}
		}

		public void SaveMaterialToFolder()
		{
			for (int i = 0; i < targets.Length; i++)
			{
				AllIn13DShaderComponent allIn13DShaderComponent = (AllIn13DShaderComponent)targets[i];
				SaveMaterialToFolder(allIn13DShaderComponent);
			}

			EditorUtils.SetDirtyCurrentScene();
		}

		private bool CheckSelectedComponents()
		{
			bool res = true;

			for (int i = 0; i < targets.Length; i++)
			{
				AllIn13DShaderComponent allIn13DShaderComponent = (AllIn13DShaderComponent)targets[i];

				bool isValid = allIn13DShaderComponent.CheckValidComponent();
				if (!isValid)
				{
					DestroyImmediate(allIn13DShaderComponent);
				}

				res = res && isValid;
			}

			return res;
		}

		private void ExecuteActionAfterCheck(Action action)
		{
			bool selectedComponentsAreValid = CheckSelectedComponents();

			if (selectedComponentsAreValid)
			{
				action();
			}
			else
			{
				SceneView.lastActiveSceneView.ShowNotification(new GUIContent("Some of the selected components are not valid"));
			}
		}

		private void SaveMaterialToFolder(AllIn13DShaderComponent comp)
		{
			Material matToSave = comp.currMaterial;
			bool isAlreadySaved = AssetDatabase.Contains(matToSave);
			if (isAlreadySaved)
			{
				matToSave = comp.DuplicateCurrentMaterial();
			}

			string folderPath = GlobalConfiguration.instance.MaterialSavePath;
			if (!Directory.Exists(folderPath))
			{
				bool ok = EditorUtility.DisplayDialog("The desired save folder doesn't exist",
					"Go to Window -> AllIn13DShaderWindow and set a valid folder", "Set default values and save material", "Cancel");

				if (ok)
				{
					Directory.CreateDirectory(folderPath);
				}
			}

			if (Directory.Exists(folderPath))
			{
				string fullPath = Path.Combine(folderPath, matToSave.name + ".mat");
				fullPath = AssetDatabase.GenerateUniqueAssetPath(fullPath);

				AssetDatabase.CreateAsset(matToSave, fullPath);
				AssetDatabase.Refresh();

				EditorGUIUtility.PingObject(matToSave);
			}
		}

		private void ApplyMaterialToAllChildren()
		{
			for (int i = 0; i < targets.Length; i++)
			{
				AllIn13DShaderComponent allIn13DShaderComponent = (AllIn13DShaderComponent)targets[i];
				allIn13DShaderComponent.ApplyMaterialToChildren();

				EditorUtility.SetDirty(allIn13DShaderComponent);
			}

			EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
		}

		private void RenderMaterialToImage()
		{
			for (int i = 0; i < targets.Length; i++)
			{
				AllIn13DShaderComponent allIn13DShaderComponent = (AllIn13DShaderComponent)targets[i];
				RenderToImage(allIn13DShaderComponent);

				EditorUtility.SetDirty(allIn13DShaderComponent);
			}
		}

		public void RenderToImage(AllIn13DShaderComponent allIn13DShaderComponent)
		{
			Texture tex = allIn13DShaderComponent.currMaterial.GetTexture("_MainTex");
			if (tex != null)
			{
				string folderPath = GlobalConfiguration.instance.RenderImageSavePath;
				string fileName = allIn13DShaderComponent.gameObject.name + ".png";
				RenderMaterialToImageTool.RenderAndSaveTexture(allIn13DShaderComponent.currMaterial, tex, 4.0f, folderPath, fileName);
			}
			else
			{
				EditorUtility.DisplayDialog("No valid target texture found",
					   "All In 1 3DShader component couldn't find a valid Main Texture in this GameObject (" +
					   allIn13DShaderComponent.gameObject.name +
					   "). This means that the material you are using has no Main Texture or that the texture couldn't be reached through the Renderer component you are using." +
					   " Please make sure to have a valid Main Texture in the Material", "Ok");
			}
		}

		private void RemoveComponent()
		{
			for (int i = targets.Length - 1; i >= 0; i--)
			{
				AllIn13DShaderComponent allIn13DShaderComponent = (AllIn13DShaderComponent)targets[i];
				DestroyImmediate(allIn13DShaderComponent);
			}

			//EditorUtils.SetDirtyCurrentScene();

			SetSceneDirty();
			EditorUtils.ShowNotification("AllIn3DShader: Component Removed");
		}

		private void RemoveComponentAndMaterial()
		{
			for (int i = 0; i < targets.Length; i++)
			{
				AllIn13DShaderComponent allIn13DShaderComponent = (AllIn13DShaderComponent)targets[i];
				allIn13DShaderComponent.CleanMaterial();
			}

			for (int i = targets.Length - 1; i >= 0; i--)
			{
				AllIn13DShaderComponent allIn13DShaderComponent = (AllIn13DShaderComponent)targets[i];
				DestroyImmediate(allIn13DShaderComponent);
			}

			SetSceneDirty();
		}

		public void SetSceneDirty()
		{
			if (!Application.isPlaying) EditorSceneManager.MarkAllScenesDirty();

			//If you get an error here please delete the code block below
#if UNITY_2021_2_OR_NEWER
			var prefabStage = UnityEditor.SceneManagement.PrefabStageUtility.GetCurrentPrefabStage();
#else
            var prefabStage = UnityEditor.Experimental.SceneManagement.PrefabStageUtility.GetCurrentPrefabStage();
#endif
			if (prefabStage != null)
			{
				EditorSceneManager.MarkSceneDirty(prefabStage.scene);
			}	

			//Until here
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/CustomEditors/AllIn13DShaderComponentCustomEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/CustomEditors/AllIn13DShaderMaterialInspector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 57331ffe54816494c92e6b25562e4ed5
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	[CanEditMultipleObjects]
	public class AllIn13DShaderMaterialInspector : ShaderGUI
	{
		private PropertiesConfigCollection propertiesConfigCollection;
		private PropertiesConfig currentPropertiesConfig;

		private AllIn13DShaderInspectorReferences inspectorReferences;
		private AbstractEffectDrawer[] drawers;
		private GlobalPropertiesDrawer globalPropertiesDrawer;
		private AdvancedPropertiesDrawer advancedPropertiesDrawer;

		private MaterialPresetCollection blendingModeCollection;

		private MaterialProperty matPropertyRenderPreset;
		private MaterialProperty matPropertyBlendSrc;
		private MaterialProperty matPropertyBlendDst;
		private MaterialProperty matPropertyZWrite;
		
		private int lastRenderQueue;
		private float lasTimeRebuilt;

		private void RefreshReferences(MaterialEditor materialEditor, MaterialProperty[] properties)
		{
			if (inspectorReferences == null)
			{
				inspectorReferences = new AllIn13DShaderInspectorReferences();
				inspectorReferences.Setup(materialEditor, properties);

				if (lastRenderQueue > 0)
				{
					inspectorReferences.targetMat.renderQueue = lastRenderQueue;
				}
			}

			if (propertiesConfigCollection == null)
			{
				string[] guids = AssetDatabase.FindAssets("PropertiesConfigCollection t:PropertiesConfigCollection");
				if(guids.Length == 0)
				{
					Debug.LogWarning("PropertiesConfigCollection not found in the project. Configuring...");
					this.propertiesConfigCollection = PropertiesConfigCreator.CreateConfig();
					Debug.LogWarning("AllIn13DShader configured");
				}
				else
				{
					string path = AssetDatabase.GUIDToAssetPath(guids[0]);
					propertiesConfigCollection = AssetDatabase.LoadAssetAtPath<PropertiesConfigCollection>(path);
				}

				RefreshPropertiesConfig();

				lasTimeRebuilt = (float)EditorApplication.timeSinceStartup;
			}

			if (blendingModeCollection == null)
			{
				blendingModeCollection = (MaterialPresetCollection)EditorUtils.FindAsset<ScriptableObject>("BlendingModeCollection");
			}

			CreateDrawers();

			matPropertyRenderPreset = inspectorReferences.matProperties[currentPropertiesConfig.renderPreset];
			matPropertyBlendSrc = inspectorReferences.matProperties[currentPropertiesConfig.blendSrcIdx];
			matPropertyBlendDst = inspectorReferences.matProperties[currentPropertiesConfig.blendDstIdx];
			matPropertyZWrite = inspectorReferences.matProperties[currentPropertiesConfig.zWriteIndex];

			//We ensure that data is refreshed. Sometimes objects are not null but we need to refresh the references
			inspectorReferences.Setup(materialEditor, properties);
			RefreshDrawers();
		}

		private void ResetReferences()
		{
			this.propertiesConfigCollection = null;
			this.currentPropertiesConfig = null;

			inspectorReferences = null;
			drawers = null;

			globalPropertiesDrawer = null;
			advancedPropertiesDrawer = null;
		}

		private void CreateDrawers()
		{
			if (drawers == null)
			{
				drawers = new AbstractEffectDrawer[0];

				GeneralEffectDrawer generalEffectDrawer = new GeneralEffectDrawer(inspectorReferences, currentPropertiesConfig);


				EffectProperty mainNormalMapProperty = currentPropertiesConfig.FindEffectProperty("NORMAL_MAP", "_NormalMap");

				TriplanarEffectDrawer triplanarEffectDrawer = new TriplanarEffectDrawer(mainNormalMapProperty, inspectorReferences, currentPropertiesConfig);
				ColorRampEffectDrawer colorRampEffectDrawer = new ColorRampEffectDrawer(inspectorReferences, currentPropertiesConfig);
				OutlineEffectDrawer outlineEffectDrawer = new OutlineEffectDrawer(inspectorReferences, currentPropertiesConfig);
				TextureBlendingEffectDrawer vertexColorEffectDrawer = new TextureBlendingEffectDrawer(mainNormalMapProperty, inspectorReferences, currentPropertiesConfig);

				ArrayUtility.Add(ref drawers, generalEffectDrawer);
				ArrayUtility.Add(ref drawers, triplanarEffectDrawer);
				ArrayUtility.Add(ref drawers, colorRampEffectDrawer);
				ArrayUtility.Add(ref drawers, outlineEffectDrawer);
				ArrayUtility.Add(ref drawers, vertexColorEffectDrawer);

				advancedPropertiesDrawer = new AdvancedPropertiesDrawer(currentPropertiesConfig.advancedProperties, currentPropertiesConfig.blendSrcIdx, currentPropertiesConfig.blendDstIdx, inspectorReferences);
			}

			if (globalPropertiesDrawer == null)
			{
				globalPropertiesDrawer = new GlobalPropertiesDrawer();
			}
		}

		private void RefreshDrawers()
		{
			for(int i = 0; i < drawers.Length; i++)
			{
				drawers[i].Refresh(inspectorReferences);
			}
		}

		private AbstractEffectDrawer FindEffectDrawerByID(string drawerID)
		{
			AbstractEffectDrawer res = null;

			for (int i = 0; i < drawers.Length; i++)
			{
				if (drawers[i].ID == drawerID)
				{
					res = drawers[i];
					break;
				}
			}

			return res;
		}

		public override void AssignNewShaderToMaterial(Material material, Shader oldShader, Shader newShader)
		{
			base.AssignNewShaderToMaterial(material, oldShader, newShader);
		}

		private void RefreshPropertiesConfig()
		{
			currentPropertiesConfig = propertiesConfigCollection.FindPropertiesConfigByShader(inspectorReferences.targetMat.shader);

			inspectorReferences.SetOutlineEffect(currentPropertiesConfig);
			inspectorReferences.SetCastShadowsEffect(currentPropertiesConfig);
		}

		public override void OnGUI(MaterialEditor materialEditor, MaterialProperty[] properties)
		{
			if (lasTimeRebuilt <= EditorPrefs.GetFloat(Constants.LAST_TIME_SHADER_PROPERTIES_REBUILT_KEY, float.MaxValue))
			{
				ResetReferences();
				lasTimeRebuilt = (float)EditorApplication.timeSinceStartup;
			}

			if (inspectorReferences != null && drawers != null)
			{
				inspectorReferences.Setup(materialEditor, properties);
			}

			RefreshReferences(materialEditor, properties);

			DrawPresetsTabs();
			DrawAdvancedProperties();
			DrawGlobalProperties();
			DrawEffects();

			lastRenderQueue = inspectorReferences.targetMat.renderQueue;


			CheckPasses();

			CheckShader();
		}

		private void CheckShader()
		{
			bool isOutline = AllIn13DEffectConfig.IsEffectEnabled(inspectorReferences.outlineEffectConfig, inspectorReferences);
			bool castShadowsEnabled = AllIn13DEffectConfig.IsEffectEnabled(inspectorReferences.castShadowsEffectConfig, inspectorReferences);

			bool shaderChanged = false;

			Shader oldShader = null;
			Shader newShader = null;
			Shader shaderToCompare = null;

			if (isOutline)
			{
				if (castShadowsEnabled)
				{
					shaderToCompare = inspectorReferences.shOutline;
				}
				else
				{
					shaderToCompare = inspectorReferences.shOutlineNoShadowCaster;
				}
			}
			else
			{
				if (castShadowsEnabled)
				{
					shaderToCompare = inspectorReferences.shStandard;
				}
				else
				{
					shaderToCompare = inspectorReferences.shStandardNoShadowCaster;
				}
			}

			if (inspectorReferences.targetMat.shader != shaderToCompare)
			{
				oldShader = inspectorReferences.targetMat.shader;
				newShader = shaderToCompare;

				shaderChanged = true;
			}

			if (shaderChanged)
			{
				inspectorReferences.targetMat.shader = newShader;
				ResetReferences();
			}
		}

		private bool CheckOutlineShader(ref bool shaderChanged)
		{
			bool res = false;

			bool outlineEnabled = AllIn13DEffectConfig.IsEffectEnabled(inspectorReferences.outlineEffectConfig, inspectorReferences);
			shaderChanged = false;

			Shader oldShader = null;
			Shader newShader = null;

			if (outlineEnabled)
			{
				if(inspectorReferences.targetMat.shader != inspectorReferences.shOutline)
				{
					oldShader = inspectorReferences.shStandard;
					newShader = inspectorReferences.shOutline;

					shaderChanged = true;
				}
			}
			else
			{
				if (inspectorReferences.targetMat.shader != inspectorReferences.shStandard)
				{
					oldShader = inspectorReferences.shOutline;
					newShader = inspectorReferences.shStandard;

					shaderChanged = true;
				}
			}

			if (shaderChanged)
			{
				inspectorReferences.targetMat.shader = newShader;
			}

			res = outlineEnabled;

			return res;
		}

		//TODO: Reuse code from CheckOutlineShader
		private void CheckCastShadows(bool isOutline, ref bool shaderChanged)
		{
			bool castShadowEnabled = AllIn13DEffectConfig.IsEffectEnabled(inspectorReferences.castShadowsEffectConfig, inspectorReferences);
			
			Shader referenceShaderNoShadowCaster = inspectorReferences.shStandardNoShadowCaster;
			if (isOutline)
			{
				referenceShaderNoShadowCaster = inspectorReferences.shOutlineNoShadowCaster;
			}

			Shader referenceShadowWithShadowCaster = inspectorReferences.shStandard;
			if (isOutline)
			{
				referenceShadowWithShadowCaster = inspectorReferences.shOutline;
			}

			Shader oldShader = null;
			Shader newShader = inspectorReferences.targetMat.shader;

			if (!castShadowEnabled)
			{
				if (inspectorReferences.targetMat.shader != referenceShaderNoShadowCaster)
				{
					oldShader = inspectorReferences.targetMat.shader;
					newShader = referenceShaderNoShadowCaster;

					shaderChanged = true;
				}
			}
			else
			{
				if (inspectorReferences.targetMat.shader != referenceShadowWithShadowCaster)
				{
					oldShader = inspectorReferences.targetMat.shader;
					newShader = referenceShadowWithShadowCaster;

					shaderChanged = true;
				}
			}

			if (shaderChanged)
			{
				inspectorReferences.targetMat.shader = newShader;
			}
		}

		private void CheckPasses()
		{
			if (inspectorReferences.targetMat.IsKeywordEnabled("_LIGHTMODEL_FASTLIGHTING") || inspectorReferences.targetMat.IsKeywordEnabled("_LIGHTMODEL_NONE"))
			{
				inspectorReferences.targetMat.SetShaderPassEnabled("ForwardAdd", false);
			}
			else
			{
				inspectorReferences.targetMat.SetShaderPassEnabled("ForwardAdd", true);
			}
		}

		private void DrawPresetsTabs()
		{
			EditorGUI.BeginChangeCheck();

			string[] texts = blendingModeCollection.CreateStringsArray();


			int presetIndex = (int)matPropertyRenderPreset.floatValue;
			if (presetIndex >= blendingModeCollection.presets.Length)
			{
				presetIndex = 1;
				matPropertyRenderPreset.floatValue = presetIndex;
			}

			BlendingMode previousPreset = blendingModeCollection[presetIndex];
			if(previousPreset == null)
			{
				previousPreset = blendingModeCollection[0];
			}

			int newIndex = (int)matPropertyRenderPreset.floatValue;
			newIndex = GUILayout.SelectionGrid(newIndex, texts, 3, inspectorReferences.tabButtonStyle);
			matPropertyRenderPreset.floatValue = newIndex;
			if (EditorGUI.EndChangeCheck())
			{
				BlendingMode selectedPreset = blendingModeCollection[newIndex];
				ApplyMaterialPreset(previousPreset, selectedPreset);
			}
		}

		private void DrawAdvancedProperties()
		{
			advancedPropertiesDrawer.Draw();
		}

		private void DrawGlobalProperties()
		{
			globalPropertiesDrawer.Draw(currentPropertiesConfig.singleProperties, inspectorReferences);
		}

		private void DrawEffects()
		{
			int globalEffectIndex = 0;
			for (int groupIdx = 0; groupIdx < currentPropertiesConfig.effectsGroups.Length; groupIdx++)
			{
				EffectGroup effectGroup = currentPropertiesConfig.effectsGroups[groupIdx];
				if (effectGroup.effects.Length <= 0) { continue; }

				EditorGUILayout.Separator();
				EditorUtils.DrawLine(Color.grey, 1, 3);
				GUILayout.Label(effectGroup.DisplayName, inspectorReferences.bigLabelStyle);

				for (int effectIdx = 0; effectIdx < effectGroup.effects.Length; effectIdx++)
				{
					AllIn13DEffectConfig effectConfig = effectGroup.effects[effectIdx];

					globalEffectIndex++;

					AbstractEffectDrawer drawer = FindEffectDrawerByID(effectConfig.effectDrawerID);
					drawer.Draw(currentPropertiesConfig, effectConfig, globalEffectIndex);
				}
			}
		}

		private void ApplyMaterialPreset(BlendingMode previousPresset, BlendingMode newPreset)
		{
			matPropertyBlendSrc.floatValue = (float)newPreset.blendSrc;
			matPropertyBlendDst.floatValue = (float)newPreset.blendDst;
			matPropertyZWrite.floatValue = newPreset.depthWrite ? 1.0f : 0.0f;


			lastRenderQueue = (int)newPreset.renderQueue;
			inspectorReferences.targetMat.renderQueue = lastRenderQueue;

			if (previousPresset != newPreset && previousPresset.defaultEnabledEffects != null)
			{
				for (int i = 0; i < previousPresset.defaultEnabledEffects.Length; i++)
				{
					string effectID = previousPresset.defaultEnabledEffects[i];
					AllIn13DEffectConfig effectConfig = currentPropertiesConfig.FindEffectConfigByID(effectID);

					AllIn13DEffectConfig.DisableEffectToggle(effectConfig, inspectorReferences);
				}
			}

			if (newPreset.defaultEnabledEffects != null)
			{
				for (int i = 0; i < newPreset.defaultEnabledEffects.Length; i++)
				{
					string effectID = newPreset.defaultEnabledEffects[i];
					AllIn13DEffectConfig effectConfig = currentPropertiesConfig.FindEffectConfigByID(effectID);

					AllIn13DEffectConfig.EnableEffectToggle(effectConfig, inspectorReferences);
				}
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/CustomEditors/AllIn13DShaderMaterialInspector.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/CustomEditors/DepthColoringPropertiesCustomEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 3a34b75ebd088a947a2e03b954f187d4
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	[CustomEditor(typeof(AllIn1DepthColoringProperties))]
	public class DepthColoringPropertiesCustomEditor : Editor
	{
		private SerializedProperty spDepthColoringMinDepth;
		private SerializedProperty spDepthZoneLength;
		private SerializedProperty spFallOff;
		private SerializedProperty spDepthColoringGradientTex;

		private Texture gradientTex;

		private bool createGradientToggle;

		private GradientEditorDrawer gradientEditorDrawer;

		private AllIn1DepthColoringProperties depthColoringProperties;

		private void RefreshRerences()
		{
			if(spDepthColoringMinDepth == null)
			{
				spDepthColoringMinDepth = serializedObject.FindProperty("depthColoringMinDepth");
			}

			if(spDepthZoneLength == null)
			{
				spDepthZoneLength = serializedObject.FindProperty("depthZoneLength");
			}

			if(spDepthColoringGradientTex == null)
			{
				spDepthColoringGradientTex = serializedObject.FindProperty("depthColoringGradientTex");
			}

			if (spFallOff == null)
			{
				spFallOff = serializedObject.FindProperty("fallOff");
			}

			if(gradientEditorDrawer == null)
			{
				gradientEditorDrawer = new GradientEditorDrawer();
			}

			depthColoringProperties = (AllIn1DepthColoringProperties)target;
		}

		public override void OnInspectorGUI()
		{
			RefreshRerences();

			serializedObject.Update();

			EditorGUI.BeginChangeCheck();
			EditorGUILayout.PropertyField(spDepthColoringMinDepth);
			EditorGUILayout.PropertyField(spDepthZoneLength);
			EditorGUILayout.PropertyField(spFallOff);

			Rect rect = EditorGUILayout.GetControlRect(true, 500f);


			if(spDepthColoringGradientTex.objectReferenceValue != null)
			{
				gradientTex = (Texture)spDepthColoringGradientTex.objectReferenceValue;
			}

			gradientTex = gradientEditorDrawer.Draw(rect, gradientTex);
			spDepthColoringGradientTex.objectReferenceValue = gradientTex;

			bool changes = EditorGUI.EndChangeCheck();

			serializedObject.ApplyModifiedProperties();

			if (changes)
			{
				Texture gradientTexToApply = spDepthColoringGradientTex.objectReferenceValue == null ? gradientTex : (Texture)spDepthColoringGradientTex.objectReferenceValue;
				depthColoringProperties.ApplyValues(gradientTexToApply);
			}
		}

		private void GradientChangedCallback()
		{
			depthColoringProperties.ApplyValues();
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/CustomEditors/DepthColoringPropertiesCustomEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/CustomEditors/GlobalConfigurationCustomEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c57330f81e2eed441862d8a92a0e63cf
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEditor;

namespace AllIn13DShader
{
	[CustomEditor(typeof(GlobalConfiguration))]
	public class GlobalConfigurationCustomEditor : Editor
	{
		public override void OnInspectorGUI()
		{
		
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/CustomEditors/GlobalConfigurationCustomEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/CustomEditors/PropertiesConfigCollectionCustomEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 436434178bc9cbf449485b83a639cdbb
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEditor;

namespace AllIn13DShader
{
	[CustomEditor(typeof(PropertiesConfigCollection))]
	public class PropertiesConfigCollectionCustomEditor : Editor
	{
		public override void OnInspectorGUI()
		{
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/CustomEditors/PropertiesConfigCollectionCustomEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/AdvancedPropertiesDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 4877ef4771a6497458bd45402be12188
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class AdvancedPropertiesDrawer
	{
		private List<int> advancedPropertiesIndices;
		private int blendSrcIndex;
		private int blendDstIndex;

		private AllIn13DShaderInspectorReferences references;

		private MaterialProperty advancedPropertiesEnabledMatProperty;

		private bool AdvancedPropertiesEnabled
		{
			get
			{
				bool res = advancedPropertiesEnabledMatProperty.floatValue > 0;
				return res;
			}
			set
			{
				float floatValue = value ? 1.0f : 0f;
				advancedPropertiesEnabledMatProperty.floatValue = floatValue;
			}
		}

		public AdvancedPropertiesDrawer(List<int> advancedPropertiesIndices, int blendSrcIndex, int blendDstIndex, AllIn13DShaderInspectorReferences references)
		{
			this.advancedPropertiesIndices = advancedPropertiesIndices;
			this.blendSrcIndex = blendSrcIndex;
			this.blendDstIndex = blendDstIndex;

			this.references = references;

			advancedPropertiesEnabledMatProperty = references.matProperties[advancedPropertiesIndices[0]];
		}

		public void Draw()
		{
			AdvancedPropertiesEnabled = GUILayout.Toggle(AdvancedPropertiesEnabled, new GUIContent("Show Advanced Configuration"), references.toggleButtonStyle);
			if (AdvancedPropertiesEnabled)
			{
				EditorGUILayout.BeginVertical(references.propertiesStyle);

				EffectPropertyDrawer.DrawProperty(blendSrcIndex, string.Empty, false, references);
				EffectPropertyDrawer.DrawProperty(blendDstIndex, string.Empty, false, references);
				EditorUtils.DrawThinLine();

				for (int i = 1; i < advancedPropertiesIndices.Count; i++)
				{
					//if(i == blendSrcIndex || i == blendDstIndex) { continue; }
					EffectPropertyDrawer.DrawProperty(advancedPropertiesIndices[i], string.Empty, false, references);
					EditorUtils.DrawThinLine();
				}

				references.editorMat.EnableInstancingField();

				Rect rect = EditorGUILayout.GetControlRect();
				rect.x += 3f;
				rect.width -= 3f;
				references.editorMat.RenderQueueField(rect);

				EditorGUILayout.EndVertical();
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/AdvancedPropertiesDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/AtlasPackerDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 34d02d3768139eb44a2176f800efaa40
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.IO;
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class AtlasPackerDrawer : ScriptableObject
	{
		public Texture2D[] Atlas;
		private AtlasPackerTool atlasPackerTool;
		private CommonStyles commonStyles;

		private bool SquareAtlas
		{
			get
			{
				return atlasPackerTool.squareAtlas;
			}
			set
			{
				atlasPackerTool.squareAtlas = value;
			}
		}

		private int AtlasXCount
		{
			get
			{
				return atlasPackerTool.atlasXCount;
			}
			set
			{
				atlasPackerTool.atlasXCount = value;
			}
		}

		private int AtlasYCount
		{
			get
			{
				return atlasPackerTool.atlasYCount;
			}
			set
			{
				atlasPackerTool.atlasYCount = value;
			}
		}

		private FilterMode AtlasFiltering
		{
			get
			{
				return atlasPackerTool.atlasFiltering;
			}
			set
			{
				atlasPackerTool.atlasFiltering = value;
			}
		}

		private TextureSizes AtlasSizesX
		{
			get
			{
				return atlasPackerTool.atlasSizesX;
			}
			set
			{
				atlasPackerTool.atlasSizesX = value;
			}
		}

		private TextureSizes AtlasSizesY
		{
			get
			{
				return atlasPackerTool.atlasSizesY;
			}
			set
			{
				atlasPackerTool.atlasSizesY = value;
			}
		}

		public void Setup(AtlasPackerTool atlasPackerTool, CommonStyles commonStyles)
		{
			this.atlasPackerTool = atlasPackerTool;
			this.commonStyles = commonStyles;
			Atlas = new Texture2D[0];
		}

		public void Draw()
		{
			GUILayout.Label("Texture Atlas / Spritesheet Packer", commonStyles.bigLabel);
			GUILayout.Space(20);
			GUILayout.Label("Add Textures to the Atlas array", EditorStyles.boldLabel);

			SerializedObject so = new SerializedObject(this);
			SerializedProperty atlasProperty = so.FindProperty("Atlas");
			EditorGUILayout.PropertyField(atlasProperty, true, GUILayout.MaxWidth(200));
			so.ApplyModifiedProperties();

			atlasPackerTool.atlas = Atlas;

			SquareAtlas = EditorGUILayout.Toggle("Square Atlas?", SquareAtlas, GUILayout.MaxWidth(200));
			EditorGUILayout.BeginHorizontal();
			{
				if (SquareAtlas)
				{
					AtlasXCount = EditorGUILayout.IntSlider("Column and Row Count", AtlasXCount, 1, 8, GUILayout.MaxWidth(302));
					AtlasYCount = AtlasXCount;
				}
				else
				{
					AtlasXCount = EditorGUILayout.IntSlider("Column Count", AtlasXCount, 1, 8, GUILayout.MaxWidth(302));
					GUILayout.Space(10);
					AtlasYCount = EditorGUILayout.IntSlider("Row Count", AtlasYCount, 1, 8, GUILayout.MaxWidth(302));
				}
			}
			EditorGUILayout.EndHorizontal();

			EditorGUILayout.BeginHorizontal();
			{
				if (SquareAtlas)
				{
					GUILayout.Label("Atlas Size:", GUILayout.MaxWidth(100));
					AtlasSizesX = (TextureSizes)EditorGUILayout.EnumPopup(AtlasSizesX, GUILayout.MaxWidth(200));
					AtlasSizesY = AtlasSizesX;
				}
				else
				{
					GUILayout.Label("Atlas Size X:", GUILayout.MaxWidth(100));
					AtlasSizesX = (TextureSizes)EditorGUILayout.EnumPopup(AtlasSizesX, GUILayout.MaxWidth(200));
					GUILayout.Space(10);
					GUILayout.Label("Atlas Size Y:", GUILayout.MaxWidth(100));
					AtlasSizesY = (TextureSizes)EditorGUILayout.EnumPopup(AtlasSizesY, GUILayout.MaxWidth(200));
				}
			}
			EditorGUILayout.EndHorizontal();
			EditorGUILayout.BeginHorizontal();
			{
				GUILayout.Label("Atlas Filtering: ", GUILayout.MaxWidth(100));
				AtlasFiltering = (FilterMode)EditorGUILayout.EnumPopup(AtlasFiltering, GUILayout.MaxWidth(200));
			}
			EditorGUILayout.EndHorizontal();

			int atlasElements = atlasPackerTool.GetAtlasElements();
			int atlasWidth = (int)AtlasSizesX;
			int atlasHeight = (int)AtlasSizesY;
			GUILayout.Label("Output will be a " + AtlasXCount + " X " + AtlasYCount + " atlas, " + atlasElements + " elements in total. In a " +
							atlasWidth + "pixels X " + atlasHeight + "pixels texture", EditorStyles.boldLabel);

			int usedAtlasSlots = 0;
			for (int i = 0; i < atlasPackerTool.atlas.Length; i++)
			{
				if (atlasPackerTool.atlas[i] != null)
				{
					usedAtlasSlots++;
				}
			}
			if (usedAtlasSlots > atlasElements)
			{
				GUILayout.Label("*Please reduce the Atlas texture slots by " + Mathf.Abs(atlasElements - atlasPackerTool.atlas.Length) + " (extra textures will be ignored)", EditorStyles.boldLabel);
			}

			if (atlasElements > usedAtlasSlots)
			{
				GUILayout.Label("*" + (atlasElements - usedAtlasSlots) + " atlas slots unused or null (it will be filled with black)", EditorStyles.boldLabel);
			}

			GUILayout.Space(20);
			GUILayout.Label("Select the folder where new Atlases will be saved", EditorStyles.boldLabel);
			GlobalConfiguration.instance.AtlasesSavePath = EditorUtils.DrawSelectorFolder(GlobalConfiguration.instance.AtlasesSavePath, /*AllIn13DShaderConfig.ATLASES_SAVE_PATH_DEFAULT,*/ "Atlas");


			if (Directory.Exists(GlobalConfiguration.instance.AtlasesSavePath))
			{
				if (GUILayout.Button("Create And Save Atlas Texture", GUILayout.MaxWidth(CommonStyles.BUTTON_WIDTH)))
				{
					atlasPackerTool.CreateAtlas();
					EditorUtils.SaveTextureAsPNG(GlobalConfiguration.instance.AtlasesSavePath, "NormalMap", "Normal Map", atlasPackerTool.createdAtlas, AtlasFiltering, TextureImporterType.Default, TextureWrapMode.Clamp);
				}
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/AtlasPackerDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/CommonStyles.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: aba3dca1c691c3b4891e7a7e67ad55dc
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class CommonStyles
	{
		public const int BUTTON_WIDTH = 600;
		public const int BIG_FONT_SIZE = 16;

		public GUIStyle style;
		public GUIStyle bigLabel;

		public void InitStyles()
		{
			if(style == null)
			{
				style = new GUIStyle(EditorStyles.helpBox);
				style.margin = new RectOffset(0, 0, 0, 0);
			}

			if(bigLabel == null)
			{
				bigLabel = new GUIStyle(EditorStyles.boldLabel);
				bigLabel.fontSize = BIG_FONT_SIZE;
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/CommonStyles.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/EffectDrawers/AbstractEffectDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1fc7c21ef6e0e8b4c9333a9fdd7a4bb6
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public abstract class AbstractEffectDrawer
	{
		private const float HEIGHT_PER_LINE = 12.5f;

		protected string drawerID;
		protected PropertiesConfig propertiesConfig;
		protected AllIn13DEffectConfig effectConfig;
		protected AllIn13DShaderInspectorReferences references;
		protected int globalEffectIndex;

		public string ID
		{
			get
			{
				return drawerID;
			}
		}

		public AbstractEffectDrawer(AllIn13DShaderInspectorReferences references, PropertiesConfig propertiesConfig)
		{
			this.references = references;
			this.propertiesConfig = propertiesConfig;
		}

		public void Draw(PropertiesConfig propertiesConfig, AllIn13DEffectConfig effectConfig, int globalEffectIndex)
		{
			this.propertiesConfig = propertiesConfig;
			this.effectConfig = effectConfig;
			this.globalEffectIndex = globalEffectIndex;

			Draw();
		}

		protected virtual void Draw()
		{
			bool areDependenciesMet = AreDependenciesMet();

			EditorGUI.BeginDisabledGroup(!areDependenciesMet);
			EffectPropertyDrawer.DrawMainProperty(globalEffectIndex, effectConfig, references);
			bool isAnyPropertyVisible = IsAnyPropertyVisible();
			
			if (isAnyPropertyVisible)
			{
				EditorGUILayout.BeginVertical(references.propertiesStyle);
				DrawExtraData();
				DrawProperties();
				EditorGUILayout.EndVertical();
			}
			EditorGUI.EndDisabledGroup();
		}

		private void DrawExtraData()
		{
			if (IsParentPropertyEnabled())
			{
				string customMessage = effectConfig.GetCustomMessage(references.targetMat);
				if (!string.IsNullOrEmpty(customMessage))
				{
					EditorGUILayout.BeginHorizontal();

					int numLines = EditorUtils.GetNumLines(customMessage);
					float heightField = numLines * HEIGHT_PER_LINE;

					if (!string.IsNullOrEmpty(effectConfig.docURL))
					{
						if (GUILayout.Button("?", GUILayout.Width(heightField), GUILayout.Height(heightField)))
						{
							Application.OpenURL(effectConfig.docURL);
						}
					}


					EditorGUILayout.LabelField(customMessage, references.smallLabelStyle, GUILayout.Height(heightField));
					EditorGUILayout.EndHorizontal();
				}
			}
		}

		protected virtual void DrawProperties()
		{
			for (int i = 0; i < effectConfig.effectProperties.Count; i++)
			{
				EffectProperty effectProperty = effectConfig.effectProperties[i];
				DrawProperty(effectProperty, string.Empty, true);
			}
		}

		protected virtual void DrawProperty(EffectProperty effectProperty)
		{
			DrawProperty(effectProperty, true);
		}

		protected virtual void DrawProperty(EffectProperty effectProperty, bool allowReset)
		{
			DrawProperty(effectProperty, string.Empty, allowReset);
		}

		protected virtual void DrawProperty(EffectProperty effectProperty, string labelPrefix, bool allowReset)
		{
			if (IsEffectPropertyVisible(effectProperty))
			{
				EffectPropertyDrawer.DrawProperty(effectProperty, labelPrefix, allowReset, references);
			}
		}

		protected bool IsParentPropertyEnabled()
		{
			bool res = false;

			for (int i = 0; i < effectConfig.keywords.Count; i++)
			{
				string kw = effectConfig.keywords[i].keyword;
				if (references.targetMat.shaderKeywords.Contains(kw))
				{
					res = true;
					break;
				}
			}

			return res;
		}

		protected bool IsAnyPropertyVisible()
		{
			bool res = false;

			bool parentPropertyEnabled = IsParentPropertyEnabled();
			if (parentPropertyEnabled)
			{
				for (int propIdx = 0; propIdx < effectConfig.effectProperties.Count; propIdx++)
				{
					EffectProperty effectProperty = effectConfig.effectProperties[propIdx];

					res = IsEffectPropertyVisible(effectProperty);
					if (res)
					{
						break;
					}
				}
			}

			res = res || (parentPropertyEnabled && !string.IsNullOrEmpty(effectConfig.GetCustomMessage(references.targetMat)));

			return res;
		}

		protected bool IsEffectPropertyVisible(EffectProperty effectProperty)
		{
			bool res = false;

			bool anyIncompatibilities = false;
			for (int i = 0; i < effectProperty.incompatibleKeywords.Count; i++)
			{
				string incompatibleKw = effectProperty.incompatibleKeywords[i];
				if (references.targetMat.shaderKeywords.Contains(incompatibleKw))
				{
					anyIncompatibilities = true;
					break;
				}
			}

			if (!anyIncompatibilities)
			{
				if (effectProperty.keywordsOp == KeywordsOp.OR)
				{
					for (int i = 0; i < effectProperty.keywords.Count; i++)
					{
						string keyword = effectProperty.keywords[i];
						if (references.targetMat.shaderKeywords.Contains(keyword))
						{
							res = true;
							break;
						}
					}
				}
				else
				{
					res = true;
					for (int i = 0; i < effectProperty.keywords.Count; i++)
					{
						string keyword = effectProperty.keywords[i];
						if (!references.targetMat.shaderKeywords.Contains(keyword))
						{
							res = false;
							break;
						}
					}
				}
			}

			return res;
		}

		protected MaterialProperty FindPropertyByName(string propertyName)
		{
			MaterialProperty res = null;

			for (int i = 0; i < references.matProperties.Length; i++)
			{
				if (references.matProperties[i].name == propertyName)
				{
					res = references.matProperties[i];
					break;
				}
			}

			return res;
		}

		protected int FindPropertyIndex(string propertyName)
		{
			int res = -1;

			for (int i = 0; i < references.matProperties.Length; i++)
			{
				if (references.matProperties[i].name == propertyName)
				{
					res = i;
					break;
				}
			}

			return res;
		}

		protected bool AreDependenciesMet()
		{
			bool res = true;

			if (!string.IsNullOrEmpty(effectConfig.dependentOnEffect))
			{
				AllIn13DEffectConfig dependentEffect = propertiesConfig.FindEffectConfigByID(effectConfig.dependentOnEffect);
				res = res && AllIn13DEffectConfig.IsEffectEnabled(dependentEffect, references);
			}

			if (!string.IsNullOrEmpty(effectConfig.incompatibleWithEffectID))
			{
				AllIn13DEffectConfig dependentEffect = propertiesConfig.FindEffectConfigByID(effectConfig.incompatibleWithEffectID);
				res = res && !AllIn13DEffectConfig.IsEffectEnabled(dependentEffect, references);
			}

			return res;
		}

		public virtual void Refresh(AllIn13DShaderInspectorReferences references)
		{
			this.references = references;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/EffectDrawers/AbstractEffectDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/EffectDrawers/AllIn13DShaderGradientDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: aaf7449ec0a51804980a5d076861735c
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class AllIn13DShaderGradientDrawer : MaterialPropertyDrawer
	{
		private GradientEditorDrawer gradientEditorDrawer;

		private void RefreshReferences(MaterialProperty prop)
		{
			if(gradientEditorDrawer == null)
			{
				gradientEditorDrawer = new GradientEditorDrawer();
			}
		}

		public override void OnGUI(Rect position, MaterialProperty prop, GUIContent label, MaterialEditor editor)
		{
			RefreshReferences(prop);

			Texture texValue = prop.textureValue;

			EditorGUI.BeginChangeCheck();
			Texture newTex = gradientEditorDrawer.Draw(position, texValue);
			if (EditorGUI.EndChangeCheck())
			{
				prop.textureValue = newTex;
			}
		}

		public override float GetPropertyHeight(MaterialProperty prop, string label, MaterialEditor editor)
		{
			float res = 0f;
			if(gradientEditorDrawer != null)
			{
				res = gradientEditorDrawer.GetPropertyHeight();
			}

			return res;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/EffectDrawers/AllIn13DShaderGradientDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/EffectDrawers/ColorRampEffectDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 17130facc1b999348a0cbd8784766aba
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEditor;

namespace AllIn13DShader
{
	public class ColorRampEffectDrawer : AbstractEffectDrawer
	{
		public ColorRampEffectDrawer(AllIn13DShaderInspectorReferences references, PropertiesConfig propertiesConfig) : base(references, propertiesConfig)
		{
			this.drawerID = Constants.COLOR_RAMP_EFFECT_DRAWER_ID;
		}

		protected override void DrawProperties()
		{
			for(int i = 0; i < effectConfig.effectProperties.Count; i++)
			{
				DrawProperty(effectConfig.effectProperties[i]);
				if (i == 2)
				{
					EditorGUILayout.LabelField("*Set the Color Ramp Texture to Repeat Wrap Mode if using Tiling and/or Scroll Speed", references.smallLabelStyle);
				}
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/EffectDrawers/ColorRampEffectDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/EffectDrawers/GeneralEffectDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 8d0ce6e8dd172c346b1c817ec5065103
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class GeneralEffectDrawer : AbstractEffectDrawer
	{
		public GeneralEffectDrawer(AllIn13DShaderInspectorReferences references, PropertiesConfig propertiesConfig) : base(references, propertiesConfig)
		{
			this.drawerID = Constants.GENERAL_EFFECT_DRAWER_ID;

			
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/EffectDrawers/GeneralEffectDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/EffectDrawers/OutlineEffectDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6cc036b9a5e6daf40895576180575dd3
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class OutlineEffectDrawer : AbstractEffectDrawer
	{
		private MaterialProperty stencilRefMatProperty;

		public OutlineEffectDrawer(AllIn13DShaderInspectorReferences references, PropertiesConfig propertiesConfig) : base(references, propertiesConfig)
		{
			this.drawerID = Constants.OUTLINE_DRAWER_ID;

			stencilRefMatProperty = FindPropertyByName("_StencilRef");
		}

		protected override void DrawProperties()
		{
			base.DrawProperties();

			if (stencilRefMatProperty != null)
			{
				EffectPropertyDrawer.DrawProperty(stencilRefMatProperty, references);
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/EffectDrawers/OutlineEffectDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/EffectPropertyDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: edd8e2faf4f408743829655503b71b17
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;

namespace AllIn13DShader
{
	public static class EffectPropertyDrawer
	{
		public static void DrawMainProperty(int globalEffectIndex, AllIn13DEffectConfig effectConfig, AllIn13DShaderInspectorReferences references)
		{
			EditorGUILayout.BeginHorizontal();

			string label = $"{globalEffectIndex}. {effectConfig.displayName}";
			
			switch (effectConfig.effectConfigType)
			{
				case EffectConfigType.EFFECT_TOGGLE:
					DrawMainPropertyToggle(label, effectConfig, references);
					break;
				case EffectConfigType.EFFECT_ENUM:
					DrawMainPropertyEnum(label, effectConfig, references);
					break;
			}

			EditorGUILayout.EndHorizontal();
		}

		public static void DrawMainPropertyToggle(string label, AllIn13DEffectConfig effectConfig, AllIn13DShaderInspectorReferences references)
		{
			bool isEffectEnabled = AllIn13DEffectConfig.IsEffectEnabled(effectConfig, references);
			
			EditorGUI.BeginChangeCheck();

			string tooltip = effectConfig.keywords[0].keyword + " (C#)";
			GUIContent guiContent = new GUIContent(label, tooltip);
			isEffectEnabled = GUILayout.Toggle(isEffectEnabled, guiContent);
			if (EditorGUI.EndChangeCheck())
			{
				if (isEffectEnabled)
				{
					AllIn13DEffectConfig.EnableEffect(effectConfig, references);
				}
				else
				{
					AllIn13DEffectConfig.DisableEffect(effectConfig, references);
				}

				references.matProperties[effectConfig.keywordPropertyIndex].floatValue = isEffectEnabled ? 1f : 0f;

				EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
				EditorUtility.SetDirty(references.targetMat);
			}
		}

		public static void DrawMainPropertyEnum(string label, AllIn13DEffectConfig effectConfig, AllIn13DShaderInspectorReferences references)
		{
			int selectedIndex = 0;
			bool isEffectEnabled = AllIn13DEffectConfig.IsEffectEnabled(effectConfig, ref selectedIndex, references);

			EditorGUI.BeginChangeCheck();

			string tooltip = effectConfig.keywords[selectedIndex].keyword + " (C#)";
			GUIContent guiContent = new GUIContent(label, tooltip);
			selectedIndex = EditorGUILayout.Popup(guiContent, selectedIndex, effectConfig.keywordsDisplayNames);

			if (EditorGUI.EndChangeCheck())
			{
				if(selectedIndex >= 0)
				{
					AllIn13DEffectConfig.EnableEffectByIndex(effectConfig, selectedIndex, references);
				}
				else
				{
					AllIn13DEffectConfig.DisableEffect(effectConfig, references);
				}

				references.matProperties[effectConfig.keywordPropertyIndex].floatValue = selectedIndex;

				EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
				EditorUtility.SetDirty(references.targetMat);
			}
		}

		public static void DrawProperty(int propertyIndex, string labelPrefix, bool allowReset, AllIn13DShaderInspectorReferences references)
		{
			MaterialProperty targetProperty = references.matProperties[propertyIndex];
			DrawProperty(targetProperty, labelPrefix, allowReset, references);
		}

		public static void DrawProperty(EffectProperty effectProperty, string labelPrefix, bool allowReset, AllIn13DShaderInspectorReferences references)
		{
			DrawProperty(effectProperty.propertyIndex, labelPrefix, effectProperty.allowReset, references);
		}

		public static void DrawProperty(EffectProperty effectProperty, AllIn13DShaderInspectorReferences references)
		{
			DrawProperty(effectProperty.propertyIndex, references);
		}

		public static void DrawProperty(int propertyIndex, AllIn13DShaderInspectorReferences references)
		{
			DrawProperty(propertyIndex, string.Empty, true, references);
		}

		public static void DrawProperty(MaterialProperty materialProperty, AllIn13DShaderInspectorReferences references)
		{
			DrawProperty(materialProperty, string.Empty, true, references);
		}

		public static void DrawProperty(MaterialProperty materialProperty, bool allowReset, AllIn13DShaderInspectorReferences references)
		{
			DrawProperty(materialProperty, string.Empty, allowReset, references);
		}

		public static void DrawProperty(MaterialProperty materialProperty, string labelPrefix, bool allowReset, AllIn13DShaderInspectorReferences references)
		{
			DrawProperty(
				materialProperty: materialProperty, 
				labelPrefix: labelPrefix, 
				displayName: materialProperty.displayName,
				allowReset: allowReset, 
				references: references);
		}

		public static void DrawProperty(MaterialProperty materialProperty, string labelPrefix, string displayName, bool allowReset, AllIn13DShaderInspectorReferences references)
		{
			string label = $"{labelPrefix} {displayName}";
			string tooltip = materialProperty.name + "(C#)";


			EditorGUILayout.BeginHorizontal();

			DrawProperty(materialProperty, label, tooltip, references);
			if (allowReset)
			{
				DrawResetButton(materialProperty, references);
			}

			EditorGUILayout.EndHorizontal();
		}

		public static void DrawProperty(MaterialProperty targetProperty, string label, string tooltip, AllIn13DShaderInspectorReferences references)
		{
			GUIContent propertyLabel = new GUIContent();
			propertyLabel.text = label;
			propertyLabel.tooltip = tooltip;

			references.editorMat.ShaderProperty(targetProperty, propertyLabel);
		}

		public static void DrawResetButton(MaterialProperty targetProperty, AllIn13DShaderInspectorReferences references)
		{
			GUIContent resetButtonLabel = new GUIContent();
			resetButtonLabel.text = "R";
			resetButtonLabel.tooltip = "Resets to default value";
			if (GUILayout.Button(resetButtonLabel, GUILayout.Width(20)))
			{
				AllIn13DEffectConfig.ResetProperty(targetProperty, references);
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/EffectPropertyDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/GlobalPropertiesDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 55fc5c9db4641f54a912ca07e7d764f8
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class GlobalPropertiesDrawer
	{
		private List<int> globalPropertiesIndices;
		private AllIn13DShaderInspectorReferences references;

		public GlobalPropertiesDrawer()
		{
		}

		public void Draw(List<int> globalPropertiesIndices, AllIn13DShaderInspectorReferences references)
		{
			this.globalPropertiesIndices = globalPropertiesIndices;
			this.references = references;

			GUILayout.Label("Global Properties", references.bigLabelStyle);

			EditorGUILayout.BeginVertical(references.propertiesStyle);
			for (int i = 0; i < globalPropertiesIndices.Count; i++)
			{
				MaterialProperty matProperty = references.matProperties[globalPropertiesIndices[i]];
				EffectPropertyDrawer.DrawProperty(matProperty, references);
			}
			EditorGUILayout.EndVertical();
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/GlobalPropertiesDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/GradientCreatorDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 53d536ed22c0b4d4e8472402997463dd
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.IO;
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class GradientCreatorDrawer
	{
		private GradientCreatorTool gradientCreatorTool;
		private CommonStyles commonStyles;

		private Texture2D GradientTex
		{
			get
			{
				return gradientCreatorTool.gradientTex;
			}
			set
			{
				gradientCreatorTool.gradientTex = value;
			}
		}

		private Gradient Grad
		{
			get
			{
				return gradientCreatorTool.gradient;
			}
			set
			{
				gradientCreatorTool.gradient = value;
			}
		}

		private TextureSizes GradientSizes
		{
			get	
			{
				return gradientCreatorTool.gradientSizes;
			}
			set
			{
				gradientCreatorTool.gradientSizes = value;
			}
		}

		private FilterMode GradientFiltering
		{
			get
			{
				return gradientCreatorTool.gradientFiltering;
			}
			set
			{
				gradientCreatorTool.gradientFiltering = value;
			}
		}

		public GradientCreatorDrawer(GradientCreatorTool gradientCreatorTool, CommonStyles commonStyles)
		{
			this.gradientCreatorTool = gradientCreatorTool;
			this.commonStyles = commonStyles;
		}

		public void Draw()
		{
			GUILayout.Label("Color Gradient Creator", commonStyles.bigLabel);
			GUILayout.Space(20);
			GUILayout.Label("This feature can be used to create textures for the Color Ramp Effect", EditorStyles.boldLabel);

			EditorGUI.BeginChangeCheck();
			Grad = EditorGUILayout.GradientField("Color Gradient: ", Grad, GUILayout.Height(25), GUILayout.MaxWidth(CommonStyles.BUTTON_WIDTH));
			EditorGUILayout.BeginHorizontal();
			{
				GUILayout.Label("Texture Size:", GUILayout.MaxWidth(145));
				GradientSizes = (TextureSizes)EditorGUILayout.EnumPopup(GradientSizes, GUILayout.MaxWidth(200));
			}
			EditorGUILayout.EndHorizontal();
			EditorGUILayout.BeginHorizontal();
			{
				GUILayout.Label("New Textures Filtering: ", GUILayout.MaxWidth(145));
				GradientFiltering = (FilterMode)EditorGUILayout.EnumPopup(GradientFiltering, GUILayout.MaxWidth(200));
			}
			EditorGUILayout.EndHorizontal();
			
			bool gradientChanged = EditorGUI.EndChangeCheck();
			if (gradientChanged)
			{
				gradientCreatorTool.CreateGradientTexture();
			}

			GUILayout.Space(20);
			GUILayout.Label("Select the folder where new Color Gradient Textures will be saved", EditorStyles.boldLabel);

			GlobalConfiguration.instance.GradientSavePath = EditorUtils.DrawSelectorFolder(GlobalConfiguration.instance.GradientSavePath, /*AllIn13DShaderConfig.GRADIENT_SAVE_PATH_DEFAULT,*/ "Gradients");
			if (Directory.Exists(GlobalConfiguration.instance.GradientSavePath))
			{
				if (GUILayout.Button("Save Color Gradient Texture", GUILayout.MaxWidth(CommonStyles.BUTTON_WIDTH)))
				{
					EditorUtils.SaveTextureAsPNG(GlobalConfiguration.instance.GradientSavePath, "ColorGradient", "Gradient", GradientTex, GradientFiltering, 
						TextureImporterType.Default, TextureWrapMode.Clamp);
				}
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/GradientCreatorDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/GradientEditorDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 42eeae2ae0fe6674786f324f6b74294c
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class GradientEditorDrawer
	{
		private const float OFFSET = 5f;

		private Gradient gradient;
		private Rect lastRect;
		private Texture2D previewTex;
		private GradientCreatorTool gradientCreatorTool;

		private bool createGradientToggle;
		private bool textureSaved;
		private bool usingPreviewTex;
		private bool isModifyingExistingTexture;

		private Texture lastSavedTexture;
		private Gradient lastGradient;

		private GradientTexture gradientTextureAsset;

		private void RefreshReferences(Texture lastTexture)
		{
			if (gradient == null)
			{
				gradient = new Gradient();
			}

			if (previewTex == null)
			{
				previewTex = new Texture2D(128, 128);
			}

			if (gradientCreatorTool == null)
			{
				gradientCreatorTool = new GradientCreatorTool();
			}

			if (lastSavedTexture == null)
			{
				lastSavedTexture = lastTexture;
			}

			if (lastGradient == null)
			{
				lastGradient = new Gradient();
			}
		}

		private Texture RefreshGradientState(Texture texValue)
		{
			Texture res = texValue;

			if (createGradientToggle)
			{
				lastSavedTexture = texValue;

				isModifyingExistingTexture = EditorUtils.IsProjectAsset(lastSavedTexture);

				this.gradientTextureAsset = GradientCreatorTool.FindGradientTexureByTex(texValue);
				if (this.gradientTextureAsset != null)
				{
					GradientCreatorTool.CopyGradient(gradientTextureAsset.gradient, gradient);
				}
				else
				{
					if (isModifyingExistingTexture)
					{
						gradient = CreateGradientFromTexture(texValue);
					}
					else
					{
						gradient = new Gradient();
					}
				}

				previewTex = gradientCreatorTool.CreateGradientTexture(gradient);
				res = previewTex;
			}
			else
			{
				GradientCreatorTool.CopyGradient(gradient, lastGradient);
				previewTex = null;
				res = lastSavedTexture;
			}

			return res;
		}

		private Gradient CreateGradientFromTexture(Texture texSource)
		{
			int width = texSource.width;
			int height = texSource.height;

			RenderTexture renderTex = RenderTexture.GetTemporary(
				width,
				height,
				0,
				RenderTextureFormat.Default,
				RenderTextureReadWrite.Linear);

			Graphics.Blit(texSource, renderTex);
			RenderTexture previous = RenderTexture.active;
			RenderTexture.active = renderTex;
			Texture2D readableText = new Texture2D(texSource.width, texSource.height);
			readableText.ReadPixels(new Rect(0, 0, renderTex.width, renderTex.height), 0, 0);
			readableText.Apply();
			RenderTexture.active = previous;
			RenderTexture.ReleaseTemporary(renderTex);


			Gradient res = new Gradient();
			List<GradientColorKey> gradientColorKeys = new List<GradientColorKey>();

			int numSamples = 5;
			float step = (((float)width) / numSamples) / width;

			Vector2 sampleUV = Vector2.zero;
			for(int i = 0; i < numSamples; i++)
			{
				Color col = readableText.GetPixelBilinear(sampleUV.x, sampleUV.y);
				gradientColorKeys.Add(new GradientColorKey(col, sampleUV.x));

				sampleUV.x += step;
			}

			res.colorKeys = gradientColorKeys.ToArray();
			res.mode = GradientMode.Blend;

			return res;
		}

		public Texture Draw(Rect position, Texture gradientTexture)
		{
			RefreshReferences(gradientTexture);

			lastRect = position;

			Texture texValue = gradientTexture;

			EditorGUI.BeginChangeCheck();
			
			if (createGradientToggle && texValue == null)
			{
				texValue = lastSavedTexture;
				createGradientToggle = false;
			}

			texValue = DrawTextureField(texValue, 60f, "Color ramp texture");
			bool changes = EditorGUI.EndChangeCheck();
			if (changes)
			{
				createGradientToggle = false;
				lastSavedTexture = texValue;
			}


			EditorGUI.BeginChangeCheck();
			DrawCreateGradientToggle(15f, "Create Gradient");
			bool createGradientToggleChanged = EditorGUI.EndChangeCheck();
			if (createGradientToggleChanged)
			{
				texValue = RefreshGradientState(texValue);
			}

			EditorGUI.BeginChangeCheck();
			if (createGradientToggle)
			{
				texValue = DrawGradientField(40f, "Gradient", texValue);
			}

			EditorGUI.showMixedValue = false;
			bool gradientFieldChanged = EditorGUI.EndChangeCheck();
			if (gradientFieldChanged && !textureSaved)
			{
				previewTex = gradientCreatorTool.CreateGradientTexture(TextureSizes._256, FilterMode.Bilinear, gradient);
				texValue = previewTex;

				usingPreviewTex = true;
			}

			textureSaved = false;

			return texValue;
		}

		private Texture DrawTextureField(Texture tex, float height, string label)
		{
			Rect rect = new Rect(lastRect);
			rect.height = height;

			GUIStyle labelStyle = EditorStyles.label;
			labelStyle.alignment = TextAnchor.UpperLeft;

			Rect labelRect = new Rect(rect);
			labelRect.width = 200f;
			EditorGUI.LabelField(labelRect, new GUIContent(label), labelStyle);

			GUIStyle textureStyle = EditorStyles.objectField;
			textureStyle.alignment = TextAnchor.MiddleLeft;

			Rect textureRect = new Rect(rect);
			textureRect.width = height;
			textureRect.height = height;
			textureRect.x = rect.width - textureRect.width - 10f;

			Texture res = (Texture)EditorGUI.ObjectField(textureRect, tex, typeof(Texture), false);
			lastRect.y += height;

			return res;
		}

		private Texture DrawGradientField(float height, string label, Texture texValue)
		{
			Texture res = texValue;

			Rect rect = new Rect(lastRect);
			rect.height = height;
			rect.y += height * 0.5f;

			float createButtonWidth = 100f;

			GUIStyle labelStyle = EditorStyles.label;
			labelStyle.alignment = TextAnchor.UpperLeft;
			Rect labelRect = new Rect(rect);
			labelRect.width = 200f;
			EditorGUI.LabelField(labelRect, new GUIContent(label), labelStyle);

			GUIStyle textureStyle = EditorStyles.objectField;
			textureStyle.alignment = TextAnchor.MiddleLeft;

			Rect gradientAndButtonRect = new Rect(rect);
			gradientAndButtonRect.width = rect.width - labelRect.width;
			gradientAndButtonRect.height = rect.height;
			gradientAndButtonRect.x = labelRect.x + labelRect.width;

			Rect gradientRect = new Rect(gradientAndButtonRect);
			gradientRect.width = gradientAndButtonRect.width * 0.5f;
			gradientRect.height = rect.height * 0.5f;
			gradientRect.x = rect.x + rect.width - gradientRect.width - (createButtonWidth * 2f) - 10f;
			gradient = EditorGUI.GradientField(gradientRect, gradient);

			Rect createButtonRect = new Rect(gradientAndButtonRect);
			createButtonRect.width = createButtonWidth;
			createButtonRect.height = gradientRect.height;
			createButtonRect.x = gradientRect.x + gradientRect.width + 10f;

			Rect modifyButtonRect = new Rect(createButtonRect);
			modifyButtonRect.x = createButtonRect.x + createButtonRect.width + 10f;

			if (GUI.Button(createButtonRect, "Save Texture"))
			{
				res = ChangeTextureOnDisk(true);
			}

			EditorGUI.BeginDisabledGroup(!isModifyingExistingTexture || gradientTextureAsset == null);
			if (GUI.Button(modifyButtonRect, "Overwrite"))
			{
				res = ChangeTextureOnDisk(false);
			}
			EditorGUI.EndDisabledGroup();

			lastRect.y += height + OFFSET;

			if (usingPreviewTex && !textureSaved)
			{
				Rect helpBoxRect = new Rect(lastRect);
				helpBoxRect.height = 40f;
				EditorGUI.HelpBox(helpBoxRect, "Texture is not saved! Click on Save Texture to save it", MessageType.Warning);

				lastRect.y += helpBoxRect.height + OFFSET;
			}

			return res;
		}

		private Texture ChangeTextureOnDisk(bool createNew)
		{
			gradientCreatorTool.CreateGradientTexture(gradient);
			Texture savedTex = gradientCreatorTool.SaveGradientTexture(gradientTextureAsset, createNew);

			Texture res = savedTex;
			lastSavedTexture = savedTex;

			textureSaved = true;
			usingPreviewTex = false;
			createGradientToggle = false;

			gradientTextureAsset = null;

			return res;
		}

		private void DrawCreateGradientToggle(float height, string label)
		{
			Rect rect = new Rect(lastRect);
			rect.height = height;

			Rect toggleRect = new Rect(rect);

			createGradientToggle = EditorGUI.ToggleLeft(toggleRect, label, createGradientToggle);
			
			lastRect.y += height;
		}

		public float GetPropertyHeight()
		{
			float res = 80f;

			if (createGradientToggle)
			{
				res += 45f;
				if (usingPreviewTex)
				{
					res += 40f;
				}
			}

			return res;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/GradientEditorDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/NoiseCreatorDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f1d0e6ca131aebb45a4e398281fa7db3
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.IO;
using UnityEditor;
using UnityEngine;
using static AllIn13DShader.NoiseCreatorTool;

namespace AllIn13DShader
{
	public class NoiseCreatorDrawer
	{
		private NoiseCreatorTool noiseCreatorTool;
		private CommonStyles commonStyles;

		private NoiseCreatorValues Values
		{
			get
			{
				return noiseCreatorTool.values;
			}
		}

		public NoiseCreatorDrawer(NoiseCreatorTool noiseCreatorTool, CommonStyles commonStyles)
		{
			this.noiseCreatorTool = noiseCreatorTool;
			this.commonStyles = commonStyles;
		}

		public void Draw()
		{
			GUILayout.Label("Tileable Noise Creator", commonStyles.bigLabel);
			GUILayout.Space(20);

			EditorGUILayout.BeginHorizontal();
			{
				EditorGUILayout.BeginVertical(GUILayout.MaxWidth(550));
				{
					if (Values.noisePreview == null)
					{
						GUILayout.Label("*Change a property to start editing a Noise texture", EditorStyles.boldLabel);
					}

					EditorGUI.BeginChangeCheck();
					EditorGUILayout.BeginHorizontal();
					{
						GUILayout.Label("Noise Type:", GUILayout.MaxWidth(145));
						Values.noiseType = (NoiseTypes)EditorGUILayout.EnumPopup(Values.noiseType, GUILayout.MaxWidth(200));
					}
					EditorGUILayout.EndHorizontal();
					if (EditorGUI.EndChangeCheck())
					{
						noiseCreatorTool.NoiseSetMaterial();
						noiseCreatorTool.CheckCreationNoiseTextures();
						noiseCreatorTool.UpdateNoiseMatAndRender();
					}

					EditorGUI.BeginChangeCheck();
					if (Values.isFractalNoise)
					{
						EditorUtils.TextureEditorFloatParameter("Scale X", ref Values.noiseScaleX, 0.1f, 50f, 4f);
						if (!Values.noiseSquareScale) EditorUtils.TextureEditorFloatParameter("Scale Y", ref Values.noiseScaleY, 0.1f, 50f, 4f);
					}
					else
					{
						EditorUtils.TextureEditorFloatParameter("Scale X", ref Values.noiseScaleX, 0.1f, 50f, 10f);
						if (!Values.noiseSquareScale) EditorUtils.TextureEditorFloatParameter("Scale Y", ref Values.noiseScaleY, 0.1f, 50f, 10f);
					}
					Values.noiseSquareScale = EditorGUILayout.Toggle("Square Scale?", Values.noiseSquareScale, GUILayout.MaxWidth(200));
					if (Values.noiseSquareScale) Values.noiseScaleY = Values.noiseScaleX;
					if (Values.noiseType == NoiseTypes.Fractal) EditorUtils.TextureEditorFloatParameter("Fractal Amount", ref Values.noiseFractalAmount, 1f, 10f, 8f);
					else if (Values.noiseType == NoiseTypes.Perlin) EditorUtils.TextureEditorFloatParameter("Fractal Amount", ref Values.noiseFractalAmount, 1f, 10f, 1f);
					else if (Values.noiseType == NoiseTypes.Billow) EditorUtils.TextureEditorFloatParameter("Fractal Amount", ref Values.noiseFractalAmount, 1f, 10f, 4f);
					else EditorUtils.TextureEditorFloatParameter("Jitter", ref Values.noiseJitter, 0.0f, 2f, 1f);
					EditorUtils.TextureEditorFloatParameter("Contrast", ref Values.noiseContrast, 0.1f, 10f, 1f);
					EditorUtils.TextureEditorFloatParameter("Brightness", ref Values.noiseBrightness, -1f, 1f, 0f);
					EditorUtils.TextureEditorIntParameter("Random Seed", ref Values.noiseSeed, 0, 100, 0);
					Values.noiseInverted = EditorGUILayout.Toggle("Inverted?", Values.noiseInverted);

					if (EditorGUI.EndChangeCheck())
					{
						if (Values.noiseMaterial == null)
						{
							noiseCreatorTool.NoiseSetMaterial();
						}
						noiseCreatorTool.CheckCreationNoiseTextures();

						noiseCreatorTool.UpdateNoiseMatAndRender();
					}

					GUILayout.Space(20);
					EditorGUILayout.BeginHorizontal();
					{
						GUILayout.Label("Noise Size:", GUILayout.MaxWidth(145));
						Values.noiseSize = (TextureSizes)EditorGUILayout.EnumPopup(Values.noiseSize, GUILayout.MaxWidth(200));
					}
					EditorGUILayout.EndHorizontal();
					EditorGUILayout.BeginHorizontal();
					{
						GUILayout.Label("New Noise Filtering: ", GUILayout.MaxWidth(145));
						Values.noiseFiltering = (FilterMode)EditorGUILayout.EnumPopup(Values.noiseFiltering, GUILayout.MaxWidth(200));
					}
					EditorGUILayout.EndHorizontal();
				}
				EditorGUILayout.EndVertical();

				if (Values.noisePreview != null) GUILayout.Label(Values.noisePreview, GUILayout.MaxWidth(450), GUILayout.MaxHeight(450));
			}
			EditorGUILayout.EndHorizontal();

			
			GUILayout.Space(20);
			GUILayout.Label("Select the folder where new Noise Textures will be saved", EditorStyles.boldLabel);
			GlobalConfiguration.instance.NoiseSavePath = EditorUtils.DrawSelectorFolder(GlobalConfiguration.instance.NoiseSavePath, /*AllIn13DShaderConfig.NOISES_SAVE_PATH_DEFAULT,*/ "Noises");

			if (Directory.Exists(GlobalConfiguration.instance.NoiseSavePath) && Values.noisePreview != null)
			{
				if (GUILayout.Button("Save Noise Texture", GUILayout.MaxWidth(CommonStyles.BUTTON_WIDTH)))
				{
					noiseCreatorTool.CreateNoiseTex();
					EditorUtils.SaveTextureAsPNG(GlobalConfiguration.instance.NoiseSavePath, "Noise", "Noises", 
						Values.finalNoiseTex, Values.noiseFiltering, TextureImporterType.Default, TextureWrapMode.Clamp);
				}
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/NoiseCreatorDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/NoiseCreatorValues.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 14c147009aa5dae418a84b61107ada3c
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class NoiseCreatorValues
	{
		public Texture2D noisePreview = null;
		public Texture2D finalNoiseTex = null;

		public RenderTexture noiseRenderTarget = null;
		public Material noiseMaterial;

		public float noiseScaleX = 10f;
		public float noiseScaleY = 10f;
		public float noiseContrast = 1f;
		public float noiseBrightness = 0f;

		public float noiseFractalAmount = 1f;
		public float noiseJitter = 1f;
		public int noiseSeed = 0;

		public bool noiseSquareScale = false;
		public bool noiseInverted = false;
		public bool isFractalNoise = false;

		public NoiseCreatorTool.NoiseTypes noiseType;

		public TextureSizes noiseSize;
		public FilterMode noiseFiltering;

		public NoiseCreatorValues()
		{
			SetDefault();
		}

		public void SetDefault()
		{
			noisePreview = null;
			noiseRenderTarget = null;
			finalNoiseTex = null;

			noiseMaterial = null;
			noiseScaleX = 10f;
			noiseScaleY = 10f;
			noiseContrast = 1f;
			noiseBrightness = 0f;

			noiseFractalAmount = 1f;
			noiseJitter = 1f;
			noiseSeed = 0;

			noiseSquareScale = false;
			noiseInverted = false;
			isFractalNoise = false;

			noiseType = NoiseCreatorTool.NoiseTypes.Voronoi;

			noiseSize = TextureSizes._512;
			noiseFiltering = FilterMode.Bilinear;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/NoiseCreatorValues.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/NormalMapCreatorDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6304f118428d4744c8f82a134c469288
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System;
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class NormalMapCreatorDrawer
	{
		private NormalMapCreatorTool normalMapCreatorTool;
		private CommonStyles commonStyles;
		private Action repaintAction;


		private Texture2D TargetNormalImage
		{
			get
			{
				return normalMapCreatorTool.targetNormalImage;
			}
			set
			{
				normalMapCreatorTool.targetNormalImage = value;
			}
		}

		private float NormalStrength
		{
			get
			{
				return normalMapCreatorTool.normalStrength;
			}
			set
			{
				normalMapCreatorTool.normalStrength = value;
			}
		}

		private int NormalSmoothing
		{
			get
			{
				return normalMapCreatorTool.normalSmoothing;
			}
			set
			{
				normalMapCreatorTool.normalSmoothing = value;
			}
		}

		private int IsComputingNormals
		{
			get
			{
				return normalMapCreatorTool.isComputingNormals;
			}
			set
			{
				normalMapCreatorTool.isComputingNormals = value;
			}
		}

		public NormalMapCreatorDrawer(NormalMapCreatorTool normalMapCreatorTool, CommonStyles commonStyles, Action repaintAction)
		{
			this.normalMapCreatorTool = normalMapCreatorTool;
			this.commonStyles = commonStyles;
			this.repaintAction = repaintAction;
		}

		public void Draw()
		{
			GUILayout.Label("Normal/Distortion Map Creator", commonStyles.bigLabel);
			GUILayout.Space(20);

			GUILayout.Label("Select the folder where new Normal Maps will be saved when the Create Normal Map button of the asset component is pressed", EditorStyles.boldLabel);

			GlobalConfiguration.instance.NormalMapSavePath = EditorUtils.DrawSelectorFolder(GlobalConfiguration.instance.NormalMapSavePath, /*AllIn13DShaderConfig.NORMAL_MAP_SAVE_PATH_DEFAULT,*/ "Normal Maps Folder");

			GUILayout.Label("Assign a texture you want to create a normal map from. Choose the normal map settings and press the 'Create And Save Normal Map' button", EditorStyles.boldLabel);
			TargetNormalImage = (Texture2D)EditorGUILayout.ObjectField("Target Image", TargetNormalImage, typeof(Texture2D), false, GUILayout.MaxWidth(225));

			EditorGUILayout.BeginHorizontal();
			{
				GUILayout.Label("Normal Strength:", GUILayout.MaxWidth(150));
				NormalStrength = EditorGUILayout.Slider(NormalStrength, 1f, 20f, GUILayout.MaxWidth(400));
			}
			EditorGUILayout.EndHorizontal();

			EditorGUILayout.BeginHorizontal();
			{
				GUILayout.Label("Normal Smoothing:", GUILayout.MaxWidth(150));
				NormalSmoothing = EditorGUILayout.IntSlider(NormalSmoothing, 0, 3, GUILayout.MaxWidth(400));
			}
			EditorGUILayout.EndHorizontal();

			if (IsComputingNormals == 0)
			{
				if (TargetNormalImage != null)
				{
					if (GUILayout.Button("Create And Save Normal Map", GUILayout.MaxWidth(CommonStyles.BUTTON_WIDTH)))
					{
						IsComputingNormals = 1;
						return;
					}
				}
				else
				{
					GUILayout.Label("Add a Target Image to use this feature", EditorStyles.boldLabel);
				}
			}
			else
			{
				GUILayout.Label("Normal Map is currently being created, be patient", EditorStyles.boldLabel, GUILayout.Height(40));
				repaintAction();

				IsComputingNormals++;
				if(IsComputingNormals > 5)
				{
					EditorUtils.SetTextureReadWrite(AssetDatabase.GetAssetPath(TargetNormalImage), true);

					Texture2D normalMapToSave = normalMapCreatorTool.CreateNormalMap();
					EditorUtils.SaveTextureAsPNG(GlobalConfiguration.instance.NormalMapSavePath, "NormalMap", "Normal Map", normalMapToSave, FilterMode.Bilinear, TextureImporterType.NormalMap, TextureWrapMode.Repeat);

					IsComputingNormals = 0;
				}
			}

			GUILayout.Label("*This process will freeze the editor for some seconds, larger images will take longer", EditorStyles.boldLabel);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/NormalMapCreatorDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/TextureBlendingEffectDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 081c5e8bfd291a145abf082e4835e2b2
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class TextureBlendingEffectDrawer : AbstractEffectDrawer
	{
		private int mainTexPropertyIndex;
		private EffectProperty mainNormalEffectProperty;

		private EffectProperty effectPropBlendingSource;

		private EffectProperty effectPropTexBlendingMask;
		private EffectProperty effectPropBlendingMaskCutoffG;
		private EffectProperty effectPropBlendingMaskSmoothnessG;
		private EffectProperty effectPropBlendingMaskCutoffB;
		private EffectProperty effectPropBlendingMaskSmoothnessB;

		private EffectProperty effectPropBlendingMaskCutoffWhite;
		private EffectProperty effectPropBlendingMaskSmoothnessWhite;

		private EffectProperty effectPropBlendingMode;

		private EffectProperty effectPropBlendingTextureG;
		private EffectProperty effectPropBlendingTextureB;
		private EffectProperty effectPropBlendingTextureWhite;

		private EffectProperty effectPropBlendingNormalMapG;
		private EffectProperty effectPropBlendingNormalMapB;
		private EffectProperty effectPropBlendingNormalMapWhite;

		public TextureBlendingEffectDrawer(EffectProperty mainNormalMapEffectProperty, AllIn13DShaderInspectorReferences references, PropertiesConfig propertiesConfig) : base(references, propertiesConfig)
		{
			this.drawerID = Constants.TEXTURE_BLENDING_EFFECT_DRAWER_ID;

			mainTexPropertyIndex = FindPropertyIndex("_MainTex");
			this.mainNormalEffectProperty = mainNormalMapEffectProperty;

			this.effectConfig = propertiesConfig.FindEffectConfigByID("TEXTURE_BLENDING");

			this.effectPropBlendingSource = effectConfig.FindEffectPropertyByName("_TextureBlendingSource");

			this.effectPropTexBlendingMask = effectConfig.FindEffectPropertyByName("_TexBlendingMask");
			this.effectPropBlendingMaskCutoffG = effectConfig.FindEffectPropertyByName("_BlendingMaskCutoffG");
			this.effectPropBlendingMaskSmoothnessG = effectConfig.FindEffectPropertyByName("_BlendingMaskSmoothnessG");
			this.effectPropBlendingMaskCutoffB = effectConfig.FindEffectPropertyByName("_BlendingMaskCutoffB");
			this.effectPropBlendingMaskSmoothnessB = effectConfig.FindEffectPropertyByName("_BlendingMaskSmoothnessB");

			this.effectPropBlendingMaskCutoffWhite = effectConfig.FindEffectPropertyByName("_BlendingMaskCutoffWhite");
			this.effectPropBlendingMaskSmoothnessWhite = effectConfig.FindEffectPropertyByName("_BlendingMaskSmoothnessWhite");

			this.effectPropBlendingMode = effectConfig.FindEffectPropertyByName("_TextureBlendingMode");

			this.effectPropBlendingTextureG		= effectConfig.FindEffectPropertyByName("_BlendingTextureG");
			this.effectPropBlendingTextureB		= effectConfig.FindEffectPropertyByName("_BlendingTextureB");
			this.effectPropBlendingTextureWhite = effectConfig.FindEffectPropertyByName("_BlendingTextureWhite");

			this.effectPropBlendingNormalMapG		= effectConfig.FindEffectPropertyByName("_BlendingNormalMapG");
			this.effectPropBlendingNormalMapB		= effectConfig.FindEffectPropertyByName("_BlendingNormalMapB");
			this.effectPropBlendingNormalMapWhite	= effectConfig.FindEffectPropertyByName("_BlendingNormalMapWhite");
		}

		protected override void DrawProperties()
		{
			bool isRGBMode = references.targetMat.IsKeywordEnabled("_TEXTUREBLENDINGMODE_RGB");
			bool isBlendingSourceTexture = references.targetMat.IsKeywordEnabled("_TEXTUREBLENDINGSOURCE_TEXTURE");
			bool isNormalEnabled = references.targetMat.IsKeywordEnabled("_NORMAL_MAP_ON");

			DrawProperty(effectPropBlendingSource);
			if(IsEffectPropertyVisible(effectPropTexBlendingMask))
			{
				DrawProperty(effectPropTexBlendingMask);
			}


			DrawProperty(effectPropBlendingMode);

			GUILayout.Space(20f);

			MaterialProperty matPropertyMainNormalMap = references.matProperties[mainNormalEffectProperty.propertyIndex];
			if (isRGBMode)
			{
				EffectPropertyDrawer.DrawProperty(
					materialProperty: references.matProperties[mainTexPropertyIndex],
					labelPrefix: string.Empty,
					displayName: $"{references.matProperties[mainTexPropertyIndex].displayName} (R)",
					allowReset: true,
					references: references);

				if (isNormalEnabled)
				{
					EffectPropertyDrawer.DrawProperty(
						materialProperty: matPropertyMainNormalMap,
						labelPrefix: string.Empty,
						displayName: $"{matPropertyMainNormalMap.displayName} (R)",
						allowReset: true,
						references: references);
				}

				if (isBlendingSourceTexture)
				{
					GUILayout.Space(20f);
				}

				DrawProperty(effectPropBlendingTextureG);
				if (isNormalEnabled)
				{
					DrawProperty(effectPropBlendingNormalMapG);
				}

				if (isBlendingSourceTexture)
				{
					DrawProperty(effectPropBlendingMaskCutoffG);
					DrawProperty(effectPropBlendingMaskSmoothnessG);
					GUILayout.Space(20f);
				}

				DrawProperty(effectPropBlendingTextureB);
				if (isNormalEnabled)
				{
					DrawProperty(effectPropBlendingNormalMapB);
				}

				if (isBlendingSourceTexture)
				{
					DrawProperty(effectPropBlendingMaskCutoffB);
					DrawProperty(effectPropBlendingMaskSmoothnessB);
					GUILayout.Space(20f);
				}
			}
			else
			{
				EffectPropertyDrawer.DrawProperty(
					materialProperty: references.matProperties[mainTexPropertyIndex],
					labelPrefix: string.Empty,
					displayName: $"{references.matProperties[mainTexPropertyIndex].displayName} (Black)",
					allowReset: true,
					references: references);

				if (isNormalEnabled)
				{
					EffectPropertyDrawer.DrawProperty(
						materialProperty: matPropertyMainNormalMap,
						labelPrefix: string.Empty,
						displayName: $"{matPropertyMainNormalMap.displayName} (R)",
						allowReset: true,
						references: references);
				}

				DrawProperty(effectPropBlendingTextureWhite);
				if (isNormalEnabled)
				{
					DrawProperty(effectPropBlendingNormalMapWhite);
				}

				if (isBlendingSourceTexture)
				{
					DrawProperty(effectPropBlendingMaskCutoffWhite);
					DrawProperty(effectPropBlendingMaskSmoothnessWhite);
				}
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/TextureBlendingEffectDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/TextureEditorValuesDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d9909526746655a4a9be1aaef56a41b9
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class TextureEditorValuesDrawer
	{
		private TextureEditorTool textureEditorTool;


		private TextureEditorValues values
		{
			get
			{
				return textureEditorTool.values;
			}
		}

		private Texture2D editorTexInput
		{
			get
			{
				return textureEditorTool.editorTexInput;
			}
		}

		private Texture2D editorTex
		{
			get
			{
				return textureEditorTool.editorTex;
			}
		}

		private Texture2D cleanEditorTex
		{
			get
			{
				return textureEditorTool.cleanEditorTex;
			}
		}


		private const int BUTTON_WIDTH = 600;


		public void Setup(TextureEditorTool textureEditorTool)
		{
			this.textureEditorTool = textureEditorTool;
		}

		public void Draw()
		{
			EditorGUILayout.BeginHorizontal();

			if (!values.showOriginalImage)
			{
				GUILayout.Label(editorTex);
			}
			else
			{
				GUILayout.Label(cleanEditorTex);
			}

			EditorGUILayout.BeginVertical();

			EditorGUI.BeginChangeCheck();
			EditorUtils.TextureEditorColorParameter("Color Tint", ref values.editorColorTint, Color.white);
			EditorUtils.TextureEditorFloatParameter("Brightness", ref values.brightness, -1f, 5f);
			EditorUtils.TextureEditorFloatParameter("Contrast", ref values.contrast, 0.0f, 5.0f, 1f);
			EditorUtils.TextureEditorFloatParameter("Gamma", ref values.gamma, 0.0f, 10f, 1f);
			EditorUtils.TextureEditorFloatParameter("Exposure", ref values.exposure, -5f, 5f, 0f);
			EditorUtils.TextureEditorFloatParameter("Saturation", ref values.saturation, 0f, 5f, 1f);
			EditorUtils.TextureEditorFloatParameter("Hue", ref values.hue, 0f, 360f, 0f);

			EditorGUILayout.BeginHorizontal();
			{
				values.invert = EditorGUILayout.Toggle("Invert", values.invert, GUILayout.Width(253));
				values.greyscale = EditorGUILayout.Toggle("Greyscale", values.greyscale);
			}
			EditorGUILayout.EndHorizontal();

			EditorGUILayout.BeginHorizontal();
			{
				values.fullWhite = EditorGUILayout.Toggle("Fully white", values.fullWhite, GUILayout.Width(253));
				values.blackBackground = EditorGUILayout.Toggle("Black background", values.blackBackground);
			}
			EditorGUILayout.EndHorizontal();
			
			EditorGUILayout.BeginHorizontal();
			{
				values.alphaGreyscale = EditorGUILayout.Toggle("Greyscale is alpha", values.alphaGreyscale, GUILayout.Width(253));
				values.alphaIsOne = EditorGUILayout.Toggle("Alpha to 1", values.alphaIsOne);
			}
			EditorGUILayout.EndHorizontal();
			
			if (EditorGUI.EndChangeCheck())
			{
				textureEditorTool.RecalculateEditorTexture();
			}

			EditorGUILayout.Space();
			EditorGUILayout.BeginHorizontal();
			{
				if (GUILayout.Button("Rotate Left 90°", GUILayout.MaxWidth(210)))
				{
					textureEditorTool.RotateEditorTextureLeft();
				}

				if (GUILayout.Button("Rotate Right 90°", GUILayout.MaxWidth(210)))
				{
					for (int i = 0; i < 3; i++)
					{
						textureEditorTool.RotateEditorTextureLeft();
					}
				}
			}
			EditorGUILayout.EndHorizontal();

			EditorGUILayout.BeginHorizontal();
			{
				if (GUILayout.Button("Flip Horizontal", GUILayout.MaxWidth(210)))
				{
					textureEditorTool.FlipEditorTexture(true);
				}

				if (GUILayout.Button("Flip Vertical", GUILayout.MaxWidth(210)))
				{
					textureEditorTool.FlipEditorTexture(false);
				}
			}
			EditorGUILayout.EndHorizontal();

			EditorGUILayout.Space();
			if (!values.showOriginalImage)
			{
				if (GUILayout.Button("Press to show Original Image", GUILayout.MaxWidth(425)))
				{
					values.showOriginalImage = true;
				}
			}
			else
			{
				Color backgroundColor = GUI.backgroundColor;
				GUI.backgroundColor = Color.red;
				if (GUILayout.Button("Press to show Editor Image", GUILayout.MaxWidth(425)))
				{
					values.showOriginalImage = false;
				}
				GUI.backgroundColor = backgroundColor;
			}


			EditorGUILayout.EndVertical();
			EditorGUILayout.EndHorizontal();

			GUILayout.Label("*Preview is locked to 256px maximum (bigger textures are scaled down), but the image will be saved to its full resolution", EditorStyles.boldLabel);

			EditorUtils.DrawThinLine();
			EditorGUILayout.Space();
			EditorUtils.TextureEditorFloatParameter("Export Scale", ref values.exportScale, 0.01f, 2f, 1f);
			int currWidth = Mathf.ClosestPowerOfTwo((int)(editorTexInput.width * values.exportScale));
			int currHeight = Mathf.ClosestPowerOfTwo((int)(editorTexInput.height * values.exportScale));
			GUILayout.Label("Current export size is: " + currWidth + " x " + currHeight + " (size snaps to the closest power of 2)", EditorStyles.boldLabel);

			if (GUILayout.Button("Save Resulting Image as PNG file", GUILayout.MaxWidth(BUTTON_WIDTH)))
			{
				textureEditorTool.SaveAsPNG();
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/TextureEditorValuesDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/TriplanarEffectDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 580ede76f9fd8d844ab570643abe14cd
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class TriplanarEffectDrawer : AbstractEffectDrawer
	{
		private int mainTexPropertyIndex;
		private EffectProperty mainNormalMapProperty;
		
		public TriplanarEffectDrawer(EffectProperty mainNormalMapProperty, AllIn13DShaderInspectorReferences references, PropertiesConfig propertiesConfig) : base(references, propertiesConfig)
		{
			this.drawerID = Constants.TRIPLANAR_EFFECT_DRAWER_ID;
			this.mainNormalMapProperty = mainNormalMapProperty;

			mainTexPropertyIndex = FindPropertyIndex("_MainTex");
		}

		protected override void DrawProperties()
		{
			EffectPropertyDrawer.DrawProperty(references.matProperties[mainTexPropertyIndex], false, references);
			
			DrawProperty(effectConfig.effectProperties[0]);
			DrawProperty(effectConfig.effectProperties[1]);

			if (IsEffectPropertyVisible(mainNormalMapProperty))
			{
				EditorUtils.DrawLine(Color.grey, 1, 3);
				DrawProperty(mainNormalMapProperty, false);
				DrawProperty(effectConfig.effectProperties[2]);
			}

			EditorUtils.DrawLine(Color.grey, 1, 3);
			DrawProperty(effectConfig.effectProperties[3]);
			DrawProperty(effectConfig.effectProperties[4]);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/TriplanarEffectDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/Vector2Drawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 87a63d9b7f80f9f4bbbe3ae4dc5b0e2a
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class Vector2Drawer : MaterialPropertyDrawer
	{
		public override void OnGUI(Rect position, MaterialProperty prop, string label, MaterialEditor editor)
		{
			if (prop.propertyType != UnityEngine.Rendering.ShaderPropertyType.Vector)
			{
				EditorGUI.LabelField(position, label, "Vector3Drawer only works with Vector properties.");
				return;
			}

			EditorGUI.BeginChangeCheck();

			// Get current vector4 value
			Vector4 vec4Value = prop.vectorValue;

			// Convert to Vector2 for editing
			Vector2 vec2Value = new Vector2(vec4Value.x, vec4Value.y);

			// Create property field for Vector3
			vec2Value = EditorGUI.Vector2Field(position, label, vec2Value);

			if (EditorGUI.EndChangeCheck())
			{
				// Convert back to Vector4, preserving the w component
				prop.vectorValue = new Vector4(vec2Value.x, vec2Value.y, vec4Value.z, vec4Value.w);
			}
		}

		public override float GetPropertyHeight(MaterialProperty prop, string label, MaterialEditor editor)
		{
			return EditorGUIUtility.singleLineHeight;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/Vector2Drawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/Vector3Drawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: ba6a058864ddc094aa1e321cab78ebd2
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
    public class Vector3Drawer : MaterialPropertyDrawer
    {
        public override void OnGUI(Rect position, MaterialProperty prop, string label, MaterialEditor editor)
        {
            if(prop.propertyType != UnityEngine.Rendering.ShaderPropertyType.Vector) {
                EditorGUI.LabelField(position, label, "Vector3Drawer only works with Vector properties.");
                return;
            }

            EditorGUI.BeginChangeCheck();
        
            // Get current vector4 value
            Vector4 vec4Value = prop.vectorValue;
        
            // Convert to Vector3 for editing
            Vector3 vec3Value = new Vector3(vec4Value.x, vec4Value.y, vec4Value.z);
        
            // Create property field for Vector3
            vec3Value = EditorGUI.Vector3Field(position, label, vec3Value);
        
            if(EditorGUI.EndChangeCheck()) {
                // Convert back to Vector4, preserving the w component
                prop.vectorValue = new Vector4(vec3Value.x, vec3Value.y, vec3Value.z, vec4Value.w);
            }
        }
    
        public override float GetPropertyHeight(MaterialProperty prop, string label, MaterialEditor editor)
        {
            return EditorGUIUtility.singleLineHeight;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Drawers/Vector3Drawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/EditorUtils.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 70da5d91445c6164eb028b7ce14af0f5
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.IO;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;

namespace AllIn13DShader
{
	public static class EditorUtils
	{
		public static T FindAsset<T>(string assetName) where T : Object
		{
			T res = null;

			string[] guids = AssetDatabase.FindAssets($"{assetName} t:{typeof(T).Name}");

			if (guids.Length > 0)
			{
				string path = AssetDatabase.GUIDToAssetPath(guids[0]);
				res = AssetDatabase.LoadAssetAtPath<T>(path);
			}	
			
			return res;
		}

		public static T FindAssetByName<T>(string assetName) where T : Object
		{
			T res = null;

			string filter = $"t:{typeof(T)} {assetName}";
			string[] guids = AssetDatabase.FindAssets(filter);

			if (guids.Length > 0)
			{
				string path = AssetDatabase.GUIDToAssetPath(guids[0]);
				res = (T)AssetDatabase.LoadAssetAtPath(path, typeof(T));
			}

			return res;
		}

		public static void PingPath(string assetPath)
		{
			Object asset = AssetDatabase.LoadAssetAtPath(assetPath, typeof(Texture));
			if(asset != null)
			{
				EditorGUIUtility.PingObject(asset);
			}
		}

		public static void ShowNotification(string message)
		{
			SceneView.lastActiveSceneView.ShowNotification(new GUIContent(message));
		}

		public static void DrawThinLine()
		{
			DrawLine(Color.grey, 1, 3);
		}

		public static void DrawLine(Color color, int thickness = 2, int padding = 10)
		{
			Rect r = EditorGUILayout.GetControlRect(GUILayout.Height(padding + thickness));
			r.height = thickness;
			r.y += (padding / 2);
			r.x -= 2;
			r.width += 6;
			EditorGUI.DrawRect(r, color);
		}

		public static void SetTextureReadWrite(string assetPath, bool enable)
		{
			TextureImporter tImporter = AssetImporter.GetAtPath(assetPath) as TextureImporter;
			if (tImporter != null)
			{
				tImporter.isReadable = enable;
				tImporter.SaveAndReimport();
			}
		}

		public static string DrawSelectorFolder(string initialPath, /*string defaultPath,*/ string label)
		{
			DefaultAsset folderAsset = AssetDatabase.LoadAssetAtPath<DefaultAsset>(initialPath);
			folderAsset = (DefaultAsset)EditorGUILayout.ObjectField(label, folderAsset, typeof(DefaultAsset), false, GUILayout.MaxWidth(500));

			string pathCandidate = AssetDatabase.GetAssetPath(folderAsset);

			string res = initialPath;
			if (Directory.Exists(pathCandidate))
			{
				res = pathCandidate;
			}
			/*
			else
			{
				res = defaultPath;
			}
			*/

			return res;
		}

		public static Texture SaveTextureAsPNG(string folderPath, string fileName, string prefixNotification, Texture2D texture, 
			FilterMode filterMode, TextureImporterType importerType, TextureWrapMode wrapMode, 
			bool askForLocation = true, bool generateUniqueAssetPath = true)
		{
			Texture res = null;

			string fileNameWithExtension = fileName + ".png";
			string path = Path.Combine(folderPath, fileNameWithExtension);

			if (generateUniqueAssetPath)
			{
				path = AssetDatabase.GenerateUniqueAssetPath(path);
			}
			
			fileName = Path.GetFileNameWithoutExtension(path);
			
			if (askForLocation)
			{
				path = EditorUtility.SaveFilePanel("Save texture as PNG", folderPath, fileName, "png");
			}

			if (!string.IsNullOrEmpty(path))
			{
				byte[] pngData = texture.EncodeToPNG();
				if (pngData != null) File.WriteAllBytes(path, pngData);
				AssetDatabase.Refresh();

				if (path.IndexOf("Assets/") >= 0)
				{
					string subPath = path.Substring(path.IndexOf("Assets/"));
					TextureImporter importer = AssetImporter.GetAtPath(subPath) as TextureImporter;
					if (importer != null)
					{
						ShowNotification($"{prefixNotification} saved inside the project: " + subPath);
						
						importer.filterMode = filterMode;
						importer.textureType = importerType;
						importer.wrapMode = wrapMode;

						importer.SaveAndReimport();
						res = AssetDatabase.LoadAssetAtPath<Texture>(subPath);
						EditorGUIUtility.PingObject(res);
					}
				}
				else 
				{
					ShowNotification($"{prefixNotification} saved outside the project: " + path);
				}
			}

			return res;
		}

		public static Texture2D ScaleTexture(Texture2D source, int targetWidth, int targetHeight)
		{
			targetWidth = Mathf.ClosestPowerOfTwo(targetWidth);
			targetHeight = Mathf.ClosestPowerOfTwo(targetHeight);

			Texture2D result = new Texture2D(targetWidth, targetHeight, source.format, true);
			Color[] scaledPixels = result.GetPixels(0);
			float incX = ((float)1 / source.width) * ((float)source.width / targetWidth);
			float incY = ((float)1 / source.height) * ((float)source.height / targetHeight);
			for (int px = 0; px < scaledPixels.Length; px++) scaledPixels[px] = source.GetPixelBilinear(incX * ((float)px % targetWidth), incY * (float)Mathf.Floor(px / targetWidth));

			result.SetPixels(scaledPixels, 0);
			result.Apply();
			return result;
		}

		public static void TextureEditorFloatParameter(string parameterName, ref float parameter, float rangeMin = -100f, float rangeMax = 100f, float resetValue = 0f)
		{
			EditorGUILayout.BeginHorizontal();
			{
				parameter = EditorGUILayout.Slider(parameterName, parameter, rangeMin, rangeMax, GUILayout.MaxWidth(400));
				GUIContent resetButtonLabel = new GUIContent
				{
					text = "R",
					tooltip = "Resets to default value"
				};
				if (GUILayout.Button(resetButtonLabel, GUILayout.Width(20))) parameter = resetValue;
			}
			EditorGUILayout.EndHorizontal();
		}

		public static void TextureEditorColorParameter(string parameterName, ref Color parameter, Color resetValue)
		{
			EditorGUILayout.BeginHorizontal();
			{
				GUIContent colorLabel = new GUIContent
				{
					text = parameterName,
					tooltip = parameterName
				};
				parameter = EditorGUILayout.ColorField(colorLabel, parameter, true, true, true, GUILayout.MaxWidth(400));
				GUIContent resetButtonLabel = new GUIContent
				{
					text = "R",
					tooltip = "Resets to default value"
				};
				if (GUILayout.Button(resetButtonLabel, GUILayout.Width(20))) parameter = resetValue;
			}
			EditorGUILayout.EndHorizontal();
		}

		public static void TextureEditorIntParameter(string parameterName, ref int parameter, int rangeMin = -100, int rangeMax = 100, int resetValue = 0)
		{
			EditorGUILayout.BeginHorizontal();
			{
				parameter = EditorGUILayout.IntSlider(parameterName, parameter, rangeMin, rangeMax, GUILayout.MaxWidth(400));
				GUIContent resetButtonLabel = new GUIContent
				{
					text = "R",
					tooltip = "Resets to default value"
				};
				if (GUILayout.Button(resetButtonLabel, GUILayout.Width(20))) parameter = resetValue;
			}
			EditorGUILayout.EndHorizontal();
		}

		public static Shader FindShader(string shaderName)
		{
			string[] guids = AssetDatabase.FindAssets($"{shaderName} t:shader");
			foreach (string guid in guids)
			{
				string path = AssetDatabase.GUIDToAssetPath(guid);
				Shader shader = AssetDatabase.LoadAssetAtPath<Shader>(path);
				if (shader != null)
				{
					string fullShaderName = shader.name;
					string actualShaderName = fullShaderName.Substring(fullShaderName.LastIndexOf('/') + 1);
					if (actualShaderName == shaderName) return shader;
				}
			}
			return null;
		}

		public static void SetDirtyCurrentScene()
		{
			EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
		}

		public static bool IsProjectAsset(Object objectToCheck)
		{
			bool res = false;

			if(objectToCheck != null)
			{
				res = AssetDatabase.Contains(objectToCheck);
			}
			return res;
		}

		public static int GetNumLines(string input)
		{
			int res = input.Split("\n").Length;
			return res;
		}

		public static bool IsAllIn13DShader(string shaderName)
		{
			bool res = false;

			for (int i = 0; i < Constants.SHADERS_NAMES.Length; i++)
			{
				res = res || shaderName.Contains(Constants.SHADERS_NAMES[i]);
			}

			return res;
		}

		public static bool IsAllIn13DShader(Shader shader)
		{
			return IsAllIn13DShader(shader.name);
		}

		public static Color GetRandomColor()
		{
			Color res = new Color(Random.value, Random.value, Random.value, 1.0f);
			return res;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/EditorUtils.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/EffectAttributeData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b36b498226214d04991027c45110f464
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
namespace AllIn13DShader
{
	public struct EffectAttributeData
	{
		public string effectID;
		public string groupID;
		public string drawerID;
		public string incompatibleWithEffectID;
		public string dependentEffectID;
		public bool docEnabled;
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/EffectAttributeData.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/EffectConfigType.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7dc13376fd758c949b917e33c0e17b0d
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
namespace AllIn13DShader
{
	public enum EffectConfigType
	{
		EFFECT_TOGGLE = 0,
		EFFECT_ENUM = 1,
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/EffectConfigType.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/EffectGroup.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e6e1909f56e3b3540a34f422ffa46b41
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.Collections.Generic;
using UnityEditor;

namespace AllIn13DShader
{
	[System.Serializable]
	public class EffectGroup
	{
		public EffectGroupGlobalConfig effectGroupConfig;
		public AllIn13DEffectConfig[] effects;

		public string GroupID
		{
			get
			{
				return effectGroupConfig.groupID;
			}
		}

		public string DisplayName
		{
			get
			{
				return effectGroupConfig.displayName;
			}
		}

		public EffectGroup(EffectGroupGlobalConfig effectGroupConfig)
		{
			this.effectGroupConfig = effectGroupConfig;
			this.effects = new AllIn13DEffectConfig[0];
		}

		public void AddEffect(AllIn13DEffectConfig effect)
		{
			ArrayUtility.Add(ref effects, effect);
		}

		public AllIn13DEffectConfig FindEffectByID(string effectID)
		{
			AllIn13DEffectConfig res = null;

			for (int i = 0; i < effects.Length; i++)
			{
				if (effects[i].effectName == effectID)
				{
					res = effects[i];
					break;
				}
			}

			return res;
		}

		public List<EffectProperty> GetEffectPropertyFlatList()
		{
			List<EffectProperty> res = new List<EffectProperty>();

			for(int i = 0; i < effects.Length; i++)
			{
				res.AddRange(effects[i].effectProperties);
			}

			return res;
		}

		public int FindEffectIndexByID(string effectID)
		{
			int res = -1;

			for(int i = 0; i < effects.Length; i++)
			{
				if (effects[i].effectName == effectID)
				{
					res = i;
					break;
				}
			}

			return res;
		}

		public string[] GetEffectsNames()
		{
			string[] res = new string[effects.Length];

			for(int i = 0; i < effects.Length; i++)
			{
				res[i] = effects[i].displayName;
			}

			return res;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/EffectGroup.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/EffectGroupGlobalConfig.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6b755efcb87425049878cf9532c736c7
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class EffectGroupGlobalConfig : ScriptableObject
	{
		public string groupID;
		public string displayName;
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/EffectGroupGlobalConfig.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/EffectGroupGlobalConfigCollection.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 5d4677818a6699f4c951378b8bbde688
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class EffectGroupGlobalConfigCollection : ScriptableObject
	{
		public EffectGroupGlobalConfig[] effectGroupGlobalConfigs;
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/EffectGroupGlobalConfigCollection.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/EffectKeywordData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 545a325a652091c47bffe78f54e5cfea
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
namespace AllIn13DShader
{
	[System.Serializable]
	public struct EffectKeywordData
	{
		public string keyword;
		public string displayName;

		public EffectKeywordData(string keyword, string displayName)
		{
			this.keyword = keyword;
			this.displayName = displayName;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/EffectKeywordData.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/EffectProperty.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1774734eeb408d648a13a453aae3cdbf
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.Collections.Generic;
using UnityEngine;

namespace AllIn13DShader
{
	[System.Serializable]
	public class EffectProperty
	{
		[SerializeReference] public AllIn13DEffectConfig parentEffect;

		public int propertyIndex;
		public string propertyName;
		public string displayName;
		
		public List<string> keywords;
		public List<string> incompatibleKeywords;
		public List<string> propertyKeywords;

		public KeywordsOp keywordsOp;
		public bool allowReset;

		public EffectProperty(AllIn13DEffectConfig parentEffect, int propertyIndex, string propertyName, string displayName, KeywordsOp keywordsOp, bool allowReset)
		{
			this.parentEffect = parentEffect;

			this.keywords = new List<string>();
			this.incompatibleKeywords = new List<string>();
			this.propertyKeywords = new List<string>();

			this.propertyIndex = propertyIndex;
			this.propertyName = propertyName;
			this.displayName = displayName;

			this.keywordsOp = keywordsOp;
			this.allowReset = allowReset;
		}

		public void AddKeyword(string keyword)
		{
			this.keywords.Add(keyword);
		}

		public void AddIncompatibleKeyword(string keyword)
		{
			this.incompatibleKeywords.Add(keyword);
		}

		public void AddPropertyKeywords(List<string> propertyKeywordsToAdd)
		{
			for(int i = 0; i < propertyKeywordsToAdd.Count; i++)
			{
				this.propertyKeywords.Add(propertyKeywordsToAdd[i]);
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/EffectProperty.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/EffectPropertyAttributeData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b2ec6620d1aff1644a581743ac174c7d
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.Collections.Generic;

namespace AllIn13DShader
{
	public class EffectPropertyAttributeData
	{
		public string parentEffectID;
		public List<string> keywords;
		public List<string> incompatibleWithKws;
		public List<string> propertyKeywords;
		public bool allowReset;
		public KeywordsOp keywordsOp;

		public EffectPropertyAttributeData()
		{
			parentEffectID = string.Empty;
			keywords = new List<string>();
			incompatibleWithKws = new List<string>();
			propertyKeywords = new List<string>();
			allowReset = true;
			keywordsOp = KeywordsOp.OR;
		}

		public void AddKeyword(string keyword)
		{
			this.keywords.Add(keyword);
		}

		public void AddIncompatibleKeyword(string keyword)
		{
			this.incompatibleWithKws.Add(keyword);
		}

		public void AddPropertyKeyword(string propertyKeyword)
		{
			this.propertyKeywords.Add(propertyKeyword);
		}

		public void AddPropertyKeywords(string[] propertyKeywords)
		{
			for(int i = 0; i < propertyKeywords.Length; i++)
			{
				AddPropertyKeyword(propertyKeywords[i].Trim());
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/EffectPropertyAttributeData.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/EffectsExtraData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 32438765f2955064bae29bed18ec5263
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.Linq;
using UnityEngine;
namespace AllIn13DShader
{
	public class EffectsExtraData : ScriptableObject
	{
		[System.Serializable]
		public class ExtraData
		{
			public string effectID;
			public string docURL;
			public MessageByKeywords[] customMessages;
		}

		[System.Serializable]
		public class MessageByKeywords
		{
			[TextArea]public string message;
			public string[] keywords;

			public bool IsMessageEnabled(Material mat)
			{
				bool res = false;

				if(keywords.Length == 0)
				{
					res = true;
				}
				else
				{
					for (int i = 0; i < keywords.Length; i++)
					{
						if (mat.shaderKeywords.Contains(keywords[i]))
						{
							res = true;
							break;
						}
					}
				}

				return res;
			}
		}

		public ExtraData[] effectsExtraData;

		public ExtraData GetExtraDataByEffectID(string effectID)
		{
			ExtraData res = null;

			for(int i = 0; i < effectsExtraData.Length; i++)
			{
				if (effectsExtraData[i].effectID == effectID)
				{
					res = effectsExtraData[i];
					break;
				}
			}

			return res;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/EffectsExtraData.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/GlobalConfiguration.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 592122c0ab3d6c04d85891bcd2f332bc
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.IO;
using UnityEditor;
using UnityEditorInternal;
using UnityEngine;

namespace AllIn13DShader
{
	public class GlobalConfiguration : ScriptableObject
	{
		private static GlobalConfiguration _instance;
		public static GlobalConfiguration instance
		{
			get
			{
				if(_instance == null)
				{
					_instance = EditorUtils.FindAsset<GlobalConfiguration>("GlobalConfiguration");
				}

				return _instance;
			}
		}


		public enum ProjectType
		{
			[InspectorName("Toon")] TOON = 0,
			[InspectorName("Standard Basic")]STANDARD_BASIC = 1,
			[InspectorName("Standard PBR")]STANDARD_PBR = 2,
			[InspectorName("AllIn13DShader Look")] ALLIN13DSHADERLOOK = 4,
			[InspectorName("Custom")] CUSTOM = 3,
		}
		
		//Project type and default materials
		public ProjectType projectType;

		public Material standardBasicMaterial;
		public Material standardPBRMaterial;
		public Material toonMaterial;
		public Material allIn13dDShaderLookMaterial;

		public Material defaultPreset;

		//Default Relative Paths
		public static string EXPORT_PARENT_FOLDER_RELATIVE = "Export";

		public static string MATERIAL_SAVE_FOLDER_NAME = "Materials";
		public static string RENDER_IMAGE_SAVE_FOLDER_NAME = "Images";
		public static string NORMAL_MAP_SAVE_FOLDER_NAME = "Normal Maps";
		public static string GRADIENT_SAVE_FOLDER_NAME = "Gradients";
		public static string ATLASES_SAVE_FOLDER_NAME = "Atlases";
		public static string NOISES_SAVE_FOLDER_NAME = "Noises";

		public static string MATERIAL_SAVE_RELATIVE_PATH_DEFAULT = "Export/Materials";
		public static string RENDER_IMAGE_SAVE_RELATIVE_PATH_DEFAULT = "Export/Images";
		public static string NORMAL_MAP_SAVE_RELATIVE_PATH_DEFAULT = "Export/Normal Maps";
		public static string GRADIENT_SAVE_RELATIVE_PATH_DEFAULT = "Export/Gradients";
		public static string ATLASES_SAVE_RELATIVE_PATH_DEFAULT = "Export/Atlases";
		public static string NOISES_SAVE_RELATIVE_PATH_DEFAULT = "Export/Noises";


		////Default Fullt Paths
		//public static string MATERIAL_SAVE_PATH_DEFAULT = Path.Combine(RootPluginPath, MATERIAL_SAVE_RELATIVE_PATH_DEFAULT);
		//public static string RENDER_IMAGE_SAVE_PATH_DEFAULT = Path.Combine(RootPluginPath, RENDER_IMAGE_SAVE_RELATIVE_PATH_DEFAULT);
		//public static string NORMAL_MAP_SAVE_PATH_DEFAULT = Path.Combine(RootPluginPath, NORMAL_MAP_SAVE_RELATIVE_PATH_DEFAULT);
		//public static string GRADIENT_SAVE_PATH_DEFAULT = Path.Combine(RootPluginPath, GRADIENT_SAVE_RELATIVE_PATH_DEFAULT);
		//public static string ATLASES_SAVE_PATH_DEFAULT = Path.Combine(RootPluginPath, ATLASES_SAVE_RELATIVE_PATH_DEFAULT);
		//public static string NOISES_SAVE_PATH_DEFAULT = Path.Combine(RootPluginPath, NOISES_SAVE_RELATIVE_PATH_DEFAULT);

		//Default Root Plugin Path
		public const string ROOT_PLUGIN_FOLDER_DEFAULT = "Assets/Plugins/AllIn13DShader";



		//Paths
		[SerializeField] private string rootPluginPath;
		[SerializeField] private string materialSavePath;
		[SerializeField] private string renderImageSavePath;
		[SerializeField] private string normalMapSavePath;
		[SerializeField] private string gradientSavePath;
		[SerializeField] private string atlasesSavePath;
		[SerializeField] private string noiseSavePath;

		//Render Image Scale
		[SerializeField] private float renderImageScale;

		//URP Configured first time
		[SerializeField] private bool urpConfiguredFirstTime;

		public string RootPluginPath
		{
			get
			{
				return rootPluginPath;
			}
			set
			{
				rootPluginPath = value;
				EditorUtility.SetDirty(this);
			}
		}

		public string MaterialSavePath
		{
			get
			{
				return materialSavePath;
			}
			set
			{
				materialSavePath = value;
				EditorUtility.SetDirty(this);
			}
		}

		public string RenderImageSavePath
		{
			get
			{
				return renderImageSavePath;
			}
			set
			{
				renderImageSavePath = value;
				EditorUtility.SetDirty(this);
			}
		}

		public string NormalMapSavePath
		{
			get
			{
				return normalMapSavePath;
			}
			set
			{
				normalMapSavePath = value;
				EditorUtility.SetDirty(this);
			}
		}

		public string GradientSavePath
		{
			get
			{
				return gradientSavePath;
			}
			set
			{
				gradientSavePath = value;
				EditorUtility.SetDirty(this);
			}
		}

		public string AtlasesSavePath
		{
			get
			{
				return atlasesSavePath;
			}
			set
			{
				atlasesSavePath = value;
				EditorUtility.SetDirty(this);
			}
		}

		public string NoiseSavePath
		{
			get
			{
				return noiseSavePath;
			}
			set
			{
				noiseSavePath = value;
				EditorUtility.SetDirty(this);
			}
		}

		public float RenderImageScale
		{
			get
			{
				return renderImageScale;
			}
			set
			{
				renderImageScale = value;
				EditorUtility.SetDirty(this);
			}
		}

		public bool URPConfiguredFirstTime
		{
			get
			{
				return urpConfiguredFirstTime;
			}
			set
			{
				urpConfiguredFirstTime = value;
				EditorUtility.SetDirty(this);
			}
		}

		public void Init()
		{
			rootPluginPath		= InitPath(rootPluginPath, ROOT_PLUGIN_FOLDER_DEFAULT, true);
			materialSavePath	= InitPath(materialSavePath, MATERIAL_SAVE_RELATIVE_PATH_DEFAULT);
			renderImageSavePath = InitPath(renderImageSavePath, RENDER_IMAGE_SAVE_RELATIVE_PATH_DEFAULT);
			normalMapSavePath	= InitPath(normalMapSavePath, NORMAL_MAP_SAVE_RELATIVE_PATH_DEFAULT);
			gradientSavePath	= InitPath(gradientSavePath, GRADIENT_SAVE_RELATIVE_PATH_DEFAULT);
			atlasesSavePath		= InitPath(atlasesSavePath, ATLASES_SAVE_RELATIVE_PATH_DEFAULT);
			noiseSavePath		= InitPath(noiseSavePath, NOISES_SAVE_RELATIVE_PATH_DEFAULT);

			CreateDefaultExportFoldersIfNotExist();
		}

		public string InitPath(string path, string defaultValue, bool isRoot = false)
		{
			string res = path;
			if (!AssetDatabase.IsValidFolder(res))
			{
				string defaultPath = defaultValue;
				if (!isRoot)
				{
					defaultPath = Path.Combine(rootPluginPath, defaultValue);
				}
				res = defaultPath;

				EditorUtility.SetDirty(this);
			}

			return res;
		}

		public void CreateDefaultExportFoldersIfNotExist()
		{
			string parentExportAbsoluteFolderPath = Path.Combine(rootPluginPath, EXPORT_PARENT_FOLDER_RELATIVE);
			CreateFolderIfNotExist(parentExportAbsoluteFolderPath, rootPluginPath, EXPORT_PARENT_FOLDER_RELATIVE);

			CreateFolderIfNotExist(materialSavePath, parentExportAbsoluteFolderPath, MATERIAL_SAVE_FOLDER_NAME);
			CreateFolderIfNotExist(renderImageSavePath, parentExportAbsoluteFolderPath, RENDER_IMAGE_SAVE_FOLDER_NAME);
			CreateFolderIfNotExist(normalMapSavePath, parentExportAbsoluteFolderPath, NORMAL_MAP_SAVE_FOLDER_NAME);
			CreateFolderIfNotExist(gradientSavePath, parentExportAbsoluteFolderPath, GRADIENT_SAVE_FOLDER_NAME);
			CreateFolderIfNotExist(atlasesSavePath, parentExportAbsoluteFolderPath, ATLASES_SAVE_FOLDER_NAME);
			CreateFolderIfNotExist(noiseSavePath, parentExportAbsoluteFolderPath, NOISES_SAVE_FOLDER_NAME);
		}

		private void CreateFolderIfNotExist(string absoluteFolderPath, string parentFolder, string relativePath)
		{
			if (!AssetDatabase.IsValidFolder(absoluteFolderPath))
			{
				AssetDatabase.CreateFolder(parentFolder, relativePath);
			}

			AssetDatabase.Refresh();
		}

		public void RefreshDefaultMaterial()
		{
			switch (projectType)
			{
				case ProjectType.STANDARD_BASIC:
					this.defaultPreset = standardBasicMaterial;
					break;
				case ProjectType.STANDARD_PBR:
					this.defaultPreset = standardPBRMaterial;
					break;
				case ProjectType.TOON:
					this.defaultPreset = toonMaterial;
					break;
				case ProjectType.ALLIN13DSHADERLOOK:
					this.defaultPreset = allIn13dDShaderLookMaterial;
					break;
			}
		}

		public void RootFolderChanged(string oldRootFolder)
		{
			MaterialSavePath	= UpdateRootFolders(oldRootFolder, MaterialSavePath, MATERIAL_SAVE_RELATIVE_PATH_DEFAULT);
			RenderImageSavePath = UpdateRootFolders(oldRootFolder, RenderImageSavePath, RENDER_IMAGE_SAVE_RELATIVE_PATH_DEFAULT);
			NormalMapSavePath	= UpdateRootFolders(oldRootFolder, NormalMapSavePath, NORMAL_MAP_SAVE_RELATIVE_PATH_DEFAULT);
			GradientSavePath	= UpdateRootFolders(oldRootFolder, GradientSavePath, GRADIENT_SAVE_RELATIVE_PATH_DEFAULT);
			AtlasesSavePath		= UpdateRootFolders(oldRootFolder, AtlasesSavePath, ATLASES_SAVE_RELATIVE_PATH_DEFAULT);
			NoiseSavePath		= UpdateRootFolders(oldRootFolder, NoiseSavePath, NOISES_SAVE_RELATIVE_PATH_DEFAULT);
		}

		private string UpdateRootFolders(string oldRootFolder, string pathToCheck, string relativePath)
		{
			string res = pathToCheck;

			string pathToCheckFull = Path.GetFullPath(pathToCheck);
			string pathWithOldRootFull = Path.GetFullPath(Path.Combine(oldRootFolder, relativePath)); 

			if (pathToCheckFull == pathWithOldRootFull)
			{
				res = Path.Combine(RootPluginPath, relativePath);
			}

			return res;
		}

		public static void CheckRootFolder()
		{
			string newRootFolder = GetRootPluginPath();

			if (newRootFolder != instance.RootPluginPath)
			{
				string oldRootFolder = instance.RootPluginPath;
				instance.RootPluginPath = newRootFolder;
				instance.RootFolderChanged(oldRootFolder);
			}
		}

		private static string GetRootPluginPath()
		{
			Object mainAssemblyAsset = EditorUtils.FindAsset<AssemblyDefinitionAsset>("AllIn13DShaderAssemebly");
			string assetPath = AssetDatabase.GetAssetPath(mainAssemblyAsset);

			string res = Path.GetDirectoryName(assetPath);
			return res;
		}

		public void Save()
		{
			EditorUtility.SetDirty(this);
			AssetDatabase.SaveAssetIfDirty(this);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/GlobalConfiguration.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/GradientTexture.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: cb204018ddc8dbc43a4340c074e1a919
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class GradientTexture : ScriptableObject
	{
		public Texture texture;
		public Gradient gradient;
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/GradientTexture.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/KeywordsOp.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 971b7074914259f44a376305157e0822
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
namespace AllIn13DShader
{
	public enum KeywordsOp
	{
		OR = 0,
		AND = 1,
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/KeywordsOp.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialConverter/Scripts/ConversionConfig.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 466e422414ab2d84fa4f40d216c7e612
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class ConversionConfig : ScriptableObject
	{
		public ConversionProperty[] conversionProperties;
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialConverter/Scripts/ConversionConfig.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialConverter/Scripts/ConversionProperty.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 95c835d611027ef4e8f42f58386c1d3f
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class ConversionProperty : ScriptableObject
	{
		public ConversionPropertyType propertyType;
		public string propertyName;
		
		[Header("Effect")]
		public string belongingToEffect;
		public bool requiredProperty;

		[Header("Alternative Names")]
		public string[] alternativeNames;
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialConverter/Scripts/ConversionProperty.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialConverter/Scripts/ConversionPropertyType.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f4436880cfef3ea4bab5b36df4eb5345
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
namespace AllIn13DShader
{
	public enum ConversionPropertyType
	{
		FLOAT,
		TEXTURE,
		COLOR,
		VECTOR,
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialConverter/Scripts/ConversionPropertyType.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialConverter/Scripts/ConverterGeneral.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: fe8d92d4b6d87fd4892ac9b7eaa2bd37
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System;
using UnityEngine;
using UnityEngine.Rendering;

namespace AllIn13DShader
{
	public class ConverterGeneral
	{
		protected Material from;
		protected Material target;

		protected ConversionConfig conversionConfig;
		protected PropertiesConfigCollection propertiesConfigCollection;
		protected PropertiesConfig propertiesConfig;

		public virtual void ApplyConversion(Material from, Material target)
		{
			this.from = from;
			this.target = target;

			this.conversionConfig = EditorUtils.FindAssetByName<ConversionConfig>("ConversionConfig");
			this.propertiesConfigCollection = EditorUtils.FindAssetByName<PropertiesConfigCollection>("PropertiesConfigCollection");
			this.propertiesConfig = propertiesConfigCollection.FindPropertiesConfigByShader(target.shader);

			for (int i = 0; i < conversionConfig.conversionProperties.Length; i++)
			{
				ConversionProperty conversionProperty = conversionConfig.conversionProperties[i];

				bool propertiveActive = false;
				ApplyConversionProperty(conversionProperty, from, target, ref propertiveActive);

				if (!string.IsNullOrEmpty(conversionProperty.belongingToEffect) && conversionProperty.requiredProperty && propertiveActive)
				{
					AllIn13DEffectConfig effectConfig = propertiesConfig.FindEffectConfigByID(conversionProperty.belongingToEffect);
					EnableEffect(effectConfig);
				}
			}

			target.renderQueue = from.renderQueue;
		}

		protected void SetEnableEffect(string effectID, bool enabled)
		{
			AllIn13DEffectConfig effectConfig = propertiesConfig.FindEffectConfigByID(effectID);

			if (enabled)
			{
				EnableEffect(effectConfig);
			}
			else
			{
				DisableEffect(effectConfig);
			}
		}

		protected void EnableEffect(AllIn13DEffectConfig effectConfig)
		{
			if (effectConfig.keywords.Count == 1)
			{
				target.EnableKeyword(effectConfig.keywords[0].keyword);
				target.SetFloat(effectConfig.keywordPropertyName, 1f);
			}
		}

		protected void DisableEffect(string effectID)
		{
			AllIn13DEffectConfig effectConfig = propertiesConfig.FindEffectConfigByID(effectID);
			DisableEffect(effectConfig);
		}

		protected void DisableEffect(AllIn13DEffectConfig effectConfig)
		{
			for (int i = 0; i < effectConfig.keywords.Count; i++)
			{
				target.DisableKeyword(effectConfig.keywords[i].keyword);
			}

			target.SetFloat(effectConfig.keywordPropertyName, 0f);
		}

		protected void EnablePBR()
		{
			AllIn13DEffectConfig shadingModelEffect = propertiesConfig.FindEffectConfigByID("SHADINGMODEL");

			DisableEffect(shadingModelEffect);

			string pbrKeyword = shadingModelEffect.keywords[1].keyword;

			target.EnableKeyword(pbrKeyword);
			target.SetFloat("_ShadingModel", 1.0f);
		}

		protected void EnableLightModelClassic()
		{
			AllIn13DEffectConfig lightModelEffect = propertiesConfig.FindEffectConfigByID("LIGHTMODEL");

			DisableEffect(lightModelEffect);

			string lightModelClassicKeyword = lightModelEffect.keywords[1].keyword;

			target.EnableKeyword(lightModelClassicKeyword);
			target.SetFloat(lightModelEffect.keywordPropertyName, 1.0f);
		}

		protected void EnableSpecularClassic()
		{
			AllIn13DEffectConfig specularModelEffect = propertiesConfig.FindEffectConfigByID("SPECULARMODEL");

			DisableEffect(specularModelEffect);

			string specularModelClassicKeyword = specularModelEffect.keywords[1].keyword;

			target.EnableKeyword(specularModelClassicKeyword);
			target.SetFloat(specularModelEffect.keywordPropertyName, 1.0f);
		}

		protected void SetBlendSrc(BlendMode blendMode)
		{
			target.SetInt("_BlendSrc", (int)blendMode);
		}

		protected void SetBlendDst(BlendMode blendMode)
		{
			target.SetInt("_BlendDst", (int)blendMode);
		}

		protected void SetAlphaPreset()
		{
			target.SetFloat("_RenderPreset", 2);
		}

		protected void SetOpaquePreset()
		{
			target.SetFloat("_RenderPreset", 1);
		}

		protected void ApplyConversionProperty(ConversionProperty conversionProperty, Material from, Material target, ref bool propertyActive)
		{
			string propertyNameFrom = string.Empty;
			string propertyNameTarget = conversionProperty.propertyName;

			if (from.HasProperty(conversionProperty.propertyName))
			{
				propertyNameFrom = conversionProperty.propertyName;
			}
			else
			{
				for (int i = 0; i < conversionProperty.alternativeNames.Length; i++)
				{
					if (from.HasProperty(conversionProperty.alternativeNames[i]))
					{
						propertyNameFrom = conversionProperty.alternativeNames[i];
						break;
					}
				}
			}

			if (!string.IsNullOrEmpty(propertyNameFrom))
			{
				switch (conversionProperty.propertyType)
				{
					case ConversionPropertyType.TEXTURE:
						Texture texValue = from.GetTexture(propertyNameFrom);
						Vector2 texOffset = from.GetTextureOffset(propertyNameFrom);
						Vector2 texScale = from.GetTextureScale(propertyNameFrom);

						target.SetTexture(propertyNameTarget, texValue);

						target.SetTextureOffset(propertyNameTarget, texOffset);
						target.SetTextureScale(propertyNameTarget, texScale);
						
						propertyActive = texValue != null;

						break;
					case ConversionPropertyType.FLOAT:
						float floatValue = from.GetFloat(propertyNameFrom);
						target.SetFloat(propertyNameTarget, floatValue);

						propertyActive = true;

						break;
					case ConversionPropertyType.COLOR:
						Color colorValue = from.GetColor(propertyNameFrom);
						target.SetColor(propertyNameTarget, colorValue);

						propertyActive = true;

						break;
					case ConversionPropertyType.VECTOR:
						Vector4 vectorValue = from.GetVector(propertyNameFrom);
						target.SetVector(propertyNameTarget, vectorValue);

						propertyActive = true;

						break;
				}
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialConverter/Scripts/ConverterGeneral.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialConverter/Scripts/ConverterStandard.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e0584ca1f69659048b2a800ed4d52cd8
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEngine;
using UnityEngine.Rendering;

namespace AllIn13DShader
{
	public class ConverterStandard : ConverterGeneral
	{
		public override void ApplyConversion(Material from, Material target)
		{
			base.ApplyConversion(from, target);

			DisableEffect("ALPHA_CUTOFF");

			bool emissionEffectEnabled = from.IsKeywordEnabled("_EMISSION");
			SetEnableEffect("EMISSION", emissionEffectEnabled);

			bool normalMapEffectEnabled = from.IsKeywordEnabled("_NORMALMAP");
			SetEnableEffect("NORMAL_MAP", normalMapEffectEnabled);

			EnableLightModelClassic();

			EnablePBR();
			
			target.SetFloat("_ReflectionsAtten", 1.0f);

			bool specularEnabled = !from.IsKeywordEnabled("_SPECULARHIGHLIGHTS_OFF");
			if (specularEnabled)
			{
				EnableSpecularClassic();
				target.SetFloat("_SpecularAtten", 1.0f);
			}
			else
			{
				DisableEffect("SPECULARMODEL");
			}

			DisableEffect("RIM_LIGHTING");

			//Blending Mode
			ConvertBlending();
		}

		protected virtual void ConvertBlending()
		{
		
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialConverter/Scripts/ConverterStandard.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialConverter/Scripts/ConverterStandardBIRP.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1a12bb5293276e74daff29adac53e710
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEngine.Rendering;

namespace AllIn13DShader
{
	public class ConverterStandardBIRP : ConverterStandard
	{
		protected override void ConvertBlending()
		{
			if (from.IsKeywordEnabled("_ALPHAPREMULTIPLY_ON"))
			{
				SetBlendSrc(BlendMode.One);
				SetBlendDst(BlendMode.OneMinusSrcAlpha);
				SetAlphaPreset();
			}
			else if (from.IsKeywordEnabled("_ALPHABLEND_ON"))
			{
				SetBlendSrc(BlendMode.SrcAlpha);
				SetBlendDst(BlendMode.OneMinusSrcAlpha);
				SetAlphaPreset();
			}
			else
			{
				SetBlendSrc(BlendMode.One);
				SetBlendDst(BlendMode.Zero);
				SetOpaquePreset();
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialConverter/Scripts/ConverterStandardBIRP.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialConverter/Scripts/ConverterURPLit.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: eda76fc9b5ca6914ea7ea1048cecba9d
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEngine.Rendering;

namespace AllIn13DShader
{
	public class ConverterURPLit : ConverterStandard
	{
		protected override void ConvertBlending()
		{
			if (from.IsKeywordEnabled("_SURFACE_TYPE_TRANSPARENT"))
			{
				if (from.IsKeywordEnabled("_ALPHAPREMULTIPLY_ON"))
				{
					SetBlendSrc(BlendMode.One);
					SetBlendDst(BlendMode.OneMinusSrcAlpha);
				}
				else
				{
					SetBlendSrc(BlendMode.SrcAlpha);
					SetBlendDst(BlendMode.OneMinusSrcAlpha);
				}

				SetAlphaPreset();
			}
			else
			{
				SetBlendSrc(BlendMode.One);
				SetBlendDst(BlendMode.Zero);
				SetOpaquePreset();
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialConverter/Scripts/ConverterURPLit.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialConverter/Scripts/MaterialConverterTool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c83ec1dea52056c478b8a512b7ea53a8
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.Collections.Generic;
using System.IO;
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public static class MaterialConverterTool
	{
		private const int OVERRIDE = 0;
		private const int CANCEL = 1;
		private const int KEEP_ORIGINALS = 2;

		//[MenuItem("Tools/AllIn1/Convert materials to AllIn13DShader")]

		[MenuItem(itemName: "Assets/AllIn1/Convert materials to AllIn13DShader", isValidateFunction: true)]
		public static bool ValidateBatchConvert()
		{
			bool res = true;

			Object[] selectedAssets = Selection.GetFiltered<Object>(SelectionMode.Assets);
			foreach (Object asset in selectedAssets)
			{
				string path = AssetDatabase.GetAssetPath(asset);
				
				bool isValidFolder = AssetDatabase.IsValidFolder(path);

				Material mat = AssetDatabase.LoadAssetAtPath<Material>(path);
				bool isMaterial = mat != null;

				res = res && (isValidFolder || isMaterial);
			}

			return res;
		}

		[MenuItem(itemName: "Assets/AllIn1/Convert materials to AllIn13DShader")]
		public static void BatchConvert()
		{
			Object[] selectedAssets = Selection.GetFiltered<Object>(SelectionMode.Assets);
			HashSet<string> pathsToConvert = CollectPathsToConvert(selectedAssets);

			string title = "Converting materials to AllIn13D";
			string message = $"You are about to convert {pathsToConvert.Count} materials to AllIn13D";
			string okButton = "Convert and Override";
			string altButton = "Convert and keep originals";
			string cancelButton = "Cancel";


			int dialog = EditorUtility.DisplayDialogComplex(title, message, okButton, cancelButton, altButton);
			
			if(dialog == 1) { return; }

			ConvertMaterials(pathsToConvert, dialog);
		}

		private static HashSet<string> CollectPathsToConvert(Object[] selectedAssets)
		{
			HashSet<string> res = new HashSet<string>();

			foreach (Object asset in selectedAssets)
			{
				string path = AssetDatabase.GetAssetPath(asset);

				if (asset is Material)
				{
					res.Add(path);
				}
				else
				{
					string[] materialsInFolderGUIDs = AssetDatabase.FindAssets("t: Material", new string[] { path });
					foreach (string guid in materialsInFolderGUIDs)
					{
						res.Add(AssetDatabase.GUIDToAssetPath(guid));
					}
				}
			}

			return res;
		}

		private static void ConvertMaterials(HashSet<string> materialsPaths, int dialog)
		{
			Undo.IncrementCurrentGroup();

			Shader allIn13DShader = Shader.Find("AllIn13DShader/AllIn13DShader");
			foreach (string path in materialsPaths)
			{
				ConvertMaterial(path, allIn13DShader, dialog);
			}

			Undo.SetCurrentGroupName("Materials conversion to AllIn13DShader");

			AssetDatabase.SaveAssets();
			AssetDatabase.Refresh();
		}

		private static void ConvertMaterial(string path, Shader allIn13DShader, int dialog)
		{
			Material matFrom = AssetDatabase.LoadAssetAtPath<Material>(path);
			Material target = new Material(allIn13DShader);

			ApplyConversion(matFrom, target);

			string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(path);
			string folder = Path.GetDirectoryName(path);
			string fileName = Path.GetFileName(path);

			string fileNameNewAsset = fileNameWithoutExtension + "_AllIn13D" + ".mat";
			string pathNewAsset = Path.Combine(folder, fileNameNewAsset);

			if (dialog == KEEP_ORIGINALS)
			{
				AssetDatabase.CreateAsset(target, pathNewAsset);
				Object createdObject = AssetDatabase.LoadAssetAtPath<Object>(pathNewAsset);
			}
			else if (dialog == OVERRIDE)
			{
				Undo.RecordObject(matFrom, "Material converted");

				matFrom.shader = target.shader;
				matFrom.CopyMatchingPropertiesFromMaterial(target);
				EditorUtility.SetDirty(matFrom);
			}
		}

		public static Material Convert(Shader shader, Material from)
		{
			Material res = new Material(shader);
			Texture normalMap = from.GetTexture("_BumpMap");

			if (normalMap != null)
			{
				res.SetTexture("_NormalMap", normalMap);
			}

			return res;
		}

		public static ConverterGeneral GetConverterByShader(Shader shader)
		{
			ConverterGeneral res = new ConverterGeneral();

			if(shader.name == "Standard")
			{
				res = new ConverterStandardBIRP();
			}
			else if(shader.name == "Universal Render Pipeline/Lit")
			{
				res = new ConverterURPLit();
			}

			return res;
		}

		public static void ApplyConversion(Material from, Material target)
		{
			if(from != null && target != null)
			{
				ConverterGeneral converter = GetConverterByShader(from.shader);
				converter.ApplyConversion(from, target);
			}
		}

		public static void ApplyConversionProperty(ConversionProperty conversionProperty, Material from, Material target, ref bool propertyActive)
		{
			string propertyNameFrom = string.Empty;
			string propertyNameTarget = conversionProperty.propertyName;

			if (from.HasProperty(conversionProperty.propertyName))
			{
				propertyNameFrom = conversionProperty.propertyName;
			}
			else
			{
				for (int i = 0; i < conversionProperty.alternativeNames.Length; i++)
				{
					if (from.HasProperty(conversionProperty.alternativeNames[i]))
					{
						propertyNameFrom = conversionProperty.alternativeNames[i];
						break;
					}
				}
			}

			if (!string.IsNullOrEmpty(propertyNameFrom))
			{
				switch (conversionProperty.propertyType)
				{
					case ConversionPropertyType.TEXTURE:
						Texture texValue = from.GetTexture(propertyNameFrom);
						target.SetTexture(propertyNameTarget, texValue);
						
						propertyActive = texValue != null;

						break;
					case ConversionPropertyType.FLOAT:
						float floatValue = from.GetFloat(propertyNameFrom);
						target.SetFloat(propertyNameTarget, floatValue);

						propertyActive = true;

						break;
					case ConversionPropertyType.COLOR:
						Color colorValue = from.GetColor(propertyNameFrom);
						target.SetColor(propertyNameTarget, colorValue);

						propertyActive = true;

						break;
					case ConversionPropertyType.VECTOR:
						Vector4 vectorValue = from.GetVector(propertyNameFrom);
						target.SetVector(propertyNameTarget, vectorValue);

						propertyActive = true;

						break;
				}
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialConverter/Scripts/MaterialConverterTool.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialOverride/Scripts/AbstractEffectOverride.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 0611bcd764908134fa1f7a375b5e9e53
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.Collections.Generic;
using UnityEngine;

namespace AllIn13DShader
{
	public abstract class AbstractEffectOverride
	{
		public List<PropertyOverride> propertyOverrides;

		public string displayName;
		public string propertyName;

		public bool overrideEnabled;

		public List<EffectKeywordData> keywords;

		public AbstractEffectOverride(AllIn13DEffectConfig effectConfig)
		{
			this.displayName = effectConfig.displayName;
			this.propertyName = effectConfig.keywordPropertyName;
			this.keywords = new List<EffectKeywordData>(effectConfig.keywords);

			this.propertyOverrides = new List<PropertyOverride>();
		}

		public void AddPropertyOverride(EffectProperty effectProperty, Shader shader)
		{
			PropertyOverride propertyOverride = new PropertyOverride(this, effectProperty, shader);

			AddPropertyOverride(propertyOverride);
		}

		public void AddPropertyOverride(int propertyIndex, Shader shader)
		{
			PropertyOverride propertyOverride = new PropertyOverride(this, propertyIndex, shader);

			AddPropertyOverride(propertyOverride);
		}

		private void AddPropertyOverride(PropertyOverride propertyOverride)
		{
			if (!propertyOverrides.Contains(propertyOverride))
			{
				propertyOverrides.Add(propertyOverride);
			}
		}

		public virtual void ApplyChangesToMaterial(Material mat)
		{
			if (overrideEnabled)
			{
				ApplyMainPropertyChanges(mat);
			}

			for(int i = 0; i < propertyOverrides.Count; i++)
			{
				propertyOverrides[i].ApplyChangesToMaterial(mat);
			}
		}

		protected abstract void ApplyMainPropertyChanges(Material mat);

		public bool RemovePropertyOverride(PropertyOverride propertyOverrideToRemove)
		{
			bool res = propertyOverrides.Remove(propertyOverrideToRemove);
			return res;
		}

		public override bool Equals(object obj)
		{
			bool res = false;

			if(obj is AbstractEffectOverride)
			{
				AbstractEffectOverride abstractEffectOverride = (AbstractEffectOverride)obj;
				res = propertyName == abstractEffectOverride.propertyName;
			}

			return res;
		}

		public override int GetHashCode()
		{
			return propertyName.GetHashCode();
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialOverride/Scripts/AbstractEffectOverride.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialOverride/Scripts/EffectEnumOverride.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f4ad01e8d27a2b3499bce2fe41f386c1
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class EffectEnumOverride : AbstractEffectOverride
	{
		public string[] enumOptions;

		public int index;

		public EffectEnumOverride(AllIn13DEffectConfig effectConfig) : base(effectConfig)
		{
			enumOptions = new string[effectConfig.keywords.Count];
			for(int i = 0; i < enumOptions.Length; i++)
			{
				enumOptions[i] = effectConfig.keywords[i].displayName;
			}
		}

		protected override void ApplyMainPropertyChanges(Material mat)
		{
			for(int i = 0; i < keywords.Count; i++)
			{
				mat.DisableKeyword(keywords[i].keyword);
			}

			mat.EnableKeyword(keywords[index].keyword);
			mat.SetFloat(propertyName, (float)index);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialOverride/Scripts/EffectEnumOverride.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialOverride/Scripts/EffectToggleOverride.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 87a78a29536838242b8abe925b7597bb
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class EffectToggleOverride : AbstractEffectOverride
	{
		public bool boolValue;

		public EffectToggleOverride(AllIn13DEffectConfig effectConfig) : base(effectConfig)
		{

		}

		protected override void ApplyMainPropertyChanges(Material mat)
		{
			if (boolValue)
			{
				mat.EnableKeyword(keywords[0].keyword);
				mat.SetFloat(propertyName, 1f);
			}
			else
			{
				mat.DisableKeyword(keywords[0].keyword);
				mat.SetFloat(propertyName, 0f);
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialOverride/Scripts/EffectToggleOverride.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialOverride/Scripts/MaterialOverrideData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 74623754e448ca3499d27a22fd49f94a
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.Collections.Generic;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;

namespace AllIn13DShader
{
	[System.Serializable]
	public class MaterialOverrideData : ScriptableObject
	{
		public class MaterialOverride
		{
			public Material sourceMaterial;
			public Material previewMaterial;

			public MaterialOverride(Material sourceMaterial)
			{
				this.sourceMaterial = sourceMaterial;

				if(sourceMaterial == null)
				{
					this.previewMaterial = null;
				}
				else
				{
					this.previewMaterial = new Material(sourceMaterial);
					this.previewMaterial.name = this.previewMaterial.name + "_PREVIEW";
				}
			}

			public void ApplyPreviewToSource()
			{
				sourceMaterial.CopyMatchingPropertiesFromMaterial(previewMaterial);
			}


			public bool ApplySourceToPreview()
			{
				bool res = true;

				if (previewMaterial == null || sourceMaterial == null)
				{
					res = false;
				}
				else
				{
					previewMaterial.CopyMatchingPropertiesFromMaterial(sourceMaterial);
				}

				return res;
			}
		}

		public class RendererOverride
		{
			public Renderer renderer;
			public MaterialOverride[] materialsOverrides;

			public Material[] sourceMaterials;
			public Material[] previewMaterials;

			public RendererOverride(Renderer renderer)
			{
				this.renderer = renderer;
				this.materialsOverrides = new MaterialOverride[renderer.sharedMaterials.Length];

				sourceMaterials = new Material[materialsOverrides.Length];
				previewMaterials = new Material[materialsOverrides.Length];

				for (int i = 0; i < materialsOverrides.Length; i++)
				{
					materialsOverrides[i]	= new MaterialOverride(renderer.sharedMaterials[i]);
					sourceMaterials[i]		= materialsOverrides[i].sourceMaterial;
					previewMaterials[i]		= materialsOverrides[i].previewMaterial;
				}
			}

			public void UsePreviewMaterials()
			{
				if (renderer != null)
				{
					renderer.sharedMaterials = previewMaterials;
				}
			}

			public void UseMaterialSource()
			{
				if (renderer != null)
				{
					renderer.sharedMaterials = sourceMaterials;
				}
			}

			public void ApplyPreviewMaterial()
			{
				for (int i = 0; i < materialsOverrides.Length; i++)
				{
					materialsOverrides[i].ApplyPreviewToSource();
					renderer.sharedMaterials[i] = materialsOverrides[i].sourceMaterial;
				}
			}

			//public void ApplyPropertyOverrideOnPreviewMaterial(PropertyOverride propertyOverride)
			//{
			//	switch (propertyOverride.shaderPropertyType)
			//	{
			//		case ShaderPropertyType.Float:
			//		case ShaderPropertyType.Range:
			//			materialOverride.previewMaterial.SetFloat(propertyOverride.propertyName, propertyOverride.floatValue);
			//			break;
			//	}
			//}

			public Material[] GetPreviewMaterials()
			{
				return previewMaterials;
			}

			public void CleanPreviewMaterials()
			{
				for(int i = 0; i < materialsOverrides.Length; i++)
				{
					MaterialOverride matOverride = materialsOverrides[i];

					matOverride.ApplySourceToPreview();

					string[] keywords = new string[matOverride.sourceMaterial.shaderKeywords.Length];
					matOverride.sourceMaterial.shaderKeywords.CopyTo(keywords, 0);

					matOverride.previewMaterial.shaderKeywords = keywords;
				}
			}
		}

		public enum ApplyTarget
		{
			NONE = 0,
			SELECTED_FOLDERS = 1,
			CURRENT_SCENE = 2,
			ALL_PROJECT = 3,
		}

		public List<AbstractEffectOverride> effectOverrides;
		public List<PropertyOverride> generalPropertiesOverrides;

		public RendererOverride[] rendererOverrides;

		public ApplyTarget applyTarget;

		[SerializeField] private Object[] folders;

		public void Initialize()
		{
			ResetData();
		}

		public void ResetData()
		{
			effectOverrides = new List<AbstractEffectOverride>();
			generalPropertiesOverrides = new List<PropertyOverride>();
			
			rendererOverrides = new RendererOverride[0];
			applyTarget = ApplyTarget.NONE;
		}

		public void CreateRendererOverride()
		{
			Renderer[] renderers = FindObjectsOfType<Renderer>();
			for (int i = 0; i < renderers.Length; i++)
			{
				if (renderers[i] is ParticleSystemRenderer) { continue; }

				RendererOverride rendererOverride = new RendererOverride(renderers[i]);
				ArrayUtility.Add(ref rendererOverrides, rendererOverride);
			}
		}

		public List<Material> CollectAffectedMaterials()
		{
			List<Material> res = new List<Material>();

			switch (applyTarget)
			{
				case ApplyTarget.SELECTED_FOLDERS:
					CollectAffectedMaterialsOnSelectedFolders(res);
					break;
				case ApplyTarget.CURRENT_SCENE:
					CollectAffectedMaterialsOnCurrentScene(res);
					break;
				case ApplyTarget.ALL_PROJECT:
					CollectAffectedMaterialsAllProject(res);
					break;
			}

			return res;
		}

		public void UsePreviewMaterials()
		{
			for (int i = 0; i < rendererOverrides.Length; i++)
			{
				rendererOverrides[i].UsePreviewMaterials();
			}
		}

		public void UseMaterialSource()
		{
			for (int i = 0; i < rendererOverrides.Length; i++)
			{
				rendererOverrides[i].UseMaterialSource();
			}
		}

		public void EndOverrideProcess()
		{
			UseMaterialSource();

			effectOverrides = new List<AbstractEffectOverride>();
			rendererOverrides = new RendererOverride[0];
		}

		public void ApplyChangesToMaterials(Material[] materials)
		{
			for (int i = 0; i < materials.Length; i++)
			{
				ApplyChangesToMaterial(materials[i]);
			}
		}

		public void ApplyChangesToMaterials(List<Material> materials)
		{
			for(int i = 0; i < materials.Count; i++)
			{
				ApplyChangesToMaterial(materials[i]);
			}
		}

		public void ApplyChangesToMaterial(Material mat)
		{
			for (int i = 0; i < effectOverrides.Count; i++)
			{
				effectOverrides[i].ApplyChangesToMaterial(mat);
			}

			for (int i = 0; i < generalPropertiesOverrides.Count; i++)
			{
				generalPropertiesOverrides[i].ApplyChangesToMaterial(mat);
			}
		}

		private void CollectAffectedMaterialsOnCurrentScene(List<Material> affectedMaterials)
		{
			for (int i = 0; i < rendererOverrides.Length; i++)
			{
				affectedMaterials.AddRange(rendererOverrides[i].sourceMaterials);
			}
		}

		private void CollectAffectedMaterialsOnSelectedFolders(List<Material> affectedMaterials)
		{
			HashSet<string> materialsInFolderGUIDs = new HashSet<string>();

			for (int i = 0; i < folders.Length; i++)
			{
				string folderPath = AssetDatabase.GetAssetPath(folders[i]);
				if (AssetDatabase.IsValidFolder(folderPath))
				{
					string[] assetsPathsInFolder = AssetDatabase.FindAssets("t: Material", new string[] { folderPath });

					for (int j = 0; j < assetsPathsInFolder.Length; j++)
					{
						materialsInFolderGUIDs.Add(assetsPathsInFolder[j]);
					}
				}
			}

			foreach (string guid in materialsInFolderGUIDs)
			{
				string path = AssetDatabase.GUIDToAssetPath(guid);
				Material mat = AssetDatabase.LoadAssetAtPath<Material>(path);

				if (EditorUtils.IsAllIn13DShader(mat.shader))
				{
					affectedMaterials.Add(mat);
				}
			}
		}

		private void CollectAffectedMaterialsAllProject(List<Material> affectedMaterials)
		{
			string[] materialsGUIDs = AssetDatabase.FindAssets("t: Material");

			foreach (string guid in materialsGUIDs)
			{
				string path = AssetDatabase.GUIDToAssetPath(guid);
				Material mat = AssetDatabase.LoadAssetAtPath<Material>(path);

				if (EditorUtils.IsAllIn13DShader(mat.shader))
				{
					affectedMaterials.Add(mat);
				}
			}
		}

		public bool IsApplyEnabled()
		{
			bool res = false;

			switch (applyTarget)
			{
				case ApplyTarget.SELECTED_FOLDERS:
					res = (folders != null) && (folders.Length > 0);
					break;
				case ApplyTarget.CURRENT_SCENE:
					res = true;
					break;
				case ApplyTarget.ALL_PROJECT:
					res = true;
					break;
			}

			return res;
		}

		public AbstractEffectOverride AddEffectOverride(AllIn13DEffectConfig effectConfig)
		{
			AbstractEffectOverride res = FindEffectOverride(effectConfig.keywordPropertyName);

			if (res == null)
			{
				switch (effectConfig.effectConfigType)
				{
					case EffectConfigType.EFFECT_ENUM:
						res = new EffectEnumOverride(effectConfig);
						break;
					case EffectConfigType.EFFECT_TOGGLE:
						res = new EffectToggleOverride(effectConfig);
						break;
				}

				effectOverrides.Add(res);
			}

			return res;
		}

		public void AddCopmleteEffectOverride(AllIn13DEffectConfig effectConfig, Shader shader)
		{
			AbstractEffectOverride effectOverride = FindEffectOverride(effectConfig.keywordPropertyName);

			if(effectOverride == null)
			{
				effectOverride = AddEffectOverride(effectConfig);
			}

			for (int i = 0; i < effectConfig.effectProperties.Count; i++)
			{
				effectOverride.AddPropertyOverride(effectConfig.effectProperties[i], shader);	
			}
		}

		public void AddPropertyOverride(AllIn13DEffectConfig effectConfig, EffectProperty effectProperty, Shader shader)
		{
			AbstractEffectOverride effectOverride = FindEffectOverride(effectConfig.keywordPropertyName);

			effectOverride = AddEffectOverride(effectConfig);
			effectOverride.AddPropertyOverride(effectProperty.propertyIndex, shader);
		}

		public void AddGeneralPropertyOverride(int propertyIndex, Shader shader)
		{
			PropertyOverride propertyOverride = new PropertyOverride(null, propertyIndex, shader);
			if (!generalPropertiesOverrides.Contains(propertyOverride))
			{
				generalPropertiesOverrides.Add(propertyOverride);
			}
		}

		public void RemoveEffectOverride(AbstractEffectOverride effectOverrideToRemove)
		{
			effectOverrides.Remove(effectOverrideToRemove);
			
			RebuildPreviewMaterial();
		}

		public void RemovePropertyOverride(PropertyOverride propertyOverride)
		{
			bool removeSuccessfully = propertyOverride.Remove();
			if (!removeSuccessfully)
			{
				generalPropertiesOverrides.Remove(propertyOverride);
			}
		}

		public void RebuildPreviewMaterial()
		{
			for (int i = 0; i < rendererOverrides.Length; i++)
			{
				rendererOverrides[i].CleanPreviewMaterials();
			}

			ShowPreviewChanges();
		}

		public void ShowPreviewChanges()
		{
			for (int i = 0; i < rendererOverrides.Length; i++)
			{
				RendererOverride rendererOverride = rendererOverrides[i];

				rendererOverride.UsePreviewMaterials();

				ApplyChangesToMaterials(rendererOverride.previewMaterials);
			}
		}

		public AbstractEffectOverride FindEffectOverride(string effectPropertyName)
		{
			AbstractEffectOverride res = null;

			for(int i = 0; i < effectOverrides.Count; i++)
			{
				if (effectOverrides[i].propertyName == effectPropertyName)
				{
					res = effectOverrides[i];
					break;
				}
			}

			return res;
		}

		public bool IsEmpty()
		{
			bool res = effectOverrides.Count <= 0 && generalPropertiesOverrides.Count <= 0;
			return res;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialOverride/Scripts/MaterialOverrideData.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialOverride/Scripts/OverrideEntry.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e130f397ef034734c995ecaed8cb8d4c
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public abstract class OverrideEntry
	{
		public enum OverrideCategory
		{
			KEYWORD_TOGGLE,
			KEYWORD_ENUM,
			COMMON,
			GLOBAL_PROPERTY,
		}

		public OverrideCategory overrideCategory;


		public OverrideEntry(OverrideCategory overrideCategory)
		{
			this.overrideCategory = overrideCategory;
		}

		public abstract void ApplyChangesToMaterial(Material mat);

		public override bool Equals(object obj)
		{
			bool res = false;

			if (obj is OverrideEntry)
			{
				OverrideEntry overrideEntry = (OverrideEntry)obj;
				res = overrideCategory == overrideEntry.overrideCategory;
			}

			return res;
		}

		public override int GetHashCode()
		{
			return overrideCategory.GetHashCode();
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialOverride/Scripts/OverrideEntry.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialOverride/Scripts/PropertyOverride.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 108081ac17dcca346914c1f8627b1b27
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEditor;
using UnityEngine;
using UnityEngine.Rendering;

namespace AllIn13DShader
{
	public class PropertyOverride
	{
		public string propertyName
		{
			get; private set;
		}

		public string displayName
		{
			get; private set;
		}

		private AbstractEffectOverride effectOverride;

		public ShaderPropertyType shaderPropertyType;

		public bool isKeywordsProperty;

		public float floatValue;
		public int intValue;
		public Color colorValue;
		public Vector2 rangeLimits;
		public Vector4 vectorValue;
		public Texture texValue;

		public string[] keywordsEnumOptions;


		public PropertyOverride(AbstractEffectOverride effectOverride, int propertyIndex, Shader shader)
		{
			this.effectOverride = effectOverride;
			this.isKeywordsProperty = false;

			Initialize(propertyIndex, shader);
		}

		public PropertyOverride(AbstractEffectOverride effectOverride, EffectProperty effectProperty, Shader shader) 
		{
			this.effectOverride = effectOverride;
			this.isKeywordsProperty = effectProperty.propertyKeywords.Count > 0;

			if (isKeywordsProperty)
			{
				keywordsEnumOptions = new string[effectProperty.propertyKeywords.Count];
				for(int i = 0; i < effectProperty.propertyKeywords.Count; i++)
				{
					keywordsEnumOptions[i] = effectProperty.propertyKeywords[i];
				}
			}

			Initialize(effectProperty.propertyIndex, shader);
		}

		private void Initialize(int propertyIndex, Shader shader)
		{
			this.propertyName = shader.GetPropertyName(propertyIndex);
			this.displayName = shader.GetPropertyDescription(propertyIndex);

			this.shaderPropertyType = shader.GetPropertyType(propertyIndex);

			if (this.shaderPropertyType == ShaderPropertyType.Range)
			{
				this.rangeLimits = shader.GetPropertyRangeLimits(propertyIndex);
			}

			InitializeDefaultValues(propertyIndex, shader);
		}

		private void InitializeDefaultValues(int propertyIndex, Shader shader)
		{
			switch (shaderPropertyType)
			{
				case ShaderPropertyType.Range:
				case ShaderPropertyType.Float:
					this.floatValue = shader.GetPropertyDefaultFloatValue(propertyIndex);
					break;
				case ShaderPropertyType.Vector:
					this.vectorValue = shader.GetPropertyDefaultVectorValue(propertyIndex);
					break;
				case ShaderPropertyType.Color:
					this.colorValue = shader.GetPropertyDefaultVectorValue(propertyIndex);
					break;
				case ShaderPropertyType.Int:
					this.intValue = (int)shader.GetPropertyDefaultFloatValue(propertyIndex);
					break;
			}
		}

		public override bool Equals(object obj)
		{
			bool res = false;

			if (obj is PropertyOverride)
			{
				PropertyOverride propertyOverride = (PropertyOverride)obj;
				res = (propertyName == propertyOverride.propertyName);
			}

			return res;
		}

		public override int GetHashCode()
		{
			int res = propertyName.GetHashCode();

			return res;
		}

		public void ApplyChangesToMaterial(Material mat)
		{
			if(mat == null) { return; }

			if (isKeywordsProperty)
			{
				//TODO: Make this cleaner
				for(int i = 0; i < keywordsEnumOptions.Length; i++)
				{
					string kw = (propertyName + "_" + keywordsEnumOptions[i]).ToUpper();
					mat.DisableKeyword(kw);

					if(i == floatValue)
					{
						mat.EnableKeyword(kw);
					}
				}
			}

			switch (shaderPropertyType)
			{
				case ShaderPropertyType.Float:
				case ShaderPropertyType.Range:
					mat.SetFloat(propertyName, floatValue);
					break;
				case ShaderPropertyType.Color:
					mat.SetColor(propertyName, colorValue);
					break;
				case ShaderPropertyType.Texture:
					mat.SetTexture(propertyName, texValue);
					break;
				case ShaderPropertyType.Vector:
					mat.SetVector(propertyName, vectorValue);
					break;
				case ShaderPropertyType.Int:
					mat.SetInt(propertyName, intValue);
					break;
			}
		}

		public bool Remove()
		{
			bool res = false;

			if(effectOverride != null)
			{
				res = effectOverride.RemovePropertyOverride(this);
			}

			return res;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialOverride/Scripts/PropertyOverride.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialOverride/Scripts/PropertySelectorAuxWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 135c1998be2528b458ad97784b0692ee
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System;
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class PropertySelectorAuxWindow : EditorWindow
	{
		public enum SelectionType
		{
			GLOBAL_PROPERTY,
			EFFECT_GROUP,
		}

		public enum TypeOfPropertyAdded
		{
			GLOBAL_PROPERTY,
			EFFECT_PROPERTY,
			EFFECT_MAIN,
		}

		private PropertiesConfigCollection propertiesConfigCollection;

		private Shader allIn13DShader;
		private Shader allIn13DShaderOutline;

		private PropertiesConfig propertiesConfigNormal;
		private PropertiesConfig propertiesConfigOutline;

		private int effectGroupIdx;
		private int effectIdx;
		private int propertyIdx;
		private int globalPropertyIdx;

		private EffectGroup selectedEffectGroup;
		private AllIn13DEffectConfig selectedEffectConfig;
		private EffectProperty selectedEffectProperty;

		private TypeOfPropertyAdded typeOfPropertyAdded;
		private SelectionType selectionType;

		private Action<AllIn13DEffectConfig, int, Shader, TypeOfPropertyAdded> propertyOverrideAddedCallback;

		private void OnEnable()
		{
			this.allIn13DShader = Shader.Find(Constants.SHADER_FULL_NAME_ALLIN13D);
			this.allIn13DShaderOutline = Shader.Find(Constants.SHADER_FULL_NAME_ALLIN13D);

			this.effectIdx = 0;
			this.propertyIdx = 0;
			this.globalPropertyIdx = 0;

			propertiesConfigCollection = EditorUtils.FindAsset<PropertiesConfigCollection>("PropertiesConfigCollection");
			propertiesConfigNormal = propertiesConfigCollection.FindPropertiesConfigByShader(allIn13DShader);
		}

		public void Setup(Action<AllIn13DEffectConfig, int, Shader, TypeOfPropertyAdded> propertyOverrideAddedCallback)
		{
			this.propertyOverrideAddedCallback = propertyOverrideAddedCallback;
		}

		private void OnGUI()
		{
			DrawEffectGroupSelector();

			if(selectionType == SelectionType.EFFECT_GROUP)
			{
				DrawEffectSelector();
				//DrawPropertySelector();
			}
			else if(selectionType == SelectionType.GLOBAL_PROPERTY)
			{
				DrawGlobalPropertySelector();
			}

			GUILayout.Space(20f);

			if (GUILayout.Button("Add"))
			{
				AddProperty();
			}
		}

		private void DrawEffectGroupSelector()
		{
			string[] effectsGroupsNames = propertiesConfigNormal.GetEffectGroupsDisplayNames();
			ArrayUtility.Insert(ref effectsGroupsNames, 0, "Global Properties");
			effectGroupIdx = EditorGUILayout.Popup("Group", effectGroupIdx, effectsGroupsNames);

			if(effectGroupIdx == 0)
			{
				selectionType = SelectionType.GLOBAL_PROPERTY;
				this.selectedEffectGroup = null;
			}
			else
			{
				selectionType = SelectionType.EFFECT_GROUP;
				this.selectedEffectGroup = propertiesConfigNormal.effectsGroups[effectGroupIdx - 1];
			}
		}

		private void DrawEffectSelector()
		{
			string[] effectsNames = selectedEffectGroup.GetEffectsNames();
			effectIdx = EditorGUILayout.Popup("Effect", effectIdx, effectsNames);

			selectedEffectConfig = selectedEffectGroup.effects[effectIdx];
		}

		private void DrawGlobalPropertySelector()
		{
			string[] globalPropertyNames = propertiesConfigNormal.GetGlobalPropertyNames();
			globalPropertyIdx = EditorGUILayout.Popup("Property", globalPropertyIdx, globalPropertyNames);
		}

		private void DrawPropertySelector()
		{
			string[] propertyNames = selectedEffectConfig.GetPropertyNames();

			string overrideEffectMsg = "Enable or Disable";
			if (selectedEffectConfig.keywords.Count > 1)
			{
				overrideEffectMsg = selectedEffectConfig.displayName;
				overrideEffectMsg += " (";
				for (int i = 0; i < selectedEffectConfig.keywords.Count; i++) 
				{
					overrideEffectMsg += selectedEffectConfig.keywords[i].displayName;
					if(i < selectedEffectConfig.keywords.Count - 1)
					{
						overrideEffectMsg += ", ";
					}
				}
				overrideEffectMsg += ")";
			}

			ArrayUtility.Add(ref propertyNames, overrideEffectMsg);

			propertyIdx = EditorGUILayout.Popup("Property", propertyIdx, propertyNames);

			if(propertyIdx <= selectedEffectConfig.effectProperties.Count - 1)
			{
				selectedEffectProperty = selectedEffectConfig.effectProperties[propertyIdx];
			}
			else
			{
				selectedEffectProperty = null;
			}
		}

		private void AddProperty()
		{
			if(selectionType == SelectionType.GLOBAL_PROPERTY)
			{
				typeOfPropertyAdded = TypeOfPropertyAdded.GLOBAL_PROPERTY;
			}
			else
			{
				if(selectedEffectProperty == null)
				{
					typeOfPropertyAdded = TypeOfPropertyAdded.EFFECT_MAIN;
				}
				else
				{
					typeOfPropertyAdded = TypeOfPropertyAdded.EFFECT_PROPERTY;
				}
			}

			if (propertyOverrideAddedCallback != null)
			{
				switch (typeOfPropertyAdded)
				{
					case TypeOfPropertyAdded.GLOBAL_PROPERTY:
						propertyOverrideAddedCallback(selectedEffectConfig, propertiesConfigNormal.singleProperties[globalPropertyIdx], allIn13DShader, typeOfPropertyAdded);
						break;
					case TypeOfPropertyAdded.EFFECT_MAIN:
						propertyOverrideAddedCallback(selectedEffectConfig, -1, allIn13DShader, typeOfPropertyAdded);
						break;
					//case TypeOfPropertyAdded.EFFECT_PROPERTY:
					//	propertyOverrideAddedCallback(selectedEffectConfig, selectedEffectProperty.propertyIndex, allIn13DShader, typeOfPropertyAdded);
					//	break;
				}
			}
		
			Close();
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/MaterialOverride/Scripts/PropertySelectorAuxWindow.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Presets/Scripts/BlendingMode.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6b20560ae87df6542bbfbc050c039189
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEngine;
using UnityEngine.Rendering;

namespace AllIn13DShader
{
	public class BlendingMode : ScriptableObject
	{
		public string displayName;

		public RenderQueue renderQueue;
		public BlendMode blendSrc;
		public BlendMode blendDst;
		public bool depthWrite;

		public string[] defaultEnabledEffects;
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Presets/Scripts/BlendingMode.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Presets/Scripts/MaterialPresetCollection.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 4629d07b23a824a409376d81eaa9733c
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class MaterialPresetCollection : ScriptableObject
	{
		public BlendingMode this[int key]
		{
			get => presets[key];
		}

		public BlendingMode[] presets;

		public string[] CreateStringsArray()
		{
			string[] res = new string[presets.Length];

			for(int i = 0; i < presets.Length; i++)
			{
				res[i] = presets[i].displayName;
			}

			return res;
		}

		public int GetIndex(BlendingMode materialPreset)
		{
			int res = -1;

			for(int i = 0; i < presets.Length; i++)
			{
				if (presets[i] == materialPreset)
				{
					res = i;
					break;
				}
			}

			return res;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Presets/Scripts/MaterialPresetCollection.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Presets/Scripts/MaterialPropertyValue.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 86890d6861f68c54181bbbfffcbd8d33
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	[System.Serializable]
	public class MaterialPropertyValue
	{
		public enum ValueType
		{
			NONE,
			INT,
			FLOAT,
			COLOR,
			TEXTURE,
		}

		public string propertyName;

		public ValueType valueType;

		public int intValue;
		public float floatValue;
		public Color colorValue;
		public Texture2D textureValue;
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Presets/Scripts/MaterialPropertyValue.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/PropertiesConfig.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6e68af35905cddc49a168dd54443e2c8
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.Collections.Generic;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	[System.Serializable]
	public class PropertiesConfig
	{
		public Shader shader;

		public EffectGroup[] effectsGroups;
		public List<int> singleProperties;
		public List<int> advancedProperties;

		public int renderPreset; 
		public int blendSrcIdx;
		public int blendDstIdx;
		public int zWriteIndex;

		public void CreateConfig(EffectGroupGlobalConfigCollection effectGroupGlobalConfigCollection, EffectsExtraData effectsExtraData)
		{
			effectsGroups = new EffectGroup[0];
			singleProperties = new List<int>();
			advancedProperties = new List<int>();

			CreateGroups(effectGroupGlobalConfigCollection);

			int numProperties = shader.GetPropertyCount();

			for (int i = 0; i < numProperties; i++)
			{
				string[] attributes = shader.GetPropertyAttributes(i);
				string displayName	= shader.GetPropertyDescription(i);
				string propertyName = shader.GetPropertyName(i);

				if (propertyName == Constants.MATPROPERTY_RENDERING_MODE)
				{
					this.renderPreset = i;
				}
				else
				{
					if (attributes.Length > 0)
					{
						int idxOffset = 0;
						string firstAttribute = attributes[0];
						string secondAttribute = string.Empty;
						if(attributes.Length >= 2)
						{
							secondAttribute = attributes[1];
						}



						if (firstAttribute.Contains(Constants.EFFECT_ATTRIBUTE_PREFIX))
						{
							ConfigureEffect(displayName, i, propertyName, firstAttribute, attributes[idxOffset + 1], effectsExtraData);
						}
						else if (firstAttribute.StartsWith(Constants.EFFECT_PROPERTY_ATTRIBUTE_PREFIX))
						{
							EffectPropertyAttributeData effectPropertyAttributeData = GetEffectPropertyAttributeData(firstAttribute, secondAttribute);
							ConfigureProperty(effectPropertyAttributeData, i, propertyName, displayName);
						}
						else if (firstAttribute.Contains(Constants.SINGLE_PROPERTY_ATTRIBUTE))
						{
							singleProperties.Add(i);
						}
						else if (firstAttribute.Contains(Constants.ADVANCED_PROPERTY_ATTRIBUTE))
						{
							advancedProperties.Add(i);
						}
					}
				}
				if (propertyName == Constants.MATPROPERTY_BLEND_SRC)
				{
					this.blendSrcIdx = i;
				}
				else if (propertyName == Constants.MATPROPERTY_BLEND_DST)
				{
					this.blendDstIdx = i;
				}
			}

			zWriteIndex = FindPropertyIndex("_ZWrite");
		}

		private void CreateGroups(EffectGroupGlobalConfigCollection effectGroupGlobalConfigCollection)
		{
			for (int i = 0; i < effectGroupGlobalConfigCollection.effectGroupGlobalConfigs.Length; i++)
			{
				EffectGroupGlobalConfig effectGroupGlobalConfig = effectGroupGlobalConfigCollection.effectGroupGlobalConfigs[i];
				//string groupID = Constants.EFFECTS_GROUPS_IDS[i];

				EffectGroup group = new EffectGroup(effectGroupGlobalConfig);
				ArrayUtility.Add(ref effectsGroups, group);
			}
		}

		private EffectPropertyAttributeData GetEffectPropertyAttributeData(string attribute, string secondAttribute)
		{
			EffectPropertyAttributeData res = new EffectPropertyAttributeData();

			MatchCollection matchCollection = Regex.Matches(attribute, Constants.REGEX_EFFECT_PROOPERTY_COMPLETE);
			if (matchCollection != null && matchCollection.Count > 0)
			{
				res.parentEffectID = matchCollection[0].Groups[1].Value;
				string[] keywordListSplit = matchCollection[0].Groups[4].Value.Split(",");
				for(int i = 0; i < keywordListSplit.Length; i++)
				{
					string kw = keywordListSplit[i].Trim();
					res.AddKeyword(kw);
				}

				string[] incompatibleKwsSplit = matchCollection[0].Groups[3].Value.Split(",");
				for(int i = 0; i < incompatibleKwsSplit.Length; i++)
				{
					string incompatibleKw = incompatibleKwsSplit[i];
					res.AddIncompatibleKeyword(incompatibleKw);
				}

				string strAllowReset = matchCollection[0].Groups[5].Value.ToUpper();
				res.allowReset = strAllowReset == "TRUE";
			
				string strKeywordsOp = matchCollection[0].Groups[2].Value.ToUpper();
				if (!string.IsNullOrEmpty(strKeywordsOp))
				{
					res.keywordsOp = strKeywordsOp == "AND" ? KeywordsOp.AND : KeywordsOp.OR;
				}
			}
			else
			{
				matchCollection = Regex.Matches(attribute, Constants.REGEX_EFFECT_PROPERTY);
				
				string[] contentSplit = matchCollection[0].Groups[1].Value.Split(",");

				string parentEffectID = contentSplit[0].Trim();
				res.parentEffectID = parentEffectID;

				if (contentSplit.Length > 1)
				{
					for (int i = 1; i < contentSplit.Length; i++)
					{
						string kw = $"_{parentEffectID}_{contentSplit[i].Trim()}";
						res.AddKeyword(kw);
					}
				}
				else
				{
					string kw = $"_{parentEffectID}_ON";
					res.AddKeyword(kw);
				}
			}

			if (!string.IsNullOrEmpty(secondAttribute))
			{
				matchCollection = Regex.Matches(secondAttribute, Constants.REGEX_KEYWORDS_ENUM);
				if (matchCollection.Count >= 1)
				{
					string[] contentSplit = matchCollection[0].Groups[1].Value.Split(",");
					res.AddPropertyKeywords(contentSplit);
				}
			}

			return res;
		}

		private EffectKeywordData[] GetParentEffectKeywords(string attribute, string effectName)
		{
			MatchCollection matchCollection = Regex.Matches(attribute, Constants.REGEX_PARENT_EFFECT_KEYWORDS);
			string[] matchSplitted = matchCollection[0].Groups[1].Value.Split(",");
			EffectKeywordData[] res = new EffectKeywordData[matchSplitted.Length];
			for (int i = 0; i < matchSplitted.Length; i++)
			{
				matchSplitted[i] = matchSplitted[i].Trim();

				string displayName = matchSplitted[i];

				string keyword = string.Empty;
				if(matchSplitted.Length == 1)
				{
					keyword = $"{matchSplitted[i].ToUpper()}";
				}
				else
				{
					keyword = $"_{effectName}_{matchSplitted[i].ToUpper()}";
				}

				res[i] = new EffectKeywordData(keyword, displayName);
				//matchSplitted[i] = matchSplitted[i].ToUpper();
			}

			return res;
		}

		private EffectAttributeData GetEffectAttributeData(string rawAttribute)
		{
			EffectAttributeData res = new EffectAttributeData();

			Match match = Regex.Match(rawAttribute, Constants.REGEX_EFFECT);
			res.effectID = match.Groups[1].Value.Trim();
			res.groupID = match.Groups[2].Value.Trim();
			res.dependentEffectID = match.Groups[4].Value.Trim();
			res.incompatibleWithEffectID = match.Groups[5].Value.Trim();
			res.docEnabled = match.Groups[6].Value.Trim().ToUpper() == "TRUE";
			res.drawerID = match.Groups[7].Value.Trim();

			if (string.IsNullOrEmpty(res.drawerID))
			{
				res.drawerID = Constants.GENERAL_EFFECT_DRAWER_ID;
			}

			return res;
		}

		private void ConfigureEffect(string displayName, int propertyIndex, string propertyName, string rawEffectAttribute, string attributeKeywords,
			EffectsExtraData effectsExtraData)
		{
			EffectAttributeData effectAttributeData = GetEffectAttributeData(rawEffectAttribute);

			string effectName = effectAttributeData.effectID;

			AllIn13DEffectConfig effectConfig = FindEffectConfigByID(effectAttributeData.effectID);
			EffectKeywordData[] keywordsDatas = GetParentEffectKeywords(attributeKeywords, effectName);

			EffectConfigType effectConfigType = keywordsDatas.Length == 1 ? EffectConfigType.EFFECT_TOGGLE : EffectConfigType.EFFECT_ENUM;
			if (effectConfig == null)
			{
				effectConfig = new AllIn13DEffectConfig(displayName, propertyName, propertyIndex, effectConfigType, 
					effectAttributeData, effectsExtraData);

				effectConfig.AddKeywords(keywordsDatas);
				effectConfig.Setup();

				EffectGroup effectGroup = GetEffecGroupByID(effectAttributeData.groupID);
				effectGroup.AddEffect(effectConfig);
			}
		}

		private EffectGroup GetEffecGroupByID(string groupID)
		{
			EffectGroup res = null;

			for (int i = 0; i < effectsGroups.Length; i++)
			{
				if (effectsGroups[i].GroupID == groupID)
				{
					res = effectsGroups[i];
					break;
				}
			}

			return res;
		}

		//private void ConfigureProperty(string[] propertyContent, int propertyIndex, string propertyName)
		//{
		//	string effectID = propertyContent[0];
		//	List<string> keywords = new List<string>();

		//	if (propertyContent.Length > 1)
		//	{
		//		for (int i = 1; i < propertyContent.Length; i++)
		//		{
		//			string kw = $"_{effectID}_{propertyContent[i]}";
		//			keywords.Add(kw);
		//		}
		//	}
		//	else
		//	{
		//		string kw = $"_{effectID}_ON";
		//		keywords.Add(kw);
		//	}

		//	ConfigureProperty(effectID, keywords, propertyIndex, propertyName);
		//}

		private void ConfigureProperty(EffectPropertyAttributeData data, int propertyIndex, string propertyName, string displayName)
		{
			AllIn13DEffectConfig effectConfig = FindEffectConfigByID(data.parentEffectID);
			EffectProperty effectProperty = effectConfig.CreateEffectProperty(propertyIndex, propertyName, displayName, data);
		}

		public AllIn13DEffectConfig FindEffectConfigByID(string effectID)
		{
			AllIn13DEffectConfig res = null;

			for (int groupIdx = 0; groupIdx < effectsGroups.Length; groupIdx++)
			{
				EffectGroup effectGroup = effectsGroups[groupIdx];

				res = effectGroup.FindEffectByID(effectID);

				if (res != null)
				{
					break;
				}
			}

			return res;
		}

		public EffectProperty FindEffectProperty(string effectID, string propertyName)
		{
			AllIn13DEffectConfig effectConfig = FindEffectConfigByID(effectID);

			EffectProperty res = effectConfig.FindEffectPropertyByName(propertyName);
			return res;
		}

		public int FindPropertyIndex(string propertyName)
		{
			int res = shader.FindPropertyIndex(propertyName);
			return res;
		}

		//public EffectProperty FindGeneralEffectProperty(string propertyName)
		//{
		//	EffectProperty res = null;

		//	for(int i = 0; i < singleProperties.Count; i++)
		//	{
		//		break;
		//	}

		//	return res;
		//}

		public List<AllIn13DEffectConfig> GetAllEffects()
		{
			List<AllIn13DEffectConfig> res = new List<AllIn13DEffectConfig>();

			for (int groupIdx = 0; groupIdx < effectsGroups.Length; groupIdx++)
			{
				res.AddRange(effectsGroups[groupIdx].effects);
			}

			return res;
		}

		public EffectGroup FindEffectGroupByID(string groupID)
		{
			EffectGroup res = null;

			for(int i = 0; i < effectsGroups.Length; i++)
			{
				if (effectsGroups[i].GroupID == groupID)
				{
					res = effectsGroups[i];
					break;
				}
			}

			return res;
		}

		public string[] GetEffectGroupsIDs()
		{
			string[] res = new string[effectsGroups.Length];

			for(int i = 0; i < effectsGroups.Length; i++)
			{
				res[i] = effectsGroups[i].GroupID;
			}

			return res;
		}

		public string[] GetEffectGroupsDisplayNames()
		{
			string[] res = new string[effectsGroups.Length];

			for(int i = 0; i < effectsGroups.Length; i++)
			{
				res[i] = effectsGroups[i].DisplayName;
			}

			return res;
		}

		public string[] GetGlobalPropertyNames()
		{
			string[] res = new string[singleProperties.Count];

			for(int i = 0; i < singleProperties.Count; i++)
			{
				res[i] = shader.GetPropertyDescription(singleProperties[i]);
			}

			return res;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/PropertiesConfig.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/PropertiesConfigCollection.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: de2c732907004674f91e71073a09d404
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class PropertiesConfigCollection : ScriptableObject
	{
		public PropertiesConfig[] shaderPropertiesConfig;

		public void AddConfig(PropertiesConfig config)
		{
			if (shaderPropertiesConfig == null)
			{
				shaderPropertiesConfig = new PropertiesConfig[0];
			}

			ArrayUtility.Add(ref shaderPropertiesConfig, config);
		}

		public PropertiesConfig FindPropertiesConfigByShader(Shader shader)
		{
			PropertiesConfig res = null;

			for (int i = 0; i < shaderPropertiesConfig.Length; i++)
			{
				if (shaderPropertiesConfig[i].shader == shader)
				{
					res = shaderPropertiesConfig[i];
					break;
				}
			}

			return res;
		}

		public bool IsAllIn3DShaderMaterial(Material mat)
		{
			bool res = false;

			for (int i = 0; i < shaderPropertiesConfig.Length; i++)
			{
				if (shaderPropertiesConfig[i].shader == mat.shader)
				{
					res = true;
				}
			}

			return res;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/PropertiesConfigCollection.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/PropertiesConfigCreator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 4220235a1363ffa45a709aa2921ab167
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.IO;
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class PropertiesConfigCreator : AssetPostprocessor
	{
		private const string KEY_PROPERTIES_CONFIG_CREATED_FIRST_TIME = "AllIn13DShader_PropertiesConfigCreatedFirstTime";

		private static PropertiesConfigCollection propertiesCollection;

		private static EffectGroupGlobalConfigCollection effectGroupGlobalConfigCollection;
		private static EffectsExtraData effectsExtraData;


		[MenuItem("Tools/AllIn1/3DShader/Data/Create Properties Configs")]
		public static PropertiesConfigCollection CreateConfig()
		{
			propertiesCollection = CreatePropertiesCollection();
			effectGroupGlobalConfigCollection = GetEffectGroupGlobalConfigCollection();
			effectsExtraData = GetEffectsExtraData();

			for (int i = 0; i < Constants.SHADERS_NAMES.Length; i++)
			{
				CreatePropertiesConfig(propertiesCollection, Constants.SHADERS_NAMES[i]);
			}

			EditorUtility.SetDirty(propertiesCollection);
			AssetDatabase.SaveAssets();
			AssetDatabase.Refresh(ImportAssetOptions.ForceSynchronousImport);

			EditorPrefs.SetFloat(Constants.LAST_TIME_SHADER_PROPERTIES_REBUILT_KEY, (float)EditorApplication.timeSinceStartup);

			Debug.LogWarning("Creating data...");

			return propertiesCollection;
		}

		private static PropertiesConfigCollection CreatePropertiesCollection()
		{
			PropertiesConfigCollection res = FindPropertiesCollection();
			string path = AssetDatabase.GetAssetPath(res);

			if (File.Exists(path))
			{
				AssetDatabase.DeleteAsset(path);
				AssetDatabase.Refresh();
			}

			string propertiesCollectionPath = Path.Combine(Constants.SHADERS_PROPERTIES_FOLDER_PATH, "PropertiesConfigCollection.asset");
			res = ScriptableObject.CreateInstance<PropertiesConfigCollection>();
			AssetDatabase.CreateAsset(res, propertiesCollectionPath);
			AssetDatabase.Refresh(ImportAssetOptions.ForceSynchronousImport);

			return res;
		}

		private static EffectGroupGlobalConfigCollection GetEffectGroupGlobalConfigCollection()
		{
			string[] guids = AssetDatabase.FindAssets("t:EffectGroupGlobalConfigCollection");
			string path = AssetDatabase.GUIDToAssetPath(guids[0]);

			EffectGroupGlobalConfigCollection res = AssetDatabase.LoadAssetAtPath<EffectGroupGlobalConfigCollection>(path);
			return res;
		}

		private static EffectsExtraData GetEffectsExtraData()
		{
			EffectsExtraData res = null;

			res = EditorUtils.FindAsset<EffectsExtraData>("EffectsExtraData");

			return res;
		}

		private static EffectGroupGlobalConfig[] GetEffectGroups()
		{
			EffectGroupGlobalConfig[] res = new EffectGroupGlobalConfig[0];
			string[] guids = AssetDatabase.FindAssets("t:EffectGroupGlobalConfig");

			for (int i = 0; i < guids.Length; i++)
			{
				string path = AssetDatabase.GUIDToAssetPath(guids[i]);
				EffectGroupGlobalConfig effectGroupGlobalConfig = AssetDatabase.LoadAssetAtPath<EffectGroupGlobalConfig>(path);
				ArrayUtility.Add(ref res, effectGroupGlobalConfig);
			}

			return res;
		}

		private static void CreatePropertiesConfig(PropertiesConfigCollection propertiesCollection, string shaderName)
		{
			string shaderNameWithExtension = shaderName + ".shader";
			string assetPath = Path.Combine(Constants.SHADERS_FOLDER_PATH, shaderNameWithExtension);

			Shader shader = AssetDatabase.LoadAssetAtPath<Shader>(assetPath);

			PropertiesConfig propertiesConfig = new PropertiesConfig();
			propertiesConfig.shader = shader;

			propertiesConfig.CreateConfig(effectGroupGlobalConfigCollection, effectsExtraData);

			propertiesCollection.AddConfig(propertiesConfig);
		}

		private static PropertiesConfigCollection FindPropertiesCollection()
		{
			PropertiesConfigCollection res = null;

			string[] guids = AssetDatabase.FindAssets("t:PropertiesConfigCollection");
			if (guids.Length > 0)
			{
				string assetPath = AssetDatabase.GUIDToAssetPath(guids[0]);
				res = AssetDatabase.LoadAssetAtPath<PropertiesConfigCollection>(assetPath);
			}

			return res;
		}

		static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths, bool didDomainReload)
		{
			GlobalConfiguration.CheckRootFolder();

			bool configCreatedFirstTime = SessionState.GetBool(KEY_PROPERTIES_CONFIG_CREATED_FIRST_TIME, false);
			bool rebuildShaderProperties = false;

			for (int i = 0; i < importedAssets.Length; i++)
			{
				rebuildShaderProperties = rebuildShaderProperties || IsAllIn13DShader(importedAssets[i]);
			}

			if (rebuildShaderProperties || !configCreatedFirstTime)
			{
				SessionState.SetBool(KEY_PROPERTIES_CONFIG_CREATED_FIRST_TIME, true);
				ShadersCreatorTool.BuildShaderFiles();
				CreateConfig();
			}

#if ALLIN13DSHADER_URP
			URPConfigurator.AllAssetProcessed();
#endif
			GlobalConfiguration.instance.Init();
		}

		private static bool IsAllIn13DShader(string importedAsset)
		{
			bool res = false;

			for (int i = 0; i < Constants.SHADERS_NAMES.Length; i++)
			{
				string shaderName = $"{Constants.SHADERS_NAMES[i]}.shader";
				res = res || importedAsset.Contains(shaderName);
			}

			return res;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/PropertiesConfigCreator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/RenderPreset.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 2cccc54d5414b39479eba144f916afd6
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
namespace AllIn13DShader
{
	public enum RenderPreset
	{
		Transparent = 0,
		Additive = 1,
		Opaque = 2,
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/RenderPreset.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Templates/ShadersCreatorTool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: cbfc829814986aa428fd5296759d7687
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.IO;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public static class ShadersCreatorTool
	{
		private const string TEMPLATE_EXTENSION = ".allIn13DTemplate";

		private static string[] TEMPLATES_NAMES = new string[] 
		{
			"AllIn13DShaderOutline_NoShadowCaster_Template",
			"AllIn13DShaderOutline_Template",
			"AllIn13DShader_NoShadowCaster_Template"
		};

		private static string[] TEMPLATE_TAGS = new string[]
		{
			"COMMON_PROPERTIES",
			"BASE_PASS",
			"FORWARD_ADD_PASS",
			"SHADOW_CASTER_PASS",
			"CUSTOM_EDITOR",
			"BASE_PASS_URP",
			"SHADOW_CASTER_PASS_URP",
			"DEPTH_NORMALS_PASS_URP",
		};

		private const string REGEX_CORE = @"\/\*<{0}_START>\*\/\s*([\t\r\ ]*(?:.*\n)*)[\t\r\ ]*\s+\/\*<{0}_END>\*\/";
		private const string TAG_FORMAT = "<{0}>";

		[MenuItem("Tools/Create Shader Files")]
		public static void BuildShaderFiles()
		{
			Shader mainShader = Shader.Find(Constants.SHADER_FULL_NAME_ALLIN13D);
			string mainShaderPath = AssetDatabase.GetAssetPath(mainShader);

			string shaderFileText = File.ReadAllText(mainShaderPath);

			for(int i = 0; i < TEMPLATES_NAMES.Length; i++)
			{
				string templatePath = Path.Combine(Constants.TEMPLATES_FOLDER, TEMPLATES_NAMES[i]) + TEMPLATE_EXTENSION;
				
				string templateText = File.ReadAllText(templatePath);
				string newShaderFileText = SearchAndReplaceTemplateTags(shaderFileText, templateText);

				string newShaderFileName = TEMPLATES_NAMES[i].Replace("_Template", "");
				string newShaderPath = Path.Combine(Constants.SHADERS_FOLDER_PATH, newShaderFileName + ".shader");
				File.WriteAllText(newShaderPath, newShaderFileText);
			}

			AssetDatabase.Refresh(ImportAssetOptions.ForceSynchronousImport);
		}

		private static string SearchAndReplaceTemplateTags(string shaderFileText, string templateText)
		{
			string res = templateText;

			for (int i = 0; i < TEMPLATE_TAGS.Length; i++)
			{
				string tagData = GetDataByTag(shaderFileText, TEMPLATE_TAGS[i]);
				res = OverrideTagWithData(TEMPLATE_TAGS[i], tagData, res);
			}

			return res;
		}

		private static string GetDataByTag(string shaderFileTex, string tag)
		{
			string regex = string.Format(REGEX_CORE, tag);
			MatchCollection matchCollection = Regex.Matches(shaderFileTex, regex);
			string res = matchCollection[0].Groups[1].Value.TrimStart().TrimEnd();

			return res;
		}

		private static string OverrideTagWithData(string tag, string data, string targetFileTxt)
		{
			string res = targetFileTxt;

			string formattedTag = string.Format(TAG_FORMAT, tag);
			res = res.Replace(formattedTag, data);

			return res;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Templates/ShadersCreatorTool.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/TextureSizes.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 3bfc75873bcad9e40840bfc361b8d9ce
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
namespace AllIn13DShader
{
	public enum TextureSizes
	{
		_2 = 2,
		_4 = 4,
		_8 = 8,
		_16 = 16,
		_32 = 32,
		_64 = 64,
		_128 = 128,
		_256 = 256,
		_512 = 512,
		_1024 = 1024,
		_2048 = 2048
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/TextureSizes.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Tools/AtlasPackerTool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 22cf4eeb2432eff42a008c7a5c157f0f
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class AtlasPackerTool
	{
		public int atlasXCount;
		public int atlasYCount;
		
		public TextureSizes atlasSizesX;
		public TextureSizes atlasSizesY;

		public FilterMode atlasFiltering;

		public bool squareAtlas;

		public Texture2D[] atlas;

		public Texture2D createdAtlas;

		public AtlasPackerTool()
		{
			atlasXCount = 1;
			atlasYCount = 1;

			atlasSizesX = TextureSizes._1024;
			atlasSizesY = TextureSizes._1024;

			squareAtlas = true;

			atlasFiltering = FilterMode.Bilinear;
		}

		public void CreateAtlas()
		{
			int atlasElements = atlasXCount * atlasYCount;
			int atlasWidth = (int)atlasSizesX;
			int atlasHeight = (int)atlasSizesY;

			Texture2D[] AtlasCopy = (Texture2D[])atlas.Clone();
			int textureXTargetWidth = atlasWidth / atlasXCount;
			int textureYTargetHeight = atlasHeight / atlasYCount;
			createdAtlas = new Texture2D(atlasWidth, atlasHeight);
			for (int i = 0; i < atlasYCount; i++)
			{
				for (int j = 0; j < atlasXCount; j++)
				{
					int currIndex = (i * atlasXCount) + j;
					bool hasImageForThisIndex = currIndex < AtlasCopy.Length && AtlasCopy[currIndex] != null;
					if (hasImageForThisIndex)
					{
						EditorUtils.SetTextureReadWrite(AssetDatabase.GetAssetPath(AtlasCopy[currIndex]), true);
						Texture2D copyTexture = new Texture2D(AtlasCopy[currIndex].width, AtlasCopy[currIndex].height);
						copyTexture.SetPixels(AtlasCopy[currIndex].GetPixels());
						copyTexture.Apply();
						AtlasCopy[currIndex] = copyTexture;
						AtlasCopy[currIndex] = EditorUtils.ScaleTexture(AtlasCopy[currIndex], textureXTargetWidth, textureYTargetHeight);
						AtlasCopy[currIndex].Apply();
					}

					for (int y = 0; y < textureYTargetHeight; y++)
					{
						for (int x = 0; x < textureXTargetWidth; x++)
						{
							if (hasImageForThisIndex) createdAtlas.SetPixel((j * textureXTargetWidth) + x, (i * textureYTargetHeight) + y, AtlasCopy[currIndex].GetPixel(x, y));
							else createdAtlas.SetPixel((j * textureXTargetWidth) + x, (i * textureYTargetHeight) + y, new Color(0, 0, 0, 1));
						}
					}
				}
			}

			createdAtlas.Apply();
		}

		public int GetAtlasElements()
		{
			int res = atlasXCount * atlasYCount;
			return res;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Tools/AtlasPackerTool.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Tools/GradientCreatorTool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d9a976b4a21c9a34884e574c601d7e55
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.IO;
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class GradientCreatorTool
	{
		public Texture2D gradientTex;

		public TextureSizes gradientSizes;
		public FilterMode gradientFiltering;
		public Gradient gradient;

		public GradientCreatorTool()
		{
			gradientSizes = TextureSizes._128;
			gradientFiltering = FilterMode.Bilinear;
			gradient = new Gradient();

			int size = (int)gradientSizes;
			gradientTex = new Texture2D(size, size);
		}

		public Texture2D CreateGradientTexture(TextureSizes gradientSizes, FilterMode gradientFiltering, Gradient gradient)
		{
			this.gradientSizes = gradientSizes;
			this.gradientFiltering = gradientFiltering;
			this.gradient = gradient;

			return CreateGradientTexture();
		}

		public Texture2D CreateGradientTexture(Gradient gradient)
		{
			this.gradientSizes = TextureSizes._256;
			this.gradientFiltering = FilterMode.Bilinear;
			this.gradient = gradient;

			return CreateGradientTexture();
		}

		public Texture2D CreateGradientTexture()
		{
			int textureSize = (int)gradientSizes;
			this.gradientTex = new Texture2D(textureSize, 1, TextureFormat.RGBA32, false);
			this.gradientTex.wrapMode = TextureWrapMode.Clamp;

			for (int i = 0; i < textureSize; i++)
			{
				gradientTex.SetPixel(i, 0, gradient.Evaluate((float)i / (float)textureSize));
			}

			gradientTex.Apply();
			return gradientTex;
		}

		public Texture SaveGradientTexture(GradientTexture gradientTextureAsset, bool generateUniqueAssetPath)
		{
			string texName = "RampTexture";
			if(gradientTextureAsset != null)
			{
				texName = gradientTextureAsset.texture.name;
			}

			Texture tex = EditorUtils.SaveTextureAsPNG(GlobalConfiguration.instance.GradientSavePath, texName, "Ramp Texture", gradientTex,
					FilterMode.Bilinear, TextureImporterType.Default, TextureWrapMode.Clamp, false, generateUniqueAssetPath);

			if (generateUniqueAssetPath)
			{
				GradientTexture gradientTexture = ScriptableObject.CreateInstance<GradientTexture>();
				gradientTexture.texture = tex;
				gradientTexture.gradient = new Gradient();
				CopyGradient(gradient, gradientTexture.gradient);

				string gradientTextureAssetPath = Path.Combine(GlobalConfiguration.instance.GradientSavePath, $"GradientAsset_{tex.name}.asset");
				gradientTextureAssetPath = AssetDatabase.GenerateUniqueAssetPath(gradientTextureAssetPath);

				AssetDatabase.CreateAsset(gradientTexture, gradientTextureAssetPath);
				AssetDatabase.Refresh();
			}
			else
			{
				gradientTextureAsset.texture = tex;

				gradientTextureAsset.gradient = new Gradient();
				CopyGradient(gradient, gradientTextureAsset.gradient);

				EditorUtility.SetDirty(gradientTextureAsset);
			}

			return tex;
		}

		public static void CopyGradient(Gradient from, Gradient to)
		{
			GradientColorKey[] newColorKeys = new GradientColorKey[from.colorKeys.Length];
			GradientAlphaKey[] newAlphaKeys = new GradientAlphaKey[from.alphaKeys.Length];

			for (int i = 0; i < from.colorKeys.Length; i++)
			{
				newColorKeys[i] = from.colorKeys[i];
			}

			for (int i = 0; i < from.alphaKeys.Length; i++)
			{
				newAlphaKeys[i] = from.alphaKeys[i];
			}

			to.colorKeys = newColorKeys;
			to.alphaKeys = newAlphaKeys;
			to.mode = from.mode;
		}

		public static GradientTexture FindGradientTexureByTex(Texture selectedTex)
		{
			GradientTexture res = null;
			string[] guids = AssetDatabase.FindAssets("t:GradientTexture");

			for (int i = 0; i < guids.Length; i++)
			{
				string path = AssetDatabase.GUIDToAssetPath(guids[i]);
				GradientTexture gradientTexture = AssetDatabase.LoadAssetAtPath<GradientTexture>(path);

				if (gradientTexture.name.StartsWith("GradientAsset_"))
				{
					if (gradientTexture.texture == selectedTex)
					{
						res = gradientTexture;
						break;
					}
				}
			}

			return res;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Tools/GradientCreatorTool.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Tools/NoiseCreatorTool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e268a0b97ec21eb4181d17530e323c9b
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class NoiseCreatorTool
	{
		private const string SHADER_NAME_FRACTAL_NOISE = "AllIn13DShaderFractalNoise";
		private const string SHADER_NAME_WORLEY_NOISE = "AllIn13DShaderWorleyNoise";

		public enum NoiseTypes
		{
			Fractal,
			Perlin,
			Billow,
			Voronoi,
			Water,
			Cellular,
			Cells1,
			Cells2
		}

		public NoiseCreatorValues values;

		public NoiseCreatorTool()
		{
			values = new NoiseCreatorValues();

			NoiseSetMaterial();
			CheckCreationNoiseTextures();
			UpdateNoiseMatAndRender();
			CreateNoiseTex();
		}

		public void CreateNoiseTex()
		{
			int texSize = (int)values.noiseSize;
			values.finalNoiseTex = new Texture2D(texSize, texSize);
			RenderTexture finalRenderTarget = new RenderTexture(values.finalNoiseTex.width, values.finalNoiseTex.height, 0, RenderTextureFormat.ARGB32);
			Graphics.Blit(values.finalNoiseTex, finalRenderTarget, values.noiseMaterial);
			values.finalNoiseTex.ReadPixels(new Rect(0, 0, finalRenderTarget.width, finalRenderTarget.height), 0, 0);
			values.finalNoiseTex.Apply();
		}

		public void CheckCreationNoiseTextures()
		{
			if (values.noisePreview == null)
			{
				values.noisePreview = new Texture2D(256, 256);
			}

			if (values.noiseRenderTarget == null)
			{
				values.noiseRenderTarget = new RenderTexture(values.noisePreview.width, values.noisePreview.height, 0, RenderTextureFormat.ARGB32);
			}
		}

		public void UpdateNoiseMatAndRender()
		{
			if (values.noiseType == NoiseTypes.Fractal || values.noiseType == NoiseTypes.Perlin || values.noiseType == NoiseTypes.Billow)
			{
				values.noiseMaterial.SetFloat("_EndBand", values.noiseFractalAmount);
			}
			else values.noiseMaterial.SetFloat("_Jitter", values.noiseJitter);

			values.noiseMaterial.SetFloat("_ScaleX", values.noiseScaleX);
			values.noiseMaterial.SetFloat("_ScaleY", values.noiseScaleY);
			values.noiseMaterial.SetFloat("_Offset", (float)values.noiseSeed);
			values.noiseMaterial.SetFloat("_Contrast", values.noiseContrast);
			values.noiseMaterial.SetFloat("_Brightness", values.noiseBrightness);
			values.noiseMaterial.SetFloat("_Invert", values.noiseInverted ? 1f : 0f);

			Graphics.Blit(values.noisePreview, values.noiseRenderTarget, values.noiseMaterial);
			values.noisePreview.ReadPixels(new Rect(0, 0, values.noiseRenderTarget.width, values.noiseRenderTarget.height), 0, 0);
			values.noisePreview.Apply();
		}

		public void NoiseSetMaterial()
		{
			if (values.noiseType == NoiseTypes.Fractal || values.noiseType == NoiseTypes.Perlin || values.noiseType == NoiseTypes.Billow)
			{
				values.isFractalNoise = true;
				values.noiseMaterial = new Material(EditorUtils.FindShader(SHADER_NAME_FRACTAL_NOISE));
				values.noiseScaleX = 4f;
				values.noiseScaleY = 4f;
			}
			else
			{
				values.isFractalNoise = false;
				values.noiseMaterial = new Material(EditorUtils.FindShader(SHADER_NAME_WORLEY_NOISE));
				values.noiseScaleX = 10f;
				values.noiseScaleY = 10f;
			}

			switch (values.noiseType)
			{
				case NoiseTypes.Fractal:
					values.noiseFractalAmount = 8f;
					values.noiseMaterial.SetFloat("_Fractal", 1);
					break;
				case NoiseTypes.Perlin:
					values.noiseFractalAmount = 1f;
					values.noiseMaterial.SetFloat("_Fractal", 1);
					break;
				case NoiseTypes.Billow:
					values.noiseFractalAmount = 4f;
					values.noiseMaterial.SetFloat("_Fractal", 0);
					break;
				case NoiseTypes.Voronoi:
					values.noiseMaterial.SetFloat("_NoiseType", 0f);
					break;
				case NoiseTypes.Water:
					values.noiseMaterial.SetFloat("_NoiseType", 3f);
					break;
				case NoiseTypes.Cellular:
					values.noiseMaterial.SetFloat("_NoiseType", 4f);
					break;
				case NoiseTypes.Cells1:
					values.noiseMaterial.SetFloat("_NoiseType", 1f);
					break;
				case NoiseTypes.Cells2:
					values.noiseMaterial.SetFloat("_NoiseType", 2f);
					break;
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Tools/NoiseCreatorTool.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Tools/NormalMapCreatorTool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 377ab8b8193dc364ba6f648292b747d9
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class NormalMapCreatorTool
	{
		public Texture2D targetNormalImage;
		public int normalSmoothing;
		public float normalStrength;
		public int isComputingNormals;

		public Texture2D CreateNormalMap()
		{
			int width = targetNormalImage.width;
			int height = targetNormalImage.height;
			Color[] sourcePixels = targetNormalImage.GetPixels();
			Color[] resultPixels = new Color[width * height];
			Vector3 vScale = new Vector3(0.3333f, 0.3333f, 0.3333f);

			for (int y = 0; y < height; y++)
			{
				for (int x = 0; x < width; x++)
				{
					int index = x + y * width;
					Vector3 cSampleNegXNegY = GetPixelClamped(sourcePixels, x - 1, y - 1, width, height);
					Vector3 cSampleZerXNegY = GetPixelClamped(sourcePixels, x, y - 1, width, height);
					Vector3 cSamplePosXNegY = GetPixelClamped(sourcePixels, x + 1, y - 1, width, height);
					Vector3 cSampleNegXZerY = GetPixelClamped(sourcePixels, x - 1, y, width, height);
					Vector3 cSamplePosXZerY = GetPixelClamped(sourcePixels, x + 1, y, width, height);
					Vector3 cSampleNegXPosY = GetPixelClamped(sourcePixels, x - 1, y + 1, width, height);
					Vector3 cSampleZerXPosY = GetPixelClamped(sourcePixels, x, y + 1, width, height);
					Vector3 cSamplePosXPosY = GetPixelClamped(sourcePixels, x + 1, y + 1, width, height);

					float fSampleNegXNegY = Vector3.Dot(cSampleNegXNegY, vScale);
					float fSampleZerXNegY = Vector3.Dot(cSampleZerXNegY, vScale);
					float fSamplePosXNegY = Vector3.Dot(cSamplePosXNegY, vScale);
					float fSampleNegXZerY = Vector3.Dot(cSampleNegXZerY, vScale);
					float fSamplePosXZerY = Vector3.Dot(cSamplePosXZerY, vScale);
					float fSampleNegXPosY = Vector3.Dot(cSampleNegXPosY, vScale);
					float fSampleZerXPosY = Vector3.Dot(cSampleZerXPosY, vScale);
					float fSamplePosXPosY = Vector3.Dot(cSamplePosXPosY, vScale);

					float edgeX = (fSampleNegXNegY - fSamplePosXNegY) * 0.25f + (fSampleNegXZerY - fSamplePosXZerY) * 0.5f + (fSampleNegXPosY - fSamplePosXPosY) * 0.25f;
					float edgeY = (fSampleNegXNegY - fSampleNegXPosY) * 0.25f + (fSampleZerXNegY - fSampleZerXPosY) * 0.5f + (fSamplePosXNegY - fSamplePosXPosY) * 0.25f;

					Vector2 vEdge = new Vector2(edgeX, edgeY) * normalStrength;
					Vector3 norm = new Vector3(vEdge.x, vEdge.y, 1.0f).normalized;
					resultPixels[index] = new Color(norm.x * 0.5f + 0.5f, norm.y * 0.5f + 0.5f, norm.z * 0.5f + 0.5f, 1);
				}
			}

			if (normalSmoothing > 0)
			{
				resultPixels = SmoothNormals(resultPixels, width, height, normalSmoothing);
			}

			Texture2D texNormal = new Texture2D(width, height, TextureFormat.RGB24, false, false);
			texNormal.SetPixels(resultPixels);
			texNormal.Apply();
			return texNormal;
		}

		private Vector3 GetPixelClamped(Color[] pixels, int x, int y, int width, int height)
		{
			x = Mathf.Clamp(x, 0, width - 1);
			y = Mathf.Clamp(y, 0, height - 1);
			Color c = pixels[x + y * width];
			return new Vector3(c.r, c.g, c.b);
		}

		private Color[] SmoothNormals(Color[] pixels, int width, int height, int normalSmooth)
		{
			Color[] smoothedPixels = new Color[pixels.Length];
			float step = 0.00390625f * normalSmooth;

			for (int y = 0; y < height; y++)
			{
				for (int x = 0; x < width; x++)
				{
					float pixelsToAverage = 0.0f;
					Color c = pixels[x + y * width];
					pixelsToAverage++;

					for (int offsetY = -normalSmooth; offsetY <= normalSmooth; offsetY++)
					{
						for (int offsetX = -normalSmooth; offsetX <= normalSmooth; offsetX++)
						{
							if (offsetX == 0 && offsetY == 0) continue;

							int sampleX = Mathf.Clamp(x + offsetX, 0, width - 1);
							int sampleY = Mathf.Clamp(y + offsetY, 0, height - 1);

							c += pixels[sampleX + sampleY * width];
							pixelsToAverage++;
						}
					}

					smoothedPixels[x + y * width] = c / pixelsToAverage;
				}
			}

			return smoothedPixels;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Tools/NormalMapCreatorTool.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Tools/RenderMaterialToImageTool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 543c3fdde2688b6428241f7df95a671a
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.IO;
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class RenderMaterialToImageTool
	{
		public static void RenderAndSaveTexture(Material targetMaterial, Texture targetTexture, float scaleSlider, string folderPath, string fileName)
		{
			RenderTexture renderTarget = new RenderTexture((int)(targetTexture.width * scaleSlider),
				(int)(targetTexture.height * scaleSlider), 0, RenderTextureFormat.ARGB32);
			Graphics.Blit(targetTexture, renderTarget, targetMaterial);
			Texture2D resultTex = new Texture2D(renderTarget.width, renderTarget.height, TextureFormat.ARGB32, false);
			resultTex.ReadPixels(new Rect(0, 0, renderTarget.width, renderTarget.height), 0, 0);
			resultTex.Apply();
			
			if (!Directory.Exists(folderPath))
			{
				EditorUtility.DisplayDialog("The desired Material to Image Save Path doesn't exist",
					"Go to Window -> AllIn1VfxWindow and set a valid folder", "Ok");
				return;
			}

			string fullPath = Path.Combine(folderPath, fileName + ".png");
			fullPath = AssetDatabase.GenerateUniqueAssetPath(fullPath);

			string correctedFileName = fullPath.Replace(folderPath, string.Empty);
			
			fullPath = EditorUtility.SaveFilePanel("Save Render Image", folderPath, fileName, "png");

			byte[] bytes = resultTex.EncodeToPNG();
			File.WriteAllBytes(fullPath, bytes);
			AssetDatabase.ImportAsset(fullPath);
			AssetDatabase.Refresh();
			GameObject.DestroyImmediate(resultTex);

			EditorUtils.PingPath(fullPath);

			EditorUtils.ShowNotification("Render Image saved to: " + fullPath + " with scale: " + scaleSlider +
			" (it can be changed in Tools -> AllIn1 -> 3DShaderWindow)");
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Tools/RenderMaterialToImageTool.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Tools/TextureEditorTool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 0d7236daca41e9541a940c4cb32fca47
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System;
using System.IO;
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class TextureEditorTool
	{
		public Texture2D editorTexInput;
		public Texture2D editorTex;
		public Texture2D cleanEditorTex;

		public TextureEditorValues values;

		public void Setup()
		{
			EditorUtils.SetTextureReadWrite(AssetDatabase.GetAssetPath(editorTexInput), true);

			editorTex = new Texture2D(editorTexInput.width, editorTexInput.height);
			editorTex.SetPixels(editorTexInput.GetPixels());
			editorTex.Apply();

			float aspectRatio = (float)editorTex.width / (float)editorTex.height;
			int width = Mathf.Min(editorTex.width, 256);
			editorTex = ScaleTexture(editorTex, width, (int)(width / aspectRatio));

			cleanEditorTex = new Texture2D(editorTex.width, editorTex.height);
			cleanEditorTex.SetPixels(editorTex.GetPixels());
			cleanEditorTex.Apply();

			values = new TextureEditorValues();

			RecalculateEditorTexture();
		}

		//private void SetTextureReadWrite(string assetPath, bool enable)
		//{
		//	TextureImporter tImporter = AssetImporter.GetAtPath(assetPath) as TextureImporter;
		//	if (tImporter != null)
		//	{
		//		tImporter.isReadable = enable;
		//		tImporter.SaveAndReimport();
		//	}
		//}

		private Texture2D ScaleTexture(Texture2D source, int targetWidth, int targetHeight)
		{
			targetWidth = Mathf.ClosestPowerOfTwo(targetWidth);
			targetHeight = Mathf.ClosestPowerOfTwo(targetHeight);

			Texture2D result = new Texture2D(targetWidth, targetHeight, source.format, true);
			Color[] scaledPixels = result.GetPixels(0);
			float incX = ((float)1 / source.width) * ((float)source.width / targetWidth);
			float incY = ((float)1 / source.height) * ((float)source.height / targetHeight);
			for (int px = 0; px < scaledPixels.Length; px++) scaledPixels[px] = source.GetPixelBilinear(incX * ((float)px % targetWidth), incY * (float)Mathf.Floor(px / targetWidth));

			result.SetPixels(scaledPixels, 0);
			result.Apply();
			return result;
		}

		public void RecalculateEditorTexture()
		{
			Color[] pixels = cleanEditorTex.GetPixels();
			int texWidth = cleanEditorTex.width;
			int texHeight = cleanEditorTex.height;

			ComputeImageColorFilters(pixels);

			editorTex = new Texture2D(texWidth, texHeight);
			editorTex.SetPixels(pixels);
			editorTex.Apply();
		}

		private void ComputeImageColorFilters(Color[] pixels)
		{
			float cosHsv = values.saturation * Mathf.Cos(values.hue * 3.14159265f / 180f);
			float sinHsv = values.saturation * Mathf.Sin(values.hue * 3.14159265f / 180f);

			for (int i = 0; i < pixels.Length; i++)
			{
				pixels[i].r = Mathf.Clamp01(((pixels[i].r - 0.5f) * values.contrast) + 0.5f);
				pixels[i].g = Mathf.Clamp01(((pixels[i].g - 0.5f) * values.contrast) + 0.5f);
				pixels[i].b = Mathf.Clamp01(((pixels[i].b - 0.5f) * values.contrast) + 0.5f);

				pixels[i] = new Color(Mathf.Clamp01(pixels[i].r * (1 + values.brightness)), Mathf.Clamp01(pixels[i].g * (1 + values.brightness)), Mathf.Clamp01(pixels[i].b * (1 + values.brightness)), pixels[i].a);

				pixels[i].r = Mathf.Pow(Mathf.Abs(pixels[i].r), values.gamma);
				pixels[i].g = Mathf.Pow(Mathf.Abs(pixels[i].g), values.gamma);
				pixels[i].b = Mathf.Pow(Mathf.Abs(pixels[i].b), values.gamma);

				pixels[i].r = Mathf.Clamp01(pixels[i].r * Mathf.Pow(2, values.exposure));
				pixels[i].g = Mathf.Clamp01(pixels[i].g * Mathf.Pow(2, values.exposure));
				pixels[i].b = Mathf.Clamp01(pixels[i].b * Mathf.Pow(2, values.exposure));

				pixels[i] *= values.editorColorTint;

				Color hueShiftColor = pixels[i];
				hueShiftColor.r = Mathf.Clamp01((.299f + .701f * cosHsv + .168f * sinHsv) * pixels[i].r + (.587f - .587f * cosHsv + .330f * sinHsv) * pixels[i].g + (.114f - .114f * cosHsv - .497f * sinHsv) * pixels[i].b);
				hueShiftColor.g = Mathf.Clamp01((.299f - .299f * cosHsv - .328f * sinHsv) * pixels[i].r + (.587f + .413f * cosHsv + .035f * sinHsv) * pixels[i].g + (.114f - .114f * cosHsv + .292f * sinHsv) * pixels[i].b);
				hueShiftColor.b = Mathf.Clamp01((.299f - .3f * cosHsv + 1.25f * sinHsv) * pixels[i].r + (.587f - .588f * cosHsv - 1.05f * sinHsv) * pixels[i].g + (.114f + .886f * cosHsv - .203f * sinHsv) * pixels[i].b);
				pixels[i] = hueShiftColor;

				if (values.invert) pixels[i] = new Color(1 - pixels[i].r, 1 - pixels[i].g, 1 - pixels[i].b, pixels[i].a);

				if (values.greyscale || values.fullWhite || values.alphaGreyscale)
				{
					float greyScale = pixels[i].r * 0.59f + pixels[i].g * 0.3f + pixels[i].b * 0.11f;

					if (values.fullWhite) pixels[i] = new Color(1, 1, 1, greyScale);
					else if (values.greyscale) pixels[i] = new Color(greyScale, greyScale, greyScale, pixels[i].a);

					if (values.alphaGreyscale) pixels[i] = new Color(pixels[i].r, pixels[i].g, pixels[i].b, greyScale);
				}
				
				if (values.alphaIsOne) pixels[i] = new Color(pixels[i].r, pixels[i].g, pixels[i].b, 1f);

				if (values.blackBackground)
				{
					if (pixels[i].a < 0.05f) pixels[i] = new Color(pixels[i].a, pixels[i].a, pixels[i].a, 1);
					else pixels[i] = new Color(pixels[i].r, pixels[i].g, pixels[i].b, 1);
				}
			}
		}

		public void FlipEditorTexture(bool isHorizontal)
		{
			Color[] pixels = editorTex.GetPixels();
			Color[] pixelsClean = cleanEditorTex.GetPixels();
			int texWidth = editorTex.width;
			int texHeight = editorTex.height;

			if (isHorizontal)
			{
				pixels = FlipHorizontal(pixels, texWidth, texHeight);
				pixelsClean = FlipHorizontal(pixelsClean, texWidth, texHeight);
				values.isFlipHorizontal = !values.isFlipHorizontal;
			}
			else
			{
				pixels = FlipVertical(pixels, texWidth, texHeight);
				pixelsClean = FlipVertical(pixelsClean, texWidth, texHeight);
				values.isFlipVertical = !values.isFlipVertical;
			}

			editorTex = new Texture2D(texWidth, texHeight);
			editorTex.SetPixels(pixels);
			editorTex.Apply();
			cleanEditorTex = new Texture2D(texWidth, texHeight);
			cleanEditorTex.SetPixels(pixelsClean);
			cleanEditorTex.Apply();
		}

		private Color[] FlipHorizontal(Color[] pixels, int width, int height)
		{
			Color[] outputPixels = new Color[pixels.Length];
			for (int y = 0; y < height; y++)
			{
				for (int x = 0; x < width; x++)
				{
					int i1 = GetPixelIndex(x, y, width);
					int i2 = GetPixelIndex(width - 1 - x, y, width);
					outputPixels[i1] = pixels[i2];
				}
			}

			return outputPixels;
		}

		private Color[] FlipVertical(Color[] pixels, int width, int height)
		{
			Color[] outputPixels = new Color[pixels.Length];
			for (int y = 0; y < height; y++)
			{
				for (int x = 0; x < width; x++)
				{
					int i1 = GetPixelIndex(x, y, width);
					int i2 = GetPixelIndex(x, height - 1 - y, width);
					outputPixels[i1] = pixels[i2];
				}
			}

			return outputPixels;
		}

		private int GetPixelIndex(int x, int y, int width)
		{
			return y * width + x;
		}

		public void RotateEditorTextureLeft()
		{
			Color[] pixels = editorTex.GetPixels();
			Color[] pixelsClean = cleanEditorTex.GetPixels();
			int texWidth = editorTex.width;
			int texHeight = editorTex.height;

			pixels = RotateClockWise(pixels, texWidth, texHeight);
			pixelsClean = RotateClockWise(pixelsClean, texWidth, texHeight);

			editorTex = new Texture2D(texHeight, texWidth); //Width and Height get swapped to account for rotation
			editorTex.SetPixels(pixels);
			editorTex.Apply();
			cleanEditorTex = new Texture2D(texHeight, texWidth); //Width and Height get swapped to account for rotation
			cleanEditorTex.SetPixels(pixelsClean);
			cleanEditorTex.Apply();

			values.rotationAmount = (values.rotationAmount + 1) % 4;
		}

		public Color[] RotateClockWise(Color[] pixels, int width, int height)
		{
			Color[] outputPixels = new Color[pixels.Length];
			for (int y = 0; y < height; y++)
			{
				for (int x = 0; x < width; x++)
				{
					int i1 = GetPixelIndex(x, height - y - 1, width);
					int i2 = GetPixelIndex(y, x, height);
					outputPixels[i2] = pixels[i1];
				}
			}

			return outputPixels;
		}

		private void ComputeFinalTexture()
		{
			Color[] pixels;
			int texWidth, texHeight;

			for (int i = 0; i < values.rotationAmount; i++)
			{
				texWidth = editorTexInput.width;
				texHeight = editorTexInput.height;
				pixels = editorTexInput.GetPixels();
				pixels = RotateClockWise(pixels, texWidth, texHeight);
				editorTexInput = new Texture2D(texHeight, texWidth);
				editorTexInput.SetPixels(pixels);
				editorTexInput.Apply();
			}

			pixels = editorTexInput.GetPixels();
			texWidth = editorTexInput.width;
			texHeight = editorTexInput.height;
			if (values.isFlipHorizontal) 
			{
				pixels = FlipHorizontal(pixels, texWidth, texHeight);
			}
			if (values.isFlipVertical)
			{
				pixels = FlipVertical(pixels, texWidth, texHeight);
			}

			ComputeImageColorFilters(pixels);
			editorTexInput = new Texture2D(texWidth, texHeight);
			editorTexInput.SetPixels(pixels);
			editorTexInput.Apply();

			if (Math.Abs(values.exportScale - 1f) > 0.05f)
			{
				editorTexInput = ScaleTexture(editorTexInput, (int)(texWidth * values.exportScale), (int)(texHeight * values.exportScale));
			}
		}

		public void SaveAsPNG()
		{
			string fullPath = AssetDatabase.GetAssetPath(editorTexInput);
			string path = fullPath.Replace(Path.GetFileName(fullPath), "");

			fullPath = AssetDatabase.GenerateUniqueAssetPath(fullPath);

			string fileName = fullPath.Replace(path, "");
			fileName = fileName.Replace(".png", "");
			fullPath = EditorUtility.SaveFilePanel("Save Image", path, fileName, "png");
			if (fullPath.Length == 0) 
			{
				return;
			}

			string pingPath = fullPath;

			ComputeFinalTexture();

			byte[] bytes = editorTexInput.EncodeToPNG();
			File.WriteAllBytes(pingPath, bytes);
			AssetDatabase.ImportAsset(pingPath);
			AssetDatabase.Refresh();
			EditorGUIUtility.PingObject(AssetDatabase.LoadAssetAtPath(pingPath, typeof(Texture)));

			EditorUtils.ShowNotification("Edited Image saved to: " + fullPath);

			editorTexInput = null;
			editorTex = null;
			cleanEditorTex = null;

			SetTextureEditorDefaultValues();
		}

		private void SetTextureEditorDefaultValues()
		{
			values.SetDefault();
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Tools/TextureEditorTool.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Tools/TextureEditorValues.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 32d12b4e3bfea4e42bca81b1abfb8e7b
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class TextureEditorValues
	{
		public Color editorColorTint;
		public float brightness;
		public float contrast;
		public float gamma;
		public float exposure;
		public float saturation;
		public float hue;
		public bool invert;
		public bool greyscale;
		public bool fullWhite;
		public bool blackBackground;
		public bool alphaGreyscale;
		public bool alphaIsOne;
		public bool showOriginalImage;
		public bool isFlipHorizontal;
		public bool isFlipVertical;
		public int rotationAmount;
		public float exportScale;

		public TextureEditorValues()
		{
			SetDefault();
		}

		public void SetDefault()
		{
			editorColorTint = Color.white;
			brightness = 0f;
			contrast = 1f;
			gamma = 1f;
			exposure = 0f;
			saturation = 1f;
			hue = 0f;
			invert = false;
			greyscale = false;
			fullWhite = false;
			blackBackground = false;
			alphaGreyscale = false;
			showOriginalImage = false;
			isFlipHorizontal = false;
			isFlipVertical = false;
			rotationAmount = 0;
			exportScale = 1f;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Tools/TextureEditorValues.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/URPConfigurator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 80f03ed0410db654a95ec1e8b07e3b73
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.Collections.Generic;
using System.Reflection;
using UnityEditor;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEditor.Rendering;
using System.IO;


#if ALLIN13DSHADER_URP

using UnityEditor.Rendering.Universal;
#if UNITY_6000_0_OR_NEWER
using UnityEngine.Rendering.Universal;
#else
using UnityEngine.Experimental.Rendering.Universal;
using UnityEngine.Rendering.Universal;
#endif

#endif

namespace AllIn13DShader
{
	public static class URPConfigurator
	{
#if ALLIN13DSHADER_URP

		public static void Configure()
		{
			ConfigureRenderPipeline();
			ConvertDemoMaterials();

			GlobalConfiguration.instance.URPConfiguredFirstTime = true;
		}

		public static void ConfigureRenderPipeline()
		{
			UniversalRenderPipelineAsset pipeline = GraphicsSettings.currentRenderPipeline as UniversalRenderPipelineAsset;
			ScriptableRenderer scriptableRenderer = pipeline.GetRenderer(0);

			FieldInfo rendererDataListFieldInfo = typeof(UniversalRenderPipelineAsset).GetField("m_RendererDataList", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);
			ScriptableRendererData[] scriptableRendererDatas = rendererDataListFieldInfo.GetValue(pipeline) as ScriptableRendererData[];

			UniversalRendererData universalRendererData = scriptableRendererDatas[0] as UniversalRendererData;

			Undo.RecordObject(universalRendererData, "");

			universalRendererData.depthPrimingMode = DepthPrimingMode.Disabled;


			string outlinePassName = "OutlinePass";
			string outlineRenderFeatureName = "Render Feature - Outline";

			RenderObjects outlineRenderFeature = null;
			bool outlineRenderFeatureFound = false;

			List<ScriptableRendererFeature> rendererFeatures = universalRendererData.rendererFeatures;
			foreach (ScriptableRendererFeature scriptableRendererFeature in rendererFeatures)
			{
				if (scriptableRendererFeature is RenderObjects)
				{
					RenderObjects renderObjects = (RenderObjects)scriptableRendererFeature;

					string[] passNames = renderObjects.settings.filterSettings.PassNames;
					foreach (string passName in passNames)
					{
						if (passName == outlinePassName)
						{
							outlineRenderFeature = renderObjects;
							outlineRenderFeatureFound = true;
						}
					}
				}

				if (outlineRenderFeatureFound)
				{
					break;
				}
			}

			if (!outlineRenderFeatureFound)
			{
				outlineRenderFeature = RenderObjects.CreateInstance<RenderObjects>();
				outlineRenderFeature.name = outlineRenderFeatureName;

				rendererFeatures.Add(outlineRenderFeature);

				FieldInfo fieldInfoRenderFeaturesMap = typeof(UniversalRendererData).GetField("m_RendererFeatureMap", BindingFlags.Instance | BindingFlags.NonPublic);
				List<long> renderFeaturesMapList = fieldInfoRenderFeaturesMap.GetValue(universalRendererData) as List<long>;

				string guid;
				long localID;
				AssetDatabase.TryGetGUIDAndLocalFileIdentifier(outlineRenderFeature, out guid, out localID);
				renderFeaturesMapList.Add(localID);

				AssetDatabase.AddObjectToAsset(outlineRenderFeature, universalRendererData);
				EditorUtility.SetDirty(outlineRenderFeature);
			}

			outlineRenderFeature.name = outlineRenderFeatureName;
			outlineRenderFeature.settings.filterSettings.RenderQueueType = RenderQueueType.Opaque;
			outlineRenderFeature.settings.filterSettings.LayerMask = ~0;
			outlineRenderFeature.settings.filterSettings.PassNames = new string[] { "OutlinePass" };

			EditorUtility.SetDirty(outlineRenderFeature);
			EditorUtility.SetDirty(universalRendererData);

			FieldInfo fieldInfoRendererFeatures = typeof(UniversalRendererData).GetField("m_RendererFeatures", BindingFlags.Instance | BindingFlags.NonPublic);
			fieldInfoRendererFeatures.SetValue(universalRendererData, rendererFeatures);

			EditorUtility.SetDirty(universalRendererData);
			EditorUtility.SetDirty(pipeline);
			AssetDatabase.SaveAssets();
		}

		public static void ConvertDemoMaterials()
		{
			StandardUpgrader standardUpgrader = new StandardUpgrader("Standard");

			string dirPath = Path.Combine(GlobalConfiguration.instance.RootPluginPath, "Demo/Materials/StandardExamples");
			DirectoryInfo dir = new DirectoryInfo(dirPath);

			List<string> materialsPathsToConvert = new List<string>();
			FileInfo[] files = dir.GetFiles("*.mat");
			for (int i = 0; i < files.Length; i++)
			{
				string materialPath = Path.Combine(dirPath, files[i].Name);
				materialsPathsToConvert.Add(materialPath);
			}

			for (int i = 0; i < materialsPathsToConvert.Count; i++)
			{
				Material mat = AssetDatabase.LoadAssetAtPath<Material>(materialsPathsToConvert[i]);
				standardUpgrader.Upgrade(mat, MaterialUpgrader.UpgradeFlags.None);
			}
		}
		
		public static void AllAssetProcessed()
		{
			if (!GlobalConfiguration.instance.URPConfiguredFirstTime)
			{
				Debug.Log("Configuring plugin to work with URP for the first time...");
				Configure();
			}
		}
#endif
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/URPConfigurator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Utilities/RenderPipelineChecker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 5d4b26b0600ea8841a3d0638622becb6
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEditor.Build;
using UnityEditor.Callbacks;

#if UNITY_2019_3_OR_NEWER

namespace AllIn13DShader
{
	public static class RenderPipelineChecker
	{
		public enum RenderPipeline
		{
			NONE = 0,
			BIRP = 1,
			URP = 2,
			HDRP = 3
		}

		private const string SYMBOL_URP = "ALLIN13DSHADER_URP";
		private const string SYMBOL_HDRP = "ALLIN13DSHADER_HDRP";
		private const string SYMBOL_BIRP = "ALLIN13DSHADER_BIRP";


		private const string HDRP_PACKAGE = "HDRenderPipelineAsset";
		private const string URP_PACKAGE = "UniversalRenderPipelineAsset";

		public static bool IsHDRP
		{
			get; private set;
		}
		public static bool IsURP
		{
			get; private set;
		}
		public static bool IsStandardRP
		{
			get; private set;
		}

		public static RenderPipeline CurrentRenderPipeline
		{
			get; private set;
		}

		public static void RefreshData()
		{
			IsHDRP = DoesTypeExist(HDRP_PACKAGE);
			IsURP = DoesTypeExist(URP_PACKAGE);

			if (!(IsHDRP || IsURP))
			{
				IsStandardRP = true;
			}

			else if (IsURP)
			{
				CurrentRenderPipeline = RenderPipeline.URP;
			}
			else if (IsHDRP)
			{
				CurrentRenderPipeline = RenderPipeline.HDRP;
			}
			else
			{
				CurrentRenderPipeline = RenderPipeline.BIRP;
			}
		}

		public static bool DoesTypeExist(string className)
		{
			var foundType = (from assembly in AppDomain.CurrentDomain.GetAssemblies()
				from type in GetTypesSafe(assembly)
				where type.Name == className
				select type).FirstOrDefault();

			return foundType != null;
		}

		public static IEnumerable<Type> GetTypesSafe(System.Reflection.Assembly assembly)
		{
			Type[] types;

			try
			{
				types = assembly.GetTypes();
			}
			catch (ReflectionTypeLoadException e)
			{
				types = e.Types;
			}

			return types.Where(x => x != null);
		}

		public static bool IsRenderPipelineDefined()
		{
			bool res = false;

			BuildTarget buildTarget = EditorUserBuildSettings.activeBuildTarget;
			BuildTargetGroup buildTargetGroup = EditorUserBuildSettings.selectedBuildTargetGroup;

			NamedBuildTarget namedBuildTarget = NamedBuildTarget.FromBuildTargetGroup(buildTargetGroup);
			string[] defineSymbols = new string[0];
			PlayerSettings.GetScriptingDefineSymbols(namedBuildTarget, out defineSymbols);

			for (int i = defineSymbols.Length - 1; i >= 0; i--)
			{
				if (defineSymbols[i] == SYMBOL_URP || defineSymbols[i] == SYMBOL_HDRP || defineSymbols[i] == SYMBOL_BIRP)
				{
					res = true;
				}
			}

			return res;
		}

		[DidReloadScripts]
		public static void ScriptsReloaded()
		{
			RefreshData();

			RenderPipeline lastRenderPipeline = (RenderPipeline)EditorPrefs.GetInt(Constants.LAST_RENDER_PIPELINE_CHECKED_KEY, 0);
			if (lastRenderPipeline != CurrentRenderPipeline || !IsRenderPipelineDefined())
			{
				BuildTarget buildTarget = EditorUserBuildSettings.activeBuildTarget;
				BuildTargetGroup buildTargetGroup = EditorUserBuildSettings.selectedBuildTargetGroup;

				NamedBuildTarget namedBuildTarget = NamedBuildTarget.FromBuildTargetGroup(buildTargetGroup);
				string[] defineSymbols = new string[0];
				PlayerSettings.GetScriptingDefineSymbols(namedBuildTarget, out defineSymbols);

				for (int i = defineSymbols.Length - 1; i >= 0; i--)
				{
					if (defineSymbols[i] == SYMBOL_URP || defineSymbols[i] == SYMBOL_HDRP || defineSymbols[i] == SYMBOL_BIRP)
					{
						ArrayUtility.RemoveAt(ref defineSymbols, i);
					}
				}

				if (IsURP)
				{
					ArrayUtility.Add(ref defineSymbols, SYMBOL_URP);
				}
				else if (IsHDRP)
				{
					ArrayUtility.Add(ref defineSymbols, SYMBOL_HDRP);
				}
				else
				{
					ArrayUtility.Add(ref defineSymbols, SYMBOL_BIRP);
				}

				PlayerSettings.SetScriptingDefineSymbols(namedBuildTarget, defineSymbols);

				EditorPrefs.SetInt(Constants.LAST_RENDER_PIPELINE_CHECKED_KEY, (int)CurrentRenderPipeline);
			}
		}
	}
}

#endif
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Utilities/RenderPipelineChecker.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Utilities/RightClickMaterialCreator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: adcc78e01c8d09c46b440d328c933fc8
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.IO;
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public static class RightClickMaterialCreator
	{
		private const string MENU_PATH = "Assets/Create/AllIn13DShader/Materials";

		public static void CreateMaterial(Material matSource)
		{
			string saveFolderPath = AssetDatabase.GetAssetPath(Selection.activeObject);

			if (!AssetDatabase.IsValidFolder(saveFolderPath))
			{
				saveFolderPath = GlobalConfiguration.instance.MaterialSavePath;
			}

			Material mat = new Material(matSource);

			string materialPath = Path.Combine(saveFolderPath, AllIn13DShaderConfig.MATERIAL_NAME_DEFAULT);
			materialPath = AssetDatabase.GenerateUniqueAssetPath(materialPath);
			AssetDatabase.CreateAsset(mat, materialPath);

			AssetDatabase.SaveAssets();
			AssetDatabase.Refresh();

			Selection.activeObject = mat;
		}

		private static GlobalConfiguration GetGlobalConfiguration()
		{
			GlobalConfiguration res = EditorUtils.FindAsset<GlobalConfiguration>("GlobalConfiguration");
			return res;
		}

		[MenuItem(MENU_PATH + "/Default Material", false, 1)]
		public static void CreateMaterialDefault()
		{
			GlobalConfiguration globalConfiguration = GetGlobalConfiguration();
			CreateMaterial(globalConfiguration.defaultPreset);
		}

		[MenuItem(MENU_PATH + "/Toon Material", false, 1)]
		public static void CreateMaterialToon()
		{
			GlobalConfiguration globalConfiguration = GetGlobalConfiguration();
			CreateMaterial(globalConfiguration.toonMaterial);
		}

		[MenuItem(MENU_PATH + "/PBR Material", false, 1)]
		public static void CreateMaterialPBR()
		{
			GlobalConfiguration globalConfiguration = GetGlobalConfiguration();
			CreateMaterial(globalConfiguration.standardPBRMaterial);
		}

		[MenuItem(MENU_PATH + "/Basic Lighting Material", false, 1)]
		public static void CreateMaterialBasic()
		{
			GlobalConfiguration globalConfiguration = GetGlobalConfiguration();
			CreateMaterial(globalConfiguration.standardBasicMaterial);
		}

		[MenuItem(MENU_PATH + "/AllIn13D Look", false, 1)]
		public static void CreateMaterialAllIn3DLook()
		{
			GlobalConfiguration globalConfiguration = GetGlobalConfiguration();
			CreateMaterial(globalConfiguration.allIn13dDShaderLookMaterial);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Utilities/RightClickMaterialCreator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Windows/AllIn13DShaderWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 51e8848e3c58c334eacf2c12d0e69b68
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.IO;
using UnityEditor;
using UnityEditor.Callbacks;
using UnityEditorInternal;
using UnityEngine;

namespace AllIn13DShader
{
	public class AllIn13DShaderWindow : EditorWindow
	{
		private Vector2 scrollPosition;

		private int currTab = 0;
		private string[] tabsNames;

		private CommonStyles commonStyles;
		private GlobalConfiguration globalConfiguration;

		private Texture imageInspector;

		private TextureEditorTool textureEditorTool;
		private TextureEditorValuesDrawer textureEditorValuesDrawer;

		private NormalMapCreatorTool normalMapCreatorTool;
		private NormalMapCreatorDrawer normalMapCreatorDrawer;

		private GradientCreatorTool gradientCreatorTool;
		private GradientCreatorDrawer gradientCreatorDrawer;

		private AtlasPackerTool atlasPackerTool;
		private AtlasPackerDrawer atlasPackerDrawer;

		private NoiseCreatorTool noiseCreatorTool;
		private NoiseCreatorDrawer noiseCreatorDrawer;

		private OverrideMaterialsTabDrawer overrideMaterialsTabDrawer;
		private OtherTabDrawer otherTabDrawer;
		private URPSettingsDrawer urpSettingsDrawer;



		private bool initialized;


		[MenuItem("Tools/AllIn1/3DShaderWindow")]
		public static void ShowAllIn13DShaderWindow() => GetWindow<AllIn13DShaderWindow>("All In 1 3DShader Window");

		private void Init()
		{
			//EditorApplication.wantsToQuit += OnWantsToQuit;

			commonStyles = new CommonStyles();
			globalConfiguration = EditorUtils.FindAssetByName<GlobalConfiguration>("GlobalConfiguration");


			scrollPosition = Vector2.zero;

#if ALLIN13DSHADER_URP
			tabsNames = new string[] { "Save Paths", "Texture Editor", "Texture Creators", "Override Materials", "Default Look", "URP Settings"};
#else
			tabsNames = new string[] { "Save Paths", "Texture Editor", "Texture Creators", "Override Materials", "Default Look"};
#endif

			if (imageInspector == null)
			{
				imageInspector = AllIn13DShaderConfig.GetInspectorImage();
			}

			textureEditorTool = new TextureEditorTool();
			textureEditorValuesDrawer = new TextureEditorValuesDrawer();
			textureEditorValuesDrawer.Setup(textureEditorTool);

			normalMapCreatorTool = new NormalMapCreatorTool();
			normalMapCreatorDrawer = new NormalMapCreatorDrawer(normalMapCreatorTool, commonStyles, Repaint);

			gradientCreatorTool = new GradientCreatorTool();
			gradientCreatorDrawer = new GradientCreatorDrawer(gradientCreatorTool, commonStyles);

			atlasPackerTool = new AtlasPackerTool();
			atlasPackerDrawer = ScriptableObject.CreateInstance<AtlasPackerDrawer>();
			atlasPackerDrawer.Setup(atlasPackerTool, commonStyles);

			noiseCreatorTool = new NoiseCreatorTool();
			noiseCreatorDrawer = new NoiseCreatorDrawer(noiseCreatorTool, commonStyles);

			otherTabDrawer = new OtherTabDrawer();
			otherTabDrawer.Setup(globalConfiguration, commonStyles);

			overrideMaterialsTabDrawer = new OverrideMaterialsTabDrawer();
			overrideMaterialsTabDrawer.Setup(commonStyles, this);

			urpSettingsDrawer = new URPSettingsDrawer();
			urpSettingsDrawer.Setup(commonStyles);

			initialized = true;
		}

		private void OnEnable()
		{
			Init();
		}

		private void OnDisable()
		{

		}

		private void OnDestroy()
		{
			WindowClosed();
		}

		private void WindowClosed()
		{
			overrideMaterialsTabDrawer.Close();
			Repaint();
		}

		private void OnGUI()
		{
			if (!initialized)
			{
				Init();
			}

			commonStyles.InitStyles();

			using (var scrollView = new EditorGUILayout.ScrollViewScope(scrollPosition, GUILayout.Width(position.width), GUILayout.Height(position.height)))
			{
				scrollPosition = scrollView.scrollPosition;

				if (imageInspector)
				{
					Rect rect = EditorGUILayout.GetControlRect(GUILayout.Height(50));
					GUI.DrawTexture(rect, imageInspector, ScaleMode.ScaleToFit, true);
				}

				EditorUtils.DrawThinLine();
				int newTab = GUILayout.Toolbar(currTab, tabsNames);
				if(newTab != currTab)
				{
					if (newTab == 3)
					{
						overrideMaterialsTabDrawer.Show();
					}
					else if(currTab == 3)
					{
						overrideMaterialsTabDrawer.Hide();
					}

					currTab = newTab;
				}
				EditorUtils.DrawThinLine();

				switch (currTab)
				{
					case 0:
						DrawTabSavePaths();
						break;
					case 1:
						DrawTabTextureEditor();
						break;
					case 2:
						DrawTabTextureCreators();
						break;
					case 3:
						DrawTabOverrideMaterials();
						break;
					case 4:
						DrawTabOthers();
						break;
#if ALLIN13DSHADER_URP
					case 5:
						DrawTabURPSettings();
						break;
#endif
				}

				GUILayout.Space(10);
				EditorUtils.DrawThinLine();
				GUILayout.Label("Current asset version is " + Constants.VERSION, EditorStyles.boldLabel);
			}
		}

		private void DrawTabSavePaths()
		{
			GUILayout.Label("Material Save Path", commonStyles.bigLabel);
			GUILayout.Space(20);
			GUILayout.Label("Select the folder where new Materials will be saved when the Save Material To Folder button of the asset component is pressed", EditorStyles.boldLabel);
			GlobalConfiguration.instance.MaterialSavePath = EditorUtils.DrawSelectorFolder(GlobalConfiguration.instance.MaterialSavePath, /*GlobalConfiguration.MATERIAL_SAVE_PATH_DEFAULT,*/ "New Material Folder");

			EditorUtils.DrawThinLine();
			GUILayout.Label("Render Material to Image Save Path", commonStyles.bigLabel);
			GUILayout.Space(20);

			EditorGUILayout.BeginHorizontal();
			GUILayout.Label("Rendered Image Texture Scale", GUILayout.MaxWidth(190));
			GlobalConfiguration.instance.RenderImageScale = EditorGUILayout.Slider(GlobalConfiguration.instance.RenderImageScale, 0.2f, 5f, GUILayout.MaxWidth(200));
			if (GUILayout.Button("Default Value", GUILayout.MaxWidth(100)))
			{
				GlobalConfiguration.instance.RenderImageScale = 1f;
			}
			EditorGUILayout.EndHorizontal();

			GlobalConfiguration.instance.RenderImageSavePath = EditorUtils.DrawSelectorFolder(GlobalConfiguration.instance.RenderImageSavePath, /*GlobalConfiguration.RENDER_IMAGE_SAVE_PATH_DEFAULT,*/"New Images Folder");
		}

		private void DrawTabTextureEditor()
		{
			EditorGUI.BeginChangeCheck();
			textureEditorTool.editorTexInput = EditorGUILayout.ObjectField("Image to Edit", textureEditorTool.editorTexInput, typeof(Texture2D), false, GUILayout.Width(300), GUILayout.Height(50)) as Texture2D;
			if (EditorGUI.EndChangeCheck())
			{
				if (textureEditorTool.editorTexInput != null)
				{
					textureEditorTool.Setup();
				}
			}

			EditorUtils.DrawThinLine();

			if (textureEditorTool.editorTex != null)
			{
				textureEditorValuesDrawer.Draw();
			}
			else
			{
				GUILayout.Label("Please select an Image to Edit above", EditorStyles.boldLabel);
			}
		}

		private void DrawTabTextureCreators()
		{
			normalMapCreatorDrawer.Draw();

			EditorUtils.DrawThinLine();

			gradientCreatorDrawer.Draw();

			EditorUtils.DrawThinLine();

			atlasPackerDrawer.Draw();

			EditorUtils.DrawThinLine();

			noiseCreatorDrawer.Draw();
		}

		private void DrawTabOverrideMaterials()
		{
			overrideMaterialsTabDrawer.Draw();
		}

		private void DrawTabOthers()
		{
			otherTabDrawer.Draw();
		}

		private void DrawTabURPSettings()
		{
			urpSettingsDrawer.Draw();
		}

		//private static void CheckRootFolder()
		//{
		//	string newRootFolder = GetRootPluginPath();

		//	if(newRootFolder != GlobalConfiguration.instance.RootPluginPath)
		//	{
		//		string oldRootFolder = GlobalConfiguration.instance.RootPluginPath;
		//		GlobalConfiguration.instance.RootPluginPath = newRootFolder;
		//		GlobalConfiguration.instance.RootFolderChanged(oldRootFolder);
		//	}
		//}

		//private static string GetRootPluginPath()
		//{
		//	Object mainAssemblyAsset = EditorUtils.FindAsset<AssemblyDefinitionAsset>("AllIn13DShaderAssemebly");
		//	string assetPath = AssetDatabase.GetAssetPath(mainAssemblyAsset);

		//	string res = Path.GetDirectoryName(assetPath);
		//	return res;
		//}

		//[MenuItem("Tools/AllIn13DShader/Reset Configuration")]
		//public static void ResetPluginConfiguration()
		//{
		//	string rootFolder = GetRootPluginPath();
		//	AllIn13DShaderConfig.RootPluginPath = rootFolder;
		//	AllIn13DShaderConfig.ResetPaths();
		//}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Windows/AllIn13DShaderWindow.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Windows/OtherTabDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 305faffa5984380458d6390103d1a838
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
	public class OtherTabDrawer
	{
		private GlobalConfiguration globalConfiguration;
		private CommonStyles commonStyles;

		public void Setup(GlobalConfiguration globalConfiguration, CommonStyles commonStyles)
		{
			this.globalConfiguration = globalConfiguration;
			this.commonStyles = commonStyles;

			if (globalConfiguration.defaultPreset == null)
			{
				globalConfiguration.projectType = GlobalConfiguration.ProjectType.STANDARD_BASIC;
				globalConfiguration.RefreshDefaultMaterial();
				globalConfiguration.Save();
			}
		}

		public void Draw()
		{
			GUILayout.Label("Default Materials", commonStyles.bigLabel);
			GUILayout.Space(20);

			EditorGUI.BeginChangeCheck();
			globalConfiguration.projectType = (GlobalConfiguration.ProjectType)EditorGUILayout.EnumPopup("Project Type", globalConfiguration.projectType);
			bool projectTypeChanged = EditorGUI.EndChangeCheck(); 

			bool disabled = globalConfiguration.projectType != GlobalConfiguration.ProjectType.CUSTOM;
			EditorGUI.BeginDisabledGroup(disabled);
			EditorGUI.BeginChangeCheck();
			globalConfiguration.defaultPreset = (Material)EditorGUILayout.ObjectField("Default Material", globalConfiguration.defaultPreset, typeof(Material), false);
			bool defaultPresetChanged = EditorGUI.EndChangeCheck();
			EditorGUI.EndDisabledGroup();

			if (projectTypeChanged)
			{
				globalConfiguration.RefreshDefaultMaterial();
			}

			if(projectTypeChanged || defaultPresetChanged)
			{
				globalConfiguration.Save();
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Windows/OtherTabDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Windows/OverrideMaterialsTabDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 3ff44cb967a47df41a2c11c4f4bc3bbe
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using System.Collections.Generic;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;
using static AllIn13DShader.MaterialOverrideData;

namespace AllIn13DShader
{
	public class OverrideMaterialsTabDrawer
	{
		private enum State
		{
			NONE = 0,
			PREVIEW = 1,
		}

		private AllIn13DShaderWindow parentWindow;

		private CommonStyles commonStyles;

		private PropertySelectorAuxWindow propertySelectorWindow;

		private State state;

		private static MaterialOverrideData overrideData;
		private SerializedObject dataSO;
		private SerializedProperty spFolders;

		private GUIStyle propertiesStyle;

		public OverrideMaterialsTabDrawer()
		{
			Initialize();
		}

		private void Initialize()
		{
			overrideData = ScriptableObject.CreateInstance<MaterialOverrideData>();
			overrideData.Initialize();

			state = State.NONE;

			dataSO = new SerializedObject(overrideData);
			spFolders = dataSO.FindProperty("folders");
		}

		public void Show()
		{
			EditorApplication.wantsToQuit	+= OnWantsToQuit;
			EditorSceneManager.sceneClosing += OnSceneClosing;
			EditorSceneManager.sceneSaving	+= OnSceneSaving;
			EditorSceneManager.sceneSaved	+= OnSceneSaved;
		}

		public void Hide()
		{
			EditorApplication.wantsToQuit	-= OnWantsToQuit;
			EditorSceneManager.sceneClosing -= OnSceneClosing;
			EditorSceneManager.sceneSaving	-= OnSceneSaving;
			EditorSceneManager.sceneSaved	-= OnSceneSaved;

			Close();
		}

		public void Setup(CommonStyles commonStyles, AllIn13DShaderWindow parentWindow)
		{
			this.commonStyles = commonStyles;
			this.parentWindow = parentWindow;
		}

		public void Draw()
		{
			if(propertiesStyle == null)
			{
				propertiesStyle = new GUIStyle(EditorStyles.helpBox);
				propertiesStyle.margin = new RectOffset(0, 0, 0, 0);
			}

			dataSO.Update();

			GUILayout.Space(10f);

			if (state == State.NONE)
			{
				DrawStateNone();
			}
			else
			{
				DrawStatePreview();
			}

			dataSO.ApplyModifiedProperties();
		}

		private void StartOverrideProcess()
		{
			overrideData.ResetData();
			overrideData.CreateRendererOverride();

			overrideData.ShowPreviewChanges();

			state = State.PREVIEW;
		}

		private void EndOverrideProcess(bool applyChanges)
		{
			if (applyChanges)
			{
				List<Material> affectedMaterials = overrideData.CollectAffectedMaterials();

				string title = "Overriding AllIn13D materials";
				string message = $"You are about to override {affectedMaterials.Count} materials";
				string okButton = "Override";
				string cancelButton = "Cancel";

				bool isOk = EditorUtility.DisplayDialog(title, message, okButton, cancelButton);

				if (isOk)
				{
					overrideData.ApplyChangesToMaterials(affectedMaterials);
					overrideData.EndOverrideProcess();

					if(overrideData.applyTarget == MaterialOverrideData.ApplyTarget.CURRENT_SCENE)
					{
						EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
						AssetDatabase.SaveAssets();
					}

					state = State.NONE;
				}
			}
			else
			{
				overrideData.EndOverrideProcess();
				state = State.NONE;
			}
		}

		private void DrawStateNone()
		{
			if (GUILayout.Button("Start"))
			{
				StartOverrideProcess();
			}
		}

		private void DrawStatePreview()
		{
			overrideData.applyTarget = (MaterialOverrideData.ApplyTarget)EditorGUILayout.EnumPopup("Apply Target", overrideData.applyTarget);
			if(overrideData.applyTarget == MaterialOverrideData.ApplyTarget.SELECTED_FOLDERS)
			{
				EditorGUILayout.PropertyField(spFolders);
			}

			GUILayout.Space(20f);

			if (GUILayout.Button("+"))
			{
				propertySelectorWindow = PropertySelectorAuxWindow.GetWindow<PropertySelectorAuxWindow>(title: "Select Property", utility: true);
				propertySelectorWindow.Setup(PropertyAddedCallback);
			}

			GUILayout.Space(20f);

			EditorGUI.BeginChangeCheck();

			for(int i = 0; i < overrideData.generalPropertiesOverrides.Count; i++)
			{
				DrawOverriddenEffectProperty(overrideData.generalPropertiesOverrides[i]);
			}

			if (!overrideData.IsEmpty())
			{
				GUILayout.Space(10f);
			}

			for (int i = 0; i < overrideData.effectOverrides.Count; i++)
			{
				DrawEffectOverride(overrideData.effectOverrides[i]);
			}

			if (EditorGUI.EndChangeCheck())
			{
				overrideData.ShowPreviewChanges();
			}

			EditorGUILayout.BeginHorizontal();

			EditorGUI.BeginDisabledGroup(!overrideData.IsApplyEnabled() || overrideData.IsEmpty());
			if (GUILayout.Button("Apply"))
			{
				EndOverrideProcess(applyChanges: true);
			}
			EditorGUI.EndDisabledGroup();

			if (GUILayout.Button("Cancel"))
			{
				EndOverrideProcess(applyChanges: false);
			}
			
			EditorGUILayout.EndHorizontal();
		}

		private void DrawEffectOverride(AbstractEffectOverride effectOverride)
		{
			EditorGUILayout.BeginHorizontal();

			float lastLabelWidth = EditorGUIUtility.labelWidth;
			EditorGUIUtility.labelWidth = 150f;
			EditorGUI.BeginChangeCheck();
			effectOverride.overrideEnabled = EditorGUILayout.Toggle($"{effectOverride.displayName} Override", effectOverride.overrideEnabled);
			if (EditorGUI.EndChangeCheck())
			{
				overrideData.RebuildPreviewMaterial();
			}
			EditorGUIUtility.labelWidth = lastLabelWidth;

			EditorGUI.BeginDisabledGroup(!effectOverride.overrideEnabled);
			if (effectOverride is EffectToggleOverride)
			{
				EffectToggleOverride effectToggleOverride = (EffectToggleOverride)effectOverride;
				effectToggleOverride.boolValue = EditorGUILayout.Toggle("On/Off", effectToggleOverride.boolValue);
			}
			else if(effectOverride is EffectEnumOverride)
			{
				EffectEnumOverride effectEnumOverride = (EffectEnumOverride)effectOverride;
				effectEnumOverride.index = EditorGUILayout.Popup("Value", effectEnumOverride.index, effectEnumOverride.enumOptions);
			}
			EditorGUI.EndDisabledGroup();

			if (GUILayout.Button("-", GUILayout.Width(50f)))
			{
				overrideData.RemoveEffectOverride(effectOverride);
			}

			EditorGUILayout.EndHorizontal();

			DrawEffectOverrideProperties(effectOverride);
		}

		private void DrawEffectOverrideProperties(AbstractEffectOverride effectOverride)
		{
			EditorGUILayout.BeginVertical(propertiesStyle);
			for (int i = 0; i < effectOverride.propertyOverrides.Count; i++)
			{
				DrawOverriddenEffectProperty(effectOverride.propertyOverrides[i]);
			}
			EditorGUILayout.EndVertical();
		}

		private void DrawOverriddenEffectProperty(PropertyOverride propertyOverride)
		{
			EditorGUILayout.BeginHorizontal();
			if (propertyOverride.isKeywordsProperty)
			{
				propertyOverride.floatValue = EditorGUILayout.Popup(propertyOverride.displayName, (int)propertyOverride.floatValue, propertyOverride.keywordsEnumOptions);
			}
			else
			{
				switch (propertyOverride.shaderPropertyType)
				{
					case ShaderPropertyType.Float:
						propertyOverride.floatValue = EditorGUILayout.FloatField(propertyOverride.displayName, propertyOverride.floatValue);
						break;
					case ShaderPropertyType.Range:
						propertyOverride.floatValue = EditorGUILayout.Slider(propertyOverride.displayName, propertyOverride.floatValue, propertyOverride.rangeLimits.x, propertyOverride.rangeLimits.y);
						break;
					case ShaderPropertyType.Int:
						propertyOverride.intValue = EditorGUILayout.IntField(propertyOverride.displayName, propertyOverride.intValue);
						break;
					case ShaderPropertyType.Color:
						propertyOverride.colorValue = EditorGUILayout.ColorField(propertyOverride.displayName, propertyOverride.colorValue);
						break;
					case ShaderPropertyType.Texture:
						propertyOverride.texValue = (Texture)EditorGUILayout.ObjectField(propertyOverride.displayName, propertyOverride.texValue, typeof(Texture), false);
						break;
					case ShaderPropertyType.Vector:
						propertyOverride.vectorValue = EditorGUILayout.Vector4Field(propertyOverride.displayName, propertyOverride.vectorValue);
						break;
				}
			}

			if (GUILayout.Button("-", GUILayout.Width(50f)))
			{
				overrideData.RemovePropertyOverride(propertyOverride);
				overrideData.RebuildPreviewMaterial();
			}

			EditorGUILayout.EndHorizontal();
		}

		private void PropertyAddedCallback(AllIn13DEffectConfig effectConfig, int propertyIndex, Shader shader, 
			PropertySelectorAuxWindow.TypeOfPropertyAdded typeOfPropertyAdded)
		{
			if(typeOfPropertyAdded == PropertySelectorAuxWindow.TypeOfPropertyAdded.EFFECT_MAIN)
			{
				overrideData.AddCopmleteEffectOverride(effectConfig, shader);
			}
			else if(typeOfPropertyAdded == PropertySelectorAuxWindow.TypeOfPropertyAdded.GLOBAL_PROPERTY)
			{
				overrideData.AddGeneralPropertyOverride(propertyIndex, shader);
			}
			//else if(typeOfPropertyAdded == PropertySelectorAuxWindow.TypeOfPropertyAdded.EFFECT_MAIN)
			//{
			//	overrideData.AddEffectOverride(effectConfig);
			//}

			overrideData.ShowPreviewChanges();
			parentWindow.Repaint();
		}

		public void Close()
		{
			EndOverrideProcess(applyChanges: false);
			//EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
			//AssetDatabase.SaveAssets();

			if (propertySelectorWindow != null)
			{
				propertySelectorWindow.Close();
			}
		}

		private void OnSceneClosing(Scene scene, bool removingScene)
		{
			Close();
			EditorSceneManager.MarkSceneDirty(scene);
			AssetDatabase.SaveAssets();

			Initialize();
		}

		private void OnSceneSaving(Scene scene, string path)
		{
			overrideData.UseMaterialSource();
			EditorSceneManager.MarkSceneDirty(scene);
		}

		private void OnSceneSaved(Scene scene)
		{
			if(state == State.PREVIEW)
			{
				overrideData.UsePreviewMaterials();
			}
		}

		private bool OnWantsToQuit()
		{
			bool res = true;

			if(state == State.PREVIEW)
			{
				bool dialog = EditorUtility.DisplayDialog("Overriding in process", "You are using preview materials. Finish override process before closing Unity", "End override process", "Cancel");
				if (dialog)
				{
					Close();
				}

				res = false;
			}

			return res;
		}

	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Windows/OverrideMaterialsTabDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Windows/URPSettingsDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 638a6d02f9a0f524386897efd05ce5c9
# ASMDEF: AllIn13DShaderAssemebly.Editor.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class URPSettingsDrawer
	{
		private CommonStyles commonStyles;

		public void Setup(CommonStyles commonStyles)
		{
			this.commonStyles = commonStyles;
		}

		public void Draw()
		{
			GUILayout.Label("Configure AllIn13D to work correctly with URP", commonStyles.bigLabel);
			if (GUILayout.Button("Configure"))
			{
#if ALLIN13DSHADER_URP
				URPConfigurator.Configure();
#endif
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Editor/Windows/URPSettingsDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Editor/OpenXRAutoHandAxisFingerBenderEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 06d98d8af92fb7b44bfde58de392c013
# ASMDEF: Autohand.OpenXR.Editor.dll
# ---
using Autohand.Demo;
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace Autohand {
    [CustomEditor(typeof(OpenXRAutoHandAxisFingerBender))]
    public class OpenXRAutoHandAxisFingerBenderEditor : Editor{
        OpenXRAutoHandAxisFingerBender bender;

        void OnEnable() {
            bender = target as OpenXRAutoHandAxisFingerBender;
        }

        public override void OnInspectorGUI() {
            EditorUtility.SetDirty(bender);

            DrawDefaultInspector();
            EditorGUILayout.Space();
            if(bender.hand != null) {
                if(bender.bendOffsets.Length != bender.hand.fingers.Length)
                    bender.bendOffsets = new float[bender.hand.fingers.Length];
                for(int i = 0; i < bender.hand.fingers.Length; i++) {
                    var layout = EditorGUILayout.GetControlRect();
                    layout.width /= 2;
                    var text = new GUIContent(bender.hand.fingers[i].name + " Offset", "0 is no bend, 0.5 is half bend, 1 is full bend, -1 to stiffen finger from sway");
                    EditorGUI.LabelField(layout, text);
                    layout.x += layout.width;
                    bender.bendOffsets[i] = EditorGUI.FloatField(layout, bender.bendOffsets[i]);
                }
            }
            serializedObject.ApplyModifiedProperties();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Editor/OpenXRAutoHandAxisFingerBenderEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Editor/OpenXRAutoHandFingerBenderEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 53e00d75b24d0d94cb70bb3bc9b40842
# ASMDEF: Autohand.OpenXR.Editor.dll
# ---
using Autohand.Demo;
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace Autohand {
    [CustomEditor(typeof(OpenXRAutoHandFingerBender))]
    public class OpenXRAutoHandFingerBenderEditor : Editor{
        OpenXRAutoHandFingerBender bender;

        void OnEnable() {
            bender = target as OpenXRAutoHandFingerBender;
        }

        public override void OnInspectorGUI() {
            EditorUtility.SetDirty(bender);

            DrawDefaultInspector();
            EditorGUILayout.Space();
            if(bender.hand != null) {
                if(bender.bendOffsets.Length != bender.hand.fingers.Length)
                    bender.bendOffsets = new float[bender.hand.fingers.Length];
                for(int i = 0; i < bender.hand.fingers.Length; i++) {
                    var layout = EditorGUILayout.GetControlRect();
                    layout.width /= 2;
                    var text = new GUIContent(bender.hand.fingers[i].name + " Offset", "0 is no bend, 0.5 is half bend, 1 is full bend, -1 to stiffen finger from sway");
                    EditorGUI.LabelField(layout, text);
                    layout.x += layout.width;
                    bender.bendOffsets[i] = EditorGUI.FloatField(layout, bender.bendOffsets[i]);
                }
            }
            serializedObject.ApplyModifiedProperties();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Editor/OpenXRAutoHandFingerBenderEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/Editor/XRAutoHandAxisFingerBenderEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d53486d497e80624493261495e0d47b9
# ASMDEF: Autohand.XR.Editor.dll
# ---
using Autohand.Demo;
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace Autohand {
    [CustomEditor(typeof(XRAutoHandAxisFingerBender))]
    public class XRAutoHandAxisFingerBenderEditor : Editor{
        XRAutoHandAxisFingerBender bender;

        void OnEnable() {
            bender = target as XRAutoHandAxisFingerBender;
        }

        public override void OnInspectorGUI() {
            EditorUtility.SetDirty(bender);

            DrawDefaultInspector();
            EditorGUILayout.Space();
            if(bender.controller != null) {
                if(bender.bendOffsets.Length != bender.controller.hand.fingers.Length)
                    bender.bendOffsets = new float[bender.controller.hand.fingers.Length];
                for(int i = 0; i < bender.controller.hand.fingers.Length; i++) {
                    var layout = EditorGUILayout.GetControlRect();
                    layout.width /= 2;
                    var text = new GUIContent(bender.controller.hand.fingers[i].name + " Offset", "0 is no bend, 0.5 is half bend, 1 is full bend, -1 to stiffen finger from sway");
                    EditorGUI.LabelField(layout, text);
                    layout.x += layout.width;
                    bender.bendOffsets[i] = EditorGUI.FloatField(layout, bender.bendOffsets[i]);
                }
            }
            serializedObject.ApplyModifiedProperties();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/Editor/XRAutoHandAxisFingerBenderEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/Editor/XRAutoHandFingerBenderEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d672e009cdc74814fbd45c23353d303e
# ASMDEF: Autohand.XR.Editor.dll
# ---
using Autohand.Demo;
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace Autohand {
    [CustomEditor(typeof(XRAutoHandFingerBender))]
    public class XRAutoHandFingerBenderEditor : Editor{
        XRAutoHandFingerBender bender;

        void OnEnable() {
            bender = target as XRAutoHandFingerBender;
        }

        public override void OnInspectorGUI() {
            EditorUtility.SetDirty(bender);

            DrawDefaultInspector();
            EditorGUILayout.Space();
            if(bender.controller != null) {
                if(bender.bendOffsets.Length != bender.controller.hand.fingers.Length)
                    bender.bendOffsets = new float[bender.controller.hand.fingers.Length];
                for(int i = 0; i < bender.controller.hand.fingers.Length; i++) {
                    var layout = EditorGUILayout.GetControlRect();
                    layout.width /= 2;
                    var text = new GUIContent(bender.controller.hand.fingers[i].name + " Offset", "0 is no bend, 0.5 is half bend, 1 is full bend, -1 to stiffen finger from sway");
                    EditorGUI.LabelField(layout, text);
                    layout.x += layout.width;
                    bender.bendOffsets[i] = EditorGUI.FloatField(layout, bender.bendOffsets[i]);
                }
            }
            serializedObject.ApplyModifiedProperties();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/Editor/XRAutoHandFingerBenderEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/DecoratorDrawers/HorizontalLineDecoratorDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 3ec99f3a124f20e40b8f5edfeb1ecced
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEngine;
using UnityEditor;

namespace NaughtyAttributes.Editor
{
	[CustomPropertyDrawer(typeof(HorizontalLineAttribute))]
	public class HorizontalLineDecoratorDrawer : DecoratorDrawer
	{
		public override float GetHeight()
		{
			HorizontalLineAttribute lineAttr = (HorizontalLineAttribute)attribute;
			return EditorGUIUtility.singleLineHeight + lineAttr.Height;
		}

		public override void OnGUI(Rect position)
		{
			Rect rect = EditorGUI.IndentedRect(position);
			rect.y += EditorGUIUtility.singleLineHeight / 3.0f;
			HorizontalLineAttribute lineAttr = (HorizontalLineAttribute)attribute;
			NaughtyEditorGUI.HorizontalLine(rect, lineAttr.Height, lineAttr.Color.GetColor());
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/DecoratorDrawers/HorizontalLineDecoratorDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/DecoratorDrawers/InfoBoxDecoratorDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e9c18b0e698717442b7631c5066d667f
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace NaughtyAttributes.Editor
{
	[CustomPropertyDrawer(typeof(InfoBoxAttribute))]
	public class InfoBoxDecoratorDrawer : DecoratorDrawer
	{
		public override float GetHeight()
		{
			return GetHelpBoxHeight();
		}

		public override void OnGUI(Rect rect)
		{
			InfoBoxAttribute infoBoxAttribute = (InfoBoxAttribute)attribute;

			float indentLength = NaughtyEditorGUI.GetIndentLength(rect);
			Rect infoBoxRect = new Rect(
				rect.x + indentLength,
				rect.y,
				rect.width - indentLength,
				GetHelpBoxHeight());

			DrawInfoBox(infoBoxRect, infoBoxAttribute.Text, infoBoxAttribute.Type);
		}

		private float GetHelpBoxHeight()
		{
			InfoBoxAttribute infoBoxAttribute = (InfoBoxAttribute)attribute;
			float minHeight = EditorGUIUtility.singleLineHeight * 2.0f;
			float desiredHeight = GUI.skin.box.CalcHeight(new GUIContent(infoBoxAttribute.Text), EditorGUIUtility.currentViewWidth);
			float height = Mathf.Max(minHeight, desiredHeight);

			return height;
		}

		private void DrawInfoBox(Rect rect, string infoText, EInfoBoxType infoBoxType)
		{
			MessageType messageType = MessageType.None;
			switch (infoBoxType)
			{
				case EInfoBoxType.Normal:
					messageType = MessageType.Info;
					break;

				case EInfoBoxType.Warning:
					messageType = MessageType.Warning;
					break;

				case EInfoBoxType.Error:
					messageType = MessageType.Error;
					break;
			}

			NaughtyEditorGUI.HelpBox(rect, infoText, messageType);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/DecoratorDrawers/InfoBoxDecoratorDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/NaughtyInspector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1b9b53879f7c93b42835c3ad9e0d0a66
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

using UnityEditor;
using UnityEngine;

namespace NaughtyAttributes.Editor
{
	[CanEditMultipleObjects]
	[CustomEditor(typeof(UnityEngine.Object), true)]
	public class NaughtyInspector : UnityEditor.Editor
	{
		protected List<NaughtyProperty> _serializedProperties = new List<NaughtyProperty>();
		protected List<FieldInfo> _nonSerializedFields;
		protected List<PropertyInfo> _nativeProperties;
		protected List<MethodInfo> _methods;

		protected List<NaughtyProperty> _nonGroupedSerializedProperty;
		protected SerializedProperty m_ScriptProperty;

		protected List<IGrouping<string, NaughtyProperty>> _groupedSerialzedProperty;
		protected List<IGrouping<string, NaughtyProperty>> _foldoutGroupedSerializedProperty;
		
		private Dictionary<string, SavedBool> _foldouts = new Dictionary<string, SavedBool>();

		private bool _anyNaughtyAttribute;
		
		protected bool _useCachedMetaAttributes;
		protected bool _changeDetected;
		
		protected virtual void OnEnable()
		{
			this.Prepare();
		}

		protected virtual void OnDisable()
		{
			//cleanup memory
			ReorderableListPropertyDrawer.Instance.ClearCache();

			_nonSerializedFields.Clear();
			_nativeProperties.Clear();
			_methods.Clear();
			_foldouts.Clear();

			_foldoutGroupedSerializedProperty.Clear();
			_groupedSerialzedProperty.Clear();
			_nonGroupedSerializedProperty.Clear();
			_serializedProperties.Clear();
			
			m_ScriptProperty = default;
		}

		public virtual void Prepare()
		{
			_nonSerializedFields = ReflectionUtility.GetAllFields(
				target, f => f.GetCustomAttributes(typeof(ShowNonSerializedFieldAttribute), true).Length > 0).ToList();

			_nativeProperties = ReflectionUtility.GetAllProperties(
				target, p => p.GetCustomAttributes(typeof(ShowNativePropertyAttribute), true).Length > 0).ToList();

			_methods = ReflectionUtility.GetAllMethods(
				target, m => m.GetCustomAttributes(typeof(ButtonAttribute), true).Length > 0).ToList();

			GetSerializedProperties(ref _serializedProperties);
			
			_anyNaughtyAttribute = _serializedProperties.Any(p => PropertyUtility.GetAttribute<INaughtyAttribute>(p.serializedProperty) != null);

			_nonGroupedSerializedProperty = GetNonGroupedProperties(_serializedProperties).ToList();
			
			//.First(...) doesnt work for some reason because the m_Script field isnt loaded yet I assume
			NaughtyProperty[] mScripts = _serializedProperties.Where(p => p.serializedProperty.name.Equals("m_Script")).ToArray();
			m_ScriptProperty = mScripts.Length > 0 ? mScripts[0].serializedProperty : null;
			
			_groupedSerialzedProperty = GetGroupedProperties(_serializedProperties).ToList();

			_foldoutGroupedSerializedProperty = GetFoldoutProperties(_serializedProperties).ToList();

			_useCachedMetaAttributes = false;
		}
		
		public override void OnInspectorGUI()
		{
			_changeDetected = false;
			
			if (!_anyNaughtyAttribute)
			{
				DrawDefaultInspector();
			}
			else
			{
				DrawSerializedProperties();
			}

			DrawNonSerializedFields();
			DrawNativeProperties();
			DrawButtons();

			_useCachedMetaAttributes = !_changeDetected;
		}
		
		protected virtual void GetSerializedProperties(ref List<NaughtyProperty> outSerializedProperties)
		{
			outSerializedProperties.Clear();
			outSerializedProperties.TrimExcess();
			
			using (var iterator = serializedObject.GetIterator())
			{
				if (iterator.NextVisible(true))
				{
					do
					{
						outSerializedProperties.Add(
							PropertyUtility.CreateNaughtyProperty(
								serializedObject.FindProperty(iterator.name)));
					}
					while (iterator.NextVisible(false));
				}
			}
		}

		protected virtual void DrawSerializedProperties()
		{
			serializedObject.Update();

			if (m_ScriptProperty != null)
			{
				using (new EditorGUI.DisabledScope(disabled: true))
				{
					EditorGUILayout.PropertyField(m_ScriptProperty);
				}
			}

			// Draw non-grouped serialized properties
			foreach (var naughtyProperty in _nonGroupedSerializedProperty)
			{
				if (!_useCachedMetaAttributes)
				{
					naughtyProperty.cachedIsVisible = PropertyUtility.IsVisible(naughtyProperty.showIfAttribute,
						naughtyProperty.serializedProperty);
					
					naughtyProperty.cachedIsEnabled = PropertyUtility.IsEnabled(naughtyProperty.readOnlyAttribute, naughtyProperty.enableIfAttribute,
						naughtyProperty.serializedProperty);
				}
				
				_changeDetected |= NaughtyEditorGUI.PropertyField_Layout(naughtyProperty, includeChildren: true);
			}

			// Draw grouped serialized properties
			foreach (var group in _groupedSerialzedProperty)
			{
				IEnumerable<NaughtyProperty> visibleProperties = 
					_useCachedMetaAttributes 
						? group.Where(p => p.cachedIsVisible)
						: group.Where(p =>
						{
							p.cachedIsEnabled = PropertyUtility.IsEnabled(p.readOnlyAttribute, p.enableIfAttribute,
								p.serializedProperty);
							
							return p.cachedIsVisible =
									PropertyUtility.IsVisible(p.showIfAttribute, p.serializedProperty);
						});
				
				if (!visibleProperties.Any())
				{
					continue;
				}
			
				NaughtyEditorGUI.BeginBoxGroup_Layout(group.Key);
				foreach (var naughtyProperty in visibleProperties)
				{
					_changeDetected |= NaughtyEditorGUI.PropertyField_Layout(naughtyProperty, includeChildren: true);
				}
				NaughtyEditorGUI.EndBoxGroup_Layout();
			}
			
			// Draw foldout serialized properties
			foreach (var group in _foldoutGroupedSerializedProperty)
			{
				IEnumerable<NaughtyProperty> visibleProperties = 
					_useCachedMetaAttributes 
						? group.Where(p => p.cachedIsVisible)
						: group.Where(p =>
						{
							p.cachedIsEnabled = PropertyUtility.IsEnabled(p.readOnlyAttribute, p.enableIfAttribute,
								p.serializedProperty);
							
							return p.cachedIsVisible =
									PropertyUtility.IsVisible(p.showIfAttribute, p.serializedProperty);
						});
				
				if (!visibleProperties.Any())
				{
					continue;
				}
			
				if (!_foldouts.ContainsKey(group.Key))
				{
					_foldouts[group.Key] = new SavedBool($"{target.GetInstanceID()}.{group.Key}", false);
				}
			
				_foldouts[group.Key].Value = EditorGUILayout.Foldout(_foldouts[group.Key].Value, group.Key, true);
				if (_foldouts[group.Key].Value)
				{
					foreach (var naughtyProperty in visibleProperties)
					{
						_changeDetected |= NaughtyEditorGUI.PropertyField_Layout(naughtyProperty, true);
					}
				}
			}

			serializedObject.ApplyModifiedProperties();
		}

		protected virtual void DrawNonSerializedFields(bool drawHeader = false)
		{
			if (_nonSerializedFields.Any())
			{
				if (drawHeader)
				{
					EditorGUILayout.Space();
					EditorGUILayout.LabelField("Non-Serialized Fields", GetHeaderGUIStyle());
					NaughtyEditorGUI.HorizontalLine(
						EditorGUILayout.GetControlRect(false), HorizontalLineAttribute.DefaultHeight, HorizontalLineAttribute.DefaultColor.GetColor());
				}

				foreach (var field in _nonSerializedFields)
				{
					NaughtyEditorGUI.NonSerializedField_Layout(serializedObject.targetObject, field);
				}
			}
		}

		protected virtual void DrawNativeProperties(bool drawHeader = false)
		{
			if (_nativeProperties.Any())
			{
				if (drawHeader)
				{
					EditorGUILayout.Space();
					EditorGUILayout.LabelField("Native Properties", GetHeaderGUIStyle());
					NaughtyEditorGUI.HorizontalLine(
						EditorGUILayout.GetControlRect(false), HorizontalLineAttribute.DefaultHeight, HorizontalLineAttribute.DefaultColor.GetColor());
				}

				foreach (var property in _nativeProperties)
				{
					NaughtyEditorGUI.NativeProperty_Layout(serializedObject.targetObject, property);
				}
			}
		}

		protected virtual void DrawButtons(bool drawHeader = false)
		{
			if (_methods.Any())
			{
				if (drawHeader)
				{
					EditorGUILayout.Space();
					EditorGUILayout.LabelField("Buttons", GetHeaderGUIStyle());
					NaughtyEditorGUI.HorizontalLine(
						EditorGUILayout.GetControlRect(false), HorizontalLineAttribute.DefaultHeight, HorizontalLineAttribute.DefaultColor.GetColor());
				}

				foreach (var method in _methods)
				{
					NaughtyEditorGUI.Button(serializedObject.targetObject, method);
				}
			}
		}

		private static IEnumerable<NaughtyProperty> GetNonGroupedProperties(IEnumerable<NaughtyProperty> properties)
		{
			return properties.Where(p => PropertyUtility.GetAttribute<IGroupAttribute>(p.serializedProperty) == null && !p.serializedProperty.name.Equals("m_Script"));
		}

		private static IEnumerable<IGrouping<string, NaughtyProperty>> GetGroupedProperties(IEnumerable<NaughtyProperty> properties)
		{
			return properties
				.Where(p => PropertyUtility.GetAttribute<BoxGroupAttribute>(p.serializedProperty) != null)
				.GroupBy(p => PropertyUtility.GetAttribute<BoxGroupAttribute>(p.serializedProperty).Name);
		}

		private static IEnumerable<IGrouping<string, NaughtyProperty>> GetFoldoutProperties(IEnumerable<NaughtyProperty> properties)
		{
			return properties
				.Where(p => PropertyUtility.GetAttribute<FoldoutAttribute>(p.serializedProperty) != null)
				.GroupBy(p => PropertyUtility.GetAttribute<FoldoutAttribute>(p.serializedProperty).Name);
		}

		private static GUIStyle GetHeaderGUIStyle()
		{
			GUIStyle style = new GUIStyle(EditorStyles.centeredGreyMiniLabel);
			style.fontStyle = FontStyle.Bold;
			style.alignment = TextAnchor.UpperCenter;

			return style;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/NaughtyInspector.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/NaughtyProperty.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 12288d0262da08245af3b1fef6421c75
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEditor;

namespace NaughtyAttributes.Editor
{
    public class NaughtyProperty
    {
        public SerializedProperty serializedProperty;
        
        public LabelAttribute labelAttribute;
        
        public SpecialCaseDrawerAttribute specialCaseDrawerAttribute;
        
        public ShowIfAttributeBase showIfAttribute;
        public EnableIfAttributeBase enableIfAttribute;
        public ReadOnlyAttribute readOnlyAttribute;
        public ValidatorAttribute[] validatorAttributes;

        public bool cachedIsVisible = true;
        public bool cachedIsEnabled = true;
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/NaughtyProperty.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/AllowNestingPropertyDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a3175e7041b8f4348bd652485a78e7b1
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEngine;
using UnityEditor;

namespace NaughtyAttributes.Editor
{
	[CustomPropertyDrawer(typeof(AllowNestingAttribute))]
	public class AllowNestingPropertyDrawer : PropertyDrawerBase
	{
		protected override void OnGUI_Internal(Rect rect, SerializedProperty property, GUIContent label)
		{
			EditorGUI.BeginProperty(rect, label, property);
			EditorGUI.PropertyField(rect, property, label, true);
			EditorGUI.EndProperty();
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/AllowNestingPropertyDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/AnimatorParamPropertyDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 98ff8cb1bcefae740a68d9a5c5ee3563
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using System.Collections.Generic;
using System.Reflection;
using UnityEditor;
using UnityEditor.Animations;
using UnityEngine;

namespace NaughtyAttributes.Editor
{
	[CustomPropertyDrawer(typeof(AnimatorParamAttribute))]
	public class AnimatorParamPropertyDrawer : PropertyDrawerBase
	{
		private AnimatorParamAttribute _cachedAnimatorParamAttribute;
		
		private const string InvalidAnimatorControllerWarningMessage = "Target animator controller is null";
		private const string InvalidTypeWarningMessage = "{0} must be an int or a string";

		protected override float GetPropertyHeight_Internal(SerializedProperty property, GUIContent label)
		{
			if (_cachedAnimatorParamAttribute == null)
				_cachedAnimatorParamAttribute = PropertyUtility.GetAttribute<AnimatorParamAttribute>(property);
			
			AnimatorParamAttribute animatorParamAttribute = _cachedAnimatorParamAttribute;
			bool validAnimatorController = GetAnimatorController(property, animatorParamAttribute.AnimatorName) != null;
			bool validPropertyType = property.propertyType == SerializedPropertyType.Integer || property.propertyType == SerializedPropertyType.String;

			return (validAnimatorController && validPropertyType)
				? GetPropertyHeight(property)
				: GetPropertyHeight(property) + GetHelpBoxHeight();
		}

		protected override void OnGUI_Internal(Rect rect, SerializedProperty property, GUIContent label)
		{
			EditorGUI.BeginProperty(rect, label, property);

			if (_cachedAnimatorParamAttribute == null)
				_cachedAnimatorParamAttribute = PropertyUtility.GetAttribute<AnimatorParamAttribute>(property);
			
			AnimatorParamAttribute animatorParamAttribute = _cachedAnimatorParamAttribute;

			AnimatorController animatorController = GetAnimatorController(property, animatorParamAttribute.AnimatorName);
			if (animatorController == null)
			{
				DrawDefaultPropertyAndHelpBox(rect, property, InvalidAnimatorControllerWarningMessage, MessageType.Warning);
				return;
			}

			int parametersCount = animatorController.parameters.Length;
			List<AnimatorControllerParameter> animatorParameters = new List<AnimatorControllerParameter>(parametersCount);
			for (int i = 0; i < parametersCount; i++)
			{
				AnimatorControllerParameter parameter = animatorController.parameters[i];
				if (animatorParamAttribute.AnimatorParamType == null || parameter.type == animatorParamAttribute.AnimatorParamType)
				{
					animatorParameters.Add(parameter);
				}
			}

			switch (property.propertyType)
			{
				case SerializedPropertyType.Integer:
					DrawPropertyForInt(rect, property, label, animatorParameters);
					break;
				case SerializedPropertyType.String:
					DrawPropertyForString(rect, property, label, animatorParameters);
					break;
				default:
					DrawDefaultPropertyAndHelpBox(rect, property, string.Format(InvalidTypeWarningMessage, property.name), MessageType.Warning);
					break;
			}

			EditorGUI.EndProperty();
		}

		private static void DrawPropertyForInt(Rect rect, SerializedProperty property, GUIContent label, List<AnimatorControllerParameter> animatorParameters)
		{
			int paramNameHash = property.intValue;
			int index = 0;

			for (int i = 0; i < animatorParameters.Count; i++)
			{
				if (paramNameHash == animatorParameters[i].nameHash)
				{
					index = i + 1; // +1 because the first option is reserved for (None)
					break;
				}
			}

			string[] displayOptions = GetDisplayOptions(animatorParameters);

			int newIndex = EditorGUI.Popup(rect, label.text, index, displayOptions);
			int newValue = newIndex == 0 ? 0 : animatorParameters[newIndex - 1].nameHash;

			if (property.intValue != newValue)
			{
				property.intValue = newValue;
			}
		}

		private static void DrawPropertyForString(Rect rect, SerializedProperty property, GUIContent label, List<AnimatorControllerParameter> animatorParameters)
		{
			string paramName = property.stringValue;
			int index = 0;

			for (int i = 0; i < animatorParameters.Count; i++)
			{
				if (paramName.Equals(animatorParameters[i].name, System.StringComparison.Ordinal))
				{
					index = i + 1; // +1 because the first option is reserved for (None)
					break;
				}
			}

			string[] displayOptions = GetDisplayOptions(animatorParameters);

			int newIndex = EditorGUI.Popup(rect, label.text, index, displayOptions);
			string newValue = newIndex == 0 ? null : animatorParameters[newIndex - 1].name;

			if (!property.stringValue.Equals(newValue, System.StringComparison.Ordinal))
			{
				property.stringValue = newValue;
			}
		}

		private static string[] GetDisplayOptions(List<AnimatorControllerParameter> animatorParams)
		{
			string[] displayOptions = new string[animatorParams.Count + 1];
			displayOptions[0] = "(None)";

			for (int i = 0; i < animatorParams.Count; i++)
			{
				displayOptions[i + 1] = animatorParams[i].name;
			}

			return displayOptions;
		}

		private static AnimatorController GetAnimatorController(SerializedProperty property, string animatorName)
		{
			object target = PropertyUtility.GetTargetObjectWithProperty(property);

			FieldInfo animatorFieldInfo = ReflectionUtility.GetField(target, animatorName);
			if (animatorFieldInfo != null &&
				animatorFieldInfo.FieldType == typeof(Animator))
			{
				Animator animator = animatorFieldInfo.GetValue(target) as Animator;
				if (animator != null)
				{
					AnimatorController animatorController = animator.runtimeAnimatorController as AnimatorController;
					return animatorController;
				}
			}

			PropertyInfo animatorPropertyInfo = ReflectionUtility.GetProperty(target, animatorName);
			if (animatorPropertyInfo != null &&
				animatorPropertyInfo.PropertyType == typeof(Animator))
			{
				Animator animator = animatorPropertyInfo.GetValue(target) as Animator;
				if (animator != null)
				{
					AnimatorController animatorController = animator.runtimeAnimatorController as AnimatorController;
					return animatorController;
				}
			}

			MethodInfo animatorGetterMethodInfo = ReflectionUtility.GetMethod(target, animatorName);
			if (animatorGetterMethodInfo != null &&
				animatorGetterMethodInfo.ReturnType == typeof(Animator) &&
				animatorGetterMethodInfo.GetParameters().Length == 0)
			{
				Animator animator = animatorGetterMethodInfo.Invoke(target, null) as Animator;
				if (animator != null)
				{
					AnimatorController animatorController = animator.runtimeAnimatorController as AnimatorController;
					return animatorController;
				}
			}

			return null;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/AnimatorParamPropertyDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/CurveRangePropertyDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 798b8c99fbc072a4b83ee387e472a2bd
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEngine;
using UnityEditor;

namespace NaughtyAttributes.Editor
{
	[CustomPropertyDrawer(typeof(CurveRangeAttribute))]
	public class CurveRangePropertyDrawer : PropertyDrawerBase
	{
		private CurveRangeAttribute _cachedCurveRangeAttribute;
		
		protected override float GetPropertyHeight_Internal(SerializedProperty property, GUIContent label)
		{
			float propertyHeight = property.propertyType == SerializedPropertyType.AnimationCurve
				? GetPropertyHeight(property)
				: GetPropertyHeight(property) + GetHelpBoxHeight();

			return propertyHeight;
		}

		protected override void OnGUI_Internal(Rect rect, SerializedProperty property, GUIContent label)
		{
			EditorGUI.BeginProperty(rect, label, property);

			// Check user error
			if (property.propertyType != SerializedPropertyType.AnimationCurve)
			{
				string message = string.Format("Field {0} is not an AnimationCurve", property.name);
				DrawDefaultPropertyAndHelpBox(rect, property, message, MessageType.Warning);
				return;
			}

			if (_cachedCurveRangeAttribute == null)
				_cachedCurveRangeAttribute = PropertyUtility.GetAttribute<CurveRangeAttribute>(property);
			
			var attribute = _cachedCurveRangeAttribute;

			EditorGUI.CurveField(
				rect, 
				property,
				attribute.Color == EColor.Clear ? Color.green : attribute.Color.GetColor(),
				new Rect(attribute.Min.x, attribute.Min.y, attribute.Max.x - attribute.Min.x, attribute.Max.y - attribute.Min.y),
				label);

			EditorGUI.EndProperty();
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/CurveRangePropertyDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/DropdownPropertyDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: dd080b36769bcd94d909fc0431cf25e0
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEngine;
using UnityEditor;
using System.Collections;
using System.Reflection;
using System;
using System.Collections.Generic;

namespace NaughtyAttributes.Editor
{
	[CustomPropertyDrawer(typeof(DropdownAttribute))]
	public class DropdownPropertyDrawer : PropertyDrawerBase
	{
		protected override float GetPropertyHeight_Internal(SerializedProperty property, GUIContent label)
		{
			DropdownAttribute dropdownAttribute = (DropdownAttribute)attribute;
			object values = GetValues(property, dropdownAttribute.ValuesName);
			FieldInfo fieldInfo = ReflectionUtility.GetField(PropertyUtility.GetTargetObjectWithProperty(property), property.name);

			float propertyHeight = AreValuesValid(values, fieldInfo)
				? GetPropertyHeight(property)
				: GetPropertyHeight(property) + GetHelpBoxHeight();

			return propertyHeight;
		}

		protected override void OnGUI_Internal(Rect rect, SerializedProperty property, GUIContent label)
		{
			EditorGUI.BeginProperty(rect, label, property);

			DropdownAttribute dropdownAttribute = (DropdownAttribute)attribute;
			object target = PropertyUtility.GetTargetObjectWithProperty(property);

			object valuesObject = GetValues(property, dropdownAttribute.ValuesName);
			FieldInfo dropdownField = ReflectionUtility.GetField(target, property.name);

			if (AreValuesValid(valuesObject, dropdownField))
			{
				if (valuesObject is IList && dropdownField.FieldType == GetElementType(valuesObject))
				{
					// Selected value
					object selectedValue = dropdownField.GetValue(target);

					// Values and display options
					IList valuesList = (IList)valuesObject;
					object[] values = new object[valuesList.Count];
					string[] displayOptions = new string[valuesList.Count];

					for (int i = 0; i < values.Length; i++)
					{
						object value = valuesList[i];
						values[i] = value;
						displayOptions[i] = value == null ? "<null>" : value.ToString();
					}

					// Selected value index
					int selectedValueIndex = Array.IndexOf(values, selectedValue);
					if (selectedValueIndex < 0)
					{
						selectedValueIndex = 0;
					}

					NaughtyEditorGUI.Dropdown(
						rect, property.serializedObject, target, dropdownField, label.text, selectedValueIndex, values, displayOptions);
				}
				else if (valuesObject is IDropdownList)
				{
					// Current value
					object selectedValue = dropdownField.GetValue(target);

					// Current value index, values and display options
					int index = -1;
					int selectedValueIndex = -1;
					List<object> values = new List<object>();
					List<string> displayOptions = new List<string>();
					IDropdownList dropdown = (IDropdownList)valuesObject;

					using (IEnumerator<KeyValuePair<string, object>> dropdownEnumerator = dropdown.GetEnumerator())
					{
						while (dropdownEnumerator.MoveNext())
						{
							index++;

							KeyValuePair<string, object> current = dropdownEnumerator.Current;
							if (current.Value?.Equals(selectedValue) == true)
							{
								selectedValueIndex = index;
							}

							values.Add(current.Value);

							if (current.Key == null)
							{
								displayOptions.Add("<null>");
							}
							else if (string.IsNullOrWhiteSpace(current.Key))
							{
								displayOptions.Add("<empty>");
							}
							else
							{
								displayOptions.Add(current.Key);
							}
						}
					}

					if (selectedValueIndex < 0)
					{
						selectedValueIndex = 0;
					}

					NaughtyEditorGUI.Dropdown(
						rect, property.serializedObject, target, dropdownField, label.text, selectedValueIndex, values.ToArray(), displayOptions.ToArray());
				}
			}
			else
			{
				string message = string.Format("Invalid values with name '{0}' provided to '{1}'. Either the values name is incorrect or the types of the target field and the values field/property/method don't match",
					dropdownAttribute.ValuesName, dropdownAttribute.GetType().Name);

				DrawDefaultPropertyAndHelpBox(rect, property, message, MessageType.Warning);
			}

			EditorGUI.EndProperty();
		}

		private object GetValues(SerializedProperty property, string valuesName)
		{
			object target = PropertyUtility.GetTargetObjectWithProperty(property);

			FieldInfo valuesFieldInfo = ReflectionUtility.GetField(target, valuesName);
			if (valuesFieldInfo != null)
			{
				return valuesFieldInfo.GetValue(target);
			}

			PropertyInfo valuesPropertyInfo = ReflectionUtility.GetProperty(target, valuesName);
			if (valuesPropertyInfo != null)
			{
				return valuesPropertyInfo.GetValue(target);
			}

			MethodInfo methodValuesInfo = ReflectionUtility.GetMethod(target, valuesName);
			if (methodValuesInfo != null &&
				methodValuesInfo.ReturnType != typeof(void) &&
				methodValuesInfo.GetParameters().Length == 0)
			{
				return methodValuesInfo.Invoke(target, null);
			}

			return null;
		}

		private bool AreValuesValid(object values, FieldInfo dropdownField)
		{
			if (values == null || dropdownField == null)
			{
				return false;
			}

			if ((values is IList && dropdownField.FieldType == GetElementType(values)) ||
				(values is IDropdownList))
			{
				return true;
			}

			return false;
		}

		private Type GetElementType(object values)
		{
			Type valuesType = values.GetType();
			Type elementType = ReflectionUtility.GetListElementType(valuesType);

			return elementType;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/DropdownPropertyDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/EnumFlagsPropertyDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b750e1461c1126d4399459b90b31e75e
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEngine;
using UnityEditor;
using System;

namespace NaughtyAttributes.Editor
{
	[CustomPropertyDrawer(typeof(EnumFlagsAttribute))]
	public class EnumFlagsPropertyDrawer : PropertyDrawerBase
	{
		protected override float GetPropertyHeight_Internal(SerializedProperty property, GUIContent label)
		{
			Enum targetEnum = PropertyUtility.GetTargetObjectOfProperty(property) as Enum;

			return (targetEnum != null)
				? GetPropertyHeight(property)
				: GetPropertyHeight(property) + GetHelpBoxHeight();
		}

		protected override void OnGUI_Internal(Rect rect, SerializedProperty property, GUIContent label)
		{
			EditorGUI.BeginProperty(rect, label, property);

			Enum targetEnum = PropertyUtility.GetTargetObjectOfProperty(property) as Enum;
			if (targetEnum != null)
			{
				Enum enumNew = EditorGUI.EnumFlagsField(rect, label.text, targetEnum);
				property.intValue = (int)Convert.ChangeType(enumNew, targetEnum.GetType());
			}
			else
			{
				string message = attribute.GetType().Name + " can be used only on enums";
				DrawDefaultPropertyAndHelpBox(rect, property, message, MessageType.Warning);
			}

			EditorGUI.EndProperty();
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/EnumFlagsPropertyDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/ExpandablePropertyDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d1ddb7194615bdc4e8b2088c8d165d8b
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEngine;
using UnityEditor;

namespace NaughtyAttributes.Editor
{
	[CustomPropertyDrawer(typeof(ExpandableAttribute))]
	public class ExpandablePropertyDrawer : PropertyDrawerBase
	{
		protected override float GetPropertyHeight_Internal(SerializedProperty property, GUIContent label)
		{
			if (property.objectReferenceValue == null)
			{
				return GetPropertyHeight(property);
			}

			System.Type propertyType = PropertyUtility.GetPropertyType(property);
			if (typeof(ScriptableObject).IsAssignableFrom(propertyType))
			{
				ScriptableObject scriptableObject = property.objectReferenceValue as ScriptableObject;
				if (scriptableObject == null)
				{
					return GetPropertyHeight(property);
				}

				if (property.isExpanded)
				{
					using (SerializedObject serializedObject = new SerializedObject(scriptableObject))
					{
						float totalHeight = EditorGUIUtility.singleLineHeight;

						using (var iterator = serializedObject.GetIterator())
						{
							if (iterator.NextVisible(true))
							{
								do
								{
									SerializedProperty childProperty = serializedObject.FindProperty(iterator.name);
									if (childProperty.name.Equals("m_Script", System.StringComparison.Ordinal))
									{
										continue;
									}

									bool visible = PropertyUtility.IsVisible(childProperty);
									if (!visible)
									{
										continue;
									}

									float height = GetPropertyHeight(childProperty);
									totalHeight += height;
								}
								while (iterator.NextVisible(false));
							}
						}

						totalHeight += EditorGUIUtility.standardVerticalSpacing;
						return totalHeight;
					}
				}
				else
				{
					return GetPropertyHeight(property);
				}
			}
			else
			{
				return GetPropertyHeight(property) + GetHelpBoxHeight();
			}
		}

		protected override void OnGUI_Internal(Rect rect, SerializedProperty property, GUIContent label)
		{
			EditorGUI.BeginProperty(rect, label, property);

			if (property.objectReferenceValue == null)
			{
				EditorGUI.PropertyField(rect, property, label, false);
			}
			else
			{
				System.Type propertyType = PropertyUtility.GetPropertyType(property);
				if (typeof(ScriptableObject).IsAssignableFrom(propertyType))
				{
					ScriptableObject scriptableObject = property.objectReferenceValue as ScriptableObject;
					if (scriptableObject == null)
					{
						EditorGUI.PropertyField(rect, property, label, false);
					}
					else
					{
						// Draw a foldout
						Rect foldoutRect = new Rect()
						{
							x = rect.x,
							y = rect.y,
							width = EditorGUIUtility.labelWidth,
							height = EditorGUIUtility.singleLineHeight
						};

						property.isExpanded = EditorGUI.Foldout(foldoutRect, property.isExpanded, label, toggleOnLabelClick: true);

						// Draw the scriptable object field
						Rect propertyRect = new Rect()
						{
							x = rect.x,
							y = rect.y,
							width = rect.width,
							height = EditorGUIUtility.singleLineHeight
						};

						EditorGUI.PropertyField(propertyRect, property, label, false);

						property.serializedObject.ApplyModifiedProperties();

						// Draw the child properties
						if (property.isExpanded)
						{
							DrawChildProperties(rect, property);
						}
					}
				}
				else
				{
					string message = $"{typeof(ExpandableAttribute).Name} can only be used on scriptable objects";
					DrawDefaultPropertyAndHelpBox(rect, property, message, MessageType.Warning);
				}
			}

			EditorGUI.EndProperty();
		}
		
		private void DrawChildProperties(Rect rect, SerializedProperty property)
		{
			ScriptableObject scriptableObject = property.objectReferenceValue as ScriptableObject;
			if (scriptableObject == null)
			{
				return;
			}

			Rect boxRect = new Rect()
			{
				x = 0.0f,
				y = rect.y + EditorGUIUtility.singleLineHeight,
				width = rect.width * 2.0f,
				height = rect.height - EditorGUIUtility.singleLineHeight
			};

			GUI.Box(boxRect, GUIContent.none);

			using (new EditorGUI.IndentLevelScope())
			{
				SerializedObject serializedObject = new SerializedObject(scriptableObject);

				using (var iterator = serializedObject.GetIterator())
				{
					float yOffset = EditorGUIUtility.singleLineHeight;

					if (iterator.NextVisible(true))
					{
						do
						{
							SerializedProperty childProperty = serializedObject.FindProperty(iterator.name);
							if (childProperty.name.Equals("m_Script", System.StringComparison.Ordinal))
							{
								continue;
							}

							bool visible = PropertyUtility.IsVisible(childProperty);
							if (!visible)
							{
								continue;
							}

							float childHeight = GetPropertyHeight(childProperty);
							Rect childRect = new Rect()
							{
								x = rect.x,
								y = rect.y + yOffset,
								width = rect.width,
								height = childHeight
							};

							//TODO since the depth can go deeper we cant just use one field. - need better caching and mapping here!
							//_naughtyProperty ??= PropertyUtility.CreateNaughtyProperty(childProperty);
							NaughtyEditorGUI.PropertyField(childRect, PropertyUtility.CreateNaughtyProperty(childProperty), true);

							yOffset += childHeight;
						}
						while (iterator.NextVisible(false));
					}
				}

				serializedObject.ApplyModifiedProperties();
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/ExpandablePropertyDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/InputAxisPropertyDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 0de9d3dfe2d466a458be838edf361645
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace NaughtyAttributes.Editor
{
	[CustomPropertyDrawer(typeof(InputAxisAttribute))]
	public class InputAxisPropertyDrawer : PropertyDrawerBase
	{
		private static readonly string AssetPath = Path.Combine("ProjectSettings", "InputManager.asset");
		private const string AxesPropertyPath = "m_Axes";
		private const string NamePropertyPath = "m_Name";

		protected override float GetPropertyHeight_Internal(SerializedProperty property, GUIContent label)
		{
			return (property.propertyType == SerializedPropertyType.String)
				? GetPropertyHeight(property)
				: GetPropertyHeight(property) + GetHelpBoxHeight();
		}

		protected override void OnGUI_Internal(Rect rect, SerializedProperty property, GUIContent label)
		{
			EditorGUI.BeginProperty(rect, label, property);

			if (property.propertyType == SerializedPropertyType.String)
			{
				var inputManagerAsset = AssetDatabase.LoadAssetAtPath(AssetPath, typeof(object));
				var inputManager = new SerializedObject(inputManagerAsset);

				var axesProperty = inputManager.FindProperty(AxesPropertyPath);
				var axesSet = new HashSet<string>();
				axesSet.Add("(None)");

				for (var i = 0; i < axesProperty.arraySize; i++)
				{
					var axis = axesProperty.GetArrayElementAtIndex(i).FindPropertyRelative(NamePropertyPath).stringValue;
					axesSet.Add(axis);
				}

				var axes = axesSet.ToArray();

				string propertyString = property.stringValue;
				int index = 0;
				// check if there is an entry that matches the entry and get the index
				// we skip index 0 as that is a special custom case
				for (int i = 1; i < axes.Length; i++)
				{
					if (axes[i].Equals(propertyString, System.StringComparison.Ordinal))
					{
						index = i;
						break;
					}
				}

				// Draw the popup box with the current selected index
				int newIndex = EditorGUI.Popup(rect, label.text, index, axes);

				// Adjust the actual string value of the property based on the selection
				string newValue = newIndex > 0 ? axes[newIndex] : string.Empty;

				if (!property.stringValue.Equals(newValue, System.StringComparison.Ordinal))
				{
					property.stringValue = newValue;
				}
			}
			else
			{
				string message = string.Format("{0} supports only string fields", typeof(InputAxisAttribute).Name);
				DrawDefaultPropertyAndHelpBox(rect, property, message, MessageType.Warning);
			}

			EditorGUI.EndProperty();
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/InputAxisPropertyDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/LayerPropertyDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7278ba0893ab7d940b5f944e5b1cf1a7
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEngine;
using UnityEditor;
using System;

namespace NaughtyAttributes.Editor
{
	[CustomPropertyDrawer(typeof(LayerAttribute))]
	public class LayerPropertyDrawer : PropertyDrawerBase
	{
		private const string TypeWarningMessage = "{0} must be an int or a string";

		protected override float GetPropertyHeight_Internal(SerializedProperty property, GUIContent label)
		{
			bool validPropertyType = property.propertyType == SerializedPropertyType.String || property.propertyType == SerializedPropertyType.Integer;

			return validPropertyType
				? GetPropertyHeight(property)
				: GetPropertyHeight(property) + GetHelpBoxHeight();
		}

		protected override void OnGUI_Internal(Rect rect, SerializedProperty property, GUIContent label)
		{
			EditorGUI.BeginProperty(rect, label, property);

			switch (property.propertyType)
			{
				case SerializedPropertyType.String:
					DrawPropertyForString(rect, property, label, GetLayers());
					break;
				case SerializedPropertyType.Integer:
					DrawPropertyForInt(rect, property, label, GetLayers());
					break;
				default:
					string message = string.Format(TypeWarningMessage, property.name);
					DrawDefaultPropertyAndHelpBox(rect, property, message, MessageType.Warning);
					break;
			}

			EditorGUI.EndProperty();
		}

		private string[] GetLayers()
		{
			return UnityEditorInternal.InternalEditorUtility.layers;
		}

		private static void DrawPropertyForString(Rect rect, SerializedProperty property, GUIContent label, string[] layers)
		{
			int index = IndexOf(layers, property.stringValue);
			int newIndex = EditorGUI.Popup(rect, label.text, index, layers);
			string newLayer = layers[newIndex];

			if (!property.stringValue.Equals(newLayer, StringComparison.Ordinal))
			{
				property.stringValue = layers[newIndex];
			}
		}

		private static void DrawPropertyForInt(Rect rect, SerializedProperty property, GUIContent label, string[] layers)
		{
			int index = 0;
			string layerName = LayerMask.LayerToName(property.intValue);
			for (int i = 0; i < layers.Length; i++)
			{
				if (layerName.Equals(layers[i], StringComparison.Ordinal))
				{
					index = i;
					break;
				}
			}

			int newIndex = EditorGUI.Popup(rect, label.text, index, layers);
			string newLayerName = layers[newIndex];
			int newLayerNumber = LayerMask.NameToLayer(newLayerName);

			if (property.intValue != newLayerNumber)
			{
				property.intValue = newLayerNumber;
			}
		}

		private static int IndexOf(string[] layers, string layer)
		{
			var index = Array.IndexOf(layers, layer);
			return Mathf.Clamp(index, 0, layers.Length - 1);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/LayerPropertyDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/MinMaxSliderPropertyDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 27011af81554b5b4489b155f09275475
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace NaughtyAttributes.Editor
{
	[CustomPropertyDrawer(typeof(MinMaxSliderAttribute))]
	public class MinMaxSliderPropertyDrawer : PropertyDrawerBase
	{
		protected override float GetPropertyHeight_Internal(SerializedProperty property, GUIContent label)
		{
			return (property.propertyType == SerializedPropertyType.Vector2 || property.propertyType == SerializedPropertyType.Vector2Int)
				? GetPropertyHeight(property)
				: GetPropertyHeight(property) + GetHelpBoxHeight();
		}

		protected override void OnGUI_Internal(Rect rect, SerializedProperty property, GUIContent label)
		{
			EditorGUI.BeginProperty(rect, label, property);

			MinMaxSliderAttribute minMaxSliderAttribute = (MinMaxSliderAttribute)attribute;

			if (property.propertyType == SerializedPropertyType.Vector2 || property.propertyType == SerializedPropertyType.Vector2Int)
			{
				EditorGUI.BeginProperty(rect, label, property);

				float indentLength = NaughtyEditorGUI.GetIndentLength(rect);
				float labelWidth = EditorGUIUtility.labelWidth + NaughtyEditorGUI.HorizontalSpacing;
				float floatFieldWidth = EditorGUIUtility.fieldWidth;
				float sliderWidth = rect.width - labelWidth - 2.0f * floatFieldWidth;
				float sliderPadding = 5.0f;

				Rect labelRect = new Rect(
					rect.x,
					rect.y,
					labelWidth,
					rect.height);

				Rect sliderRect = new Rect(
					rect.x + labelWidth + floatFieldWidth + sliderPadding - indentLength,
					rect.y,
					sliderWidth - 2.0f * sliderPadding + indentLength,
					rect.height);

				Rect minFloatFieldRect = new Rect(
					rect.x + labelWidth - indentLength,
					rect.y,
					floatFieldWidth + indentLength,
					rect.height);

				Rect maxFloatFieldRect = new Rect(
					rect.x + labelWidth + floatFieldWidth + sliderWidth - indentLength,
					rect.y,
					floatFieldWidth + indentLength,
					rect.height);

				// Draw the label
				EditorGUI.LabelField(labelRect, label.text);

				// Draw the slider
				EditorGUI.BeginChangeCheck();

				if (property.propertyType == SerializedPropertyType.Vector2)
				{
					Vector2 sliderValue = property.vector2Value;
					EditorGUI.MinMaxSlider(sliderRect, ref sliderValue.x, ref sliderValue.y, minMaxSliderAttribute.MinValue, minMaxSliderAttribute.MaxValue);

					sliderValue.x = EditorGUI.FloatField(minFloatFieldRect, sliderValue.x);
					sliderValue.x = Mathf.Clamp(sliderValue.x, minMaxSliderAttribute.MinValue, Mathf.Min(minMaxSliderAttribute.MaxValue, sliderValue.y));

					sliderValue.y = EditorGUI.FloatField(maxFloatFieldRect, sliderValue.y);
					sliderValue.y = Mathf.Clamp(sliderValue.y, Mathf.Max(minMaxSliderAttribute.MinValue, sliderValue.x), minMaxSliderAttribute.MaxValue);

					if (EditorGUI.EndChangeCheck())
					{
						property.vector2Value = sliderValue;
					}
				}
				else if (property.propertyType == SerializedPropertyType.Vector2Int)
				{
					Vector2Int sliderValue = property.vector2IntValue;
					float xValue = sliderValue.x;
					float yValue = sliderValue.y;
					EditorGUI.MinMaxSlider(sliderRect, ref xValue, ref yValue, minMaxSliderAttribute.MinValue, minMaxSliderAttribute.MaxValue);

					sliderValue.x = EditorGUI.IntField(minFloatFieldRect, (int)xValue);
					sliderValue.x = (int)Mathf.Clamp(sliderValue.x, minMaxSliderAttribute.MinValue, Mathf.Min(minMaxSliderAttribute.MaxValue, sliderValue.y));

					sliderValue.y = EditorGUI.IntField(maxFloatFieldRect, (int)yValue);
					sliderValue.y = (int)Mathf.Clamp(sliderValue.y, Mathf.Max(minMaxSliderAttribute.MinValue, sliderValue.x), minMaxSliderAttribute.MaxValue);

					if (EditorGUI.EndChangeCheck())
					{
						property.vector2IntValue = sliderValue;
					}
				}

				EditorGUI.EndProperty();
			}
			else
			{
				string message = minMaxSliderAttribute.GetType().Name + " can be used only on Vector2 or Vector2Int fields";
				DrawDefaultPropertyAndHelpBox(rect, property, message, MessageType.Warning);
			}

			EditorGUI.EndProperty();
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/MinMaxSliderPropertyDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/ProgressBarPropertyDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 0bcbc424b10864b4eb6e3bcfb276cdf9
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEngine;
using UnityEditor;
using System.Reflection;

namespace NaughtyAttributes.Editor
{
	[CustomPropertyDrawer(typeof(ProgressBarAttribute))]
	public class ProgressBarPropertyDrawer : PropertyDrawerBase
	{
		private ProgressBarAttribute _cachedProgressBarAttribute;
		
		protected override float GetPropertyHeight_Internal(SerializedProperty property, GUIContent label)
		{
			if (_cachedProgressBarAttribute == null)
				_cachedProgressBarAttribute = PropertyUtility.GetAttribute<ProgressBarAttribute>(property);
			
			ProgressBarAttribute progressBarAttribute = _cachedProgressBarAttribute;
			var maxValue = GetMaxValue(property, progressBarAttribute);

			return IsNumber(property) && IsNumber(maxValue)
				? GetPropertyHeight(property)
				: GetPropertyHeight(property) + GetHelpBoxHeight();
		}

		protected override void OnGUI_Internal(Rect rect, SerializedProperty property, GUIContent label)
		{
			EditorGUI.BeginProperty(rect, label, property);

			if (!IsNumber(property))
			{
				string message = string.Format("Field {0} is not a number", property.name);
				DrawDefaultPropertyAndHelpBox(rect, property, message, MessageType.Warning);
				return;
			}

			if (_cachedProgressBarAttribute == null)
				_cachedProgressBarAttribute = PropertyUtility.GetAttribute<ProgressBarAttribute>(property);
			
			ProgressBarAttribute progressBarAttribute = _cachedProgressBarAttribute;
			var value = property.propertyType == SerializedPropertyType.Integer ? property.intValue : property.floatValue;
			var valueFormatted = property.propertyType == SerializedPropertyType.Integer ? value.ToString() : string.Format("{0:0.00}", value);
			var maxValue = GetMaxValue(property, progressBarAttribute);

			if (maxValue != null && IsNumber(maxValue))
			{
				var fillPercentage = value / CastToFloat(maxValue);
				var barLabel = (!string.IsNullOrEmpty(progressBarAttribute.Name) ? "[" + progressBarAttribute.Name + "] " : "") + valueFormatted + "/" + maxValue;
				var barColor = progressBarAttribute.Color.GetColor();
				var labelColor = Color.white;

				var indentLength = NaughtyEditorGUI.GetIndentLength(rect);
				Rect barRect = new Rect()
				{
					x = rect.x + indentLength,
					y = rect.y,
					width = rect.width - indentLength,
					height = EditorGUIUtility.singleLineHeight
				};

				DrawBar(barRect, Mathf.Clamp01(fillPercentage), barLabel, barColor, labelColor);
			}
			else
			{
				string message = string.Format(
					"The provided dynamic max value for the progress bar is not correct. Please check if the '{0}' is correct, or the return type is float/int",
					nameof(progressBarAttribute.MaxValueName));

				DrawDefaultPropertyAndHelpBox(rect, property, message, MessageType.Warning);
			}

			EditorGUI.EndProperty();
		}

		private object GetMaxValue(SerializedProperty property, ProgressBarAttribute progressBarAttribute)
		{
			if (string.IsNullOrEmpty(progressBarAttribute.MaxValueName))
			{
				return progressBarAttribute.MaxValue;
			}
			else
			{
				object target = PropertyUtility.GetTargetObjectWithProperty(property);

				FieldInfo valuesFieldInfo = ReflectionUtility.GetField(target, progressBarAttribute.MaxValueName);
				if (valuesFieldInfo != null)
				{
					return valuesFieldInfo.GetValue(target);
				}

				PropertyInfo valuesPropertyInfo = ReflectionUtility.GetProperty(target, progressBarAttribute.MaxValueName);
				if (valuesPropertyInfo != null)
				{
					return valuesPropertyInfo.GetValue(target);
				}

				MethodInfo methodValuesInfo = ReflectionUtility.GetMethod(target, progressBarAttribute.MaxValueName);
				if (methodValuesInfo != null &&
					(methodValuesInfo.ReturnType == typeof(float) || methodValuesInfo.ReturnType == typeof(int)) &&
					methodValuesInfo.GetParameters().Length == 0)
				{
					return methodValuesInfo.Invoke(target, null);
				}

				return null;
			}
		}

		private void DrawBar(Rect rect, float fillPercent, string label, Color barColor, Color labelColor)
		{
			if (Event.current.type != EventType.Repaint)
			{
				return;
			}

			var fillRect = new Rect(rect.x, rect.y, rect.width * fillPercent, rect.height);

			EditorGUI.DrawRect(rect, new Color(0.13f, 0.13f, 0.13f));
			EditorGUI.DrawRect(fillRect, barColor);

			// set alignment and cache the default
			var align = GUI.skin.label.alignment;
			GUI.skin.label.alignment = TextAnchor.UpperCenter;

			// set the color and cache the default
			var c = GUI.contentColor;
			GUI.contentColor = labelColor;

			// calculate the position
			var labelRect = new Rect(rect.x, rect.y - 2, rect.width, rect.height);

			// draw~
			EditorGUI.DropShadowLabel(labelRect, label);

			// reset color and alignment
			GUI.contentColor = c;
			GUI.skin.label.alignment = align;
		}

		private bool IsNumber(SerializedProperty property)
		{
			bool isNumber = property.propertyType == SerializedPropertyType.Float || property.propertyType == SerializedPropertyType.Integer;
			return isNumber;
		}

		private bool IsNumber(object obj)
		{
			return (obj is float) || (obj is int);
		}

		private float CastToFloat(object obj)
		{
			if (obj is int)
			{
				return (int)obj;
			}
			else
			{
				return (float)obj;
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/ProgressBarPropertyDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/PropertyDrawerBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 574f5fa6033f26342816a8a5f39749e5
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace NaughtyAttributes.Editor
{
	public abstract class PropertyDrawerBase : PropertyDrawer
	{
		private SpecialCaseDrawerAttribute _cachedSpecialCaseDrawerAttribute;
		
		public sealed override void OnGUI(Rect rect, SerializedProperty property, GUIContent label)
		{
			// Check if visible
			bool visible = PropertyUtility.IsVisible(property);
			if (!visible)
			{
				return;
			}

			// Validate
			ValidatorAttribute[] validatorAttributes = PropertyUtility.GetAttributes<ValidatorAttribute>(property);
			foreach (var validatorAttribute in validatorAttributes)
			{
				validatorAttribute.GetValidator().ValidateProperty(property);
			}

			// Check if enabled and draw
			EditorGUI.BeginChangeCheck();
			bool enabled = PropertyUtility.IsEnabled(property);

			using (new EditorGUI.DisabledScope(disabled: !enabled))
			{
				OnGUI_Internal(rect, property, PropertyUtility.GetLabel(property));
			}

			// Call OnValueChanged callbacks
			if (EditorGUI.EndChangeCheck())
			{
				PropertyUtility.CallOnValueChangedCallbacks(property);
			}
		}

		protected abstract void OnGUI_Internal(Rect rect, SerializedProperty property, GUIContent label);

		sealed override public float GetPropertyHeight(SerializedProperty property, GUIContent label)
		{
			bool visible = PropertyUtility.IsVisible(property);
			if (!visible)
			{
				return 0.0f;
			}

			return GetPropertyHeight_Internal(property, label);
		}

		protected virtual float GetPropertyHeight_Internal(SerializedProperty property, GUIContent label)
		{
			return EditorGUI.GetPropertyHeight(property, includeChildren: true);
		}

		protected float GetPropertyHeight(SerializedProperty property)
		{
			if (_cachedSpecialCaseDrawerAttribute == null)
				_cachedSpecialCaseDrawerAttribute = PropertyUtility.GetAttribute<SpecialCaseDrawerAttribute>(property);
			
			SpecialCaseDrawerAttribute specialCaseAttribute = _cachedSpecialCaseDrawerAttribute;
			if (specialCaseAttribute != null)
			{
				return specialCaseAttribute.GetDrawer().GetPropertyHeight(property);
			}

			return EditorGUI.GetPropertyHeight(property, includeChildren: true);
		}

		public virtual float GetHelpBoxHeight()
		{
			return EditorGUIUtility.singleLineHeight * 2.0f;
		}

		public void DrawDefaultPropertyAndHelpBox(Rect rect, SerializedProperty property, string message, MessageType messageType)
		{
			float indentLength = NaughtyEditorGUI.GetIndentLength(rect);
			Rect helpBoxRect = new Rect(
				rect.x + indentLength,
				rect.y,
				rect.width - indentLength,
				GetHelpBoxHeight());

			NaughtyEditorGUI.HelpBox(helpBoxRect, message, MessageType.Warning, context: property.serializedObject.targetObject);

			Rect propertyRect = new Rect(
				rect.x,
				rect.y + GetHelpBoxHeight(),
				rect.width,
				GetPropertyHeight(property));

			EditorGUI.PropertyField(propertyRect, property, true);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/PropertyDrawerBase.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/ResizableTextAreaPropertyDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6e27ffd9a96b58c46bb74cc93de3e06f
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEngine;
using UnityEditor;
using System.Text.RegularExpressions;
using System;

namespace NaughtyAttributes.Editor
{
	[CustomPropertyDrawer(typeof(ResizableTextAreaAttribute))]
	public class ResizableTextAreaPropertyDrawer : PropertyDrawerBase
	{
		protected override float GetPropertyHeight_Internal(SerializedProperty property, GUIContent label)
		{
			if (property.propertyType == SerializedPropertyType.String)
			{
				float labelHeight = EditorGUIUtility.singleLineHeight;
				float textAreaHeight = GetTextAreaHeight(property.stringValue);
				return labelHeight + textAreaHeight;
			}
			else
			{
				return GetPropertyHeight(property) + GetHelpBoxHeight();
			}
		}

		protected override void OnGUI_Internal(Rect rect, SerializedProperty property, GUIContent label)
		{
			EditorGUI.BeginProperty(rect, label, property);

			if (property.propertyType == SerializedPropertyType.String)
			{
				Rect labelRect = new Rect()
				{
					x = rect.x,
					y = rect.y,
					width = rect.width,
					height = EditorGUIUtility.singleLineHeight
				};

				EditorGUI.LabelField(labelRect, label.text);

				EditorGUI.BeginChangeCheck();

				Rect textAreaRect = new Rect()
				{
					x = labelRect.x,
					y = labelRect.y + EditorGUIUtility.singleLineHeight,
					width = labelRect.width,
					height = GetTextAreaHeight(property.stringValue)
				};

				string textAreaValue = EditorGUI.TextArea(textAreaRect, property.stringValue);

				if (EditorGUI.EndChangeCheck())
				{
					property.stringValue = textAreaValue;
				}
			}
			else
			{
				string message = typeof(ResizableTextAreaAttribute).Name + " can only be used on string fields";
				DrawDefaultPropertyAndHelpBox(rect, property, message, MessageType.Warning);
			}

			EditorGUI.EndProperty();
		}

		private int GetNumberOfLines(string text)
		{
			string content = Regex.Replace(text, @"\r\n|\n\r|\r|\n", Environment.NewLine);
			string[] lines = content.Split(new string[] { Environment.NewLine }, StringSplitOptions.None);
			return lines.Length;
		}

		private float GetTextAreaHeight(string text)
		{
			float height = (EditorGUIUtility.singleLineHeight - 3.0f) * GetNumberOfLines(text) + 3.0f;
			return height;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/ResizableTextAreaPropertyDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/ScenePropertyDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7f5ed440d4f429e42a5da7bc5df48fd8
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEngine;
using UnityEditor;
using System.Linq;
using System.Text.RegularExpressions;
using System;

namespace NaughtyAttributes.Editor
{
	[CustomPropertyDrawer(typeof(SceneAttribute))]
	public class ScenePropertyDrawer : PropertyDrawerBase
	{
		private const string SceneListItem = "{0} ({1})";
		private const string ScenePattern = @".+\/(.+)\.unity";
		private const string TypeWarningMessage = "{0} must be an int or a string";
		private const string BuildSettingsWarningMessage = "No scenes in the build settings";

		protected override float GetPropertyHeight_Internal(SerializedProperty property, GUIContent label)
		{
			bool validPropertyType = property.propertyType == SerializedPropertyType.String || property.propertyType == SerializedPropertyType.Integer;
			bool anySceneInBuildSettings = GetScenes().Length > 0;

			return (validPropertyType && anySceneInBuildSettings)
				? GetPropertyHeight(property)
				: GetPropertyHeight(property) + GetHelpBoxHeight();
		}

		protected override void OnGUI_Internal(Rect rect, SerializedProperty property, GUIContent label)
		{
			EditorGUI.BeginProperty(rect, label, property);

			string[] scenes = GetScenes();
			bool anySceneInBuildSettings = scenes.Length > 0;
			if (!anySceneInBuildSettings)
			{
				DrawDefaultPropertyAndHelpBox(rect, property, BuildSettingsWarningMessage, MessageType.Warning);
				return;
			}

			string[] sceneOptions = GetSceneOptions(scenes);
			switch (property.propertyType)
			{
				case SerializedPropertyType.String:
					DrawPropertyForString(rect, property, label, scenes, sceneOptions);
					break;
				case SerializedPropertyType.Integer:
					DrawPropertyForInt(rect, property, label, sceneOptions);
					break;
				default:
					string message = string.Format(TypeWarningMessage, property.name);
					DrawDefaultPropertyAndHelpBox(rect, property, message, MessageType.Warning);
					break;
			}

			EditorGUI.EndProperty();
		}

		private string[] GetScenes()
		{
			return EditorBuildSettings.scenes
				.Where(scene => scene.enabled)
				.Select(scene => Regex.Match(scene.path, ScenePattern).Groups[1].Value)
				.ToArray();
		}

		private string[] GetSceneOptions(string[] scenes)
		{
			return scenes.Select((s, i) => string.Format(SceneListItem, s, i)).ToArray();
		}

		private static void DrawPropertyForString(Rect rect, SerializedProperty property, GUIContent label, string[] scenes, string[] sceneOptions)
		{
			int index = IndexOf(scenes, property.stringValue);
			int newIndex = EditorGUI.Popup(rect, label.text, index, sceneOptions);
			string newScene = scenes[newIndex];

			if (!property.stringValue.Equals(newScene, StringComparison.Ordinal))
			{
				property.stringValue = scenes[newIndex];
			}
		}

		private static void DrawPropertyForInt(Rect rect, SerializedProperty property, GUIContent label, string[] sceneOptions)
		{
			int index = property.intValue;
			int newIndex = EditorGUI.Popup(rect, label.text, index, sceneOptions);

			if (property.intValue != newIndex)
			{
				property.intValue = newIndex;
			}
		}

		private static int IndexOf(string[] scenes, string scene)
		{
			var index = Array.IndexOf(scenes, scene);
			return Mathf.Clamp(index, 0, scenes.Length - 1);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/ScenePropertyDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/ShowAssetPreviewPropertyDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 24dee3fc91cfe94438de1e3c158f187f
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEngine;
using UnityEditor;

namespace NaughtyAttributes.Editor
{
	[CustomPropertyDrawer(typeof(ShowAssetPreviewAttribute))]
	public class ShowAssetPreviewPropertyDrawer : PropertyDrawerBase
	{
		private ShowAssetPreviewAttribute _cachedShowAssetPreviewAttribute;
		
		protected override float GetPropertyHeight_Internal(SerializedProperty property, GUIContent label)
		{
			if (property.propertyType == SerializedPropertyType.ObjectReference)
			{
				Texture2D previewTexture = GetAssetPreview(property);
				if (previewTexture != null)
				{
					return GetPropertyHeight(property) + GetAssetPreviewSize(property).y;
				}
				else
				{
					return GetPropertyHeight(property);
				}
			}
			else
			{
				return GetPropertyHeight(property) + GetHelpBoxHeight();
			}
		}

		protected override void OnGUI_Internal(Rect rect, SerializedProperty property, GUIContent label)
		{
			EditorGUI.BeginProperty(rect, label, property);

			if (property.propertyType == SerializedPropertyType.ObjectReference)
			{
				Rect propertyRect = new Rect()
				{
					x = rect.x,
					y = rect.y,
					width = rect.width,
					height = EditorGUIUtility.singleLineHeight
				};

				EditorGUI.PropertyField(propertyRect, property, label);

				Texture2D previewTexture = GetAssetPreview(property);
				if (previewTexture != null)
				{
					Rect previewRect = new Rect()
					{
						x = rect.x + NaughtyEditorGUI.GetIndentLength(rect),
						y = rect.y + EditorGUIUtility.singleLineHeight,
						width = rect.width,
						height = GetAssetPreviewSize(property).y
					};

					GUI.Label(previewRect, previewTexture);
				}
			}
			else
			{
				string message = property.name + " doesn't have an asset preview";
				DrawDefaultPropertyAndHelpBox(rect, property, message, MessageType.Warning);
			}

			EditorGUI.EndProperty();
		}

		private Texture2D GetAssetPreview(SerializedProperty property)
		{
			if (property.propertyType == SerializedPropertyType.ObjectReference)
			{
				if (property.objectReferenceValue != null)
				{
					Texture2D previewTexture = AssetPreview.GetAssetPreview(property.objectReferenceValue);
					return previewTexture;
				}

				return null;
			}

			return null;
		}

		private Vector2 GetAssetPreviewSize(SerializedProperty property)
		{
			Texture2D previewTexture = GetAssetPreview(property);
			if (previewTexture == null)
			{
				return Vector2.zero;
			}
			else
			{
				int targetWidth = ShowAssetPreviewAttribute.DefaultWidth;
				int targetHeight = ShowAssetPreviewAttribute.DefaultHeight;

				if (_cachedShowAssetPreviewAttribute == null)
					_cachedShowAssetPreviewAttribute =
						PropertyUtility.GetAttribute<ShowAssetPreviewAttribute>(property);
				
				ShowAssetPreviewAttribute showAssetPreviewAttribute = _cachedShowAssetPreviewAttribute;
				if (showAssetPreviewAttribute != null)
				{
					targetWidth = showAssetPreviewAttribute.Width;
					targetHeight = showAssetPreviewAttribute.Height;
				}

				int width = Mathf.Clamp(targetWidth, 0, previewTexture.width);
				int height = Mathf.Clamp(targetHeight, 0, previewTexture.height);

				return new Vector2(width, height);
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/ShowAssetPreviewPropertyDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/TagPropertyDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 3df4c068c970ab6498df7a60efbde311
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace NaughtyAttributes.Editor
{
	[CustomPropertyDrawer(typeof(TagAttribute))]
	public class TagPropertyDrawer : PropertyDrawerBase
	{
		protected override float GetPropertyHeight_Internal(SerializedProperty property, GUIContent label)
		{
			return (property.propertyType == SerializedPropertyType.String)
				? GetPropertyHeight(property)
				: GetPropertyHeight(property) + GetHelpBoxHeight();
		}

		protected override void OnGUI_Internal(Rect rect, SerializedProperty property, GUIContent label)
		{
			EditorGUI.BeginProperty(rect, label, property);

			if (property.propertyType == SerializedPropertyType.String)
			{
				// generate the taglist + custom tags
				List<string> tagList = new List<string>();
				tagList.Add("(None)");
				tagList.Add("Untagged");
				tagList.AddRange(UnityEditorInternal.InternalEditorUtility.tags);

				string propertyString = property.stringValue;
				int index = 0;
				// check if there is an entry that matches the entry and get the index
				// we skip index 0 as that is a special custom case
				for (int i = 1; i < tagList.Count; i++)
				{
					if (tagList[i].Equals(propertyString, System.StringComparison.Ordinal))
					{
						index = i;
						break;
					}
				}

				// Draw the popup box with the current selected index
				int newIndex = EditorGUI.Popup(rect, label.text, index, tagList.ToArray());

				// Adjust the actual string value of the property based on the selection
				string newValue = newIndex > 0 ? tagList[newIndex] : string.Empty;

				if (!property.stringValue.Equals(newValue, System.StringComparison.Ordinal))
				{
					property.stringValue = newValue;
				}
			}
			else
			{
				string message = string.Format("{0} supports only string fields", typeof(TagAttribute).Name);
				DrawDefaultPropertyAndHelpBox(rect, property, message, MessageType.Warning);
			}

			EditorGUI.EndProperty();
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers/TagPropertyDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers_SpecialCase/ReorderableListPropertyDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: bf36691a6d456564db2fcbfa8726b3f3
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEngine;
using UnityEditor;
using UnityEditorInternal;
using System.Collections.Generic;

namespace NaughtyAttributes.Editor
{
	public class ReorderableListPropertyDrawer : SpecialCasePropertyDrawerBase
	{
		public static readonly ReorderableListPropertyDrawer Instance = new ReorderableListPropertyDrawer();

		private readonly Dictionary<string, ReorderableList> _reorderableListsByPropertyName = new Dictionary<string, ReorderableList>();

		private GUIStyle _labelStyle;

		private GUIStyle GetLabelStyle()
		{
			if (_labelStyle == null)
			{
				_labelStyle = new GUIStyle(EditorStyles.boldLabel);
				_labelStyle.richText = true;
			}

			return _labelStyle;
		}

		private string GetPropertyKeyName(SerializedProperty property)
		{
			return property.serializedObject.targetObject.GetInstanceID() + "." + property.name;
		}

		protected override float GetPropertyHeight_Internal(SerializedProperty property)
		{
			if (property.isArray)
			{
				string key = GetPropertyKeyName(property);

				if (_reorderableListsByPropertyName.TryGetValue(key, out ReorderableList reorderableList) == false)
				{
					return 0;
				}

				return reorderableList.GetHeight();
			}

			return EditorGUI.GetPropertyHeight(property, true);
		}

		protected override void OnGUI_Internal(Rect rect, SerializedProperty property, GUIContent label)
		{
			if (property.isArray)
			{
				string key = GetPropertyKeyName(property);

				ReorderableList reorderableList = null;
				if (!_reorderableListsByPropertyName.ContainsKey(key))
				{
					reorderableList = new ReorderableList(property.serializedObject, property, true, true, true, true)
					{
						drawHeaderCallback = (Rect r) =>
						{
							EditorGUI.LabelField(r, string.Format("{0}: {1}", label.text, property.arraySize), GetLabelStyle());
							HandleDragAndDrop(r, reorderableList);
						},

						drawElementCallback = (Rect r, int index, bool isActive, bool isFocused) =>
						{
							SerializedProperty element = property.GetArrayElementAtIndex(index);
							r.y += 1.0f;
							r.x += 10.0f;
							r.width -= 10.0f;

							EditorGUI.PropertyField(new Rect(r.x, r.y, r.width, EditorGUIUtility.singleLineHeight), element, true);
						},

						elementHeightCallback = (int index) =>
						{
							return EditorGUI.GetPropertyHeight(property.GetArrayElementAtIndex(index)) + 4.0f;
						}
					};

					_reorderableListsByPropertyName[key] = reorderableList;
				}

				reorderableList = _reorderableListsByPropertyName[key];

				if (rect == default)
				{
					reorderableList.DoLayoutList();
				}
				else
				{
					reorderableList.DoList(rect);
				}
			}
			else
			{
				string message = typeof(ReorderableListAttribute).Name + " can be used only on arrays or lists";
				NaughtyEditorGUI.HelpBox_Layout(message, MessageType.Warning, context: property.serializedObject.targetObject);
				EditorGUILayout.PropertyField(property, true);
			}
		}

		public void ClearCache()
		{
			_reorderableListsByPropertyName.Clear();
		}

		private Object GetAssignableObject(Object obj, ReorderableList list)
		{
			System.Type listType = PropertyUtility.GetPropertyType(list.serializedProperty);
			System.Type elementType = ReflectionUtility.GetListElementType(listType);

			if (elementType == null)
			{
				return null;
			}

			System.Type objType = obj.GetType();

			if (elementType.IsAssignableFrom(objType))
			{
				return obj;
			}

			if (objType == typeof(GameObject))
			{
				if (typeof(Transform).IsAssignableFrom(elementType))
				{
					Transform transform = ((GameObject)obj).transform;
					if (elementType == typeof(RectTransform))
					{
						RectTransform rectTransform = transform as RectTransform;
						return rectTransform;
					}
					else
					{
						return transform;
					}
				}
				else if (typeof(MonoBehaviour).IsAssignableFrom(elementType))
				{
					return ((GameObject)obj).GetComponent(elementType);
				}
			}

			return null;
		}

		private void HandleDragAndDrop(Rect rect, ReorderableList list)
		{
			var currentEvent = Event.current;
			var usedEvent = false;

			switch (currentEvent.type)
			{
				case EventType.DragExited:
					if (GUI.enabled)
					{
						HandleUtility.Repaint();
					}

					break;

				case EventType.DragUpdated:
				case EventType.DragPerform:
					if (rect.Contains(currentEvent.mousePosition) && GUI.enabled)
					{
						// Check each single object, so we can add multiple objects in a single drag.
						bool didAcceptDrag = false;
						Object[] references = DragAndDrop.objectReferences;
						foreach (Object obj in references)
						{
							Object assignableObject = GetAssignableObject(obj, list);
							if (assignableObject != null)
							{
								DragAndDrop.visualMode = DragAndDropVisualMode.Copy;
								if (currentEvent.type == EventType.DragPerform)
								{
									list.serializedProperty.arraySize++;
									int arrayEnd = list.serializedProperty.arraySize - 1;
									list.serializedProperty.GetArrayElementAtIndex(arrayEnd).objectReferenceValue = assignableObject;
									didAcceptDrag = true;
								}
							}
						}

						if (didAcceptDrag)
						{
							GUI.changed = true;
							DragAndDrop.AcceptDrag();
							usedEvent = true;
						}
					}

					break;
			}

			if (usedEvent)
			{
				currentEvent.Use();
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers_SpecialCase/ReorderableListPropertyDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers_SpecialCase/SpecialCasePropertyDrawerBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 771776453ad34b045a41dea54856fa12
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace NaughtyAttributes.Editor
{
	public abstract class SpecialCasePropertyDrawerBase
	{
		public bool OnGUI(Rect rect, NaughtyProperty naughtyProperty)
		{
			bool changeDetected = false;
			
			// Check if visible
			bool visible = PropertyUtility.IsVisible(naughtyProperty.showIfAttribute, naughtyProperty.serializedProperty);
			if (!visible)
			{
				return false;
			}

			// Validate
			ValidatorAttribute[] validatorAttributes = naughtyProperty.validatorAttributes;
			foreach (var validatorAttribute in validatorAttributes)
			{
				validatorAttribute.GetValidator().ValidateProperty(naughtyProperty.serializedProperty);
			}

			// Check if enabled and draw
			EditorGUI.BeginChangeCheck();
			bool enabled = PropertyUtility.IsEnabled(naughtyProperty.readOnlyAttribute, naughtyProperty.enableIfAttribute, naughtyProperty.serializedProperty);

			using (new EditorGUI.DisabledScope(disabled: !enabled))
			{
				OnGUI_Internal(rect, naughtyProperty.serializedProperty, PropertyUtility.GetLabel(naughtyProperty.labelAttribute, naughtyProperty.serializedProperty));
			}

			// Call OnValueChanged callbacks
			if (EditorGUI.EndChangeCheck())
			{
				changeDetected = true;
				PropertyUtility.CallOnValueChangedCallbacks(naughtyProperty.serializedProperty);
			}

			return changeDetected;
		}

		public float GetPropertyHeight(SerializedProperty property)
		{
			return GetPropertyHeight_Internal(property);
		}

		protected abstract void OnGUI_Internal(Rect rect, SerializedProperty property, GUIContent label);
		protected abstract float GetPropertyHeight_Internal(SerializedProperty property);
	}

	public static class SpecialCaseDrawerAttributeExtensions
	{
		private static Dictionary<Type, SpecialCasePropertyDrawerBase> _drawersByAttributeType;

		static SpecialCaseDrawerAttributeExtensions()
		{
			_drawersByAttributeType = new Dictionary<Type, SpecialCasePropertyDrawerBase>();
			_drawersByAttributeType[typeof(ReorderableListAttribute)] = ReorderableListPropertyDrawer.Instance;
		}

		public static SpecialCasePropertyDrawerBase GetDrawer(this SpecialCaseDrawerAttribute attr)
		{
			SpecialCasePropertyDrawerBase drawer;
			if (_drawersByAttributeType.TryGetValue(attr.GetType(), out drawer))
			{
				return drawer;
			}
			else
			{
				return null;
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyDrawers_SpecialCase/SpecialCasePropertyDrawerBase.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyValidators/MaxValuePropertyValidator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 627b8e9e7bda6fa408c6f47fb8285665
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEngine;
using UnityEditor;

namespace NaughtyAttributes.Editor
{
	public class MaxValuePropertyValidator : PropertyValidatorBase
	{
		private MaxValueAttribute _cachedMaxValueAttribute;
		
		public override void ValidateProperty(SerializedProperty property)
		{
			if (_cachedMaxValueAttribute == null)
				_cachedMaxValueAttribute = PropertyUtility.GetAttribute<MaxValueAttribute>(property);
			
			MaxValueAttribute maxValueAttribute = _cachedMaxValueAttribute;

			if (property.propertyType == SerializedPropertyType.Integer)
			{
				if (property.intValue > maxValueAttribute.MaxValue)
				{
					property.intValue = (int)maxValueAttribute.MaxValue;
				}
			}
			else if (property.propertyType == SerializedPropertyType.Float)
			{
				if (property.floatValue > maxValueAttribute.MaxValue)
				{
					property.floatValue = maxValueAttribute.MaxValue;
				}
			}
			else if (property.propertyType == SerializedPropertyType.Vector2)
			{
				property.vector2Value = Vector2.Min(property.vector2Value, new Vector2(maxValueAttribute.MaxValue, maxValueAttribute.MaxValue));
			}
			else if (property.propertyType == SerializedPropertyType.Vector3)
			{
				property.vector3Value = Vector3.Min(property.vector3Value, new Vector3(maxValueAttribute.MaxValue, maxValueAttribute.MaxValue, maxValueAttribute.MaxValue));
			}
			else if (property.propertyType == SerializedPropertyType.Vector4)
			{
				property.vector4Value = Vector4.Min(property.vector4Value, new Vector4(maxValueAttribute.MaxValue, maxValueAttribute.MaxValue, maxValueAttribute.MaxValue, maxValueAttribute.MaxValue));
			}
			else if (property.propertyType == SerializedPropertyType.Vector2Int)
			{
				property.vector2IntValue = Vector2Int.Min(property.vector2IntValue, new Vector2Int((int)maxValueAttribute.MaxValue, (int)maxValueAttribute.MaxValue));
			}
			else if (property.propertyType == SerializedPropertyType.Vector3Int)
			{
				property.vector3IntValue = Vector3Int.Min(property.vector3IntValue, new Vector3Int((int)maxValueAttribute.MaxValue, (int)maxValueAttribute.MaxValue, (int)maxValueAttribute.MaxValue));
			}
			else
			{
				string warning = maxValueAttribute.GetType().Name + " can be used only on int, float, Vector or VectorInt fields";
				Debug.LogWarning(warning, property.serializedObject.targetObject);
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyValidators/MaxValuePropertyValidator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyValidators/MinValuePropertyValidator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 03dd23f6c0598074fb1b721dcd8fe023
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEngine;
using UnityEditor;

namespace NaughtyAttributes.Editor
{
	public class MinValuePropertyValidator : PropertyValidatorBase
	{
		private MinValueAttribute _cachedMinValueAttribute;
		
		public override void ValidateProperty(SerializedProperty property)
		{
			if (_cachedMinValueAttribute == null)
				_cachedMinValueAttribute = PropertyUtility.GetAttribute<MinValueAttribute>(property);
			
			MinValueAttribute minValueAttribute = _cachedMinValueAttribute;

			if (property.propertyType == SerializedPropertyType.Integer)
			{
				if (property.intValue < minValueAttribute.MinValue)
				{
					property.intValue = (int)minValueAttribute.MinValue;
				}
			}
			else if (property.propertyType == SerializedPropertyType.Float)
			{
				if (property.floatValue < minValueAttribute.MinValue)
				{
					property.floatValue = minValueAttribute.MinValue;
				}
			}
			else if (property.propertyType == SerializedPropertyType.Vector2)
			{
				property.vector2Value = Vector2.Max(property.vector2Value, new Vector2(minValueAttribute.MinValue, minValueAttribute.MinValue));
			}
			else if (property.propertyType == SerializedPropertyType.Vector3)
			{
				property.vector3Value = Vector3.Max(property.vector3Value, new Vector3(minValueAttribute.MinValue, minValueAttribute.MinValue, minValueAttribute.MinValue));
			}
			else if (property.propertyType == SerializedPropertyType.Vector4)
			{
				property.vector4Value = Vector4.Max(property.vector4Value, new Vector4(minValueAttribute.MinValue, minValueAttribute.MinValue, minValueAttribute.MinValue, minValueAttribute.MinValue));
			}
			else if (property.propertyType == SerializedPropertyType.Vector2Int)
			{
				property.vector2IntValue = Vector2Int.Max(property.vector2IntValue, new Vector2Int((int)minValueAttribute.MinValue, (int)minValueAttribute.MinValue));
			}
			else if (property.propertyType == SerializedPropertyType.Vector3Int)
			{
				property.vector3IntValue = Vector3Int.Max(property.vector3IntValue, new Vector3Int((int)minValueAttribute.MinValue, (int)minValueAttribute.MinValue, (int)minValueAttribute.MinValue));
			}
			else
			{
				string warning = minValueAttribute.GetType().Name + " can be used only on int, float, Vector or VectorInt fields";
				Debug.LogWarning(warning, property.serializedObject.targetObject);
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyValidators/MinValuePropertyValidator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyValidators/PropertyValidatorBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f332c8e1c3627d742aa9158af7b02ccc
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using System;
using System.Collections.Generic;
using UnityEditor;

namespace NaughtyAttributes.Editor
{
	public abstract class PropertyValidatorBase
	{
		public abstract void ValidateProperty(SerializedProperty property);
	}

	public static class ValidatorAttributeExtensions
	{
		private static Dictionary<Type, PropertyValidatorBase> _validatorsByAttributeType;

		static ValidatorAttributeExtensions()
		{
			_validatorsByAttributeType = new Dictionary<Type, PropertyValidatorBase>();
			_validatorsByAttributeType[typeof(MinValueAttribute)] = new MinValuePropertyValidator();
			_validatorsByAttributeType[typeof(MaxValueAttribute)] = new MaxValuePropertyValidator();
			_validatorsByAttributeType[typeof(RequiredAttribute)] = new RequiredPropertyValidator();
			_validatorsByAttributeType[typeof(ValidateInputAttribute)] = new ValidateInputPropertyValidator();
		}

		public static PropertyValidatorBase GetValidator(this ValidatorAttribute attr)
		{
			PropertyValidatorBase validator;
			if (_validatorsByAttributeType.TryGetValue(attr.GetType(), out validator))
			{
				return validator;
			}
			else
			{
				return null;
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyValidators/PropertyValidatorBase.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyValidators/RequiredPropertyValidator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 3a7e657ea45f6414682b5f41be9541b4
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEditor;

namespace NaughtyAttributes.Editor
{
	public class RequiredPropertyValidator : PropertyValidatorBase
	{
		private RequiredAttribute _cachedRequiredAttribute;
		
		public override void ValidateProperty(SerializedProperty property)
		{
			if (_cachedRequiredAttribute == null)
				_cachedRequiredAttribute = PropertyUtility.GetAttribute<RequiredAttribute>(property);
			
			RequiredAttribute requiredAttribute = _cachedRequiredAttribute;

			if (property.propertyType == SerializedPropertyType.ObjectReference)
			{
				if (property.objectReferenceValue == null)
				{
					string errorMessage = property.name + " is required";
					if (!string.IsNullOrEmpty(requiredAttribute.Message))
					{
						errorMessage = requiredAttribute.Message;
					}

					NaughtyEditorGUI.HelpBox_Layout(errorMessage, MessageType.Error, context: property.serializedObject.targetObject);
				}
			}
			else
			{
				string warning = requiredAttribute.GetType().Name + " works only on reference types";
				NaughtyEditorGUI.HelpBox_Layout(warning, MessageType.Warning, context: property.serializedObject.targetObject);
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyValidators/RequiredPropertyValidator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyValidators/ValidateInputPropertyValidator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 5f6adf84ed53a7840a456e8b4dce38d9
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEditor;
using System.Reflection;
using System;

namespace NaughtyAttributes.Editor
{
	public class ValidateInputPropertyValidator : PropertyValidatorBase
	{
		private ValidateInputAttribute _cachedValidateInputAttribute;
		
		public override void ValidateProperty(SerializedProperty property)
		{
			if (_cachedValidateInputAttribute == null)
				_cachedValidateInputAttribute = PropertyUtility.GetAttribute<ValidateInputAttribute>(property);
			
			ValidateInputAttribute validateInputAttribute = _cachedValidateInputAttribute;
			object target = PropertyUtility.GetTargetObjectWithProperty(property);

			MethodInfo validationCallback = ReflectionUtility.GetMethod(target, validateInputAttribute.CallbackName);

			if (validationCallback != null &&
				validationCallback.ReturnType == typeof(bool))
			{
				ParameterInfo[] callbackParameters = validationCallback.GetParameters();

				if (callbackParameters.Length == 0) {
					if (!(bool)validationCallback.Invoke(target, null))
					{
						if (string.IsNullOrEmpty(validateInputAttribute.Message))
						{
							NaughtyEditorGUI.HelpBox_Layout(
								property.name + " is not valid", MessageType.Error, context: property.serializedObject.targetObject);
						}
						else
						{
							NaughtyEditorGUI.HelpBox_Layout(
								validateInputAttribute.Message, MessageType.Error, context: property.serializedObject.targetObject);
						}
					}
				}
				else if (callbackParameters.Length == 1)
				{
					FieldInfo fieldInfo = ReflectionUtility.GetField(target, property.name);
					Type fieldType = fieldInfo.FieldType;
					Type parameterType = callbackParameters[0].ParameterType;

					if (fieldType == parameterType)
					{
						if (!(bool)validationCallback.Invoke(target, new object[] { fieldInfo.GetValue(target) }))
						{
							if (string.IsNullOrEmpty(validateInputAttribute.Message))
							{
								NaughtyEditorGUI.HelpBox_Layout(
									property.name + " is not valid", MessageType.Error, context: property.serializedObject.targetObject);
							}
							else
							{
								NaughtyEditorGUI.HelpBox_Layout(
									validateInputAttribute.Message, MessageType.Error, context: property.serializedObject.targetObject);
							}
						}
					}
					else
					{
						string warning = "The field type is not the same as the callback's parameter type";
						NaughtyEditorGUI.HelpBox_Layout(warning, MessageType.Warning, context: property.serializedObject.targetObject);
					}
				}
				else
				{
					string warning =
						validateInputAttribute.GetType().Name +
						" needs a callback with boolean return type and an optional single parameter of the same type as the field";

					NaughtyEditorGUI.HelpBox_Layout(warning, MessageType.Warning, context: property.serializedObject.targetObject);
				}
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/PropertyValidators/ValidateInputPropertyValidator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/Utility/ButtonUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a273f81125ec52d4cb5dec2228afda0e
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEngine;
using System.Reflection;
using System.Collections.Generic;

namespace NaughtyAttributes.Editor
{
	public static class ButtonUtility
	{
		public static bool IsEnabled(Object target, MethodInfo method)
		{
			EnableIfAttributeBase enableIfAttribute = method.GetCustomAttribute<EnableIfAttributeBase>();
			if (enableIfAttribute == null)
			{
				return true;
			}

			List<bool> conditionValues = PropertyUtility.GetConditionValues(target, enableIfAttribute.Conditions);
			if (conditionValues.Count > 0)
			{
				bool enabled = PropertyUtility.GetConditionsFlag(conditionValues, enableIfAttribute.ConditionOperator, enableIfAttribute.Inverted);
				return enabled;
			}
			else
			{
				string message = enableIfAttribute.GetType().Name + " needs a valid boolean condition field, property or method name to work";
				Debug.LogWarning(message, target);

				return false;
			}
		}

		public static bool IsVisible(Object target, MethodInfo method)
		{
			ShowIfAttributeBase showIfAttribute = method.GetCustomAttribute<ShowIfAttributeBase>();
			if (showIfAttribute == null)
			{
				return true;
			}

			List<bool> conditionValues = PropertyUtility.GetConditionValues(target, showIfAttribute.Conditions);
			if (conditionValues.Count > 0)
			{
				bool enabled = PropertyUtility.GetConditionsFlag(conditionValues, showIfAttribute.ConditionOperator, showIfAttribute.Inverted);
				return enabled;
			}
			else
			{
				string message = showIfAttribute.GetType().Name + " needs a valid boolean condition field, property or method name to work";
				Debug.LogWarning(message, target);

				return false;
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/Utility/ButtonUtility.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/Utility/NaughtyEditorGUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6ff27ff7705d6064e935bb2159a1b453
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using System;
using System.Collections;
using System.Linq;
using System.Reflection;

using UnityEditor;
using UnityEditor.Experimental.SceneManagement;
using UnityEditor.SceneManagement;
using UnityEngine;

namespace NaughtyAttributes.Editor
{
	public static class NaughtyEditorGUI
	{
		public const float IndentLength = 15.0f;
		public const float HorizontalSpacing = 2.0f;

		private static GUIStyle _buttonStyle = new GUIStyle(GUI.skin.button) { richText = true };

		private delegate void PropertyFieldFunction(Rect rect, NaughtyProperty naughtyProperty, GUIContent label, bool includeChildren);

		public static bool PropertyField(Rect rect, NaughtyProperty naughtyProperty, bool includeChildren)
		{
			return PropertyField_Implementation(rect, naughtyProperty, includeChildren, DrawPropertyField);
		}

		public static bool PropertyField_Layout(NaughtyProperty naughtyProperty, bool includeChildren)
		{
			Rect dummyRect = new Rect();
			return PropertyField_Implementation(dummyRect, naughtyProperty, includeChildren, DrawPropertyField_Layout);
		}

		private static void DrawPropertyField(Rect rect, NaughtyProperty naughtyProperty, GUIContent label, bool includeChildren)
		{
			EditorGUI.PropertyField(rect, naughtyProperty.serializedProperty, label, includeChildren);
		}

		private static void DrawPropertyField_Layout(Rect rect, NaughtyProperty naughtyProperty, GUIContent label, bool includeChildren)
		{
			EditorGUILayout.PropertyField(naughtyProperty.serializedProperty, label, includeChildren);
		}

		private static bool PropertyField_Implementation(Rect rect, NaughtyProperty naughtyProperty, bool includeChildren, PropertyFieldFunction propertyFieldFunction)
		{
			bool changeDetected = false;
			
			if (naughtyProperty.specialCaseDrawerAttribute != null)
			{
				return naughtyProperty.specialCaseDrawerAttribute.GetDrawer().OnGUI(rect, naughtyProperty);
			}
			else
			{
				// Check if visible
				if (!naughtyProperty.cachedIsVisible)
				{
					return false;
				}
				
				// Validate
				foreach (var validatorAttribute in naughtyProperty.validatorAttributes)
				{
					validatorAttribute.GetValidator().ValidateProperty(naughtyProperty.serializedProperty);
				}
				
				// Check if enabled and draw
				EditorGUI.BeginChangeCheck();
				bool enabled = naughtyProperty.cachedIsEnabled;
				
				using (new EditorGUI.DisabledScope(disabled: !enabled))
				{
					propertyFieldFunction.Invoke(rect, naughtyProperty, PropertyUtility.GetLabel(naughtyProperty.labelAttribute, naughtyProperty.serializedProperty), includeChildren);
				}
				
				// Call OnValueChanged callbacks
				if (EditorGUI.EndChangeCheck())
				{
					changeDetected = true;
					PropertyUtility.CallOnValueChangedCallbacks(naughtyProperty.serializedProperty);
				}
			}

			return changeDetected;
		}

		public static float GetIndentLength(Rect sourceRect)
		{
			Rect indentRect = EditorGUI.IndentedRect(sourceRect);
			float indentLength = indentRect.x - sourceRect.x;

			return indentLength;
		}

		public static void BeginBoxGroup_Layout(string label = "")
		{
			EditorGUILayout.BeginVertical(GUI.skin.box);
			if (!string.IsNullOrEmpty(label))
			{
				EditorGUILayout.LabelField(label, EditorStyles.boldLabel);
			}
		}

		public static void EndBoxGroup_Layout()
		{
			EditorGUILayout.EndVertical();
		}

		/// <summary>
		/// Creates a dropdown
		/// </summary>
		/// <param name="rect">The rect the defines the position and size of the dropdown in the inspector</param>
		/// <param name="serializedObject">The serialized object that is being updated</param>
		/// <param name="target">The target object that contains the dropdown</param>
		/// <param name="dropdownField">The field of the target object that holds the currently selected dropdown value</param>
		/// <param name="label">The label of the dropdown</param>
		/// <param name="selectedValueIndex">The index of the value from the values array</param>
		/// <param name="values">The values of the dropdown</param>
		/// <param name="displayOptions">The display options for the values</param>
		public static void Dropdown(
			Rect rect, SerializedObject serializedObject, object target, FieldInfo dropdownField,
			string label, int selectedValueIndex, object[] values, string[] displayOptions)
		{
			EditorGUI.BeginChangeCheck();

			int newIndex = EditorGUI.Popup(rect, label, selectedValueIndex, displayOptions);
			object newValue = values[newIndex];

			if (!dropdownField.GetValue(target).Equals(newValue))
			{
				Undo.RecordObject(serializedObject.targetObject, "Dropdown");

				// TODO: Problem with structs, because they are value type.
				// The solution is to make boxing/unboxing but unfortunately I don't know the compile time type of the target object
				dropdownField.SetValue(target, newValue);
			}
		}

		public static void Button(UnityEngine.Object target, MethodInfo methodInfo)
		{
			bool visible = ButtonUtility.IsVisible(target, methodInfo);
			if (!visible)
			{
				return;
			}

			if (methodInfo.GetParameters().All(p => p.IsOptional))
			{
				ButtonAttribute buttonAttribute = (ButtonAttribute)methodInfo.GetCustomAttributes(typeof(ButtonAttribute), true)[0];
				string buttonText = string.IsNullOrEmpty(buttonAttribute.Text) ? ObjectNames.NicifyVariableName(methodInfo.Name) : buttonAttribute.Text;

				bool buttonEnabled = ButtonUtility.IsEnabled(target, methodInfo);

				EButtonEnableMode mode = buttonAttribute.SelectedEnableMode;
				buttonEnabled &=
					mode == EButtonEnableMode.Always ||
					mode == EButtonEnableMode.Editor && !Application.isPlaying ||
					mode == EButtonEnableMode.Playmode && Application.isPlaying;

				bool methodIsCoroutine = methodInfo.ReturnType == typeof(IEnumerator);
				if (methodIsCoroutine)
				{
					buttonEnabled &= (Application.isPlaying ? true : false);
				}

				EditorGUI.BeginDisabledGroup(!buttonEnabled);

				if (GUILayout.Button(buttonText, _buttonStyle))
				{
					object[] defaultParams = methodInfo.GetParameters().Select(p => p.DefaultValue).ToArray();
					IEnumerator methodResult = methodInfo.Invoke(target, defaultParams) as IEnumerator;

					if (!Application.isPlaying)
					{
						// Set target object and scene dirty to serialize changes to disk
						EditorUtility.SetDirty(target);

						PrefabStage stage = PrefabStageUtility.GetCurrentPrefabStage();
						if (stage != null)
						{
							// Prefab mode
							EditorSceneManager.MarkSceneDirty(stage.scene);
						}
						else
						{
							// Normal scene
							EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
						}
					}
					else if (methodResult != null && target is MonoBehaviour behaviour)
					{
						behaviour.StartCoroutine(methodResult);
					}
				}

				EditorGUI.EndDisabledGroup();
			}
			else
			{
				string warning = typeof(ButtonAttribute).Name + " works only on methods with no parameters";
				HelpBox_Layout(warning, MessageType.Warning, context: target, logToConsole: true);
			}
		}

		public static void NativeProperty_Layout(UnityEngine.Object target, PropertyInfo property)
		{
			object value = property.GetValue(target, null);

			if (value == null)
			{
				string warning = string.Format("{0} is null. {1} doesn't support reference types with null value", property.Name, typeof(ShowNativePropertyAttribute).Name);
				HelpBox_Layout(warning, MessageType.Warning, context: target);
			}
			else if (!Field_Layout(value, property.Name))
			{
				string warning = string.Format("{0} doesn't support {1} types", typeof(ShowNativePropertyAttribute).Name, property.PropertyType.Name);
				HelpBox_Layout(warning, MessageType.Warning, context: target);
			}
		}

		public static void NonSerializedField_Layout(UnityEngine.Object target, FieldInfo field)
		{
			object value = field.GetValue(target);

			if (value == null)
			{
				string warning = string.Format("{0} is null. {1} doesn't support reference types with null value", field.Name, typeof(ShowNonSerializedFieldAttribute).Name);
				HelpBox_Layout(warning, MessageType.Warning, context: target);
			}
			else if (!Field_Layout(value, field.Name))
			{
				string warning = string.Format("{0} doesn't support {1} types", typeof(ShowNonSerializedFieldAttribute).Name, field.FieldType.Name);
				HelpBox_Layout(warning, MessageType.Warning, context: target);
			}
		}

		public static void HorizontalLine(Rect rect, float height, Color color)
		{
			rect.height = height;
			EditorGUI.DrawRect(rect, color);
		}

		public static void HelpBox(Rect rect, string message, MessageType type, UnityEngine.Object context = null, bool logToConsole = false)
		{
			EditorGUI.HelpBox(rect, message, type);

			if (logToConsole)
			{
				DebugLogMessage(message, type, context);
			}
		}

		public static void HelpBox_Layout(string message, MessageType type, UnityEngine.Object context = null, bool logToConsole = false)
		{
			EditorGUILayout.HelpBox(message, type);

			if (logToConsole)
			{
				DebugLogMessage(message, type, context);
			}
		}

		public static bool Field_Layout(object value, string label)
		{
			using (new EditorGUI.DisabledScope(disabled: true))
			{
				bool isDrawn = true;
				Type valueType = value.GetType();

				if (valueType == typeof(bool))
				{
					EditorGUILayout.Toggle(label, (bool)value);
				}
				else if (valueType == typeof(short))
				{
					EditorGUILayout.IntField(label, (short)value);
				}
				else if (valueType == typeof(ushort))
				{
					EditorGUILayout.IntField(label, (ushort)value);
				}
				else if (valueType == typeof(int))
				{
					EditorGUILayout.IntField(label, (int)value);
				}
				else if (valueType == typeof(uint))
				{
					EditorGUILayout.LongField(label, (uint)value);
				}
				else if (valueType == typeof(long))
				{
					EditorGUILayout.LongField(label, (long)value);
				}
				else if (valueType == typeof(ulong))
				{
					EditorGUILayout.TextField(label, ((ulong)value).ToString());
				}
				else if (valueType == typeof(float))
				{
					EditorGUILayout.FloatField(label, (float)value);
				}
				else if (valueType == typeof(double))
				{
					EditorGUILayout.DoubleField(label, (double)value);
				}
				else if (valueType == typeof(string))
				{
					EditorGUILayout.TextField(label, (string)value);
				}
				else if (valueType == typeof(Vector2))
				{
					EditorGUILayout.Vector2Field(label, (Vector2)value);
				}
				else if (valueType == typeof(Vector3))
				{
					EditorGUILayout.Vector3Field(label, (Vector3)value);
				}
				else if (valueType == typeof(Vector4))
				{
					EditorGUILayout.Vector4Field(label, (Vector4)value);
				}
				else if (valueType == typeof(Vector2Int))
				{
					EditorGUILayout.Vector2IntField(label, (Vector2Int)value);
				}
				else if (valueType == typeof(Vector3Int))
				{
					EditorGUILayout.Vector3IntField(label, (Vector3Int)value);
				}
				else if (valueType == typeof(Color))
				{
					EditorGUILayout.ColorField(label, (Color)value);
				}
				else if (valueType == typeof(Bounds))
				{
					EditorGUILayout.BoundsField(label, (Bounds)value);
				}
				else if (valueType == typeof(Rect))
				{
					EditorGUILayout.RectField(label, (Rect)value);
				}
				else if (valueType == typeof(RectInt))
				{
					EditorGUILayout.RectIntField(label, (RectInt)value);
				}
				else if (typeof(UnityEngine.Object).IsAssignableFrom(valueType))
				{
					EditorGUILayout.ObjectField(label, (UnityEngine.Object)value, valueType, true);
				}
				else if (valueType.BaseType == typeof(Enum))
				{
					EditorGUILayout.EnumPopup(label, (Enum)value);
				}
				else if (valueType.BaseType == typeof(System.Reflection.TypeInfo))
				{
					EditorGUILayout.TextField(label, value.ToString());
				}
				else
				{
					isDrawn = false;
				}

				return isDrawn;
			}
		}

		private static void DebugLogMessage(string message, MessageType type, UnityEngine.Object context)
		{
			switch (type)
			{
				case MessageType.None:
				case MessageType.Info:
					Debug.Log(message, context);
					break;
				case MessageType.Warning:
					Debug.LogWarning(message, context);
					break;
				case MessageType.Error:
					Debug.LogError(message, context);
					break;
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/Utility/NaughtyEditorGUI.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/Utility/PropertyUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 312eedcb79c7a5542b87c0b848e3e2fa
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEditor;
using System.Reflection;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace NaughtyAttributes.Editor
{
	public static class PropertyUtility
	{
		public static T GetAttribute<T>(SerializedProperty property) where T : class
		{
			T[] attributes = GetAttributes<T>(property);
			return (attributes.Length > 0) ? attributes[0] : null;
		}

		public static T[] GetAttributes<T>(SerializedProperty property) where T : class
		{
			FieldInfo fieldInfo = ReflectionUtility.GetField(GetTargetObjectWithProperty(property), property.name);
			if (fieldInfo == null)
			{
				return new T[] { };
			}

			return (T[])fieldInfo.GetCustomAttributes(typeof(T), true);
		}

		public static NaughtyProperty CreateNaughtyProperty(SerializedProperty serializedProperty)
		{
			NaughtyProperty naughtyProperty = new NaughtyProperty();
			naughtyProperty.serializedProperty = serializedProperty;

			naughtyProperty.readOnlyAttribute = PropertyUtility.GetAttribute<ReadOnlyAttribute>(serializedProperty);
			naughtyProperty.enableIfAttribute = PropertyUtility.GetAttribute<EnableIfAttributeBase>(serializedProperty);
						
			naughtyProperty.showIfAttribute = PropertyUtility.GetAttribute<ShowIfAttributeBase>(serializedProperty);
			naughtyProperty.validatorAttributes = PropertyUtility.GetAttributes<ValidatorAttribute>(serializedProperty);

			naughtyProperty.labelAttribute = PropertyUtility.GetAttribute<LabelAttribute>(serializedProperty);
			
			naughtyProperty.specialCaseDrawerAttribute =
				PropertyUtility.GetAttribute<SpecialCaseDrawerAttribute>(serializedProperty);
			
			return naughtyProperty;
		}

		public static GUIContent GetLabel(SerializedProperty property)
		{
			LabelAttribute labelAttribute = GetAttribute<LabelAttribute>(property);
			return GetLabel(labelAttribute, property);
		}
		
		public static GUIContent GetLabel(LabelAttribute labelAttribute, SerializedProperty property)
		{
			string labelText = (labelAttribute == null)
				? property.displayName
				: labelAttribute.Label;

			GUIContent label = new GUIContent(labelText);
			return label;
		}

		public static void CallOnValueChangedCallbacks(SerializedProperty property)
		{
			OnValueChangedAttribute[] onValueChangedAttributes = GetAttributes<OnValueChangedAttribute>(property);
			if (onValueChangedAttributes.Length == 0)
			{
				return;
			}

			object target = GetTargetObjectWithProperty(property);
			property.serializedObject.ApplyModifiedProperties(); // We must apply modifications so that the new value is updated in the serialized object

			foreach (var onValueChangedAttribute in onValueChangedAttributes)
			{
				MethodInfo callbackMethod = ReflectionUtility.GetMethod(target, onValueChangedAttribute.CallbackName);
				if (callbackMethod != null &&
					callbackMethod.ReturnType == typeof(void) &&
					callbackMethod.GetParameters().Length == 0)
				{
					callbackMethod.Invoke(target, new object[] { });
				}
				else
				{
					string warning = string.Format(
						"{0} can invoke only methods with 'void' return type and 0 parameters",
						onValueChangedAttribute.GetType().Name);

					Debug.LogWarning(warning, property.serializedObject.targetObject);
				}
			}
		}

		public static bool IsEnabled(SerializedProperty property)
		{
			ReadOnlyAttribute readOnlyAttribute = GetAttribute<ReadOnlyAttribute>(property);
			EnableIfAttributeBase enableIfAttribute = GetAttribute<EnableIfAttributeBase>(property);

			return IsEnabled(readOnlyAttribute, enableIfAttribute, property);
		}

		public static bool IsEnabled(ReadOnlyAttribute readOnlyAttribute, EnableIfAttributeBase enableIfAttribute, SerializedProperty property)
		{
			if (readOnlyAttribute != null)
			{
				return false;
			}
			
			if (enableIfAttribute == null)
			{
				return true;
			}
			
			object target = GetTargetObjectWithProperty(property);

			// deal with enum conditions
			if (enableIfAttribute.EnumValue != null)
			{
				Enum value = GetEnumValue(target, enableIfAttribute.Conditions[0]);
				if (value != null)
				{
					bool matched = value.GetType().GetCustomAttribute<FlagsAttribute>() == null
						? enableIfAttribute.EnumValue.Equals(value)
						: value.HasFlag(enableIfAttribute.EnumValue);

					return matched != enableIfAttribute.Inverted;
				}

				string message = enableIfAttribute.GetType().Name + " needs a valid enum field, property or method name to work";
				Debug.LogWarning(message, property.serializedObject.targetObject);

				return false;
			}

			// deal with normal conditions
			List<bool> conditionValues = GetConditionValues(target, enableIfAttribute.Conditions);
			if (conditionValues.Count > 0)
			{
				bool enabled = GetConditionsFlag(conditionValues, enableIfAttribute.ConditionOperator, enableIfAttribute.Inverted);
				return enabled;
			}
			else
			{
				string message = enableIfAttribute.GetType().Name + " needs a valid boolean condition field, property or method name to work";
				Debug.LogWarning(message, property.serializedObject.targetObject);

				return false;
			}
		}
		
		public static bool IsVisible(SerializedProperty property)
		{
			ShowIfAttributeBase showIfAttribute = GetAttribute<ShowIfAttributeBase>(property);

			return IsVisible(showIfAttribute, property);
		}

		public static bool IsVisible(ShowIfAttributeBase showIfAttribute, SerializedProperty property)
		{
			if (showIfAttribute == null)
			{
				return true;
			}
			
			object target = GetTargetObjectWithProperty(property);

			// deal with enum conditions
			if (showIfAttribute.EnumValue != null)
			{
				Enum value = GetEnumValue(target, showIfAttribute.Conditions[0]);
				if (value != null)
				{
					bool matched = value.GetType().GetCustomAttribute<FlagsAttribute>() == null
						? showIfAttribute.EnumValue.Equals(value)
						: value.HasFlag(showIfAttribute.EnumValue);

					return matched != showIfAttribute.Inverted;
				}

				string message = showIfAttribute.GetType().Name +
				                 " needs a valid enum field, property or method name to work";
				Debug.LogWarning(message, property.serializedObject.targetObject);

				return false;
			}

			// deal with normal conditions
			List<bool> conditionValues = GetConditionValues(target, showIfAttribute.Conditions);
			if (conditionValues.Count > 0)
			{
				bool enabled = GetConditionsFlag(conditionValues, showIfAttribute.ConditionOperator,
					showIfAttribute.Inverted);
				return enabled;
			}
			else
			{
				string message = showIfAttribute.GetType().Name +
				                 " needs a valid boolean condition field, property or method name to work";
				Debug.LogWarning(message, property.serializedObject.targetObject);

				return false;
			}
		}

		/// <summary>
		///		Gets an enum value from reflection.
		/// </summary>
		/// <param name="target">The target object.</param>
		/// <param name="enumName">Name of a field, property, or method that returns an enum.</param>
		/// <returns>Null if can't find an enum value.</returns>
		internal static Enum GetEnumValue(object target, string enumName)
		{
			FieldInfo enumField = ReflectionUtility.GetField(target, enumName);
			if (enumField != null && enumField.FieldType.IsSubclassOf(typeof(Enum)))
			{
				return (Enum)enumField.GetValue(target);
			}

			PropertyInfo enumProperty = ReflectionUtility.GetProperty(target, enumName);
			if (enumProperty != null && enumProperty.PropertyType.IsSubclassOf(typeof(Enum)))
			{
				return (Enum)enumProperty.GetValue(target);
			}

			MethodInfo enumMethod = ReflectionUtility.GetMethod(target, enumName);
			if (enumMethod != null && enumMethod.ReturnType.IsSubclassOf(typeof(Enum)))
			{
				return (Enum)enumMethod.Invoke(target, null);
			}

			return null;
		}

		internal static List<bool> GetConditionValues(object target, string[] conditions)
		{
			List<bool> conditionValues = new List<bool>();
			foreach (var condition in conditions)
			{
				FieldInfo conditionField = ReflectionUtility.GetField(target, condition);
				if (conditionField != null &&
					conditionField.FieldType == typeof(bool))
				{
					conditionValues.Add((bool)conditionField.GetValue(target));
				}

				PropertyInfo conditionProperty = ReflectionUtility.GetProperty(target, condition);
				if (conditionProperty != null &&
					conditionProperty.PropertyType == typeof(bool))
				{
					conditionValues.Add((bool)conditionProperty.GetValue(target));
				}

				MethodInfo conditionMethod = ReflectionUtility.GetMethod(target, condition);
				if (conditionMethod != null &&
					conditionMethod.ReturnType == typeof(bool) &&
					conditionMethod.GetParameters().Length == 0)
				{
					conditionValues.Add((bool)conditionMethod.Invoke(target, null));
				}
			}

			return conditionValues;
		}

		internal static bool GetConditionsFlag(List<bool> conditionValues, EConditionOperator conditionOperator, bool invert)
		{
			bool flag;
			if (conditionOperator == EConditionOperator.And)
			{
				flag = true;
				foreach (var value in conditionValues)
				{
					flag = flag && value;
				}
			}
			else
			{
				flag = false;
				foreach (var value in conditionValues)
				{
					flag = flag || value;
				}
			}

			if (invert)
			{
				flag = !flag;
			}

			return flag;
		}

		public static Type GetPropertyType(SerializedProperty property)
		{
			object obj = GetTargetObjectOfProperty(property);
			Type objType = obj.GetType();

			return objType;
		}

		/// <summary>
		/// Gets the object the property represents.
		/// </summary>
		/// <param name="property"></param>
		/// <returns></returns>
		public static object GetTargetObjectOfProperty(SerializedProperty property)
		{
			if (property == null)
			{
				return null;
			}

			string path = property.propertyPath.Replace(".Array.data[", "[");
			object obj = property.serializedObject.targetObject;
			string[] elements = path.Split('.');

			foreach (var element in elements)
			{
				if (element.Contains("["))
				{
					string elementName = element.Substring(0, element.IndexOf("["));
					int index = Convert.ToInt32(element.Substring(element.IndexOf("[")).Replace("[", "").Replace("]", ""));
					obj = GetValue_Imp(obj, elementName, index);
				}
				else
				{
					obj = GetValue_Imp(obj, element);
				}
			}

			return obj;
		}

		/// <summary>
		/// Gets the object that the property is a member of
		/// </summary>
		/// <param name="property"></param>
		/// <returns></returns>
		public static object GetTargetObjectWithProperty(SerializedProperty property)
		{
			string path = property.propertyPath.Replace(".Array.data[", "[");
			object obj = property.serializedObject.targetObject;
			string[] elements = path.Split('.');

			for (int i = 0; i < elements.Length - 1; i++)
			{
				string element = elements[i];
				if (element.Contains("["))
				{
					string elementName = element.Substring(0, element.IndexOf("["));
					int index = Convert.ToInt32(element.Substring(element.IndexOf("[")).Replace("[", "").Replace("]", ""));
					obj = GetValue_Imp(obj, elementName, index);
				}
				else
				{
					obj = GetValue_Imp(obj, element);
				}
			}

			return obj;
		}

		private static object GetValue_Imp(object source, string name)
		{
			if (source == null)
			{
				return null;
			}

			Type type = source.GetType();

			while (type != null)
			{
				FieldInfo field = type.GetField(name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance);
				if (field != null)
				{
					return field.GetValue(source);
				}

				PropertyInfo property = type.GetProperty(name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
				if (property != null)
				{
					return property.GetValue(source, null);
				}

				type = type.BaseType;
			}

			return null;
		}

		private static object GetValue_Imp(object source, string name, int index)
		{
			IEnumerable enumerable = GetValue_Imp(source, name) as IEnumerable;
			if (enumerable == null)
			{
				return null;
			}

			IEnumerator enumerator = enumerable.GetEnumerator();
			for (int i = 0; i <= index; i++)
			{
				if (!enumerator.MoveNext())
				{
					return null;
				}
			}

			return enumerator.Current;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/Utility/PropertyUtility.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/Utility/ReflectionUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1d86c581f02a55f458e36bf7e81e3084
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEngine;

namespace NaughtyAttributes.Editor
{
	public static class ReflectionUtility
	{
		public static IEnumerable<FieldInfo> GetAllFields(object target, Func<FieldInfo, bool> predicate)
		{
			if (target == null)
			{
				Debug.LogError("The target object is null. Check for missing scripts.");
				yield break;
			}

			List<Type> types = GetSelfAndBaseTypes(target);

			for (int i = types.Count - 1; i >= 0; i--)
			{
				IEnumerable<FieldInfo> fieldInfos = types[i]
					.GetFields(BindingFlags.Instance | BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.DeclaredOnly)
					.Where(predicate);

				foreach (var fieldInfo in fieldInfos)
				{
					yield return fieldInfo;
				}
			}
		}

		public static IEnumerable<PropertyInfo> GetAllProperties(object target, Func<PropertyInfo, bool> predicate)
		{
			if (target == null)
			{
				Debug.LogError("The target object is null. Check for missing scripts.");
				yield break;
			}

			List<Type> types = GetSelfAndBaseTypes(target);

			for (int i = types.Count - 1; i >= 0; i--)
			{
				IEnumerable<PropertyInfo> propertyInfos = types[i]
					.GetProperties(BindingFlags.Instance | BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.DeclaredOnly)
					.Where(predicate);

				foreach (var propertyInfo in propertyInfos)
				{
					yield return propertyInfo;
				}
			}
		}

		public static IEnumerable<MethodInfo> GetAllMethods(object target, Func<MethodInfo, bool> predicate)
		{
			if (target == null)
			{
				Debug.LogError("The target object is null. Check for missing scripts.");
				yield break;
			}

			List<Type> types = GetSelfAndBaseTypes(target);

			for (int i = types.Count - 1; i >= 0; i--)
			{
				IEnumerable<MethodInfo> methodInfos = types[i]
					.GetMethods(BindingFlags.Instance | BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.DeclaredOnly)
					.Where(predicate);

				foreach (var methodInfo in methodInfos)
				{
					yield return methodInfo;
				}
			}
		}

		public static FieldInfo GetField(object target, string fieldName)
		{
			return GetAllFields(target, f => f.Name.Equals(fieldName, StringComparison.Ordinal)).FirstOrDefault();
		}

		public static PropertyInfo GetProperty(object target, string propertyName)
		{
			return GetAllProperties(target, p => p.Name.Equals(propertyName, StringComparison.Ordinal)).FirstOrDefault();
		}

		public static MethodInfo GetMethod(object target, string methodName)
		{
			return GetAllMethods(target, m => m.Name.Equals(methodName, StringComparison.Ordinal)).FirstOrDefault();
		}

		public static Type GetListElementType(Type listType)
		{
			if (listType.IsGenericType)
			{
				return listType.GetGenericArguments()[0];
			}
			else
			{
				return listType.GetElementType();
			}
		}

		/// <summary>
		///		Get type and all base types of target, sorted as following:
		///		<para />[target's type, base type, base's base type, ...]
		/// </summary>
		/// <param name="target"></param>
		/// <returns></returns>
		private static List<Type> GetSelfAndBaseTypes(object target)
		{
			List<Type> types = new List<Type>()
			{
				target.GetType()
			};

			while (types.Last().BaseType != null)
			{
				types.Add(types.Last().BaseType);
			}

			return types;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/Utility/ReflectionUtility.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/Utility/SavedBool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 18613afe66b0c0344a2be5f430bf965a
# ASMDEF: NaughtyAttributes.Editor.dll
# ---
using UnityEditor;

namespace NaughtyAttributes.Editor
{
	internal class SavedBool
	{
		private bool _value;
		private string _name;

		public bool Value
		{
			get
			{
				return _value;
			}
			set
			{
				if (_value == value)
				{
					return;
				}

				_value = value;
				EditorPrefs.SetBool(_name, value);
			}
		}

		public SavedBool(string name, bool value)
		{
			_name = name;
			_value = EditorPrefs.GetBool(name, value);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Editor/Utility/SavedBool.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Editor/AutoHandSetupWizard.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f6b04d9364665ab4c9e634f1f2486f73
# ASMDEF: Autohand.Editor.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using System.IO;
using System.Threading;
using Autohand;

namespace AutoHand {
    [InitializeOnLoad]
    public class AutoHandSetupWizard : EditorWindow {
        public Texture autohandlogo;

        static AutoHandSetupWizard window;
        static string[] requiredLayerNames = { "Grabbing", "Grabbable", "Hand", "HandPlayer" };
        static string assetPath;


        public static float quality = 2;

        static AutoHandSettings _handSettings = null;
        static AutoHandSettings handSettings {
            get {
                if(_handSettings == null)
                    _handSettings = Resources.Load<AutoHandSettings>("AutoHandSettings");
                return _handSettings;
            }
        }

        static AutoHandSetupWizard() {
            EditorApplication.update += Start;
        }


        static void Start() {
            SetRequiredSettings();

            if(ShowSetupWindow()) {
                OpenWindow();
                Application.OpenURL("https://earnest-robot.gitbook.io/auto-hand-docs/");
                assetPath = Application.dataPath;
            }

            EditorApplication.update -= Start;
        }

        [MenuItem("Window/Autohand/Setup Window")]
        public static void OpenWindow() {
            window = GetWindow<AutoHandSetupWizard>(true);
            window.minSize = new Vector2(320, 440);
            window.maxSize = new Vector2(360, 500);
            window.titleContent = new GUIContent("Auto Hand Setup");
            SetRequiredSettings();
        }

        void OnDestroy() {
            SetRequiredSettings();
        }


        public void OnGUI() {

            if(autohandlogo == null) {
                var assets = AssetDatabase.FindAssets("AutohandLogo");
                if(assets.Length > 0)
                    autohandlogo = AssetDatabase.LoadAssetAtPath<Texture>(AssetDatabase.GUIDToAssetPath(assets[0]));
            }

            var rect = EditorGUILayout.GetControlRect();
            rect.height *= 5;
            GUI.Label(rect, autohandlogo, AutoHandExtensions.LabelStyle(TextAnchor.MiddleCenter, FontStyle.Normal, 25));
            rect = EditorGUILayout.GetControlRect();
            rect = EditorGUILayout.GetControlRect();
            rect = EditorGUILayout.GetControlRect();

            GUILayout.Space(12f);
            GUI.Label(qualityLabelRect, "AUTO HAND SETUP", AutoHandExtensions.LabelStyle(TextAnchor.MiddleCenter, FontStyle.Normal, 25));
            GUILayout.Space(12f);

            GUI.Label(qualityLabelRect, "RECOMMENDED PHYSICS SETTINGS", AutoHandExtensions.LabelStyle(TextAnchor.MiddleCenter, FontStyle.Normal, 19));
            GUILayout.Space(24f);

            GUI.Label(qualityLabelRect, "Physics Quality", AutoHandExtensions.LabelStyle(TextAnchor.MiddleCenter, FontStyle.Normal, 16));
            GUILayout.Space(5f);

            quality = GUI.HorizontalSlider(qualitySliderRect, quality, -1, 3);
            quality = Mathf.Round(quality);

            GUI.Label(qualityLabelRect, QualityGUIContent(quality), AutoHandExtensions.LabelStyle(QualityColor(quality), TextAnchor.MiddleCenter));


            ShowQualitySettings(quality);


            GUILayout.Space(30f);
            if(GUI.Button(qualitySliderRect, "Apply")) {
                handSettings.quality = quality;
                SetPhysicsSettings(handSettings.quality);
                EditorUtility.SetDirty(handSettings); 
                var physicsManager = AssetDatabase.LoadAllAssetsAtPath("ProjectSettings/DynamicsManager.asset")[0];
                if(physicsManager != null) {
                    EditorUtility.SetDirty(physicsManager);
                }
                this.Close();
            }

            ShowDoNotShowButton();
        }


        public void ShowQualitySettings(float quality) {

            GUILayout.Space(15);
            var labelStyle = AutoHandExtensions.LabelStyle(new Color(0.7f, 0.7f, 0.7f, 1f));
            var labelStyleB = AutoHandExtensions.LabelStyleB(new Color(0.7f, 0.7f, 0.7f, 1f));

            handSettings.useAutomaticControllerOffset = GUI.Toggle(qualitySliderRect, handSettings.useAutomaticControllerOffset, "Automatic Controller Offset", labelStyleB);
            handSettings.usingDynamicTimestep = GUI.Toggle(qualitySliderRect, handSettings.usingDynamicTimestep, "Dynamic Timestep", labelStyleB);

            if(quality <= -1) {
                GUI.Label(qualitySliderRect, "Ignore Recommended Settings", labelStyle);
            }
            else if(quality <= 0) {
                if(!handSettings.usingDynamicTimestep)
                    GUI.Label(qualitySliderRect, "Fixed Timestep: 1/50", labelStyle);
                GUI.Label(qualitySliderRect, "Contact Offset: 0.01", labelStyle);
                GUI.Label(qualitySliderRect, "Solver Iterations: 10", labelStyle);
                GUI.Label(qualitySliderRect, "Solver Velocity Iterations: 5", labelStyle);
            }
            else if(quality <= 1) {
                if(!handSettings.usingDynamicTimestep)
                    GUI.Label(qualitySliderRect, "Fixed Timestep: 1/60", labelStyle);
                GUI.Label(qualitySliderRect, "Contact Offset: 0.01", labelStyle);
                GUI.Label(qualitySliderRect, "Solver Iterations: 10", labelStyle);
                GUI.Label(qualitySliderRect, "Solver Velocity Iterations: 5", labelStyle);
                GUI.Label(qualitySliderRect, "Enable Adaptive Force: true", labelStyle);
            }
            else if(quality <= 2) {
                if(!handSettings.usingDynamicTimestep)
                    GUI.Label(qualitySliderRect, "Fixed Timestep: 1/72", labelStyle);
                GUI.Label(qualitySliderRect, "Contact Offset: 0.005", labelStyle);
                GUI.Label(qualitySliderRect, "Solver Iterations: 20", labelStyle);
                GUI.Label(qualitySliderRect, "Solver Velocity Iterations: 10", labelStyle);
                GUI.Label(qualitySliderRect, "Enable Adaptive Force: true", labelStyle);
            }
            else if(quality <= 3) {
                if(!handSettings.usingDynamicTimestep)
                    GUI.Label(qualitySliderRect, "Fixed Timestep: 1/90", labelStyle);
                GUI.Label(qualitySliderRect, "Contact Offset: 0.0035", labelStyle);
                GUI.Label(qualitySliderRect, "Solver Iterations: 50", labelStyle);
                GUI.Label(qualitySliderRect, "Solver Velocity Iterations: 50", labelStyle);
                GUI.Label(qualitySliderRect, "Enable Adaptive Force: true", labelStyle);
            }

        }

        public static void SetPhysicsSettings(float quality) {

            if(quality <= 0) {
                Time.fixedDeltaTime = 1 / 50f;
                Physics.defaultContactOffset = 0.01f;
                Physics.defaultSolverIterations = 10;
                Physics.defaultSolverVelocityIterations = 5;
                Physics.defaultMaxAngularSpeed = 35f;

            }
            else if(quality <= 1) {
                EnableAdaptiveForce();
                Time.fixedDeltaTime = 1 / 60f;
                Physics.defaultContactOffset = 0.0075f;
                Physics.defaultSolverIterations = 10;
                Physics.defaultSolverVelocityIterations = 5;
                Physics.defaultMaxAngularSpeed = 35f;
            }
            else if(quality <= 2) {
                EnableAdaptiveForce();
                Time.fixedDeltaTime = 1 / 72f;
                Physics.defaultContactOffset = 0.005f;
                Physics.defaultSolverIterations = 20;
                Physics.defaultSolverVelocityIterations = 10;
                Physics.defaultMaxAngularSpeed = 35f;
            }
            else if(quality <= 3) {
                EnableAdaptiveForce();
                Time.fixedDeltaTime = 1 / 90f;
                Physics.defaultContactOffset = 0.0035f;
                Physics.defaultSolverIterations = 30;
                Physics.defaultSolverVelocityIterations = 20;
                Physics.defaultMaxAngularSpeed = 35f;

            }
        }

        public static void SetRequiredSettings() {
            if(!LayersExist()) {
                GenerateAutoHandLayers();
                UpdateRequiredCollisionLayers();
            }
            if(!IsIgnoreCollisionSet()) {
                UpdateRequiredCollisionLayers();
            }
        }


        void ShowDoNotShowButton() {
            var GUIColor = GUI.backgroundColor;
            GUI.backgroundColor = new Color(0.7f, 0.4f, 0.4f);
            GUILayout.Space(30f);
            var buttonRect = new Rect(qualitySliderRect);
            buttonRect.width /= 1.5f;
            buttonRect.height /= 1f;
            buttonRect.x += buttonRect.width / 4f;
            if(GUI.Button(buttonRect, "Dont Show Again")) {
                EditorUtility.SetDirty(handSettings);
                handSettings.ignoreSetup = true;
                this.Close();
            }
            GUI.backgroundColor = GUIColor;
        }


        public Rect qualitySliderRect {
            get {
                var _qualitySlider = EditorGUILayout.GetControlRect();
                _qualitySlider.x += _qualitySlider.width / 6f;
                _qualitySlider.width *= 2 / 3f;
                return _qualitySlider;
            }
        }

        public Rect qualityLabelRect {
            get {
                var _qualitySlider = EditorGUILayout.GetControlRect();
                _qualitySlider.height *= 1.5f;
                return _qualitySlider;
            }
        }

        public Color QualityColor(float quality) {
            if(quality <= 0) {
                return Color.red;
            }
            else if(quality <= 1) {
                return Color.yellow;
            }
            else if(quality <= 2) {
                return Color.green;
            }
            else if(quality <= 3) {
                return Color.magenta;
            }

            return Color.white;
        }


        public GUIContent QualityGUIContent(float quality) {
            var content = new GUIContent();
            if(quality <= -1)
                content.text += "IGNORE RECOMMENDED SETTINGS";
            else if(quality <= 0)
                content.text += "LOW (Not Recommended)";
            else if(quality <= 1)
                content.text += "MEDIUM";
            else if(quality <= 2)
                content.text += "HIGH (Quest Recommended)";
            else if(quality <= 3)
                content.text += "VERY HIGH";

            return content;
        }



        static bool ShowSetupWindow() {
            return handSettings.quality == -1 && !handSettings.ignoreSetup || !AutoHandSetupWizard.LayersExist();
        }


        static void GenerateAutoHandLayers() {
            CreateLayers();
            AssetDatabase.Refresh();
#if UNITY_2020
#if !UNITY_2020_1
        AssetDatabase.RefreshSettings();
#endif
#endif

        }


        public static void CreateLayers() {
            foreach(var layer in requiredLayerNames) {
                CreateLayer(layer);
            }
        }

        public static bool LayersExist() {
            bool success = true;
            Dictionary<string, int> existingLayers = GetAllLayers();
            foreach(var layer in requiredLayerNames) {
                if(!existingLayers.ContainsKey(layer)) {
                    success = false;
                    break;
                }
            }
            return success;
        }


        static void CreateLayer(string name) {
            bool success = false;
            Dictionary<string, int> existingLayers = GetAllLayers();

            if(!existingLayers.ContainsKey(name)) {
                SerializedObject tagManager = new SerializedObject(AssetDatabase.LoadAllAssetsAtPath("ProjectSettings/TagManager.asset")[0]);
                SerializedProperty layers = tagManager.FindProperty("layers");

                for(int i = 0; i < 31; i++) {
                    SerializedProperty element = layers.GetArrayElementAtIndex(i);
                    if(string.IsNullOrEmpty(element.stringValue) && i >= 6) {
                        element.stringValue = name;

                        tagManager.ApplyModifiedProperties();
                        success = true;
                        Debug.Log(i.ToString() + " layer created: " + name);
                        break;
                    }
                }

                if(!success) {
                    Debug.Log("Could not create required layer, you likely do not have enough empty layers. Please delete some unused physics layers and reload the Auto Hand Setup Wizard in Window/AutoHand/Setup");
                }
            }
        }

        public static Dictionary<string, int> GetAllLayers() {
            Dictionary<string, int> layerDictionary = new Dictionary<string, int>();
            SerializedObject tagManager = new SerializedObject(AssetDatabase.LoadAllAssetsAtPath("ProjectSettings/TagManager.asset")[0]);
            SerializedProperty layers = tagManager.FindProperty("layers");
            int layerSize = layers.arraySize;

            for(int i = 0; i < layerSize; i++) {
                SerializedProperty element = layers.GetArrayElementAtIndex(i);
                string layerName = element.stringValue;

                if(!string.IsNullOrEmpty(layerName)) {
                    layerDictionary.Add(layerName, i);
                }
            }

            return layerDictionary;
        }


        static void EnableAdaptiveForce() {
            assetPath = Application.dataPath;
            var path = assetPath.Substring(0, assetPath.Length - 6);
            path += "ProjectSettings/DynamicsManager.asset";

            List<string> layerNames = new List<string>();
            for(int i = 0; i < requiredLayerNames.Length; i++) {
                layerNames.Add(requiredLayerNames[i]);
            }

            StreamReader reader = new StreamReader(path);
            string line = reader.ReadLine();
            string[] lines = File.ReadAllLines(path);

            int lineIndex = 0;
            List<int> lineTargetList = new List<int>();

            while((line = reader.ReadLine()) != null) {
                if(line.Contains("m_EnableAdaptiveForce"))
                    lineTargetList.Add(lineIndex);
                lineIndex++;
            }
            reader.Close();


            StreamWriter writer = new StreamWriter(path);
            lineIndex = 0;
            for(lineIndex = 0; lineIndex < lines.Length; lineIndex++) {
                bool found = false;
                if(lineIndex == lineTargetList[0] + 1) {
                    writer.WriteLine("  m_EnableAdaptiveForce: 1");
                    found = true;
                }
                if(!found)
                    writer.WriteLine(lines[lineIndex]);

            }
            writer.Close();
            AssetDatabase.Refresh();
#if UNITY_2020
#if !UNITY_2020_1
        AssetDatabase.RefreshSettings();
#endif
#endif
        }

        static void UpdateRequiredCollisionLayers() {
            Physics.IgnoreLayerCollision(LayerMask.NameToLayer("Hand"), LayerMask.NameToLayer("Hand"), true);
            Physics.IgnoreLayerCollision(LayerMask.NameToLayer("Hand"), LayerMask.NameToLayer("Grabbing"), true);

            Physics.IgnoreLayerCollision(LayerMask.NameToLayer("HandPlayer"), LayerMask.NameToLayer("Grabbable"), true);
            Physics.IgnoreLayerCollision(LayerMask.NameToLayer("HandPlayer"), LayerMask.NameToLayer("Grabbing"), true);
            Physics.IgnoreLayerCollision(LayerMask.NameToLayer("HandPlayer"), LayerMask.NameToLayer("Hand"), true);
            Physics.IgnoreLayerCollision(LayerMask.NameToLayer("HandPlayer"), LayerMask.NameToLayer("HandPlayer"), true);
        }



        public static bool IsIgnoreCollisionSet() {
            return LayersExist() &&
            Physics.GetIgnoreLayerCollision(LayerMask.NameToLayer("Hand"), LayerMask.NameToLayer("Hand")) &&
            Physics.GetIgnoreLayerCollision(LayerMask.NameToLayer("Hand"), LayerMask.NameToLayer("Grabbing")) &&

            Physics.GetIgnoreLayerCollision(LayerMask.NameToLayer("HandPlayer"), LayerMask.NameToLayer("Grabbable")) &&
            Physics.GetIgnoreLayerCollision(LayerMask.NameToLayer("HandPlayer"), LayerMask.NameToLayer("Grabbing")) &&
            Physics.GetIgnoreLayerCollision(LayerMask.NameToLayer("HandPlayer"), LayerMask.NameToLayer("Hand")) &&
            Physics.GetIgnoreLayerCollision(LayerMask.NameToLayer("HandPlayer"), LayerMask.NameToLayer("HandPlayer"));
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Editor/AutoHandSetupWizard.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Editor/AutoHandUpdateDataWizard.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b465f823e64154843ac64328dea3a71a
# ASMDEF: Autohand.Editor.dll
# ---


using UnityEditor;
using UnityEngine;
using System.Collections.Generic;
using Autohand;
using System.Linq;

namespace Autohand {

    public class AutoHandUpdateDataWizard : EditorWindow {
        public Texture autohandlogo;
        private SerializedObject serializedObject;

        public List<Hand> hands = new List<Hand>();
        public List<HandPoseDataContainer> scenePoses = new List<HandPoseDataContainer>();
        public List<HandPoseDataContainer> prefabPoses = new List<HandPoseDataContainer>();

        private SerializedProperty handsProperty;
        private SerializedProperty scenePosesProperty;
        private SerializedProperty prefabPosesProperty;


        private Vector2 scrollPosition;
        static bool loaded = false;
        public static AutoHandUpdateDataWizard window;

        bool validHandData;
        bool didValidationFail;

        static AutoHandSettings _handSettings = null;
        static AutoHandSettings handSettings {
            get {
                if(_handSettings == null)
                    _handSettings = Resources.Load<AutoHandSettings>("AutoHandSettings");
                return _handSettings;
            }
        }


        [UnityEditor.InitializeOnLoadMethod]
        public static void CheckSceneForOldPoses() {
            if(!loaded) {
                if(window != null)
                    window.Close();

                if(EditorWindow.HasOpenInstances<AutoHandUpdateDataWizard>())
                    return;

                window = GetWindow<AutoHandUpdateDataWizard>("Update Pose Data");
                if(handSettings.quality == -1 && !handSettings.ignoreSetup)
                    window.FindPrefabPoses();

                if(window.FindScenePoses() == 0 && (window.prefabPoses.Count) == 0)
                    window.Close();

                // Mark as loaded so this auto-initialization only happens once.
                loaded = true;
            }
        }

        [MenuItem("Window/Autohand/Pose Data Updater")]
        public static void ShowWindow() {
            if(window != null)
                window.Close();

            if(EditorWindow.HasOpenInstances<AutoHandUpdateDataWizard>())
                return;

            window = GetWindow<AutoHandUpdateDataWizard>(true);
            window.minSize = new Vector2(320, 440);
            window.maxSize = new Vector2(360, 500);
            window.titleContent = new GUIContent("Auto Hand Setup");
        }

        void OnEnable() {
            serializedObject = new SerializedObject(this);
            handsProperty = serializedObject.FindProperty("hands");
            scenePosesProperty = serializedObject.FindProperty("scenePoses");
            prefabPosesProperty = serializedObject.FindProperty("prefabPoses");
        }




        void OnGUI() {
            serializedObject.Update();
            ShowTitle();

            scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);
            ShowHandReferences();
            ShowPoseProperties();
            EditorGUILayout.EndScrollView();

            GUILayout.Space(4f);
            if(GUI.Button(qualitySliderRect, "Find Scene Poses"))
                FindScenePoses();

            if(GUI.Button(qualitySliderRect, "Find Prefab Poses"))
                FindPrefabPoses();

            ShowUpdateDataButton();
            GUILayout.Space(8f);

            serializedObject.ApplyModifiedProperties();
        }



        void ShowUpdateDataButton() {
            GUILayout.Space(8f);
            if(!validHandData || didValidationFail) {
                GUI.backgroundColor = Color.red / 4f;
                GUI.Button(qualitySliderRect, "Invalid Hand References");
            }
            else if(GUI.Button(qualitySliderRect, "Update Poses")) {
                if(hands.Count == 0) {
                    Debug.LogError("AUTO HAND: No hands to update poses with, please include at the hand(s) that was used to create the poses");
                    return;
                }
                else {
                    foreach(var hand in hands) {
                        foreach(var finger in hand.fingers) {
                            finger.UpdateDepricatedValues();
                        }
                    }
                }

                foreach(var pose in prefabPoses) {
                    foreach(var hand in hands) {
                        if(hand.poseIndex == pose.poseIndex) {
                            pose.UpdateDepricatedData(hand);
                            EditorUtility.SetDirty(pose);
                        }
                    }
                }

                AssetDatabase.Refresh();
#if UNITY_2020_1_OR_NEWER
                AssetDatabase.RefreshSettings();
#endif
                prefabPoses.Clear();

                foreach(var pose in scenePoses) {
                    foreach(var hand in hands) {
                        if(hand.poseIndex == pose.poseIndex) {
                            pose.UpdateDepricatedData(hand);
                            EditorUtility.SetDirty(pose);
                        }
                    }
                }

                AssetDatabase.Refresh();
#if UNITY_2020_1_OR_NEWER
                AssetDatabase.RefreshSettings();
#endif
                scenePoses.Clear();

            }
        }

        void ShowPoseProperties() {
            EditorGUILayout.LabelField(new GUIContent("Poses to Update"), EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(prefabPosesProperty, new GUIContent("Prefab Poses"), true);
            EditorGUILayout.PropertyField(scenePosesProperty, new GUIContent("Scene Poses"), true);
        }

        void ShowTitle() {
            if(autohandlogo == null) {
                var assets = AssetDatabase.FindAssets("AutohandLogo");
                if(assets.Length > 0)
                    autohandlogo = AssetDatabase.LoadAssetAtPath<Texture>(AssetDatabase.GUIDToAssetPath(assets[0]));
            }

            var rect = EditorGUILayout.GetControlRect();
            rect.height *= 5;
            GUI.Label(rect, autohandlogo, AutoHandExtensions.LabelStyle(TextAnchor.MiddleCenter, FontStyle.Normal, 25));

            EditorGUILayout.Space(70f);
            EditorGUILayout.LabelField("POSE DATA UPDATER", AutoHandExtensions.LabelStyle(TextAnchor.MiddleCenter, FontStyle.Normal, 24));
            EditorGUILayout.Space(8f);
        }

        void ShowHandReferences() {
            EditorGUILayout.LabelField(new GUIContent("Refence Hands", "These hand will try to be automatically updated if not updated, then they will be used as a reference to update the data in all the given pose objects below if they have the same pose index as the given hand"), EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(handsProperty, new GUIContent("Hands"), true);
            didValidationFail = false;
            validHandData = true;

            foreach(var hand in hands) {
                if(hand == null)
                    continue;

                foreach(var finger in hand.fingers) {
                    if(!finger.isMissingReferences && !finger.isDataDepricated)
                        continue;
                    else if(finger.UpdateDepricatedValues())
                        continue;

                    if(finger.isMissingReferences && (didValidationFail || !finger.UpdateDepricatedValues())) {
                        didValidationFail = true;
                        EditorGUILayout.HelpBox("Finger data is missing required references, as of V3.3 fingers require manual connects to each of three joints", MessageType.Error);
                        break;
                    }
                    else if(finger.isDataDepricated && ((validHandData && !didValidationFail) || !finger.UpdateDepricatedValues())) {
                        validHandData = false;
                        EditorGUILayout.HelpBox("Finger data is depricated - please try manually updating the finger references on your hand and try again", MessageType.Warning);
                        break;
                    }
                }
            }

            GUILayout.Space(8f);
        }

        public void UpdatePoses() {
            foreach(var hand in hands) {
                foreach(var finger in hand.fingers) {
                    if(!finger.UpdateDepricatedValues()) {
                        Debug.LogError("AUTO HAND: Finger data is depricated - please try manually updating the finger references on your hand and try again", finger);
                        return;
                    }
                }

                foreach(var pose in prefabPoses) {
                    if(hand.poseIndex == pose.poseIndex)
                        pose.UpdateDepricatedData(hand);
                    else
                        Debug.Log("Pose not marked as depricated or mismatching pose index", pose);
                }

                foreach(var pose in scenePoses) {
                    if(hand.poseIndex == pose.poseIndex)
                        pose.UpdateDepricatedData(hand);
                    else
                        Debug.Log("Pose not marked as depricated or mismatching pose index", pose);
                }
            }
        }

        public int FindScenePoses() {
            scenePoses.Clear();
            scenePoses = FindObjectsByType<HandPoseDataContainer>(FindObjectsInactive.Include, FindObjectsSortMode.None).ToList();
            Debug.Log("Found " + scenePoses.Count + " scene poses");
            for(int i = scenePoses.Count - 1; i >= 0; i--) {
                if(!scenePoses[i].isDataDepricated)
                    scenePoses.RemoveAt(i);
            }

            return scenePoses.Count;
        }

        public int FindPrefabPoses() {
            prefabPoses.Clear();
            string[] guids = AssetDatabase.FindAssets("t:Prefab");
            foreach(var guid in guids) {
                var assetObject = AssetDatabase.LoadAssetAtPath<GameObject>(AssetDatabase.GUIDToAssetPath(guid));
                var poses = assetObject.GetComponentsInChildren<HandPoseDataContainer>(true);
                foreach(var pose in poses)
                    if(pose != null && pose.isDataDepricated)
                        prefabPoses.Add(pose);
            }

            return prefabPoses.Count;
        }

        public Rect qualitySliderRect {
            get {
                var _qualitySlider = EditorGUILayout.GetControlRect();
                _qualitySlider.x += _qualitySlider.width / 20f;
                _qualitySlider.width *= 9 / 10f;
                return _qualitySlider;
            }
        }

        public Rect qualityLabelRect {
            get {
                var _qualitySlider = EditorGUILayout.GetControlRect();
                _qualitySlider.height *= 1.5f;
                return _qualitySlider;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Editor/AutoHandUpdateDataWizard.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Editor/AutoHandVersionControlFixer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 4251fc38713049444aed832ac5295105
# ASMDEF: Autohand.Editor.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;
using UnityEngine.SceneManagement;

[InitializeOnLoad]
public class AutoHandVersionControlFixer {
    static AutoHandVersionControlFixer() {
        EditorSceneManager.sceneOpened += OnSceneOpened;
    }

    private static void OnSceneOpened(Scene scene, OpenSceneMode mode) {
#if UNITY_2022_1_OR_NEWER
#else
        var colliderFixers = GameObject.FindObjectsOfType<BoxColliderSerializationFixer>();
        foreach(var fixer in colliderFixers) {
            fixer.ApplyColliderSizesRecursive();
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Editor/AutoHandVersionControlFixer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Editor/EditorHandEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 2a370f4ecc762d048b1a40b25cfb3407
# ASMDEF: Autohand.Editor.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEditor.PackageManager.UI;
using UnityEngine;

namespace Autohand {
    [CustomEditor(typeof(EditorHand))]
    public class EditorHandEditor : Editor {

        bool[] fingerStates = new bool[] { };

        private void OnEnable() {
            var editorHand = (target as EditorHand);
            var hand = editorHand.hand;

            if(fingerStates.Length == 0)
                fingerStates = new bool[hand.fingers.Length];

            for(int i = 0; i < fingerStates.Length; i++)
                fingerStates[i] = true;

            hand.SetLayerRecursive(hand.transform, LayerMask.NameToLayer(hand.left ? Hand.leftHandLayerName : Hand.rightHandLayerName));

            if(editorHand.handPoseDataContainer != null)
                EditorHandTool.ShowWindow(hand, editorHand.handPoseDataContainer);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Editor/EditorHandEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Editor/EditorHandTool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 043ee891e8f433f45ac35a02aed8935d
# ASMDEF: Autohand.Editor.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEditor.EditorTools;
using UnityEditorInternal;
using UnityEngine;
using UnityEngine.XR;

namespace Autohand {

    public class EditorHandTool : EditorWindow {

        float bendFingers = 0;
        bool[] fingerStates = new bool[] { };
        float[] fingerBendStates = new float[] { };
        float[] lastFingerBendStates = new float[] { };

        Hand handCopy;
        HandPoseDataContainer pose;
        GrabbablePose grabbablePose;
        GrabbablePoseAdvanced advancedPose;
        HandPoseArea poseArea;

        const int smallestWindowHeight = 320;

        public static void ShowWindow(Hand hand, HandPoseDataContainer pose) {
            var window = GetWindow<EditorHandTool>("Hand Pose Tool", true);
            window.handCopy = hand;
            window.pose = pose;
            window.maxSize = new Vector2(400, smallestWindowHeight + 180);
            window.minSize = new Vector2(160, smallestWindowHeight);
            window.Show(true);
            window.ShowTab();
            if(pose is GrabbablePoseAdvanced)
                window.position = new Rect(50, 100, 240, smallestWindowHeight + 180);
            else
                window.position = new Rect(50, 100, 240, smallestWindowHeight);
        }


        public static void ShowWindow(Hand hand, HandPoseArea poseArea) {
            var window = GetWindow<EditorHandTool>("Hand Pose Tool", true);
            window.handCopy = hand;
            window.poseArea = poseArea;
            window.maxSize = new Vector2(400, smallestWindowHeight);
            window.minSize = new Vector2(160, smallestWindowHeight);
            window.Show(true);
            window.ShowTab();
            window.position = new Rect(50, 100, 240, smallestWindowHeight);
        }

        void CheckInit() {
            if(fingerStates.Length == 0) {
                fingerStates = new bool[handCopy.fingers.Length];
                fingerBendStates = new float[handCopy.fingers.Length];
                lastFingerBendStates = new float[handCopy.fingers.Length];

                for(int i = 0; i < fingerStates.Length; i++) {
                    fingerStates[i] = true;
                    fingerBendStates[i] = 0;
                }

                handCopy.SetLayerRecursive(handCopy.transform, LayerMask.NameToLayer(handCopy.left ? Hand.leftHandLayerName : Hand.rightHandLayerName));
            }
        }


        public void OnGUI() {

            CheckInit();

            if(handCopy == null) {
                Close();
                return;
            }

            Handles.BeginGUI();
            GUILayout.BeginArea(new Rect(0, 0, position.width, position.height));

            var rect1 = EditorGUILayout.BeginVertical();
            GUI.color = Color.grey;
            GUI.Box(rect1, GUIContent.none);
            EditorGUILayout.EndVertical();

            GUILayout.EndArea();
            Handles.EndGUI();


            Handles.BeginGUI();
            GUILayout.BeginArea(new Rect(0, 0, position.width, position.height));
            var rect = EditorGUILayout.BeginVertical();

            GUI.color = Color.grey;
            GUI.Box(rect, GUIContent.none);
            GUI.Box(rect, GUIContent.none);
            GUI.Box(rect, GUIContent.none);

            ShowTitle();

            ShowFingerMask();

            ShowGrabSlider();

            ShowGrabButton();

            ShowInvertButtons();

            ShowSaveButtons();

            //ShowMultiPoseOptions();

            ShowAdvancedPoseOptions();

            ShowDeleteButton();

            GUILayout.Space(30f);
            EditorGUILayout.EndVertical();

            GUILayout.EndArea();

            Handles.EndGUI();
        }


        //void ShowMultiPoseOptions() {

        //    if(pose is GrabbableMultiPose) 
        //        multiPose = pose as GrabbableMultiPose;
        //    else 
        //        multiPose = null;

        //    if(multiPose != null && leftPosesList == null && rightPosesList == null) {
        //        InitMultiPoseLists();
        //    }
        //    if(multiPose != null) {
        //        GUILayout.Space(20);
        //        Rect tempRect = GUILayoutUtility.GetRect(0, 1000, 0, 1000, GUILayout.ExpandHeight(true), GUILayout.ExpandWidth(true));

        //        float columnWidth = (tempRect.width - 10) / 2;

        //        Rect leftListRect = new Rect(tempRect.x, tempRect.y, columnWidth, tempRect.height);
        //        Rect rightListRect = new Rect(tempRect.x + columnWidth + 2, tempRect.y, columnWidth, tempRect.height);

        //        if(leftPosesList != null) {
        //            EditorGUI.LabelField(new Rect(leftListRect.x, leftListRect.y - 20, leftListRect.width, 20), "Left Hand Poses", EditorStyles.boldLabel);
        //            leftListRect.y -= 15; 
        //            leftPosesList.DoList(leftListRect);
        //        }

        //        if(rightPosesList != null) {
        //            EditorGUI.LabelField(new Rect(rightListRect.x, rightListRect.y - 20, rightListRect.width, 20), "Right Hand Poses", EditorStyles.boldLabel);
        //            rightListRect.y -= 15; 
        //            rightPosesList.DoList(rightListRect);
        //        }
        //    }
        //}

        void ShowAdvancedPoseOptions() {
            if(pose is GrabbablePoseAdvanced) {
                advancedPose = (pose as GrabbablePoseAdvanced);
            }
            else {
                advancedPose = null;
            }

            if(advancedPose != null) {
                if(handCopy.left && !advancedPose.leftPoseSet)
                    GUI.backgroundColor = Color.red;
                else if(!handCopy.left && !advancedPose.rightPoseSet)
                    GUI.backgroundColor = Color.red;


                GUILayout.Space(20);
                Rect tempRect = GUILayoutUtility.GetRect(0, 1000, 0, 1000, GUILayout.ExpandHeight(true), GUILayout.ExpandWidth(true));

                float columnWidth = (tempRect.width - 10);
                Rect rect = new Rect(tempRect.x+5, tempRect.y, columnWidth, tempRect.height);

                EditorGUI.LabelField(new Rect(rect.x, rect.y - 20, rect.width, 20), "Advanced Pose Options", EditorStyles.boldLabel);
                rect.y -= 15;

                EditorGUI.BeginChangeCheck();

                advancedPose.maxRange = EditorGUI.FloatField(new Rect(rect.x, rect.y + 20, rect.width, 20), "Max Range", advancedPose.maxRange);
                advancedPose.minRange = EditorGUI.FloatField(new Rect(rect.x, rect.y + 40, rect.width, 20), "Min Range", advancedPose.minRange);
                advancedPose.testRange = EditorGUI.Slider(new Rect(rect.x, rect.y + 60, rect.width, 20),  advancedPose.testRange, advancedPose.minRange, advancedPose.maxRange);

                advancedPose.maxAngle = EditorGUI.IntField(new Rect(rect.x, rect.y + 82, rect.width, 20), "Max Angle", advancedPose.maxAngle);
                advancedPose.minAngle = EditorGUI.IntField(new Rect(rect.x, rect.y + 102, rect.width, 20), "Min Angle", advancedPose.minAngle);

                advancedPose.testAngle = EditorGUI.IntSlider(new Rect(rect.x, rect.y + 122, rect.width, 20), advancedPose.testAngle, advancedPose.minAngle, advancedPose.maxAngle);



                if(EditorGUI.EndChangeCheck()) {
                    advancedPose.EditorTestValues(handCopy);
                    EditorUtility.SetDirty(advancedPose);
                    Undo.RegisterCompleteObjectUndo(advancedPose, "Advanced Pose Options");
                }
            }
        }

        void ShowTitle() {
            GUI.color = Color.white;

            GUILayout.BeginHorizontal();
            GUILayout.Label("Hand Pose Tool", AutoHandExtensions.LabelStyle(TextAnchor.MiddleCenter, FontStyle.Bold, 16));
            GUILayout.EndHorizontal();
        }

        Vector2 leftPosesScrollPosition;
        Vector2 rightPosesScrollPosition;
        
        ReorderableList leftPosesList;
        ReorderableList rightPosesList;

        //GrabbableMultiPose multiPose; 
        //void InitMultiPoseLists() {
        //    multiPose = pose as GrabbableMultiPose;
        //    if(multiPose != null) {
        //        // Initialize the ReorderableList for extraLeftPoses
        //        leftPosesList = new ReorderableList(multiPose.extraLeftPoses, typeof(HandPoseData), true, true, true, true);
        //        ConfigureReorderableList(leftPosesList, multiPose.extraLeftPoses, false);

        //        // Initialize the ReorderableList for extraRightPoses
        //        rightPosesList = new ReorderableList(multiPose.extraRightPoses, typeof(HandPoseData), true, true, true, true);
        //        ConfigureReorderableList(rightPosesList, multiPose.extraRightPoses, true);
        //    }
        //}

        void ConfigureReorderableList(ReorderableList list, List<HandPoseData> poses, bool isRightHand) {
            list.drawHeaderCallback = (Rect rect) => {
                EditorGUI.LabelField(rect, isRightHand ? "Extra Right Poses" : "Extra Left Poses");
            };

            list.drawElementCallback = (Rect rect, int index, bool isActive, bool isFocused) => {
                EditorGUI.LabelField(rect, "Pose: " + index);
            };

            list.onSelectCallback = (ReorderableList l) => {
                Debug.Log("Selected pose: " + pose);
                poses[l.index].SetPose(handCopy, pose.transform);
            };

            list.onAddCallback = (ReorderableList l) => {
                poses.Add(new HandPoseData(handCopy, pose.transform));
            };
        }

        void ShowFingerMask() {
            for(int i = 0; i < fingerStates.Length; i++) {
                GUILayout.BeginHorizontal();
                var layoutRect = GUILayoutUtility.GetRect(position.width, 20);
                layoutRect.width = layoutRect.width / 2f;
                layoutRect.x += 5f;

                fingerStates[i] = GUI.Toggle(layoutRect, fingerStates[i], handCopy.fingers[i].name);

                layoutRect.position = new Vector2(layoutRect.width, layoutRect.position.y);
                layoutRect.width = layoutRect.width - 10f;
                fingerBendStates[i] = GUI.HorizontalSlider(layoutRect, fingerBendStates[i], 0, 1);

                if(fingerStates[i] && lastFingerBendStates[i] != fingerBendStates[i]) {
                    lastFingerBendStates[i] = fingerBendStates[i];
                    handCopy.fingers[i].SetFingerBend(fingerBendStates[i]);
                }

                GUILayout.EndHorizontal();
            }
        }


        void ShowGrabSlider() {
            EditorGUILayout.Space();
            GUILayout.BeginHorizontal();

            GUI.backgroundColor = Color.white;

            bendFingers = GUILayout.HorizontalSlider(bendFingers, 0, 1);

            GUI.backgroundColor = new Color(0.9f, 0.4f, 0.4f, 1f);
            if(GUILayout.Button("Set Fingers Bend")) {
                Undo.RegisterFullObjectHierarchyUndo(handCopy.gameObject, "Auto Pose");

                for(int i = 0; i < handCopy.fingers.Length; i++) {
                    if(fingerStates[i])
                        handCopy.fingers[i].SetFingerBend(bendFingers);
                }
            }

            GUILayout.EndHorizontal();
        }


        void ShowGrabButton() {
            GUILayout.BeginHorizontal();
            GUI.backgroundColor = new Color(0.9f, 0.4f, 0.4f, 1f);

            if(GUILayout.Button("Auto Pose")) {
                Undo.RegisterFullObjectHierarchyUndo(handCopy.gameObject, "Auto Pose");

                for(int i = 0; i < handCopy.fingers.Length; i++) {
                    if(fingerStates[i])
                        handCopy.fingers[i].BendFingerUntilHit(100, ~LayerMask.GetMask(Hand.rightHandLayerName, Hand.leftHandLayerName));
                }
            }
            GUILayout.EndHorizontal();
        }


        void ShowInvertButtons() {
            GUILayout.BeginHorizontal();

            GUI.backgroundColor = new Color(0.9f, 0.4f, 0.4f, 1f);

            if(GUILayout.Button("Invert X")) {
                var undoObject = new UnityEngine.Object[] { handCopy, handCopy.transform.parent };
                Undo.RecordObjects(undoObject, "Invert X");

                var scale = handCopy.transform.parent.localScale;
                scale.x = -scale.x;
                handCopy.transform.parent.localScale = scale;
                handCopy.left = !handCopy.left;
            }
            if(GUILayout.Button("Invert Y")) {
                var undoObject = new UnityEngine.Object[]{ handCopy, handCopy.transform.parent };
                Undo.RecordObjects(undoObject, "Invert Y");

                var scale = handCopy.transform.parent.localScale;
                scale.x = -scale.x;
                handCopy.transform.parent.Rotate(new Vector3(0, 0, 180));
                handCopy.transform.parent.localScale = scale;
                handCopy.left = !handCopy.left;
            }
            if(GUILayout.Button("Invert Z")) {
                var undoObject = new UnityEngine.Object[] { handCopy, handCopy.transform.parent };
                Undo.RecordObjects(undoObject, "Invert Z");

                var scale = handCopy.transform.parent.localScale;
                handCopy.transform.parent.Rotate(new Vector3(0, 180, 0));
                scale.x = -scale.x;
                handCopy.transform.parent.localScale = scale;
                handCopy.left = !handCopy.left;
            }

            GUILayout.EndHorizontal();
        }


        void ShowSaveButtons() {
            EditorGUILayout.Space();
            GUI.backgroundColor = Color.grey;

            GUILayout.BeginHorizontal();

            if(pose != null)
                EditorGUILayout.ObjectField(pose, typeof(GrabbablePose), true);
            else
                EditorGUILayout.ObjectField(poseArea, typeof(HandPoseArea), true);

            GUILayout.EndHorizontal();

            EditorGUILayout.BeginHorizontal();


            if(pose != null) {
                if(pose.leftPoseSet)
                    GUI.backgroundColor = Color.green;
                else
                    GUI.backgroundColor = Color.red;


                if(GUILayout.Button("Save Left")) {
                    if(pose.poseIndex != pose.editorHand.poseIndex) {
                        Debug.Log("Automatically overriding local Pose Index to match hand Pose Index");
                        pose.poseIndex = pose.editorHand.poseIndex;
                    }

                    pose.EditorSaveGrabPose(pose.editorHand);
                }


                if(pose.rightPoseSet)
                    GUI.backgroundColor = Color.green;
                else
                    GUI.backgroundColor = Color.red;


                if(GUILayout.Button("Save Right")) {
                    if(pose.poseIndex != pose.editorHand.poseIndex) {
                        Debug.Log("Automatically overriding local Pose Index to match hand Pose Index");
                        pose.poseIndex = pose.editorHand.poseIndex;
                    }

                    pose.EditorSaveGrabPose(pose.editorHand);
                }

            }
            else {
                var pose = poseArea;

                if(pose.leftPoseSet)
                    GUI.backgroundColor = Color.green;
                else
                    GUI.backgroundColor = Color.red;

                if(GUILayout.Button("Save Left")) {
                    if(pose.poseIndex != pose.editorHand.poseIndex)
                        Debug.LogError("CANNOT SAVE: Your hand's \"Pose Index\" value does not match the local \"Pose Index\" value");
                    else
                        pose.EditorSaveGrabPose(pose.editorHand);
                }


                if(pose.rightPoseSet)
                    GUI.backgroundColor = Color.green;
                else
                    GUI.backgroundColor = Color.red;


                if(GUILayout.Button("Save Right")) {
                    if(pose.poseIndex != pose.editorHand.poseIndex)
                        Debug.LogError("CANNOT SAVE: Your hand's \"Pose Index\" value does not match the local \"Pose Index\" value");
                    else
                        pose.EditorSaveGrabPose(pose.editorHand);
                }
            }


            GUILayout.EndHorizontal();
        }


        void ShowDeleteButton() {
            EditorGUILayout.Space();
            GUI.backgroundColor = Color.grey;

            GUILayout.BeginHorizontal();
            EditorGUILayout.ObjectField(handCopy, typeof(Hand), true);
            GUILayout.EndHorizontal();

            GUI.backgroundColor = new Color(1f, 0f, 0f, 1f);

            if(GUILayout.Button("Delete Hand Copy")) {
                if(pose != null)
                    Selection.activeGameObject = pose.gameObject;
                else
                    Selection.activeGameObject = poseArea.gameObject;
                DestroyImmediate(handCopy.transform.parent.gameObject);
                Close();
            }

        }
    }

}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Editor/EditorHandTool.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Editor/FingerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d482994e929ca434a88533407763f8a5
# ASMDEF: Autohand.Editor.dll
# ---
using Autohand;
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace Autohand {
    [CustomEditor(typeof(Finger))]
    public class FingerEditor : Editor {
        Finger finger;
        float lastOffset;

        private void OnEnable() {
            finger = target as Finger;
            lastOffset = finger.bendOffset;
        }

        public override void OnInspectorGUI() {
            DrawDefaultInspector();
            if(lastOffset != finger.bendOffset){
                lastOffset = finger.bendOffset;
                finger.SetFingerBend(lastOffset);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Editor/FingerEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Editor/GrabbableEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 65812e0613b7db448a93f4b1ace2dac9
# ASMDEF: Autohand.Editor.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class GrabbableEditor
{

}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Editor/GrabbableEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Editor/HandColliderEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 5164f9606040e934cad716277013baaa
# ASMDEF: Autohand.Editor.dll
# ---
//CREDIT: Silk from the AutoHand discord server for the original script

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

public class HandColliderEditor : EditorWindow {
    private GameObject selectedHand;
    private PhysicsMaterial replacementMaterial;

    [MenuItem("/Window/Autohand/Hand Collider Editor")]
    public static void ShowWindow() => GetWindow<HandColliderEditor>("Hand Collider Editor");

    void OnGUI() {
        GUI.color = Color.white;
        selectedHand = (GameObject)EditorGUILayout.ObjectField("Hand Root", selectedHand, typeof(GameObject), true);
        if(selectedHand == null) {
            GUILayout.BeginHorizontal();
            EditorGUILayout.HelpBox("Please select a valid hand root object, this must be the root object of your hand prefab, not the root bone transform.", MessageType.None);
            GUILayout.EndHorizontal();
        }
        GUILayout.Space(2.5f);
        GUILayout.Box("", GUILayout.Height(10), GUILayout.ExpandWidth(true));
        GUILayout.Space(2.5f);
        GUILayout.BeginHorizontal();
        if(GUILayout.Button("Generate Colliders") && selectedHand != null) GenerateColliders(selectedHand);
        if(GUILayout.Button("Destroy Colliders") && selectedHand != null) DestroyColliders(selectedHand);
        GUILayout.EndHorizontal();
        GUILayout.Space(2.5f);
        GUILayout.Box("", GUILayout.Height(10), GUILayout.ExpandWidth(true));
    }

    void DestroyColliders(GameObject obj) {
        foreach(Collider collider in obj.GetComponentsInChildren<Collider>())
            DestroyImmediate(collider.gameObject, true);
    }

    void GenerateColliders(GameObject handRoot) {
        SkinnedMeshRenderer skinnedMesh = handRoot.GetComponentInChildren<SkinnedMeshRenderer>();
        if(skinnedMesh == null) {
            Debug.LogError("No SkinnedMeshRenderer found in the hand object.");
            return;
        }

        Mesh bakedMesh = new Mesh();
        skinnedMesh.BakeMesh(bakedMesh);
        Transform[] bones = skinnedMesh.bones;
        Dictionary<Transform, List<Vector3>> boneVertexMap = new Dictionary<Transform, List<Vector3>>();

        for(int i = 0; i < bakedMesh.vertexCount; i++) {
            Vector3 worldVertex = skinnedMesh.transform.TransformPoint(bakedMesh.vertices[i]);
            BoneWeight weight = skinnedMesh.sharedMesh.boneWeights[i];
            Transform bone = bones[weight.boneIndex0];
            if(!boneVertexMap.ContainsKey(bone)) boneVertexMap[bone] = new List<Vector3>();
            boneVertexMap[bone].Add(worldVertex);
        }

        foreach(var pair in boneVertexMap) {
            Transform bone = pair.Key;
            List<Vector3> vertices = pair.Value;
            if(vertices.Count == 0) continue;
            Vector3 center = Vector3.zero;

            foreach(var v in vertices) 
                center += v;

            center /= vertices.Count;
            Vector3 min = center, max = center;

            foreach(var v in vertices) {
                min = Vector3.Min(min, v);
                max = Vector3.Max(max, v);
            }

            Vector3 size = max - min;
            GameObject colliderHolder = new GameObject("ColliderHolder");
            colliderHolder.transform.SetParent(bone, false);
            colliderHolder.transform.localPosition = Vector3.zero;
            colliderHolder.transform.rotation = bone.rotation;

            var localRotation = colliderHolder.transform.localRotation;
            localRotation.z = bone.localRotation.z;
            colliderHolder.transform.localScale = Vector3.one;

            Vector3 localCenter = colliderHolder.transform.InverseTransformPoint(center);
            localCenter.x = 0;
            localCenter.z = 0;

            if(size.x > size.y || size.x > 0.05f) {
                Vector3 appendedSize = new Vector3(size.x * 1.2f, size.y * 1.3f, size.z);
                BoxCollider box = colliderHolder.AddComponent<BoxCollider>();
                box.gameObject.transform.rotation = Quaternion.identity;
                box.center = localCenter;
                box.size = appendedSize / 1.5f;
            }
            else {
                CapsuleCollider capsule = colliderHolder.AddComponent<CapsuleCollider>();
                capsule.center = localCenter;
                capsule.height = size.y * 1.15f;
                capsule.radius = Mathf.Max(size.x, size.z) / 2.5f;
                capsule.direction = 1;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Editor/HandColliderEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Editor/HandEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 191981544d2a50e45bdbbdb6455e9ec0
# ASMDEF: Autohand.Editor.dll
# ---
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace Autohand {
    [CustomEditor(typeof(Hand)), CanEditMultipleObjects]
    public class HandEditor : Editor {

        public HandEditor(){ }

        public override void OnInspectorGUI() {
            DrawDefaultInspector();
            Hand hand = target as Hand;

            if(GUILayout.Button("Convert Hand Left/Right")) {
                InvertHandData(hand);
            }

            if(GUILayout.Button("Copy Hand Data")) {
                if(hand.copyFromHand != null) {
                    for(int i = 0; i < hand.copyFromHand.fingers.Length; i++) {
                        if(hand.fingers[i] == null) 
                            continue;
                        
                        hand.fingers[i].CopyPoseData(hand.copyFromHand.fingers[i]);
                        EditorUtility.SetDirty(hand.fingers[i]);
                    }
                    Debug.Log("Auto Hand: Copied Hand Pose!");
                }
            }

            var fingerEnumNames = System.Enum.GetNames(typeof(FingerPoseEnum));
            var fingerEnumValues = System.Enum.GetValues(typeof(FingerPoseEnum));

            for(int i = 0; i < fingerEnumNames.Length-1; i++) {
                var pose = (FingerPoseEnum)fingerEnumValues.GetValue(i);

                //If pose is set button should be green
                GUI.backgroundColor = IsPoseSaved(hand, pose) ? Color.green : Color.red;


                if(hand.fingers != null) {
                    foreach(var finger in hand.fingers) {
                        if(finger == null)
                            continue;
                        if(finger.isMissingReferences) {
                            EditorGUILayout.HelpBox("Finger " + finger.name + " is missing references", MessageType.Error);
                            return;
                        }
                        else if(finger.isDataDepricated) {
                            finger.UpdateDepricatedValues();
                        }
                    }
                }

                if(GUILayout.Button("Save " + fingerEnumNames[i] + " Pose")) {
                    if(hand.fingers == null || hand.fingers.Length == 0) {
                        EditorGUILayout.HelpBox("Fingers not initalized", MessageType.Error);
                    }
                    else {
                        foreach(var finger in hand.fingers) {
                            if(finger == null)
                                continue;
                            finger.SavePose(hand, finger, pose);
                            EditorUtility.SetDirty(finger);
                            Debug.Log($"Saving pose {pose} for finger {finger.name}");
                        }
                    }
                }
            }

        }

        public void InvertHandData(Hand hand) {
            hand.transform.localScale = new Vector3(-hand.transform.localScale.x, hand.transform.localScale.y, hand.transform.localScale.z);
            foreach(var finger in hand.fingers) {
                if(finger == null)
                    continue;

                for(int i = 0; i < finger.poseData.Length; i++) {
                    if(finger.poseData[i].poseRelativeMatrix.Length == 0)
                        continue;       

                    finger.poseData[i].poseRelativeMatrix[0].m00 *= -1;
                }
            }
        }

        public bool IsPoseSaved(Hand hand, FingerPoseEnum poseType) {
            if(hand.fingers == null || hand.fingers.Length == 0)
                return false;

            foreach(var finger in hand.fingers) {
                if(finger == null)
                    return false;

                if(!finger.IsPoseSaved(poseType)) {
                    return false;
                }
            }

            return true;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Editor/HandEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Editor/HandPoseDataContainerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: fba77dca3c363459e90bc679e20e6c8b
# ASMDEF: Autohand.Editor.dll
# ---
using UnityEditor;
using UnityEngine;
using UnityEditor.SceneManagement;



namespace Autohand {
    [CustomEditor(typeof(HandPoseDataContainer), true)]
    public class HandPoseDataContainerEditor : Editor {
        HandPoseDataContainer handPoseContainer;

        private void OnEnable() {
            handPoseContainer = target as HandPoseDataContainer;
        }

        public override void OnInspectorGUI() {
            DrawDefaultInspector();
            var startBackground = GUI.backgroundColor; 
            if(handPoseContainer.gameObject != null) {
                EditorUtility.SetDirty(handPoseContainer);
                handPoseContainer.showEditorTools = DrawAutoToggleHeader("Show Editor Tools", handPoseContainer.showEditorTools);

                if(handPoseContainer.showEditorTools) {

                    ShowScriptableSaveButton();

                    ShowHandEditorHand();

                    ShowSaveButtons();

                    DrawHorizontalLine();

                    ShowDeleteOptions();
                }
            }

            GUI.backgroundColor = startBackground;
        }


        public void ShowScriptableSaveButton() {
            EditorGUILayout.Space();
            EditorGUILayout.Space();

            handPoseContainer.poseScriptable = (HandPoseScriptable)EditorGUILayout.ObjectField(new GUIContent("Pose Scriptable", "Allows you to save the pose to a scriptable pose, create scriptable pose by right clicking in project [Create > Auto hand > Custom Pose]"), handPoseContainer.poseScriptable, typeof(HandPoseScriptable), true);

            if(handPoseContainer.poseScriptable != null) {
                EditorUtility.SetDirty(handPoseContainer.poseScriptable);
                var rect = EditorGUILayout.GetControlRect();

                if(GUI.Button(rect, "Save Scriptable"))
                    handPoseContainer.SaveScriptable();

                rect = EditorGUILayout.GetControlRect();
                if(GUI.Button(rect, "Load Scriptable"))
                    handPoseContainer.LoadScriptable();

                EditorGUILayout.Space();
            }
            EditorGUILayout.Space();
        }

        public void ShowDeleteOptions() {
            GUI.backgroundColor = Color.red;

            if(GUILayout.Button("Delete Hand Copy")) {
                if(string.Equals(handPoseContainer.editorHand.transform.parent.name, "HAND COPY CONTAINER DELETE"))
                    DestroyImmediate(handPoseContainer.editorHand.transform.parent.gameObject);
                else
                    Debug.LogError("Not a copy - Will not delete");
            }
            if(GUILayout.Button("Clear Saved Poses"))
                handPoseContainer.EditorClearPoses();

        }

        public void ShowHandEditorHand() {
            handPoseContainer.editorHand = (Hand)EditorGUILayout.ObjectField(new GUIContent("Editor Hand", "This will be used as a reference to create a hand copy that can be used to model your new pose"), handPoseContainer.editorHand, typeof(Hand), true);

            if(GUILayout.Button("Create Hand Copy"))
                handPoseContainer.EditorCreateHandCopyTool(handPoseContainer.editorHand, handPoseContainer.transform);

            if(GUILayout.Button("Select Hand Copy"))
                Selection.activeGameObject = handPoseContainer.editorHand.gameObject;
        }

        public void DrawHorizontalLine() {

            var rect = EditorGUILayout.GetControlRect();
            rect.y += rect.height / 2f;
            rect.height /= 10f;

            EditorGUI.DrawRect(rect, Color.grey);
        }

        public bool DrawAutoToggleHeader(string label, bool value) {

            EditorGUILayout.Space();
            EditorGUILayout.Space();


            // draw header background and label
            var headerRect = EditorGUILayout.GetControlRect();

            var biggerRect = new Rect(headerRect);
            biggerRect.width += biggerRect.x * 2;
            biggerRect.x = 0;
            biggerRect.y -= 5f;
            biggerRect.height += 10f;
            EditorGUI.DrawRect(biggerRect, Constants.BackgroundColor);


            var labelStyle = Constants.LabelStyle;

            var oldColor1 = GUI.color;
            if(!value) {
                var newColor = new Color(0.65f, 0.65f, 0.65f, 1f);
                newColor.a = 1;
                GUI.contentColor = newColor;
            }

            EditorGUI.LabelField(headerRect, new GUIContent("   " + label), labelStyle);

            GUI.contentColor = oldColor1;

            var oldColor = GUI.color;
            GUI.color = value ? new Color(0.7f, 1f, 0.7f) : new Color(1f, 0.7f, 0.7f);

            var newRect = new Rect(headerRect);
            newRect.position = new Vector2(newRect.x + newRect.width - 18, newRect.y);
            value = EditorGUI.Toggle(newRect, value);

            GUI.color = oldColor;


            return value;
        }

        public void ShowSaveButtons() {
            EditorGUILayout.Space();
            EditorGUILayout.Space();

            EditorGUILayout.BeginHorizontal();

            if(handPoseContainer.leftPoseSet)
                GUI.backgroundColor = Color.green;
            else
                GUI.backgroundColor = Color.red;


            if(GUILayout.Button("Save Left")) {
                if(handPoseContainer.poseIndex != handPoseContainer.editorHand.poseIndex)
                    Debug.LogError("CANNOT SAVE: Your hand's \"Pose Index\" value does not match the local \"Pose Index\" value");
                else
                    handPoseContainer.EditorSaveGrabPose(handPoseContainer.editorHand);
            }


            if(handPoseContainer.rightPoseSet)
                GUI.backgroundColor = Color.green;
            else
                GUI.backgroundColor = Color.red;


            if(GUILayout.Button("Save Right")) {
                if(handPoseContainer.poseIndex != handPoseContainer.editorHand.poseIndex)
                    Debug.LogError("CANNOT SAVE: Your hand's \"Pose Index\" value does not match the local \"Pose Index\" value");
                else
                    handPoseContainer.EditorSaveGrabPose(handPoseContainer.editorHand);
            }


            GUILayout.EndHorizontal();
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Editor/HandPoseDataContainerEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/BakeMeshWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: befdb339588e28f41aa626b8c6319d06
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using UnityEditor;
    using System.IO;

    public class BakeMeshWindow : EditorWindow
    {
        public bool isStatic = true;
        public bool copy = false;
        public bool removeComputer = false;
        public bool permanent = false;
        public bool generateLightmapUVs = false;

        MeshFilter filter;
        MeshRenderer renderer;
        MeshGenerator meshGen;
        public enum SaveFormat { MeshAsset, OBJ, Scene }
        SaveFormat format = SaveFormat.MeshAsset;

        public void Init(MeshGenerator generator)
        {
            titleContent = new GUIContent("Bake Mesh");
            meshGen = generator;
            filter = generator.GetComponent<MeshFilter>();
            renderer = generator.GetComponent<MeshRenderer>();
            if (EditorPrefs.HasKey("BakeWindow_isStatic")) isStatic = EditorPrefs.GetBool("BakeWindow_isStatic");
            if (EditorPrefs.HasKey("BakeWindow_generateLightmapUVs")) generateLightmapUVs = EditorPrefs.GetBool("BakeWindow_generateLightmapUVs");
            if (EditorPrefs.HasKey("BakeWindow_copy")) copy = EditorPrefs.GetBool("BakeWindow_copy");
            if (EditorPrefs.HasKey("BakeWindow_removeComputer")) removeComputer = EditorPrefs.GetBool("BakeWindow_removeComputer");
            if (EditorPrefs.HasKey("BakeWindow_permanent")) permanent = EditorPrefs.GetBool("BakeWindow_permanent");
            format = (SaveFormat)EditorPrefs.GetInt("BakeWindow_format", 0);
            minSize = new Vector2(340, 220);
            maxSize = minSize;
        }

        void OnDestroy()
        {
            EditorPrefs.SetBool("BakeWindow_isStatic", isStatic);
            EditorPrefs.SetBool("BakeWindow_generateLightmapUVs", generateLightmapUVs);
            EditorPrefs.SetBool("BakeWindow_copy", copy);
            EditorPrefs.SetBool("BakeWindow_removeComputer", removeComputer);
            EditorPrefs.SetBool("BakeWindow_permanent", permanent);
            EditorPrefs.SetInt("BakeWindow_format", (int)format);
        }

        void OnGUI() {
            format = (SaveFormat)EditorGUILayout.EnumPopup("Save Format", format);
            bool saveMesh = format != SaveFormat.Scene;

            if (format != SaveFormat.Scene) copy = EditorGUILayout.Toggle("Save without baking", copy);
            bool isCopy = format != SaveFormat.Scene && copy;
            switch (format)
            {
                case SaveFormat.Scene: EditorGUILayout.HelpBox("Saves the mesh inside the scene for lightmap", MessageType.Info); break;
                case SaveFormat.MeshAsset: EditorGUILayout.HelpBox("Saves the mesh as an .asset file inside the project. This makes using the mesh in prefabs and across scenes possible.", MessageType.Info); break;
                case SaveFormat.OBJ: EditorGUILayout.HelpBox("Exports the mesh as an OBJ file which can be imported in a third-party modeling application.", MessageType.Info); break;
            }
            EditorGUILayout.Space();

            if (!isCopy)
            {
                isStatic = EditorGUILayout.Toggle("Make Static", isStatic);
                permanent = EditorGUILayout.Toggle("Permanent", permanent);
                generateLightmapUVs = EditorGUILayout.Toggle("Generate Lightmap UVs", generateLightmapUVs);
                if (permanent)
                {
                    removeComputer = EditorGUILayout.Toggle("Remove SplineComputer", removeComputer);
                    if (meshGen.spline.subscriberCount > 1 && !isCopy) EditorGUILayout.HelpBox("WARNING: Removing the SplineComputer from this object will cause other SplineUsers to malfunction!", MessageType.Warning);
                }
            }

            string bakeText = "Bake Mesh";
            if (saveMesh) bakeText = "Bake & Save Mesh";
            if (isCopy) bakeText = "Save Mesh";

            if (GUILayout.Button(bakeText))
            {
                if (permanent)
                {
                    if (!EditorUtility.DisplayDialog("Permanent bake?", "This operation will remove the Mesh Generator. Are you sure you want to continue?", "Yes", "No")) return;
                }
                string savePath = "";
                if (saveMesh)
                {
                    string ext = "asset";
                    if (format == SaveFormat.OBJ) ext = "obj";
                    string meshName = "mesh";
                    if (filter != null) meshName = filter.sharedMesh.name;
                    savePath = EditorUtility.SaveFilePanel("Save " + meshName, Application.dataPath, meshName + "." + ext, ext);
                    if (!Directory.Exists(Path.GetDirectoryName(savePath)) || savePath == "")
                    {
                        EditorUtility.DisplayDialog("Save error", "Invalid save path. Please select a valid save path and try again", "OK");
                        return;
                    }
                    if (format == SaveFormat.OBJ && !copy && !savePath.StartsWith(Application.dataPath))
                    {
                        EditorUtility.DisplayDialog("Save error", "OBJ files can be saved outside of the project folder only when \"Save without baking\" is selected. Please select a directory inside the project in order to save.", "OK");
                        return;
                    }

                    if (format == SaveFormat.MeshAsset && !savePath.StartsWith(Application.dataPath))
                    {
                        EditorUtility.DisplayDialog("Save error", "Asset files cannot be saved outside of the project directory. Please select a path inside the project directory.", "OK");
                        return;
                    }
                }
                Undo.RecordObject(meshGen.gameObject, "Bake mesh");
                if (!isCopy) Bake();
                else
                {
                    MeshUtility.Optimize(filter.sharedMesh);
                    Unwrapping.GenerateSecondaryUVSet(filter.sharedMesh);
                }
                if (saveMesh)
                {
                    SaveMeshFile(savePath);
                }
            }
        }

        void Bake()
        {
            meshGen.Bake(isStatic, generateLightmapUVs);
            EditorUtility.SetDirty(meshGen);
            if (permanent && !copy)
            {
                SplineComputer meshGenComputer = meshGen.spline;
                if (permanent)
                {
                    meshGenComputer.Unsubscribe(meshGen);

                    if (removeComputer && meshGen.transform.IsChildOf(meshGenComputer.transform))
                    {
                        DestroyImmediate(meshGenComputer);
                    }

                    DestroyImmediate(meshGen);
                }
                if (removeComputer && meshGenComputer != null)
                {
                    if (meshGenComputer.GetComponents<Component>().Length == 2)
                    {
                        DestroyImmediate(meshGenComputer.gameObject);
                    }
                    else
                    {
                        DestroyImmediate(meshGenComputer);
                    }
                }
            }
        }

        void SaveMeshFile(string savePath)
        {
            if (format == SaveFormat.Scene) return;
            string relativePath = "";
            if(savePath.StartsWith(Application.dataPath)) relativePath = "Assets" + savePath.Substring(Application.dataPath.Length);

            if (format == SaveFormat.MeshAsset)
            {
                if (copy)
                {
                    Mesh assetMesh = Dreamteck.MeshUtility.Copy(filter.sharedMesh);
                    AssetDatabase.CreateAsset(assetMesh, relativePath);
                } else AssetDatabase.CreateAsset(filter.sharedMesh, relativePath);
            }

            if (format == SaveFormat.OBJ)
            {
                string objString = Dreamteck.MeshUtility.ToOBJString(filter.sharedMesh, renderer.sharedMaterials);
                File.WriteAllText(savePath, objString);
                if (!copy) DestroyImmediate(filter.sharedMesh);
                if (relativePath != "") //Import back the OBJ
                {
                    AssetDatabase.ImportAsset(relativePath, ImportAssetOptions.ForceSynchronousImport);
                    if (!copy) filter.sharedMesh = AssetDatabase.LoadAssetAtPath<Mesh>(relativePath);
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/BakeMeshWindow.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/CapsuleColliderGeneratorEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 3a4dd445293b6d345b9675494ec5e182
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using UnityEditor;

    [CustomEditor(typeof(CapsuleColliderGenerator), true)]
    [CanEditMultipleObjects]
    public class CapsuleColliderGeneratorEditor : SplineUserEditor
    {
        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
        }

        protected override void BodyGUI()
        {
            base.BodyGUI();
            CapsuleColliderGenerator generator = (CapsuleColliderGenerator)target;
            SerializedProperty directionProperty = serializedObject.FindProperty("_direction");
            SerializedProperty heightProperty = serializedObject.FindProperty("_height");
            SerializedProperty radiusProperty = serializedObject.FindProperty("_radius");
            SerializedProperty overlapCapsProperty = serializedObject.FindProperty("_overlapCaps");

            EditorGUI.BeginChangeCheck();
            EditorGUILayout.PropertyField(directionProperty);
            CapsuleColliderGenerator.CapsuleColliderZDirection direction = (CapsuleColliderGenerator.CapsuleColliderZDirection)directionProperty.intValue;
            if(direction == CapsuleColliderGenerator.CapsuleColliderZDirection.Z)
            {
                EditorGUILayout.PropertyField(radiusProperty);
                EditorGUILayout.PropertyField(overlapCapsProperty);
            } else
            {
                EditorGUILayout.PropertyField(heightProperty);
            }

            if (EditorGUI.EndChangeCheck())
            {
                serializedObject.ApplyModifiedProperties();
            }

        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/CapsuleColliderGeneratorEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/ComplexSurfaceGeneratorEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: cf0447f608cafa548962ac2c49022f90
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
#if UNITY_EDITOR
using Dreamteck.Splines.Editor;
using UnityEditor;
using UnityEngine;

namespace Dreamteck.Splines
{
    [CustomEditor(typeof(ComplexSurfaceGenerator), true)]
    public class ComplexSurfaceGeneratorEditor : MeshGenEditor
    {
        private SplineComputer _lastEditedComputer;
        private SplineComputer _highlightedComputer;
        private int _lastEditedPointIndex = -1;
        private bool _positionHandle = false;
        private Vector2 _scroll = Vector2.zero;

        protected override void Awake()
        {
            base.Awake();
            _positionHandle = EditorPrefs.GetBool(nameof(ComplexSurfaceGeneratorEditor) + ".positionHandles", false);
            if (Application.isPlaying) return;
            SerializedProperty initProperty = serializedObject.FindProperty("_initializedInEditor");
            ComplexSurfaceGenerator gen = (ComplexSurfaceGenerator)target;

            if (!initProperty.boolValue)
            {
                AddSpline(gen);
                initProperty.boolValue = true;
                serializedObject.ApplyModifiedProperties();
            }

            SerializedProperty computersProperty = serializedObject.FindProperty("_otherComputers");
            ValidateSplines(gen, computersProperty);
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
            EditorPrefs.SetBool(nameof(ComplexSurfaceGeneratorEditor) + ".positionHandles", _positionHandle);
        }

        protected override void BodyGUI()
        {
            base.BodyGUI();
            ComplexSurfaceGenerator gen = (ComplexSurfaceGenerator)target;
            EditorGUI.BeginChangeCheck();
            gen.separateMaterialIDs = EditorGUILayout.Toggle("Separate Material IDs", gen.separateMaterialIDs);

            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Paths", EditorStyles.boldLabel);

            SerializedProperty computersProperty = serializedObject.FindProperty("_otherComputers");
            SerializedProperty subdivisionsProperty = serializedObject.FindProperty("_subdivisions");
            SerializedProperty subdivisionModeProperty = serializedObject.FindProperty("_subdivisionMode");
            if (EditorGUI.EndChangeCheck()) serializedObject.ApplyModifiedProperties();

            EditorGUI.BeginChangeCheck();
            bool hasNullSpline = false;
            for (int i = 0; i < gen.otherComputers.Length; i++)
            {
                if (gen.otherComputers[i] == null)
                {
                    hasNullSpline = true;
                    break;
                }
            }
            if(hasNullSpline)
            {
                EditorGUILayout.HelpBox("Missing or not enough splines. Please, link at least one splines and remove any missing references.", MessageType.Error);
            }

            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Splines", EditorStyles.boldLabel);
            _positionHandle = EditorGUILayout.Toggle("Toggle Move Handles", _positionHandle);
            EditorGUILayout.Space();
            EditorGUI.indentLevel++;

            _scroll = EditorGUILayout.BeginScrollView(_scroll, GUILayout.Height(Mathf.Min(computersProperty.arraySize * 22, 300)));
            for (int i = 0; i < computersProperty.arraySize; i++)
            {
                SerializedProperty compProperty = computersProperty.GetArrayElementAtIndex(i);
                SplineComputer spline = (SplineComputer)compProperty.objectReferenceValue;
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.LabelField(spline.name);
                if (GUILayout.Button("Edit", GUILayout.MaxWidth(75)))
                {
                    Selection.activeGameObject = spline.gameObject;
                }

                if (GUILayout.Button("Highlight", GUILayout.MaxWidth(75)))
                {
                    if(_highlightedComputer == spline)
                    {
                        _highlightedComputer = null;
                    } else
                    {
                        _highlightedComputer = spline;
                    }
                }
                if (GUILayout.Button("Remove", GUILayout.MaxWidth(75)))
                {
                    if(EditorUtility.DisplayDialog("Delete Spline", "Also remove spline object?", "Yes", "No"))
                    {
                        DestroyImmediate(spline.gameObject);
                    }

                    computersProperty.DeleteArrayElementAtIndex(i);
                    i--;
                    serializedObject.ApplyModifiedProperties();
                    gen.RebuildImmediate();
                }
                EditorGUILayout.EndHorizontal();
            }

            //sEditorGUILayout.PropertyField(computersProperty, new GUIContent("Other Splines"));

            if (EditorGUI.EndChangeCheck())
            {
                ValidateSplines(gen, computersProperty);
                serializedObject.ApplyModifiedProperties();
                gen.RebuildImmediate();
            }
            EditorGUILayout.EndScrollView();

            if (GUILayout.Button("Add Spline"))
            {
                AddSpline(gen);
            }

            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            EditorGUI.BeginChangeCheck();
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Normals", EditorStyles.boldLabel);
            gen.automaticNormals = EditorGUILayout.Toggle("Automatic Normals", gen.automaticNormals);

            var normalMethods = new string[]
            {
                MeshGenerator.NormalMethod.Recalculate.ToString(),
                MeshGenerator.NormalMethod.SplineNormals.ToString(),
            };

            if (!gen.automaticNormals) gen.normalMethod = (MeshGenerator.NormalMethod)EditorGUILayout.Popup("Normal Method", (int)gen.normalMethod, normalMethods);

            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Geometry", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(subdivisionModeProperty);
            EditorGUILayout.PropertyField(subdivisionsProperty);
            if (EditorGUI.EndChangeCheck()) serializedObject.ApplyModifiedProperties();

            UVControls(gen);
        }

        private void ValidateSplines(ComplexSurfaceGenerator gen, SerializedProperty computersProperty)
        {
            for (int i = 0; i < computersProperty.arraySize; i++)
            {
                SerializedProperty compProperty = computersProperty.GetArrayElementAtIndex(i);
                SplineComputer spline = (SplineComputer)compProperty.objectReferenceValue;

                bool isValid = spline != null;

                if (isValid)
                {
                    for (int j = 0; j < i; j++)
                    {
                        SerializedProperty compPropertyPrevious = computersProperty.GetArrayElementAtIndex(j);
                        SplineComputer previousSpline = (SplineComputer)compPropertyPrevious.objectReferenceValue;
                        if (spline == previousSpline)
                        {
                            isValid = false;
                            break;
                        }
                    }
                }



                if (!isValid)
                {
                    computersProperty.DeleteArrayElementAtIndex(i);
                    serializedObject.ApplyModifiedProperties();
                    gen.RebuildImmediate();
                    i--;
                    continue;
                }

                spline.Unsubscribe(gen);
                spline.Subscribe(gen);
            }
        }

        private void AddSpline(ComplexSurfaceGenerator gen)
        {
            SplineComputer reference = gen.spline;
            if (gen.otherComputers.Length > 0)
            {
                for (int i = gen.otherComputers.Length - 1; i >= 0; i--)
                {
                    if (gen.otherComputers[i] != null)
                    {
                        reference = gen.otherComputers[i];
                        break;
                    }
                }
            }

            SplineComputer spline = Instantiate(reference, gen.transform);
            Component[] components = spline.GetComponents<Component>();
            for (int i = components.Length-1; i >= 0; i--)
            {
                if (!(components[i] is SplineComputer || components[i] is Transform))
                {
                    DestroyImmediate(components[i]);
                }
            }

            while(spline.transform.childCount > 0)
            {
                DestroyImmediate(spline.transform.GetChild(0).gameObject);
            }

            Undo.RegisterCreatedObjectUndo(spline.gameObject, "Surface Add Spline");

            Vector3 direction = Vector3.Slerp(reference.Evaluate(0.0).right, reference.Evaluate(1.0).right, 0.5f);
            spline.Subscribe(gen);
            spline.transform.position += direction * reference.CalculateLength() / Mathf.Max((reference.pointCount - 1), 1);
            SerializedProperty computersProperty = serializedObject.FindProperty("_otherComputers");
            computersProperty.arraySize += 1;
            computersProperty.GetArrayElementAtIndex(computersProperty.arraySize - 1).objectReferenceValue = spline;
            serializedObject.ApplyModifiedProperties();
            spline.RebuildImmediate();
            gen.RebuildImmediate();
        }

        public override void OnInspectorGUI()
        {
            showSize = false;
            showRotation = false;
            showNormalMethod = false;
            showOffset = false;
            base.OnInspectorGUI();
        }

        protected override void DuringSceneGUI(SceneView currentSceneView)
        {
            ComplexSurfaceGenerator gen = (ComplexSurfaceGenerator)target;
            base.DuringSceneGUI(currentSceneView);
            for (int i = 0; i < gen.otherComputers.Length; i++)
            {
                //SplineDrawer.DrawSplineComputer(gen.otherComputers[i]);
            }

            SplineComputer[] otherSplines = gen.otherComputers;

            bool rebuild = false;
            for (int i = 0; i < otherSplines.Length; i++)
            {
                bool markDirty = false;
                if (otherSplines[i] == null) continue;
                for (int j = 0; j < otherSplines[i].pointCount; j++)
                {
                    if (otherSplines[i].subscriberCount == 1)
                    {
                        otherSplines[i].name = "Surface Spline " + (i + 1);
                    }
                    Vector3 point = otherSplines[i].GetPointPosition(j);

                    Vector3 newPos = point;

                    if (_positionHandle)
                    {
                        newPos = Handles.PositionHandle(newPos, Quaternion.identity);
                    } else
                    {
                        Handles.color = Color.clear;
                        newPos = SplineEditorHandles.FreeMoveRectangle(point, HandleUtility.GetHandleSize(point) * 0.16f);
                    }
                        

                    if (Vector3.Distance(point, newPos) > 0.01f)
                    {
                        _lastEditedComputer = otherSplines[i];
                        _lastEditedPointIndex = j;
                        _highlightedComputer = null;
                        MainPointModule.HoldInteraction();
                        markDirty = true;
                        otherSplines[i].SetPointPosition(j, newPos);
                    }

                    bool isSelected = (_lastEditedComputer == otherSplines[i] && _lastEditedPointIndex == j) || (_highlightedComputer == otherSplines[i]);
 

                    if (Event.current.type == EventType.Repaint)
                    {    
                        SplineEditorHandles.DrawPoint(point, isSelected, MainPointModule.isSelecting ? new Color(0.5f, 0.5f, 0.5f, 0.5f) : Color.white);
                    }
                }

                if(Event.current.type == EventType.MouseUp && Event.current.button == 0)
                {
                    _lastEditedPointIndex = -1;
                    _lastEditedComputer = null;
                }

                if (markDirty)
                {
                    EditorUtility.SetDirty(otherSplines[i]);
                    rebuild = true;
                }
            }
            if (rebuild)
            {
                for (int i = 0; i < users.Length; i++)
                {
                    users[i].RebuildImmediate();
                }
            }
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/ComplexSurfaceGeneratorEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/EdgeColliderGeneratorEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 18c6e61192794d34084b29e95d81c0bc
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using UnityEditor;

    [CustomEditor(typeof(EdgeColliderGenerator))]
    [CanEditMultipleObjects]
    public class EdgeColliderGeneratorEditor : SplineUserEditor
    {
        protected override void BodyGUI()
        {
            base.BodyGUI();
            EdgeColliderGenerator generator = (EdgeColliderGenerator)target;

            serializedObject.Update();
            SerializedProperty offset = serializedObject.FindProperty("_offset");
            SerializedProperty updateRate = serializedObject.FindProperty("updateRate");

            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Polygon", EditorStyles.boldLabel);

            EditorGUI.BeginChangeCheck();
            EditorGUILayout.PropertyField(offset, new GUIContent("Offset"));
            EditorGUILayout.PropertyField(updateRate);
            if (updateRate.floatValue < 0f) updateRate.floatValue = 0f;
            if (EditorGUI.EndChangeCheck())
            {
                serializedObject.ApplyModifiedProperties();
            }
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/EdgeColliderGeneratorEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/LengthCalculatorEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 4b0cb98d553738f458280b7a6589f63d
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using UnityEditor;

    [CustomEditor(typeof(LengthCalculator), true)]
    [CanEditMultipleObjects]
    public class LengthCalculatorEditor : SplineUserEditor
    {
        public override void OnInspectorGUI()
        {
            showAveraging = false;
            base.OnInspectorGUI();
        }

        protected override void BodyGUI()
        {
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Length Calculator", EditorStyles.boldLabel);
            base.BodyGUI();
            LengthCalculator calculator = (LengthCalculator)target;
            for (int i = 0; i < targets.Length; i++)
            {
                LengthCalculator lengthCalc = (LengthCalculator)targets[i];
                if (lengthCalc.spline == null) continue;
                EditorGUILayout.HelpBox(lengthCalc.spline.name + " Length: " + lengthCalc.length, MessageType.Info);
            }
            if (targets.Length > 1) return;
            SerializedProperty events = serializedObject.FindProperty("lengthEvents");

            EditorGUI.BeginChangeCheck();
            for (int i = 0; i < events.arraySize; i++)
            {
                SerializedProperty eventProperty = events.GetArrayElementAtIndex(i);
                SerializedProperty onChange = eventProperty.FindPropertyRelative("onChange");
                SerializedProperty enabled = eventProperty.FindPropertyRelative("enabled");
                SerializedProperty targetLength = eventProperty.FindPropertyRelative("targetLength");
                SerializedProperty type = eventProperty.FindPropertyRelative("type");

                EditorGUIUtility.labelWidth = 100;
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.PropertyField(enabled, new GUIContent(""), GUILayout.Width(20));
                EditorGUILayout.PropertyField(targetLength);
                EditorGUIUtility.labelWidth = 60;
                EditorGUILayout.PropertyField(type);
                if (GUILayout.Button("x", GUILayout.Width(20)))
                {
                    Undo.RecordObject(calculator, "Remove Length Event");
                    ArrayUtility.RemoveAt(ref calculator.lengthEvents, i);
                }
                EditorGUILayout.EndHorizontal();
                EditorGUIUtility.labelWidth = 0;
                EditorGUILayout.PropertyField(onChange);
                EditorGUILayout.Space();
            }
            if (EditorGUI.EndChangeCheck()) serializedObject.ApplyModifiedProperties();
            if (GUILayout.Button("Add Length Event"))
            {
                Undo.RecordObject(calculator, "Add Length Event");
                ArrayUtility.Add(ref calculator.lengthEvents, new LengthCalculator.LengthEvent());
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/LengthCalculatorEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/MeshGenEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 5853c8e53cbbcea4c86f3dfc39e39f47
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using UnityEditor;

    [CustomEditor(typeof(MeshGenerator))]
    [CanEditMultipleObjects]
    public class MeshGenEditor : SplineUserEditor
    {
        protected bool showSize = true;
        protected bool showColor = true;
        protected bool showDoubleSided = true;
        protected bool showFlipFaces = true;
        protected bool showRotation = true;
        protected bool showInfo = false;
        protected bool showOffset = true;
        protected bool showTangents = true;
        protected bool showNormalMethod = true;

        private int _framesPassed = 0;
        private bool _commonFoldout = false;

        MeshGenerator[] generators = new MeshGenerator[0];

        BakeMeshWindow bakeWindow = null;

        protected override void DuringSceneGUI(SceneView currentSceneView)
        {
            base.DuringSceneGUI(currentSceneView);
            MeshGenerator generator = (MeshGenerator)target;
            if (Application.isPlaying) return;
            _framesPassed++;
            if(_framesPassed >= 100)
            {
                _framesPassed = 0;
                if (generator != null && generator.GetComponent<MeshCollider>() != null) generator.UpdateCollider();
            }
        }

        protected override void OnEnable()
        {
            base.OnEnable();
            generators = new MeshGenerator[targets.Length];
            for (int i = 0; i < targets.Length; i++)
            {
                generators[i] = (MeshGenerator)targets[i];
            }
            MeshGenerator user = (MeshGenerator)target;
        }

        public override void OnInspectorGUI()
        {
            MeshGenerator generator = (MeshGenerator)target;
            if (generator.baked)
            {
                SplineEditorGUI.SetHighlightColors(SplinePrefs.highlightColor, SplinePrefs.highlightContentColor);
                if (SplineEditorGUI.EditorLayoutSelectableButton(new GUIContent("Revert Bake", "Makes the mesh dynamic again and allows editing"), true, true))
                {
                    for (int i = 0; i < generators.Length; i++)
                    {
                        generators[i].Unbake();
                        EditorUtility.SetDirty(generators[i]);
                    }
                }
                return;
            }
            base.OnInspectorGUI();
        }

        protected override void BodyGUI()
        {
            base.BodyGUI();
            MeshGenerator generator = (MeshGenerator)target;
            serializedObject.Update();
            SerializedProperty calculateTangents = serializedObject.FindProperty("_calculateTangents");
            SerializedProperty markDynamic = serializedObject.FindProperty("_markDynamic");
            SerializedProperty size = serializedObject.FindProperty("_size");
            SerializedProperty color = serializedObject.FindProperty("_color");
            SerializedProperty normalMethod = serializedObject.FindProperty("_normalMethod");
            SerializedProperty useSplineSize = serializedObject.FindProperty("_useSplineSize");
            SerializedProperty useSplineColor = serializedObject.FindProperty("_useSplineColor");
            SerializedProperty offset = serializedObject.FindProperty("_offset");
            SerializedProperty rotation = serializedObject.FindProperty("_rotation");
            SerializedProperty flipFaces = serializedObject.FindProperty("_flipFaces");
            SerializedProperty doubleSided = serializedObject.FindProperty("_doubleSided");
            SerializedProperty meshIndexFormat = serializedObject.FindProperty("_meshIndexFormat");

            EditorGUI.BeginChangeCheck();

            EditorGUILayout.Space();

            _commonFoldout = EditorGUILayout.Foldout(_commonFoldout, "Common", foldoutHeaderStyle);
            if (_commonFoldout)
            {
                EditorGUI.indentLevel++;
                if (showSize) EditorGUILayout.PropertyField(size, new GUIContent("Size"));
                if (showColor) EditorGUILayout.PropertyField(color, new GUIContent("Color"));
                if (showNormalMethod) EditorGUILayout.PropertyField(normalMethod, new GUIContent("Normal Method"));
                if (showOffset) EditorGUILayout.PropertyField(offset, new GUIContent("Offset"));
                if (showRotation) EditorGUILayout.PropertyField(rotation, new GUIContent("Rotation"));
                if (showTangents) EditorGUILayout.PropertyField(calculateTangents, new GUIContent("Calculate Tangents"));

                EditorGUILayout.PropertyField(useSplineSize, new GUIContent("Use Spline Size"));
                EditorGUILayout.PropertyField(useSplineColor, new GUIContent("Use Spline Color"));
                EditorGUILayout.PropertyField(markDynamic, new GUIContent("Mark Dynamic", "Improves performance in situations where the mesh changes frequently"));
                EditorGUILayout.PropertyField(meshIndexFormat, new GUIContent("Index Format", "Format of the mesh index buffer data. Index buffer can either be 16 bit(supports up to 65535 vertices in a mesh), or 32 bit(supports up to 4 billion vertices).Default index format is 16 bit, since that takes less memory and bandwidth."));
                if(meshIndexFormat.enumValueIndex > 0)
                {
                    EditorGUILayout.HelpBox("Note that GPU support for 32 bit indices is not guaranteed on all platforms; for example Android devices with Mali-400 GPU do not support them.", MessageType.Warning);
                }
                EditorGUI.indentLevel--;
            }

            if (showDoubleSided || showFlipFaces)
            {
                EditorGUILayout.Space();
                EditorGUILayout.LabelField("Faces", EditorStyles.boldLabel);
                if (showDoubleSided) EditorGUILayout.PropertyField(doubleSided, new GUIContent("Double-sided"));
                if (!generator.doubleSided && showFlipFaces) EditorGUILayout.PropertyField(flipFaces, new GUIContent("Flip Faces"));
            }

            if (generator.GetComponent<MeshCollider>() != null)
            {
                EditorGUILayout.Space();
                EditorGUILayout.LabelField("Mesh Collider", EditorStyles.boldLabel);
                generator.colliderUpdateRate = EditorGUILayout.FloatField("Collider Update Iterval", generator.colliderUpdateRate);
            }
            if (EditorGUI.EndChangeCheck())
            {
                serializedObject.ApplyModifiedProperties();
                for (int i = 0; i < generators.Length; i++)
                {
                    generators[i].Rebuild();
                }
            }
        }

        protected override void FooterGUI()
        {
            base.FooterGUI();
            showInfo = EditorGUILayout.Foldout(showInfo, "Info & Components");
            if (showInfo)
            {
                MeshGenerator generator = (MeshGenerator)target;
                MeshFilter filter = generator.GetComponent<MeshFilter>();
                if (filter == null) return;
                MeshRenderer renderer = generator.GetComponent<MeshRenderer>();
                string str = "";
                if (filter.sharedMesh != null) str = "Vertices: " + filter.sharedMesh.vertexCount + "\r\nTriangles: " + (filter.sharedMesh.triangles.Length / 3);
                else str = "No info available";
                EditorGUILayout.HelpBox(str, MessageType.Info);
                bool showFilter = filter.hideFlags == HideFlags.None;
                bool last = showFilter;
                showFilter = EditorGUILayout.Toggle("Show Mesh Filter", showFilter);
                if (last != showFilter)
                {
                    if (showFilter) filter.hideFlags = HideFlags.None;
                    else filter.hideFlags = HideFlags.HideInInspector;
                }
                bool showRenderer = renderer.hideFlags == HideFlags.None;
                last = showRenderer;
                showRenderer = EditorGUILayout.Toggle("Show Mesh Renderer", showRenderer);
                if (last != showRenderer)
                {
                    if (showRenderer) renderer.hideFlags = HideFlags.None;
                    else renderer.hideFlags = HideFlags.HideInInspector;
                }
            }
            if (generators.Length == 1)
            {
                if (GUILayout.Button("Bake Mesh"))
                {
                    MeshGenerator generator = (MeshGenerator)target;
                    bakeWindow = EditorWindow.GetWindow<BakeMeshWindow>();
                    bakeWindow.Init(generator);
                }
            }
        }
        
        protected override void Awake()
        {
            MeshGenerator generator = (MeshGenerator)target;
            MeshRenderer rend = generator.GetComponent<MeshRenderer>();
            if (rend == null) return;
            base.Awake();
        }
        
        protected override void OnDestroy()
        {
            MeshGenerator generator = (MeshGenerator)target;
            base.OnDestroy();
            MeshGenerator gen = (MeshGenerator)target;
            if (gen == null) return;
            if (gen.GetComponent<MeshCollider>() != null) generator.UpdateCollider();
            if (bakeWindow != null) bakeWindow.Close();
        }

        protected override void OnDelete()
        {
            base.OnDelete();
            MeshGenerator generator = (MeshGenerator)target;
            if (generator == null) return;
            MeshFilter filter = generator.GetComponent<MeshFilter>();
            if (filter != null) filter.hideFlags = HideFlags.None;
            MeshRenderer renderer = generator.GetComponent<MeshRenderer>();
            if (renderer != null) renderer.hideFlags = HideFlags.None;
        }

        protected virtual void UVControls(MeshGenerator generator)
        {
            serializedObject.Update();
            SerializedProperty uvMode = serializedObject.FindProperty("_uvMode");
            SerializedProperty uvOffset = serializedObject.FindProperty("_uvOffset");
            SerializedProperty uvRotation = serializedObject.FindProperty("_uvRotation");
            SerializedProperty uvScale = serializedObject.FindProperty("_uvScale");

            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Uv Coordinates", EditorStyles.boldLabel);
            EditorGUI.BeginChangeCheck();
            EditorGUILayout.PropertyField(uvMode, new GUIContent("UV Mode"));
            EditorGUILayout.PropertyField(uvOffset, new GUIContent("UV Offset"));
            EditorGUILayout.PropertyField(uvRotation, new GUIContent("UV Rotation"));
            EditorGUILayout.PropertyField(uvScale, new GUIContent("UV Scale"));
            if (EditorGUI.EndChangeCheck()) serializedObject.ApplyModifiedProperties();
        }
        
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/MeshGenEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/NodeEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 29b7ad072e04e6341bbda1d04593b91f
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using UnityEditor;
    using System.Collections.Generic;

    [CustomEditor(typeof(Node), true)]
    [CanEditMultipleObjects]
    public class NodeEditor : Editor {
        private SplineComputer addComp = null;
        private int addPoint = 0;
        private Node lastnode = null;
        private int[] availablePoints;
        bool connectionsOpen = false, settingsOpen = false;

        private SerializedProperty transformNormals, transformSize, transformTangents, type;
        private Node[] nodes = new Node[0];
        private SerializedObject serializedNodes;


        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
            Node node = (Node)target;
            if (nodes.Length == 1)
            {
                if (addComp != null)
                {
                    string[] pointNames = new string[availablePoints.Length];
                    for (int i = 0; i < pointNames.Length; i++)
                    {
                        pointNames[i] = "Point " + (availablePoints[i] + 1);
                    }
                    if (availablePoints.Length > 0) addPoint = EditorGUILayout.Popup("Link point", addPoint, pointNames);
                    else EditorGUILayout.LabelField("No Points Available");

                    if (GUILayout.Button("Cancel"))
                    {
                        addComp = null;
                        addPoint = 0;
                    }
                    if (addPoint >= 0 && availablePoints.Length > addPoint)
                    {
                        if (node.HasConnection(addComp, availablePoints[addPoint])) EditorGUILayout.HelpBox("Connection already exists (" + addComp.name + "," + availablePoints[addPoint], MessageType.Error);
                        else if (GUILayout.Button("Link"))
                        {
                            AddConnection(addComp, availablePoints[addPoint]);
                        }
                    }
                }
                else
                {
                    SplineEditorGUI.BeginContainerBox(ref connectionsOpen, "Connections");
                    if (connectionsOpen)
                    {
                        ConnectionsGUI();
                    }
                    SplineEditorGUI.EndContainerBox();

                    Rect rect = GUILayoutUtility.GetLastRect();
                    SplineComputer[] addComps;
                    SplineComputer lastComp = addComp;
                    bool dragged = DreamteckEditorGUI.DropArea<SplineComputer>(rect, out addComps);
                    if (dragged && addComps.Length > 0)
                    {
                        SelectComputer(addComps[0]);
                    }

                    if (lastComp != addComp)
                    {
                        SceneView.RepaintAll();
                    }
                }
            } else
            {
                EditorGUILayout.HelpBox("Connection UI not available when multiple Nodes are selected.", MessageType.Info);
            }

            SplineEditorGUI.BeginContainerBox(ref settingsOpen, "Settings");
            if (settingsOpen)
            {
                SettingsGUI();
            }
            SplineEditorGUI.EndContainerBox();
        }

        private void SettingsGUI()
        {
            Node node = (Node)target;
            serializedNodes = new SerializedObject(nodes);
            transformNormals = serializedNodes.FindProperty("_transformNormals");
            transformSize = serializedNodes.FindProperty("_transformSize");
            transformTangents = serializedNodes.FindProperty("_transformTangents");
            type = serializedNodes.FindProperty("type");


            EditorGUI.BeginChangeCheck();

            EditorGUILayout.PropertyField(transformNormals, new GUIContent("Transform Normals"));
            EditorGUILayout.PropertyField(transformSize, new GUIContent("Transform Size"));
            EditorGUILayout.PropertyField(transformTangents, new GUIContent("Transform Tangents"));
            EditorGUILayout.PropertyField(type, new GUIContent("Node Type"));

            if (EditorGUI.EndChangeCheck())
            {
                SceneView.RepaintAll();
                serializedNodes.ApplyModifiedProperties();
                node.UpdatePoints();
                node.UpdateConnectedComputers();
                SetDirty(node);
            }

            EditorGUILayout.BeginHorizontal();

            if(GUILayout.Button("Align Tangents X"))
            {
                AlignTangents(node, 0);
            }

            if (GUILayout.Button("Align Tangents Y"))
            {
                AlignTangents(node, 1);
            }

            if (GUILayout.Button("Align Tangents Z"))
            {
                AlignTangents(node, 2);
            }

            EditorGUILayout.EndHorizontal();
        }

        private void AlignTangents(Node node, int axis)
        {
            Vector3 axisVector = Vector3.forward;
            switch (axis)
            {
                case 0: axisVector = node.transform.right; break;
                case 1: axisVector = node.transform.up; break;
                case 2: axisVector = node.transform.forward; break;
            }

            Undo.RecordObject(node, "Align Tangents");
            SplinePoint point = node.GetPoint(0, false);
            Vector3 tan1 = point.tangent - point.position;
            Vector3 tan2 = point.tangent2 - point.position;
            float tan1Dir = Mathf.Sign(Vector3.Dot(tan1, axisVector));
            float tan2Dir = Mathf.Sign(Vector3.Dot(tan2, axisVector));
            point.tangent = point.position + axisVector * tan1Dir * tan1.magnitude;
            point.tangent2 = point.position + axisVector * tan2Dir * tan2.magnitude;
            node.SetPoint(0, point, false);
            node.UpdateConnectedComputers();
            SetDirty(node);
            SceneView.RepaintAll();
        }

        void ConnectionsGUI()
        {
            Node node = (Node)target;
            Node.Connection[] connections = node.GetConnections();
            EditorGUILayout.Space();

            if (connections.Length > 0)
            {
                for (int i = 0; i < connections.Length; i++)
                {
                    EditorGUILayout.BeginHorizontal();
                    EditorGUILayout.LabelField(connections[i].spline.name + " at point " + (connections[i].pointIndex+1));
                    if (GUILayout.Button("Select", GUILayout.Width(70)))
                    {
                        Selection.activeGameObject = connections[i].spline.gameObject;
                    }
                    SplineEditorGUI.SetHighlightColors(SplinePrefs.highlightColor, SplinePrefs.highlightContentColor);
                    if (SplineEditorGUI.EditorLayoutSelectableButton(new GUIContent("Swap Tangents"), connections[i].spline.type == Spline.Type.Bezier, connections[i].invertTangents))
                    {
                        connections[i].invertTangents = !connections[i].invertTangents;
                        node.UpdateConnectedComputers();
                        SetDirty(node);
                        SceneView.RepaintAll();
                    }
                   
                    if (GUILayout.Button("x", GUILayout.Width(20)))
                    {
                        Undo.RecordObject(node, "Remove connection");
                        Undo.RecordObject(connections[i].spline, "Remove node");
                        connections[i].spline.DisconnectNode(connections[i].pointIndex);
                        node.RemoveConnection(connections[i].spline, connections[i].pointIndex);
                    }
                    EditorGUILayout.EndHorizontal();
                }
            }
            else EditorGUILayout.HelpBox("Drag & Drop SplineComputers here to link their points.", MessageType.Info);
        }

        void OnEnable()
        {
            lastnode = (Node)target;
            lastnode.EditorMaintainConnections();
            connectionsOpen = EditorPrefs.GetBool("Dreamteck.Splines.Editor.NodeEditor.connectionsOpen");
            settingsOpen = EditorPrefs.GetBool("Dreamteck.Splines.Editor.NodeEditor.settingsOpen");
            nodes = new Node[targets.Length];
            for (int i = 0; i < targets.Length; i++)
            {
                nodes[i] = (Node)targets[i];
            }
#if UNITY_2019_1_OR_NEWER
            SceneView.duringSceneGui += DuringSceneGUI;
#else
            SceneView.onSceneGUIDelegate += DuringSceneGUI;
#endif
        }

        private void OnDisable()
        {
            EditorPrefs.SetBool("Dreamteck.Splines.Editor.NodeEditor.connectionsOpen", connectionsOpen);
            EditorPrefs.SetBool("Dreamteck.Splines.Editor.NodeEditor.settingsOpen", settingsOpen);
#if UNITY_2019_1_OR_NEWER
            SceneView.duringSceneGui -= DuringSceneGUI;
#else
            SceneView.onSceneGUIDelegate -= DuringSceneGUI;
#endif
        }

        void OnDestroy()
        {
            if (Application.isEditor && !Application.isPlaying)
            {
                if (((Node)target) == null)
                {
                    Node.Connection[] connections = lastnode.GetConnections();
                    for(int i = 0; i < connections.Length; i++)
                    {
                        if (connections[i].spline == null) continue;
                        Undo.RecordObject(connections[i].spline, "Delete node connections");
                    }
                    lastnode.ClearConnections();
                }
            }
        }

        void SelectComputer(SplineComputer comp)
        {
            addComp = comp;
            if (addComp != null) availablePoints = GetAvailablePoints(addComp);
            SceneView.RepaintAll();
            Repaint();
        }

        void AddConnection(SplineComputer computer, int pointIndex)
        {
            Node node = (Node)target;
            Node.Connection[] connections = node.GetConnections();
            if (EditorUtility.DisplayDialog("Link point?", "Add point " + (pointIndex+1) + " to connections?", "Yes", "No"))
            {
                Undo.RecordObject(addComp, "Add connection");
                Undo.RecordObject(node, "Add Connection");
                if (connections.Length == 0)
                {
                    switch (EditorUtility.DisplayDialogComplex("Align node to point?", "This is the first connection for the node, would you like to snap or align the node's Transform the spline point.", "No", "Snap", "Snap and Align"))
                    {
                        case 1: SplinePoint point = addComp.GetPoint(pointIndex);
                            node.transform.position = point.position;
                            break;
                        case 2:
                            SplineSample result = addComp.Evaluate(pointIndex);
                            node.transform.position = result.position;
                            node.transform.rotation = result.rotation;
                            break;
                    }
                }
                computer.ConnectNode(node, pointIndex);
                addComp = null;
                addPoint = 0;
                SetDirty(node);
                SceneView.RepaintAll();
                Repaint();
            }
        }

        int[] GetAvailablePoints(SplineComputer computer)
        {
            List<int> indices = new List<int>();
            for (int i = 0; i < computer.pointCount; i++)
            {
                if (computer.GetNode(i) != null) continue;
                indices.Add(i);
            }
            return indices.ToArray();
        }

        protected virtual void DuringSceneGUI(SceneView current)
        {
            Node node = (Node)target;
            Node.Connection[] connections = node.GetConnections();
            for (int i = 0; i < connections.Length; i++)
            {
                DSSplineDrawer.DrawSplineComputer(connections[i].spline, 0.0, 1.0, 0.5f);
            }

            if (addComp == null)
            {
                if (connections.Length > 0)
                {
                    bool bezier = false;
                    for (int i = 0; i < connections.Length; i++)
                    {
                        if (connections[i].spline == null) continue;
                        if (connections[i].spline.type == Spline.Type.Bezier)
                        {
                            bezier = true;
                            continue;
                        }
                    }
                    if (bezier && node.type == Node.Type.Smooth)  
                    {
                        if (connections[0].spline != null)
                        {
                            SplinePoint point = node.GetPoint(0, true);
                            Handles.DrawDottedLine(node.transform.position, point.tangent, 6f);
                            Handles.DrawDottedLine(node.transform.position, point.tangent2, 6f);
                            Vector3 lastPos = point.tangent;
                            bool setPoint = false;
                            point.SetTangentPosition(Handles.PositionHandle(point.tangent, node.transform.rotation));
                            if (lastPos != point.tangent) setPoint = true;
                            lastPos = point.tangent2;
                            point.SetTangent2Position(Handles.PositionHandle(point.tangent2, node.transform.rotation));
                            if (lastPos != point.tangent2) setPoint = true;

                            if (setPoint)
                            {
                                node.SetPoint(0, point, true);
                                node.UpdateConnectedComputers();
                                SetDirty(node);
                            }
                        }
                    }
                }
                return;
            }
            SplinePoint[] points = addComp.GetPoints();
            Transform camTransform = SceneView.currentDrawingSceneView.camera.transform;
            DSSplineDrawer.DrawSplineComputer(addComp, 0.0, 1.0, 0.5f);
            TextAnchor originalAlignment = GUI.skin.label.alignment;
            Color originalColor = GUI.skin.label.normal.textColor;

            GUI.skin.label.alignment = TextAnchor.MiddleCenter;
            GUI.skin.label.normal.textColor = addComp.editorPathColor;
            for (int i = 0; i < availablePoints.Length; i++)
            {
                if (addComp.isClosed && i == points.Length - 1) break;

                Handles.Label(points[i].position + Camera.current.transform.up * HandleUtility.GetHandleSize(points[i].position) * 0.3f, (i + 1).ToString());
                if (SplineEditorHandles.CircleButton(points[availablePoints[i]].position, Quaternion.LookRotation(-camTransform.forward, camTransform.up), HandleUtility.GetHandleSize(points[availablePoints[i]].position) * 0.1f, 2f, addComp.editorPathColor))
                {
                    AddConnection(addComp, availablePoints[i]);
                    break;
                }
            }
            GUI.skin.label.alignment = originalAlignment;
            GUI.skin.label.normal.textColor = originalColor;

        }

        public static void SetDirty(Node node)
        {
            EditorUtility.SetDirty(node);
            Node.Connection[] connections = node.GetConnections();
            for (int i = 0; i < connections.Length; i++)
            {
                EditorUtility.SetDirty(connections[i].spline);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/NodeEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/ObjectBenderEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 09a7b4cd1afdfcd48b026eef6eef39db
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using UnityEditor;
    using System.Collections.Generic;

    [CustomEditor(typeof(ObjectBender), true)]
    [CanEditMultipleObjects]
    public class ObjectBenderEditor : SplineUserEditor
    {
        List<int> selected = new List<int>();
        Vector2 scroll = Vector2.zero;
        bool generatedUvs = false;

        protected override void Awake() 
        {
            ObjectBender bender = (ObjectBender)target;
            if(!Application.isPlaying) bender.UpdateReferences();
            base.Awake();
        }

        void PropertyEditor(ObjectBender.BendProperty[] properties)
        {
            if (selected.Count == 0) return;
            int applyRotationCount = 0, applyScaleCount = 0, enableCount = 0, bendMeshCount = 0, bendColliderCount = 0, bendSplineCount = 0;
            bool showMesh = false, showCollider = false, showSpline = false;
            float colliderUpdateRate = 0f;
            for(int i = 0; i < selected.Count; i++)
            {
                ObjectBender.BendProperty property = properties[selected[i]];
                if (property.enabled) enableCount++;
                if (property.applyRotation) applyRotationCount++;
                if (property.applyScale) applyScaleCount++;
                if (property.bendMesh) bendMeshCount++;
                if (property.bendCollider) bendColliderCount++;
                if (property.bendSpline) bendSplineCount++;
                if (property.filter != null) showMesh = true;
                if (property.collider != null) showCollider = true;
                if (property.splineComputer != null) showSpline = true;
                colliderUpdateRate += property.colliderUpdateRate;
            }
            bool enabled = enableCount == selected.Count;
            bool applyRotation = applyRotationCount == selected.Count;
            bool applyScale = applyScaleCount == selected.Count;
            bool bendMesh = bendMeshCount == selected.Count;
            bool bendCollider = bendColliderCount == selected.Count;
            bool bendSpline = bendSplineCount == selected.Count;
            colliderUpdateRate /= selected.Count;
            bool lastEnabled = enabled, lastApplyRotation = applyRotation, lastApplyScale = applyScale, lastBendMesh = bendMesh, lastBendCollider = bendCollider, lastBendSpline = bendSpline;
            float lastColliderUpdateRate = colliderUpdateRate;

            EditorGUIUtility.labelWidth = 90;
            EditorGUI.BeginChangeCheck();
            GUI.color = Color.white;
            EditorGUILayout.BeginVertical(GUI.skin.box, GUILayout.Width(EditorGUIUtility.currentViewWidth - 50));
            EditorGUILayout.BeginHorizontal();
            enabled = EditorGUILayout.Toggle(enabled, GUILayout.Width(20));
            if (selected.Count == 1) EditorGUILayout.LabelField(properties[selected[0]].transform.transform.name);
            else EditorGUILayout.LabelField("Multiple objects");
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.BeginHorizontal();

            EditorGUILayout.BeginVertical();
            applyRotation = EditorGUILayout.Toggle("Apply rotation", applyRotation);
            applyScale = EditorGUILayout.Toggle("Apply scale", applyScale);
            if (showSpline) bendSpline = EditorGUILayout.Toggle("Bend Spline", bendSpline);
            EditorGUILayout.EndVertical();

            EditorGUILayout.BeginVertical();
            if (showMesh)
            {
                bendMesh = EditorGUILayout.Toggle("Bend Mesh", bendMesh);
                if (bendMesh)
                {
                    if (showCollider)
                    {
                        bendCollider = EditorGUILayout.Toggle("Bend Collider", bendCollider);
                        if (bendCollider)
                        {
                            EditorGUI.indentLevel++;
                            colliderUpdateRate = EditorGUILayout.FloatField("Update Rate", colliderUpdateRate);
                            EditorGUI.indentLevel--;
                        }
                    }
                    else GUI.Label(new Rect(EditorGUIUtility.currentViewWidth / 2f - 25, 40, EditorGUIUtility.currentViewWidth / 2f - 30, 22), "No Mesh Colliders Available");
                }
            }
            else EditorGUILayout.LabelField("No Meshes Available");
            EditorGUILayout.EndVertical();

            EditorGUILayout.EndHorizontal();

            EditorGUILayout.EndVertical();
            if (EditorGUI.EndChangeCheck())
            {
                for(int i = 0; i < selected.Count; i++)
                {
                    if (lastEnabled != enabled) properties[selected[i]].enabled = enabled;
                    if (lastApplyRotation != applyRotation) properties[selected[i]].applyRotation = applyRotation;
                    if (lastApplyScale != applyScale) properties[selected[i]].applyScale = applyScale;
                    if (bendMesh != lastBendMesh) properties[selected[i]].bendMesh = bendMesh;
                    if (bendCollider != lastBendCollider) properties[selected[i]].bendCollider = bendCollider;
                    if (bendSpline != lastBendSpline) properties[selected[i]].bendSpline = bendSpline;
                    if (lastColliderUpdateRate != colliderUpdateRate) properties[selected[i]].colliderUpdateRate = colliderUpdateRate;
                }
            }
        }

        void GetChildCount(Transform parent, ref int count)
        {
            foreach(Transform child in parent)
            {
                count++;
                GetChildCount(child, ref count);
            }
        }

        public override void OnInspectorGUI()
        {
            showAveraging = false;
            base.OnInspectorGUI();
        }

        protected override void BodyGUI()
        {
            base.BodyGUI();
            ObjectBender bender = (ObjectBender)target;

            serializedObject.Update();
            SerializedProperty axis = serializedObject.FindProperty("_axis");
            SerializedProperty normalMode = serializedObject.FindProperty("_normalMode");
            SerializedProperty forwardMode = serializedObject.FindProperty("_forwardMode");

            for (int i = 0; i < targets.Length; i++)
            {
                ObjectBender objBender = (ObjectBender)targets[i];
                int childCount = 0;
                GetChildCount(objBender.transform, ref childCount);
                if (objBender.bendProperties.Length - 1 != childCount && !Application.isPlaying) objBender.UpdateReferences();
            }
            EditorGUI.BeginChangeCheck();
            EditorGUILayout.PropertyField(axis, new GUIContent("Axis"));
            EditorGUILayout.PropertyField(normalMode, new GUIContent("Up Vector"));

            if (normalMode.intValue == (int)ObjectBender.NormalMode.Custom)
            {
                SerializedProperty customNormal = serializedObject.FindProperty("_customNormal");
                EditorGUILayout.PropertyField(customNormal, new GUIContent("Custom Up"));
            }
            EditorGUILayout.PropertyField(forwardMode, new GUIContent("Forward Vector"));
            if (forwardMode.intValue == (int)ObjectBender.ForwardMode.Custom)
            {
                SerializedProperty customForward = serializedObject.FindProperty("_customForward");
                EditorGUILayout.PropertyField(customForward, new GUIContent("Custom Forward"));
            }

            if (EditorGUI.EndChangeCheck())
            {
                serializedObject.ApplyModifiedProperties();
                for (int i = 0; i < targets.Length; i++)
                {
                    ObjectBender objBender = (ObjectBender)targets[i];
                    objBender.Rebuild();
                }
            }

            if (targets.Length > 1)
            {
                EditorGUILayout.LabelField("Object properties unavailable when multiple benders are selected.", EditorStyles.centeredGreyMiniLabel);
                return;
            }
            if (!bender.bend)
            {
                float scrollHeight = Mathf.Min(bender.bendProperties.Length, 15) * 22;
                scroll = EditorGUILayout.BeginScrollView(scroll, GUILayout.Height(scrollHeight+5));

                for (int i = 0; i < bender.bendProperties.Length; i++)
                {
                    bool isSelected = selected.Contains(i);
                    if (!bender.bendProperties[i].enabled)
                    {
                        GUI.color = Color.gray;
                        if (isSelected) GUI.color = Color.Lerp(Color.gray, SplinePrefs.highlightColor, 0.5f);
                    }
                    else
                    {
                        if (isSelected) GUI.color = SplinePrefs.highlightColor;
                        else GUI.color = Color.white;
                    }
                    GUILayout.Box(bender.bendProperties[i].transform.transform.name, GUILayout.Height(18), GUILayout.Width(EditorGUIUtility.currentViewWidth - 60));
                    if (GUILayoutUtility.GetLastRect().Contains(Event.current.mousePosition) && Event.current.type == EventType.MouseDown)
                    {
                        if (Event.current.control)
                        {
                            if (!selected.Contains(i)) selected.Add(i);
                        }
                        else if (Event.current.shift && selected.Count > 0)
                        {
                            int from = selected[0];
                            selected.Clear();
                            if (from < i)
                            {
                                for (int n = from; n <= i; n++) selected.Add(n);
                            }
                            else
                            {
                                for (int n = from; n >= i; n--) selected.Add(n);
                            }
                        }
                        else
                        {
                            selected.Clear();
                            selected.Add(i);
                        }
                        Repaint();
                        SceneView.RepaintAll();
                    }
                    GUI.color = Color.white;
                }
                EditorGUILayout.EndScrollView();

                if (selected.Count > 0)
                {
                    PropertyEditor(bender.bendProperties);
                }

                if (selected.Count > 0)
                {
                    if (Event.current.type == EventType.KeyDown)
                    {
                        if (Event.current.keyCode == KeyCode.DownArrow)
                        {
                            if (selected.Count > 1)
                            {
                                int temp = selected[selected.Count - 1];
                                selected.Clear();
                                selected.Add(temp);
                            }
                            selected[0]++;
                            if (selected[0] >= bender.bendProperties.Length) selected[0] = 0;
                        }
                        if (Event.current.keyCode == KeyCode.UpArrow)
                        {
                            if (selected.Count > 1)
                            {
                                int temp = selected[0];
                                selected.Clear();
                                selected.Add(temp);
                            }
                            selected[0]--;
                            if (selected[0] < 0) selected[0] = bender.bendProperties.Length - 1;
                        }

                        Repaint();
                        SceneView.RepaintAll();
                        Event.current.Use();
                    }
                }

            }
            string editModeText = "Enter Edit Mode";
            if (!bender.bend) editModeText = "Bend";
            if (GUILayout.Button(editModeText))
            {
                if (bender.bend) bender.bend = false;
                else bender.bend = true;
            }
            if (bender.bend && !generatedUvs)
            {
                if (GUILayout.Button("Generate Lightmap UVS"))
                {
                    bender.EditorGenerateLightmapUVs();
                    generatedUvs = true;
                }
            }
        }

        protected override void DuringSceneGUI(SceneView currentSceneView)
        {
            base.DuringSceneGUI(currentSceneView);
            ObjectBender bender = (ObjectBender)target;
            if (selected.Count > 0)
            {
                Handles.BeginGUI();
                for(int i = 0; i < selected.Count; i++)
                {
                    Vector2 screenPosition = HandleUtility.WorldToGUIPoint(bender.bendProperties[selected[i]].transform.transform.position);
                    DreamteckEditorGUI.Label(new Rect(screenPosition.x - 120 + bender.bendProperties[selected[i]].transform.transform.name.Length * 4, screenPosition.y, 120, 25), bender.bendProperties[selected[i]].transform.transform.name);
                }
                Handles.EndGUI();
            }
            for(int i = 0; i < bender.bendProperties.Length; i++)
            {
                if(bender.bendProperties[i].bendSpline && bender.bendProperties[i].splineComputer != null)
                {
                    DSSplineDrawer.DrawSplineComputer(bender.bendProperties[i].splineComputer, 0.0, 1.0, 0.2f);
                }
            }

            //Draw bounds
            if (bender.bend) return;
            TS_Bounds bound = bender.GetBounds();
            Vector3 a = bender.transform.TransformPoint(bound.min);
            Vector3 b = bender.transform.TransformPoint(new Vector3(bound.max.x, bound.min.y, bound.min.z));
            Vector3 c = bender.transform.TransformPoint(new Vector3(bound.max.x, bound.min.y, bound.max.z));
            Vector3 d = bender.transform.TransformPoint(new Vector3(bound.min.x, bound.min.y, bound.max.z));

            Vector3 e = bender.transform.TransformPoint(new Vector3(bound.min.x, bound.max.y, bound.min.z));
            Vector3 f = bender.transform.TransformPoint(new Vector3(bound.max.x, bound.max.y, bound.min.z));
            Vector3 g = bender.transform.TransformPoint(new Vector3(bound.max.x, bound.max.y, bound.max.z));
            Vector3 h = bender.transform.TransformPoint(new Vector3(bound.min.x, bound.max.y, bound.max.z));

            Handles.color = Color.gray;
            Handles.DrawLine(a, b);
            Handles.DrawLine(b, c);
            Handles.DrawLine(c, d);
            Handles.DrawLine(d, a);

            Handles.DrawLine(e, f);
            Handles.DrawLine(f, g);
            Handles.DrawLine(g, h);
            Handles.DrawLine(h, e);

            Handles.DrawLine(a, e);
            Handles.DrawLine(b, f);
            Handles.DrawLine(c, g);
            Handles.DrawLine(d, h);

            Vector3 r = bender.transform.right;
            Vector3 fr = bender.transform.forward;

            switch (bender.axis)
            {
                case ObjectBender.Axis.Z: Handles.color = Color.blue; Handles.DrawLine(r + b, r + c);  break;
                case ObjectBender.Axis.X: Handles.color = Color.red; Handles.DrawLine(b - fr, a - fr); break;
                case ObjectBender.Axis.Y: Handles.color = Color.green; Handles.DrawLine(b- fr + r, f - fr + r); break;
            }
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
            SplineUser user = (SplineUser)target;
            if (Application.isEditor && !Application.isPlaying)
            {
                if (user == null) OnDelete(); //The object or the component is being deleted
                else if (user.spline != null)
                {
                    if(!generatedUvs)  user.Rebuild();
                }
            }
            SplineComputerEditor.hold = false;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/ObjectBenderEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/ObjectControllerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 4be170f07c25f6840a0370aab63c89af
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using UnityEditor;
    using Dreamteck.Splines;

    [CustomEditor(typeof(ObjectController))]
    [CanEditMultipleObjects]
    public class ObjectControllerEditor : SplineUserEditor
    {

        protected override void BodyGUI()
        {
            base.BodyGUI();
            ObjectController user = (ObjectController)target;
            serializedObject.Update();
            SerializedProperty objectMethod = serializedObject.FindProperty("_objectMethod");
            SerializedProperty retainPrefabInstancesInEditor = serializedObject.FindProperty("_retainPrefabInstancesInEditor");
            SerializedProperty spawnMethod = serializedObject.FindProperty("_spawnMethod");
            SerializedProperty spawnCount = serializedObject.FindProperty("_spawnCount");
            SerializedProperty delayedSpawn = serializedObject.FindProperty("delayedSpawn");
            SerializedProperty spawnDelay = serializedObject.FindProperty("spawnDelay");
            SerializedProperty iteration = serializedObject.FindProperty("_iteration");
            SerializedProperty applyRotation = serializedObject.FindProperty("_applyRotation");
            SerializedProperty minRotation = serializedObject.FindProperty("_minRotation");
            SerializedProperty maxRotation = serializedObject.FindProperty("_maxRotation");
            SerializedProperty applyScale = serializedObject.FindProperty("_applyScale");
            SerializedProperty minScaleMultiplier = serializedObject.FindProperty("_minScaleMultiplier");
            SerializedProperty maxScaleMultiplier = serializedObject.FindProperty("_maxScaleMultiplier");
            SerializedProperty uniformScaleLerp = serializedObject.FindProperty("_uniformScaleLerp");
            SerializedProperty objectPositioning = serializedObject.FindProperty("_objectPositioning");
            SerializedProperty evaluateOffset = serializedObject.FindProperty("_evaluateOffset");
            SerializedProperty offsetUseWorldCoords = serializedObject.FindProperty("_offsetUseWorldCoords");
            SerializedProperty minOffset = serializedObject.FindProperty("_minOffset");
            SerializedProperty maxOffset = serializedObject.FindProperty("_maxOffset");
            SerializedProperty shellOffset = serializedObject.FindProperty("_shellOffset");
            SerializedProperty rotateByOffset = serializedObject.FindProperty("_rotateByOffset");
            SerializedProperty randomSeed = serializedObject.FindProperty("_randomSeed");
            SerializedProperty useCustomObjectDistance = serializedObject.FindProperty("_useCustomObjectDistance");
            SerializedProperty minObjectDistance = serializedObject.FindProperty("_minObjectDistance");
            SerializedProperty maxObjectDistance = serializedObject.FindProperty("_maxObjectDistance");
            SerializedProperty customOffsetRule = serializedObject.FindProperty("_customOffsetRule");
            SerializedProperty customRotationRule = serializedObject.FindProperty("_customRotationRule");
            SerializedProperty customScaleRule = serializedObject.FindProperty("_customScaleRule");


            EditorGUI.BeginChangeCheck();
            EditorGUILayout.PropertyField(objectMethod, new GUIContent("Object Method"));
            if (objectMethod.intValue == (int)ObjectController.ObjectMethod.Instantiate) EditorGUILayout.PropertyField(retainPrefabInstancesInEditor, new GUIContent("Retain Prefab Instances"));
            if (objectMethod.intValue == (int)ObjectController.ObjectMethod.Instantiate)
            {
                bool objectsChanged = false;
                bool hasObj = false;
                if (users.Length > 1)
                {
                    EditorGUILayout.HelpBox("Editing unavailable when multiple objects are selected", MessageType.Info);
                }
                else
                {
                    EditorGUILayout.Space();
                    EditorGUILayout.LabelField("Instantiate Objects", EditorStyles.boldLabel);
                    EditorGUILayout.BeginVertical();

                    for (int i = 0; i < user.objects.Length; i++)
                    {
                        EditorGUILayout.BeginHorizontal();
                        user.objects[i] = (GameObject)EditorGUILayout.ObjectField(user.objects[i], typeof(GameObject), true);
                        if (GUILayout.Button("x", GUILayout.Width(20)))
                        {
                            GameObject[] newObjects = new GameObject[user.objects.Length - 1];
                            for (int n = 0; n < user.objects.Length; n++)
                            {
                                if (n < i) newObjects[n] = user.objects[n];
                                else if (n == i) continue;
                                else newObjects[n - 1] = user.objects[n];
                                objectsChanged = true;
                            }
                            user.objects = newObjects;
                        }
                        if (i > 0)
                        {
                            if (GUILayout.Button("▲", GUILayout.Width(20)))
                            {
                                GameObject temp = user.objects[i - 1];
                                user.objects[i - 1] = user.objects[i];
                                user.objects[i] = temp;
                                objectsChanged = true;
                            }
                        }
                        if (i < user.objects.Length - 1)
                        {
                            if (GUILayout.Button("▼", GUILayout.Width(20)))
                            {
                                GameObject temp = user.objects[i + 1];
                                user.objects[i + 1] = user.objects[i];
                                user.objects[i] = temp;
                                objectsChanged = true;
                            }
                        }
                        EditorGUILayout.EndHorizontal();
                    }
                    EditorGUILayout.EndVertical();
                    GameObject newObj = null;
                    newObj = (GameObject)EditorGUILayout.ObjectField("Add Object", newObj, typeof(GameObject), true);
                    if (newObj != null)
                    {
                        GameObject[] newObjects = new GameObject[user.objects.Length + 1];
                        user.objects.CopyTo(newObjects, 0);
                        newObjects[newObjects.Length - 1] = newObj;
                        user.objects = newObjects;
                        objectsChanged = true;
                    }

                    for (int i = 0; i < user.objects.Length; i++)
                    {
                        if (user.objects[i] != null)
                        {
                            hasObj = true;
                            break;
                        }
                    }
                }
                
                int lastSpawnMethod = spawnMethod.intValue;
                EditorGUILayout.PropertyField(spawnMethod, new GUIContent("Spawn Method"));
                if (lastSpawnMethod != spawnMethod.intValue)
                {
                    objectsChanged = true;
                }

                if (spawnMethod.intValue == (int)ObjectController.SpawnMethod.Count)
                {
                    int lastSpawnCount = spawnCount.intValue;
                    if (hasObj) EditorGUILayout.PropertyField(spawnCount, new GUIContent("Spawn Count"));
                    else spawnCount.intValue = 0;
                    if (lastSpawnCount != spawnCount.intValue) objectsChanged = true;
                }
                EditorGUILayout.PropertyField(delayedSpawn, new GUIContent("Delayed Spawn"));
                if (delayedSpawn.boolValue)
                {
                    EditorGUILayout.PropertyField(spawnDelay, new GUIContent("Spawn Delay"));
                }

                int lastIteration = iteration.intValue;
                EditorGUILayout.PropertyField(iteration, new GUIContent("Iteration"));
                if (lastIteration != iteration.intValue)
                {
                    objectsChanged = true;
                }

                if (objectsChanged)
                {
                    serializedObject.ApplyModifiedProperties();
                    user.Clear();
                    user.Spawn();
                }
            }
            EditorGUILayout.Space();
            EditorGUILayout.PropertyField(useCustomObjectDistance, new GUIContent("Custom Object Distance"));
            if (useCustomObjectDistance.boolValue)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(minObjectDistance, new GUIContent("Min. Distance"));
                EditorGUILayout.PropertyField(maxObjectDistance, new GUIContent("Max. Distance"));
                EditorGUI.indentLevel--;
            }

            EditorGUILayout.Space();

            EditorGUILayout.LabelField("Position and Offset");
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(customOffsetRule);

            if (customOffsetRule.objectReferenceValue == null)
            {
                if (offsetUseWorldCoords.boolValue)
                {
                    minOffset.vector3Value = EditorGUILayout.Vector3Field("Min. Offset", minOffset.vector3Value);
                    maxOffset.vector3Value = EditorGUILayout.Vector3Field("Max. Offset", maxOffset.vector3Value);
                }
                else
                {
                    minOffset.vector3Value = EditorGUILayout.Vector2Field("Min. Offset", minOffset.vector3Value);
                    maxOffset.vector3Value = EditorGUILayout.Vector2Field("Max. Offset", maxOffset.vector3Value);
                }
            } else
            {
                CustomRuleUI((ObjectControllerCustomRuleBase)customOffsetRule.objectReferenceValue);
            }
            EditorGUI.indentLevel--;

            EditorGUILayout.Space();
            EditorGUILayout.PropertyField(applyRotation, new GUIContent("Apply Rotation"));
            if (user.applyRotation)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(customRotationRule);
                if (customRotationRule.objectReferenceValue == null)
                {
                    EditorGUILayout.PropertyField(minRotation, new GUIContent("Min. Rotation Offset"));
                    EditorGUILayout.PropertyField(maxRotation, new GUIContent("Max. Rotation Offset"));
                } else
                {
                    CustomRuleUI((ObjectControllerCustomRuleBase)customRotationRule.objectReferenceValue);
                }
                EditorGUI.indentLevel--;
            }

            EditorGUILayout.Space();
            EditorGUILayout.PropertyField(applyScale, new GUIContent("Apply Scale"));
            if (user.applyScale)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(customScaleRule);
                if (customScaleRule.objectReferenceValue == null)
                {
                    EditorGUILayout.PropertyField(minScaleMultiplier, new GUIContent("Min. Scale Multiplier"));
                    EditorGUILayout.PropertyField(maxScaleMultiplier, new GUIContent("Max. Scale Multiplier"));
                    EditorGUI.indentLevel++;
                    EditorGUILayout.PropertyField(uniformScaleLerp, new GUIContent("Uniform Lerp"));
                    EditorGUI.indentLevel--;
                } else
                {
                    CustomRuleUI((ObjectControllerCustomRuleBase)customScaleRule.objectReferenceValue);
                }
                EditorGUI.indentLevel--;
            }

            EditorGUILayout.PropertyField(objectPositioning, new GUIContent("Object Positioning"));
            EditorGUILayout.PropertyField(evaluateOffset, new GUIContent("Evaluate Offset"));

            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(offsetUseWorldCoords, new GUIContent("Use World Coords."));
            if(minOffset.vector3Value != maxOffset.vector3Value) EditorGUILayout.PropertyField(shellOffset, new GUIContent("Shell"));
            EditorGUI.indentLevel--;

            EditorGUILayout.PropertyField(rotateByOffset, new GUIContent("Rotate by Offset"));
            EditorGUILayout.PropertyField(randomSeed, new GUIContent("Random Seed"));
            if (EditorGUI.EndChangeCheck()) serializedObject.ApplyModifiedProperties();
            
        }

        private void CustomRuleUI(ObjectControllerCustomRuleBase customRule)
        {
            SerializedObject serializedRule = new SerializedObject(customRule);
            SerializedProperty property = serializedRule.GetIterator();
            property.NextVisible(true);
            property.NextVisible(false);
            EditorGUI.BeginChangeCheck();
            do
            {
                EditorGUILayout.PropertyField(property);
            } while (property.NextVisible(false));
            if (EditorGUI.EndChangeCheck())
            {
                serializedRule.ApplyModifiedProperties();
            }
        }

    }


}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/ObjectControllerEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/ParticleControllerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b2fe6a6d8bb85894c96049081f441293
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using UnityEditor;

    [CustomEditor(typeof(ParticleController))]
    [CanEditMultipleObjects]
    public class ParticleControllerEditor : SplineUserEditor
    {
        protected override void BodyGUI()
        {
            base.BodyGUI();
            ParticleController user = (ParticleController)target;

            serializedObject.Update();
            SerializedProperty _particleSystem = serializedObject.FindProperty("_particleSystem");

            SerializedProperty emitPoint = serializedObject.FindProperty("emitPoint");
            SerializedProperty offset = serializedObject.FindProperty("offset");
            SerializedProperty volumetric = serializedObject.FindProperty("volumetric");
            SerializedProperty pauseWhenNotVisible = serializedObject.FindProperty("pauseWhenNotVisible");
            SerializedProperty applyRotation = serializedObject.FindProperty("apply3DRotation");
            SerializedProperty emitFromShell = serializedObject.FindProperty("emitFromShell");
            SerializedProperty scale = serializedObject.FindProperty("scale");
            SerializedProperty motionType = serializedObject.FindProperty("motionType");
            SerializedProperty wrapMode = serializedObject.FindProperty("wrapMode");
            SerializedProperty minCycles = serializedObject.FindProperty("minCycles");
            SerializedProperty maxCycles = serializedObject.FindProperty("maxCycles");

            EditorGUI.BeginChangeCheck();
            EditorGUILayout.PropertyField(_particleSystem, new GUIContent("Particle System"));
            if (_particleSystem.objectReferenceValue == null)
            {
                EditorGUILayout.HelpBox("No particle system is assigned", MessageType.Error);
                return;
            }
            EditorGUILayout.PropertyField(pauseWhenNotVisible);
            EditorGUILayout.PropertyField(emitPoint);
            EditorGUILayout.PropertyField(offset);
            EditorGUILayout.PropertyField(applyRotation);
            EditorGUILayout.PropertyField(volumetric);
            if (volumetric.boolValue)
            {
                EditorGUILayout.PropertyField(emitFromShell);
                EditorGUILayout.PropertyField(scale);
            }
            EditorGUILayout.PropertyField(motionType);
            if(motionType.intValue == (int)ParticleController.MotionType.FollowForward || motionType.intValue == (int)ParticleController.MotionType.FollowBackward)
            {
                EditorGUILayout.PropertyField(wrapMode);
                EditorGUILayout.Space();
                EditorGUILayout.LabelField("Path cycles (over " + user.particleSystemComponent.main.startLifetime.constantMax + "s.)", EditorStyles.boldLabel);
                EditorGUILayout.PropertyField(minCycles, new GUIContent("Min. Cycles"));
                if (minCycles.floatValue < 0f) minCycles.floatValue = 0f;
                EditorGUILayout.PropertyField(maxCycles, new GUIContent("Max. Cycles"));
                if (maxCycles.floatValue < minCycles.floatValue) maxCycles.floatValue = minCycles.floatValue; 
            }

            if (EditorGUI.EndChangeCheck())
            {
                serializedObject.ApplyModifiedProperties();
            }

            if (!Application.isPlaying)
            {
                EditorGUILayout.HelpBox("Particles may not work in the editor preview. Play the game to see the in-game result.", MessageType.Info);
            }

        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/ParticleControllerEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/PathGeneratorEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: fb780cd10e9c18946bf622bab1d979d9
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using UnityEditor;

    [CustomEditor(typeof(PathGenerator), true)]
    [CanEditMultipleObjects]
    public class PathGeneratorEditor : MeshGenEditor
    {
        protected override void BodyGUI()
        {
            base.BodyGUI();
            PathGenerator pathGenerator = (PathGenerator)target;
            serializedObject.Update();
            SerializedProperty slices = serializedObject.FindProperty("_slices");
            SerializedProperty shape = serializedObject.FindProperty("_shape");
            SerializedProperty shapeExposure = serializedObject.FindProperty("_shapeExposure");
            SerializedProperty useShapeCurve = serializedObject.FindProperty("_useShapeCurve");
            SerializedProperty compensateCorners = serializedObject.FindProperty("_compensateCorners");
            EditorGUI.BeginChangeCheck();
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Geometry", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(slices, new GUIContent("Slices"));
            EditorGUILayout.PropertyField(compensateCorners, new GUIContent("Compensate Corners"));

            EditorGUILayout.PropertyField(useShapeCurve, new GUIContent("Use Shape Curve"));
            if (useShapeCurve.boolValue)
            {
                if(shape.animationCurveValue == null || shape.animationCurveValue.keys.Length == 0)
                {
                    shape.animationCurveValue = new AnimationCurve();
                    shape.animationCurveValue.AddKey(new Keyframe(0, 0));
                    shape.animationCurveValue.AddKey(new Keyframe(1, 0));
                }
                if (slices.intValue == 1) EditorGUILayout.HelpBox("Slices are set to 1. The curve shape may not be approximated correctly. You can increase the slices in order to fix that.", MessageType.Warning);
                EditorGUILayout.PropertyField(shape, new GUIContent("Shape Curve"));
                EditorGUILayout.PropertyField(shapeExposure, new GUIContent("Shape Exposure"));
            }
            if (slices.intValue < 1) slices.intValue = 1;
            if (EditorGUI.EndChangeCheck()) serializedObject.ApplyModifiedProperties();
            

            UVControls(pathGenerator);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/PathGeneratorEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/PolygonColliderGenEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: db08e631e1379c04898db9f7c1414513
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using UnityEditor;

    [CustomEditor(typeof(PolygonColliderGenerator))]
    [CanEditMultipleObjects]
    public class PolygonColliderGenEditor : SplineUserEditor
    {
        protected override void BodyGUI()
        {
            base.BodyGUI();
            PolygonColliderGenerator generator = (PolygonColliderGenerator)target;

            serializedObject.Update();
            SerializedProperty type = serializedObject.FindProperty("_type");
            SerializedProperty size = serializedObject.FindProperty("_size");
            SerializedProperty offset = serializedObject.FindProperty("_offset");
            SerializedProperty updateRate = serializedObject.FindProperty("updateRate");

            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Polygon", EditorStyles.boldLabel);

            EditorGUI.BeginChangeCheck();
            EditorGUILayout.PropertyField(type, new GUIContent("Type"));
            if (type.intValue == (int)PolygonColliderGenerator.Type.Path) EditorGUILayout.PropertyField(size, new GUIContent("Size"));
            EditorGUILayout.PropertyField(offset, new GUIContent("Offset"));
            EditorGUILayout.PropertyField(updateRate);
            if (updateRate.floatValue < 0f) updateRate.floatValue = 0f;
            if (EditorGUI.EndChangeCheck()) serializedObject.ApplyModifiedProperties();
        }
        
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/PolygonColliderGenEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SetClipRangeWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: db448abaf3c4f914a9fb3ee946340d1c
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEditor;
    public class ClipRangeWindow : EditorWindow
    {
        private float from = 0f;
        private float to = 0f;
        private  System.Action<float, float> rcv;
        private float length = 0f;
        public void Init(System.Action<float, float> receiver, float fromDistance, float toDistance, float totalLength)
        {
            rcv = receiver;
            length = totalLength;
            from = fromDistance;
            to = toDistance;
            titleContent = new GUIContent("Set Clip Range Distances");
            minSize = maxSize = new Vector2(240, 120);
        }

        private void OnGUI()
        {
            if (Event.current.type == EventType.KeyDown && (Event.current.keyCode == KeyCode.KeypadEnter || Event.current.keyCode == KeyCode.Return))
            {
                rcv(from, to);
                Close();
            }
            from = EditorGUILayout.FloatField("From ", from);
            if (from < 0f) from = 0f;
            else if (from > length) from = length;

            to = EditorGUILayout.FloatField("To ", to);
            if (to < 0f) to = 0f;
            else if (to > length) to = length;

            EditorGUILayout.HelpBox("Enter the distance and press Enter. Current spline length: " + length, MessageType.Info);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SetClipRangeWindow.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SetDistanceWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 17ee393449811f045b95ade0241f6d05
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEditor;
    public class DistanceWindow : EditorWindow
    {
        float distance = 0f;
        DistanceReceiver rcv;
        float length = 0f;
        public delegate void DistanceReceiver(float distance);
        public void Init(DistanceReceiver receiver, float totalLength)
        {
            rcv = receiver;
            length = totalLength;
            titleContent = new GUIContent("Set Distance");
            minSize = maxSize = new Vector2(240, 90);
        }

        private void OnGUI()
        {
            if (Event.current.type == EventType.KeyDown && (Event.current.keyCode == KeyCode.KeypadEnter || Event.current.keyCode == KeyCode.Return))
            {
                rcv(distance);
                Close();
            }
            distance = EditorGUILayout.FloatField("Distance", distance);
            if (distance < 0f) distance = 0f;
            else if (distance > length) distance = length;
            if (distance > 0f)
            {
                EditorGUILayout.LabelField("Press Enter to set.", EditorStyles.centeredGreyMiniLabel);
            }
            EditorGUILayout.HelpBox("Enter the distance and press Enter. Current spline length: " + length, MessageType.Info);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SetDistanceWindow.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SplineFollowerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f0ceef9665459454c863f7c9a1de1685
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using UnityEditor;

    [CustomEditor(typeof(SplineFollower), true)]
    [CanEditMultipleObjects]
    public class SplineFollowerEditor : SplineTracerEditor
    {
        SplineSample result = new SplineSample();
        protected SplineFollower[] followers = new SplineFollower[0];
        protected FollowerSpeedModifierEditor speedModifierEditor;

        void OnSetDistance(float distance)
        {
            for (int i = 0; i < targets.Length; i++)
            {
                SplineFollower follower = (SplineFollower)targets[i];
                double travel = follower.Travel(0.0, distance, Spline.Direction.Forward);
                var startPosition = serializedObject.FindProperty("_startPosition");
                startPosition.floatValue = (float)travel;
                follower.SetPercent(travel);
                EditorUtility.SetDirty(follower);
            }
        }

        protected override void OnEnable()
        {
            base.OnEnable();
            followers = new SplineFollower[users.Length];
            for (int i = 0; i < followers.Length; i++)
            {
                followers[i] = (SplineFollower)users[i];
            }

            if (followers.Length == 1)
            {
                speedModifierEditor = new FollowerSpeedModifierEditor(followers[0], this);
            }
        }

        protected override void BodyGUI()
        {
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Following", EditorStyles.boldLabel);
            SplineFollower follower = (SplineFollower)target;

            SerializedProperty followMode = serializedObject.FindProperty("followMode");
            SerializedProperty preserveUniformSpeedWithOffset = serializedObject.FindProperty("preserveUniformSpeedWithOffset");
            SerializedProperty wrapMode = serializedObject.FindProperty("wrapMode");
            SerializedProperty startPosition = serializedObject.FindProperty("_startPosition");
            SerializedProperty autoStartPosition = serializedObject.FindProperty("autoStartPosition");
            SerializedProperty follow = serializedObject.FindProperty("_follow");
            SerializedProperty direction = serializedObject.FindProperty("_direction");
            SerializedProperty unityOnEndReached = serializedObject.FindProperty("_unityOnEndReached");
            SerializedProperty unityOnBeginningReached = serializedObject.FindProperty("_unityOnBeginningReached");

            EditorGUI.BeginChangeCheck();

            bool lastFollow = follow.boolValue;
            EditorGUILayout.PropertyField(follow);
            if(lastFollow != follow.boolValue)
            {
                if (follow.boolValue)
                {
                    if (autoStartPosition.boolValue)
                    {
                        SplineSample sample = new SplineSample();
                        followers[0].Project(followers[0].transform.position, ref sample);
                        if (Application.isPlaying)
                        {
                            for (int i = 0; i < followers.Length; i++)
                            {
                                followers[i].SetPercent(sample.percent);
                            }
                        }
                    }
                }
            }
            EditorGUILayout.PropertyField(followMode);
            if (followMode.intValue == (int)SplineFollower.FollowMode.Uniform)
            {
                SerializedProperty followSpeed = serializedObject.FindProperty("_followSpeed");

                if(followSpeed.floatValue < 0f)
                {
                    direction.intValue = (int)Spline.Direction.Backward;
                } else if (followSpeed.floatValue > 0f)
                {
                    direction.intValue = (int)Spline.Direction.Forward;
                }

                SerializedProperty motion = serializedObject.FindProperty("_motion");
                SerializedProperty motionHasOffset = motion.FindPropertyRelative("_hasOffset");

                EditorGUILayout.PropertyField(followSpeed, new GUIContent("Follow Speed"));



                if (motionHasOffset.boolValue)
                {
                    EditorGUILayout.PropertyField(preserveUniformSpeedWithOffset, new GUIContent("Preserve Uniform Speed With Offset"));
                }
                if (followers.Length == 1)
                {
                    speedModifierEditor.DrawInspector();
                }
            }
            else
            {
                follower.followDuration = EditorGUILayout.FloatField("Follow duration", follower.followDuration);
            }
            


            EditorGUILayout.PropertyField(wrapMode);


            if (follower.motion.applyRotation)
            {
                follower.applyDirectionRotation = EditorGUILayout.Toggle("Face Direction", follower.applyDirectionRotation);
            }

            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Start Position", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(autoStartPosition, new GUIContent("Automatic Start Position"));
            EditorGUILayout.BeginHorizontal();
            EditorGUIUtility.labelWidth = 100f;
            if (!follower.autoStartPosition && !Application.isPlaying)
            {
                float lastStartpos = startPosition.floatValue;
                EditorGUILayout.PropertyField(startPosition, new GUIContent("Start Position"));
                if (GUILayout.Button("Set Distance", GUILayout.Width(85)))
                {
                    DistanceWindow w = EditorWindow.GetWindow<DistanceWindow>(true);
                    w.Init(OnSetDistance, follower.CalculateLength());
                }
            }
            else
            {
                EditorGUILayout.LabelField("Start position", GUILayout.Width(EditorGUIUtility.labelWidth));
            }
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.PropertyField(unityOnBeginningReached);
            EditorGUILayout.PropertyField(unityOnEndReached);

            if (EditorGUI.EndChangeCheck())
            {
                serializedObject.ApplyModifiedProperties();
                if (!Application.isPlaying)
                {
                    for (int i = 0; i < followers.Length; i++)
                    {
                        if(followers[i].spline.sampleCount > 0)
                        {
                            if (!followers[i].autoStartPosition)
                            {
                                followers[i].SetPercent(startPosition.floatValue);
                                if (!followers[i].follow) SceneView.RepaintAll();
                            }
                        }
                    }
                }
            }

            int lastDirection = direction.intValue;
            base.BodyGUI();

            if(lastDirection != direction.intValue)
            {
                SerializedProperty followSpeed = serializedObject.FindProperty("_followSpeed");
                if(direction.intValue == (int)Spline.Direction.Forward)
                {
                    followSpeed.floatValue = Mathf.Abs(followSpeed.floatValue);
                } else
                {
                    followSpeed.floatValue = -Mathf.Abs(followSpeed.floatValue);
                }
            }
        }


        protected override void DuringSceneGUI(SceneView currentSceneView)
        {
            base.DuringSceneGUI(currentSceneView);
            SplineFollower user = (SplineFollower)target;
            if (user == null) return;
            if (Application.isPlaying)
            {
                if (!user.follow) DrawResult(user.result);
                return;
            }
            if (user.spline == null) return;
            if (user.autoStartPosition)
            {
                user.spline.Project(user.transform.position, ref result, user.clipFrom, user.clipTo);
                DrawResult(result);
            } else if(!user.follow) DrawResult(user.result);

            if (followers.Length == 1)
            {
                speedModifierEditor.DrawScene();
            }

        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SplineFollowerEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SplineMeshEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 411935f4b3b0d9b428e92c1b65a2fc16
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using UnityEditor;

    [CustomEditor(typeof(SplineMesh), true)]
    [CanEditMultipleObjects]
    public class SplineMeshEditor : MeshGenEditor
    {
        private int selectedChannel = -1;
        SplineMesh.Channel renameChannel = null;
        MeshDefinitionWindow definitionWindow = null;
        MeshScaleModifierEditor scaleModifierEditor;

        private Mesh GetMeshFromObject(Object obj)
        {
            SplineMesh user = (SplineMesh)target;
            if (!(obj is GameObject)) return null;
            GameObject gameObj = (GameObject)obj;
            MeshFilter filter = gameObj.GetComponent<MeshFilter>();
            Mesh returnMesh = null;
            if (filter != null && filter.sharedMesh != null) returnMesh = filter.sharedMesh;
            MeshRenderer rend = user.GetComponent<MeshRenderer>();
            if (rend == null) return returnMesh;
            MeshRenderer meshRend = gameObj.GetComponent<MeshRenderer>();
            if (meshRend == null) return returnMesh;
            bool found = false;
            for (int i = 0; i < meshRend.sharedMaterials.Length; i++)
            {
                for (int j = 0; j < rend.sharedMaterials.Length; j++)
                {
                    if(meshRend.sharedMaterials[i] == rend.sharedMaterials[j])
                    {
                        found = true;
                        break;
                    }
                }
            }
            if (!found)
            {
                if(EditorUtility.DisplayDialog("New Materials", "The added object has one or more materials which are not refrenced by the renderer. Would you like to add them?", "Yes", "No")) {
                    if(rend.sharedMaterial == AssetDatabase.GetBuiltinExtraResource<Material>("Default-Diffuse.mat"))
                    {
                        if (EditorUtility.DisplayDialog("Replace Material", "The renderer is using the default material. Replace it?", "Yes", "No")) rend.sharedMaterials = new Material[0];
                    }
                    for (int i = 0; i < meshRend.sharedMaterials.Length; i++) AddMaterial(rend, meshRend.sharedMaterials[i]);
                }
            }
            
            return returnMesh;
        }

        void AddMaterial(MeshRenderer target, Material material)
        {
            for (int i = 0; i < target.sharedMaterials.Length; i++)
            {
                if (target.sharedMaterials[i] == material) return;
            }
            Material[] newMaterials = new Material[target.sharedMaterials.Length + 1];
            target.sharedMaterials.CopyTo(newMaterials, 0);
            newMaterials[newMaterials.Length - 1] = material;
            target.sharedMaterials = newMaterials;
        }

        void OnDuplicateChannel(object index)
        {
            SplineMesh extruder = (SplineMesh)target;
            SplineMesh.Channel source = extruder.GetChannel((int)index);
            SplineMesh.Channel newChannel = extruder.AddChannel(source.name);
            source.CopyTo(newChannel);
        }

        void OnRenameChannel(object index)
        {
            SplineMesh extruder = (SplineMesh)target;
            renameChannel = extruder.GetChannel((int)index);
            Repaint();
        }

        void OnDeleteChannel(object index)
        {
            SplineMesh extruder = (SplineMesh)target;
            extruder.RemoveChannel((int)index);
            Repaint();
        }

        void OnMoveChannelUp(object index)
        {
            SplineMesh extruder = (SplineMesh)target;
            extruder.SwapChannels((int)index, ((int)index)-1);
            Repaint();
        }

        void OnMoveChannelDown(object index)
        {
            SplineMesh extruder = (SplineMesh)target;
            extruder.SwapChannels((int)index, ((int)index) + 1);
            Repaint();
        }

        protected override void DuringSceneGUI(SceneView currentSceneView)
        {
            base.DuringSceneGUI(currentSceneView);
            if (scaleModifierEditor != null) scaleModifierEditor.DrawScene();
        }

        protected override void BodyGUI()
        {
            showSize = false;
            showDoubleSided = false;
            showFlipFaces = false;
            base.BodyGUI();

            SplineMesh user = (SplineMesh)target;
            EditorGUI.BeginChangeCheck();

            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Uv Coordinates", EditorStyles.boldLabel);
            user.uvOffset = EditorGUILayout.Vector2Field("UV Offset", user.uvOffset);
            user.uvScale = EditorGUILayout.Vector2Field("UV Scale", user.uvScale);

            if (targets.Length > 1)
            {
                EditorGUILayout.HelpBox("Cannot edit channels when multiple objects are selected", MessageType.Info);
                return;
            }

            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Channels", EditorStyles.boldLabel);
            for (int i = 0; i < user.GetChannelCount(); i++)
            {
                if (ChannelPanel(i))
                {
                    if (Event.current.type == EventType.MouseDown)
                    {
                        Repaint();
                        if (Event.current.button == 0)
                        {
                            if (selectedChannel == i)
                            {
                                selectedChannel = -1;
                            }
                            else
                            {
                                selectedChannel = i;
                                scaleModifierEditor = new MeshScaleModifierEditor(user, this, i);
                                scaleModifierEditor.alwaysOpen = true;
                            }
                        }
                        else if (Event.current.button == 1)
                        {
                            GenericMenu menu = new GenericMenu();
                            menu.AddItem(new GUIContent("Rename"), false, OnRenameChannel, i);
                            menu.AddItem(new GUIContent("Duplicate"), false, OnDuplicateChannel, i);
                            if (i == 0) menu.AddDisabledItem(new GUIContent("Move Up"));
                            else menu.AddItem(new GUIContent("Move Up"), false, OnMoveChannelUp, i);
                            if (i == user.GetChannelCount() - 1) menu.AddDisabledItem(new GUIContent("Move Down"));
                            else menu.AddItem(new GUIContent("Move Down"), false, OnMoveChannelDown, i);
                            menu.AddSeparator("");
                            menu.AddItem(new GUIContent("Delete"), false, OnDeleteChannel, i);
                            menu.ShowAsContext();
                        }
                    }
                }
            }
            if (GUILayout.Button("New Channel")) user.AddChannel("Channel " + (user.GetChannelCount() + 1));

            if (EditorGUI.EndChangeCheck()) EditorUtility.SetDirty(user);
        }

        bool ChannelPanel(int channelIndex)
        {
            SplineMesh.Channel channel = ((SplineMesh)target).GetChannel(channelIndex);
            bool open = selectedChannel == channelIndex;

            GUILayout.BeginVertical(EditorStyles.helpBox);
            if (renameChannel == channel && Event.current.type == EventType.KeyDown && (Event.current.keyCode == KeyCode.Return || Event.current.keyCode == KeyCode.KeypadEnter))
            {
                renameChannel = null;
                Repaint();
            }
            if (renameChannel == channel) channel.name = EditorGUILayout.TextField(channel.name);
            else EditorGUILayout.LabelField(channel.name, EditorStyles.boldLabel);
            if (!open)
            {
                GUILayout.EndVertical();
                return GUILayoutUtility.GetLastRect().Contains(Event.current.mousePosition);
            }
            Rect labelRect = GUILayoutUtility.GetLastRect();
            EditorGUI.indentLevel++;
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Mesh Objects", EditorStyles.boldLabel);

            EditorGUILayout.BeginHorizontal();
            EditorGUIUtility.labelWidth = 100f;
            EditorGUILayout.BeginVertical();
            for (int i = 0; i < channel.GetMeshCount(); i++) MeshRow(channel, i);
            Object obj = null;
            obj = EditorGUILayout.ObjectField("Add Mesh", obj, typeof(Object), true);
            if (obj != null)
            {
                if (obj is Mesh) channel.AddMesh((Mesh)obj);
                else
                {
                    Mesh m = GetMeshFromObject(obj);
                    if (m != null) channel.AddMesh(m);
                }
            }
            EditorGUILayout.EndVertical();
            EditorGUILayout.BeginVertical();
            channel.type = (SplineMesh.Channel.Type)EditorGUILayout.EnumPopup("Type", channel.type);
            if (channel.autoCount) EditorGUILayout.TextField("Auto Count: " + channel.count);
            else channel.count = EditorGUILayout.IntField("Count", channel.count);
            channel.autoCount = EditorGUILayout.Toggle("Auto Count", channel.autoCount);
            channel.randomOrder = EditorGUILayout.Toggle("Random Order", channel.randomOrder);
            if (channel.randomOrder) channel.randomSeed = EditorGUILayout.IntField("Seed", channel.randomSeed);
            EditorGUILayout.EndVertical();
            EditorGUIUtility.labelWidth = 0f;
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.Space();

            float clipFrom = (float)channel.clipFrom;
            float clipTo = (float)channel.clipTo;
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.MinMaxSlider(new GUIContent("Clip Range:"), ref clipFrom, ref clipTo, 0f, 1f);
            EditorGUIUtility.labelWidth = 0f;
            EditorGUILayout.EndHorizontal();
            channel.clipFrom = clipFrom;
            channel.clipTo = clipTo;
            EditorGUILayout.BeginHorizontal(GUILayout.MaxWidth(30));
            channel.clipFrom = EditorGUILayout.FloatField((float)channel.clipFrom);
            channel.clipTo = EditorGUILayout.FloatField((float)channel.clipTo);
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Geometry", EditorStyles.boldLabel);

            if(channel.type != SplineMesh.Channel.Type.Place) channel.spacing = EditorGUILayout.Slider("Spacing", (float)channel.spacing, 0f, 1f);

            //Offset
            channel.minOffset = EditorGUILayout.Vector2Field(channel.randomOffset ? "Offset Min" : "Offset", channel.minOffset);
            if(channel.randomOffset) channel.maxOffset = EditorGUILayout.Vector2Field("Offset Max", channel.maxOffset);
            EditorGUILayout.BeginHorizontal();
            EditorGUIUtility.labelWidth = 130f;
            channel.randomOffset = EditorGUILayout.Toggle("Randomize Offset", channel.randomOffset);
            if (channel.randomOffset) channel.offsetSeed = EditorGUILayout.IntField("Seed", channel.offsetSeed);
            EditorGUIUtility.labelWidth = 0f;
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.Space();

            //Rotation
            if (channel.type == SplineMesh.Channel.Type.Extrude)
            {
                Vector3 rot = channel.minRotation;
                rot.z = EditorGUILayout.FloatField(channel.randomRotation ? "Rotation Min" : "Rotation", rot.z);
                channel.minRotation = rot;
                if (channel.randomRotation)
                {
                    rot = channel.maxRotation;
                    rot.z = EditorGUILayout.FloatField("Rotation Max", rot.z);
                    channel.maxRotation = rot;
                }
            }
            else
            {
                channel.minRotation = EditorGUILayout.Vector3Field(channel.randomRotation ? "Rotation Min" : "Rotation", channel.minRotation);
                if (channel.randomRotation) channel.maxRotation = EditorGUILayout.Vector3Field("Rotation Max", channel.maxRotation);
            }
            EditorGUILayout.BeginHorizontal();
            EditorGUIUtility.labelWidth = 130f;
            channel.randomRotation = EditorGUILayout.Toggle("Randomize Rotation", channel.randomRotation);
            if (channel.randomRotation) channel.rotationSeed = EditorGUILayout.IntField("Seed", channel.rotationSeed);
            EditorGUIUtility.labelWidth = 0f;
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.Space();

            //Scale
            if (channel.type == SplineMesh.Channel.Type.Extrude)
            {
                float lastZ = channel.minScale.z;
                Vector3 scale = channel.minScale;
                scale = EditorGUILayout.Vector2Field(channel.randomScale ? "Scale Min" : "Scale", scale);
                scale += Vector3.forward * lastZ;
                channel.minScale = scale;
                if (channel.randomScale)
                {
                    lastZ = channel.maxScale.z;
                    scale = channel.maxScale;
                    scale = EditorGUILayout.Vector2Field("Scale Max", scale);
                    scale += Vector3.forward * lastZ;
                    channel.maxScale = scale;
                }
            }
            else
            {
                channel.minScale = EditorGUILayout.Vector3Field(channel.randomScale ? "Scale Min" : "Scale", channel.minScale);
                if (channel.randomScale) channel.maxScale = EditorGUILayout.Vector3Field("Scale Max", channel.maxScale);
            }
            EditorGUILayout.BeginHorizontal();
            EditorGUIUtility.labelWidth = 130f;
            channel.randomScale = EditorGUILayout.Toggle("Randomize Scale", channel.randomScale);
            if (channel.randomScale) channel.scaleSeed = EditorGUILayout.IntField("Seed", channel.scaleSeed);
            EditorGUIUtility.labelWidth = 0f;
            EditorGUILayout.EndHorizontal();
            if (channel.randomScale)
            {
                EditorGUI.indentLevel++;
                EditorGUIUtility.labelWidth = 120f;
                channel.uniformRandomScale = EditorGUILayout.Toggle("Uniform", channel.uniformRandomScale);
                EditorGUIUtility.labelWidth = 0f;
                EditorGUI.indentLevel--;
            }

            EditorGUILayout.Space();
            EditorGUILayout.LabelField("UV Coordinates", EditorStyles.boldLabel);
            channel.uvOffset = EditorGUILayout.Vector2Field("UV Offset", channel.uvOffset);
            channel.uvScale = EditorGUILayout.Vector2Field("UV Scale", channel.uvScale);

            //Override

            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Override", EditorStyles.boldLabel);
            channel.overrideNormal = EditorGUILayout.Toggle("Normal", channel.overrideNormal);
            if(channel.overrideNormal) channel.customNormal = EditorGUILayout.Vector3Field("Normal", channel.customNormal);

            if (channel.type == SplineMesh.Channel.Type.Extrude)
            {
                channel.overrideUVs = (SplineMesh.Channel.UVOverride)EditorGUILayout.EnumPopup("UVs", channel.overrideUVs);
                if(channel.overrideUVs != SplineMesh.Channel.UVOverride.None)
                {

                }
            }
            
            channel.overrideMaterialID = EditorGUILayout.Toggle("Material IDs", channel.overrideMaterialID);
            if (channel.overrideMaterialID) channel.targetMaterialID = EditorGUILayout.IntField("Target ID", channel.targetMaterialID);


            if (scaleModifierEditor != null)
            {
                EditorGUILayout.LabelField("Scale Regions", EditorStyles.boldLabel);
                scaleModifierEditor.DrawInspector();
            }
            EditorGUI.indentLevel--;
            GUILayout.EndVertical();
            return labelRect.Contains(Event.current.mousePosition);
        }

        void OnDuplicateMesh(object mesh)
        {
            MeshLink link = (MeshLink)mesh;
            link.channel.DuplicateMesh(link.index);
        }

        void OnDeleteMesh(object mesh)
        {
            MeshLink link = (MeshLink)mesh;
            link.channel.RemoveMesh(link.index);
            Repaint();
        }

        void OnMoveMeshUp(object mesh)
        {
            MeshLink link = (MeshLink)mesh;
            link.channel.SwapMeshes(link.index, link.index - 1);
            Repaint();
        }

        void OnMoveMeshDown(object mesh)
        {
            MeshLink link = (MeshLink)mesh;
            link.channel.SwapMeshes(link.index, link.index + 1);
            Repaint();
        }

        void MeshRow(SplineMesh.Channel channel, int index)
        {
            SplineMesh.Channel.MeshDefinition definition = channel.GetMesh(index);
            EditorGUILayout.BeginHorizontal();
            GUILayout.Space(15);
            if(definition.mesh == null) GUILayout.Box("NULL", EditorStyles.helpBox, GUILayout.MinWidth(200));
            else GUILayout.Box(definition.mesh.name, EditorStyles.helpBox, GUILayout.MinWidth(200));
            EditorGUILayout.EndHorizontal();
            Rect rect = GUILayoutUtility.GetLastRect();
            if (Event.current.type == EventType.MouseDown && rect.Contains(Event.current.mousePosition)){
                if(Event.current.button == 0)
                {
                    definitionWindow = EditorWindow.GetWindow<MeshDefinitionWindow>(true);
                    definitionWindow.Init((SplineMesh)target, definition);
                }   

                if(Event.current.button == 1)
                {
                    GenericMenu menu = new GenericMenu();
                    menu.AddItem(new GUIContent("Duplicate"), false, OnDuplicateMesh, new MeshLink(index, channel));
                    if (index == 0) menu.AddDisabledItem(new GUIContent("Move Up"));
                    else menu.AddItem(new GUIContent("Move Up"), false, OnMoveMeshUp, new MeshLink(index, channel));
                    if (index == channel.GetMeshCount() - 1) menu.AddDisabledItem(new GUIContent("Move Down"));
                    else menu.AddItem(new GUIContent("Move Down"), false, OnMoveMeshDown, new MeshLink(index, channel));
                    menu.AddSeparator("");
                    menu.AddItem(new GUIContent("Delete"), false, OnDeleteMesh, new MeshLink(index, channel));
                    menu.ShowAsContext();
                }
            }
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
            if (definitionWindow != null) definitionWindow.Close();
        }

        internal class MeshLink
        {
            internal int index = 0;
            internal SplineMesh.Channel channel;
            internal MeshLink(int i, SplineMesh.Channel l)
            {
                index = i;
                channel = l;
            }
        }

        public class MeshDefinitionWindow : EditorWindow
        {
            internal SplineMesh.Channel.MeshDefinition definition = null;
            internal SplineMesh extrude = null;

            internal void Init(SplineMesh e, SplineMesh.Channel.MeshDefinition d)
            {
                minSize = new Vector2(482, 180);
                extrude = e;
                definition = d;
                if(definition.mesh != null) titleContent = new GUIContent("Configure " + definition.mesh.name);
                else titleContent = new GUIContent("Configure Mesh");
            }

            private void OnGUI()
            {
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.BeginVertical();
                EditorGUILayout.LabelField("Geometry", EditorStyles.boldLabel);
                definition.mesh = (Mesh)EditorGUILayout.ObjectField(definition.mesh, typeof(Mesh), true);
                definition.mirror = (SplineMesh.Channel.MeshDefinition.MirrorMethod)EditorGUILayout.EnumPopup("Mirror", definition.mirror);
                definition.offset = EditorGUILayout.Vector3Field("Offset", definition.offset);
                definition.rotation = EditorGUILayout.Vector3Field("Rotation", definition.rotation);
                definition.scale = EditorGUILayout.Vector3Field("Scale", definition.scale);
                var spacing = definition.spacing;
                EditorGUILayout.BeginHorizontal();
                EditorGUIUtility.labelWidth = 40;
                EditorGUILayout.LabelField("Spacing");
                spacing.front = EditorGUILayout.FloatField("Front", spacing.front);
                spacing.back = EditorGUILayout.FloatField("Back", spacing.back);
                definition.spacing = spacing;
                EditorGUILayout.EndHorizontal();
                EditorGUIUtility.labelWidth = 0;
                EditorGUILayout.EndVertical();
                EditorGUILayout.BeginVertical();
                EditorGUILayout.LabelField("Faces", EditorStyles.boldLabel);
                definition.doubleSided = EditorGUILayout.Toggle("Double sided", definition.doubleSided);
                if (definition.doubleSided) definition.flipFaces = false;
                else definition.flipFaces = EditorGUILayout.Toggle("Flip Faces", definition.flipFaces);
                definition.removeInnerFaces = EditorGUILayout.Toggle("Remove Inner Faces", definition.removeInnerFaces);
                EditorGUILayout.LabelField("UVs", EditorStyles.boldLabel);
                definition.uvOffset = EditorGUILayout.Vector2Field("UV Offset", definition.uvOffset);
                definition.uvScale = EditorGUILayout.Vector2Field("UV Scale", definition.uvScale);
                definition.uvRotation = EditorGUILayout.Slider("UV Rotation", definition.uvRotation, -180f, 180f);
                definition.vertexGroupingMargin = EditorGUILayout.FloatField("Vertex Grouping Margin", definition.vertexGroupingMargin);
                EditorGUILayout.EndVertical();
                EditorGUILayout.EndHorizontal();
                if (GUI.changed) extrude.Rebuild();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SplineMeshEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SplineMorphEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1be9ae956377fd04384669edabafbd7f
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEditor;

    [CustomEditor(typeof(SplineMorph))]
    public class SplineMorphEditor : Editor
    {
        private string addName = "";
        bool rename = false;
        int selected = -1;

        SplineMorph morph;

        private void OnEnable()
        {
            morph = (SplineMorph)target;
            GetAddName();
        }

        void GetAddName()
        {
            addName = "Channel " + morph.GetChannelCount();
        }

        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
            Undo.RecordObject(morph, "Edit Morph");
            morph.spline = (SplineComputer)EditorGUILayout.ObjectField("Spline", morph.spline, typeof(SplineComputer), true);
            morph.space = (SplineComputer.Space)EditorGUILayout.EnumPopup("Space", morph.space);
            morph.cycle = EditorGUILayout.Toggle("Runtime Cycle", morph.cycle);
            if (morph.cycle)
            {
                EditorGUI.indentLevel++;
                morph.cycleMode = (SplineMorph.CycleMode)EditorGUILayout.EnumPopup("Cycle Wrap", morph.cycleMode);
                morph.cycleUpdateMode = (SplineMorph.UpdateMode)EditorGUILayout.EnumPopup("Update Mode", morph.cycleUpdateMode);
                morph.cycleDuration = EditorGUILayout.FloatField("Cycle Duration", morph.cycleDuration);
                EditorGUI.indentLevel--;
            }

            int channelCount = morph.GetChannelCount();
            if (channelCount > 0)
            {
                if(morph.spline == null)
                {
                    EditorGUILayout.HelpBox("No spline assigned.", MessageType.Error);
                    return;
                }
                if (morph.GetSnapshot(0).Length != morph.spline.pointCount)
                {
                    EditorGUILayout.HelpBox("Recorded morphs require the spline to have " + morph.GetSnapshot(0).Length + ". The spline has " + morph.spline.pointCount, MessageType.Error);
                    EditorGUILayout.BeginHorizontal();
                    if (GUILayout.Button("Clear morph states"))
                    {
                        if (EditorUtility.DisplayDialog("Clear morph states?", "Do you want to clear all morph states?", "Yes", "No"))
                        {
                            morph.Clear();
                        }
                    }
                    string str = "Reduce";
                    if (morph.GetSnapshot(0).Length > morph.spline.pointCount) str = "Increase";
                    if (GUILayout.Button(str + " spline points"))
                    {
                        if (EditorUtility.DisplayDialog(str + " spline points?", "Do you want to " + str + " the spline points?", "Yes", "No"))
                        {
                            morph.spline.SetPoints(morph.GetSnapshot(0), SplineComputer.Space.Local);
                        }
                    }

                    if (GUILayout.Button("Update Morph States"))
                    {
                        if (EditorUtility.DisplayDialog("Update morph states?", "This will add or delete the needed spline points to all morph states", "Yes", "No"))
                        {
                            for (int i = 0; i < morph.GetChannelCount(); i++)
                            {
                                var points = morph.GetSnapshot(i);
                                while (points.Length < morph.spline.pointCount)
                                {
                                    Dreamteck.ArrayUtility.Add(ref points, new SplinePoint());
                                }

                                while (points.Length > morph.spline.pointCount)
                                {
                                    Dreamteck.ArrayUtility.RemoveAt(ref points, points.Length-1);
                                }

                                morph.SetSnapshot(i, points);
                            }
                        }
                    }
                    EditorGUILayout.EndHorizontal();
                    return;
                }
            }

            for (int i = 0; i < channelCount; i++) DrawChannel(i);
            EditorGUILayout.Space();
            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button("+", GUILayout.Width(40)))
            {
                morph.AddChannel(addName);
                GetAddName();
            }
            addName = EditorGUILayout.TextField(addName);
            
            EditorGUILayout.EndHorizontal();
            if (GUI.changed) SceneView.RepaintAll();
        }

        void DrawChannel(int index)
        {
            SplineMorph.Channel channel = morph.GetChannel(index);
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            GUI.backgroundColor = Color.white;
            if (selected == index && rename)
            {
                if (Event.current.type == EventType.KeyDown && Event.current.keyCode == KeyCode.Return) rename = false;
                channel.name = EditorGUILayout.TextField(channel.name);
            }
            else if (index > 0)
            {
                float weight = morph.GetWeight(index);
                float lastWeight = weight;
                EditorGUILayout.BeginHorizontal();
                if (GUILayout.Button(new GUIContent("●", "Capture Snapshot"), GUILayout.Width(22f))) morph.CaptureSnapshot(index);
                EditorGUILayout.LabelField(channel.name, GUILayout.Width(EditorGUIUtility.labelWidth));
                weight = EditorGUILayout.Slider(weight, 0f, 1f);
                EditorGUILayout.EndHorizontal();
                if (lastWeight != weight) morph.SetWeight(index, weight);
                SplineMorph.Channel.Interpolation lastInterpolation = channel.interpolation;
                channel.interpolation = (SplineMorph.Channel.Interpolation)EditorGUILayout.EnumPopup("Interpolation", channel.interpolation);
                if (lastInterpolation != channel.interpolation) morph.UpdateMorph();

                channel.curve = EditorGUILayout.CurveField("Curve", channel.curve);
            }
            else
            {
                EditorGUILayout.BeginHorizontal();
                if (GUILayout.Button(new GUIContent("●", "Capture Snapshot"), GUILayout.Width(22f))) morph.CaptureSnapshot(index);
                GUILayout.Label(channel.name);
                EditorGUILayout.EndHorizontal();
            }
            EditorGUILayout.EndVertical();
            Rect last = GUILayoutUtility.GetLastRect();
            if (last.Contains(Event.current.mousePosition))
            {
                if(Event.current.type == EventType.MouseDown)
                {
                    if (Event.current.button == 0)
                    {
                        rename = false;
                        selected = -1;
                        Repaint();
                    }
                    if (Event.current.button == 1)
                    {
                        GenericMenu menu = new GenericMenu();
                        menu.AddItem(new GUIContent("Rename"), false, delegate { rename = true; selected = index; });
                        menu.AddItem(new GUIContent("Delete"), false, delegate
                        {
                            morph.SetWeight(index, 0f);
                            morph.RemoveChannel(index);
                            selected = -1;
                            GetAddName();
                        });
                        menu.ShowAsContext();
                    }
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SplineMorphEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SplinePositionerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7ac70fff277ab9440b800398df5fb37f
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using UnityEditor;

    [CustomEditor(typeof(SplinePositioner), true)]
    [CanEditMultipleObjects]
    public class SplinePositionerEditor : SplineTracerEditor
    {
        protected override void BodyGUI()
        {
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Positioning", EditorStyles.boldLabel);

            serializedObject.Update();
            SerializedProperty mode = serializedObject.FindProperty("_mode");
            SerializedProperty position = serializedObject.FindProperty("_position");
            SerializedProperty followTarget = serializedObject.FindProperty("_followTarget");
            SerializedProperty followLoop = serializedObject.FindProperty("_followLoop");
            SerializedProperty followTargetDistance = serializedObject.FindProperty("_followTargetDistance");
            SerializedProperty followTargetDirection = serializedObject.FindProperty("_followTargetDirection");

            EditorGUI.BeginChangeCheck();
            SplinePositioner positioner = (SplinePositioner)target;
            if(followTarget.objectReferenceValue == null)
            {
                EditorGUILayout.PropertyField(mode, new GUIContent("Mode"));
                if (positioner.mode == SplinePositioner.Mode.Distance)
                {
                    float lastPos = position.floatValue;
                    EditorGUILayout.PropertyField(position, new GUIContent("Distance"));
                    if (lastPos != position.floatValue)
                    {
                        positioner.position = position.floatValue;
                    }
                }
                else
                {
                    SerializedProperty percent = serializedObject.FindProperty("_result").FindPropertyRelative("percent");
                    EditorGUILayout.BeginHorizontal();
                
                    float pos = position.floatValue;
                    pos = EditorGUILayout.Slider("Percent", (float)pos, 0f, 1f);
                    if(pos != position.floatValue)
                    {
                        position.floatValue = pos;
                        serializedObject.ApplyModifiedProperties();
                        positioner.Rebuild();
                    }


                    if (GUILayout.Button("Set Distance", GUILayout.Width(85)))
                    {
                        DistanceWindow w = EditorWindow.GetWindow<DistanceWindow>(true);
                        w.Init(OnSetDistance, positioner.CalculateLength());
                    }
                    EditorGUILayout.EndHorizontal();
                }
            }

            EditorGUILayout.PropertyField(followTarget);
            if(followTarget.objectReferenceValue != null)
            {
                EditorGUILayout.PropertyField(followTargetDistance);
                EditorGUILayout.PropertyField(followTargetDirection);
                EditorGUILayout.PropertyField(followLoop);
            }

            EditorGUILayout.Space();
            SerializedProperty targetObject = serializedObject.FindProperty("_targetObject");
            EditorGUILayout.PropertyField(targetObject, new GUIContent("Target Object", "Which object to apply the transformations to."));
            

            if (EditorGUI.EndChangeCheck())
            {
                positioner.followTarget = followTarget.objectReferenceValue as SplineTracer;
                positioner.followTargetDistance = followTargetDistance.floatValue;
                positioner.followTargetDirection = (Spline.Direction)followTargetDirection.intValue;
                positioner.followLoop = followLoop.boolValue;
                serializedObject.ApplyModifiedProperties();
            }
            base.BodyGUI();
        }

        void OnSetDistance(float distance)
        {
            int longest = 0;
            float max = 0f;
            for (int i = 0; i < users.Length; i++)
            {
                float length = users[i].CalculateLength();
                if (length > max)
                {
                    max = length;
                    longest = i;
                }
            }
            SerializedProperty position = serializedObject.FindProperty("_position");
            SplinePositioner positioner = (SplinePositioner)targets[longest];
            double travel = positioner.Travel(0.0, distance, Spline.Direction.Forward);
            position.floatValue = (float)travel;
            serializedObject.ApplyModifiedProperties();

            for (int i = 0; i < targets.Length; i++)
            {
                positioner = (SplinePositioner)targets[0];
                positioner.position = travel;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SplinePositionerEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SplineProjectorEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 2d67d75417f347c4ebff4e77014108eb
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using UnityEditor;

    [CustomEditor(typeof(SplineProjector), true)]
    [CanEditMultipleObjects]
    public class SplineProjectorEditor : SplineTracerEditor
    {
        private bool info = false;

        public override void OnInspectorGUI()
        {
            SplineProjector user = (SplineProjector)target;
            if (user.mode == SplineProjector.Mode.Accurate)
            {
                showAveraging = false;
            }
            else
            {
                showAveraging = true;
            }
            base.OnInspectorGUI();
        }

        protected override void BodyGUI()
        {
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Projector", EditorStyles.boldLabel);

            serializedObject.Update();
            SerializedProperty mode = serializedObject.FindProperty("_mode");
            SerializedProperty projectTarget = serializedObject.FindProperty("_projectTarget");
            SerializedProperty targetObject = serializedObject.FindProperty("_targetObject");
            SerializedProperty autoProject = serializedObject.FindProperty("_autoProject");


            EditorGUI.BeginChangeCheck();
            EditorGUILayout.PropertyField(mode, new GUIContent("Mode"));
            if (mode.intValue == (int)SplineProjector.Mode.Accurate)
            {
                SerializedProperty subdivide = serializedObject.FindProperty("_subdivide");
                EditorGUILayout.PropertyField(subdivide, new GUIContent("Subdivide"));
            }
            EditorGUILayout.PropertyField(projectTarget, new GUIContent("Project Target"));
            EditorGUILayout.PropertyField(targetObject, new GUIContent("Apply Target"));

            GUI.color = Color.white;
            EditorGUILayout.PropertyField(autoProject, new GUIContent("Auto Project"));

            info = EditorGUILayout.Foldout(info, "Info");
            SerializedProperty percent = serializedObject.FindProperty("_result").FindPropertyRelative("percent");
            if (info) EditorGUILayout.HelpBox("Projection percent: " + percent.floatValue, MessageType.Info);

            if (EditorGUI.EndChangeCheck()) serializedObject.ApplyModifiedProperties();
            base.BodyGUI();
        }

        protected override void DuringSceneGUI(SceneView currentSceneView)
        {
            base.DuringSceneGUI(currentSceneView);
            for (int i = 0; i < users.Length; i++)
            {
                SplineProjector user = (SplineProjector)users[i];
                if (user.spline == null) return;
                if (!user.autoProject) return;
                DrawResult(user.result);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SplineProjectorEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SplineRendererEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 50802729861530b4fa1d9c6a58c5530c
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using UnityEditor;

    [CustomEditor(typeof(SplineRenderer), true)]
    [CanEditMultipleObjects]
    public class SplineRendererEditor : MeshGenEditor
    {
        protected override void BodyGUI()
        {
            showDoubleSided = false;
            showFlipFaces = false;
            showRotation = false;
            showNormalMethod = false;

            serializedObject.Update();
            SerializedProperty slices = serializedObject.FindProperty("_slices");
            SerializedProperty autoOrient = serializedObject.FindProperty("autoOrient");
            SerializedProperty updateFrameInterval = serializedObject.FindProperty("updateFrameInterval");

            base.BodyGUI();
            EditorGUI.BeginChangeCheck();
            SplineRenderer user = (SplineRenderer)target;
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Geometry", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(slices);
            if (slices.intValue < 1) slices.intValue = 1;
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Render", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(autoOrient);
            if (user.autoOrient)
            {
                EditorGUILayout.PropertyField(updateFrameInterval);
                if (updateFrameInterval.intValue < 0) updateFrameInterval.intValue = 0; 
            }

            if (EditorGUI.EndChangeCheck()) serializedObject.ApplyModifiedProperties();

            UVControls(user);
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SplineRendererEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SplineTracerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 3c6edfe32b7af2542b1eda2ec76580b9
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEditor;

    [CustomEditor(typeof(SplineTracer), true)]
    public class SplineTracerEditor : SplineUserEditor
    {
        private bool cameraFoldout = false;
        private TransformModuleEditor motionEditor;
        private RenderTexture rt;
        private Texture2D renderCanvas = null;
        private Camera cam;
        SplineTracer[] tracers = new SplineTracer[0];

        public delegate void DistanceReceiver(float distance);

        protected override void OnEnable()
        {
            base.OnEnable();
            SplineTracer tracer = (SplineTracer)target;
            motionEditor = new TransformModuleEditor(tracer, this, tracer.motion);
            tracers = new SplineTracer[targets.Length];
            for (int i = 0; i < tracers.Length; i++)
            {
                tracers[i] = (SplineTracer)targets[i];
            }
        }

        private int GetRTWidth()
        {
            return Mathf.RoundToInt(EditorGUIUtility.currentViewWidth)-50;
        }

        private int GetRTHeight()
        {
            return Mathf.RoundToInt(GetRTWidth()/cam.aspect);
        }

        private void CreateRT()
        {
            if(rt != null)
            {
                DestroyImmediate(rt);
                DestroyImmediate(renderCanvas);
            }
            rt = new RenderTexture(GetRTWidth(), GetRTHeight(), 16, RenderTextureFormat.Default, RenderTextureReadWrite.Default);
            renderCanvas = new Texture2D(rt.width, rt.height, TextureFormat.RGB24, false);
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
            DestroyImmediate(rt);
        }

        protected override void BodyGUI()
        {
            base.BodyGUI();
            EditorGUILayout.LabelField("Tracing", EditorStyles.boldLabel);
            SplineTracer tracer = (SplineTracer)target;
            serializedObject.Update();
            SerializedProperty useTriggers = serializedObject.FindProperty("useTriggers");
            SerializedProperty triggerGroup = serializedObject.FindProperty("triggerGroup");
            SerializedProperty direction = serializedObject.FindProperty("_direction");
            SerializedProperty physicsMode = serializedObject.FindProperty("_physicsMode");
            SerializedProperty dontLerpDirection = serializedObject.FindProperty("_dontLerpDirection");

            EditorGUI.BeginChangeCheck();
            EditorGUILayout.PropertyField(useTriggers);
            if (useTriggers.boolValue) EditorGUILayout.PropertyField(triggerGroup);
            EditorGUILayout.PropertyField(direction, new GUIContent("Direction"));
            EditorGUILayout.PropertyField(dontLerpDirection, new GUIContent("Don't Lerp Direction"));
            EditorGUI.BeginChangeCheck();
            EditorGUILayout.PropertyField(physicsMode, new GUIContent("Physics Mode"));

            if (tracer.physicsMode == SplineTracer.PhysicsMode.Rigidbody)
            {
                Rigidbody rb = tracer.GetComponent<Rigidbody>();
                if (rb == null) EditorGUILayout.HelpBox("Assign a Rigidbody component.", MessageType.Error);
                else if (rb.interpolation == RigidbodyInterpolation.None && tracer.updateMethod != SplineUser.UpdateMethod.FixedUpdate) EditorGUILayout.HelpBox("Switch to FixedUpdate mode to ensure smooth update for non-interpolated rigidbodies", MessageType.Warning);

            }
            else if (tracer.physicsMode == SplineTracer.PhysicsMode.Rigidbody2D)
            {
                Rigidbody2D rb = tracer.GetComponent<Rigidbody2D>();
                if (rb == null) EditorGUILayout.HelpBox("Assign a Rigidbody2D component.", MessageType.Error);
                else if (rb.interpolation == RigidbodyInterpolation2D.None && tracer.updateMethod != SplineUser.UpdateMethod.FixedUpdate) EditorGUILayout.HelpBox("Switch to FixedUpdate mode to ensure smooth update for non-interpolated rigidbodies", MessageType.Warning);
            }
            if (tracers.Length == 1)
            {
                bool mightBe2d = false;
                if(tracers[0].spline != null)
                {
                    mightBe2d = tracers[0].spline.is2D;
                }
                if (!mightBe2d)
                {
                    mightBe2d = physicsMode.intValue == (int)SplineTracer.PhysicsMode.Rigidbody2D;
                }
                if (!mightBe2d)
                {
                    if(tracer.GetComponentInChildren<SpriteRenderer>() != null)
                    {
                        mightBe2d = true;
                    }
                }
                motionEditor.DrawInspector();

                if (mightBe2d && !tracer.motion.is2D)
                {
                    EditorGUILayout.HelpBox(
                        "The object is possibly set up for 2D but the rotation is applied in 3D. If the intention is for the object to be 2D, switch to 2D in the Motion panel.",
                        MessageType.Warning);
                }

                cameraFoldout = EditorGUILayout.Foldout(cameraFoldout, "Camera preview");
                if (cameraFoldout)
                {
                    if (cam == null)
                    {
                        cam = tracer.GetComponentInChildren<Camera>();
                    }
                    if (cam != null)
                    {
                        if (rt == null || rt.width != GetRTWidth() || rt.height != GetRTHeight()) CreateRT();
                        GUILayout.Box("", GUILayout.Width(rt.width), GUILayout.Height(rt.height));
                        RenderTexture prevTarget = cam.targetTexture;
                        RenderTexture prevActive = RenderTexture.active;
                        CameraClearFlags lastFlags = cam.clearFlags;
                        Color lastColor = cam.backgroundColor;
                        cam.targetTexture = rt;
                        cam.clearFlags = CameraClearFlags.Color;
                        cam.backgroundColor = Color.black;
                        cam.Render();
                        RenderTexture.active = rt;
                        renderCanvas.SetPixels(new Color[renderCanvas.width * renderCanvas.height]);
                        renderCanvas.ReadPixels(new Rect(0, 0, rt.width, rt.height), 0, 0);
                        renderCanvas.Apply();
                        RenderTexture.active = prevActive;
                        cam.targetTexture = prevTarget;
                        cam.clearFlags = lastFlags;
                        cam.backgroundColor = lastColor;
                        GUI.DrawTexture(GUILayoutUtility.GetLastRect(), renderCanvas, ScaleMode.StretchToFill);
                    }
                    else EditorGUILayout.HelpBox("There is no camera attached to the selected object or its children.", MessageType.Info);
                }
            }
            if (EditorGUI.EndChangeCheck())
            {
                serializedObject.ApplyModifiedProperties();
                for (int i = 0; i < tracers.Length; i++) tracers[i].Rebuild();
            }
        }

        protected override void DuringSceneGUI(SceneView currentSceneView)
        {
            base.DuringSceneGUI(currentSceneView);
            SplineTracer tracer = (SplineTracer)target;
        }

        protected void DrawResult(SplineSample result)
        {
            SplineTracer tracer = (SplineTracer)target;
            Handles.color = Color.white;
            Handles.DrawLine(tracer.transform.position, result.position);
            SplineEditorHandles.DrawSolidSphere(result.position, HandleUtility.GetHandleSize(result.position) * 0.2f);
            Handles.color = Color.blue;
            Handles.DrawLine(result.position, result.position + result.forward * HandleUtility.GetHandleSize(result.position) * 0.5f);
            Handles.color = Color.green;
            Handles.DrawLine(result.position, result.position + result.up * HandleUtility.GetHandleSize(result.position) * 0.5f);
            Handles.color = Color.red;
            Handles.DrawLine(result.position, result.position + result.right * HandleUtility.GetHandleSize(result.position) * 0.5f);
            Handles.color = Color.white;
        }


    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SplineTracerEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SplineUserEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 0895930635ab45148bfcd359f0f2ce19
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using System.Collections.Generic;
    using UnityEditor;

    [CustomEditor(typeof(SplineUser), true)]
    [CanEditMultipleObjects]
    public class SplineUserEditor : Editor
    {
        protected bool showClip = true;
        protected bool showAveraging = true;
        protected bool showUpdateMethod = true;
        protected bool showMultithreading = true;
        private bool settingsFoldout = false;
        protected RotationModifierEditor rotationModifierEditor;
        protected OffsetModifierEditor offsetModifierEditor;
        protected ColorModifierEditor colorModifierEditor;
        protected SizeModifierEditor sizeModifierEditor;
        protected SplineUser[] users = new SplineUser[0];
        SerializedProperty multithreadedProperty, updateMethodProperty, buildOnAwakeProperty, buildOnEnableProperty, autoUpdateProperty, loopSamplesProperty, clipFromProperty, clipToProperty;
        protected GUIStyle foldoutHeaderStyle;

        bool doRebuild = false;
        protected SerializedProperty spline;

        public int editIndex
        {
            get { return _editIndex; }
            set
            {
                if(value == 0)
                {
                    Debug.LogError("Cannot set edit index to 0. 0 is reserved.");
                    return;
                }
                if (value < -1) value = -1;
                _editIndex = value;
            }
        }
        private int _editIndex = -1; //0 is reserved for editing clip values

        protected GUIContent editButtonContent = new GUIContent("Edit", "Enable edit mode in scene view");

        protected virtual void HeaderGUI()
        {
            SplineUser user = (SplineUser)target;
            Undo.RecordObject(user, "Inspector Change");
            SplineComputer lastSpline = (SplineComputer)spline.objectReferenceValue;
            EditorGUILayout.PropertyField(spline);
            SplineComputer newSpline = (SplineComputer)spline.objectReferenceValue;
            if (lastSpline != (SplineComputer)spline.objectReferenceValue)
            {
                for (int i = 0; i < users.Length; i++)
                {
                    if (lastSpline != null) lastSpline.Unsubscribe(users[i]);
                    if (newSpline != null) newSpline.Subscribe(users[i]);
                }
                user.Rebuild();
            }


            if (user.spline == null) EditorGUILayout.HelpBox("No SplineComputer is referenced. Link a SplineComputer to make this SplineUser work.", MessageType.Error);

            settingsFoldout = EditorGUILayout.Foldout(settingsFoldout, "User Configuration", foldoutHeaderStyle);
            if (settingsFoldout)
            {
                EditorGUI.indentLevel++;
                if (showClip) InspectorClipEdit();
                if (showUpdateMethod) EditorGUILayout.PropertyField(updateMethodProperty);
                EditorGUILayout.PropertyField(autoUpdateProperty, new GUIContent("Auto Rebuild"));
                if (showMultithreading) EditorGUILayout.PropertyField(multithreadedProperty);
                EditorGUILayout.PropertyField(buildOnAwakeProperty);
                EditorGUILayout.PropertyField(buildOnEnableProperty);
                EditorGUI.indentLevel--;
            }
        }

        private void InspectorClipEdit()
        {
            bool isClosed = true;
            bool loopSamples = true;
            for (int i = 0; i < users.Length; i++)
            {
                if (users[i].spline == null) isClosed = false;
                else if (!users[i].spline.isClosed) isClosed = false;
                else if (!users[i].loopSamples) loopSamples = false;
            }

            float clipFrom = clipFromProperty.floatValue;
            float clipTo = clipToProperty.floatValue;

            if (isClosed && loopSamples)
            {
                EditorGUILayout.BeginHorizontal();
                if (EditButton(_editIndex == 0))
                {
                    if (_editIndex == 0) _editIndex = -1;
                    else _editIndex = 0;
                }
                EditorGUILayout.BeginVertical();
                clipFrom = EditorGUILayout.Slider("Clip From", clipFrom, 0f, 1f);
                clipTo = EditorGUILayout.Slider("Clip To", clipTo, 0f, 1f);
                EditorGUILayout.EndVertical();
                EditorGUILayout.EndHorizontal();
            }
            else
            {
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.BeginHorizontal();
                if (EditButton(_editIndex == 0))
                {
                    if (_editIndex == 0) _editIndex = -1;
                    else _editIndex = 0;
                }
                if (GUILayout.Button("Set Distance", GUILayout.Width(85)))
                {
                    ClipRangeWindow w = EditorWindow.GetWindow<ClipRangeWindow>(true);
                    float length = 0f;
                    if(users.Length == 1)
                    {
                        length = users[0].spline.CalculateLength();
                    }
                    float fromDist = 0f;
                    float toDist = 0f;
                    int divide = 0;
                    for (int i = 0; i < users.Length; i++)
                    {
                        if(users[i].spline != null)
                        {
                            fromDist += users[i].spline.CalculateLength(0.0, users[i].clipFrom);
                            toDist += users[i].spline.CalculateLength(0.0, users[i].clipTo);
                            divide++;
                        }
                    }

                    if(divide > 0)
                    {
                        fromDist /= divide;
                        toDist /= divide;
                    }
                    w.Init(OnSetClipRangeDistance, fromDist, toDist, length);

                }
                EditorGUIUtility.labelWidth = 80f;
                EditorGUILayout.MinMaxSlider(new GUIContent("Clip Range "), ref clipFrom, ref clipTo, 0f, 1f);
                EditorGUIUtility.labelWidth = 0f;
                EditorGUILayout.EndHorizontal();
                EditorGUILayout.BeginHorizontal(GUILayout.MaxWidth(30));
                clipFrom = EditorGUILayout.FloatField(clipFrom);
                clipTo = EditorGUILayout.FloatField(clipTo);
                EditorGUILayout.EndHorizontal();
                EditorGUILayout.EndHorizontal();
               
            }
            clipFromProperty.floatValue = clipFrom;
            clipToProperty.floatValue = clipTo;
            SplineComputerEditor.hold = _editIndex >= 0;

            if (isClosed) EditorGUILayout.PropertyField(loopSamplesProperty, new GUIContent("Loop Samples"));
            if (!loopSamplesProperty.boolValue || !isClosed)
            {
                if (clipFromProperty.floatValue > clipToProperty.floatValue)
                {
                    float temp = clipToProperty.floatValue;
                    clipToProperty.floatValue = clipFromProperty.floatValue;
                    clipFromProperty.floatValue = temp;
                }
            }
        }

        void OnSetClipRangeDistance(float from, float to)
        {
            int longest = 0;
            float max = 0f;
            for (int i = 0; i < users.Length; i++)
            {
                if (users[i].spline == null) continue;
                float length = users[i].CalculateLength();
                if(length > max)
                {
                    max = length;
                    longest = i;
                }
            }
            clipFromProperty = serializedObject.FindProperty("_clipFrom");
            clipToProperty = serializedObject.FindProperty("_clipTo");
            serializedObject.Update();
            clipFromProperty.floatValue = (float)users[longest].spline.Travel(0.0, from);
            clipToProperty.floatValue = (float)users[longest].spline.Travel(0.0, to);

            serializedObject.ApplyModifiedProperties();

            for (int i = 0; i < users.Length; i++)
            {
                if (users[i].spline == null) continue;
                users[i].clipFrom = clipFromProperty.floatValue;
                users[i].clipTo = clipToProperty.floatValue;
                users[i].RebuildImmediate();
            }
        }

        protected virtual void BodyGUI()
        {
            EditorGUILayout.Space();
        }

        protected virtual void FooterGUI()
        {
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Sample Modifiers", EditorStyles.boldLabel);
            if (users.Length == 1)
            {
                if (offsetModifierEditor != null) offsetModifierEditor.DrawInspector();
                if (rotationModifierEditor != null) rotationModifierEditor.DrawInspector();
                if (colorModifierEditor != null) colorModifierEditor.DrawInspector();
                if (sizeModifierEditor != null) sizeModifierEditor.DrawInspector();
            }
            else EditorGUILayout.LabelField("Modifiers not available when multiple Spline Users are selected.", EditorStyles.centeredGreyMiniLabel);
            
            EditorGUILayout.Space();
        }

        protected virtual void DuringSceneGUI(SceneView currentSceneView)
        {
            if (doRebuild)
            {
                DoRebuild();
            }
            SplineUser user = (SplineUser)target;
            if (user == null) return;
            if (user.spline != null)
            {
                SplineComputer rootComputer = user.GetComponent<SplineComputer>();
                List<SplineComputer> allComputers = user.spline.GetConnectedComputers();
                for (int i = 0; i < allComputers.Count; i++)
                {
                    if (allComputers[i] == rootComputer && _editIndex == -1) continue;
                    if (allComputers[i].editorAlwaysDraw) continue;
                    DSSplineDrawer.DrawSplineComputer(allComputers[i], 0.0, 1.0, 0.4f);
                }
                DSSplineDrawer.DrawSplineComputer(user.spline);
            }
            if (_editIndex == 0) SceneClipEdit();
            if (offsetModifierEditor != null) offsetModifierEditor.DrawScene();
            if (rotationModifierEditor != null)  rotationModifierEditor.DrawScene();
            if (colorModifierEditor != null) colorModifierEditor.DrawScene();
            if (sizeModifierEditor != null) sizeModifierEditor.DrawScene();
        }

        void SceneClipEdit()
        {
            if (users.Length > 1) return;
            SplineUser user = (SplineUser)target;
            if (user.spline == null) return;
            Color col = user.spline.editorPathColor;
            Undo.RecordObject(user, "Edit Clip Range");
            double val = user.clipFrom;
            SplineComputerEditorHandles.Slider(user.spline, ref val, col, "Clip From", SplineComputerEditorHandles.SplineSliderGizmo.ForwardTriangle);
            if (val != user.clipFrom) user.clipFrom = val;
            val = user.clipTo;
            SplineComputerEditorHandles.Slider(user.spline, ref val, col, "Clip To", SplineComputerEditorHandles.SplineSliderGizmo.BackwardTriangle);
            if (val != user.clipTo) user.clipTo = val;
        }

        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
            if (doRebuild) DoRebuild();
            serializedObject.Update();

            EditorGUI.BeginChangeCheck();
            HeaderGUI();
            if (EditorGUI.EndChangeCheck())
            {
                ApplyAndRebuild();
            }

            EditorGUI.BeginChangeCheck();
            BodyGUI();
            if (EditorGUI.EndChangeCheck())
            {
                ApplyAndRebuild();
            }

            EditorGUI.BeginChangeCheck();
            FooterGUI();
            if (EditorGUI.EndChangeCheck())
            {
                ApplyAndRebuild();
            }
        }

        private void ApplyAndRebuild()
        {
            serializedObject.ApplyModifiedProperties();
            DoRebuild();
        }

        private void DoRebuild()
        {
            for (int i = 0; i < users.Length; i++)
            {
                if (users[i] && users[i].isActiveAndEnabled)
                {
                    try
                    {
                        users[i].Rebuild();
                    }
                    catch (System.Exception ex)
                    {
                        Debug.Log(ex.Message);
                    }
                }
            }
            doRebuild = false;
        }

        protected virtual void OnDestroy()
        {
            if (Application.isEditor && !Application.isPlaying)
            {
                if (target == null)
                {
                    OnDelete(); //The object or the component is being deleted
                }
                else
                {
                    DoRebuild();
                }
            }
            SplineComputerEditor.hold = false;

#if UNITY_2019_1_OR_NEWER
            SceneView.duringSceneGui -= DuringSceneGUI;
#endif
        }

        protected virtual void OnDelete()
        {
        }

        protected virtual void Awake()
        {
            foldoutHeaderStyle = EditorStyles.foldout;
#if UNITY_2019_1_OR_NEWER
            SceneView.duringSceneGui += DuringSceneGUI;
#endif
            SplineUser user = (SplineUser)target;
            user.EditorAwake();
        }

#if !UNITY_2019_1_OR_NEWER
        protected void OnSceneGUI()
        {
            DuringSceneGUI(SceneView.currentDrawingSceneView);
        }
#endif


        protected virtual void OnEnable()
        {
            SplineUser user = (SplineUser)target;
            
            settingsFoldout = EditorPrefs.GetBool("Dreamteck.Splines.Editor.SplineUserEditor.settingsFoldout", false);
            rotationModifierEditor = new RotationModifierEditor(user, this);
            offsetModifierEditor = new OffsetModifierEditor(user, this);
            colorModifierEditor = new ColorModifierEditor(user, this);
            sizeModifierEditor = new SizeModifierEditor(user, this);

            updateMethodProperty = serializedObject.FindProperty("updateMethod");
            buildOnAwakeProperty = serializedObject.FindProperty("buildOnAwake");
            buildOnEnableProperty = serializedObject.FindProperty("buildOnEnable");
            multithreadedProperty = serializedObject.FindProperty("multithreaded");
            autoUpdateProperty = serializedObject.FindProperty("_autoUpdate");
            loopSamplesProperty = serializedObject.FindProperty("_loopSamples");
            clipFromProperty = serializedObject.FindProperty("_clipFrom");
            clipToProperty = serializedObject.FindProperty("_clipTo");
            spline = serializedObject.FindProperty("_spline");

            users = new SplineUser[targets.Length];
            for (int i = 0; i < users.Length; i++)
            {
                users[i] = (SplineUser)targets[i];
            }
            Undo.undoRedoPerformed += OnUndoRedo;
        }


        protected virtual void OnDisable()
        {
            EditorPrefs.SetBool("Dreamteck.Splines.Editor.SplineUserEditor.settingsFoldout", settingsFoldout);
            Undo.undoRedoPerformed -= OnUndoRedo;
        }

        protected virtual void OnUndoRedo()
        {
            doRebuild = true;
        }

        public bool EditButton(bool selected)
        {
            float width = 40f;
            editButtonContent.image = ResourceUtility.EditorLoadTexture("Splines/Editor/Icons", "edit_cursor");
            if (editButtonContent.image != null)
            {
                editButtonContent.text = "";
                width = 25f;
            }
            SplineEditorGUI.SetHighlightColors(SplinePrefs.highlightColor, SplinePrefs.highlightContentColor);
            if (SplineEditorGUI.EditorLayoutSelectableButton(editButtonContent, true, selected, GUILayout.Width(width)))
            {
                SceneView.RepaintAll();
                return true;
            }
            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SplineUserEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SplineUserSubEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 072866cc5f8b8e94d9ed416f33661a42
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEditor;

    public class SplineUserSubEditor
    {
        protected string title = "";
        protected SplineUser user;
        protected SplineUserEditor editor = null;
        public bool alwaysOpen = false;

        public bool isOpen
        {
            get { return foldout || alwaysOpen; }
        }
        bool foldout = false;

        public SplineUserSubEditor(SplineUser user, SplineUserEditor editor)
        {
            this.editor = editor;
            this.user = user;
        }

        public virtual void DrawInspector()
        {
            if (!alwaysOpen)
            {
                foldout = EditorGUILayout.Foldout(foldout, title);
            }
        }

        public virtual void DrawScene()
        {

        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SplineUserSubEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SurfaceGeneratorEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 09f3755defd393e4d862eb6298748196
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using UnityEditor;

    [CustomEditor(typeof(SurfaceGenerator))]
    [CanEditMultipleObjects]
    public class SurfaceGeneratorEditor : MeshGenEditor
    {
        protected override void DuringSceneGUI(SceneView currentSceneView)
        {
            base.DuringSceneGUI(currentSceneView);
            SurfaceGenerator user = (SurfaceGenerator)target;
            if (user.extrudeSpline != null)
            {
                DSSplineDrawer.DrawSplineComputer(user.extrudeSpline, 0.0, 1.0, 0.5f);
            }
        }
        
        protected override void BodyGUI()
        {
            showSize = false;
            showRotation = false;
            base.BodyGUI();
            SurfaceGenerator user = (SurfaceGenerator)target;
            serializedObject.Update();
            SerializedProperty expand = serializedObject.FindProperty("_expand");
            SerializedProperty extrude = serializedObject.FindProperty("_extrude");
            SerializedProperty extrudeSpline = serializedObject.FindProperty("_extrudeSpline");
            EditorGUI.BeginChangeCheck();
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Shape", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(expand, new GUIContent("Expand"));
            if (extrudeSpline.objectReferenceValue == null) EditorGUILayout.PropertyField(extrude, new GUIContent("Extrude"));
            var lastExtrudeSpline = extrudeSpline.objectReferenceValue;
            EditorGUILayout.PropertyField(extrudeSpline, new GUIContent("Extrude Path"));
            if(lastExtrudeSpline != extrudeSpline.objectReferenceValue)
            {
                if (lastExtrudeSpline != null)
                {
                    for (int i = 0; i < users.Length; i++)
                    {
                        ((SplineComputer)lastExtrudeSpline).Unsubscribe(users[i]);
                    }
                }

                SplineComputer spline = (SplineComputer)extrudeSpline.objectReferenceValue;
                if (spline != null)
                {
                    for (int i = 0; i < users.Length; i++)
                    {
                        spline.Subscribe(users[i]);
                    }
                }
            }

            if (extrudeSpline.objectReferenceValue != null)
            {
                SerializedProperty extrudeClipFrom = serializedObject.FindProperty("_extrudeFrom");
                SerializedProperty extrudeClipTo = serializedObject.FindProperty("_extrudeTo");
                float clipFrom = extrudeClipFrom.floatValue;
                float clipTo = extrudeClipTo.floatValue;
                EditorGUILayout.MinMaxSlider(new GUIContent("Extrude Clip Range:"), ref clipFrom, ref clipTo, 0f, 1f);
                extrudeClipFrom.floatValue = clipFrom;
                extrudeClipTo.floatValue = clipTo;
                SerializedProperty extrudeOffset = serializedObject.FindProperty("_extrudeOffset");
                EditorGUILayout.PropertyField(extrudeOffset);
            }
            bool change = false;
            if (EditorGUI.EndChangeCheck())
            {
                change = true;
                serializedObject.ApplyModifiedProperties();
            }

            UVControls(user);

            if (extrude.floatValue != 0f || extrudeSpline.objectReferenceValue != null)
            {
                EditorGUI.BeginChangeCheck();
                SerializedProperty sideUvOffset = serializedObject.FindProperty("_sideUvOffset");
                SerializedProperty sideUvScale = serializedObject.FindProperty("_sideUvScale");
                SerializedProperty sideUVRotation = serializedObject.FindProperty("_sideUvRotation");
                SerializedProperty uniformUvs = serializedObject.FindProperty("_uniformUvs");


                EditorGUILayout.PropertyField(sideUvOffset, new GUIContent("Side UV Offset"));
                EditorGUILayout.PropertyField(sideUVRotation, new GUIContent("Side UV Rotation"));
                EditorGUILayout.PropertyField(sideUvScale, new GUIContent("Side UV Scale"));
                EditorGUILayout.PropertyField(uniformUvs, new GUIContent("Unform UVs"));
                if (EditorGUI.EndChangeCheck())
                {
                    change = true;
                    serializedObject.ApplyModifiedProperties();
                }
            }

            if (change)
            {
                for (int i = 0; i < users.Length; i++)
                {
                    users[i].Rebuild();
                }
            }
        }  
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/SurfaceGeneratorEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/TubeGeneratorEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 79c4f01065705344ab89e0e3534c2e64
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using UnityEditor;

    [CustomEditor(typeof(TubeGenerator))]
    [CanEditMultipleObjects]
    public class TubeGeneratorEditor : MeshGenEditor
    {

        protected override void BodyGUI()
        {
            base.BodyGUI();
            TubeGenerator tubeGenerator = (TubeGenerator)target;
            serializedObject.Update();
            SerializedProperty sides = serializedObject.FindProperty("_sides");
            SerializedProperty capMode = serializedObject.FindProperty("_capMode");
            SerializedProperty revolve = serializedObject.FindProperty("_revolve");

            EditorGUI.BeginChangeCheck();
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Shape", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(sides, new GUIContent("Sides"));
            EditorGUILayout.PropertyField(capMode, new GUIContent("Cap"));
            EditorGUILayout.PropertyField(revolve, new GUIContent("Revolve"));
            if(capMode.intValue == (int)TubeGenerator.CapMethod.Round)
            {
                SerializedProperty latitude = serializedObject.FindProperty("_roundCapLatitude");
                EditorGUILayout.PropertyField(latitude, new GUIContent("Cap Latitude"));
            }
            if (sides.intValue < 3) sides.intValue = 3;
            if (EditorGUI.EndChangeCheck()) serializedObject.ApplyModifiedProperties();

            UVControls(tubeGenerator);
            SerializedProperty uvTwist = serializedObject.FindProperty("_uvTwist");
            EditorGUILayout.PropertyField(uvTwist, new GUIContent("UV Twist"));
            if (capMode.intValue != 0)
            {
                SerializedProperty capUVScale = serializedObject.FindProperty("_capUVScale");
                EditorGUILayout.PropertyField(capUVScale, new GUIContent("Cap UV Scale"));
            }
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/TubeGeneratorEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/WaveformGeneratorEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 988e0370e4dbf5a4e82a4b537aaf96e4
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using UnityEditor;

    [CustomEditor(typeof(WaveformGenerator), true)]
    [CanEditMultipleObjects]
    public class WaveGeneratorEditor : MeshGenEditor
    {
        protected override void BodyGUI()
        {
            showSize = false;
            showRotation = false;
            base.BodyGUI();
            WaveformGenerator user = (WaveformGenerator)target;

            serializedObject.Update();
            SerializedProperty axis = serializedObject.FindProperty("_axis");
            SerializedProperty slices = serializedObject.FindProperty("_slices");
            SerializedProperty symmetry = serializedObject.FindProperty("_symmetry");
            SerializedProperty uvWrapMode = serializedObject.FindProperty("_uvWrapMode");
            SerializedProperty uvOffset = serializedObject.FindProperty("_uvOffset");
            SerializedProperty uvScale = serializedObject.FindProperty("_uvScale");

            EditorGUI.BeginChangeCheck();
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Axis", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(axis, new GUIContent("Axis"));

            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Shape", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(slices, new GUIContent("Slices"));
            if (slices.intValue < 1) slices.intValue = 1;

            EditorGUILayout.PropertyField(symmetry, new GUIContent("Use Symmetry"));
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Uv Coordinates", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(uvWrapMode, new GUIContent("Wrap Mode"));
            EditorGUILayout.PropertyField(uvOffset, new GUIContent("UV Offset"));
            EditorGUILayout.PropertyField(uvScale, new GUIContent("UV Scale"));
            if (EditorGUI.EndChangeCheck())
            {
                serializedObject.ApplyModifiedProperties();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Components/WaveformGeneratorEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/ComputerSplitModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 95c0ed13476debc49bb9365a20fb7c9e
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using System.Collections.Generic;
    using UnityEditor;

    public class ComputerSplitModule : ComputerEditorModule
    {

        public ComputerSplitModule(SplineComputer spline) : base(spline)
        {

        }

        public override GUIContent GetIconOff()
        {
            return IconContent("Split", "split", "Split Spline");
        }

        public override GUIContent GetIconOn()
        {
            return IconContent("Split", "split_on", "Split Spline");
        }

        protected override void OnDrawScene()
        {
            bool change = false;
            Camera editorCamera = SceneView.currentDrawingSceneView.camera;

            for (int i = 0; i < spline.pointCount; i++)
            {
                Vector3 pos = spline.GetPointPosition(i);
                if (SplineEditorHandles.CircleButton(pos, Quaternion.LookRotation(editorCamera.transform.position - pos), HandleUtility.GetHandleSize(pos) * 0.12f, 1f, spline.editorPathColor))
                {
                    SplitAtPoint(i);
                    change = true;
                    break;
                }
            }
            SplineSample projected  = spline.Evaluate(ProjectMouse());
            if (!change)
            {
                float pointValue = (float)projected.percent * (spline.pointCount - 1);
                int pointIndex = Mathf.FloorToInt(pointValue);
                    float size = HandleUtility.GetHandleSize(projected.position) * 0.3f;
                    Vector3 up = Vector3.Cross(editorCamera.transform.forward, projected.forward).normalized * size + projected.position;
                    Vector3 down = Vector3.Cross(projected.forward, editorCamera.transform.forward).normalized * size + projected.position;
                    Handles.color = spline.editorPathColor;
                    Handles.DrawLine(up, down);
                    Handles.color = Color.white;
                if (pointValue - pointIndex > spline.moveStep) { 
                    if (SplineEditorHandles.CircleButton(projected.position, Quaternion.LookRotation(editorCamera.transform.position - projected.position), HandleUtility.GetHandleSize(projected.position) * 0.12f, 1f, spline.editorPathColor))
                    {
                        SplitAtPercent(projected.percent);
                        change = true;
                    }
                }
                SceneView.RepaintAll();
            }
            Handles.color = Color.white;
            DSSplineDrawer.DrawSplineComputer(spline, 0.0, projected.percent, 1f);
            DSSplineDrawer.DrawSplineComputer(spline, projected.percent, 1.0, 0.4f);
        }
        
        
        void HandleNodes(SplineComputer newSpline, int splitIndex)
        {
            List<Node> nodes = new List<Node>();
            List<int> indices = new List<int>();

            for (int i = splitIndex; i < spline.pointCount; i++)
            {
                Node node = spline.GetNode(i);
                if(node != null)
                {
                    nodes.Add(node);
                    indices.Add(i);
                    spline.DisconnectNode(i);
                    i--;
                }
            }
            for (int i = 0; i < nodes.Count; i++) newSpline.ConnectNode(nodes[i], indices[i] - splitIndex);
        }

       void SplitAtPercent(double percent)
       {
            RecordUndo("Split Spline");
            float pointValue = (spline.pointCount - 1) * (float)percent;
            int lastPointIndex = Mathf.FloorToInt(pointValue);
            int nextPointIndex = Mathf.CeilToInt(pointValue);
            SplinePoint[] splitPoints = new SplinePoint[spline.pointCount - lastPointIndex];
            float lerpPercent = Mathf.InverseLerp(lastPointIndex, nextPointIndex, pointValue);
            SplinePoint splitPoint = SplinePoint.Lerp(spline.GetPoint(lastPointIndex), spline.GetPoint(nextPointIndex), lerpPercent);
            splitPoint.SetPosition(spline.EvaluatePosition(percent));
            splitPoints[0] = splitPoint;
            for (int i = 1; i < splitPoints.Length; i++) splitPoints[i] = spline.GetPoint(lastPointIndex + i);
            SplineComputer newSpline = CreateNewSpline();
            newSpline.SetPoints(splitPoints);

            HandleNodes(newSpline, lastPointIndex);

            SplineUser[] users = newSpline.GetSubscribers();
            for (int i = 0; i < users.Length; i++)
            {
                users[i].clipFrom = DMath.InverseLerp(percent, 1.0, users[i].clipFrom);
                users[i].clipTo = DMath.InverseLerp(percent, 1.0, users[i].clipTo);
            }
            splitPoints = new SplinePoint[lastPointIndex + 2];
            for (int i = 0; i <= lastPointIndex; i++) splitPoints[i] = spline.GetPoint(i);
            splitPoints[splitPoints.Length - 1] = splitPoint;
            spline.SetPoints(splitPoints);
            users = spline.GetSubscribers();
            for (int i = 0; i < users.Length; i++)
            {
                users[i].clipFrom = DMath.InverseLerp(0.0, percent, users[i].clipFrom);
                users[i].clipTo = DMath.InverseLerp(0.0, percent, users[i].clipTo);
            }
        }

        void SplitAtPoint(int index)
        {
            RecordUndo("Split Spline");
            SplinePoint[] splitPoints = new SplinePoint[spline.pointCount - index];
            for(int i = 0; i < splitPoints.Length; i++) splitPoints[i] = spline.GetPoint(index + i);
            SplineComputer newSpline = CreateNewSpline();
            newSpline.SetPoints(splitPoints);

            HandleNodes(newSpline, index);

            SplineUser[] users = newSpline.GetSubscribers();
            for (int i = 0; i < users.Length; i++)
            {
                users[i].clipFrom = DMath.InverseLerp((double)index / (spline.pointCount - 1), 1.0, users[i].clipFrom);
                users[i].clipTo = DMath.InverseLerp((double)index / (spline.pointCount - 1), 1.0, users[i].clipTo);
            }
            splitPoints = new SplinePoint[index + 1];
            for (int i = 0; i <= index; i++) splitPoints[i] = spline.GetPoint(i);
            spline.SetPoints(splitPoints);
            users = spline.GetSubscribers();
            for (int i = 0; i < users.Length; i++)
            {
                users[i].clipFrom = DMath.InverseLerp(0.0, ((double)index) / (spline.pointCount - 1), users[i].clipFrom);
                users[i].clipTo = DMath.InverseLerp(0.0, ((double)index) / (spline.pointCount - 1), users[i].clipTo);
            }

        }

        SplineComputer CreateNewSpline()
        {
            GameObject go = Object.Instantiate(spline.gameObject);
            Undo.RegisterCreatedObjectUndo(go, "New Spline");
            go.name = spline.name + "_split";
            SplineUser[] users = go.GetComponents<SplineUser>();
            SplineComputer newSpline = go.GetComponent<SplineComputer>();
            for (int i = 0; i < users.Length; i++)
            {
                spline.Unsubscribe(users[i]);
                users[i].spline = newSpline;
                newSpline.Subscribe(users[i]);
            }
            for(int i = go.transform.childCount-1; i>=0; i--)
            {
                Undo.DestroyObjectImmediate(go.transform.GetChild(i).gameObject);
            }
            return newSpline;
        }

        private double ProjectMouse()
        {
            if (spline.pointCount == 0) return 0.0;
            float closestDistance = (Event.current.mousePosition - HandleUtility.WorldToGUIPoint(spline.GetPointPosition(0))).sqrMagnitude;
            double closestPercent = 0.0;
            double add = spline.moveStep;
            if (spline.type == Spline.Type.Linear) add /= 2.0;
            int count = 0;
            for (double i = add; i < 1.0; i += add)
            {
                SplineSample result = spline.Evaluate(i);
                Vector2 point = HandleUtility.WorldToGUIPoint(result.position);
                float dist = (point - Event.current.mousePosition).sqrMagnitude;
                if (dist < closestDistance)
                {
                    closestDistance = dist;
                    closestPercent = i;
                }
                count++;
            }
            return closestPercent;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/ComputerSplitModule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/DSSplineDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 9779e890dd6cb8b4d9de13ddc05cb546
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEditor;
    using UnityEngine;
    using UnityEditor.SceneManagement;

    [InitializeOnLoad]
    public static class DSSplineDrawer
    {
        private static bool refreshComputers = false;
        private static List<SplineComputer> drawComputers = new List<SplineComputer>();
        private static Vector3[] positions = new Vector3[0];
        private static UnityEngine.SceneManagement.Scene currentScene;

        static DSSplineDrawer()
        {
#if UNITY_2019_1_OR_NEWER
            SceneView.duringSceneGui += AutoDrawComputers;
#else
            SceneView.onSceneGUIDelegate += AutoDrawComputers;
#endif

            FindComputers();
            EditorApplication.hierarchyChanged += HerarchyWindowChanged;
            EditorApplication.playModeStateChanged += ModeChanged;
        }


        static void ModeChanged(PlayModeStateChange stateChange)
        {
            refreshComputers = true;
        }

        private static void HerarchyWindowChanged()
        {
        if (currentScene != EditorSceneManager.GetActiveScene())
            {
                currentScene = EditorSceneManager.GetActiveScene();
                FindComputers();
            }
            
        }

        private static void FindComputers()
        {
            drawComputers.Clear();
            SplineComputer[] computers = GameObject.FindObjectsOfType<SplineComputer>();
            drawComputers.AddRange(computers);
        }

        private static void AutoDrawComputers(SceneView current)
        {
            if (refreshComputers)
            {
                refreshComputers = false;
                FindComputers();
            }
            for (int i = 0; i < drawComputers.Count; i++)
            {
                if (!drawComputers[i].editorAlwaysDraw)
                {
                    drawComputers.RemoveAt(i);
                    i--;
                    continue;
                }
                DrawSplineComputer(drawComputers[i]);
            }
        }

        public static void RegisterComputer(SplineComputer comp)
        {
            if (drawComputers.Contains(comp)) return;
            comp.editorAlwaysDraw = true;
            drawComputers.Add(comp);
        }

        public static void UnregisterComputer(SplineComputer comp)
        {
            for(int i = 0; i < drawComputers.Count; i++)
            {
                if(drawComputers[i] == comp)
                {
                    drawComputers[i].editorAlwaysDraw = false;
                    drawComputers.RemoveAt(i);
                    return;
                }
            }
        }

        public static void DrawSplineComputer(SplineComputer comp, double fromPercent = 0.0, double toPercent = 1.0, float alpha = 1f)
        {
            if (comp == null) return;
            if (comp.pointCount < 2) return;
            if (Event.current.type != EventType.Repaint) return;
            Color prevColor = Handles.color;
            Color handleColor = comp.editorPathColor;
            handleColor.a = alpha;
            Handles.color = handleColor;

            if (comp.type == Spline.Type.BSpline && comp.pointCount > 1)
            {
                SplinePoint[] compPoints = comp.GetPoints();
                Handles.color = new Color(handleColor.r, handleColor.g, handleColor.b, 0.5f * alpha);
                for (int i = 0; i < compPoints.Length - 1; i++)
                {
                    Handles.DrawLine(compPoints[i].position, compPoints[i + 1].position);
                }
                Handles.color = handleColor;
            }

            if (!comp.editorDrawThickness)
            {
                if (positions.Length != comp.sampleCount * 2)
                {
                    positions = new Vector3[comp.sampleCount * 2];
                }
                Vector3 prevPoint = comp.EvaluatePosition(fromPercent);
                int pointIndex = 0;
                for (int i = 1; i < comp.sampleCount; i++)
                {
                    positions[pointIndex] = prevPoint;
                    pointIndex++;
                    positions[pointIndex] = comp[i].position;
                    pointIndex++;
                    prevPoint = positions[pointIndex - 1];
                }
                Handles.DrawLines(positions);
            }
            else
            {
                Transform editorCamera = SceneView.currentDrawingSceneView.camera.transform;
                if (positions.Length != comp.sampleCount * 6) positions = new Vector3[comp.sampleCount * 6];
                SplineSample prevResult = comp.Evaluate(fromPercent);
                Vector3 prevNormal = prevResult.up;
                if (comp.editorBillboardThickness) prevNormal = (editorCamera.position - prevResult.position).normalized;
                Vector3 prevRight = Vector3.Cross(prevResult.forward, prevNormal).normalized * prevResult.size * 0.5f;
                int pointIndex = 0;
                for (int i = 1; i < comp.sampleCount; i++)
                {
                    Vector3 newNormal = comp[i].up;
                    if (comp.editorBillboardThickness) newNormal = (editorCamera.position - comp[i].position).normalized;
                    Vector3 newRight = Vector3.Cross(comp[i].forward, newNormal).normalized * comp[i].size * 0.5f;

                    positions[pointIndex] = prevResult.position + prevRight;
                    positions[pointIndex + comp.sampleCount * 2] = prevResult.position - prevRight;
                    positions[pointIndex + comp.sampleCount * 4] = comp[i].position - newRight;
                    pointIndex++;
                    positions[pointIndex] = comp[i].position + newRight;
                    positions[pointIndex + comp.sampleCount * 2] = comp[i].position - newRight;
                    positions[pointIndex + comp.sampleCount * 4] = comp[i].position + newRight;
                    pointIndex++;
                    prevResult = comp[i];
                    prevRight = newRight;
                    prevNormal = newNormal;
                }
                Handles.DrawLines(positions);
            }
            Handles.color = prevColor;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/DSSplineDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Primitives/CapsuleEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 72fdbe7a4c526e048b71f939e9c0c73c
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
using UnityEngine;
using System.Collections;
using UnityEditor;
using Dreamteck.Splines.Editor;

namespace Dreamteck.Splines.Primitives
{
    public class CapsuleEditor : PrimitiveEditor
    {
        public override string GetName()
        {
            return "Capsule";
        }

        public override void Open(DreamteckSplinesEditor editor)
        {
            base.Open(editor);
            primitive = new Capsule();
        }

        protected override void OnGUI()
        {
            base.OnGUI();
            Capsule capsule = (Capsule)primitive;
            capsule.radius = EditorGUILayout.FloatField("Radius", capsule.radius);
            capsule.height = EditorGUILayout.FloatField("Height", capsule.height);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Primitives/CapsuleEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Primitives/EllipseEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: dbd2c446b47926347b9b126f60e16ad8
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
using UnityEngine;
using System.Collections;
using UnityEditor;
using Dreamteck.Splines.Editor;

namespace Dreamteck.Splines.Primitives
{
    public class EllipseEditor : PrimitiveEditor
    {
        

        public override string GetName()
        {
            return "Ellipse";
        }

        public override void Open(DreamteckSplinesEditor editor)
        {
            base.Open(editor);
            primitive = new Ellipse();
            primitive.offset = origin;
        }

        protected override void OnGUI()
        {
            base.OnGUI();
            Ellipse ellipse = (Ellipse)primitive;
            ellipse.xRadius = EditorGUILayout.FloatField("X Radius", ellipse.xRadius);
            ellipse.yRadius = EditorGUILayout.FloatField("Y Radius", ellipse.yRadius);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Primitives/EllipseEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Primitives/LineEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: db46236a6c24a02458ab53f69e482d9b
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
using UnityEngine;
using System.Collections;
using UnityEditor;
using Dreamteck.Splines.Editor;

namespace Dreamteck.Splines.Primitives
{
    public class LineEditor : PrimitiveEditor
    {
        public override string GetName()
        {
            return "Line";
        }

        public override void Open(DreamteckSplinesEditor editor)
        {
            base.Open(editor);
            primitive = new Line();
        }

        protected override void OnGUI()
        {
            base.OnGUI();
            Line line = (Line)primitive;
            line.length = EditorGUILayout.FloatField("Length", line.length);
            line.mirror = EditorGUILayout.Toggle("Mirror", line.mirror);
            line.rotation = EditorGUILayout.Vector3Field("Rotation", line.rotation);
            line.segments = EditorGUILayout.IntField("Segments", line.segments);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Primitives/LineEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Primitives/NgonEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 77c0bc8ac03c5ef49b19f61d6b0d5e63
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
using UnityEngine;
using System.Collections;
using UnityEditor;
using Dreamteck.Splines.Editor;

namespace Dreamteck.Splines.Primitives
{
    public class NgonEditor : PrimitiveEditor
    {
        public override string GetName()
        {
            return "Ngon";
        }

        public override void Open(DreamteckSplinesEditor editor)
        {
            base.Open(editor);
            primitive = new Ngon();
        }

        protected override void OnGUI()
        {
            base.OnGUI();
            Ngon ngon = (Ngon)primitive;
            ngon.radius = EditorGUILayout.FloatField("Radius", ngon.radius);
            ngon.sides = EditorGUILayout.IntField("Sides", ngon.sides);
            if (ngon.sides < 3) ngon.sides = 3;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Primitives/NgonEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Primitives/PrimitiveEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c64bf70078577534a9a2e5015c93459a
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Primitives
{
    using UnityEngine;
    using UnityEditor;
    using System.Collections;
    using Dreamteck.Splines.Editor;

    [System.Serializable]
    public class PrimitiveEditor
    {
        [System.NonSerialized]
        protected DreamteckSplinesEditor editor;
        [System.NonSerialized]
        public Vector3 origin = Vector3.zero;

        protected SplinePrimitive primitive = new SplinePrimitive();

        public virtual string GetName()
        {
            return "Primitive";
        }

        public virtual void Open(DreamteckSplinesEditor editor)
        {
            this.editor = editor;
            primitive.is2D = editor.is2D;
            primitive.Calculate();
        }

        public void Draw()
        {
            EditorGUI.BeginChangeCheck();
            OnGUI();
            if (EditorGUI.EndChangeCheck())
            {
                Update();
            }
        }

        public void Update()
        {
            primitive.is2D = editor.is2D;
            primitive.Calculate();
            editor.SetPointsArray(primitive.GetPoints());
            editor.SetSplineType(primitive.GetSplineType());
            editor.SetSplineClosed(primitive.GetIsClosed());
            editor.ApplyModifiedProperties(true);
        }

        protected virtual void OnGUI()
        {
            primitive.is2D = editor.is2D;
            primitive.offset = EditorGUILayout.Vector3Field("Offset", primitive.offset);
            if (editor.is2D)
            {
                float rot = primitive.rotation.z;
                rot = EditorGUILayout.FloatField("Rotation", rot);
                primitive.rotation = new Vector3(0f, 0f, rot);
            }
             else primitive.rotation = EditorGUILayout.Vector3Field("Rotation", primitive.rotation);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Primitives/PrimitiveEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Primitives/RectangleEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 0f93155830fd1d14d889c002374573e8
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
using UnityEngine;
using System.Collections;
using UnityEditor;
using Dreamteck.Splines.Editor;

namespace Dreamteck.Splines.Primitives
{
    public class RectangleEditor : PrimitiveEditor
    {
        public override string GetName()
        {
            return "Rectangle";
        }

        public override void Open(DreamteckSplinesEditor editor)
        {
            base.Open(editor);
            primitive = new Rectangle();
            primitive.offset = origin;
        }

        protected override void OnGUI()
        {
            base.OnGUI();
            Rectangle rect = (Rectangle)primitive;
            rect.size = EditorGUILayout.Vector2Field("Size", rect.size);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Primitives/RectangleEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Primitives/RoundedRectangleEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 81b24eca83abc154581a3830334d1e26
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
using UnityEngine;
using System.Collections;
using UnityEditor;
using Dreamteck.Splines.Editor;

namespace Dreamteck.Splines.Primitives
{
    public class RoundedRectangleEditor : PrimitiveEditor
    {
        public override string GetName()
        {
            return "Rounded Rect";
        }

        public override void Open(DreamteckSplinesEditor editor)
        {
            base.Open(editor);
            primitive = new RoundedRectangle();
            primitive.offset = origin;
        }

        protected override void OnGUI()
        {
            base.OnGUI();
            RoundedRectangle rect = (RoundedRectangle)primitive;
            rect.size = EditorGUILayout.Vector2Field("Size", rect.size);
            rect.xRadius = EditorGUILayout.FloatField("X Radius", rect.xRadius);
            rect.yRadius = EditorGUILayout.FloatField("Y Radius", rect.yRadius);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Primitives/RoundedRectangleEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Primitives/SpiralEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 2c5f355b780664e408027fdc7ce5a8d4
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
using UnityEngine;
using System.Collections;
using UnityEditor;
using Dreamteck.Splines.Editor;

namespace Dreamteck.Splines.Primitives
{
    public class SpiralEditor : PrimitiveEditor
    {

        public override string GetName()
        {
            return "Spiral";
        }

        public override void Open(DreamteckSplinesEditor editor)
        {
            base.Open(editor);
            primitive = new Spiral();
        }

        protected override void OnGUI()
        {
            base.OnGUI();
            Spiral spiral = (Spiral)primitive;
            spiral.clockwise = EditorGUILayout.Toggle("Clockwise", spiral.clockwise);
            spiral.curve = EditorGUILayout.CurveField("Radius Interpolation", spiral.curve);
            spiral.startRadius = EditorGUILayout.FloatField("Start Radius", spiral.startRadius);
            spiral.endRadius = EditorGUILayout.FloatField("End Radius", spiral.endRadius);
            spiral.stretch = EditorGUILayout.FloatField("Stretch", spiral.stretch);
            spiral.iterations = EditorGUILayout.IntField("Iterations", spiral.iterations);
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Primitives/SpiralEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Primitives/StarEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 4bb5e3d650b12b84a977fe5b175067b2
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
using UnityEngine;
using System.Collections;
using UnityEditor;
using Dreamteck.Splines.Editor;

namespace Dreamteck.Splines.Primitives
{
    public class StarEditor : PrimitiveEditor
    {
        public override string GetName()
        {
            return "Star";
        }

        public override void Open(DreamteckSplinesEditor editor)
        {
            base.Open(editor);
            primitive = new Star();
        }

        protected override void OnGUI()
        {
            base.OnGUI();
            Star star = (Star)primitive;
            star.radius = EditorGUILayout.FloatField("Radius", star.radius);
            star.depth = EditorGUILayout.FloatField("Depth", star.depth);
            star.sides = EditorGUILayout.IntField("Sides", star.sides);
            if (star.sides < 3) star.sides = 3;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Primitives/StarEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Sample Modifiers/ColorModifierEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e4533e035e560d64aaa86e06610a58ed
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    using UnityEditor;

    public class ColorModifierEditor : SplineSampleModifierEditor
    {
        private float addTime = 0f;

        public ColorModifierEditor(SplineUser user, SplineUserEditor editor) : base(user, editor, "_colorModifier")
        {
            title = "Color Modifiers";
        }

        public void ClearSelection()
        {
            selected = -1;
        }

        public override void DrawInspector()
        {
            base.DrawInspector();
            if (!isOpen) return;
            if (GUILayout.Button("Add New Color"))
            {
                AddKey(addTime - 0.1f, addTime + 0.1f);
                UpdateValues();
            }
        }

        protected override void KeyGUI(SerializedProperty key)
        {
            SerializedProperty color = key.FindPropertyRelative("color");
            SerializedProperty blendMode = key.FindPropertyRelative("blendMode");
            base.KeyGUI(key);
            EditorGUILayout.PropertyField(color);
            EditorGUILayout.PropertyField(blendMode);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Sample Modifiers/ColorModifierEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Sample Modifiers/FollowerSpeedModifierEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: ffa7555a9d798574584a7e90f0fdebf2
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    using UnityEditor;

    public class FollowerSpeedModifierEditor : SplineSampleModifierEditor
    {
        public bool allowSelection = true;
        private float addTime = 0f;

        public FollowerSpeedModifierEditor(SplineUser user, SplineUserEditor editor) : base(user, editor, "_speedModifier")
        {
            title = "Speed Modifiers";
        }

        public void ClearSelection()
        {
            selected = -1;
        }

        public override void DrawInspector()
        {
            base.DrawInspector();
            if (!isOpen) return;
            if (GUILayout.Button("Add Speed Region"))
            {
                AddKey(addTime - 0.1f, addTime + 0.1f);
                UpdateValues();
            }
        }

        protected override void KeyGUI(SerializedProperty key)
        {
            SerializedProperty speed = key.FindPropertyRelative("speed");
            SerializedProperty mode = key.FindPropertyRelative("mode");
            base.KeyGUI(key);
            EditorGUILayout.PropertyField(mode);
            string text = (mode.intValue == (int)FollowerSpeedModifier.SpeedKey.Mode.Add ? "Add" : "Multiply") + " Speed";
            EditorGUILayout.PropertyField(speed, new GUIContent(text));
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Sample Modifiers/FollowerSpeedModifierEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Sample Modifiers/MeshScaleModifierEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 5d48815d31d0e5549be897862f9353bc
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    using UnityEditor;

    public class MeshScaleModifierEditor : SplineSampleModifierEditor
    {
        public bool allowSelection = true;
        private float addTime = 0f;

        public MeshScaleModifierEditor(MeshGenerator user, SplineUserEditor editor, int channelIndex) : base(user, editor, "_channels/["+channelIndex+"]/_scaleModifier")
        {
            title = "Scale Modifiers";
        }

        public void ClearSelection()
        {
            selected = -1;
        }

        public override void DrawInspector()
        {
            base.DrawInspector();
            if (!isOpen) return;
            if (GUILayout.Button("Add New Scale"))
            {
                var key = AddKey(addTime - 0.1f, addTime + 0.1f);
                key.FindPropertyRelative("scale").vector3Value = Vector3.one;
                UpdateValues();
            }
        }

        protected override void KeyGUI(SerializedProperty key)
        {
            SerializedProperty scale = key.FindPropertyRelative("scale");
            base.KeyGUI(key);
            EditorGUILayout.PropertyField(scale);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Sample Modifiers/MeshScaleModifierEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Sample Modifiers/OffsetModifierEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: eaf21c57b8cb8f548984f66d80cfe07d
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    using UnityEditor;

    public class OffsetModifierEditor : SplineSampleModifierEditor
    {
        public bool allowSelection = true;
        private float addTime = 0f;
        Matrix4x4 matrix = new Matrix4x4();

        public OffsetModifierEditor(SplineUser user, SplineUserEditor editor) : base(user, editor, "_offsetModifier")
        {
            title = "Offset Modifiers";
        }

        public void ClearSelection()
        {
            selected = -1;
        }

        public override void DrawInspector()
        {
            base.DrawInspector();
            if (!isOpen) return;
            if (GUILayout.Button("Add New Offset"))
            {
                AddKey(addTime - 0.1f, addTime + 0.1f);
                UpdateValues();
            }
        }

        protected override void KeyGUI(SerializedProperty key)
        {
            SerializedProperty offset = key.FindPropertyRelative("offset");
            base.KeyGUI(key);
            EditorGUILayout.PropertyField(offset);
        }

        protected override bool KeyHandles(SerializedProperty key, bool edit)
        {
            if (!isOpen) return false;
            bool changed = false;
            bool is2D = user.spline != null && user.spline.is2D;
            SplineSample result = new SplineSample();
            SerializedProperty start = key.FindPropertyRelative("_featherStart");
            SerializedProperty end = key.FindPropertyRelative("_featherEnd");
            SerializedProperty centerStart = key.FindPropertyRelative("_centerStart");
            SerializedProperty centerEnd = key.FindPropertyRelative("_centerEnd");
            SerializedProperty offset = key.FindPropertyRelative("offset");

            float position = GetPosition(start.floatValue, end.floatValue, centerStart.floatValue, centerEnd.floatValue);

            user.spline.Evaluate(position, ref result);
            matrix.SetTRS(result.position, Quaternion.LookRotation(result.forward, result.up), Vector3.one * result.size);
            Vector3 pos = matrix.MultiplyPoint(offset.vector2Value);
            if (is2D)
            {
                Handles.DrawLine(result.position, result.position + result.right * offset.vector2Value.x * result.size);
                Handles.DrawLine(result.position, result.position - result.right * offset.vector2Value.x * result.size);
            }
            else Handles.DrawWireDisc(result.position, result.forward, offset.vector2Value.magnitude * result.size);
            Handles.DrawLine(result.position, pos);

            if (edit)
            {
                Vector3 lastPos = pos;
                pos = SplineEditorHandles.FreeMoveRectangle(pos, HandleUtility.GetHandleSize(pos) * 0.1f);
                if (pos != lastPos)
                {
                    MainPointModule.HoldInteraction();
                    changed = true;
                    pos = matrix.inverse.MultiplyPoint(pos);
                    pos.z = 0f;
                    if (is2D)
                    {
                        offset.vector2Value = Vector2.right * pos.x;
                    }
                    else
                    {
                        offset.vector2Value = pos;
                    }
                }
            }

            return base.KeyHandles(key, edit) || changed;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Sample Modifiers/OffsetModifierEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Sample Modifiers/RotationModifierEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 610b2b9894ff02a4abf2f483a19aeccc
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEditor;

    public class RotationModifierEditor : SplineSampleModifierEditor
    {
        public bool allowSelection = true;
        private float addTime = 0f;

        public RotationModifierEditor(SplineUser user, SplineUserEditor parent) : base(user, parent, "_rotationModifier")
        {
            title = "Rotation Modifiers";
        }

        public void ClearSelection()
        {
            selected = -1;
        }

        public override void DrawInspector()
        {
            base.DrawInspector();
            if (!isOpen) return;
            if (GUILayout.Button("Add New Rotation"))
            {
                AddKey(addTime - 0.1f, addTime + 0.1f);
                UpdateValues();
            }
        }

        protected override void KeyGUI(SerializedProperty key)
        {
            SerializedProperty rotation = key.FindPropertyRelative("rotation");
            SerializedProperty target = key.FindPropertyRelative("target");
            SerializedProperty useLookTarget = key.FindPropertyRelative("useLookTarget");
            base.KeyGUI(key);
            if (!useLookTarget.boolValue)
            {
                EditorGUILayout.PropertyField(rotation);
            }
            EditorGUILayout.PropertyField(useLookTarget);
            if (useLookTarget.boolValue)
            {
                EditorGUILayout.PropertyField(target);
            }
        }

        protected override bool KeyHandles(SerializedProperty key, bool edit)
        {
            if (!isOpen) return false;
            bool changed = false;
            SerializedProperty start = key.FindPropertyRelative("_featherStart");
            SerializedProperty end = key.FindPropertyRelative("_featherEnd");
            SerializedProperty centerStart = key.FindPropertyRelative("_centerStart");
            SerializedProperty centerEnd = key.FindPropertyRelative("_centerEnd");
            SerializedProperty rotation = key.FindPropertyRelative("rotation");
            SerializedProperty target = key.FindPropertyRelative("target");
            SerializedProperty useLookTarget = key.FindPropertyRelative("useLookTarget");
            float position = GetPosition(start.floatValue, end.floatValue, centerStart.floatValue, centerEnd.floatValue);
            SplineSample result = new SplineSample();
            user.spline.Evaluate(position, ref result);
            if (useLookTarget.boolValue)
            {
                if (target.objectReferenceValue != null)
                {
                    Transform targetTransform = ((Transform)target.objectReferenceValue);
                    Handles.DrawDottedLine(result.position, targetTransform.position, 5f);
                    if (edit)
                    {
                        Vector3 lastPos = targetTransform.position;
                        targetTransform.position = Handles.PositionHandle(targetTransform.position, Quaternion.identity);
                        if (lastPos != targetTransform.position)
                        {
                            MainPointModule.HoldInteraction();
                            EditorUtility.SetDirty(targetTransform);
                            changed = true;
                        }
                    }
                }
            }
            else
            {
                Quaternion directionRot = Quaternion.LookRotation(result.forward, result.up);
                Quaternion rot = directionRot * Quaternion.Euler(rotation.vector3Value);
                SplineEditorHandles.DrawArrowCap(result.position, rot, HandleUtility.GetHandleSize(result.position));

                if (edit)
                {
                    Vector3 lastEuler = rot.eulerAngles;
                    rot = Handles.RotationHandle(rot, result.position);
                    rot = Quaternion.Inverse(directionRot) * rot;
                    rotation.vector3Value = rot.eulerAngles;
                    if (rot.eulerAngles != lastEuler)
                    {
                        MainPointModule.HoldInteraction();
                        changed = true;
                    }
                }
            }
            return base.KeyHandles(key, edit) || changed;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Sample Modifiers/RotationModifierEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Sample Modifiers/SizeModifierEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: dbfe0843022c91745a4144f758c78367
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    using UnityEditor;

    public class SizeModifierEditor : SplineSampleModifierEditor
    {
        public bool allowSelection = true;
        private float addTime = 0f;

        public SizeModifierEditor(SplineUser user, SplineUserEditor editor) : base(user, editor, "_sizeModifier")
        {
            title = "Size Modifiers";
        }

        public void ClearSelection()
        {
            selected = -1;
        }

        public override void DrawInspector()
        {
            base.DrawInspector();
            if (!isOpen) return;
            if (GUILayout.Button("Add New Size"))
            {
                AddKey(addTime - 0.1f, addTime + 0.1f);
                UpdateValues();
            }
        }

        protected override void KeyGUI(SerializedProperty key)
        {
            SerializedProperty size = key.FindPropertyRelative("size");
            base.KeyGUI(key);
            EditorGUILayout.PropertyField(size);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Sample Modifiers/SizeModifierEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Sample Modifiers/SplineSampleModifierEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1cc10f0a74040154da18f19ce3fe2ccc
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using UnityEditor;

    public class SplineSampleModifierEditor : SplineUserSubEditor
    {
        protected int selected = -1;
        protected bool drawAllKeys = false;
        protected virtual SerializedProperty _keysProperty => _keys;
        protected SerializedProperty _keys;
        protected SerializedProperty _blend;
        protected SerializedProperty _useClipped;
        protected SerializedProperty _modifier;
        protected virtual string _keysPropertyName => "keys";
        private int _deleteElement = -1;

        protected SerializedObject _serializedObject;

        public SplineSampleModifierEditor(SplineUser user, SplineUserEditor editor, string modifierPropertyPath = "") : base(user, editor)
        {
            title = "Sample Modifier";
            _serializedObject = new SerializedObject(user);
            string[] propertyPath = modifierPropertyPath.Split('/');
            var property = _serializedObject.FindProperty(propertyPath[0]);
            for (int i = 1; i < propertyPath.Length; i++)
            {
                if(propertyPath[i].StartsWith("[") && propertyPath[i].EndsWith("]"))
                {
                    var num = propertyPath[i].Substring(1, propertyPath[i].Length - 2);
                    property = property.GetArrayElementAtIndex(int.Parse(num));
                    continue;
                }
                property = property.FindPropertyRelative(propertyPath[i]);
            }
            _modifier = property;
            _keys = _modifier.FindPropertyRelative(_keysPropertyName);
            _blend = _modifier.FindPropertyRelative("blend");
            _useClipped = _modifier.FindPropertyRelative("useClippedPercent");
        }

        public override void DrawInspector()
        {
            base.DrawInspector();
            if (!isOpen) return;
            if (_keysProperty.arraySize > 0)
            {
                drawAllKeys = EditorGUILayout.Toggle("Draw all Modules", drawAllKeys);
            }
            _serializedObject.Update();

            EditorGUI.BeginChangeCheck();
            for (int i = 0; i < _keysProperty.arraySize; i++)
            {
                EditorGUILayout.BeginVertical(EditorStyles.helpBox);
                SerializedProperty keyProperty = _keysProperty.GetArrayElementAtIndex(i);
                if (selected == i)
                {
                    EditorGUI.BeginChangeCheck();
                    KeyGUI(keyProperty);
                    if (EditorGUI.EndChangeCheck()) user.Rebuild();
                }
                else
                {
                    SerializedProperty start = keyProperty.FindPropertyRelative("_featherStart");
                    SerializedProperty end = keyProperty.FindPropertyRelative("_featherEnd");
                    EditorGUILayout.LabelField(i + " [" + (Mathf.Round(start.floatValue * 10) / 10f) + " - " + (Mathf.Round(end.floatValue * 10) / 10f) + "]");
                }
                EditorGUILayout.EndVertical();
                Rect lastRect = GUILayoutUtility.GetLastRect();
                if (lastRect.Contains(Event.current.mousePosition))
                {
                    if(Event.current.type == EventType.MouseDown)
                    {
                        if(Event.current.button == 0)
                        {
                            selected = i;
                            editor.Repaint();
                        } else if (Event.current.button == 1)
                        {
                            int index = i;
                            GenericMenu menu = new GenericMenu();
                            menu.AddItem(new GUIContent("Delete"), false, delegate
                            {
                                _deleteElement = index;
                            });
                            menu.ShowAsContext();
                            UpdateValues();
                            _serializedObject.Update();
                        }
                    }
                }
            }

            EditorGUILayout.Space();
            if (_keysProperty.arraySize > 0)
            {
                EditorGUILayout.PropertyField(_blend);
                EditorGUILayout.PropertyField(_useClipped, new GUIContent("Use Clipped Percents", "Whether the percentages relate to the clip range of the user or not."));
            }

            if(_deleteElement >= 0)
            {
                _keysProperty.DeleteArrayElementAtIndex(_deleteElement);
                _deleteElement = -1;
                UpdateValues();
            } else
            {
                if (EditorGUI.EndChangeCheck())
                {
                    UpdateValues();
                }
            }
        }

        public override void DrawScene()
        {
            base.DrawScene();
            _serializedObject.Update();
            bool changed = false;
            for (int i = 0; i < _keysProperty.arraySize; i++)
            {
                if (selected == i || drawAllKeys)
                {
                    if(KeyHandles(_keysProperty.GetArrayElementAtIndex(i), selected == i))
                    {
                        changed = true;
                    }
                }
            }

            if (changed)
            {
                UpdateValues();
            }
        }

        protected void UpdateValues()
        {
            if (_serializedObject != null)
            {
                _serializedObject.ApplyModifiedProperties();
            }
            user.Rebuild();
            editor.Repaint();
        }

        protected virtual SerializedProperty AddKey(float f, float t)
        {
            _keys.InsertArrayElementAtIndex(_keys.arraySize);
            var key = _keys.GetArrayElementAtIndex(_keys.arraySize - 1);
            SerializedProperty start = key.FindPropertyRelative("_featherStart");
            SerializedProperty end = key.FindPropertyRelative("_featherEnd");
            SerializedProperty centerStart = key.FindPropertyRelative("_centerStart");
            SerializedProperty centerEnd = key.FindPropertyRelative("_centerEnd");
            SerializedProperty blend = key.FindPropertyRelative("blend");
            SerializedProperty interpolation = key.FindPropertyRelative("interpolation");

            start.floatValue = Mathf.Clamp01(f);
            end.floatValue = Mathf.Clamp01(t);
            blend.floatValue = 1f;
            interpolation.animationCurveValue = AnimationCurve.Linear(0f, 0f, 1f, 1f);
            centerStart.floatValue = 0.1f;
            centerEnd.floatValue = 0.9f;
            return key;
        }

        protected virtual void KeyGUI(SerializedProperty keyProperty)
        {
            SerializedProperty start = keyProperty.FindPropertyRelative("_featherStart");
            SerializedProperty end = keyProperty.FindPropertyRelative("_featherEnd");
            SerializedProperty centerStart = keyProperty.FindPropertyRelative("_centerStart");
            SerializedProperty centerEnd = keyProperty.FindPropertyRelative("_centerEnd");
            SerializedProperty interpolation = keyProperty.FindPropertyRelative("interpolation");
            SerializedProperty blend = keyProperty.FindPropertyRelative("blend");

            EditorGUILayout.BeginHorizontal();
            EditorGUIUtility.labelWidth = 50f;
            start.floatValue = EditorGUILayout.Slider("Start", start.floatValue, 0f, 1f);
            end.floatValue = EditorGUILayout.Slider("End", end.floatValue, 0f, 1f);
            EditorGUILayout.EndHorizontal();
            EditorGUIUtility.labelWidth = 0f;
            float cs = centerStart.floatValue;
            float ce = centerEnd.floatValue;
            EditorGUILayout.MinMaxSlider("Center", ref cs, ref ce, 0f, 1f);
            centerStart.floatValue = cs;
            centerEnd.floatValue = ce;
            EditorGUILayout.PropertyField(interpolation);
            EditorGUILayout.PropertyField(blend);
        }

        protected static float GlobalToLocalPercent(float start, float end, float t)
        {
            if (start > end)
            {
                if (t > start) return Mathf.InverseLerp(start, start + (1f - start) + end, t);
                else if (t < end) return Mathf.InverseLerp(-(1f - start), end, t);
                else return 0f;
            }
            return Mathf.InverseLerp(start, end, t);
        }

        protected static float LocalToGlobalPercent(float start, float end, float t)
        {
            if (start > end)
            {
                t = Mathf.Lerp(start, start + (1f - start) + end, t);
                if (t > 1f)
                {
                    t -= Mathf.Floor(t);
                }
                return t;
            }
            return Mathf.Lerp(start, end, t);
        }

        protected static float GetPosition(float start, float end, float centerStart, float centerEnd)
        {
            float center = Mathf.Lerp(centerStart, centerEnd, 0.5f);
            if (start > end)
            {
                float fromToEndDistance = 1f - start;
                float centerDistance = center * (fromToEndDistance + end);
                float pos = start + centerDistance;
                if (pos > 1f)
                {
                    pos -= Mathf.Floor(pos);
                }
                return pos;
            }
            
            return Mathf.Lerp(start, end, center);
        }

        protected virtual bool KeyHandles(SerializedProperty key, bool edit)
        {
            if (!isOpen) return false;
            bool useClip = _useClipped.boolValue;

            SerializedProperty start = key.FindPropertyRelative("_featherStart");
            SerializedProperty end = key.FindPropertyRelative("_featherEnd");
            SerializedProperty centerStart = key.FindPropertyRelative("_centerStart");
            SerializedProperty centerEnd = key.FindPropertyRelative("_centerEnd");

            bool changed = false;
            double value = start.floatValue;

            if (useClip)
            {
                user.UnclipPercent(ref value);
            }
            SplineComputerEditorHandles.Slider(user.spline, ref value, user.spline.editorPathColor, "Start", SplineComputerEditorHandles.SplineSliderGizmo.ForwardTriangle, 0.8f);
            if (useClip)
            {
                user.ClipPercent(ref value);
            }

            if (start.floatValue != value)
            {
                MainPointModule.HoldInteraction();
                start.floatValue = (float)value;
                changed = true;
            }

            value = LocalToGlobalPercent(start.floatValue, end.floatValue, centerStart.floatValue);
            if (useClip)
            {
                user.UnclipPercent(ref value);
            }
            SplineComputerEditorHandles.Slider(user.spline, ref value, user.spline.editorPathColor, "", SplineComputerEditorHandles.SplineSliderGizmo.Rectangle, 0.6f);
            if (useClip)
            {
                user.ClipPercent(ref value);
            }

            if (LocalToGlobalPercent(start.floatValue, end.floatValue, centerStart.floatValue) != value)
            {
                MainPointModule.HoldInteraction();
                centerStart.floatValue = GlobalToLocalPercent(start.floatValue, end.floatValue, (float)value);
                changed = true;
            }

            value = LocalToGlobalPercent(start.floatValue, end.floatValue, centerEnd.floatValue);
            if (useClip)
            {
                user.UnclipPercent(ref value);
            }
            

            SplineComputerEditorHandles.Slider(user.spline, ref value, user.spline.editorPathColor, "", SplineComputerEditorHandles.SplineSliderGizmo.Rectangle, 0.6f);
            if (useClip)
            {
                user.ClipPercent(ref value);
            }
            if (LocalToGlobalPercent(start.floatValue, end.floatValue, centerEnd.floatValue) != value)
            {
                MainPointModule.HoldInteraction();
                centerEnd.floatValue = GlobalToLocalPercent(start.floatValue, end.floatValue, (float)value);
                changed = true;
            }


            value = end.floatValue;
            if (useClip)
            {
                user.UnclipPercent(ref value);
            }

            SplineComputerEditorHandles.Slider(user.spline, ref value, user.spline.editorPathColor, "End", SplineComputerEditorHandles.SplineSliderGizmo.BackwardTriangle, 0.8f);
            if (useClip)
            {
                user.ClipPercent(ref value);
            }
            if (end.floatValue != value)
            {
                MainPointModule.HoldInteraction();
                end.floatValue = (float)value;
                changed = true;
            }


            if (Event.current.control)
            {
                value = GetPosition(start.floatValue, end.floatValue, centerStart.floatValue, centerEnd.floatValue);
                double lastValue = value;
                if (useClip)
                {
                    user.UnclipPercent(ref value);
                }
                SplineComputerEditorHandles.Slider(user.spline, ref value, user.spline.editorPathColor, "", SplineComputerEditorHandles.SplineSliderGizmo.Circle, 0.4f);
                
                if (useClip)
                {
                    user.ClipPercent(ref value);
                }

                if (value != lastValue)
                {
                    MainPointModule.HoldInteraction();
                    double delta = value - lastValue;
                    start.floatValue += (float)delta;
                    end.floatValue += (float)delta;
                    start.floatValue = Mathf.Clamp01(start.floatValue);
                    end.floatValue = Mathf.Clamp(end.floatValue, start.floatValue, 1f);
                    changed = true;
                }
            }

            return changed;
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Sample Modifiers/SplineSampleModifierEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SerializedSplinePoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 452dc39a29a38bc4bb9d028f6bf626c6
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEditor;
    using UnityEngine;

    public struct SerializedSplinePoint
    {
        public bool changed;

        public SplinePoint.Type type
        {
            get
            {
                return (SplinePoint.Type)_type.enumValueIndex;
            }
            set
            {
                if (value != type)
                {
                    _type.enumValueIndex = (int)value;
                    changed = true;
                }
            }
        }

        public Vector3 position
        {
            get { return _position.vector3Value; }
            set
            {
                if (value != position)
                {
                    _position.vector3Value = value;
                    changed = true;
                }
            }
        }

        public Vector3 tangent
        {
            get { return _tangent.vector3Value; }
            set
            {
                if (value != tangent)
                {
                    _tangent.vector3Value = value;
                    changed = true;
                }
            }
        }
        public Vector3 tangent2
        {
            get { return _tangent2.vector3Value; }
            set
            {
                if (value != tangent2)
                {
                    _tangent2.vector3Value = value;
                    changed = true;
                }
            }
        }

        public Color color
        {
            get { return _color.colorValue; }
            set
            {
                if (value != color)
                {
                    _color.colorValue = value;
                    changed = true;
                }
            }
        }

        public Vector3 normal
        {
            get { return _normal.vector3Value; }
            set
            {
                if (value != normal)
                {
                    _normal.vector3Value = value;
                    changed = true;
                }
            }
        }
        public float size
        {
            get { return _size.floatValue; }
            set
            {
                if (value != size)
                {
                    _size.floatValue = value;
                    changed = true;
                }
            }
        }


        private SerializedProperty _point;
        private SerializedProperty _position;
        private SerializedProperty _tangent;
        private SerializedProperty _tangent2;
        private SerializedProperty _normal;
        private SerializedProperty _size;
        private SerializedProperty _color;
        private SerializedProperty _type;


        public SerializedSplinePoint(SerializedProperty input)
        {
            _point = input;
            _position = _point.FindPropertyRelative("position");
            _tangent = _point.FindPropertyRelative("tangent");
            _tangent2 = _point.FindPropertyRelative("tangent2");
            _normal = _point.FindPropertyRelative("normal");
            _size = _point.FindPropertyRelative("size");
            _color = _point.FindPropertyRelative("color");
            _type = _point.FindPropertyRelative("_type");
            changed = false;
        }

        public void SetPoint(SplinePoint point)
        {
            CheckForChange(point);
            position = point.position;
            tangent = point.tangent;
            tangent2 = point.tangent2;
            normal = point.normal;
            size = point.size;
            color = point.color;
            type = point.type;
        }

        private void CheckForChange(SplinePoint point)
        {
            if (position != point.position)
            {
                changed = true;
                return;
            }

            if (tangent != point.tangent)
            {
                changed = true;
                return;
            }

            if (tangent2 != point.tangent2)
            {
                changed = true;
                return;
            }

            if (normal != point.normal)
            {
                changed = true;
                return;
            }

            if (size != point.size)
            {
                changed = true;
                return;
            }

            if (color != point.color)
            {
                changed = true;
                return;
            }

            if (type != point.type)
            {
                changed = true;
                return;
            }
        }

        public void CopyFrom(SerializedSplinePoint point)
        {
            position = point.position;
            tangent = point.tangent;
            tangent2 = point.tangent2;
            normal = point.normal;
            size = point.size;
            color = point.color;
            type = point.type;
        }

        public SplinePoint CreateSplinePoint()
        {
            SplinePoint point = new SplinePoint();
            point.type = type;
            point.position = position;
            point.tangent = tangent;
            point.tangent2 = tangent2;
            point.normal = normal;
            point.size = size;
            point.color = color;
            point.isDirty = changed;
            return point;
        }

        public void SetPosition(Vector3 pos)
        {
            tangent -= position - pos;
            tangent2 -= position - pos;
            position = pos;
        }

        public void SetTangentPosition(Vector3 pos)
        {
            tangent = pos;
            switch ((SplinePoint.Type)_type.enumValueIndex)
            {
                case SplinePoint.Type.SmoothMirrored: SmoothMirrorTangent2(); break;
                case SplinePoint.Type.SmoothFree: SmoothFreeTangent2(); break;
            }
        }

        public void SetTangent2Position(Vector3 pos)
        {
            tangent2 = pos;
            switch ((SplinePoint.Type)_type.enumValueIndex)
            {
                case SplinePoint.Type.SmoothMirrored: SmoothMirrorTangent(); break;
                case SplinePoint.Type.SmoothFree: SmoothFreeTangent(); break;
            }
        }

        private void SmoothMirrorTangent2()
        {
            tangent2 = position + (position - tangent);
        }

        private void SmoothMirrorTangent()
        {
            tangent = position + (position - tangent2);
        }

        private void SmoothFreeTangent2()
        {
            tangent2 = position + (position - tangent).normalized * (tangent2 - position).magnitude;
        }

        private void SmoothFreeTangent()
        {
            tangent = position + (position - tangent2).normalized * (tangent - position).magnitude;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SerializedSplinePoint.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineComputerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 445c3a8207a79a54bbdb6eeb52cb2492
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections.Generic;
    using UnityEditor;

    [CustomEditor(typeof(SplineComputer), true)]
    [CanEditMultipleObjects]
    public partial class SplineComputerEditor : Editor 
    {
        public SplineComputer spline;
        public SplineComputer[] splines = new SplineComputer[0];
        public static bool hold = false;

        public int[] pointSelection
        {
            get
            {
                return _selectedPoints.ToArray();
            }
        }

        public int selectedPointsCount
        {
            get { return _selectedPoints.Count; }
            set { }
        }

        protected bool closedOnMirror = false;

        private DreamteckSplinesEditor _pathEditor;
        private ComputerEditor _computerEditor;
        private SplineTriggersEditor _triggersEditor;
        private SplineComputerDebugEditor _debugEditor;
        private bool _rebuildSpline = false;
        private List<int> _selectedPoints = new List<int>();


        [MenuItem("GameObject/3D Object/Spline Computer")]
        private static void NewEmptySpline()
        {
            int count = GameObject.FindObjectsOfType<SplineComputer>().Length;
            string objName = "Spline";
            if (count > 0) objName += " " + count;
            GameObject obj = new GameObject(objName);
            obj.AddComponent<SplineComputer>();
            if (Selection.activeGameObject != null)
            {
                if (EditorUtility.DisplayDialog("Make child?", "Do you want to make the new spline a child of " + Selection.activeGameObject.name + "?", "Yes", "No"))
                {
                    obj.transform.parent = Selection.activeGameObject.transform;
                    obj.transform.localPosition = Vector3.zero;
                    obj.transform.localRotation = Quaternion.identity;
                }
            }
            Selection.activeGameObject = obj;
        }

        [MenuItem("GameObject/3D Object/Spline Node")]
        private static void NewSplineNode()
        {
            int count = Object.FindObjectsOfType<Node>().Length;
            string objName = "Node";
            if (count > 0) objName += " " + count;
            GameObject obj = new GameObject(objName);
            obj.AddComponent<Node>();
            if(Selection.activeGameObject != null)
            {
                if(EditorUtility.DisplayDialog("Make child?", "Do you want to make the new node a child of " + Selection.activeGameObject.name + "?", "Yes", "No"))
                {
                    obj.transform.parent = Selection.activeGameObject.transform;
                    obj.transform.localPosition = Vector3.zero;
                    obj.transform.localRotation = Quaternion.identity;
                }
            }
            Selection.activeGameObject = obj;
        }

        public void UndoRedoPerformed()
        {
            _pathEditor.UndoRedoPerformed();
            spline.EditorUpdateConnectedNodes();
            spline.Rebuild();
        }

        private void OnEnable()
        {
            splines = new SplineComputer[targets.Length];
            for (int i = 0; i < splines.Length; i++)
            {
                splines[i] = (SplineComputer)targets[i];
                splines[i].EditorAwake();
                if (splines[i].editorAlwaysDraw)
                {
                    DSSplineDrawer.RegisterComputer(splines[i]);
                }
            }
            spline = splines[0];
            InitializeSplineEditor();
            InitializeComputerEditor();
            _debugEditor = new SplineComputerDebugEditor(spline, serializedObject, _pathEditor);
            _debugEditor.undoHandler += RecordUndo;
            _debugEditor.repaintHandler += OnRepaint;
            _triggersEditor = new SplineTriggersEditor(spline, serializedObject);
            _triggersEditor.undoHandler += RecordUndo;
            _triggersEditor.repaintHandler += OnRepaint;
            hold = false;
#if UNITY_2019_1_OR_NEWER
            SceneView.beforeSceneGui += BeforeSceneGUI;
            SceneView.duringSceneGui += DuringSceneGUI;
#else
            SceneView.onSceneGUIDelegate += BeforeSceneGUI;
            SceneView.onSceneGUIDelegate += DuringSceneGUI;
#endif
            Undo.undoRedoPerformed += UndoRedoPerformed;
        }

        private void BeforeSceneGUI(SceneView current)
        {
            _pathEditor.BeforeSceneGUI(current);

            if (Event.current.type == EventType.MouseUp)
            {
                if (Event.current.button == 0)
                {
                    for (int i = 0; i < splines.Length; i++)
                    {
                        if (splines[i].editorUpdateMode == SplineComputer.EditorUpdateMode.OnMouseUp)
                        {
                            splines[i].RebuildImmediate();
                        }
                    }
                }
            }
        }

        private void InitializeSplineEditor()
        {
            _pathEditor = new DreamteckSplinesEditor(spline, serializedObject);
            _pathEditor.undoHandler = RecordUndo;
            _pathEditor.repaintHandler = OnRepaint;
            _pathEditor.editSpace = (SplineEditor.Space)SplinePrefs.pointEditSpace;
        }

        private void InitializeComputerEditor()
        {
            _computerEditor = new ComputerEditor(splines, serializedObject, _pathEditor);
            _computerEditor.undoHandler = RecordUndo;
            _computerEditor.repaintHandler = OnRepaint;
        }

        private void RecordUndo(string title)
        {
            for (int i = 0; i < splines.Length; i++)
            {
                Undo.RecordObject(splines[i], title);
            }
        }

        private void OnRepaint()
        {
            SceneView.RepaintAll();
            Repaint();
        }

        private void OnDisable()
        {
            Undo.undoRedoPerformed -= UndoRedoPerformed;
#if UNITY_2019_1_OR_NEWER
            SceneView.beforeSceneGui -= BeforeSceneGUI;
            SceneView.duringSceneGui -= DuringSceneGUI;
#else
            SceneView.onSceneGUIDelegate -= BeforeSceneGUI;
            SceneView.onSceneGUIDelegate -= DuringSceneGUI;
#endif
            _pathEditor.Destroy();
            _computerEditor.Destroy();
            _debugEditor.Destroy();
            _triggersEditor.Destroy();
        }

        public override void OnInspectorGUI()
        {
            if (_debugEditor.editorUpdateMode == SplineComputer.EditorUpdateMode.OnMouseUp)
            {
                if (Event.current.type == EventType.MouseUp && Event.current.button == 0)
                {
                    _rebuildSpline = true;
                }
                if (Event.current.type == EventType.KeyDown && (Event.current.keyCode == KeyCode.Return || Event.current.keyCode == KeyCode.KeypadEnter))
                {
                    _rebuildSpline = true;
                }
            }
            base.OnInspectorGUI();
            spline = (SplineComputer)target;

            if (splines.Length == 1)
            {
                SplineEditorGUI.BeginContainerBox(ref _pathEditor.open, "Edit");
                if (_pathEditor.open)
                {
                    SplineEditor.Space lastSpace = _pathEditor.editSpace;
                    _pathEditor.DrawInspector();
                    if (lastSpace != _pathEditor.editSpace)
                    {
                        SplinePrefs.pointEditSpace = (SplineComputer.Space)_pathEditor.editSpace;
                        SplinePrefs.SavePrefs();
                    }
                }
                else if (_pathEditor.lastEditorTool != Tool.None && Tools.current == Tool.None)
                {
                    Tools.current = _pathEditor.lastEditorTool;
                }
                SplineEditorGUI.EndContainerBox();
            }

            SplineEditorGUI.BeginContainerBox(ref _computerEditor.open, "Spline Computer");
            if (_computerEditor.open)
            {
                _computerEditor.DrawInspector();
            }
            SplineEditorGUI.EndContainerBox();

            if (splines.Length == 1)
            {
                SplineEditorGUI.BeginContainerBox(ref _triggersEditor.open, "Triggers");
                if (_triggersEditor.open) _triggersEditor.DrawInspector();
                SplineEditorGUI.EndContainerBox();
            }

            SplineEditorGUI.BeginContainerBox(ref _debugEditor.open, "Editor Properties");
            if (_debugEditor.open) _debugEditor.DrawInspector();
            SplineEditorGUI.EndContainerBox();

            if (GUI.changed)
            {
                EditorUtility.SetDirty(spline);
            }


            if (Event.current.type == EventType.Layout && _rebuildSpline)
            {
                for (int i = 0; i < splines.Length; i++)
                {
                    if (splines[i].editorUpdateMode == SplineComputer.EditorUpdateMode.OnMouseUp)
                    {
                        splines[i].RebuildImmediate(true);
                    }
                }
                _rebuildSpline = false;
            }

        }

        public bool IsPointSelected(int index)
        {
            return _selectedPoints.Contains(index);
        }

        private void DuringSceneGUI(SceneView currentSceneView)
        {
            _debugEditor.DrawScene(currentSceneView);
            _computerEditor.drawComputer = !(_pathEditor.currentModule is CreatePointModule);
            _computerEditor.drawPivot = _pathEditor.open && spline.editorDrawPivot;
            _computerEditor.DrawScene(currentSceneView);
            if (splines.Length == 1 && _triggersEditor.open) _triggersEditor.DrawScene(currentSceneView);
            if (splines.Length == 1 && _pathEditor.open) _pathEditor.DrawScene(currentSceneView);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineComputerEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineComputerEditorHandles.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d0de0d6d9db2dd642b027ea3270e660e
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using UnityEditor;

    public static class SplineComputerEditorHandles
    {
        private static SplineSample evalResult = new SplineSample();
        public enum SplineSliderGizmo { ForwardTriangle, BackwardTriangle, DualArrow, Rectangle, Circle }

        public static bool Slider(SplineComputer spline, ref double percent, Color color, string text = "", SplineSliderGizmo gizmo = SplineSliderGizmo.Rectangle, float buttonSize = 1f)
        {
            Camera cam = SceneView.currentDrawingSceneView.camera;
            spline.Evaluate(percent, ref evalResult);
            float size = HandleUtility.GetHandleSize(evalResult.position);

            Handles.color = new Color(color.r, color.g, color.b, 0.4f);
            Handles.DrawSolidDisc(evalResult.position, cam.transform.position - evalResult.position, size * 0.2f * buttonSize);
            Handles.color = Color.white;
            if ((color.r + color.g + color.b + color.a) / 4f >= 0.9f) Handles.color = Color.black;

            Vector3 center = evalResult.position;
            Vector2 screenPosition = HandleUtility.WorldToGUIPoint(center);
            screenPosition.y += 20f;
            Vector3 localPos = cam.transform.InverseTransformPoint(center);
            if (text != "" && localPos.z > 0f)
            {
                Handles.BeginGUI();
                DreamteckEditorGUI.Label(new Rect(screenPosition.x - 120 + text.Length * 4, screenPosition.y, 120, 25), text);
                Handles.EndGUI();
            }
            bool buttonClick = SplineEditorHandles.SliderButton(center, false, Color.white, 0.3f);
            Vector3 lookAtCamera = (cam.transform.position - evalResult.position).normalized;
            Vector3 right = Vector3.Cross(lookAtCamera, evalResult.forward).normalized * size * 0.1f * buttonSize;
            Vector3 front = Vector3.forward;
            switch (gizmo)
            {
                case SplineSliderGizmo.BackwardTriangle:
                    center += evalResult.forward * size * 0.06f * buttonSize;
                    front = center - evalResult.forward * size * 0.2f * buttonSize;
                    Handles.DrawLine(center + right, front);
                    Handles.DrawLine(front, center - right);
                    Handles.DrawLine(center - right, center + right);
                    break;

                case SplineSliderGizmo.ForwardTriangle:
                    center -= evalResult.forward * size * 0.06f * buttonSize;
                    front = center + evalResult.forward * size * 0.2f * buttonSize;
                    Handles.DrawLine(center + right, front);
                    Handles.DrawLine(front, center - right);
                    Handles.DrawLine(center - right, center + right);
                    break;

                case SplineSliderGizmo.DualArrow:
                    center += evalResult.forward * size * 0.025f * buttonSize;
                    front = center + evalResult.forward * size * 0.17f * buttonSize;
                    Handles.DrawLine(center + right, front);
                    Handles.DrawLine(front, center - right);
                    Handles.DrawLine(center - right, center + right);
                    center -= evalResult.forward * size * 0.05f * buttonSize;
                    front = center - evalResult.forward * size * 0.17f * buttonSize;
                    Handles.DrawLine(center + right, front);
                    Handles.DrawLine(front, center - right);
                    Handles.DrawLine(center - right, center + right);
                    break;
                case SplineSliderGizmo.Rectangle:

                    break;

                case SplineSliderGizmo.Circle:
                    Handles.DrawWireDisc(center, lookAtCamera, 0.13f * size * buttonSize);
                    break;
            }
            Vector3 lastPos = evalResult.position;
            Handles.color = Color.clear;
            var lookRotation = Quaternion.LookRotation(cam.transform.position - evalResult.position); 
            evalResult.position = SplineEditorHandles.FreeMoveHandle(evalResult.position, size * 0.2f * buttonSize, Vector3.zero, Handles.CircleHandleCap);
            if (evalResult.position != lastPos) percent = spline.Project(evalResult.position).percent;
            Handles.color = Color.white;
            return buttonClick;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineComputerEditorHandles.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: bb2a2a0ef9560854498c33329cd5bc53
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEditor;
    using UnityEngine;
    using UnityEditor.SceneManagement;

    [InitializeOnLoad]
    public static class SplineDrawer
    {
        private static Vector3[] positions = new Vector3[0];

        public static void DrawSpline(Spline spline, Color color, double from = 0.0, double to = 1.0, bool drawThickness = false, bool thicknessAutoRotate = false)
        {
            double add = spline.moveStep;
            if (add < 0.0025) add = 0.0025;
            Color prevColor = Handles.color;
            Handles.color = color;
            int iterations = spline.iterations;
            if (iterations <= 0) return;
            if (drawThickness)
            {
                Transform editorCamera = SceneView.currentDrawingSceneView.camera.transform;
                if (positions.Length != iterations * 6) positions = new Vector3[iterations * 6];
                SplineSample prevResult = spline.Evaluate(from);
                Vector3 prevNormal = prevResult.up;
                if (thicknessAutoRotate) prevNormal = (editorCamera.position - prevResult.position).normalized;
                Vector3 prevRight = Vector3.Cross(prevResult.forward, prevNormal).normalized * prevResult.size * 0.5f;
                int pointIndex = 0;
                for (int i = 1; i < iterations; i++)
                {
                    double p = DMath.Lerp(from, to, (double)i / (iterations - 1));
                    SplineSample newResult = spline.Evaluate(p);
                    Vector3 newNormal = newResult.up;
                    if (thicknessAutoRotate) newNormal = (editorCamera.position - newResult.position).normalized;
                    Vector3 newRight = Vector3.Cross(newResult.forward, newNormal).normalized * newResult.size * 0.5f;

                    positions[pointIndex] = prevResult.position + prevRight;
                    positions[pointIndex + iterations * 2] = prevResult.position - prevRight;
                    positions[pointIndex + iterations * 4] = newResult.position - newRight;
                    pointIndex++;
                    positions[pointIndex] = newResult.position + newRight;
                    positions[pointIndex + iterations * 2] = newResult.position - newRight;
                    positions[pointIndex + iterations * 4] = newResult.position + newRight;
                    pointIndex++;
                    prevResult = newResult;
                    prevRight = newRight;
                    prevNormal = newNormal;
                }
                Handles.DrawLines(positions);
            }
            else
            {
                if (positions.Length != iterations * 2) positions = new Vector3[iterations * 2];
                Vector3 prevPoint = spline.EvaluatePosition(from);
                int pointIndex = 0;
                for (int i = 1; i < iterations; i++)
                {
                    double p = DMath.Lerp(from, to, (double)i / (iterations - 1));
                    positions[pointIndex] = prevPoint;
                    pointIndex++;
                    positions[pointIndex] = spline.EvaluatePosition(p);
                    pointIndex++;
                    prevPoint = positions[pointIndex - 1];
                }
                Handles.DrawLines(positions);
            }
            Handles.color = prevColor;
        }

        public static void DrawPath(ref Vector3[] points)
        {
            Vector3[] linePoints = new Vector3[points.Length * 2];
            Vector3 prevPoint = points[0];
            int pointIndex = 0;
            for (int currObjectIndex = 1; currObjectIndex < points.Length; currObjectIndex++)
            {
                linePoints[pointIndex] = prevPoint;
                pointIndex++;
                linePoints[pointIndex] = points[currObjectIndex];
                pointIndex++;
                prevPoint = points[currObjectIndex];
            }
            Handles.DrawLines(linePoints);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineDrawer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/DS Editor/ComputerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e59af6b243fa55640b014783bedaaae3
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEditor;

    public class ComputerEditor : SplineEditorBase
    {
        public bool drawComputer = true;
        public bool drawPivot = true;
        public bool drawConnectedComputers = true;
        private DreamteckSplinesEditor _pathEditor;
        private int _operation = -1, _module = -1, _transformTool = 1;
        private ComputerEditorModule[] _modules = new ComputerEditorModule[0];
        private Dreamteck.Editor.Toolbar _utilityToolbar;
        private Dreamteck.Editor.Toolbar _operationsToolbar;
        private Dreamteck.Editor.Toolbar _transformToolbar;
        private SplineComputer _spline = null;
        private SplineComputer[] _splines = new SplineComputer[0];
        private bool _pathToolsFoldout = false, _interpolationFoldout = false;

        private SerializedProperty _splineProperty;
        private SerializedProperty _sampleRate;
        private SerializedProperty _type;
        private SerializedProperty _knotParametrization;
        private SerializedProperty _linearAverageDirection;
        private SerializedProperty _space;
        private SerializedProperty _sampleMode;
        private SerializedProperty _optimizeAngleThreshold;
        private SerializedProperty _updateMode;
        private SerializedProperty _multithreaded;
        private SerializedProperty _customNormalInterpolation;
        private SerializedProperty _customValueInterpolation;


        public ComputerEditor(SplineComputer[] splines, SerializedObject serializedObject, DreamteckSplinesEditor pathEditor) : base(serializedObject)
        {
            _spline = splines[0];
            this._splines = splines;
            this._pathEditor = pathEditor;

            _splineProperty = serializedObject.FindProperty("_spline");
            _sampleRate = serializedObject.FindProperty("_spline").FindPropertyRelative("sampleRate");
            _type = serializedObject.FindProperty("_spline").FindPropertyRelative("type");
            _linearAverageDirection = _splineProperty.FindPropertyRelative("linearAverageDirection");
            _space = serializedObject.FindProperty("_space");
            _sampleMode = serializedObject.FindProperty("_sampleMode");
            _optimizeAngleThreshold = serializedObject.FindProperty("_optimizeAngleThreshold");
            _updateMode = serializedObject.FindProperty("updateMode");
            _multithreaded = serializedObject.FindProperty("multithreaded");
            _customNormalInterpolation = _splineProperty.FindPropertyRelative("customNormalInterpolation");
            _customValueInterpolation = _splineProperty.FindPropertyRelative("customValueInterpolation");
            _knotParametrization = _splineProperty.FindPropertyRelative("_knotParametrization");


            _modules = new ComputerEditorModule[2];
            _modules[0] = new ComputerMergeModule(_spline);
            _modules[1] = new ComputerSplitModule(_spline);
            GUIContent[] utilityContents = new GUIContent[_modules.Length], utilityContentsSelected = new GUIContent[_modules.Length];
            for (int i = 0; i < _modules.Length; i++)
            {
                utilityContents[i] = _modules[i].GetIconOff();
                utilityContentsSelected[i] = _modules[i].GetIconOn();
                _modules[i].undoHandler += OnRecordUndo;
                _modules[i].repaintHandler += OnRepaint;
            }
            _utilityToolbar = new Dreamteck.Editor.Toolbar(utilityContents, utilityContentsSelected, 35f);
            _utilityToolbar.newLine = false;


            int index = 0;
            GUIContent[] transformContents = new GUIContent[4], transformContentsSelected = new GUIContent[4];
            transformContents[index] = new GUIContent("OFF");
            transformContentsSelected[index++] = new GUIContent("OFF");

            transformContents[index] = EditorGUIUtility.IconContent("MoveTool");
            transformContentsSelected[index++] = EditorGUIUtility.IconContent("MoveTool On");

            transformContents[index] = EditorGUIUtility.IconContent("RotateTool");
            transformContentsSelected[index++] = EditorGUIUtility.IconContent("RotateTool On");

            transformContents[index] = EditorGUIUtility.IconContent("ScaleTool");
            transformContentsSelected[index] = EditorGUIUtility.IconContent("ScaleTool On");

            _transformToolbar = new Dreamteck.Editor.Toolbar(transformContents, transformContentsSelected, 35f);
            _transformToolbar.newLine = false;

            index = 0;
            GUIContent[] operationContents = new GUIContent[3], operationContentsSelected = new GUIContent[3];
            for (int i = 0; i < operationContents.Length; i++)
            {
                operationContents[i] = new GUIContent("");
                operationContentsSelected[i] = new GUIContent("");
            }
            _operationsToolbar = new Dreamteck.Editor.Toolbar(operationContents, operationContentsSelected, 64f);
            _operationsToolbar.newLine = false;
        }

        void OnRecordUndo(string title)
        {
            if (undoHandler != null) undoHandler(title);
        }

        void OnRepaint()
        {
            if (repaintHandler != null) repaintHandler();
        }

        protected override void Load()
        {
            base.Load();
            _pathToolsFoldout = LoadBool("DreamteckSplinesEditor.pathToolsFoldout", false);
            _interpolationFoldout = LoadBool("DreamteckSplinesEditor.interpolationFoldout", false);
            _transformTool = LoadInt("DreamteckSplinesEditor.transformTool", 0);
        }

        protected override void Save()
        {
            base.Save();
            SaveBool("DreamteckSplinesEditor.pathToolsFoldout", _pathToolsFoldout);
            SaveBool("DreamteckSplinesEditor.interpolationFoldout", _interpolationFoldout);
            SaveInt("DreamteckSplinesEditor.transformTool", _transformTool);
        }

        public override void Destroy()
        {
            base.Destroy();
            for (int i = 0; i < _modules.Length; i++) _modules[i].Deselect();
        }

        public override void DrawInspector()
        {
            base.DrawInspector();
            if (_spline == null) return;
            SplineEditorGUI.SetHighlightColors(SplinePrefs.highlightColor, SplinePrefs.highlightContentColor);
            EditorGUILayout.BeginHorizontal();
            GUILayout.FlexibleSpace();
            EditorGUI.BeginChangeCheck();
            _operationsToolbar.SetContent(0, new GUIContent(_spline.isClosed ? "Break" : "Close"));
            _operationsToolbar.SetContent(1, new GUIContent("Reverse"));
            _operationsToolbar.SetContent(2, new GUIContent(_spline.is2D ? "3D Mode" : "2D Mode"));
            _operationsToolbar.Draw(ref _operation);
            if (EditorGUI.EndChangeCheck())
            {
                PerformOperation();
            }
            EditorGUI.BeginChangeCheck();
            if (_splines.Length == 1)
            {
                int mod = _module;
                _utilityToolbar.Draw(ref mod);
                if (EditorGUI.EndChangeCheck())
                {
                    ToggleModule(mod);
                }
            }
            GUILayout.FlexibleSpace();
            EditorGUILayout.EndHorizontal();
            if (_module >= 0 && _module < _modules.Length)
            {
                _modules[_module].DrawInspector();
            }
            EditorGUILayout.Space();
            DreamteckEditorGUI.DrawSeparator();

            EditorGUILayout.Space();

            EditorGUI.BeginChangeCheck();
            Spline.Type lastType = (Spline.Type)_type.intValue;
            EditorGUILayout.PropertyField(_type);
            if(lastType == Spline.Type.CatmullRom && _type.intValue == (int)Spline.Type.Bezier)
            {
                if(EditorUtility.DisplayDialog("Hermite to Bezier", "Would you like to retain the Catmull Rom shape in Bezier mode?", "Yes", "No"))
                {
                    for (int i = 0; i < _splines.Length; i++)
                    {
                        Undo.RecordObject(_splines[i], "CatToBezierTangents");
                        _splines[i].CatToBezierTangents();
                        EditorUtility.SetDirty(_splines[i]);
                    }
                    _pathEditor.SetPointsArray(_spline.GetPoints());
                    _pathEditor.ApplyModifiedProperties();
                }
            }

            if(_spline.type == Spline.Type.CatmullRom)
            {
                int type = Mathf.RoundToInt(_knotParametrization.floatValue * 2);
                string catmullTypeText = "Parametrization: ";
                switch (type)
                {
                    case 0: catmullTypeText += "Uniform"; break;
                    case 1: catmullTypeText += "Centripetal"; break;
                    case 2: catmullTypeText += "Chordal"; break;
                }
                EditorGUILayout.PropertyField(_knotParametrization, new GUIContent(catmullTypeText));
            }

            if (_spline.type == Spline.Type.Linear)
            {
                EditorGUILayout.PropertyField(_linearAverageDirection);
            }

            int lastSpace = _space.intValue;
            EditorGUILayout.Space();
            EditorGUILayout.PropertyField(_space, new GUIContent("Space"));
            if((SplineComputer.Space)_space.enumValueIndex == SplineComputer.Space.Local)
            {
                EditTransformToolbar();
                if (_splines.Length == 1)
                {
                    EditorGUILayout.Space();
                }
            }
            EditorGUILayout.PropertyField(_sampleMode, new GUIContent("Sample Mode"));
            if (_sampleMode.intValue == (int)SplineComputer.SampleMode.Optimized) EditorGUILayout.PropertyField(_optimizeAngleThreshold);
            EditorGUILayout.PropertyField(_updateMode);
            if (_updateMode.intValue == (int)SplineComputer.UpdateMode.None && Application.isPlaying)
            {
                if (GUILayout.Button("Rebuild"))
                {
                    for (int i = 0; i < _splines.Length; i++) _splines[i].RebuildImmediate(true, true);
                }
            }
            if (_spline.type != Spline.Type.Linear) EditorGUILayout.PropertyField(_sampleRate, new GUIContent("Sample Rate"));
            EditorGUILayout.PropertyField(_multithreaded);

            EditorGUI.indentLevel++;
            bool curveUpdate = false;
            _interpolationFoldout = EditorGUILayout.Foldout(_interpolationFoldout, "Point Value Interpolation");
            if (_interpolationFoldout)
            {
                if (_customValueInterpolation.animationCurveValue == null || _customValueInterpolation.animationCurveValue.keys.Length == 0)
                {
                    if (GUILayout.Button("Size & Color Interpolation"))
                    {
                        AnimationCurve curve = new AnimationCurve();
                        curve.AddKey(new Keyframe(0, 0, 0, 0));
                        curve.AddKey(new Keyframe(1, 1, 0, 0));
                        for (int i = 0; i < _splines.Length; i++) _splines[i].customValueInterpolation = curve;
                        _serializedObject.Update();
                        _pathEditor.GetPointsFromSpline();
                        curveUpdate = true;
                    }
                }
                else
                {
                    EditorGUILayout.BeginHorizontal();
                    EditorGUILayout.PropertyField(_customValueInterpolation, new GUIContent("Size & Color Interpolation"));
                    if (GUILayout.Button("x", GUILayout.MaxWidth(25)))
                    {
                        _customValueInterpolation.animationCurveValue = null;
                        for (int i = 0; i < _splines.Length; i++) _splines[i].customValueInterpolation = null;
                        _serializedObject.Update();
                        _pathEditor.GetPointsFromSpline();
                        curveUpdate = true;
                    }
                    EditorGUILayout.EndHorizontal();
                }
                if (_customNormalInterpolation.animationCurveValue == null || _customNormalInterpolation.animationCurveValue.keys.Length == 0)
                {
                    if (GUILayout.Button("Normal Interpolation"))
                    {
                        AnimationCurve curve = new AnimationCurve();
                        curve.AddKey(new Keyframe(0, 0));
                        curve.AddKey(new Keyframe(1, 1));
                        for (int i = 0; i < _splines.Length; i++) _splines[i].customNormalInterpolation = curve;
                        _serializedObject.Update();
                        _pathEditor.GetPointsFromSpline();
                        curveUpdate = true;
                    }
                }
                else
                {
                    EditorGUILayout.BeginHorizontal();
                    EditorGUILayout.PropertyField(_customNormalInterpolation, new GUIContent("Normal Interpolation"));
                    if (GUILayout.Button("x", GUILayout.MaxWidth(25)))
                    {
                        _customNormalInterpolation.animationCurveValue = null;
                        for (int i = 0; i < _splines.Length; i++) _splines[i].customNormalInterpolation = null;
                        _serializedObject.Update();
                        _pathEditor.GetPointsFromSpline();
                        curveUpdate = true;
                    }
                    EditorGUILayout.EndHorizontal();
                }
            }

            EditorGUI.indentLevel--;

            if (EditorGUI.EndChangeCheck() || curveUpdate)
            {
                if (_sampleRate.intValue < 2)
                {
                    _sampleRate.intValue = 2;
                }

                bool forceUpdateAll = false;
                if (lastSpace != _space.intValue)
                {
                    forceUpdateAll = true;
                }

                _pathEditor.ApplyModifiedProperties(true);

                for (int i = 1; i < _splines.Length; i++)
                {
                    _splines[i].RebuildImmediate(true, forceUpdateAll);
                }
            }

            if (_pathEditor.currentModule != null)
            {
                _transformTool = 0;
            }
        }

        private void EditTransformToolbar()
        {
            if(_splines.Length > 1)
            {
                GUILayout.Label("Edit Transform unavailable with multiple splines");
                return;
            }
            EditorGUILayout.BeginHorizontal();
            GUILayout.Label("Edit Transform - Only");
            GUILayout.FlexibleSpace();
            int lastTool = _transformTool;
            _transformToolbar.Draw(ref _transformTool);
            if (lastTool != _transformTool && _transformTool > 0)
            {
                _pathEditor.UntoggleCurrentModule();
                Tools.current = Tool.None;
            }
            EditorGUILayout.EndHorizontal();

            switch (_transformTool)
            {
                case 1:
                    Vector3 position = _spline.transform.position;

                    position = EditorGUILayout.Vector3Field("Position", position);
                    if (position != _spline.transform.position)
                    {
                        Undo.RecordObject(_spline.transform, "Move spline computer");
                        _spline.transform.position = position;
                        _pathEditor.ApplyModifiedProperties(true);
                    }
                    break;
                case 2:
                    Quaternion rotation = _spline.transform.rotation;
                    rotation = Quaternion.Euler(EditorGUILayout.Vector3Field("Rotation", rotation.eulerAngles));
                    if (rotation != _spline.transform.rotation)
                    {
                        Undo.RecordObject(_spline.transform, "Rotate spline computer");
                        _spline.transform.rotation = rotation;
                        _pathEditor.ApplyModifiedProperties(true);
                    }
                    break;
                case 3:
                    Vector3 scale = _spline.transform.localScale;
                    scale = EditorGUILayout.Vector3Field("Scale", scale);
                    if (scale != _spline.transform.localScale)
                    {
                        Undo.RecordObject(_spline.transform, "Scale spline computer");
                        _spline.transform.localScale = scale;
                        _pathEditor.ApplyModifiedProperties(true);
                    }
                    break;
            }
        }

        void PerformOperation()
        {
            switch (_operation)
            {
                case 0:
                    if (_spline.isClosed)
                    {
                        BreakSpline();
                    }
                    else
                    {
                        CloseSpline();
                    }
                    _operation = -1;
                    break;
                case 1:
                    ReversePointOrder();
                    _operation = -1;
                    break;
                case 2:
                    {
                        _pathEditor.is2D = !_pathEditor.is2D;

                        if (_pathEditor.is2D)
                        {
                            for (int i = 0; i < _pathEditor.points.Length; i++)
                            {
                                FlattenPoint(ref _pathEditor.points[i], LinearAlgebraUtility.Axis.Z);
                            }
                        }

                        _pathEditor.ApplyModifiedProperties();
                        _operation = -1;
                    }
                    break;
            }
        }

        private void FlattenPoint(ref SerializedSplinePoint point, LinearAlgebraUtility.Axis axis, float flatValue = 0f)
        {
            point.position = LinearAlgebraUtility.FlattenVector(point.position, axis, flatValue);
            point.tangent = LinearAlgebraUtility.FlattenVector(point.tangent, axis, flatValue);
            point.tangent2 = LinearAlgebraUtility.FlattenVector(point.tangent2, axis, flatValue);
            switch (axis)
            {
                case LinearAlgebraUtility.Axis.X: point.normal = Vector3.right; break;
                case LinearAlgebraUtility.Axis.Y: point.normal = Vector3.up; break;
                case LinearAlgebraUtility.Axis.Z: point.normal = Vector3.forward; break;
            }
        }

        void ToggleModule(int index)
        {
            if (_module >= 0 && _module < _modules.Length) _modules[_module].Deselect();
            if (_module == index) index = -1;
            _module = index;
            if (_module >= 0 && _module < _modules.Length) _modules[_module].Select();
        }

        public void BreakSpline()
        {
            RecordUndo("Break path");
            if (_splines.Length == 1 && _pathEditor.selectedPoints.Count == 1)
            {
                _spline.Break(_pathEditor.selectedPoints[0]);
                EditorUtility.SetDirty(_spline);
                _pathEditor.selectedPoints.Clear();
                _pathEditor.selectedPoints.Add(0);

            }
            else
            {
                for (int i = 0; i < _splines.Length; i++)
                {
                    _splines[i].Break();
                    EditorUtility.SetDirty(_splines[i]);
                }
            }
        }

        public void CloseSpline()
        {
            RecordUndo("Close path");
            for (int i = 0; i < _splines.Length; i++)
            {
                _splines[i].Close();
            }
        }

        void ReversePointOrder()
        {
            for (int i = 0; i < _splines.Length; i++)
            {
                ReversePointOrder(_splines[i]);
            }
        }

        void ReversePointOrder(SplineComputer spline)
        {
            SplinePoint[] points = spline.GetPoints();
            for (int i = 0; i < Mathf.FloorToInt(points.Length / 2); i++)
            {
                SplinePoint temp = points[i];
                points[i] = points[(points.Length - 1) - i];
                Vector3 tempTan = points[i].tangent;
                points[i].tangent = points[i].tangent2;
                points[i].tangent2 = tempTan;
                int opposideIndex = (points.Length - 1) - i;
                points[opposideIndex] = temp;
                tempTan = points[opposideIndex].tangent;
                points[opposideIndex].tangent = points[opposideIndex].tangent2;
                points[opposideIndex].tangent2 = tempTan;
            }
            if (points.Length % 2 != 0)
            {
                Vector3 tempTan = points[Mathf.CeilToInt(points.Length / 2)].tangent;
                points[Mathf.CeilToInt(points.Length / 2)].tangent = points[Mathf.CeilToInt(points.Length / 2)].tangent2;
                points[Mathf.CeilToInt(points.Length / 2)].tangent2 = tempTan;
            }
            spline.SetPoints(points);
        }

        public override void DrawScene(SceneView current)
        {
            base.DrawScene(current);

            if (_spline == null)
            {
                return;
            }

            for (int i = 0; i < _splines.Length; i++)
            {
                if (drawComputer)
                {
                    DSSplineDrawer.DrawSplineComputer(_splines[i]);
                }

                if (drawPivot)
                {
                    var trs = _splines[i].transform;
                    float size = HandleUtility.GetHandleSize(trs.position);
                    Handles.color = Color.red;
                    Handles.DrawLine(trs.position, trs.position + trs.right * size * 0.5f);
                    Handles.color = Color.green;
                    Handles.DrawLine(trs.position, trs.position + trs.up * size * 0.5f);
                    Handles.color = Color.blue;
                    Handles.DrawLine(trs.position, trs.position + trs.forward * size * 0.5f);
                }
            }

            if (drawConnectedComputers)
            {
                for (int i = 0; i < _splines.Length; i++)
                {
                    List<SplineComputer> computers = _splines[i].GetConnectedComputers();
                    for (int j = 1; j < computers.Count; j++)
                    {
                        DSSplineDrawer.DrawSplineComputer(computers[j], 0.0, 1.0, 0.5f);
                    }
                }
            }


            if (_pathEditor.currentModule == null)
            {
                if(_splines.Length > 1 || Tools.current != Tool.None)
                {
                    _transformTool = 0;
                }
                switch (_transformTool)
                {
                    case 1:
                        Vector3 position = _spline.transform.position;
                        position = Handles.PositionHandle(position, _spline.transform.rotation);
                        if (position != _spline.transform.position)
                        {
                            Undo.RecordObject(_spline.transform, "Move spline computer");
                            _spline.transform.position = position;
                            _pathEditor.ApplyModifiedProperties(true);
                        }
                        break;
                    case 2:
                        Quaternion rotation = _spline.transform.rotation;
                        rotation = Handles.RotationHandle(rotation, _spline.transform.position);
                        if (rotation != _spline.transform.rotation)
                        {
                            Undo.RecordObject(_spline.transform, "Rotate spline computer");
                            _spline.transform.rotation = rotation;
                            _pathEditor.ApplyModifiedProperties(true);
                        }
                        break;
                    case 3:
                        Vector3 scale = _spline.transform.localScale;
                        scale = Handles.ScaleHandle(scale, _spline.transform.position, _spline.transform.rotation,
                            HandleUtility.GetHandleSize(_spline.transform.position));
                        if (scale != _spline.transform.localScale)
                        {
                            Undo.RecordObject(_spline.transform, "Scale spline computer");
                            _spline.transform.localScale = scale;
                            _pathEditor.ApplyModifiedProperties(true);
                        }
                        break;
                }
                if (_transformTool > 0)
                {
                    Vector2 screenPosition = HandleUtility.WorldToGUIPoint(_spline.transform.position);
                    screenPosition.y += 20f;
                    Handles.BeginGUI();
                    DreamteckEditorGUI.Label(new Rect(screenPosition.x - 120 + _spline.name.Length * 4, screenPosition.y, 120, 25), _spline.name);
                    Handles.EndGUI();
                }
            }
            if (_module >= 0 && _module < _modules.Length) _modules[_module].DrawScene();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/DS Editor/ComputerEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/DS Editor/ComputerEditorModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 17f0469145b8d194f8e96c0e083d5b72
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEditor;

    public class ComputerEditorModule : EditorModule
    {
        protected SplineComputer spline;
        public SplineEditorBase.UndoHandler undoHandler;
        public EmptySplineHandler repaintHandler;

        public ComputerEditorModule(SplineComputer spline)
        {
            this.spline = spline;
        }

        protected override void RecordUndo(string title)
        {
            base.RecordUndo(title);
            if (undoHandler != null) undoHandler(title);
        }

        protected override void Repaint()
        {
            base.Repaint();
            if (repaintHandler != null) repaintHandler();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/DS Editor/ComputerEditorModule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/DS Editor/ComputerMergeModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 50db3c9801774b24cbb81bdf47a3f852
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using System.Collections.Generic;
    using UnityEditor;

    public class ComputerMergeModule : ComputerEditorModule
    {
        SplineComputer[] availableMergeComputers = new SplineComputer[0];
        public enum MergeSide { Start, End }
        public MergeSide mergeSide = MergeSide.End;
        public bool mergeEndpoints = false;

        public ComputerMergeModule(SplineComputer spline) : base(spline)
        {

        }

        public override GUIContent GetIconOff()
        {
            return IconContent("Merge", "merge", "Merge Splines");
        }

        public override GUIContent GetIconOn()
        {
            return IconContent("Merge", "merge_on", "Merge Splines");
        }

        public override void LoadState()
        {
            mergeEndpoints = LoadBool("mergeEndpoints");
            mergeSide = (MergeSide)LoadInt("mergeSide");
        }

        public override void SaveState()
        {
            SaveBool("mergeEndpoints", mergeEndpoints);
            SaveInt("mergeSide", (int)mergeSide);
        }

        public override void Select()
        {
            base.Select();
            FindAvailableComputers();
        }

        private void FindAvailableComputers()
        {
            SplineComputer[] found = Object.FindObjectsOfType<SplineComputer>();
            List<SplineComputer> available = new List<SplineComputer>();
            for (int i = 0; i < found.Length; i++)
            {
                if (found[i] != spline && !found[i].isClosed && spline.pointCount >= 2) available.Add(found[i]);
            }
            availableMergeComputers = available.ToArray();
        }

        protected override void OnDrawScene()
        {
            base.OnDrawScene();
            if (spline.isClosed) return;
            Camera editorCamera = SceneView.currentDrawingSceneView.camera;
            for (int i = 0; i < availableMergeComputers.Length; i++)
            {
                DSSplineDrawer.DrawSplineComputer(availableMergeComputers[i]);
                SplinePoint startPoint = availableMergeComputers[i].GetPoint(0);
                SplinePoint endPoint = availableMergeComputers[i].GetPoint(availableMergeComputers[i].pointCount - 1);
                Handles.color = availableMergeComputers[i].editorPathColor;

                if (SplineEditorHandles.CircleButton(startPoint.position, Quaternion.LookRotation(editorCamera.transform.position - startPoint.position), HandleUtility.GetHandleSize(startPoint.position) * 0.15f, 1f, availableMergeComputers[i].editorPathColor))
                {
                    Merge(i, MergeSide.Start);
                    break;
                }
                if (SplineEditorHandles.CircleButton(endPoint.position, Quaternion.LookRotation(editorCamera.transform.position - endPoint.position), HandleUtility.GetHandleSize(endPoint.position) * 0.15f, 1f, availableMergeComputers[i].editorPathColor))
                {
                    Merge(i, MergeSide.End);
                    break;
                }
            }
            Handles.color = Color.white;
        }

        protected override void OnDrawInspector()
        {
            base.OnDrawInspector();
            if (spline.isClosed)
            {
                EditorGUILayout.LabelField("Closed splines cannot be merged with others.", EditorStyles.centeredGreyMiniLabel);
                return;
            }
            mergeSide = (MergeSide)EditorGUILayout.EnumPopup("Merge:", mergeSide);
            mergeEndpoints = EditorGUILayout.Toggle("Merge Endpoints", mergeEndpoints);
        }

        private void Merge(int index, MergeSide mergingSide)
        {
            RegisterChange();
            SplineComputer mergedSpline = availableMergeComputers[index];
            SplinePoint[] mergedPoints = mergedSpline.GetPoints();
            SplinePoint[] original = spline.GetPoints();
            List<SplinePoint> pointsList = new List<SplinePoint>();
            SplinePoint[] points;
            if (!mergeEndpoints) points = new SplinePoint[mergedPoints.Length + original.Length];
            else points = new SplinePoint[mergedPoints.Length + original.Length - 1];

            if(mergeSide == MergeSide.End)
            {
                if(mergingSide == MergeSide.Start)
                {
                    for (int i = 0; i < original.Length; i++) pointsList.Add(original[i]);
                    for (int i = mergeEndpoints ? 1 : 0; i < mergedPoints.Length; i++) pointsList.Add(mergedPoints[i]);
                } else
                {
                    for (int i = 0; i < original.Length; i++) pointsList.Add(original[i]);
                    for (int i = 0; i < mergedPoints.Length - (mergeEndpoints ? 1 : 0); i++) pointsList.Add(mergedPoints[(mergedPoints.Length-1)-i]);
                }
            } else
            {
                if (mergingSide == MergeSide.Start)
                {
                    for (int i = 0; i < mergedPoints.Length - (mergeEndpoints ? 1 : 0); i++) pointsList.Add(mergedPoints[(mergedPoints.Length - 1) - i]);
                    for (int i = 0; i < original.Length; i++) pointsList.Add(original[i]);
                }
                else
                {
                    for (int i = mergeEndpoints ? 1 : 0; i < mergedPoints.Length; i++) pointsList.Add(mergedPoints[i]);
                    for (int i = 0; i < original.Length; i++) pointsList.Add(original[i]);
                }
            }
            points = pointsList.ToArray();
            double mergedPercent = (double)(mergedPoints.Length-1) / (points.Length-1);
            double from = 0.0;
            double to = 1.0;
            if (mergeSide == MergeSide.End)
            {
                from = 1.0 - mergedPercent;
                to = 1.0;
            }
            else
            {
                from = 0.0;
                to = mergedPercent;
            }


            List<Node> mergedNodes = new List<Node>();
            List<int> mergedIndices = new List<int>();

            for (int i = 0; i < mergedSpline.pointCount; i++)
            {
                Node node = mergedSpline.GetNode(i);
                if (node != null)
                {
                    mergedNodes.Add(node);
                    mergedIndices.Add(i);
                    Undo.RecordObject(node, "Disconnect Node");
                    mergedSpline.DisconnectNode(i);
                    i--;
                }
            }

            SplineUser[] subs = mergedSpline.GetSubscribers();
            for (int i = 0; i < subs.Length; i++)
            {
                mergedSpline.Unsubscribe(subs[i]);
                subs[i].spline = spline;
                subs[i].clipFrom = DMath.Lerp(from, to, subs[i].clipFrom);
                subs[i].clipTo = DMath.Lerp(from, to, subs[i].clipTo);
            }
            spline.SetPoints(points);

            if (mergeSide == MergeSide.Start)
            {
                spline.ShiftNodes(0, spline.pointCount - 1, mergedSpline.pointCount);
                for (int i = 0; i < mergedNodes.Count; i++)
                {
                    spline.ConnectNode(mergedNodes[i], mergedIndices[i]);
                }
            } else
            {
                for (int i = 0; i < mergedNodes.Count; i++)
                {
                    int connectIndex = mergedIndices[i] + original.Length;
                    if (mergeEndpoints) connectIndex--;
                    spline.ConnectNode(mergedNodes[i], connectIndex);
                }
            }
            if (EditorUtility.DisplayDialog("Keep merged computer's GameObject?", "Do you want to keep the merged computer's game object?", "Yes", "No"))
            {
                Undo.DestroyObjectImmediate(mergedSpline);
            }
            else
            {
                for (int i = 0; i < mergedNodes.Count; i++)
                {
                    if(TransformUtility.IsParent(mergedNodes[i].transform, mergedSpline.transform))
                    {
                        Undo.SetTransformParent(mergedNodes[i].transform, mergedSpline.transform.parent, "Reparent Node");
                    }
                }
                Undo.DestroyObjectImmediate(mergedSpline.gameObject);
            }

            FindAvailableComputers();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/DS Editor/ComputerMergeModule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/DS Editor/DreamteckSplinesEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 45538fa443017094faf75943a969938d
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEditor;

    public class DreamteckSplinesEditor : SplineEditor
    {
        public SplineComputer spline = null;

        public bool splineChanged
        {
            get { return _splineChanged; }
        }

        private Transform _transform;
        private DSCreatePointModule _createPointModule = null;
        private Dreamteck.Editor.Toolbar _nodesToolbar;
        private bool _splineChanged = false;

        private List<Vector3> _triggerWorldPositions = new List<Vector3>();


        protected override string editorName { get { return "DreamteckSplines"; } }

        public DreamteckSplinesEditor(SplineComputer splineComputer, SerializedObject splineHolder) : base (splineComputer.transform.localToWorldMatrix, splineHolder, "_spline")
        {
            spline = splineComputer;
            _transform = spline.transform;
            evaluate = spline.Evaluate;
            evaluateAtPoint = spline.Evaluate;
            evaluatePosition = spline.EvaluatePosition;
            calculateLength = spline.CalculateLength;
            travel = spline.Travel;
            undoHandler = HandleUndo;
            mainModule.onBeforeDeleteSelectedPoints += OnBeforeDeleteSelectedPoints;
            mainModule.onDuplicatePoint += OnDuplicatePoint;
            if (spline.isNewlyCreated)
            {
                if (SplinePrefs.startInCreationMode)
                {
                    open = true;
                    editMode = true;
                    ToggleModule(0);
                }
                spline.isNewlyCreated = false;
            }
            GUIContent[] nodeToolbarContents = new GUIContent[3];
            nodeToolbarContents[0] = new GUIContent("Select");
            nodeToolbarContents[1] = new GUIContent("Delete");
            nodeToolbarContents[2] = new GUIContent("Disconnect");
            _nodesToolbar = new Dreamteck.Editor.Toolbar(nodeToolbarContents);
        }

        protected override void Load()
        {
            pointOperations.Add(new PointOperation { name = "Center To Transform", action = delegate { CenterSelection(); } });
            pointOperations.Add(new PointOperation { name = "Move Transform To", action = delegate { MoveTransformToSelection(); } });
            base.Load();
        }

        private void OnDuplicatePoint(int[] points)
        {
            for (int i = 0; i < points.Length; i++)
            {
                spline.ShiftNodes(points[i], spline.pointCount - 1, 1);
            }
        }

        public override void DrawInspector()
        {
            drawColor = spline.editorPathColor;
            is2D = spline.is2D;
            base.DrawInspector();
        }

        public override void DrawScene(SceneView current)
        {
            if (spline == null) return;

            drawColor = spline.editorPathColor;
            is2D = spline.is2D;
            base.DrawScene(current);
        }

        public void CacheTriggerPositions()
        {
            _triggerWorldPositions.Clear();
            LoopTriggerProperties((trigger) =>
            {
                SerializedProperty positionProperty = trigger.FindPropertyRelative("position");
                _triggerWorldPositions.Add(spline.EvaluatePosition(positionProperty.floatValue));
            });
        }

        public void WriteTriggerPositions()
        {
            SplineSample projectSample = new SplineSample();
            int index = 0;
            LoopTriggerProperties((trigger) =>
            {
                spline.Project(_triggerWorldPositions[index], ref projectSample);
                SerializedProperty positionProperty = trigger.FindPropertyRelative("position");
                positionProperty.floatValue = (float)projectSample.percent;
                index++;
            });
            _serializedObject.ApplyModifiedProperties();
        }

        private void OnBeforeDeleteSelectedPoints()
        {
            CacheTriggerPositions();
            string nodeString = "";
            List <Node> deleteNodes = new List<Node>();
            for (int i = 0; i < selectedPoints.Count; i++)
            {
                Node node = spline.GetNode(selectedPoints[i]);
                if (node)
                {
                    spline.DisconnectNode(selectedPoints[i]);
                    if (node.GetConnections().Length == 0)
                    {
                        deleteNodes.Add(node);
                        if (nodeString != "") nodeString += ", ";
                        string trimmed = node.name.Trim();
                        if (nodeString.Length + trimmed.Length > 80) nodeString += "...";
                        else nodeString += node.name.Trim();
                    }
                }
            }

            if (deleteNodes.Count > 0)
            {
                string message = "The following nodes:\r\n" + nodeString + "\r\n were only connected to the currently selected points. Would you like to remove them from the scene?";
                if (EditorUtility.DisplayDialog("Remove nodes?", message, "Yes", "No"))
                {
                    for (int i = 0; i < deleteNodes.Count; i++)
                    {
                        Undo.DestroyObjectImmediate(deleteNodes[i].gameObject);
                    }
                }
            }

            int min = spline.pointCount - 1;
            for (int i = 0; i < selectedPoints.Count; i++)
            {
                if (selectedPoints[i] < min)
                {
                    min = selectedPoints[i];
                }
            }
        }

        protected override void PointMenu()
        {
            base.PointMenu();
            EditorGUILayout.Space();
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("Nodes", GUILayout.MaxWidth(200f));
            int nodesCount = 0;
            for (int i = 0; i < selectedPoints.Count; i++)
            {
                if(spline.GetNode(selectedPoints[i]) != null)
                {
                    nodesCount ++;
                }
            }

            if (nodesCount > 0)
            {
                int option = -1;
                _nodesToolbar.center = false;
                _nodesToolbar.Draw(ref option);
                if(option == 0)
                {
                    List<Node> nodeList = new List<Node>();
                    for (int i = 0; i < selectedPoints.Count; i++)
                    {
                        Node node = spline.GetNode(selectedPoints[i]);
                        if(node != null)
                        {
                            nodeList.Add(node);
                        }
                    }
                    Selection.objects = nodeList.ToArray();
                }

                if(option == 1)
                {
                    for (int i = 0; i < selectedPoints.Count; i++)
                    {
                        bool delete = true;
                        Node node = spline.GetNode(selectedPoints[i]);
                        if(node.GetConnections().Length > 1)
                        {
                            if(!EditorUtility.DisplayDialog("Delete Node",
                                "Node " + node.name + " has multiple connections. Are you sure you want to completely remove it?", "Yes", "No"))
                            {
                                delete = false;
                            }
                        }
                        if (delete)
                        {
                            Undo.RegisterCompleteObjectUndo(spline, "Delete Node");
                            Undo.DestroyObjectImmediate(node.gameObject);
                            spline.DisconnectNode(selectedPoints[i]);
                            EditorUtility.SetDirty(spline);
                        }
                    }
                }
                if (option == 2)
                {
                    for (int i = 0; i < selectedPoints.Count; i++)
                    {
                        Undo.RegisterCompleteObjectUndo(spline, "Disconnect Node");
                        spline.DisconnectNode(selectedPoints[i]);
                        EditorUtility.SetDirty(spline);
                    }
                }
            } else
            {
                if(GUILayout.Button(selectedPoints.Count == 1 ? "Add Node to Point" : "Add Nodes to Points"))
                {
                    for (int i = 0; i < selectedPoints.Count; i++)
                    {
                        SplineSample sample = spline.Evaluate(selectedPoints[i]);
                        GameObject go = new GameObject(spline.name + "_Node_" + (spline.GetNodes().Count+1));
                        go.transform.parent = spline.transform;
                        go.transform.position = sample.position;
                        if (spline.is2D)
                        {
                            go.transform.rotation = sample.rotation * Quaternion.Euler(90, -90, 0);
                        }
                        else
                        {
                            go.transform.rotation = sample.rotation;
                        }
                        Node node = go.AddComponent<Node>();
                        Undo.RegisterCreatedObjectUndo(go, "Create Node");
                        Undo.RegisterCompleteObjectUndo(spline, "Create Node");
                        spline.ConnectNode(node, selectedPoints[i]);
                    }
                }
            }
            EditorGUILayout.Space();
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.Space();
        }
        protected override void OnModuleList(List<PointModule> list)
        {
            _createPointModule = new DSCreatePointModule(this);
            list.Add(_createPointModule);
            list.Add(new DeletePointModule(this));
            list.Add(new PointMoveModule(this));
            list.Add(new PointRotateModule(this));
            list.Add(new PointScaleModule(this));
            list.Add(new PointNormalModule(this));
            list.Add(new PointMirrorModule(this));
            list.Add(new PrimitivesModule(this));
        }

        public override void Destroy()
        {
            base.Destroy();
            if(spline != null)
            {
                spline.RebuildImmediate();
            }
        }

        public override void BeforeSceneGUI(SceneView current)
        {
            for (int i = 0; i < moduleCount; i++)
            {
                SetupModule(GetModule(i));
            }
            SetupModule(mainModule);
            _createPointModule.createPointColor = SplinePrefs.createPointColor;
            _createPointModule.createPointSize = SplinePrefs.createPointSize;
            base.BeforeSceneGUI(current);
        }

        public override void DeletePoint(int index)
        {
            CacheTriggerPositions();
            Dictionary<int, Node> nodes = new Dictionary<int, Node>();
            foreach(var node in spline.GetNodes())
            {
                if(node.Key > index)
                {
                    spline.DisconnectNode(node.Key);
                    nodes.Add(node.Key - 1, node.Value);
                }
            }
            var nodesProperty = _serializedObject.FindProperty("_nodes");
            for (int i = 0; i < nodesProperty.arraySize; i++)
            {
                var indexProperty = nodesProperty.GetArrayElementAtIndex(i).FindPropertyRelative("pointIndex");
                if(indexProperty.intValue > index)
                {
                    nodesProperty.DeleteArrayElementAtIndex(i);
                    i--;
                }
            }
            InverseTransformPoints();
            _pointsProperty.DeleteArrayElementAtIndex(index);

            foreach (var node in nodes)
            {
                spline.ConnectNode(node.Value, node.Key);
                nodesProperty.arraySize = nodesProperty.arraySize + 1;
                var lastProperty = nodesProperty.GetArrayElementAtIndex(nodesProperty.arraySize - 1);
                var lastnodeProperty = lastProperty.FindPropertyRelative("node");
                var lastIndexProperty = lastProperty.FindPropertyRelative("pointIndex");
                lastnodeProperty.objectReferenceValue = node.Value;
                lastIndexProperty.intValue = node.Key;
            }

            _serializedObject.ApplyModifiedProperties();
            GetPointsFromSpline();
            spline.Rebuild(true);
            WriteTriggerPositions();
        }

        public override void GetPointsFromSpline()
        {
            base.GetPointsFromSpline();

            if (_serializedObject.FindProperty("_space").enumValueIndex == (int)SplineComputer.Space.Local)
            {
                TransformPoints();
            }
        }

        public override void ApplyModifiedProperties(bool forceAllUpdate = false)
        {
            if (_serializedObject.FindProperty("_space").enumValueIndex == (int)SplineComputer.Space.Local)
            {
                InverseTransformPoints();
            }

            for (int i = 0; i < points.Length; i++)
            {
                if (points[i].changed || forceAllUpdate)
                {
                    spline.EditorSetPointDirty(i);
                }
            }

            _splineChanged = true;

            if (spline.isClosed && points.Length < 3)
            {
                SetSplineClosed(false);
            }

            _serializedObject.FindProperty("_is2D").boolValue = is2D;

            base.ApplyModifiedProperties(forceAllUpdate);

            spline.EditorUpdateConnectedNodes();

            if (_serializedObject.FindProperty("editorUpdateMode").enumValueIndex == (int)SplineComputer.EditorUpdateMode.Default)
            {
                spline.RebuildImmediate(true, forceAllUpdate);
            }
            GetPointsFromSpline();
        }

        public override void SetSplineClosed(bool closed)
        {
            base.SetSplineClosed(closed);
            if (closed)
            {
                spline.Close();
            }
            else
            {
                if (selectedPoints.Count > 0)
                {
                    spline.Break(selectedPoints[selectedPoints.Count - 1]);
                }
                else
                {
                    spline.Break();
                }
            }
        }

        public override void UndoRedoPerformed()
        {
            base.UndoRedoPerformed();
            spline.RebuildImmediate(true, true);
        }

        private void TransformPoints()
        {
            _matrix = spline.transform.localToWorldMatrix;
            for (int i = 0; i < points.Length; i++)
            {
                bool changed = points[i].changed;
                points[i].position = _matrix.MultiplyPoint3x4(points[i].position);
                points[i].tangent = _matrix.MultiplyPoint3x4(points[i].tangent);
                points[i].tangent2 = _matrix.MultiplyPoint3x4(points[i].tangent2);
                points[i].normal = _matrix.MultiplyVector(points[i].normal);
                points[i].changed = changed;
            }
        }

        private void InverseTransformPoints()
        {
            _matrix = spline.transform.localToWorldMatrix;
            Matrix4x4 invMatrix = _matrix.inverse;
            for (int i = 0; i < points.Length; i++)
            {
                bool changed = points[i].changed;
                points[i].position = invMatrix.MultiplyPoint3x4(points[i].position);
                points[i].tangent = invMatrix.MultiplyPoint3x4(points[i].tangent);
                points[i].tangent2 = invMatrix.MultiplyPoint3x4(points[i].tangent2);
                points[i].normal = invMatrix.MultiplyVector(points[i].normal);
                points[i].changed = changed;
            }
        }

        public override void SetPreviewPoints(SplinePoint[] points)
        {
            spline.SetPoints(points);
        }

        private void HandleUndo(string title)
        {
            Undo.RecordObject(spline, title);
        }

        public void MoveTransformToSelection()
        {
            Undo.RecordObject(_transform, "Move Transform To");
            Vector3 avg = Vector3.zero;
            for (int i = 0; i < selectedPoints.Count; i++)
            {
                avg += points[selectedPoints[i]].position;
            }
            avg /= selectedPoints.Count;
            _transform.position = avg;
            ApplyModifiedProperties(true);
            ResetCurrentModule();
        }

        public void CenterSelection()
        {
            RecordUndo("Center Selection");
            Vector3 avg = Vector3.zero;
            for (int i = 0; i < selectedPoints.Count; i++)
            {
                avg += points[selectedPoints[i]].position;
            }
            avg /= selectedPoints.Count;
            Vector3 delta = _transform.position - avg;
            for (int i = 0; i < selectedPoints.Count; i++)
            {
                points[selectedPoints[i]].SetPosition(points[selectedPoints[i]].position + delta);
            }
            ApplyModifiedProperties(true);
            ResetCurrentModule();
        }

        private void SetupModule(PointModule module)
        {
            module.duplicationDirection = SplinePrefs.duplicationDirection;
            module.highlightColor = SplinePrefs.highlightColor;
            module.showPointNumbers = SplinePrefs.showPointNumbers;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/DS Editor/DreamteckSplinesEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/DS Editor/DSCreatePointModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 870db4c17be74374e93a8dbc31114a05
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEditor;

    public class DSCreatePointModule : CreatePointModule
    {
        DreamteckSplinesEditor dsEditor;
        private bool createNode = false;

        public DSCreatePointModule(SplineEditor editor) : base(editor)
        {
            dsEditor = (DreamteckSplinesEditor)editor;
        }

        public override void LoadState()
        {
            base.LoadState();
            createNode = LoadBool("createNode");
        }

        public override void SaveState()
        {
            base.SaveState();
            SaveBool("createNode", createNode);
        }

        protected override void OnDrawInspector()
        {
            base.OnDrawInspector();
            createNode = EditorGUILayout.Toggle("Create Node", createNode);
        }

        protected override void CreateSplinePoint(Vector3 position, Vector3 normal)
        {
            GUIUtility.hotControl = GUIUtility.GetControlID(FocusType.Passive);
            List<int> indices = new List<int>();
            List<Node> nodes = new List<Node>();
            SplineComputer spline = dsEditor.spline;

            dsEditor.CacheTriggerPositions();

            if (!isClosed && points.Length >= 3)
            {
                Vector2 first = HandleUtility.WorldToGUIPoint(points[0].position);
                Vector2 last = HandleUtility.WorldToGUIPoint(position);
                if (Vector2.Distance(first, last) <= 20f)
                {
                    if (EditorUtility.DisplayDialog("Close spline?", "Do you want to make the spline path closed ?", "Yes", "No"))
                    {
                        editor.SetSplineClosed(true);
                        spline.EditorSetAllPointsDirty();
                        RegisterChange();
                        SceneView.currentDrawingSceneView.Focus();
                        SceneView.RepaintAll();
                        return;
                    }
                }
            }  

            AddPoint();

            if (appendMode == AppendMode.End)
            {
                for (int i = 0; i < indices.Count; i++)
                {
                    nodes[i].AddConnection(spline, indices[i] + 1);
                }
            }

            dsEditor.ApplyModifiedProperties(true);
            dsEditor.WriteTriggerPositions();
            RegisterChange();
            if (appendMode == AppendMode.Beginning)
            {
                spline.ShiftNodes(0, spline.pointCount - 1, 1);
            }

            if (createNode)
            {
                dsEditor.ApplyModifiedProperties();
                if (appendMode == 0)
                {
                    CreateNodeForPoint(0);
                }
                else
                {
                    CreateNodeForPoint(points.Length - 1);
                }
            }
        }

        protected override void InsertMode(Vector3 screenCoordinates)
        {
            base.InsertMode(screenCoordinates);
            double percent = ProjectScreenSpace(screenCoordinates);
            editor.evaluate(percent, ref evalResult);
            if (editor.eventModule.mouseRight)
            {
                SplineEditorHandles.DrawCircle(evalResult.position, Quaternion.LookRotation(editorCamera.transform.position - evalResult.position), HandleUtility.GetHandleSize(evalResult.position) * 0.2f);
                return;
            }
            if (SplineEditorHandles.CircleButton(evalResult.position, Quaternion.LookRotation(editorCamera.transform.position - evalResult.position), HandleUtility.GetHandleSize(evalResult.position) * 0.2f, 1.5f, color))
            {
                dsEditor.CacheTriggerPositions();
                SplinePoint newPoint = new SplinePoint(evalResult.position, evalResult.position);
                newPoint.size = evalResult.size;
                newPoint.color = evalResult.color;
                newPoint.normal = evalResult.up;
                
                
                int pointIndex = dsEditor.spline.PercentToPointIndex(percent);
                editor.AddPointAt(pointIndex + 1);
                points[pointIndex + 1].SetPoint(newPoint);
                SplineComputer spline = dsEditor.spline;
                lastCreated = points.Length - 1;
                editor.ApplyModifiedProperties(true);
                spline.ShiftNodes(pointIndex + 1, spline.pointCount - 1, 1);
                if (createNode) CreateNodeForPoint(pointIndex + 1);
                RegisterChange();
                dsEditor.WriteTriggerPositions();
            }
        }

        void CreateNodeForPoint(int index)
        {
            GameObject obj = new GameObject("Node_" + (points.Length - 1));
            obj.transform.parent = dsEditor.spline.transform;
            Node node = obj.AddComponent<Node>();
            node.transform.localRotation = Quaternion.identity;
            node.transform.position = points[index].position;
            Undo.SetCurrentGroupName("Create Node For Point " + index);
            Undo.RegisterCreatedObjectUndo(obj, "Create Node object");
            Undo.RegisterCompleteObjectUndo(dsEditor.spline, "Link Node");
            dsEditor.spline.ConnectNode(node, index);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/DS Editor/DSCreatePointModule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/DS Editor/PrimitivesModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 0a63f089fd77344408647fe340cc2cf5
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System;
    using UnityEngine;
    using Dreamteck.Splines;
    using Dreamteck.Splines.Primitives;
    using UnityEditor;
    using System.Collections;
    using System.Collections.Generic;

    public class PrimitivesModule : PointTransformModule
    {
        DreamteckSplinesEditor dsEditor = null;
        private PrimitiveEditor[] primitiveEditors;
        private string[] primitiveNames;
        private SplinePreset[] presets;
        private string[] presetNames;
        int mode = 0, selectedPrimitive = 0, selectedPreset = 0;
        bool createPresetMode = false;
        GUIContent[] toolbarContents = new GUIContent[2];
        Dreamteck.Editor.Toolbar toolbar;

        private string savePresetName = "", savePresetDescription = "";

        private bool lastClosed = false;
        private Spline.Type lastType = Spline.Type.Bezier;


        public PrimitivesModule(SplineEditor editor) : base(editor)
        {
            dsEditor = ((DreamteckSplinesEditor)editor);
            toolbarContents[0] = new GUIContent("Primitives", "Procedural Primitives");
            toolbarContents[1] = new GUIContent("Presets", "Saved spline presets");
            toolbar = new Dreamteck.Editor.Toolbar(toolbarContents, toolbarContents);
        }

        public override GUIContent GetIconOff()
        {
            return IconContent("*", "primitives", "Spline Primitives");
        }

        public override GUIContent GetIconOn()
        {
            return IconContent("*", "primitives_on", "Spline Primitives");
        }

        public override void LoadState()
        {
            base.LoadState();
            selectedPrimitive = LoadInt("selectedPrimitive");
            mode = LoadInt("mode");
            createPresetMode = LoadBool("createPresetMode");
        }

        public override void SaveState()
        {
            base.SaveState();
            SaveInt("selectedPrimitive", selectedPrimitive);
            SaveInt("mode", mode);
            SaveBool("createPresetMode", createPresetMode);
        }

        public override void Select()
        {
            base.Select();
            lastClosed = editor.GetSplineClosed();
            lastType = editor.GetSplineType();
            if(mode == 0) LoadPrimitives();
            else if(!createPresetMode) LoadPresets();
        }

        public override void Deselect()
        {
            ApplyDialog();
            base.Deselect();
        }
        
        void ApplyDialog()
        {
            if (!IsDirty()) return;
            if (EditorUtility.DisplayDialog("Unapplied Primitives", "There is an unapplied primitive. Do you want to apply the changes?", "Apply", "Revert"))
            {
                Apply();
            }
            else
            {
                Revert();
            }
        }

        public override void Revert()
        {
            editor.SetSplineType(lastType);
            editor.SetSplineClosed(lastClosed);
            base.Revert();
        }

        protected override void OnDrawInspector()
        {
            EditorGUI.BeginChangeCheck();
            toolbar.Draw(ref mode);
            if (EditorGUI.EndChangeCheck())
            {
                if (mode == 0) LoadPrimitives();
                else if (!createPresetMode) LoadPresets();
                
            }
            if (selectedPoints.Count > 0) ClearSelection();
            if (mode == 0) PrimitivesGUI();
            else PresetsGUI();

            if (IsDirty() && (!createPresetMode || mode == 0))
            {
                EditorGUILayout.BeginHorizontal();
                if (GUILayout.Button("Apply")) Apply();
                if (GUILayout.Button("Revert")) Revert();
                EditorGUILayout.EndHorizontal();
            }
        }

        void PrimitivesGUI()
        {
            int last = selectedPrimitive;
            selectedPrimitive = EditorGUILayout.Popup(selectedPrimitive, primitiveNames);
            if (last != selectedPrimitive)
            {
                primitiveEditors[selectedPrimitive].Open(dsEditor);
                primitiveEditors[selectedPrimitive].Update();
                TransformPoints();
            }

            EditorGUI.BeginChangeCheck();
            primitiveEditors[selectedPrimitive].Draw();
            if (EditorGUI.EndChangeCheck())
            {
                TransformPoints();
            }
        }

        void PresetsGUI()
        {
            if (createPresetMode)
            {
                savePresetName = EditorGUILayout.TextField("Preset name", savePresetName);
                EditorGUILayout.LabelField("Description");
                savePresetDescription = EditorGUILayout.TextArea(savePresetDescription);
                EditorGUILayout.BeginHorizontal();
                if (GUILayout.Button("Save"))
                {
                    string lower = savePresetName.ToLower();
                    string noSlashes = lower.Replace('/', '_');
                    noSlashes = noSlashes.Replace('\\', '_');
                    string noSpaces = noSlashes.Replace(' ', '_');
                    SplinePreset preset = new SplinePreset(points, isClosed, splineType);
                    preset.name = savePresetName;
                    preset.description = savePresetDescription;
                    preset.Save(noSpaces);
                    createPresetMode = false;
                    LoadPresets();
                    savePresetName = savePresetDescription = "";
                }
                if (GUILayout.Button("Cancel")) createPresetMode = false;
                EditorGUILayout.EndHorizontal();
                return;
            }
            if (GUILayout.Button("Create New")) createPresetMode = true;
            EditorGUILayout.Space();
            
            EditorGUILayout.BeginHorizontal();
            selectedPreset = EditorGUILayout.Popup(selectedPreset, presetNames, GUILayout.MaxWidth(Screen.width / 3f));
            if (selectedPreset >= 0 && selectedPreset < presets.Length)
            {
                if (GUILayout.Button("Use"))
                {
                    LoadPreset(selectedPreset);
                }
                if (GUILayout.Button("Delete", GUILayout.MaxWidth(80)))
                {
                    if (EditorUtility.DisplayDialog("Delete Preset", "This will permanently delete the preset file. Continue?", "Yes", "No"))
                    {
                        SplinePreset.Delete(presets[selectedPreset].filename);
                        LoadPresets();
                        if (selectedPreset >= presets.Length) selectedPreset = presets.Length - 1;
                    }
                }
            }
            EditorGUILayout.EndHorizontal();
            
        }

        void TransformPoints()
        {
            for (int i = 0; i < editor.points.Length; i++)
            {
                editor.points[i].position = dsEditor.spline.transform.TransformPoint(editor.points[i].position);
                editor.points[i].tangent = dsEditor.spline.transform.TransformPoint(editor.points[i].tangent);
                editor.points[i].tangent2 = dsEditor.spline.transform.TransformPoint(editor.points[i].tangent2);
                editor.points[i].normal = dsEditor.spline.transform.TransformDirection(editor.points[i].normal);
            }
            RegisterChange();
            SetDirty();
        }

        void LoadPrimitives()
        {
            List<Type> types = FindDerivedClasses.GetAllDerivedClasses(typeof(PrimitiveEditor));
            primitiveEditors = new PrimitiveEditor[types.Count];
            int count = 0;
            primitiveNames = new string[types.Count];
            foreach (Type t in types)
            {
                primitiveEditors[count] = (PrimitiveEditor)Activator.CreateInstance(t);
                primitiveNames[count] = primitiveEditors[count].GetName();
                count++;
            }

            if (selectedPrimitive >= 0 && selectedPrimitive < primitiveEditors.Length)
            {
                ClearSelection();
                primitiveEditors[selectedPrimitive].Open(dsEditor);
                primitiveEditors[selectedPrimitive].Update();
                TransformPoints();
                SetDirty();
            }
        }

        void LoadPresets()
        {
            ApplyDialog();
            presets = SplinePreset.LoadAll();
            presetNames = new string[presets.Length];
            for (int i = 0; i < presets.Length; i++)
            {
                presetNames[i] = presets[i].name;
            }
            ClearSelection();
        }

        void LoadPreset(int index)
        {
            if (index >= 0 && index < presets.Length)
            {
                editor.SetPointsArray(presets[index].points);
                editor.SetSplineClosed(presets[index].isClosed);
                editor.SetSplineType(presets[index].type);
                TransformPoints();
                FramePoints();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/DS Editor/PrimitivesModule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/DS Editor/SplineComputerDebugEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 79246ce5388cae549b7ae6bf61b912f3
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEditor;

    public class SplineComputerDebugEditor : SplineEditorBase
    {
        public SplineComputer.EditorUpdateMode editorUpdateMode
        {
            get
            {
                return (SplineComputer.EditorUpdateMode)_editorUpdateMode.enumValueIndex;
            }
        }

        private SerializedProperty _editorDrawPivot;
        private SerializedProperty _editorPathColor;
        private SerializedProperty _editorAlwaysDraw;
        private SerializedProperty _editorDrawThickness;
        private SerializedProperty _editorBillboardThickness;
        private SerializedProperty _editorUpdateMode;
        private SplineComputer _spline;
        private DreamteckSplinesEditor _pathEditor;
        private float _length = 0f;

        public SplineComputerDebugEditor(SplineComputer spline, SerializedObject serializedObject, DreamteckSplinesEditor pathEditor) : base(serializedObject)
        {
            _spline = spline;
            _pathEditor = pathEditor;
            GetSplineLength();
            _editorPathColor = serializedObject.FindProperty("editorPathColor");
            _editorAlwaysDraw = serializedObject.FindProperty("editorAlwaysDraw");
            _editorDrawThickness = serializedObject.FindProperty("editorDrawThickness");
            _editorBillboardThickness = serializedObject.FindProperty("editorBillboardThickness");
            _editorUpdateMode = serializedObject.FindProperty("editorUpdateMode");
            _editorDrawPivot = serializedObject.FindProperty("editorDrawPivot");
        }

        void GetSplineLength()
        {
            _length = Mathf.RoundToInt(_spline.CalculateLength() * 100f) / 100f;
        }

        public override void DrawInspector()
        {
            base.DrawInspector();
            if (Event.current.type == EventType.MouseUp) GetSplineLength();
            EditorGUI.BeginChangeCheck();

            EditorGUILayout.PropertyField(_editorUpdateMode, new GUIContent("Editor Update Mode"));
            EditorGUILayout.PropertyField(_editorPathColor, new GUIContent("Color in Scene"));
            bool lastAlwaysDraw = _editorAlwaysDraw.boolValue;
            EditorGUILayout.PropertyField(_editorDrawPivot, new GUIContent("Draw Transform Pivot"));
            EditorGUILayout.PropertyField(_editorAlwaysDraw, new GUIContent("Always Draw Spline"));
            if (lastAlwaysDraw != _editorAlwaysDraw.boolValue)
            {
                if (_editorAlwaysDraw.boolValue)
                {
                    for (int i = 0; i < _serializedObject.targetObjects.Length; i++)
                    {
                        if (_serializedObject.targetObjects[i] is SplineComputer)
                        {
                            DSSplineDrawer.RegisterComputer((SplineComputer)_serializedObject.targetObjects[i]);
                        }
                    }
                }
                else
                {
                    for (int i = 0; i < _serializedObject.targetObjects.Length; i++)
                    {
                        if (_serializedObject.targetObjects[i] is SplineComputer)
                        {
                            DSSplineDrawer.UnregisterComputer((SplineComputer)_serializedObject.targetObjects[i]);
                        }
                    }
                }
            }
            EditorGUILayout.PropertyField(_editorDrawThickness, new GUIContent("Draw thickness"));
            if (_editorDrawThickness.boolValue)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_editorBillboardThickness, new GUIContent("Always face camera"));
                EditorGUI.indentLevel--;
            }

            EditorGUILayout.Space();
            if (_serializedObject.targetObjects.Length == 1)
            {
                EditorGUILayout.HelpBox("Samples: " + _spline.sampleCount + "\n\r" + "Length: " + _length, MessageType.Info);
            } else
            {
                EditorGUILayout.HelpBox("Multiple spline objects selected" + _length, MessageType.Info);
            }

            if (EditorGUI.EndChangeCheck())
            {
                if (editorUpdateMode == SplineComputer.EditorUpdateMode.Default)
                {
                    for (int i = 0; i < _serializedObject.targetObjects.Length; i++)
                    {
                        if(_serializedObject.targetObjects[i] is SplineComputer)
                        {
                            ((SplineComputer)_serializedObject.targetObjects[i]).RebuildImmediate(true);
                        }
                    }
                    SceneView.RepaintAll();
                }
                _pathEditor.ApplyModifiedProperties();
            }
        }

        public override void DrawScene(SceneView current)
        {
            base.DrawScene(current);
            if (Event.current.type == EventType.MouseUp && open)
            {
                GetSplineLength();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/DS Editor/SplineComputerDebugEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/DS Editor/SplineTriggersEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 8e0ea2345d361b04b8778234920e3e24
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEditor;

    public class SplineTriggersEditor : SplineEditorBase
    {
        private int selected = -1, selectedGroup = -1;
        private bool renameTrigger = false, renameGroup = false;
        SplineComputer spline;
        SplineTrigger.Type addTriggerType = SplineTrigger.Type.Double;
        private int setDistanceGroup, setDistanceTrigger;

        public SplineTriggersEditor(SplineComputer spline, SerializedObject serializedObject) : base(serializedObject)
        {
            this.spline = spline;
        }

        protected override void Load()
        {
            base.Load();
            addTriggerType = (SplineTrigger.Type)LoadInt("addTriggerType");
        }

        protected override void Save()
        {
            base.Save();
            SaveInt("addTriggerType", (int)addTriggerType);
        }

        public override void DrawInspector()
        {
            base.DrawInspector();
            EditorGUI.BeginChangeCheck();
            EditorGUILayout.BeginVertical();
            for (int i = 0; i < spline.triggerGroups.Length; i++) DrawGroupGUI(i);
            EditorGUILayout.Space();
            if(GUILayout.Button("New Group"))
            {
                RecordUndo("Add Trigger Group");
                TriggerGroup group = new TriggerGroup();
                group.name = "Trigger Group " + (spline.triggerGroups.Length+1);
                ArrayUtility.Add(ref spline.triggerGroups, group);
            }
            EditorGUILayout.EndVertical();
            if (EditorGUI.EndChangeCheck()) SceneView.RepaintAll();
        }

        public override void DrawScene(SceneView current)
        {
            base.DrawScene(current);

            if (spline == null) return;

            for (int i = 0; i < spline.triggerGroups.Length; i++)
            {
                if (!spline.triggerGroups[i].open) continue;
                DrawGroupScene(i);
            }
        }

        void DrawGroupScene(int index)
        {
            TriggerGroup group = spline.triggerGroups[index];
            for (int i = 0; i < group.triggers.Length; i++)
            {
                SplineComputerEditorHandles.SplineSliderGizmo gizmo = SplineComputerEditorHandles.SplineSliderGizmo.DualArrow;
                switch (group.triggers[i].type)
                {
                    case SplineTrigger.Type.Backward: gizmo = SplineComputerEditorHandles.SplineSliderGizmo.BackwardTriangle; break;
                    case SplineTrigger.Type.Forward: gizmo = SplineComputerEditorHandles.SplineSliderGizmo.ForwardTriangle; break;
                    case SplineTrigger.Type.Double: gizmo = SplineComputerEditorHandles.SplineSliderGizmo.DualArrow; break;
                }
                double last = group.triggers[i].position;
                if (SplineComputerEditorHandles.Slider(spline, ref group.triggers[i].position, group.triggers[i].color, group.triggers[i].name, gizmo) || last != group.triggers[i].position)
                {
                    Select(index, i);
                    Repaint();
                }
            }
        }

        void OnSetDistance(float distance)
        {
            SerializedObject serializedObject = new SerializedObject(spline);
            SerializedProperty groups = serializedObject.FindProperty("triggerGroups");
            SerializedProperty groupProperty = groups.GetArrayElementAtIndex(setDistanceGroup);

            SerializedProperty triggersProperty = groupProperty.FindPropertyRelative("triggers");
            SerializedProperty triggerProperty = triggersProperty.GetArrayElementAtIndex(setDistanceTrigger);

            SerializedProperty position = triggerProperty.FindPropertyRelative("position");

            double travel = spline.Travel(0.0, distance, Spline.Direction.Forward);
            position.floatValue = (float)travel;
            serializedObject.ApplyModifiedProperties();
        }

        void DrawGroupGUI(int index)
        {
            TriggerGroup group = spline.triggerGroups[index];
            SerializedObject serializedObject = new SerializedObject(spline);
            SerializedProperty groups = serializedObject.FindProperty("triggerGroups");
            SerializedProperty groupProperty = groups.GetArrayElementAtIndex(index);
            EditorGUI.indentLevel += 2;
            if(selectedGroup == index && renameGroup)
            {
                if (Event.current.type == EventType.KeyDown && (Event.current.keyCode == KeyCode.Return || Event.current.keyCode == KeyCode.KeypadEnter))
                {
                    renameGroup  = false;
                    Repaint();
                }
                group.name = EditorGUILayout.TextField(group.name);
            } else group.open = EditorGUILayout.Foldout(group.open, index + " - " + group.name);
            Rect lastRect = GUILayoutUtility.GetLastRect();
            if(lastRect.Contains(Event.current.mousePosition) && Event.current.type == EventType.MouseDown && Event.current.button == 1)
            {
                GenericMenu menu = new GenericMenu();
                menu.AddItem(new GUIContent("Rename"), false, delegate { RecordUndo("Rename Trigger Group"); selectedGroup = index; renameGroup = true; renameTrigger = false; Repaint(); });
                menu.AddItem(new GUIContent("Delete"), false, delegate {
                    RecordUndo("Delete Trigger Group");
                    ArrayUtility.RemoveAt(ref spline.triggerGroups, index);
                    Repaint();
                });
                menu.ShowAsContext();
            }
            EditorGUI.indentLevel -= 2;
            if (!group.open) return;

            for (int i = 0; i < group.triggers.Length; i++) DrawTriggerGUI(i, index, groupProperty);
            if (GUI.changed) serializedObject.ApplyModifiedProperties();

            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button("Add Trigger"))
            {
                RecordUndo("Add Trigger");
                SplineTrigger newTrigger = new SplineTrigger(addTriggerType);
                newTrigger.name = "Trigger " + (group.triggers.Length + 1);
                ArrayUtility.Add(ref group.triggers, newTrigger);
            }
            addTriggerType = (SplineTrigger.Type)EditorGUILayout.EnumPopup(addTriggerType);
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.Space();
            EditorGUILayout.Space();
        }

        void Select(int group, int trigger)
        {
            selected = trigger;
            selectedGroup = group;
            renameTrigger = false;
            renameGroup = false;
            Repaint();
        }

        void DrawTriggerGUI(int index, int groupIndex, SerializedProperty groupProperty)
        {
            bool isSelected = selected == index && selectedGroup == groupIndex;
            TriggerGroup group = spline.triggerGroups[groupIndex];
            SplineTrigger trigger = group.triggers[index];
            SerializedProperty triggersProperty = groupProperty.FindPropertyRelative("triggers");
            SerializedProperty triggerProperty = triggersProperty.GetArrayElementAtIndex(index);
            SerializedProperty eventProperty = triggerProperty.FindPropertyRelative("onCross");
            SerializedProperty positionProperty = triggerProperty.FindPropertyRelative("position");
            SerializedProperty colorProperty = triggerProperty.FindPropertyRelative("color");
            SerializedProperty nameProperty = triggerProperty.FindPropertyRelative("name");
            SerializedProperty enabledProperty = triggerProperty.FindPropertyRelative("enabled");
            SerializedProperty workOnceProperty = triggerProperty.FindPropertyRelative("workOnce");
            SerializedProperty typeProperty = triggerProperty.FindPropertyRelative("type");

            Color col = colorProperty.colorValue;
            if (isSelected) col.a = 1f;
            else col.a = 0.6f;
            GUI.backgroundColor = col;

            EditorGUILayout.BeginVertical(GUI.skin.box);
            GUI.backgroundColor = Color.white;
            if (trigger == null)
            {
                EditorGUILayout.BeginHorizontal();
                GUILayout.Label("NULL");
                if (GUILayout.Button("x")) ArrayUtility.RemoveAt(ref group.triggers, index);
                EditorGUILayout.EndHorizontal();
                EditorGUILayout.EndVertical();
                return;
            }


            if (isSelected && renameTrigger)
            {
                if (Event.current.type == EventType.KeyDown && (Event.current.keyCode == KeyCode.Return || Event.current.keyCode == KeyCode.KeypadEnter))
                {
                    renameTrigger = false;
                    Repaint();
                }
                nameProperty.stringValue = EditorGUILayout.TextField(nameProperty.stringValue);
            }
            else
            {
                EditorGUILayout.LabelField(nameProperty.stringValue);
            }

            if (isSelected)
            {
                EditorGUILayout.Space();
                EditorGUILayout.PropertyField(enabledProperty);
                EditorGUILayout.PropertyField(colorProperty);

                EditorGUILayout.BeginHorizontal();
                positionProperty.floatValue = EditorGUILayout.Slider("Position", positionProperty.floatValue, 0f, 1f);
                if (GUILayout.Button("Set Distance", GUILayout.Width(85)))
                {
                    DistanceWindow w = EditorWindow.GetWindow<DistanceWindow>(true);
                    w.Init(OnSetDistance, spline.CalculateLength());
                    setDistanceGroup = groupIndex;
                    setDistanceTrigger = index;
                }
                EditorGUILayout.EndHorizontal();
                EditorGUILayout.PropertyField(typeProperty);
                EditorGUILayout.PropertyField(workOnceProperty);

                EditorGUILayout.PropertyField(eventProperty);
            }
            EditorGUILayout.EndVertical();

            Rect lastRect = GUILayoutUtility.GetLastRect();
            if (lastRect.Contains(Event.current.mousePosition) && Event.current.type == EventType.MouseDown)
            {
                if (Event.current.button == 0) Select(groupIndex, index);
                else if (Event.current.button == 1)
                {
                    GenericMenu menu = new GenericMenu();
                    menu.AddItem(new GUIContent("Deselect"), false, delegate { Select(-1, -1); });
                    menu.AddItem(new GUIContent("Rename"), false, delegate { Select(groupIndex, index); renameTrigger = true; renameGroup = false; });
                    if (index > 0)
                    {
                        menu.AddItem(new GUIContent("Move Up"), false, delegate {
                            RecordUndo("Move Trigger Up");
                            SplineTrigger temp = group.triggers[index - 1];
                            group.triggers[index - 1] = trigger;
                            group.triggers[index] = temp;
                            selected--;
                            renameTrigger = false;
                        });
                    }
                    else
                    {
                        menu.AddDisabledItem(new GUIContent("Move Up"));
                    }
                    if (index < group.triggers.Length - 1)
                    {
                        menu.AddItem(new GUIContent("Move Down"), false, delegate {
                            RecordUndo("Move Trigger Down");
                            SplineTrigger temp = group.triggers[index + 1];
                            group.triggers[index + 1] = trigger;
                            group.triggers[index] = temp;
                            selected--;
                            renameTrigger = false;
                        });
                    }
                    else
                    {
                        menu.AddDisabledItem(new GUIContent("Move Down"));
                    }

                    menu.AddItem(new GUIContent("Duplicate"), false, delegate {
                        RecordUndo("Duplicate Trigger");
                        SplineTrigger newTrigger = new SplineTrigger(SplineTrigger.Type.Double);
                        newTrigger.color = colorProperty.colorValue;
                        newTrigger.enabled = enabledProperty.boolValue;
                        newTrigger.position = positionProperty.floatValue;
                        newTrigger.type = (SplineTrigger.Type) typeProperty.intValue;
                        newTrigger.name = "Trigger " + (group.triggers.Length + 1);
                        ArrayUtility.Add(ref group.triggers, newTrigger);
                        Select(groupIndex, group.triggers.Length - 1);
                    });
                    menu.AddItem(new GUIContent("Delete"), false, delegate {
                        RecordUndo("Delete Trigger");
                        ArrayUtility.RemoveAt(ref group.triggers, index);
                        Select(-1, -1);
                    });
                    menu.ShowAsContext();
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/DS Editor/SplineTriggersEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/EditorModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 8686a0595fc0a4f439a1a64fb1a4d49a
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEditor;

    public class EditorModule
    {
        protected string prefPrefix = "";

        private bool _changed = false;

        public bool hasChanged { get { return _changed; } }

        protected SceneView _currentSceneView;


        protected void RegisterChange()
        {
            _changed = true;
        }

        public virtual void Select()
        {
            LoadState();
        }

        public virtual void Deselect()
        {
            SaveState();
        }

        public virtual void BeforeSceneDraw(SceneView current)
        {
            _currentSceneView = current;
        }

        public void DrawScene()
        {
            _changed = false;
            OnDrawScene();
        }

        protected virtual void OnDrawScene()
        {
        }

        public void DrawInspector()
        {
            _changed = false;
            OnDrawInspector();
        }

        protected virtual void OnDrawInspector()
        {
        }

        public virtual GUIContent GetIconOff()
        {
            return new GUIContent("OFF", "Point Module Off");
        }

        public virtual GUIContent GetIconOn()
        {
            return new GUIContent("ON", "Point Module On");
        }

        protected virtual void RecordUndo(string title)
        {
        }

        protected virtual void Repaint()
        {
        }

        protected void SaveBool(string variableName, bool value)
        {
            if (prefPrefix == "") prefPrefix = GetType().ToString();
            EditorPrefs.SetBool(prefPrefix + "." + variableName, value);
        }

        protected void SaveInt(string variableName, int value)
        {
            if (prefPrefix == "") prefPrefix = GetType().ToString();
            EditorPrefs.SetInt(prefPrefix + "." + variableName, value);
        }

        protected void SaveFloat(string variableName, float value)
        {
            if (prefPrefix == "") prefPrefix = GetType().ToString();
            EditorPrefs.SetFloat(prefPrefix + "." + variableName, value);
        }

        protected void SaveString(string variableName, string value)
        {
            if (prefPrefix == "") prefPrefix = GetType().ToString();
            EditorPrefs.SetString(prefPrefix + "." + variableName, value);
        }

        protected bool LoadBool(string variableName)
        {
            if (prefPrefix == "") prefPrefix = GetType().ToString();
            return EditorPrefs.GetBool(prefPrefix + "." + variableName, false);
        }

        protected int LoadInt(string variableName, int defaultValue = 0)
        {
            if (prefPrefix == "") prefPrefix = GetType().ToString();
            return EditorPrefs.GetInt(prefPrefix + "." + variableName, defaultValue);
        }

        protected float LoadFloat(string variableName, float d = 0f)
        {
            if (prefPrefix == "") prefPrefix = GetType().ToString();
            return EditorPrefs.GetFloat(prefPrefix + "." + variableName, d);
        }

        protected string LoadString(string variableName)
        {
            if (prefPrefix == "") prefPrefix = GetType().ToString();
            return EditorPrefs.GetString(prefPrefix + "." + variableName, "");
        }

        public virtual void SaveState()
        {

        }

        public virtual void LoadState()
        {

        }

        internal static GUIContent IconContent(string title, string iconName, string description)
        {
            GUIContent content = new GUIContent(title, description);
            if (EditorGUIUtility.isProSkin)
            {
                iconName += "_dark";
            }
            Texture2D tex = ResourceUtility.EditorLoadTexture("Splines/Editor/Icons", iconName);
            if (tex != null)
            {
                content.image = tex;
                content.text = "";
            }
            return content;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/EditorModule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/Point Modules/CreatePointModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: dcb9fe180ed013a44a474b2a4ece59fc
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
using UnityEngine;
using UnityEditor;
using System.Collections;
using System.Collections.Generic;

    public class CreatePointModule : PointModule
    {
        public enum AppendMode { Beginning = 0, End = 1}
        public enum PlacementMode { YPlane, XPlane, ZPlane, CameraPlane, Surface, Insert }
        public enum NormalMode { Default, LookAtCamera, AlignWithCamera, Calculate, Left, Right, Up, Down, Forward, Back }
        protected PlacementMode placementMode = PlacementMode.YPlane;
        public AppendMode appendMode = AppendMode.End;
        public float offset = 0f;
        public NormalMode normalMode = NormalMode.Default;
        public LayerMask surfaceLayerMask = new LayerMask();
        public float createPointSize = 1f;
        public Color createPointColor = Color.white;
        protected Spline visualizer;
        protected Camera editorCamera;
        protected Vector3 createPoint = Vector3.zero, createNormal = Vector3.up;
        protected SplineSample evalResult = new SplineSample();
        protected int lastCreated = -1;

        public CreatePointModule(SplineEditor editor) : base(editor)
        {

        }

        public override GUIContent GetIconOff()
        {
            return IconContent("+", "add", "Add Points");
        }

        public override GUIContent GetIconOn()
        {
            return IconContent("+", "add_on", "Add Points");
        }

        public override void LoadState()
        {
            base.LoadState();
            normalMode = (NormalMode)LoadInt("normalMode");
            placementMode = (PlacementMode)LoadInt("placementMode");
            appendMode = (AppendMode)LoadInt("appendMode", 1);
            offset = LoadFloat("offset");
            surfaceLayerMask = LoadInt("surfaceLayerMask", ~0);
        }

        public override void SaveState()
        {
            base.SaveState();
            SaveInt("normalMode", (int)normalMode);
            SaveInt("placementMode", (int)placementMode);
            SaveInt("appendMode", (int)appendMode);
            SaveFloat("offset", offset);
            SaveInt("surfaceLayerMask", surfaceLayerMask);
        }

        public override void Deselect()
        {
            base.Deselect();
            GUIUtility.hotControl = -1;
            if (Event.current != null)
            {
                Event.current.Use();
            }
        }

        protected override void OnDrawInspector()
        {
            placementMode = (PlacementMode)EditorGUILayout.EnumPopup("Placement Mode", placementMode);
            if (placementMode != PlacementMode.Insert)
            {
                normalMode = (NormalMode)EditorGUILayout.EnumPopup("Normal Mode", normalMode);
                appendMode = (AppendMode)EditorGUILayout.EnumPopup("Append To", appendMode);
            }
            string offsetLabel = "Grid Offset";
            if (placementMode == PlacementMode.CameraPlane) offsetLabel = "Far Plane";
            if (placementMode == PlacementMode.Surface) offsetLabel = "Surface Offset";
            offset = EditorGUILayout.FloatField(offsetLabel, offset);
            if (placementMode == PlacementMode.Surface)
            {
                surfaceLayerMask = DreamteckEditorGUI.LayermaskField("Surface Mask", surfaceLayerMask);
            }
        }

        protected override void OnDrawScene()
        {
            editorCamera = SceneView.currentDrawingSceneView.camera;
            bool canCreate = false;
            if (placementMode == PlacementMode.CameraPlane)
            {
                GetCreatePointOnPlane(-editorCamera.transform.forward, editorCamera.transform.position + editorCamera.transform.forward * offset, out createPoint);
                Handles.color = new Color(1f, 0.78f, 0.12f);
                DrawGrid(createPoint, editorCamera.transform.forward, Vector2.one * 10, 2.5f);
                Handles.color = Color.white;
                canCreate = true;
                createNormal = -editorCamera.transform.forward;
            }

            if (placementMode == PlacementMode.Surface)
            {
                Ray ray = HandleUtility.GUIPointToWorldRay(Event.current.mousePosition);
                RaycastHit hit;
                if (Physics.Raycast(ray, out hit, Mathf.Infinity, surfaceLayerMask))
                {
                    canCreate = true;
                    createPoint = hit.point + hit.normal * offset;
                    Handles.color = Color.blue;
                    Handles.DrawLine(hit.point, createPoint);
                    SplineEditorHandles.DrawRectangle(createPoint, Quaternion.LookRotation(-editorCamera.transform.forward, editorCamera.transform.up), HandleUtility.GetHandleSize(createPoint) * 0.1f);
                    Handles.color = Color.white;
                    createNormal = hit.normal;
                }
            }

            if (placementMode == PlacementMode.XPlane)
            {
                canCreate = AxisGrid(Vector3.right, new Color(0.85f, 0.24f, 0.11f, 0.92f), out createPoint);
                createNormal = Vector3.right;
            }

            if (placementMode == PlacementMode.YPlane)
            {
                canCreate = AxisGrid(Vector3.up, new Color(0.6f, 0.95f, 0.28f, 0.92f), out createPoint);
                createNormal = Vector3.up;
            }

            if (placementMode == PlacementMode.ZPlane)
            {
                canCreate = AxisGrid(Vector3.forward, new Color(0.22f, 0.47f, 0.97f, 0.92f), out createPoint);
                createNormal = Vector3.back;
            }

            if (placementMode == PlacementMode.Insert)
            {
                canCreate = true;
                if (points.Length < 2)
                {
                    placementMode = PlacementMode.YPlane;
                }
                else
                {
                    InsertMode(Event.current.mousePosition);
                }
            }
            else if (eventModule.mouseLeftDown && canCreate && !eventModule.mouseRight && !eventModule.alt)
            {
                CreateSplinePoint(createPoint, createNormal);
            }

            if (lastCreated >= 0 && lastCreated < points.Length && editor.eventModule.mouseLeft)
            {
                Vector3 tangent = points[lastCreated].position - createPoint;
                if (appendMode == AppendMode.End)
                {
                    tangent = createPoint - points[lastCreated].position;
                }
                points[lastCreated].SetTangent2Position(points[lastCreated].position + tangent);
                RegisterChange();
            }
            else if (!editor.eventModule.mouseLeft)
            {
                lastCreated = -1;
            }


            if (!canCreate) DrawMouseCross();
            UpdateVisualizer();
            SplineDrawer.DrawSpline(visualizer, color);
            Repaint();
        }

        protected virtual void CreateSplinePoint(Vector3 position, Vector3 normal)
        {
            GUIUtility.hotControl = -1;
            AddPoint();
        }

        protected void AddPoint()
        {
            SplinePoint newPoint = new SplinePoint(createPoint, createPoint);
            newPoint.size = createPointSize;
            newPoint.color = createPointColor;
            SplinePoint[] newPoints = editor.GetPointsArray();
            if (appendMode == AppendMode.End)
            {
                Dreamteck.ArrayUtility.Add(ref newPoints, newPoint);
                lastCreated = newPoints.Length - 1;
            }
            else
            {
                Dreamteck.ArrayUtility.Insert(ref newPoints, 0, newPoint);
                lastCreated = 0;
            }

            editor.SetPointsArray(newPoints);
            SetPointNormal(lastCreated, createNormal);
            SelectPoint(lastCreated);
            RegisterChange();
        }

        protected void SetPointNormal(int index, Vector3 defaultNormal)
        {
            if (editor.is2D)
            {
                points[index].normal = Vector3.back;
                return;
            }
            if (normalMode == NormalMode.Default) points[index].normal = defaultNormal;
            else
            {
                Camera editorCamera = SceneView.lastActiveSceneView.camera;
                switch (normalMode)
                {
                    case NormalMode.AlignWithCamera: points[index].normal = editorCamera.transform.forward; break;
                    case NormalMode.LookAtCamera: points[index].normal = Vector3.Normalize(editorCamera.transform.position - points[index].position); break;
                    case NormalMode.Calculate: PointNormalModule.CalculatePointNormal(points, index, isClosed); break;
                    case NormalMode.Left: points[index].normal = Vector3.left; break;
                    case NormalMode.Right: points[index].normal = Vector3.right; break;
                    case NormalMode.Up: points[index].normal = Vector3.up; break;
                    case NormalMode.Down: points[index].normal = Vector3.down; break;
                    case NormalMode.Forward: points[index].normal = Vector3.forward; break;
                    case NormalMode.Back: points[index].normal = Vector3.back; break;
                }
            }
        }

        protected virtual void InsertMode(Vector3 screenCoordinates)
        {
           
            double percent = ProjectScreenSpace(screenCoordinates);
            editor.evaluate(percent, ref evalResult);
            if (editor.eventModule.mouseRight)
            {
                SplineEditorHandles.DrawCircle(evalResult.position, Quaternion.LookRotation(editorCamera.transform.position - evalResult.position), HandleUtility.GetHandleSize(evalResult.position) * 0.2f);
                return;
            }
            if (SplineEditorHandles.CircleButton(evalResult.position, Quaternion.LookRotation(editorCamera.transform.position - evalResult.position), HandleUtility.GetHandleSize(evalResult.position) * 0.2f, 1.5f, color))
            {
                SplinePoint newPoint = new SplinePoint(evalResult.position, evalResult.position);
                newPoint.size = evalResult.size;
                newPoint.color = evalResult.color;
                newPoint.normal = evalResult.up;
                double floatIndex = (points.Length - 1) * percent;
                int pointIndex = Mathf.Clamp(DMath.FloorInt(floatIndex), 0, points.Length - 2);
                editor.AddPointAt(pointIndex + 1);
                points[pointIndex + 1].SetPoint(newPoint); 
                SelectPoint(pointIndex);
                RegisterChange();
            }
        }

        protected double ProjectScreenSpace(Vector2 screenPoint)
        {
            float closestDistance = (screenPoint - HandleUtility.WorldToGUIPoint(points[0].position)).sqrMagnitude;
            double closestPercent = 0.0;
            double moveStep = 1.0 / ((editor.points.Length - 1) * sampleRate);
            double add = moveStep;
            if (splineType == Spline.Type.Linear) add /= 2.0;
            int count = 0;
            for (double i = add; i < 1.0; i += add)
            {
                editor.evaluate(i, ref evalResult);
                Vector2 point = HandleUtility.WorldToGUIPoint(evalResult.position);
                float dist = (point - screenPoint).sqrMagnitude;
                if (dist < closestDistance)
                {
                    closestDistance = dist;
                    closestPercent = i;
                }
                count++;
            }
            return closestPercent;
        }

        bool GetCreatePointOnPlane(Vector3 normal, Vector3 origin, out Vector3 result)
        {
            Plane plane = new Plane(normal, origin);
            Ray ray = HandleUtility.GUIPointToWorldRay(Event.current.mousePosition);
            float rayDistance;
            if (plane.Raycast(ray, out rayDistance))
            {
                result = ray.GetPoint(rayDistance);
                return true;
            }
            else if (normal == Vector3.zero)
            {
                result = origin;
                return true;
            }
            else
            {
                result = ray.GetPoint(0f);
                return true;
            }
        }


        bool AxisGrid(Vector3 axis, Color color, out Vector3 origin)
        {
            float dot = Vector3.Dot(editorCamera.transform.position.normalized, axis);
            if (dot < 0f) axis = -axis;
            Plane plane = new Plane(axis, Vector3.zero);
            Ray ray = HandleUtility.GUIPointToWorldRay(Event.current.mousePosition);
            float rayDistance;
            if (plane.Raycast(ray, out rayDistance))
            {
                origin = ray.GetPoint(rayDistance) + axis * offset;
                Handles.color = color;
                float distance = 1f;
                ray = new Ray(editorCamera.transform.position, -axis);
                if (!editorCamera.orthographic && plane.Raycast(ray, out rayDistance)) distance = Vector3.Distance(editorCamera.transform.position + axis * offset, origin);
                else if (editorCamera.orthographic) distance = 2f * editorCamera.orthographicSize;
                DrawGrid(origin, axis, Vector2.one * distance * 0.3f, distance * 2.5f * 0.03f);
                Handles.DrawLine(origin, origin - axis * offset);
                Handles.color = Color.white;
                return true;
            }
            else
            {
                origin = Vector3.zero;
                return false;
            }
        }

        void DrawGrid(Vector3 center, Vector3 normal, Vector2 size, float scale)
        {
            Vector3 right = Vector3.Cross(Vector3.up, normal).normalized;
            if (Mathf.Abs(Vector3.Dot(Vector3.up, normal)) >= 0.9999f) right = Vector3.Cross(Vector3.forward, normal).normalized;
            Vector3 up = Vector3.Cross(normal, right).normalized;
            Vector3 startPoint = center - right * size.x * 0.5f + up * size.y * 0.5f;
            float i = 0f;
            float add = scale;
            while (i <= size.x)
            {
                Vector3 point = startPoint + right * i;
                Handles.DrawLine(point, point - up * size.y);
                i += add;
            }

            i = 0f;
            add = scale;
            while (i <= size.x)
            {
                Vector3 point = startPoint - up * i;
                Handles.DrawLine(point, point + right * size.x);
                i += add;
            }
        }

        void DrawMouseCross()
        {
            Ray ray = HandleUtility.GUIPointToWorldRay(Event.current.mousePosition);
            Vector3 origin = ray.GetPoint(1f);
            float size = 0.4f * HandleUtility.GetHandleSize(origin);
            Vector3 a = origin + editorCamera.transform.up * size - editorCamera.transform.right * size;
            Vector3 b = origin - editorCamera.transform.up * size + editorCamera.transform.right * size;
            Handles.color = Color.red;
            Handles.DrawLine(a, b);
            a = origin - editorCamera.transform.up * size - editorCamera.transform.right * size;
            b = origin + editorCamera.transform.up * size + editorCamera.transform.right * size;
            Handles.DrawLine(a, b);
            Handles.color = Color.white;
        }

        private void UpdateVisualizer()
        {
            if(visualizer == null) visualizer = new Spline(splineType);
            visualizer.type = splineType;
            visualizer.sampleRate = sampleRate;
            if(placementMode == PlacementMode.Insert)
            {
                visualizer.points = editor.GetPointsArray();
                if (isClosed) visualizer.Close();
                else if (visualizer.isClosed) visualizer.Break();
                return;
            }

            if (visualizer.points.Length != points.Length + 1)
            {
                visualizer.points = new SplinePoint[points.Length + 1];
            }

            SplinePoint newPoint = new SplinePoint(createPoint, createPoint, createNormal, 1f, Color.white);
            if (appendMode == AppendMode.End)
            {
                for (int i = 0; i < points.Length; i++)
                {
                    visualizer.points[i] = points[i].CreateSplinePoint();
                }
                visualizer.points[visualizer.points.Length - 1] = newPoint;
            }
            else
            {
                for (int i = 1; i < visualizer.points.Length; i++)
                {
                    visualizer.points[i] = points[i - 1].CreateSplinePoint();
                }
                visualizer.points[0] = newPoint;
            }

            if (isClosed && !visualizer.isClosed)
            {
                if(visualizer.points.Length >= 3)
                {
                    visualizer.Close();
                } else
                {
                    visualizer.Break();
                }
            }
            else if (!isClosed && visualizer.isClosed)
            {
                visualizer.Break();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/Point Modules/CreatePointModule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/Point Modules/DeletePointModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 031571ebca44b8a47a9af1984caeeff9
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
using UnityEngine;
using UnityEditor;
using System.Collections;
using System.Collections.Generic;

    public class DeletePointModule : PointModule
    {
        public float deleteRadius = 50f;
        Vector2 lastMousePos = Vector2.zero;


        public DeletePointModule(SplineEditor editor) : base(editor)
        {

        }

        public override GUIContent GetIconOff()
        {
            return IconContent("-", "remove", "Delete Points");
        }

        public override GUIContent GetIconOn()
        {
            return IconContent("-", "remove_on", "Delete Points");
        }

        public override void LoadState()
        {
            base.LoadState();
            deleteRadius = LoadFloat("deleteRadius", 50f);
        }

        public override void SaveState()
        {
            base.SaveState();
            SaveFloat("deleteRadius", deleteRadius);
        }

        protected override void OnDrawInspector()
        {
            deleteRadius = EditorGUILayout.FloatField("Brush Radius", deleteRadius);
        }

        protected override void OnDrawScene()
        {
            if (selectedPoints.Count > 0) ClearSelection();
            Handles.BeginGUI();
            Handles.color = Color.red;
            Handles.DrawWireDisc(Event.current.mousePosition, -Vector3.forward, deleteRadius);
            Handles.color = Color.white;
            Handles.EndGUI();
            if (!eventModule.alt && SceneView.currentDrawingSceneView.camera.pixelRect.Contains(Event.current.mousePosition)) {
                if (editor.eventModule.mouseLeftDown) GUIUtility.hotControl = GUIUtility.GetControlID(FocusType.Passive);
                if (editor.eventModule.mouseLeft && lastMousePos != Event.current.mousePosition)
                {
                    lastMousePos = Event.current.mousePosition;
                    RunDeleteMethod();
                }
            }
            Repaint();
        }

        void RunDeleteMethod()
        {
            Camera cam = SceneView.currentDrawingSceneView.camera;
            Vector3 mousPos = Event.current.mousePosition;
            Rect mouseRect = new Rect(mousPos.x - deleteRadius, mousPos.y - deleteRadius, deleteRadius * 2f, deleteRadius * 2f);
            for (int i = 0; i < points.Length; i++)
            {
                Vector3 localPos = cam.transform.InverseTransformPoint(points[i].position);
                if (localPos.z < 0f) continue;
                Vector2 screenPos = HandleUtility.WorldToGUIPoint(points[i].position);
                if (mouseRect.Contains(screenPos))
                {
                    if (Vector2.Distance(mousPos, screenPos) <= deleteRadius)
                    {
                        DeletePoint(i);
                        editor.ApplyModifiedProperties(true);
                        i--;
                    }
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/Point Modules/DeletePointModule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/Point Modules/MainPointModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 222164afd4e1e1845bca6b747eca74fb
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using UnityEditor;

    public class MainPointModule : PointModule
    {
        public bool excludeSelected = false;
        public int minimumRectSize = 5;
        private Vector2 _rectStart = Vector2.zero;
        private Vector2 _rectEnd = Vector2.zero;
        private Rect _dragRect;
        private bool _drag = false;
        private bool _finalizeDrag = false;
        private bool _pointsMoved = false;
        private bool _tangentMode = false;
        private Color _bgColor = Color.black;

        public static bool isSelecting => __isDragging;
        private static bool __holdInteraction = false;
        private static bool __isDragging = false;


        public bool isDragging
        {
            get
            {
                return _drag && _dragRect.width >= minimumRectSize && _dragRect.height >= minimumRectSize;
            }
        }

        public bool tangentMode => _tangentMode;

        public MainPointModule(SplineEditor editor) : base(editor)
        {
            _bgColor = Color.Lerp(color, Color.black, 0.75f);
            _bgColor.a = 0.75f;
        }

        public static void HoldInteraction()
        {
            __holdInteraction = true;
        }

        protected override void OnDrawInspector()
        {
            string[] options = new string[points.Length + 4];
            options[0] = "- - -";
            if (selectedPoints.Count > 1) options[0] = "- Multiple -";
            options[1] = "All";
            options[2] = "None";
            options[3] = "Inverse";
            for (int i = 0; i < points.Length; i++)
            {
                options[i + 4] = "Point " + (i + 1);
                if (splineType == Spline.Type.Bezier)
                {
                    switch (points[i].type)
                    {
                        case SplinePoint.Type.Broken: options[i + 4] += " - Broken"; break;
                        case SplinePoint.Type.SmoothFree: options[i + 4] += " - Smooth Free"; break;
                        case SplinePoint.Type.SmoothMirrored: options[i + 4] += " - Smooth Mirrored"; break;
                    }
                }
            }
            int option = 0;
            if (selectedPoints.Count == 1) {
                option = selectedPoints[0] + 4;
            }
            option = EditorGUILayout.Popup("Select", option, options);
            switch (option)
            {
                case 1:
                    ClearSelection();
                    for (int i = 0; i < points.Length; i++) AddPointSelection(i);
                    break;

                case 2:
                    ClearSelection();
                    break;

                case 3:
                    InverseSelection();
                    break;
            }
            if(option >= 4)
            {
                SelectPoint(option - 4);
            }

            if (isDragging)
            {
                if (!eventModule.mouseLeft)
                {
                    FinishDrag();
                }
            }
        }

        protected override void OnDrawScene()
        {
            if (eventModule.v) return;
            Transform camTransform = SceneView.currentDrawingSceneView.camera.transform;
            if (!_drag)
            {
                if (_finalizeDrag)
                {
                    if (_dragRect.width > 0f && _dragRect.height > 0f)
                    {
                        if (!eventModule.control) ClearSelection();
                        for (int i = 0; i < points.Length; i++)
                        {
                            Vector2 guiPoint = HandleUtility.WorldToGUIPoint(points[i].position);
                            if (_dragRect.Contains(guiPoint))
                            {
                                Vector3 local = camTransform.InverseTransformPoint(points[i].position);
                                if (local.z >= 0f)
                                {
                                    AddPointSelection(i);
                                }
                            }
                        }
                    }
                    _finalizeDrag = false;
                }
            }
            else
            {
                if (__holdInteraction)
                {
                    CancelDrag();
                }
                else
                {
                    _rectEnd = Event.current.mousePosition;
                    _dragRect = new Rect(Mathf.Min(_rectStart.x, _rectEnd.x), Mathf.Min(_rectStart.y, _rectEnd.y), Mathf.Abs(_rectEnd.x - _rectStart.x), Mathf.Abs(_rectEnd.y - _rectStart.y));
                    if (_dragRect.width >= minimumRectSize && _dragRect.height >= minimumRectSize)
                    {
                        Color col = highlightColor;
                        col.a = 0.4f;
                        Handles.BeginGUI();
                        EditorGUI.DrawRect(_dragRect, col);
                        Handles.EndGUI();
                        SceneView.RepaintAll();
                    }
                }
            }
            TextAnchor originalAlignment = GUI.skin.label.alignment;
            Color originalColor = GUI.skin.label.normal.textColor;

            GUI.skin.label.alignment = TextAnchor.MiddleCenter;
            GUI.skin.label.normal.textColor = color;

            if (selectedPoints.Count > 1)
            {
                _tangentMode = false;
            }

            for (int i = 0; i < points.Length; i++)
            {
                bool isSelected = selectedPoints.Contains(i);
                Vector3 lastPos = points[i].position;

                if (splineType == Spline.Type.Bezier && isSelected)
                {
                    Handles.color = color;


                    if (Event.current.type == EventType.Repaint)
                        Handles.DrawDottedLine(points[i].position, points[i].tangent, 4f);
                    if (Event.current.type == EventType.Repaint)
                        Handles.DrawDottedLine(points[i].position, points[i].tangent2, 4f);

                    if (_tangentMode && selectedPoints.Count == 1)
                    {
                        Handles.color = highlightColor;
                    }

                    Vector3 lastTangentPos = points[i].tangent;
                    
                    Vector3 newPos = SplineEditorHandles.FreeMoveCircle(points[i].tangent, HandleUtility.GetHandleSize(points[i].tangent) * 0.22f);
                    if (lastTangentPos != newPos)
                    {
                        points[i].SetTangentPosition(newPos);
                        RegisterChange();
                    }
                    lastTangentPos = points[i].tangent2;
                    newPos = SplineEditorHandles.FreeMoveCircle(points[i].tangent2, HandleUtility.GetHandleSize(points[i].tangent2) * 0.22f);
                    if (!__holdInteraction && lastTangentPos != newPos)
                    {
                        points[i].SetTangent2Position(newPos);
                        RegisterChange();
                    }

                    Handles.color = color;
                }
                
                Handles.color = Color.clear;

                if (showPointNumbers && camTransform.InverseTransformPoint(points[i].position).z > 0f)
                {
                    if(Event.current.type == EventType.Repaint)
                    {
                        Handles.Label(points[i].position + Camera.current.transform.up * HandleUtility.GetHandleSize(points[i].position) * 0.3f, (i + 1).ToString());
                    }
                }
                if (!eventModule.alt && !__holdInteraction)
                {
                    if (excludeSelected && isSelected)
                    {

                        SplineEditorHandles.FreeMoveRectangle(points[i].position, HandleUtility.GetHandleSize(points[i].position) * 0.1f);
                    }
                    else
                    {
                        points[i].SetPosition(SplineEditorHandles.FreeMoveRectangle(points[i].position, HandleUtility.GetHandleSize(points[i].position) * 0.1f));
                    }
                }

                if (!__holdInteraction && lastPos != points[i].position)
                {
                    _tangentMode = false;
                    _pointsMoved = true;
                    if (isSelected)
                    {
                        for (int n = 0; n < selectedPoints.Count; n++)
                        {
                            if (selectedPoints[n] == i) continue;
                            points[selectedPoints[n]].SetPosition(points[selectedPoints[n]].position + (points[i].position - lastPos));
                        }
                    }
                    else
                    {
                        SelectPoint(i);
                    }
                    RegisterChange();
                }

                if (!_pointsMoved && !eventModule.alt && editor.eventModule.mouseLeftUp)
                {
                    if(SplineEditorHandles.HoverArea(points[i].position, 0.12f))
                    {
                        if (eventModule.control && selectedPoints.Contains(i))
                        {
                            DeselectPoint(i);
                        }
                        else
                        {
                            if (eventModule.shift) ShiftSelect(i, points.Length);
                            else if (eventModule.control) AddPointSelection(i);
                            else SelectPoint(i);
                        }
                        _tangentMode = false;
                    } else if(splineType == Spline.Type.Bezier)
                    {
                        if (SplineEditorHandles.HoverArea(points[i].tangent, 0.23f))
                        {
                            if (eventModule.shift) ShiftSelect(i, points.Length);
                            else if (eventModule.control) AddPointSelection(i);
                            else SelectPoint(i);
                            _tangentMode = true;
                        }
                    }
                }

                if (!excludeSelected || !isSelected)
                {
                    if (Event.current.type == EventType.Repaint)
                    {
                        SplineEditorHandles.DrawPoint(points[i].position, isSelected && (!_tangentMode || selectedPoints.Count != 1));
                    }
                }
            }
            GUI.skin.label.alignment = originalAlignment;
            GUI.skin.label.normal.textColor = originalColor;

            if (isDragging && Event.current.type == EventType.MouseDrag)
            {
                bool mouseIsOutside = false;
#if UNITY_2022_1_OR_NEWER
                Vector2 mousePos = Event.current.mousePosition;
                Vector2 viewportSize = new Vector2(_currentSceneView.position.width, _currentSceneView.position.height);
                mouseIsOutside = mousePos.x <= 0 || mousePos.y <= 0f || mousePos.x >= viewportSize.x || mousePos.y >= viewportSize.y;
#else
                mouseIsOutside = !SceneView.currentDrawingSceneView.camera.pixelRect.Contains(Event.current.mousePosition);
#endif
                if (eventModule.alt || mouseIsOutside || !eventModule.mouseLeft)
                {
                    FinishDrag();
                }
            }

            if (eventModule.mouseLeftUp)
            {
                _pointsMoved = false;
            }

            __holdInteraction = false;

            __isDragging = isDragging;
        }

        void ShiftSelect(int index, int pointCount)
        {
            if (selectedPoints.Count == 0)
            {
                AddPointSelection(index);
                return;
            }
            int minSelected = pointCount-1, maxSelected = 0;
            for (int i = 0; i < selectedPoints.Count; i++)
            {
                if (minSelected > selectedPoints[i]) minSelected = selectedPoints[i];
                if (maxSelected < selectedPoints[i]) maxSelected = selectedPoints[i];
            }

            if(index > maxSelected)
            {
                for (int i = maxSelected + 1; i <= index; i++) AddPointSelection(i);
            } else if(index < minSelected)
            {
                for (int i = minSelected-1; i >= index; i--) AddPointSelection(i);
            } else
            {
                for (int i = minSelected + 1; i <= index; i++) AddPointSelection(i);
            }
        }

        public void StartDrag(Vector2 position)
        {
            if (__holdInteraction) return;
            _rectStart = position;
            _drag = true;
            _finalizeDrag = false;
        }

        public void FinishDrag()
        {
            if (!_drag) return;
            _drag = false;
            _finalizeDrag = true;
        }

        public void CancelDrag()
        {
            _drag = false;
            _finalizeDrag = false;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/Point Modules/MainPointModule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/Point Modules/PointMirrorModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 0562a8339f410c04180d98ba21fdafb3
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using System.Collections.Generic;
    using UnityEditor;

    public class PointMirrorModule : PointTransformModule
    {
        public enum Axis { X, Y, Z }
        public Axis axis = Axis.X;
        public bool flip = false;
        public float weldDistance = 0f;
        Vector3 mirrorCenter = Vector3.zero;


        private SplinePoint[] mirrored = new SplinePoint[0];


        public PointMirrorModule(SplineEditor editor) : base(editor)
        {
            LoadState();
        }

        public override GUIContent GetIconOff()
        {
            return IconContent("||", "mirror", "Mirror Path");
        }

        public override GUIContent GetIconOn()
        {
            return IconContent("||", "mirror_on", "Mirror Path");
        }

        public override void LoadState()
        {
            axis = (Axis)LoadInt("axis");
            flip = LoadBool("flip");
            weldDistance = LoadFloat("weldDistance");
        }

        public override void SaveState()
        {
            base.SaveState();
            SaveInt("axis", (int)axis);
            SaveBool("flip", flip);
            SaveFloat("weldDistance", weldDistance);
        }

        public override void Select()
        {
            base.Select();
            ClearSelection();
            DoMirror();
            SetDirty();
        }

        public override void Deselect()
        {
            if (IsDirty())
            {
                if (EditorUtility.DisplayDialog("Unapplied Mirror Operation", "There is an unapplied mirror operation. Do you want to apply the changes?", "Apply", "Revert"))
                {
                    Apply();
                }
                else
                {
                    Revert();
                }
            }
            base.Deselect();
        }

        protected override void OnDrawInspector()
        {
            if (selectedPoints.Count > 0) ClearSelection();
            EditorGUI.BeginChangeCheck();
            axis = (Axis)EditorGUILayout.EnumPopup("Axis", axis);
            flip = EditorGUILayout.Toggle("Flip", flip);
            weldDistance = EditorGUILayout.FloatField("Weld Distance", weldDistance);
            mirrorCenter = EditorGUILayout.Vector3Field("Center", mirrorCenter);
            if (EditorGUI.EndChangeCheck()) DoMirror();
            if (IsDirty())
            {
                EditorGUILayout.BeginHorizontal();
                if (GUILayout.Button("Apply")) Apply();
                if (GUILayout.Button("Revert")) Revert();
                EditorGUILayout.EndHorizontal();
            }
        }

        protected override void OnDrawScene()
        {
            if (selectedPoints.Count > 0) ClearSelection();
            Vector3 worldCenter = TransformPosition(mirrorCenter);
            Vector3 lastCenter = worldCenter;
            worldCenter = Handles.PositionHandle(worldCenter, rotation);
            mirrorCenter = InverseTransformPosition(worldCenter);
            DrawMirror();
            if (lastCenter != worldCenter) DoMirror();
            selectedPoints.Clear();
        }

        public void DoMirror()
        {
            List<int> half = GetHalf(ref originalPoints);
            int welded = -1;
            if (half.Count > 0)
            {
                if (flip)
                {
                    if (IsWeldable(originalPoints[half[0]]))
                    {
                        welded = half[0];
                        half.RemoveAt(0);
                    }
                }
                else
                {
                    if (IsWeldable(originalPoints[half[half.Count - 1]]))
                    {
                        welded = half[half.Count - 1];
                        half.RemoveAt(half.Count - 1);
                    }
                }

                int offset = welded >= 0 ? 1 : 0;
                int mirroredLength = half.Count * 2 + offset;
                if(mirrored.Length != mirroredLength) mirrored = new SplinePoint[mirroredLength];
                for (int i = 0; i < half.Count; i++)
                {
                    if (flip)
                    {
                        mirrored[i] = new SplinePoint(originalPoints[half[(half.Count - 1) - i]]);
                        mirrored[i + half.Count + offset] = GetMirrored(originalPoints[half[i]]);
                        SwapTangents(ref mirrored[i]);
                        SwapTangents(ref mirrored[i + half.Count + offset]);
                    }
                    else
                    {
                        mirrored[i] = new SplinePoint(originalPoints[half[i]]);
                        mirrored[i + half.Count + offset] = GetMirrored(originalPoints[half[(half.Count - 1) - i]]);
                    }
                }
                if (welded >= 0)
                {
                    mirrored[half.Count] = new SplinePoint(originalPoints[welded]);
                    if (flip) SwapTangents(ref mirrored[half.Count]);
                    MakeMiddlePoint(ref mirrored[half.Count]);
                }

                if (isClosed && mirrored.Length > 0)
                {
                    MakeMiddlePoint(ref mirrored[0]);
                    mirrored[mirrored.Length - 1] = new SplinePoint(mirrored[0]);
                }
            }
            else mirrored = new SplinePoint[0];
            editor.SetPointsArray(mirrored);
            RegisterChange();
            SetDirty();
        }

        void SwapTangents(ref SplinePoint point)
        {
            Vector3 temp = point.tangent;
            point.tangent = point.tangent2;
            point.tangent2 = temp;
        }

        void MakeMiddlePoint(ref SplinePoint point)
        {
            point.type = SplinePoint.Type.Broken;
            InverseTransformPoint(ref point);
            Vector3 newPos = point.position;
            switch (axis)
            {
                case Axis.X:
                   
                    newPos.x = mirrorCenter.x;
                    point.SetPosition(newPos);
                    if ((point.tangent.x >= mirrorCenter.x && flip) || (point.tangent.x <= mirrorCenter.x && !flip))
                    {
                        point.tangent2 = point.tangent;
                        point.SetTangent2X(point.position.x + (point.position.x - point.tangent.x));
                    }
                    else
                    {
                        point.tangent = point.tangent2;
                        point.SetTangentX(point.position.x + (point.position.x - point.tangent2.x));
                    }
                    break;
                case Axis.Y:
                    newPos.y = mirrorCenter.y;
                    point.SetPosition(newPos);
                    if ((point.tangent.y >= mirrorCenter.y && flip) || (point.tangent.y <= mirrorCenter.y && !flip))
                    {
                        point.tangent2 = point.tangent;
                        point.SetTangent2Y(point.position.y + (point.position.y - point.tangent.y));
                    }
                    else
                    {
                        point.tangent = point.tangent2;
                        point.SetTangentY(point.position.y + (point.position.y - point.tangent2.y));
                    }
                    break;
                case Axis.Z:
                    newPos.z = mirrorCenter.z;
                    point.SetPosition(newPos);
                    if ((point.tangent.z >= mirrorCenter.z && flip) || (point.tangent.z <= mirrorCenter.z && !flip))
                    {
                        point.tangent2 = point.tangent;
                        point.SetTangent2Z(point.position.z + (point.position.z - point.tangent.z));
                    }
                    else
                    {
                        point.tangent = point.tangent2;
                        point.SetTangentZ(point.position.z + (point.position.z - point.tangent2.z));
                    }
                    break;
            }
            TransformPoint(ref point);
        }

        bool IsWeldable(SplinePoint point)
        {
            switch (axis)
            {
                case Axis.X:
                    if (Mathf.Abs(point.position.x - mirrorCenter.x) <= weldDistance) return true;
                    break;
                case Axis.Y:
                    if (Mathf.Abs(point.position.y - mirrorCenter.y) <= weldDistance) return true;
                    break;
                case Axis.Z:
                    if (Mathf.Abs(point.position.z - mirrorCenter.z) <= weldDistance) return true;
                    break;
            }
            return false;
        }

        void DrawMirror()
        {
            Vector3[] points = new Vector3[4];
            Color color = Color.white;
            Vector3 worldCenter = TransformPosition(mirrorCenter);
            float size = HandleUtility.GetHandleSize(worldCenter);
            Vector3 forward = rotation * Vector3.forward * size;
            Vector3 back = -forward;
            Vector3 right = rotation * Vector3.right * size;
            Vector3 left = -right;
            Vector3 up = rotation * Vector3.up * size;
            Vector3 down = -up;
            switch (axis)
            {
                case Axis.X:
                    points[0] = back + up;
                    points[1] = forward + up;
                    points[2] = forward + down;
                    points[3] = back + down;
                    color = Color.red;
                    break;
                case Axis.Y:
                    points[0] = back + left;
                    points[1] = forward + left;
                    points[2] = forward + right;
                    points[3] = back + right;
                    color = Color.green;
                    break;
                case Axis.Z:
                    points[0] = left + up;
                    points[1] = right + up;
                    points[2] = right + down;
                    points[3] = left + down;
                    color = Color.blue;
                    break;
            }
            Handles.color = color;
            Handles.DrawLine(worldCenter + points[0], worldCenter + points[1]);
            Handles.DrawLine(worldCenter + points[1], worldCenter + points[2]);
            Handles.DrawLine(worldCenter + points[2], worldCenter + points[3]);
            Handles.DrawLine(worldCenter + points[3], worldCenter + points[0]);
            Handles.color = Color.white;
        }

        SplinePoint GetMirrored(SplinePoint source)
        {
            SplinePoint newPoint = new SplinePoint(source);
            InverseTransformPoint(ref newPoint);
            switch (axis)
            {
                case Axis.X:
                    newPoint.SetPositionX(mirrorCenter.x - (newPoint.position.x - mirrorCenter.x));
                    newPoint.SetNormalX(-newPoint.normal.x);
                    newPoint.SetTangentX(mirrorCenter.x - (newPoint.tangent.x - mirrorCenter.x));
                    newPoint.SetTangent2X(mirrorCenter.x - (newPoint.tangent2.x - mirrorCenter.x));
                    break;
                case Axis.Y:
                    newPoint.SetPositionY(mirrorCenter.y - (newPoint.position.y - mirrorCenter.y));
                    newPoint.SetNormalY(-newPoint.normal.y);
                    newPoint.SetTangentY(mirrorCenter.y - (newPoint.tangent.y - mirrorCenter.y));
                    newPoint.SetTangent2Y(mirrorCenter.y - (newPoint.tangent2.y - mirrorCenter.y));
                    break;
                case Axis.Z:
                    newPoint.SetPositionZ(mirrorCenter.z - (newPoint.position.z - mirrorCenter.z));
                    newPoint.SetNormalZ(-newPoint.normal.z);
                    newPoint.SetTangentZ(mirrorCenter.z - (newPoint.tangent.z - mirrorCenter.z));
                    newPoint.SetTangent2Z(mirrorCenter.z - (newPoint.tangent2.z - mirrorCenter.z));
                    break;
            }
            SwapTangents(ref newPoint);
            TransformPoint(ref newPoint);
            return newPoint;
        }



        List<int> GetHalf(ref SplinePoint[] points)
        {
            List<int> found = new List<int>();
            switch (axis)
            {
                case Axis.X:

                    for (int i = 0; i < points.Length; i++)
                    {
                        if (flip)
                        {
                            if (InverseTransformPosition(points[i].position).x >= mirrorCenter.x) found.Add(i);
                        }
                        else
                        {
                            if (InverseTransformPosition(points[i].position).x <= mirrorCenter.x) found.Add(i);
                        }
                    }
                    break;

                case Axis.Y:
                    for (int i = 0; i < points.Length; i++)
                    {
                        if (flip)
                        {
                            if (InverseTransformPosition(points[i].position).y >= mirrorCenter.y) found.Add(i);
                            else
                            {
                                if (InverseTransformPosition(points[i].position).y <= mirrorCenter.y) found.Add(i);
                            }
                        }
                    }
                    break;
                case Axis.Z:
                    for (int i = 0; i < points.Length; i++)
                    {
                        if (flip)
                        {
                            if (InverseTransformPosition(points[i].position).z >= mirrorCenter.z) found.Add(i);
                        }
                        else
                        {
                            if (InverseTransformPosition(points[i].position).z <= mirrorCenter.z) found.Add(i);
                        }
                    }
                    break;
            }
            return found;
        }



    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/Point Modules/PointMirrorModule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/Point Modules/PointModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b030b7d8eb93a004185129c729549ba8
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using UnityEditor;
    using System.Collections.Generic;

    public class PointModule : EditorModule
    {
        protected bool isClosed
        {
            get { return editor.GetSplineClosed(); }
        }
        protected int sampleRate
        {
            get { return editor.GetSplineSampleRate(); }
        }
        protected Spline.Type splineType
        {
            get { return editor.GetSplineType(); }
        }
        protected Color color {
            get { return editor.drawColor; }
        }
        protected SplineEditor editor;

        protected SerializedSplinePoint[] points {
            get { return editor.points; }    
            set { editor.points = value; }    
        }

        protected List<int> selectedPoints
        {
            get { return editor.selectedPoints; }
            set { editor.selectedPoints = value; }
        }

        public Vector3 center
        {
            get
            {
                Vector3 avg = Vector3.zero;
                if (points.Length == 0) return avg;
                for (int i = 0; i < points.Length; i++) avg += points[i].position;
                return avg / points.Length;
            }
        }

        public Vector3 selectionCenter
        {
            get
            {
                Vector3 avg = Vector3.zero;
                if (selectedPoints.Count == 0) return avg;
                for (int i = 0; i < selectedPoints.Count; i++) avg += points[selectedPoints[i]].position;
                return avg / selectedPoints.Count;
            }
        }

        protected EditorGUIEvents eventModule;

        public delegate void UndoHandler(string title);
        public delegate void EmptyHandler();
        public delegate void IntHandler(int value);
        public delegate void IntArrayHandler(int[] values);

        public Spline.Direction duplicationDirection = Spline.Direction.Forward;
        public Color highlightColor = Color.white;
        public bool showPointNumbers = false;

        public event EmptyHandler onBeforeDeleteSelectedPoints;
        public event EmptyHandler onSelectionChanged;
        public event IntArrayHandler onDuplicatePoint;

        private bool movePivot = false;
        private Vector3 idealPivot = Vector3.zero;

        

        public PointModule(SplineEditor editor)
        {
            this.editor = editor;
            eventModule = editor.eventModule;
        }

        protected override void RecordUndo(string title)
        {
            if (editor.undoHandler != null) editor.undoHandler(title);
        }

        protected override void Repaint()
        {
            if (editor.repaintHandler != null) editor.repaintHandler();
        }

        public override void BeforeSceneDraw(SceneView current)
        {
            base.BeforeSceneDraw(current);
            Event e = Event.current;

            if (movePivot)
            {
                SceneView.lastActiveSceneView.pivot = Vector3.Lerp(SceneView.lastActiveSceneView.pivot, idealPivot, 0.02f);
                if (e.type == EventType.MouseDown || e.type == EventType.MouseUp) movePivot = false;
                if (Vector3.Distance(SceneView.lastActiveSceneView.pivot, idealPivot) <= 0.05f)
                {
                    SceneView.lastActiveSceneView.pivot = idealPivot;
                    movePivot = false;
                }
            }

            if (e.type == EventType.KeyDown && e.keyCode == KeyCode.Delete && HasSelection())
            {
                DeleteSelectedPoints();
                e.Use();
            }

            if(e.type == EventType.ExecuteCommand && Tools.current == Tool.None)
            {
                switch (e.commandName)
                {
                    case "FrameSelected":
                        if (points.Length > 0)
                        {
                            e.commandName = "";
                            FramePoints();
                            e.Use();
                        }
                        break;
                    case "SelectAll":
                        e.commandName = "";
                        ClearSelection();
                        for (int i = 0; i < points.Length; i++)
                        {
                            AddPointSelection(i);
                        }
                        e.Use();
                        break;

                    case "Duplicate":
                        if (points.Length > 0 && selectedPoints.Count > 0)
                        {
                            e.commandName = "";
                            DuplicateSelected();
                            e.Use();
                        }
                        break;
                }
            }
        }

        public virtual void DuplicateSelected()
        {
            if (selectedPoints.Count == 0) return;
            SplinePoint[] newPoints = new SplinePoint[points.Length + selectedPoints.Count];
            SplinePoint[] duplicated = new SplinePoint[selectedPoints.Count];
            editor.SetPointsCount(newPoints.Length);
            int index = 0;
            for (int i = 0; i < selectedPoints.Count; i++) duplicated[index++] = points[selectedPoints[i]].CreateSplinePoint();
            int min = points.Length - 1, max = 0;
            for (int i = 0; i < selectedPoints.Count; i++)
            {
                if (selectedPoints[i] < min) min = selectedPoints[i];
                if (selectedPoints[i] > max) max = selectedPoints[i];
            }
            int[] selected = selectedPoints.ToArray();
            selectedPoints.Clear();
            if (duplicationDirection == Spline.Direction.Backward)
            {
                for (int i = 0; i < min; i++) newPoints[i] = points[i].CreateSplinePoint();
                for (int i = 0; i < duplicated.Length; i++)
                {
                    newPoints[i + min] = duplicated[i];
                    selectedPoints.Add(i + min);
                }
                for (int i = min; i < points.Length; i++) newPoints[i + duplicated.Length] = points[i].CreateSplinePoint();
            }
            else
            {
                for (int i = 0; i <= max; i++) newPoints[i] = points[i].CreateSplinePoint();
                for (int i = 0; i < duplicated.Length; i++)
                {
                    newPoints[i + max + 1] = duplicated[i];
                    selectedPoints.Add(i + max + 1);
                }
                for (int i = max + 1; i < points.Length; i++) newPoints[i + duplicated.Length] = points[i].CreateSplinePoint();
            }
            editor.SetPointsArray(newPoints);
            RegisterChange();
            if (onDuplicatePoint != null) onDuplicatePoint(selected);
        }

        public virtual void Reset()
        {
        }

        public bool HasSelection()
        {
            return selectedPoints.Count > 0;
        }

        public void ClearSelection()
        {
            selectedPoints.Clear();
            Repaint();
            if (editor.selectionChangeHandler != null) editor.selectionChangeHandler();
            if (onSelectionChanged != null) onSelectionChanged();
        }

        protected void DeleteSelectedPoints()
        {
            if (onBeforeDeleteSelectedPoints != null)
            {
                onBeforeDeleteSelectedPoints();
            }

            for (int i = 0; i < selectedPoints.Count; i++)
            {
                DeletePoint(selectedPoints[i]);
                for (int n = i; n < selectedPoints.Count; n++)
                {
                    selectedPoints[n]--;
                }
            }
            ClearSelection();
            RegisterChange();
            editor.ApplyModifiedProperties(true);
        }

        protected void DeletePoint(int index)
        {
            editor.DeletePoint(index);
            RegisterChange();
        }


        public void InverseSelection()
        {
            List<int> inverse = new List<int>();
            for (int i = 0; i < (isClosed ? points.Length - 1 : points.Length); i++)
            {
                bool found = false;
                for (int j = 0; j < selectedPoints.Count; j++)
                {
                    if (selectedPoints[j] == i)
                    {
                        found = true;
                        break;
                    }
                }
                if (!found) inverse.Add(i);
            }
            selectedPoints = new List<int>(inverse);
            Repaint();
            if (editor.selectionChangeHandler != null) editor.selectionChangeHandler();
            if (onSelectionChanged != null) onSelectionChanged();
        }

        protected void SelectPoint(int index)
        {
            if (selectedPoints.Count == 1 && selectedPoints[0] == index) return;
            selectedPoints.Clear();
            selectedPoints.Add(index);
            Repaint();
            if (editor.selectionChangeHandler != null) editor.selectionChangeHandler();
            if (onSelectionChanged != null) onSelectionChanged();
        }

        protected void DeselectPoint(int index)
        {
            if (selectedPoints.Contains(index))
            {
                selectedPoints.Remove(index);
                Repaint();
                if (editor.selectionChangeHandler != null) editor.selectionChangeHandler();
                if (onSelectionChanged != null) onSelectionChanged();
            }
        }

        protected void SelectPoints(List<int> indices)
        {
            selectedPoints.Clear();
            for (int i = 0; i < indices.Count; i++)
            {
                selectedPoints.Add(indices[i]);
            }
            Repaint();
            if (editor.selectionChangeHandler != null) editor.selectionChangeHandler();
            if (onSelectionChanged != null) onSelectionChanged();
        }

        protected void AddPointSelection(int index)
        {
            if (selectedPoints.Contains(index)) return;
            selectedPoints.Add(index);
            Repaint();
            if (editor.selectionChangeHandler != null) editor.selectionChangeHandler();
            if (onSelectionChanged != null) onSelectionChanged();
        }

        protected void FramePoints()
        {
            if (points.Length == 0) return;
            Vector3 center = Vector3.zero;
            Camera camera = SceneView.lastActiveSceneView.camera;
            Transform cam = camera.transform;
            Vector3 min = Vector3.zero, max = Vector3.zero;
            if (HasSelection())
            {
                for (int i = 0; i < selectedPoints.Count; i++)
                {
                    center += points[selectedPoints[i]].position;
                    Vector3 local = cam.InverseTransformPoint(points[selectedPoints[i]].position);
                    if (local.x < min.x) min.x = local.x;
                    if (local.y < min.y) min.y = local.y;
                    if (local.z < min.z) min.z = local.z;
                    if (local.x > max.x) max.x = local.x;
                    if (local.y > max.y) max.y = local.y;
                    if (local.z > max.z) max.z = local.z;
                }
                center /= selectedPoints.Count;
            }
            else
            {
                for (int i = 0; i < points.Length; i++)
                {
                    center += points[i].position;
                    Vector3 local = cam.InverseTransformPoint(points[i].position);
                    if (local.x < min.x) min.x = local.x;
                    if (local.y < min.y) min.y = local.y;
                    if (local.z < min.z) min.z = local.z;
                    if (local.x > max.x) max.x = local.x;
                    if (local.y > max.y) max.y = local.y;
                    if (local.z > max.z) max.z = local.z;
                }
                center /= points.Length;
            }
            movePivot = true;
            idealPivot = center;
        }

        
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/Point Modules/PointModule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/Point Modules/PointMoveModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 37e5af750f2ba6a49bd760d3a39d1309
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using UnityEditor;
    using System.Collections;
    using System.Collections.Generic;

    public class PointMoveModule : PointTransformModule
    {
        public bool snap = false;
        public float snapGridSize = 1f;
        public bool surfaceMode = false;
        public float surfaceOffset = 0f;
        public LayerMask surfaceLayerMask = ~0;

        private bool useTangentHandles => editor.mainModule.tangentMode || editor.selectedPoints.Count != 1;

        public PointMoveModule(SplineEditor editor) : base(editor)
        {

        }

        public override GUIContent GetIconOff()
        {
            return EditorGUIUtility.IconContent("MoveTool");
        }

        public override GUIContent GetIconOn()
        {
            return EditorGUIUtility.IconContent("MoveTool On");
        }

        public override void LoadState()
        {
            base.LoadState();
            snap = LoadBool("snap");
            snapGridSize = LoadFloat("snapGridSize", 0.5f);
            surfaceOffset = LoadFloat("surfaceOffset", 0f);
            surfaceMode = LoadBool("surfaceMode");
            surfaceLayerMask = LoadInt("surfaceLayerMask", ~0);
        }

        public override void SaveState()
        {
            base.SaveState();
            SaveBool("snap", snap);
            SaveFloat("snapGridSize", snapGridSize);
            SaveFloat("surfaceOffset", surfaceOffset);
            SaveBool("surfaceMode", surfaceMode);
            SaveInt("surfaceLayerMask", surfaceLayerMask);
        }

        public override void BeforeSceneDraw(SceneView current)
        {
            base.BeforeSceneDraw(current);
            if (Event.current.type == EventType.MouseUp) GetRotation();
        }

        protected override void OnDrawInspector()
        {
            editSpace = (EditSpace)EditorGUILayout.EnumPopup("Edit Space", editSpace);
            surfaceMode = EditorGUILayout.Toggle("Move On Surface", surfaceMode);
            if (surfaceMode)
            {
                surfaceLayerMask = DreamteckEditorGUI.LayermaskField("Surface Mask", surfaceLayerMask);
                surfaceOffset = EditorGUILayout.FloatField("Surface Offset", surfaceOffset);
            }
            snap = EditorGUILayout.Toggle("Snap to Grid", snap);
            if (snap)
            {
                snapGridSize = EditorGUILayout.FloatField("Grid Size", snapGridSize);
                if (snapGridSize < 0.0001f) snapGridSize = 0.0001f;
            }
        }

        private Vector3 SurfaceMoveHandle(Vector3 inputPosition, float size = 0.2f)
        {
            Vector3 lastPosition = inputPosition;
            inputPosition = SplineEditorHandles.FreeMoveHandle(inputPosition, HandleUtility.GetHandleSize(inputPosition) * size, Vector3.zero, Handles.CircleHandleCap);
            if (lastPosition != inputPosition)
            {
                Ray ray = HandleUtility.GUIPointToWorldRay(Event.current.mousePosition);
                RaycastHit hit;
                if (Physics.Raycast(ray, out hit, Mathf.Infinity, surfaceLayerMask))
                {
                    inputPosition = hit.point + hit.normal * surfaceOffset;
                    Handles.DrawLine(hit.point, hit.point + hit.normal * HandleUtility.GetHandleSize(hit.point) * 0.5f);
                }
            }
            return inputPosition;
        }

        protected override void OnDrawScene()
        {
            if (selectedPoints.Count == 0) return;
            Vector3 c = selectionCenter;
            Vector3 lastPos = c;
            if (surfaceMode)
            {
                c = SurfaceMoveHandle(c, 0.2f);
            }
            else
            {
                c = Handles.PositionHandle(c, rotation);
            }
            if (lastPos != c)
            {
                RegisterChange();
                for (int i = 0; i < selectedPoints.Count; i++)
                {
                    points[selectedPoints[i]].SetPosition(points[selectedPoints[i]].position + (c - lastPos));
                    if (snap) points[selectedPoints[i]].SetPosition(SnapPoint(points[selectedPoints[i]].position));
                }
            }

            if (splineType == Spline.Type.Bezier && selectedPoints.Count == 1 && useTangentHandles)
            {
                int index = selectedPoints[0];
                lastPos = points[index].tangent;
                Vector3 newPos = Vector3.zero;
                if (surfaceMode)
                {
                    newPos = SurfaceMoveHandle(points[index].tangent, 0.15f);
                } else
                {
                    newPos = Handles.PositionHandle(points[index].tangent, rotation);
                }

                if (snap) newPos = SnapPoint(newPos);
                if (newPos != lastPos)
                {
                    RegisterChange();
                }
                points[index].SetTangentPosition(newPos);

                lastPos = points[index].tangent2;
                if (surfaceMode)
                {
                    newPos = SurfaceMoveHandle(points[index].tangent2, 0.15f);
                } else
                {
                    newPos = Handles.PositionHandle(points[index].tangent2, rotation);
                }
                    
                if (snap) newPos = SnapPoint(newPos);
                if (newPos != lastPos)
                {
                    RegisterChange();
                }
                points[index].SetTangent2Position(newPos);
            }
        }

        public Vector3 SnapPoint(Vector3 point)
        {
            point.x = Mathf.RoundToInt(point.x / snapGridSize) * snapGridSize;
            point.y = Mathf.RoundToInt(point.y / snapGridSize) * snapGridSize;
            point.z = Mathf.RoundToInt(point.z / snapGridSize) * snapGridSize;
            return point;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/Point Modules/PointMoveModule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/Point Modules/PointNormalModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f9bb1bdae9d59a748a61453d1696598f
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using UnityEditor;

    public class PointNormalModule : PointModule
    {
        public enum NormalMode { Auto, Free }
        public NormalMode normalMode = NormalMode.Auto;
        SplineSample evalResult = new SplineSample();

        private string[] _normalOperations = new string[0];
        private int _normalOperation = 0;

        private NormalRotationWindow _rotationWindow;

        public PointNormalModule(SplineEditor editor) : base(editor)
        {
            _normalOperations = new string[] { "Flip",
                "Look At Camera",
                "Align with Camera",
                "Calculate",
                "Look Left",
                "Look Right",
                "Look Up",
                "Look Down",
                "Look Forward",
                "Look Back",
                "Look At Avg. Center",
                "Perpendicular to Spline",
                "Rotate Degrees"
            };
        }

        public override void LoadState()
        {
            base.LoadState();
            normalMode = (NormalMode)LoadInt("normalMode");
            _normalOperation = LoadInt("normalOperation");
        }

        public override void SaveState()
        {
            base.SaveState();
            SaveInt("normalMode", (int)normalMode);
            SaveInt("normalOperation", (int)_normalOperation);
            if (_rotationWindow != null)
            {
                _rotationWindow.Close();
            }
        }

        public override GUIContent GetIconOff()
        {
            return IconContent("N", "normal", "Set Point Normals");
        }

        public override GUIContent GetIconOn()
        {
            return IconContent("N", "normal_on", "Set Point Normals");
        }

        private void OnNormalRotationApplied()
        {
            editor.ApplyModifiedProperties(true);
            RegisterChange();
            SceneView.RepaintAll();
        }

        void SetNormals(int mode)
        {
            if (mode == 12)
            {
                _rotationWindow = EditorWindow.GetWindow<NormalRotationWindow>(true);
                _rotationWindow.Init(this, OnNormalRotationApplied);
                return;
            }

            Vector3 avg = Vector3.zero;
            for (int i = 0; i < selectedPoints.Count; i++) avg += points[selectedPoints[i]].position;
            if (selectedPoints.Count > 1) avg /= selectedPoints.Count;
            Camera editorCamera = SceneView.lastActiveSceneView.camera;

            for (int i = 0; i < selectedPoints.Count; i++)
            {
                switch (mode)
                {
                    case 0: points[selectedPoints[i]].normal *= -1; break;
                    case 1: points[selectedPoints[i]].normal = Vector3.Normalize(editorCamera.transform.position - points[selectedPoints[i]].position); break;
                    case 2: points[selectedPoints[i]].normal = editorCamera.transform.forward; break;
                    case 3: points[selectedPoints[i]].normal = CalculatePointNormal(points, selectedPoints[i], isClosed); break;
                    case 4: points[selectedPoints[i]].normal = Vector3.left; break;
                    case 5: points[selectedPoints[i]].normal = Vector3.right; break;
                    case 6: points[selectedPoints[i]].normal = Vector3.up; break;
                    case 7: points[selectedPoints[i]].normal = Vector3.down; break;
                    case 8: points[selectedPoints[i]].normal = Vector3.forward; break;
                    case 9: points[selectedPoints[i]].normal = Vector3.back; break;
                    case 10: points[selectedPoints[i]].normal = Vector3.Normalize(avg - points[selectedPoints[i]].position); break;
                    case 11:
                        SplineSample result = new SplineSample();
                        editor.evaluateAtPoint(selectedPoints[i], ref result);
                        points[selectedPoints[i]].normal = Vector3.Cross(result.forward, result.right).normalized;
                        break;
                }
            }
            RegisterChange();
            SceneView.RepaintAll();
        }

        public static Vector3 CalculatePointNormal(SerializedSplinePoint[] points, int index, bool isClosed)
        {
            if (points.Length < 3)
            {
                Debug.Log("Spline needs to have at least 3 control points in order to calculate normals");
                return Vector3.zero;
            }
            Vector3 side1 = Vector3.zero;
            Vector3 side2 = Vector3.zero;
            if (index == 0)
            {
                if (isClosed)
                {
                    side1 = points[index].position - points[index + 1].position;
                    side2 = points[index].position - points[points.Length - 2].position;
                }
                else
                {
                    side1 = points[0].position - points[1].position;
                    side2 = points[0].position - points[2].position;
                }
            }
            else if (index == points.Length - 1)
            {
                side1 = points[points.Length - 1].position - points[points.Length - 3].position;
                side2 = points[points.Length - 1].position - points[points.Length - 2].position;
            }
            else
            {
                side1 = points[index].position - points[index + 1].position;
                side2 = points[index].position - points[index - 1].position;
            }
            return Vector3.Cross(side1.normalized, side2.normalized).normalized;
        }

        protected override void OnDrawInspector()
        {
            if (editor.is2D)
            {
                EditorGUILayout.LabelField("Normal editing unavailable in 2D Mode", EditorStyles.centeredGreyMiniLabel);
                return;
            }
            normalMode = (NormalMode)EditorGUILayout.EnumPopup("Normal Mode", normalMode);



            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("Normal Operations");

            EditorGUILayout.BeginVertical();

            _normalOperation = EditorGUILayout.Popup(_normalOperation, _normalOperations);
            if (GUILayout.Button("Apply"))
            {
                SetNormals(_normalOperation);
            }
            EditorGUILayout.EndVertical();

            EditorGUILayout.EndHorizontal();
        }

        protected override void OnDrawScene()
        {
            if (editor.is2D) return;
            for (int i = 0; i < selectedPoints.Count; i++)
            {
                if (normalMode == NormalMode.Free) FreeNormal(selectedPoints[i]);
                else AutoNormal(selectedPoints[i]);
            }
        }

        void AutoNormal(int index)
        {
            editor.evaluateAtPoint(index, ref evalResult);
            Handles.color = highlightColor;
            Handles.DrawWireDisc(points[index].position, evalResult.forward, HandleUtility.GetHandleSize(points[index].position) * 0.5f);
            Handles.color = color;
            Matrix4x4 matrix = Matrix4x4.TRS(points[index].position, evalResult.rotation, Vector3.one);
            Vector3 pos = points[index].position + points[index].normal * HandleUtility.GetHandleSize(points[index].position) * 0.5f;
            Handles.DrawLine(points[index].position, pos);
            Vector3 lastPos = pos;
            Vector3 lastLocalPos = matrix.inverse.MultiplyPoint(pos);
            pos = SplineEditorHandles.FreeMoveHandle(pos, HandleUtility.GetHandleSize(pos) * 0.1f, Vector3.zero, Handles.CircleHandleCap);
            if (pos != lastPos)
            {
                pos = matrix.inverse.MultiplyPoint(pos);
                Vector3 delta = pos - lastLocalPos;
                for (int n = 0; n < selectedPoints.Count; n++)
                {
                    if (selectedPoints[n] == index) continue;
                    editor.evaluateAtPoint(selectedPoints[n], ref evalResult);
                    Matrix4x4 localMatrix = Matrix4x4.TRS(points[selectedPoints[n]].position, evalResult.rotation, Vector3.one);
                    Vector3 localPos = localMatrix.inverse.MultiplyPoint(points[selectedPoints[n]].position + points[selectedPoints[n]].normal * HandleUtility.GetHandleSize(points[selectedPoints[n]].position) * 0.5f);
                    localPos += delta;
                    localPos.z = 0f;
                    points[selectedPoints[n]].normal = (localMatrix.MultiplyPoint(localPos) - points[selectedPoints[n]].position).normalized;
                }
                pos.z = 0f;
                pos = matrix.MultiplyPoint(pos);
                points[index].normal = (pos - points[index].position).normalized;
                RegisterChange();
            }
        }

        void FreeNormal(int index)
        {
            Handles.color = highlightColor;
            Handles.DrawWireDisc(points[index].position, points[index].normal, HandleUtility.GetHandleSize(points[index].position) * 0.25f);
            Handles.DrawWireDisc(points[index].position, points[index].normal, HandleUtility.GetHandleSize(points[index].position) * 0.5f);
            Handles.color = color;
            Handles.DrawLine(points[index].position, points[index].position + HandleUtility.GetHandleSize(points[index].position) * points[index].normal);
            Vector3 normalPos = points[index].position + points[index].normal * HandleUtility.GetHandleSize(points[index].position);
            Vector3 lastNormal = points[index].normal;
            normalPos = SplineEditorHandles.FreeMoveCircle(normalPos, HandleUtility.GetHandleSize(normalPos) * 0.1f);
            normalPos -= points[index].position;
            normalPos.Normalize();
            if (normalPos == Vector3.zero) normalPos = Vector3.up;
            if (lastNormal != normalPos)
            {
                Debug.Log(Random.Range(0, 10000));
                points[index].normal = normalPos;
                Quaternion delta = Quaternion.FromToRotation(lastNormal, normalPos);
                for (int n = 0; n < selectedPoints.Count; n++)
                {
                    if (selectedPoints[n] == index) continue;
                    points[selectedPoints[n]].normal = delta * points[selectedPoints[n]].normal;
                }
                RegisterChange();
            }
        }

        private class NormalRotationWindow : EditorWindow
        {
            private float _angle = 0f;
            private PointNormalModule _normalModule;
            private System.Action _onRotationApplied;

            public void Init(PointNormalModule module, System.Action onRotationApplied)
            {
                _normalModule = module;
                _onRotationApplied = onRotationApplied;
                titleContent = new GUIContent("Rotate Normal");
                minSize = maxSize = new Vector2(240, 90);
                _angle = EditorPrefs.GetFloat("Dreamteck.Splines.Editor.PointNormalModule.NormalRotationWindow.angle", 0f);
            }

            private void OnGUI()
            {
                if (Event.current.type == EventType.KeyDown && (Event.current.keyCode == KeyCode.KeypadEnter || Event.current.keyCode == KeyCode.Return))
                {
                    ApplyRotationAndClose();
                }

                _angle = EditorGUILayout.FloatField("Angle", _angle);
                if (GUILayout.Button("Rotate"))
                {
                    ApplyRotationAndClose();
                }
            }

            private void ApplyRotationAndClose()
            {
                SplineSample sample = new SplineSample();
                for (int i = 0; i < _normalModule.selectedPoints.Count; i++)
                {
                    int pointIndex = _normalModule.selectedPoints[i];
                    _normalModule.editor.evaluateAtPoint(pointIndex, ref sample);
                    Quaternion rotation = Quaternion.AngleAxis(-_angle, sample.forward);
                    _normalModule.points[pointIndex].normal = rotation * _normalModule.points[pointIndex].normal;
                    _normalModule.points[pointIndex].changed = true;
                }
                if (_onRotationApplied != null)
                {
                    _onRotationApplied();
                }
                EditorPrefs.SetFloat("Dreamteck.Splines.Editor.PointNormalModule.NormalRotationWindow.angle", _angle);
                Close();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/Point Modules/PointNormalModule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/Point Modules/PointRotateModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 241d10a7b944cc44e9a68f8a66f3b04d
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using UnityEditor;
    using System.Collections;
    using System.Collections.Generic;

    public class PointRotateModule : PointTransformModule
    {
        public bool rotateNormals = true;
        public bool rotateTangents = true;

        public PointRotateModule(SplineEditor editor) : base(editor)
        {
        }

        public override GUIContent GetIconOff()
        {
            return EditorGUIUtility.IconContent("RotateTool");
        }

        public override GUIContent GetIconOn()
        {
            return EditorGUIUtility.IconContent("RotateTool On");
        }

        public override void LoadState()
        {
            base.LoadState();
            rotateNormals = LoadBool("rotateNormals");
            rotateTangents = LoadBool("rotateTangents");
        }

        public override void SaveState()
        {
            base.SaveState();
            SaveBool("rotateNormals", rotateNormals);
            SaveBool("rotateTangents", rotateTangents);
        }

        protected override void OnDrawInspector()
        {
            editSpace = (EditSpace)EditorGUILayout.EnumPopup("Edit Space", editSpace);
            rotateNormals = EditorGUILayout.Toggle("Rotate Normals", rotateNormals);
            rotateTangents = EditorGUILayout.Toggle("Rotate Tangents", rotateTangents);
        }

        protected override void OnDrawScene()
        {
            if (selectedPoints.Count == 0) return;
            if (rotateNormals)
            {
                Handles.color = new Color(Color.yellow.r, Color.yellow.g, Color.yellow.b, 0.4f);
                for (int i = 0; i < selectedPoints.Count; i++)
                {
                    Vector3 normal = points[selectedPoints[i]].normal;
                    normal *= HandleUtility.GetHandleSize(points[selectedPoints[i]].position);
                    Handles.DrawLine(points[selectedPoints[i]].position, points[selectedPoints[i]].position + normal);
                    SplineEditorHandles.DrawArrowCap(points[selectedPoints[i]].position + normal, Quaternion.LookRotation(normal), HandleUtility.GetHandleSize(points[selectedPoints[i]].position));
                }
            }
            Handles.color = Color.white;
            Quaternion lastRotation = rotation;
            rotation = Handles.RotationHandle(lastRotation, selectionCenter);
            if (lastRotation != rotation)
            {
                PrepareTransform();
                for (int i = 0; i < selectedPoints.Count; i++)
                {
                    var point = localPoints[selectedPoints[i]];
                    TransformPoint(ref point, rotateNormals, rotateTangents);
                    points[selectedPoints[i]].SetPoint(point);
                }
                RegisterChange();
                SetDirty();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/Point Modules/PointRotateModule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/Point Modules/PointScaleModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 2efaeffa226557a4183cdcf4cf6142a9
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using UnityEditor;
    using System.Collections;
    using System.Collections.Generic;

    public class PointScaleModule : PointTransformModule
    {
        public bool scaleSize = true;
        public bool scaleTangents = true;


        public PointScaleModule(SplineEditor editor) : base(editor)
        {
        }

        public override GUIContent GetIconOff()
        {
            return EditorGUIUtility.IconContent("ScaleTool");
        }

        public override GUIContent GetIconOn()
        {
            return EditorGUIUtility.IconContent("ScaleTool On");
        }

        public override void LoadState()
        {
            base.LoadState();
            scaleSize = LoadBool("scaleSize");
            scaleTangents = LoadBool("scaleTangents");
        }

        public override void SaveState()
        {
            base.SaveState();
            SaveBool("scaleSize", scaleSize);
            SaveBool("scaleTangents", scaleTangents);
        }

        protected override void OnDrawInspector()
        {
            editSpace = (EditSpace)EditorGUILayout.EnumPopup("Edit Space", editSpace);
            scaleSize = EditorGUILayout.Toggle("Scale Sizes", scaleSize);
            scaleTangents = EditorGUILayout.Toggle("Scale Tangents", scaleTangents);
        }

        protected override void OnDrawScene()
        {
            if (selectedPoints.Count == 0) return;
            if (eventModule.mouseLeftUp)
            {
                Reset();
            }
            Vector3 lastScale = scale;
            Vector3 c = selectionCenter;
            scale = Handles.ScaleHandle(scale, c, rotation, HandleUtility.GetHandleSize(c));
            if (lastScale != scale)
            {
                PrepareTransform();
                for (int i = 0; i < selectedPoints.Count; i++)
                {
                    var point = localPoints[selectedPoints[i]];
                    TransformPoint(ref point, false, scaleTangents, scaleSize);
                    points[selectedPoints[i]].SetPoint(point);
                }
                RegisterChange();
                SetDirty();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/Point Modules/PointScaleModule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/Point Modules/PointTransformModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 0d24553f5bce60b458dabe3b6bca0158
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    public class PointTransformModule : PointModule
    {
        public enum EditSpace { World, Transform, Spline }
        public EditSpace editSpace = EditSpace.World;
        public Vector3 scale = Vector3.one, offset = Vector3.zero;
        protected Quaternion rotation = Quaternion.identity;
        protected Vector3 origin = Vector3.zero;
        protected SplinePoint[] originalPoints = new SplinePoint[0];
        protected SplinePoint[] localPoints = new SplinePoint[0];

        private Matrix4x4 matrix = new Matrix4x4();
        private Matrix4x4 inverseMatrix = new Matrix4x4();
        private bool _unapplied = true;
        SplineSample evalResult = new SplineSample();

        public PointTransformModule(SplineEditor editor) : base(editor)
        {

        }

        public override void Reset()
        {
            base.Reset();
            GetRotation();
            origin = selectionCenter;
            scale = Vector3.one;
            matrix.SetTRS(origin, rotation, Vector3.one);
            inverseMatrix = matrix.inverse;
            localPoints = editor.GetPointsArray();
            for (int i = 0; i < localPoints.Length; i++) InverseTransformPoint(ref localPoints[i]);
        }

        protected void GetRotation()
        {
            switch (editSpace)
            {
                case EditSpace.World: rotation = Quaternion.identity; break;
                case EditSpace.Transform: rotation = TransformUtility.GetRotation(editor.matrix); break;
                case EditSpace.Spline:
                    if (editor.evaluate == null)
                    {
                        Debug.LogError("Unassigned handler evaluate for Spline Editor.");
                        break;
                    }
                    if (selectedPoints.Count == 1)
                    {
                        editor.evaluate((double)selectedPoints[0] / (points.Length - 1), ref evalResult);
                        rotation = evalResult.rotation;
                    }
                    else rotation = Quaternion.identity;
                    break;
            }
        }

        public override void LoadState()
        {
            base.LoadState();
            editSpace = (EditSpace)LoadInt("editSpace");
        }

        public override void SaveState()
        {
            base.SaveState();
            SaveInt("editSpace", (int)editSpace);
        }

        protected void SetDirty()
        {
            RegisterChange();
            _unapplied = true;
        }

        protected bool IsDirty()
        {
            return _unapplied;
        }

        public virtual void Revert()
        {
            editor.SetPointsArray(originalPoints);
            editor.ApplyModifiedProperties();
            _unapplied = false;
        }

        public virtual void Apply()
        {
            RegisterChange();
            CacheOriginalPoints();
            _unapplied = false;
        }

        public override void Select()
        {
            base.Select();
            CacheOriginalPoints();
        }

        public override void Deselect()
        {
            base.Deselect();
            _unapplied = false;
        }

        private void CacheOriginalPoints()
        {
            originalPoints = editor.GetPointsArray();
        }

        protected void PrepareTransform()
        {
            matrix.SetTRS(origin + offset, rotation, scale);
        }

        protected Vector3 TransformPosition(Vector3 position)
        {
            return matrix.MultiplyPoint3x4(position);
        }

        protected Vector3 InverseTransformPosition(Vector3 position)
        {
            return inverseMatrix.MultiplyPoint3x4(position);
        }

        protected Vector3 TransformDirection(Vector3 direction)
        {
            return matrix.MultiplyVector(direction);
        }

        protected Vector3 InverseTransformDirection(Vector3 direction)
        {
            return inverseMatrix.MultiplyVector(direction);
        }

        protected void TransformPoint(ref SplinePoint point, bool normals = true, bool tangents = true, bool size = false)
        {
            if (tangents)
            {
                point.position = TransformPosition(point.position);
                point.tangent = TransformPosition(point.tangent);
                point.tangent2 = TransformPosition(point.tangent2);
            }
            else
            {
                point.SetPosition(TransformPosition(point.position));
            }
            if(normals) point.normal = TransformDirection(point.normal).normalized;
            if (size)
            {
                float avg = (scale.x + scale.y + scale.z) / 3f;
                point.size *= avg;
            }
        }

        protected void InverseTransformPoint(ref SplinePoint point, bool normals = true, bool tangents = true, bool size = false)
        {
            if (tangents)
            {
                point.position = InverseTransformPosition(point.position);
                point.tangent = InverseTransformPosition(point.tangent);
                point.tangent2 = InverseTransformPosition(point.tangent2);
            } else point.SetPosition(TransformPosition(point.position));

            if (normals) point.normal = InverseTransformDirection(point.normal).normalized;
            if (size)
            {
                float avg = (scale.x + scale.y + scale.z) / 3f;
                point.size /= avg;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/Point Modules/PointTransformModule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/SplineEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: bb86255f2f032e04297cae0b6fde161f
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using Dreamteck.Editor;
    using UnityEngine;
    using UnityEditor;
    using Dreamteck.Splines;

    public class SplineEditor : SplineEditorBase
    {
        public enum Space { World, Local };
        public bool editMode = false;
        protected Matrix4x4 _matrix;
        protected virtual string editorName { get { return "SplineEditor"; } }

        public bool is2D = false;
        public Color drawColor = Color.white;

        public MainPointModule mainModule;
        public SerializedSplinePoint[] points = new SerializedSplinePoint[0];
        public List<int> selectedPoints = new List<int>();
        public Tool lastEditorTool = Tool.None;
        public Space editSpace = Space.World;

        public delegate void SplineEvaluation(double percent, ref SplineSample result);
        public delegate void SplinePointEvaluation(int pointIndex, ref SplineSample result);
        public delegate Vector3 SplineEvaluatePosition(double percent);
        public delegate float SplineCalculateLength(double from, double to);
        public delegate double SplineTravel(double start, float distance, Spline.Direction direction);

        public SplineEvaluation evaluate;
        public SplinePointEvaluation evaluateAtPoint;
        public SplineEvaluatePosition evaluatePosition;
        public SplineCalculateLength calculateLength;
        public SplineTravel travel;
        public EmptyHandler selectionChangeHandler;

        public int moduleCount
        {
            get { return _modules.Length; }
        }

        public PointModule currentModule
        {
            get
            {
                if (_module < 0 || _module >= _modules.Length) return null;
                else return _modules[_module];
            }
        }

        protected List<PointOperation> pointOperations = new List<PointOperation>();
        protected Vector2 lastClickPoint = Vector2.zero;
        protected GUIContent[] toolContents = new GUIContent[0], toolContentsSelected = new GUIContent[0];
        protected bool pointToolsToggle = false;
        protected Toolbar toolbar;
        protected SplineSample evalResult = new SplineSample();
        protected SerializedProperty _splineProperty { get; private set; }
        protected SerializedProperty _pointsProperty { get; private set; }
        protected SerializedProperty _typeProperty { get; private set; }
        protected SerializedProperty _sampleRateProperty { get; private set; }
        protected SerializedProperty _closedProperty { get; private set; }
        protected string splinePropertyName
        {
            get
            {
                if (_customSplinePropertyName != "") return _customSplinePropertyName;
                return "_spline";
            }
        }

        private int _module = -1, _selectModule = -1, _loadedModuleIndex = -1;
        private PointModule[] _modules = new PointModule[0];
        private string[] _pointOperationStrings = new string[0];
        private float _editLabelAlpha = 0f;
        private Vector2 _editLabelPosition = Vector2.zero;
        private float lastEmptyClickTime = 0f;
        private int _selectedPointOperation = 0;
        private bool _emptyClick = false;
        private string _customSplinePropertyName = "";

        public Matrix4x4 matrix
        {
            get { return _matrix; }
        }

        public SplineEditor(Matrix4x4 transformMatrix, SerializedObject splineHolder, string customSplinePropertyName) : base(splineHolder)
        {
            _customSplinePropertyName = customSplinePropertyName;
            Initialize(transformMatrix, splineHolder);
        }


        public SplineEditor(Matrix4x4 transformMatrix, SerializedObject splineHolder) : base(splineHolder)
        {
            Initialize(transformMatrix, splineHolder);
        }

        private void Initialize(Matrix4x4 transformMatrix, SerializedObject splineHolder)
        {
            _matrix = transformMatrix;
            string[] serializedPath = splinePropertyName.Split('/');
            foreach (var element in serializedPath)
            {
                if (_splineProperty == null)
                {
                    _splineProperty = _serializedObject.FindProperty(element);
                    continue;
                }
                int i = 0;
                if (int.TryParse(element, out i))
                {
                    _splineProperty = _splineProperty.GetArrayElementAtIndex(i);
                }
                else
                {
                    _splineProperty = _splineProperty.FindPropertyRelative(element);
                }
            }

            GetSerializedProperteis();
            mainModule = new MainPointModule(this);
            mainModule.onSelectionChanged += OnSelectionChanged;
            List<PointModule> moduleList = new List<PointModule>();
            OnModuleList(moduleList);
            _modules = moduleList.ToArray();
            toolContents = new GUIContent[_modules.Length];
            toolContentsSelected = new GUIContent[_modules.Length];
            for (int i = 0; i < _modules.Length; i++)
            {
                _modules[i].onSelectionChanged += OnSelectionChanged;
                toolContents[i] = _modules[i].GetIconOff();
                toolContentsSelected[i] = _modules[i].GetIconOn();
            }
            toolbar = new Toolbar(toolContents, toolContentsSelected, 35f);

            pointOperations.Add(new PointOperation { name = "Flat X", action = delegate { FlatSelection(0); } });
            pointOperations.Add(new PointOperation { name = "Flat Y", action = delegate { FlatSelection(1); } });
            pointOperations.Add(new PointOperation { name = "Flat Z", action = delegate { FlatSelection(2); } });
            pointOperations.Add(new PointOperation { name = "Mirror X", action = delegate { MirrorSelection(0); } });
            pointOperations.Add(new PointOperation { name = "Mirror Y", action = delegate { MirrorSelection(1); } });
            pointOperations.Add(new PointOperation { name = "Mirror Z", action = delegate { MirrorSelection(2); } });
            pointOperations.Add(new PointOperation { name = "Distribute Evenly", action = delegate { DistributeEvenly(); } });
            pointOperations.Add(new PointOperation { name = "Auto Bezier Tangents", action = delegate { AutoTangents(); } });
            pointOperations.Add(new PointOperation { name = "Swap Bezier Tangents", action = delegate { SwapTangents(); } });
            pointOperations.Add(new PointOperation { name = "Flip Bezier Tangents", action = delegate { FlipTangents(); } });
            pointOperations.Add(new PointOperation { name = "Flip First Bezier Tangent", action = delegate { FlipFirstTangent(); } });
            pointOperations.Add(new PointOperation { name = "Flip Seconds Bezier Tangent", action = delegate { FlipSecondTangent(); } });

            _pointOperationStrings = new string[pointOperations.Count];
            for (int i = 0; i < pointOperations.Count; i++)
            {
                _pointOperationStrings[i] = pointOperations[i].name;
            }
            if (_selectedPointOperation >= _pointOperationStrings.Length || _selectedPointOperation < 0)
            {
                _selectedPointOperation = 0;
            }
        }

        protected virtual void GetSerializedProperteis()
        {
            _pointsProperty = _splineProperty.FindPropertyRelative("points");
            _typeProperty = _splineProperty.FindPropertyRelative("type");
            _sampleRateProperty = _splineProperty.FindPropertyRelative("sampleRate");
            _closedProperty = _splineProperty.FindPropertyRelative("closed");
        }

        public PointModule GetModule(int index)
        {
            return _modules[index];
        }

        public override void UndoRedoPerformed()
        {
            GetPointsFromSpline();
            for (int i = 0; i < selectedPoints.Count; i++)
            {
                if(selectedPoints[i] >= points.Length)
                {
                    selectedPoints.RemoveAt(i);
                    i--;
                }
            }
            ResetCurrentModule();
        }

        protected virtual void OnModuleList(List<PointModule> list)
        {
            list.Add(new CreatePointModule(this));
            list.Add(new DeletePointModule(this));
            list.Add(new PointMoveModule(this));
            list.Add(new PointRotateModule(this));
            list.Add(new PointScaleModule(this));
            list.Add(new PointNormalModule(this));
            list.Add(new PointMirrorModule(this));
        }

        public virtual void GetPointsFromSpline()
        {
            _serializedObject.Update();
            if (points.Length != _pointsProperty.arraySize)
            {
                points = new SerializedSplinePoint[_pointsProperty.arraySize];
            }

            for (int i = 0; i < _pointsProperty.arraySize; i++)
            {
                points[i] = new SerializedSplinePoint(_pointsProperty.GetArrayElementAtIndex(i));
            }
        }

        public virtual void ApplyModifiedProperties(bool forceAllUpdate = false)
        {
            _serializedObject.ApplyModifiedProperties();
        }

        public virtual void SetPreviewPoints(SplinePoint[] points)
        {

        }

        public SplinePoint[] GetPointsArray()
        {
            SplinePoint[] p = new SplinePoint[points.Length];
            for (int i = 0; i < p.Length; i++)
            {
                p[i] = points[i].CreateSplinePoint();
            }
            return p;
        }

        public void SetPointsArray(SplinePoint[] input)
        {
            SetPointsCount(input.Length);
            for (int i = 0; i < points.Length; i++)
            {
                points[i].SetPoint(input[i]);
            }
        }

        public void SetPointsCount(int count)
        {
            _pointsProperty.arraySize = count;
            _serializedObject.ApplyModifiedProperties();
            GetPointsFromSpline();
        }

        public virtual void DeletePoint(int index)
        {
            _pointsProperty.DeleteArrayElementAtIndex(index);
            ApplyModifiedProperties(true);
            GetPointsFromSpline();
        }

        public void AddPointAt(int index)
        {
            _pointsProperty.InsertArrayElementAtIndex(index);

            _serializedObject.ApplyModifiedProperties();
            _serializedObject.Update();

            if (points.Length != _pointsProperty.arraySize)
            {
                points = new SerializedSplinePoint[_pointsProperty.arraySize];
            }

            for (int i = 0; i < _pointsProperty.arraySize; i++)
            {
                points[i] = new SerializedSplinePoint(_pointsProperty.GetArrayElementAtIndex(i));
            }

            ApplyModifiedProperties(true);
        }

        public override void Destroy()
        {
            base.Destroy();
            mainModule.Deselect();
            if (currentModule != null) currentModule.Deselect();
            if(lastEditorTool != Tool.None && Tools.current == Tool.None) Tools.current = lastEditorTool;
        }

        public virtual void SetSplineClosed(bool closed)
        {
            if (points.Length < 3)
            {
                closed = false;
            }
            _closedProperty.boolValue = closed;
        }

        public virtual void SetSplineType(Spline.Type type)
        {
            _typeProperty.enumValueIndex = (int)type;
        }

        public virtual void SetSplineSampleRate(int rate)
        {
            if (rate < 2) rate = 2;
            _sampleRateProperty.intValue = rate;
        }

        public virtual bool GetSplineClosed()
        {
            return _closedProperty.boolValue;
        }

        public virtual int GetSplineSampleRate()
        {
            return _sampleRateProperty.intValue;
        }

        public virtual Spline.Type GetSplineType()
        {
            return (Spline.Type)_typeProperty.enumValueIndex;
        }

        void OnSelectionChanged()
        {
            ResetCurrentModule();
            Repaint();
            if (selectionChangeHandler != null) selectionChangeHandler();
        }

        protected override void Save()
        {
            base.Save();
            EditorPrefs.SetBool(GetSaveName("editMode"), editMode);
            EditorPrefs.SetBool(GetSaveName("pointToolsToggle"), pointToolsToggle);
            EditorPrefs.SetInt(GetSaveName("selectedPointOperation"), _selectedPointOperation);
        }

        protected override void Load()
        {
            base.Load();
            editMode = EditorPrefs.GetBool(GetSaveName("editMode"), false);
            pointToolsToggle = EditorPrefs.GetBool(GetSaveName("pointToolsToggle"), false);
            _selectedPointOperation = EditorPrefs.GetInt(GetSaveName("selectedPointOperation"), 0);
        }

        private void HandleEditModeToggle()
        {
            if(Event.current.type == EventType.KeyDown)
            {
                if (editMode && Event.current.keyCode == KeyCode.Escape)
                {
                    if(_module >= 0)
                    {
                        UntoggleCurrentModule();
                        Repaint();
                    } else
                    {
                        editMode = false;
                        Repaint();
                    }
                }
                if (Event.current.control && Event.current.keyCode == KeyCode.E) {
                    editMode = !editMode;
                    Repaint();
                }
            }
        }

        public override void DrawInspector()
        {
            GetPointsFromSpline();
            HandleEditModeToggle();
            base.DrawInspector();
            if (editMode)
            {
                if (!gizmosEnabled)
                {
                    EditorGUILayout.HelpBox("Gizmos are disabled in the scene view. Enable Gizmos in the scene view for the spline editor to work.", MessageType.Error);
                }
                EditorGUILayout.Space();
                DrawToolMenu();
                EditorGUILayout.Space();
                EditorGUI.BeginChangeCheck();
                if (currentModule != null)
                {
                    currentModule.DrawInspector();
                    if (currentModule.hasChanged)
                    {
                        ApplyModifiedProperties();
                    }
                }
                DreamteckEditorGUI.DrawSeparator();
                PointPanel();
                if (EditorGUI.EndChangeCheck()) ResetCurrentModule();
            } else
            {
                if (GUILayout.Button("Edit"))
                {
                    editMode = true;
                }
            }
        }

        void DrawToolMenu()
        {
            EditorGUILayout.BeginHorizontal();
            if (_loadedModuleIndex >= 0)
            {
                ToggleModule(_loadedModuleIndex);
                _loadedModuleIndex = -1;
            }
            _selectModule = _module;
            EditorGUI.BeginChangeCheck();
            toolbar.Draw(ref _selectModule);
            if (EditorGUI.EndChangeCheck())
            {
                ToggleModule(_selectModule);
            }

            EditorGUILayout.EndHorizontal();
        }

        protected virtual void PointPanel()
        {
            if (points.Length == 0)
            {
                EditorGUILayout.LabelField("No control points available.", EditorStyles.centeredGreyMiniLabel);
                return;
            }
            mainModule.DrawInspector();
            if (mainModule.hasChanged)
            {
                ApplyModifiedProperties();
            }
            if (selectedPoints.Count > 0 && points.Length > 0)
            {
                PointMenu();
            }
        }

        public virtual void BeforeSceneGUI(SceneView current)
        {
            mainModule.BeforeSceneDraw(current);
            if (_module >= 0 && _module < _modules.Length)
            {
                _modules[_module].BeforeSceneDraw(current);
            }
        }

        public override void DrawScene(SceneView current)
        {
            GetPointsFromSpline();
            HandleEditModeToggle();
            if (!editMode)
            {
                return;
            }
            base.DrawScene(current);
            Event e = Event.current;
            if (Tools.current != Tool.None)
            {
                lastEditorTool = Tools.current;
                Tools.current = Tool.None;
            }
            int controlID = GUIUtility.GetControlID(FocusType.Passive);
            if (e.GetTypeForControl(controlID) == EventType.Layout) HandleUtility.AddDefaultControl(controlID);

            if (eventModule.mouseLeftDown) lastClickPoint = e.mousePosition;
            EditorGUI.BeginChangeCheck();
            mainModule.DrawScene();
            if (mainModule.hasChanged)
            {
                ApplyModifiedProperties();
            }
            if (currentModule != null)
            {
                currentModule.DrawScene();
                if (currentModule.hasChanged)
                {
                    ApplyModifiedProperties();
                }
                if (currentModule is CreatePointModule)
                {
                    if (eventModule.mouseLeftDown && eventModule.mouseRight)
                    {
                        GUIUtility.hotControl = -1;
                        ApplyModifiedProperties(true);
                        ToggleModule(0);
                    }
                }
            }
            if(eventModule.mouseLeftDown) _emptyClick = GUIUtility.hotControl == 0;

            if (_emptyClick)
            {
                if (eventModule.mouseLeft && !mainModule.isDragging && Vector2.Distance(lastClickPoint, e.mousePosition) >= mainModule.minimumRectSize && !eventModule.alt)
                {
                    mainModule.StartDrag(lastClickPoint);
                    _emptyClick = false;
                }
            }

            if (eventModule.mouseLeftUp)
            {
                if (mainModule.isDragging) mainModule.FinishDrag();
                else
                {
                    if (_emptyClick && !eventModule.alt)
                    {
                        if(selectedPoints.Count > 0) mainModule.ClearSelection();
                        else if(editMode)
                        {
                            if (Time.realtimeSinceStartup - lastEmptyClickTime <= 0.3f)
                            {
                                editMode = false;
                            }
                            else
                            {
                                _editLabelAlpha = 1f;
                                _editLabelPosition = e.mousePosition;
                                lastEmptyClickTime = Time.realtimeSinceStartup;
                            }
                        }
                    }
                }
            }


            if (!eventModule.mouseRight && !eventModule.mouseLeft && e.type == EventType.KeyDown && !e.control)
            {
                switch (e.keyCode)
                {
                    case KeyCode.Q:
                        if (_module == 0) ToggleModule(1);
                        else ToggleModule(0);
                        e.Use(); break;
                    case KeyCode.W: ToggleModule(2); e.Use(); break;
                    case KeyCode.E: ToggleModule(3); e.Use(); break;
                    case KeyCode.R: ToggleModule(4); e.Use(); break;
                    case KeyCode.T: ToggleModule(5); e.Use(); break;
                    case KeyCode.Y: ToggleModule(6); e.Use(); break;
                }
            }

            if(_editLabelAlpha > 0f)
            {
                Handles.BeginGUI();
                GUI.contentColor = new Color(1f, 1f, 1f, _editLabelAlpha);
                DreamteckEditorGUI.Label(new Rect(_editLabelPosition, new Vector2(140, 50)), "Click Again To Exit");
                Handles.EndGUI();
                _editLabelAlpha = Mathf.MoveTowards(_editLabelAlpha, 0f, Time.deltaTime * 0.05f);
                Repaint();
            }
        }

        public void ToggleModule(int index)
        {
            Tools.current = Tool.None;
            if (currentModule != null) currentModule.Deselect();
            if (index == _module) _module = -1;
            else
            {
                _module = index;
                ResetCurrentModule();
                currentModule.Select();
                if (currentModule.hasChanged)
                {
                    ApplyModifiedProperties(true);
                }
            }
            Repaint();
        }

        public void UntoggleCurrentModule()
        {
            if (currentModule != null) currentModule.Deselect();
            _module = -1;
            Repaint();
        }


        protected virtual void PointMenu()
        {
            //Otherwise show the editing menu + the point selection menu
            Vector3 avgPos = Vector3.zero;
            Vector3 avgTan = Vector3.zero;
            Vector3 avgTan2 = Vector3.zero;
            Vector3 avgNormal = Vector3.zero;
            float avgSize = 0f;
            Color avgColor = Color.clear;

            for (int i = 0; i < selectedPoints.Count; i++)
            {
                avgPos += points[selectedPoints[i]].position;
                avgNormal += points[selectedPoints[i]].normal;
                avgSize += points[selectedPoints[i]].size;
                avgTan += points[selectedPoints[i]].tangent;
                avgTan2 += points[selectedPoints[i]].tangent2;
                avgColor += points[selectedPoints[i]].color;
            }

            avgPos /= selectedPoints.Count;
            avgTan /= selectedPoints.Count;
            avgTan2 /= selectedPoints.Count;
            avgSize /= selectedPoints.Count;
            avgColor /= selectedPoints.Count;
            avgNormal.Normalize();

            SplinePoint avgPoint = new SplinePoint(avgPos, avgPos);
            avgPoint.tangent = avgTan;
            avgPoint.tangent2 = avgTan2;
            avgPoint.size = avgSize;
            avgPoint.color = avgColor;
            avgPoint.type = points[selectedPoints[0]].type;
            SplinePoint.Type lastType = avgPoint.type;

            avgPoint.normal = avgNormal;

            EditorGUILayout.Space();

            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("Point Operations");

            EditorGUILayout.BeginVertical();

            _selectedPointOperation = EditorGUILayout.Popup(_selectedPointOperation, _pointOperationStrings);
            if (GUILayout.Button("Apply"))
            {
                pointOperations[_selectedPointOperation].action.Invoke();
                ApplyModifiedProperties();
            }
            EditorGUILayout.EndVertical();

            EditorGUILayout.EndHorizontal();

            EditorGUILayout.Space();

            EditorGUI.BeginChangeCheck();
            editSpace = (Space)EditorGUILayout.EnumPopup("Coordinate Space", editSpace);
            bool isBezier = _typeProperty.enumValueIndex == (int)Spline.Type.Bezier;
            if (isBezier)
            {
                if (is2D)
                {
                    avgPoint.SetTangentPosition(TransformedPositionField2D("Tangent 1", avgPoint.tangent));
                    avgPoint.SetTangent2Position(TransformedPositionField2D("Tangent 2", avgPoint.tangent2));
                }
                else
                {
                    avgPoint.SetTangentPosition(TransformedPositionField("Tangent 1", avgPoint.tangent));
                    avgPoint.SetTangent2Position(TransformedPositionField("Tangent 2", avgPoint.tangent2));
                }
            }
            if (is2D)
            {
                avgPoint.SetPosition(TransformedPositionField2D("Position", avgPoint.position));
            }
            else
            {
                avgPoint.SetPosition(TransformedPositionField("Position", avgPoint.position));
            }

            if (!is2D)
            {
                avgPoint.normal = TransformedVectorField("Normal", avgPoint.normal);
            }
            avgPoint.size = EditorGUILayout.FloatField("Size", avgPoint.size);
            avgPoint.color = EditorGUILayout.ColorField("Color", avgPoint.color);
            if (isBezier)
            {
                avgPoint.type = (SplinePoint.Type)EditorGUILayout.EnumPopup("Point Type", avgPoint.type);
            }

            if (!EditorGUI.EndChangeCheck()) return;
            for (int i = 0; i < selectedPoints.Count; i++)
            {
                points[selectedPoints[i]].SetPosition(GetChangedVector(avgPos, avgPoint.position, points[selectedPoints[i]].position));
                points[selectedPoints[i]].normal = GetChangedVector(avgNormal, avgPoint.normal, points[selectedPoints[i]].normal);

                if (isBezier)
                {
                    points[selectedPoints[i]].SetTangentPosition(GetChangedVector(avgTan, avgPoint.tangent, points[selectedPoints[i]].tangent));
                    points[selectedPoints[i]].SetTangent2Position(GetChangedVector(avgTan2, avgPoint.tangent2, points[selectedPoints[i]].tangent2));
                }
                if (avgPoint.size != avgSize) points[selectedPoints[i]].size = avgPoint.size;
                if (avgColor != avgPoint.color) points[selectedPoints[i]].color = avgPoint.color;
                if (lastType != avgPoint.type) points[selectedPoints[i]].type = avgPoint.type;
            }
            ApplyModifiedProperties();
        }

        Vector3 GetChangedVector(Vector3 oldVector, Vector3 newVector, Vector3 original)
        {
            if (!Mathf.Approximately(oldVector.x, newVector.x)) original.x = newVector.x;
            if (!Mathf.Approximately(oldVector.y, newVector.y)) original.y = newVector.y;
            if (!Mathf.Approximately(oldVector.z, newVector.z)) original.z = newVector.z;
            return original;
        }

        Vector3 TransformedPositionField(string title, Vector3 worldPoint)
        {
            Vector3 pos = worldPoint;
            if (editSpace == Space.Local) pos = _matrix.inverse.MultiplyPoint3x4(worldPoint);
            pos = EditorGUILayout.Vector3Field(title, pos);
            if (editSpace == Space.Local) pos = _matrix.MultiplyPoint3x4(pos);
            return pos;
        }

        Vector3 TransformedVectorField(string title, Vector3 worldPoint)
        {
            Vector3 vector = worldPoint;
            if (editSpace == Space.Local) vector = _matrix.inverse.MultiplyVector(worldPoint);
            vector = EditorGUILayout.Vector3Field(title, vector);
            if (editSpace == Space.Local) vector = _matrix.MultiplyVector(vector);
            return vector;
        }

        Vector2 TransformedPositionField2D(string title, Vector3 worldPoint)
        {
            Vector2 pos = worldPoint;
            if (editSpace == Space.Local) pos = _matrix.inverse.MultiplyPoint3x4(worldPoint);
            pos = EditorGUILayout.Vector2Field(title, pos);
            if (editSpace == Space.Local) pos = _matrix.MultiplyPoint3x4(pos);
            return pos;
        }

        public void FlatSelection(int axis)
        {
            Vector3 avg = Vector3.zero;
            bool flatTangent = false;
            bool flatPosition = true;
            if (_typeProperty.enumValueIndex == (int)Spline.Type.Bezier)
            {
                switch (EditorUtility.DisplayDialogComplex("Flat Bezier", "How do you want to flat the selected Bezier points?", "Points Only", "Tangens Only", "Everything"))
                {
                    case 0: flatTangent = false; flatPosition = true; break;
                    case 1: flatTangent = true; flatPosition = false; break;
                    case 2: flatTangent = true; flatPosition = true; break;
                }
            }
            RecordUndo("Flat Selection");
            if (flatPosition)
            {
                for (int i = 0; i < selectedPoints.Count; i++)
                {
                    avg += points[selectedPoints[i]].position;
                }
                avg /= selectedPoints.Count;
                for (int i = 0; i < selectedPoints.Count; i++)
                {
                    Vector3 pos = points[selectedPoints[i]].position;
                    Vector3 nor = points[selectedPoints[i]].normal;
                    switch (axis)
                    {
                        case 0: pos.x = avg.x; nor.x = 0f; break;
                        case 1: pos.y = avg.y; nor.y = 0f; break;
                        case 2: pos.z = avg.z; nor.z = 0f; break;
                    }
                    points[selectedPoints[i]].normal = nor.normalized;
                    if (points[selectedPoints[i]].normal == Vector3.zero) points[selectedPoints[i]].normal = Vector3.up;
                    points[selectedPoints[i]].SetPosition(pos);
                    if (flatTangent)
                    {
                        Vector3 tan = points[selectedPoints[i]].tangent;
                        Vector3 tan2 = points[selectedPoints[i]].tangent2;
                        switch (axis)
                        {
                            case 0: tan.x = avg.x; tan2.x = avg.x; break;
                            case 1: tan.y = avg.y; tan2.y = avg.y; break;
                            case 2: tan.z = avg.z; tan2.z = avg.z; break;
                        }
                        points[selectedPoints[i]].SetTangentPosition(tan);
                        points[selectedPoints[i]].SetTangent2Position(tan2);
                    }
                }
            }
            else
            {
                for (int i = 0; i < selectedPoints.Count; i++)
                {
                    Vector3 tan = points[selectedPoints[i]].tangent;
                    Vector3 tan2 = points[selectedPoints[i]].tangent2;
                    Vector3 pos = points[selectedPoints[i]].position;
                    switch (axis)
                    {
                        case 0: tan.x = pos.x; tan2.x = pos.x; break;
                        case 1: tan.y = pos.y; tan2.y = pos.y; break;
                        case 2: tan.z = pos.z; tan2.z = pos.z; break;
                    }
                    points[selectedPoints[i]].SetTangentPosition(tan);
                    points[selectedPoints[i]].SetTangent2Position(tan2);
                }
            }
            ResetCurrentModule();
        }

        public void MirrorSelection(int axis)
        {
            bool mirrorTangents = false;
            if (_typeProperty.enumValueIndex == (int)Spline.Type.Bezier)
            {
                if (EditorUtility.DisplayDialog("Mirror tangents", "Do you want to mirror the tangents too ?", "Yes", "No")) mirrorTangents = true;
            }
            float min = 0f, max = 0f;
            switch (axis)
            {
                case 0: min = max = points[selectedPoints[0]].position.x; break;
                case 1: min = max = points[selectedPoints[0]].position.y; break;
                case 2: min = max = points[selectedPoints[0]].position.z; break;
            }
            RecordUndo("Mirror Selection");
            if (mirrorTangents)
            {
                float value = 0f;
                switch (axis)
                {
                    case 0: value = points[selectedPoints[0]].tangent.x; break;
                    case 1: value = points[selectedPoints[0]].tangent.y; break;
                    case 2: value = points[selectedPoints[0]].tangent.z; break;
                }
                if (value < min) min = value;
                if (value > max) max = value;
                switch (axis)
                {
                    case 0: value = points[selectedPoints[0]].tangent2.x; break;
                    case 1: value = points[selectedPoints[0]].tangent2.y; break;
                    case 2: value = points[selectedPoints[0]].tangent2.z; break;
                }
                if (value < min) min = value;
                if (value > max) max = value;
            }
            for (int i = 1; i < selectedPoints.Count; i++)
            {
                float value = 0f;
                switch (axis)
                {
                    case 0: value = points[selectedPoints[i]].position.x; break;
                    case 1: value = points[selectedPoints[i]].position.y; break;
                    case 2: value = points[selectedPoints[i]].position.z; break;
                }
                if (value < min) min = value;
                if (value > max) max = value;
                if (mirrorTangents)
                {
                    switch (axis)
                    {
                        case 0: value = points[selectedPoints[i]].tangent.x; break;
                        case 1: value = points[selectedPoints[i]].tangent.y; break;
                        case 2: value = points[selectedPoints[i]].tangent.z; break;
                    }
                    if (value < min) min = value;
                    if (value > max) max = value;
                    switch (axis)
                    {
                        case 0: value = points[selectedPoints[i]].tangent2.x; break;
                        case 1: value = points[selectedPoints[i]].tangent2.y; break;
                        case 2: value = points[selectedPoints[i]].tangent2.z; break;
                    }
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
            }

            for (int i = 0; i < selectedPoints.Count; i++)
            {
                float value = 0f;
                if (mirrorTangents)
                {
                    //Point position
                    switch (axis)
                    {
                        case 0: value = points[selectedPoints[i]].position.x; break;
                        case 1: value = points[selectedPoints[i]].position.y; break;
                        case 2: value = points[selectedPoints[i]].position.z; break;
                    }
                    float percent = Mathf.InverseLerp(min, max, value);
                    value = Mathf.Lerp(max, min, percent);
                    Vector3 pos = points[selectedPoints[i]].position;
                    switch (axis)
                    {
                        case 0: pos.x = value; break;
                        case 1: pos.y = value; break;
                        case 2: pos.z = value; break;
                    }
                    points[selectedPoints[i]].position = pos;
                    //Tangent 1
                    switch (axis)
                    {
                        case 0: value = points[selectedPoints[i]].tangent.x; break;
                        case 1: value = points[selectedPoints[i]].tangent.y; break;
                        case 2: value = points[selectedPoints[i]].tangent.z; break;
                    }
                    percent = Mathf.InverseLerp(min, max, value);
                    value = Mathf.Lerp(max, min, percent);
                    Vector3 tan = points[selectedPoints[i]].tangent;
                    switch (axis)
                    {
                        case 0: tan.x = value; break;
                        case 1: tan.y = value; break;
                        case 2: tan.z = value; break;
                    }
                    points[selectedPoints[i]].tangent = tan;
                    //Tangent 2
                    switch (axis)
                    {
                        case 0: value = points[selectedPoints[i]].tangent2.x; break;
                        case 1: value = points[selectedPoints[i]].tangent2.y; break;
                        case 2: value = points[selectedPoints[i]].tangent2.z; break;
                    }
                    percent = Mathf.InverseLerp(min, max, value);
                    value = Mathf.Lerp(max, min, percent);
                    tan = points[selectedPoints[i]].tangent2;
                    switch (axis)
                    {
                        case 0: tan.x = value; break;
                        case 1: tan.y = value; break;
                        case 2: tan.z = value; break;
                    }
                    points[selectedPoints[i]].tangent2 = tan;
                }
                else
                {
                    Vector3 pos = points[selectedPoints[i]].position;
                    switch (axis)
                    {
                        case 0: value = pos.x; break;
                        case 1: value = pos.y; break;
                        case 2: value = pos.z; break;
                    }
                    float percent = Mathf.InverseLerp(min, max, value);
                    value = Mathf.Lerp(max, min, percent);
                    switch (axis)
                    {
                        case 0: pos.x = value; break;
                        case 1: pos.y = value; break;
                        case 2: pos.z = value; break;
                    }
                    points[selectedPoints[i]].SetPosition(pos);
                }
                //Normal
                Vector3 nor = points[selectedPoints[i]].normal;
                switch (axis)
                {
                    case 0: nor.x *= -1f; break;
                    case 1: nor.y *= -1f; break;
                    case 2: nor.z *= -1f; break;
                }
                points[selectedPoints[i]].normal = nor.normalized;
            }
            ResetCurrentModule();
        }

        public void DistributeEvenly()
        {
            if (selectedPoints.Count < 3) return;
            RecordUndo("Distribute Evenly");
            int min = points.Length-1, max = 0;
            for (int i = 0; i < selectedPoints.Count; i++)
            {
                if (selectedPoints[i] < min) min = selectedPoints[i];
                if (selectedPoints[i] > max) max = selectedPoints[i];
            }
            double minPercent = (double)min / (points.Length - 1);
            double maxPercent = (double)max / (points.Length - 1);
            float length = calculateLength(minPercent, maxPercent);
            float step = length / (max - min);
            SplineSample evalResult = new SplineSample();
            evaluate(minPercent, ref evalResult);
            for (int i = min + 1; i < max; i++)
            {
                double percent = travel(evalResult.percent, step, Spline.Direction.Forward);
                evaluate(percent, ref evalResult);
                points[i].SetPosition(evalResult.position);
            }
            ResetCurrentModule();
        }

        public void LoopTriggerProperties(System.Action<SerializedProperty> onTrigger)
        {
            SerializedProperty triggerGroups = _serializedObject.FindProperty("triggerGroups");

            for (int i = 0; i < triggerGroups.arraySize; i++)
            {
                SerializedProperty triggers = triggerGroups.GetArrayElementAtIndex(i).FindPropertyRelative("triggers");
                for (int j = 0; j < triggers.arraySize; j++)
                {
                    SerializedProperty trigger = triggers.GetArrayElementAtIndex(j);
                    onTrigger.Invoke(trigger);
                }
            }
        }

        public void AutoTangents()
        {
            RecordUndo("Auto Tangents");
            for (int i = 0; i < selectedPoints.Count; i++)
            {
                int index = selectedPoints[i];
                Vector3 prevPos = points[index].position, forwardPos = points[index].position;
                if(index == 0 && points.Length > 1)
                {
                    prevPos = points[0].position + (points[0].position - points[1].position);
                } else prevPos = points[index - 1].position;
                if (index == points.Length-1 && points.Length > 1)
                {
                    forwardPos = points[points.Length-1].position + (points[points.Length - 1].position - points[points.Length - 2].position);
                }
                else forwardPos = points[index + 1].position;
                Vector3 delta = (forwardPos - prevPos) / 2f;
                points[index].tangent = points[index].position - delta / 3f;
                points[index].tangent2 = points[index].position + delta / 3f;
            }
            ResetCurrentModule();
        }

        public void SwapTangents()
        {
            RecordUndo("Swap Tangents");
            for (int i = 0; i < selectedPoints.Count; i++)
            {
                int index = selectedPoints[i];
                Vector3 tempTangent = points[index].tangent;
                points[index].tangent = points[index].tangent2;
                points[index].tangent2 = tempTangent;
            }
            ResetCurrentModule();
        }

        public void FlipTangents()
        {
            RecordUndo("Flip Tangents");
            for (int i = 0; i < selectedPoints.Count; i++)
            {
                int index = selectedPoints[i];
                points[index].tangent = points[index].position + (points[index].position - points[index].tangent);
                points[index].tangent2 = points[index].position + (points[index].position - points[index].tangent2);
            }
            ResetCurrentModule();
        }

        public void FlipFirstTangent()
        {
            RecordUndo("Flip First Tangent");
            for (int i = 0; i < selectedPoints.Count; i++)
            {
                int index = selectedPoints[i];
                points[index].tangent2 = points[index].position + (points[index].position - points[index].tangent2);
            }
            ResetCurrentModule();
        }

        public void FlipSecondTangent()
        {
            RecordUndo("Flip Second Tangent");
            for (int i = 0; i < selectedPoints.Count; i++)
            {
                int index = selectedPoints[i];
                points[index].tangent = points[index].position + (points[index].position - points[index].tangent);
            }
            ResetCurrentModule();
        }

        protected void ResetCurrentModule()
        {
            if (_module < 0 || _module >= _modules.Length) return;
            _modules[_module].Reset();
        }

        public class PointOperation
        {
            public string name = "";
            public System.Action action;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/SplineEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/SplineEditorBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: bc43fa09ec92d7b4996069786c06b474
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEditor;
    using UnityEngine;

    public class SplineEditorBase
    {
        public bool open = false;
        public EditorGUIEvents eventModule = null;

        public delegate void UndoHandler(string title);
        public delegate void EmptyHandler();

        public UndoHandler undoHandler;
        public EmptyHandler repaintHandler;

        protected bool gizmosEnabled
        {
            get { return _gizmosEnabled; }
        }

        private bool _gizmosEnabled = true;

        protected readonly SerializedObject _serializedObject;

        public SplineEditorBase(SerializedObject serializedObject)
        {
            Load();
            this._serializedObject = serializedObject;
            eventModule = new EditorGUIEvents();
        }

        public virtual void Destroy()
        {
            Save();
        }

        protected virtual void Load()
        {
            open = LoadBool("open");
        }

        protected virtual void Save()
        {
            SaveBool("open", open);
        }

        public virtual void DrawInspector()
        {
            if(SceneView.lastActiveSceneView != null)
            {
#if UNITY_2019_1_OR_NEWER
                _gizmosEnabled = SceneView.lastActiveSceneView.drawGizmos;
#endif
            }
            eventModule.Update(Event.current);
        }

        public virtual void DrawScene(SceneView current)
        {
            eventModule.Update(Event.current);
        }

        protected virtual void RecordUndo(string title)
        {
            if (undoHandler != null) undoHandler(title);
        }

        protected virtual void Repaint()
        {
            if (repaintHandler != null)
            {
                repaintHandler();
            }
        }

        public virtual void UndoRedoPerformed()
        {
            
        }

        protected string GetSaveName(string valueName)
        {
            return GetType().FullName + "." + valueName;
        }

        protected void SaveBool(string variableName, bool value)
        {
            EditorPrefs.SetBool(GetType().ToString() + "." + variableName, value);
        }

        protected void SaveInt(string variableName, int value)
        {
            EditorPrefs.SetInt(GetType().ToString() + "." + variableName, value);
        }

        protected void SaveFloat(string variableName, float value)
        {
            EditorPrefs.SetFloat(GetType().ToString() + "." + variableName, value);
        }

        protected void SaveString(string variableName, string value)
        {
            EditorPrefs.SetString(GetType().ToString() + "." + variableName, value);
        }

        protected bool LoadBool(string variableName, bool defaultValue = false)
        {
            return EditorPrefs.GetBool(GetType().ToString() + "." + variableName, defaultValue);
        }

        protected int LoadInt(string variableName, int defaultValue = 0)
        {
            return EditorPrefs.GetInt(GetType().ToString() + "." + variableName, defaultValue);
        }

        protected float LoadFloat(string variableName, float d = 0f)
        {
            return EditorPrefs.GetFloat(GetType().ToString() + "." + variableName, d);
        }

        protected string LoadString(string variableName)
        {
            return EditorPrefs.GetString(GetType().ToString() + "." + variableName, "");
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditor/SplineEditorBase.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditorGUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 593576e3e74256142bb6ead53a138bd5
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using UnityEditor;
    using System.Text.RegularExpressions;


    public static class SplineEditorGUI
    {
        public static readonly GUIStyle leftButtonStyle, midButtonStyle, rightButtonStyle, boxStyle;

        private static Color previousContentColor, previousBackgroundColor, highLightBGColor, highlightContentColor;


        public static readonly GUIStyle defaultButton = null;
        public static readonly GUIStyle defaultEditorButton = null;
        public static readonly GUIStyle defaultEditorButtonSelected = null;
        public static readonly GUIStyle dropdownItem = null;
        public static readonly GUIStyle bigButton = null;
        public static readonly GUIStyle bigButtonSelected = null;
        public static readonly GUIStyle labelText = null;
        public static GUIStyle whiteBox
        {
            get
            {
                if (_whiteBox.normal.background == null) _whiteBox.normal.background = white;
                return _whiteBox;
            }
        }
        private static readonly GUIStyle _whiteBox = null;
        public static GUIStyle defaultField
        {
            get
            {
                if (_defaultField.normal.background == null) _defaultField.normal.background = white;
                return _defaultField;
            }
        }
        private static GUIStyle _defaultField = null;
        public static GUIStyle smallField
        {
            get
            {
                if (_smallField.normal.background == null) _smallField.normal.background = white;
                return _smallField;
            }
        }
        private static GUIStyle _smallField = null;
        public static readonly Color inactiveColor = new Color(0.7f, 0.7f, 0.7f, 0.3f);
        public static readonly Color textColor = new Color(0.2f, 0.2f, 0.2f, 1f);
        public static readonly Color activeColor = new Color(1f, 1f, 1f, 1f);
        public static readonly Color blackColor = new Color(0, 0, 0, 0.7f);
        public static readonly Color buttonContentColor = Color.black;
        private static bool[] controlStates = new bool[0];
        private static string[] floatFieldContents = new string[0];
        private static int controlIndex = 0;

        public static float scale = 1f;
        public static Texture2D white
        {
            get
            {
                if (_white == null)
                {
                    _white = new Texture2D(1, 1);
                    _white.SetPixel(0, 0, Color.white);
                    _white.Apply();
                }
                return _white;
            }
        }
        private static Texture2D _white = null;

        public static void Update()
        {
            controlStates = new bool[0];
            floatFieldContents = new string[0];
        }

        public static void Reset()
        {
            controlIndex = 0;
        }

        static SplineEditorGUI()
        {
            midButtonStyle = new GUIStyle(GUI.skin.button);
            midButtonStyle.margin = new RectOffset(0, 0, midButtonStyle.margin.top, midButtonStyle.margin.bottom);
            midButtonStyle.padding = new RectOffset(3, 3, midButtonStyle.padding.top, midButtonStyle.padding.bottom);

            leftButtonStyle = new GUIStyle(midButtonStyle);
            leftButtonStyle.contentOffset = new Vector2(-leftButtonStyle.border.left * 0.5f, 0f);
            rightButtonStyle = new GUIStyle(midButtonStyle);
            rightButtonStyle.contentOffset = new Vector2(rightButtonStyle.border.right * 0.5f, 0f);

            boxStyle = new GUIStyle(GUI.skin.GetStyle("box"));
            boxStyle.normal.background = DreamteckEditorGUI.blankImage;
            boxStyle.margin = new RectOffset(0, 0, 0, 2);

            defaultButton = new GUIStyle(GUI.skin.GetStyle("button"));
            _whiteBox = new GUIStyle(GUI.skin.GetStyle("box"));
            _whiteBox.normal.background = white;
            _defaultField = new GUIStyle(GUI.skin.GetStyle("textfield"));
            _defaultField.normal.background = white;
            _defaultField.normal.textColor = Color.white;
            defaultField.alignment = TextAnchor.MiddleLeft;
            _smallField = new GUIStyle(GUI.skin.GetStyle("textfield"));
            _smallField.normal.background = white;
            _smallField.normal.textColor = Color.white;
            _smallField.alignment = TextAnchor.MiddleLeft;
            _smallField.clipping = TextClipping.Clip;
            labelText = new GUIStyle(GUI.skin.GetStyle("label"));
            labelText.fontStyle = FontStyle.Bold;
            labelText.alignment = TextAnchor.MiddleRight;
            labelText.normal.textColor = Color.white;
            dropdownItem = new GUIStyle(GUI.skin.GetStyle("button"));
            dropdownItem.normal.background = white;
            dropdownItem.normal.textColor = Color.white;
            dropdownItem.alignment = TextAnchor.MiddleLeft;
            bigButton = new GUIStyle(GUI.skin.GetStyle("button"));
            bigButton.fontStyle = FontStyle.Bold;
            bigButton.normal.textColor = buttonContentColor;
            bigButtonSelected = new GUIStyle(GUI.skin.GetStyle("button"));
            bigButtonSelected.fontStyle = FontStyle.Bold;
            buttonContentColor = defaultButton.normal.textColor;
            //If the button text color is too dark, generate a brightened version
            float avg = (buttonContentColor.r + buttonContentColor.g + buttonContentColor.b) / 3f;
            if (avg <= 0.2f) buttonContentColor = new Color(0.2f, 0.2f, 0.2f);
            Rescale();
        }

        public static void SetHighlightColors(Color background, Color content)
        {
            highLightBGColor = background;
            highlightContentColor = content;
        }

        public static bool LeftButton(GUIContent content, bool selected)
        {
            bool clicked = false;
            Rect rect = ButtonBegin(selected, leftButtonStyle);
            if (GUI.Button(new Rect(0, 0, rect.width + leftButtonStyle.border.right, rect.height), content, leftButtonStyle)) clicked = true;
            ButtonEnd();
            return clicked;
        }

        public static bool MidButton(GUIContent content, bool selected)
        {
            bool clicked = false;
            Rect rect = ButtonBegin(selected, midButtonStyle);
            if (GUI.Button(new Rect(-midButtonStyle.border.left, 0, rect.width + midButtonStyle.border.left + midButtonStyle.border.right, rect.height), content, midButtonStyle)) clicked = true;
            ButtonEnd();
            return clicked;
        }

        public static bool RightButton(GUIContent content, bool selected)
        {
            bool clicked = false;
            Rect rect = ButtonBegin(selected, rightButtonStyle);
            if (GUI.Button(new Rect(-rightButtonStyle.border.left, 0, rect.width + rightButtonStyle.border.left, rect.height), content, rightButtonStyle)) clicked = true;
            ButtonEnd();
            return clicked;
        }

        static Rect ButtonBegin(bool selected, GUIStyle style)
        {
            previousContentColor = GUI.contentColor;
            previousBackgroundColor = GUI.backgroundColor;
            GUI.contentColor = style.normal.textColor;
            if (selected)
            {
                GUI.backgroundColor = highLightBGColor;
                GUI.contentColor = highlightContentColor;
            }
            Rect rect = GUILayoutUtility.GetRect(30f, 22f);
            GUI.BeginGroup(rect);
            return rect;
        }

        public static void ButtonEnd()
        {
            GUI.EndGroup();
            GUI.contentColor = previousContentColor;
            GUI.backgroundColor = previousBackgroundColor;
        }

        public static int ButtonRibbon(GUIContent[] contents, float buttonWidth, int highLighted = -1)
        {
            int selected = -1;
            float width = contents.Length * buttonWidth;
            EditorGUILayout.BeginHorizontal(GUILayout.Width(width));
            for (int i = 0; i < contents.Length; i++)
            {
                if (i == 0)
                {
                    if (LeftButton(contents[i], highLighted == i)) selected = i;
                }
                else if (i == contents.Length - 1)
                {
                    if(RightButton(contents[i], highLighted == i)) selected = i;
                }
                else
                {
                    if(MidButton(contents[i], highLighted == i)) selected = i;
                }
            }
            EditorGUILayout.EndHorizontal();
            return selected;
        }


        public static void BeginContainerBox(ref bool open, string name)
        {
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            EditorGUI.indentLevel++;
            GUI.color = new Color(1f, 1f, 1f, 0.7f);
            open = Foldout(open, name, true);
            GUI.color = Color.white;
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();
        }

        public static void EndContainerBox()
        {
            EditorGUILayout.EndVertical();
        }

        public static bool Foldout(bool foldout, GUIContent content, bool toggleOnLabelClick)
        {
            Rect position = GUILayoutUtility.GetRect(40f, 40f, 16f, 16f, EditorStyles.foldout);
            return EditorGUI.Foldout(position, foldout, content, toggleOnLabelClick, EditorStyles.foldout);
        }

        public static bool Foldout(bool foldout, string content, bool toggleOnLabelClick)
        {
            return Foldout(foldout, new GUIContent(content), toggleOnLabelClick);
        }

        private static void Rescale()
        {
            defaultField.padding = new RectOffset(Mathf.RoundToInt(5 * scale), Mathf.RoundToInt(5 * scale), Mathf.RoundToInt(5 * scale), Mathf.RoundToInt(5 * scale));
            smallField.padding = new RectOffset(Mathf.RoundToInt(2 * scale), Mathf.RoundToInt(2 * scale), Mathf.RoundToInt(2 * scale), Mathf.RoundToInt(2 * scale));
            dropdownItem.padding = new RectOffset(Mathf.RoundToInt(10 * scale), 0, 0, 0);
            bigButton.padding = new RectOffset(Mathf.RoundToInt(3*scale), Mathf.RoundToInt(3 * scale), Mathf.RoundToInt(3 * scale), Mathf.RoundToInt(3 * scale));
            bigButtonSelected.normal.textColor = new Color(0.95f, 0.95f, 0.95f);
            bigButton.padding = new RectOffset(Mathf.RoundToInt(4 * scale), Mathf.RoundToInt(4 * scale), Mathf.RoundToInt(4 * scale), Mathf.RoundToInt(4 * scale));
            bigButton.fontSize = Mathf.RoundToInt(30 * scale);
            bigButtonSelected.fontSize = Mathf.RoundToInt(30 * scale);
            defaultButton.fontSize = Mathf.RoundToInt(14 * scale);
            dropdownItem.fontSize = Mathf.RoundToInt(12 * scale);
            labelText.fontSize = Mathf.RoundToInt(12 * scale);
            defaultField.fontSize = Mathf.RoundToInt(14 * scale);
            smallField.fontSize = Mathf.RoundToInt(11 * scale);
        }

        public static void SetScale(float s)
        {
            if(s != scale)
            {
                scale = s;
                Rescale();
            } scale = s;
        }

        public static bool EditorLayoutSelectableButton(GUIContent content, bool active = true, bool selected = false, params GUILayoutOption[] options)
        {
            Color prevColor = GUI.color;
            Color prevContentColor = GUI.contentColor;
            Color prevBackgroundColor = GUI.backgroundColor;
            GUIStyle selectedStyle = GUI.skin.button;
            if (!active) GUI.color = inactiveColor;
            else
            {
                GUI.color = activeColor;
                if (selected)
                {
                    GUI.backgroundColor = highLightBGColor;
                    GUI.contentColor = highlightContentColor;
                    selectedStyle = new GUIStyle(selectedStyle);
                    selectedStyle.normal.textColor = Color.white;
                    selectedStyle.hover.textColor = Color.white;
                    selectedStyle.active.textColor = Color.white;
                } else GUI.contentColor = buttonContentColor;
            }
            bool clicked = GUILayout.Button(content, selectedStyle, options);
            GUI.color = prevColor;
            GUI.contentColor = prevContentColor;
            GUI.backgroundColor = prevBackgroundColor;
            return clicked && active;
        }
        private static string CleanStringForFloat(string input)
        {
            if (Regex.Match(input, @"^-?[0-9]*(?:\.[0-9]*)?$").Success)
                return input;
            else
            {
                return "0";
            }
        }

       private static void HandleControlsCount() {
            if (controlIndex >= controlStates.Length)
            {
                bool[] newStates = new bool[controlStates.Length + 1];
                controlStates.CopyTo(newStates, 0);
                controlStates = newStates;

                string[] newContents = new string[controlStates.Length + 1];
                floatFieldContents.CopyTo(newContents, 0);
                floatFieldContents = newContents;
            }
        }

#if DREAMTECK_SPLINES
        public static double ScreenPointToSplinePercent(SplineComputer computer, Vector2 screenPoint)
        {
            SplinePoint[] points = computer.GetPoints();
            float closestDistance = (screenPoint - HandleUtility.WorldToGUIPoint(points[0].position)).sqrMagnitude;
            double closestPercent = 0.0;
            double add = computer.moveStep;
            if (computer.type == Spline.Type.Linear) add /= 2f;
            int count = 0;
            for (double i = add; i < 1.0; i += add)
            {
                SplineSample result = computer.Evaluate(i);
                Vector2 point = HandleUtility.WorldToGUIPoint(result.position);
                float dist = (point - screenPoint).sqrMagnitude;
                if (dist < closestDistance)
                {
                    closestDistance = dist;
                    closestPercent = i;
                }
                count++;
            }
            return closestPercent;
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditorGUI.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditorHandles.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 29e77e260a516ba4bab9b6a22397b6cf
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEditor;
    using UnityEngine;

    public static class SplineEditorHandles
    {
        public static bool SliderButton(Vector3 position, bool drawHandle, Color color, float size)
        {
            Camera cam = SceneView.currentDrawingSceneView.camera;
            Vector3 localPos = cam.transform.InverseTransformPoint(position);
            if (localPos.z < 0f) return false;

            size *= HandleUtility.GetHandleSize(position);
            Vector2 screenPos = HandleUtility.WorldToGUIPoint(position);
            Vector2 screenRectBase = HandleUtility.WorldToGUIPoint(position - cam.transform.right * size + cam.transform.up * size);
            Rect rect = new Rect(screenRectBase.x, screenRectBase.y, (screenPos.x - screenRectBase.x) * 2f, (screenPos.y - screenRectBase.y) * 2f);
            if (drawHandle)
            {
                Color previousColor = Handles.color;
                Handles.color = color;
                Handles.RectangleHandleCap(0, position, Quaternion.LookRotation(-cam.transform.forward), HandleUtility.GetHandleSize(position) * 0.1f, EventType.Repaint);
                Handles.color = previousColor;
            }
            if (rect.Contains(Event.current.mousePosition))
            {
                if (Event.current.type == EventType.MouseDown && Event.current.button == 0)
                {
                    return true;
                }
            }
            return false;
        }

        public static bool CircleButton(Vector3 position, Quaternion rotation, float size, float clickableAreaMultiplier, Color color)
        {
            Color prev = Handles.color;
            bool result = false;
            Handles.color = color;
            result = Handles.Button(position, rotation, size, size * clickableAreaMultiplier, Handles.CircleHandleCap);
            Handles.color = prev;
            return result;
        }

        public static Vector3 FreeMoveRectangle(Vector3 position, float size) 
        {
#if UNITY_2022_1_OR_NEWER
            return Handles.FreeMoveHandle(position, size, Vector3.zero, Handles.CircleHandleCap);
#else
            return Handles.FreeMoveHandle(position, Quaternion.identity, size, Vector3.zero, Handles.CircleHandleCap);
#endif
        }

        public static Vector3 FreeMoveCircle(Vector3 position, float size)
        {
#if UNITY_2022_1_OR_NEWER
            return Handles.FreeMoveHandle(position, size, Vector3.zero, Handles.CircleHandleCap);
#else
            return Handles.FreeMoveHandle(position, Quaternion.identity, size, Vector3.zero, Handles.CircleHandleCap);
#endif
        }

        public static Vector3 FreeMoveHandle(Vector3 position, float size, Vector3 snap, Handles.CapFunction capFunction)
        {
#if UNITY_2022_1_OR_NEWER
            return Handles.FreeMoveHandle(position, size, snap, capFunction);
#else
            return Handles.FreeMoveHandle(position, Quaternion.identity, size, snap, capFunction);
#endif
        }

        public static void DrawPoint(Vector3 position, bool selected)
        {
            DrawPoint(position, selected, Color.white);
        }

        public static void DrawPoint(Vector3 position, bool selected, Color tintColor)
        {
            if (selected)
            {
                Handles.color = SplinePrefs.highlightColor * tintColor;
                Handles.DrawSolidDisc(position, -SceneView.currentDrawingSceneView.camera.transform.forward, HandleUtility.GetHandleSize(position) * 0.16f);
            }

            Handles.color = SplinePrefs.outlineColor * tintColor;
            Handles.DrawSolidDisc(position, -SceneView.currentDrawingSceneView.camera.transform.forward, HandleUtility.GetHandleSize(position) * 0.12f);
            Handles.color = SplinePrefs.defaultColor * tintColor;
            Handles.DrawSolidDisc(position, -SceneView.currentDrawingSceneView.camera.transform.forward, HandleUtility.GetHandleSize(position) * 0.09f);
            Handles.color = Color.white;
        }

        public static void DrawSolidSphere(Vector3 position, float radius)
        {
            Handles.SphereHandleCap(0, position, Quaternion.identity, radius, EventType.Repaint);
        }

        public static void DrawCircle(Vector3 position, Quaternion rotation, float radius)
        {
            Handles.CircleHandleCap(0, position, rotation, radius, EventType.Repaint);
        }

        public static void DrawRectangle(Vector3 position, Quaternion rotation, float size)
        {
            Handles.RectangleHandleCap(0, position, rotation, size, EventType.Repaint);
        }

        public static void DrawArrowCap(Vector3 position, Quaternion rotation, float size)
        {
            Handles.ArrowHandleCap(0, position, rotation, size, EventType.Repaint);
        }

        public static bool HoverArea(Vector3 position, float size)
        {
            Camera cam = SceneView.currentDrawingSceneView.camera;
            Vector3 localPos = cam.transform.InverseTransformPoint(position);
            if (localPos.z < 0f) return false;

            size *= HandleUtility.GetHandleSize(position);
            Vector2 screenPos = HandleUtility.WorldToGUIPoint(position);
            Vector2 screenRectBase = HandleUtility.WorldToGUIPoint(position - cam.transform.right * size + cam.transform.up * size);
            Rect rect = new Rect(screenRectBase.x, screenRectBase.y, (screenPos.x - screenRectBase.x) * 2f, (screenPos.y - screenRectBase.y) * 2f);
            if (rect.Contains(Event.current.mousePosition)) return true;
            else return false;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditorHandles.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditorWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 91380b807009a7b4893c3dfba7da6187
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using UnityEditor;

    public class SplineEditorWindow : EditorWindow
    {
        protected Editor editor;
        protected SplineComputerEditor splineEditor;

        public void Init(Editor e, string inputTitle, Vector2 min, Vector2 max)
        {
            minSize = min;
            maxSize = max;
            Init(e, inputTitle);
        }

        public void Init(Editor e, Vector2 min, Vector2 max)
        {
            minSize = min;
            maxSize = max;
            Init(e);
        }

        public void Init(Editor e, Vector2 size)
        {
            minSize = maxSize = size;
            Init(e);
        }

        public void Init(Editor e, string inputTitle)
        {
            Init(e);
            Title(inputTitle);
        }

        public void Init(Editor e)
        {
            editor = e;
            if (editor is SplineComputerEditor) splineEditor = (SplineComputerEditor)editor;
            else splineEditor = null;
            Title(GetTitle());
            OnInitialize();
        }

        protected virtual void OnInitialize()
        {

        }

        protected virtual string GetTitle()
        {
            return "Spline Editor Window";
        }

        private void Title(string inputTitle)
        {
            titleContent = new GUIContent(inputTitle);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplineEditorWindow.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplinePreset.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 303414f4492e1ee4a94310320981f32d
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.IO;

    [System.Serializable]
    public struct S_Vector3
    {
        public float x, y, z;
        public Vector3 vector
        {
            get { return new Vector3(x, y, z); }
            set { }
        }


        public S_Vector3(Vector3 input)
        {
            x = input.x;
            y = input.y;
            z = input.z;
        }
    }
    [System.Serializable]
    public struct S_Color
    {
        public float r, g, b, a;
        public Color color
        {
            get { return new Color(r, g, b, a); }
            set { }
        }
        public S_Color(Color input)
        {
            r = input.r;
            g = input.g;
            b = input.b;
            a = input.a;
        }
    }

    [System.Serializable]
    public class SplinePreset
    {
        [SerializeField]
        private S_Vector3[] points_position = new S_Vector3[0];
        [SerializeField]
        private S_Vector3[] points_tanget = new S_Vector3[0];
        [SerializeField]
        private S_Vector3[] points_tangent2 = new S_Vector3[0];
        [SerializeField]
        private S_Vector3[] points_normal = new S_Vector3[0];
        [SerializeField]
        private S_Color[] points_color = new S_Color[0];
        [SerializeField]
        private float[] points_size = new float[0];
        [SerializeField]
        private SplinePoint.Type[] points_type = new SplinePoint.Type[0];


        [System.NonSerialized]
        protected SplineComputer computer;
        [System.NonSerialized]
        public Vector3 origin = Vector3.zero;

        public bool isClosed = false;
        public string filename = "";
        public string name = "";
        public string description = "";
        public Spline.Type type = Spline.Type.Bezier;
        private static string path = "";

        public SplinePoint[] points
        {
            get
            {
                SplinePoint[] p = new SplinePoint[points_position.Length];
                for (int i = 0; i < p.Length; i++)
                {
                    p[i].type = points_type[i];
                    p[i].position = points_position[i].vector;
                    p[i].tangent = points_tanget[i].vector;
                    p[i].tangent2 = points_tangent2[i].vector;
                    p[i].normal = points_normal[i].vector;
                    p[i].color = points_color[i].color;
                    p[i].size = points_size[i];
                }
                return p;
            }
        }

        public SplinePreset(SerializedSplinePoint[] p, bool closed, Spline.Type t)
        {
            points_position = new S_Vector3[p.Length];
            points_tanget = new S_Vector3[p.Length];
            points_tangent2 = new S_Vector3[p.Length];
            points_normal = new S_Vector3[p.Length];
            points_color = new S_Color[p.Length];
            points_size = new float[p.Length];
            points_type = new SplinePoint.Type[p.Length];
            for (int i = 0; i < p.Length; i++)
            {
                points_position[i] = new S_Vector3(p[i].position);
                points_tanget[i] = new S_Vector3(p[i].tangent);
                points_tangent2[i] = new S_Vector3(p[i].tangent2);
                points_normal[i] = new S_Vector3(p[i].normal);
                points_color[i] = new S_Color(p[i].color);
                points_size[i] = p[i].size;
                points_type[i] = p[i].type;
            }
            isClosed = closed;
            type = t;
            path = ResourceUtility.FindFolder(Application.dataPath, "Dreamteck/Splines/Presets");
        }

        public void Save(string name)
        {
            if (!Directory.Exists(path))
            {
                Directory.CreateDirectory(path);
            }
            FileStream file = File.Create(path + "/" + name + ".jsp");
            byte[] bytes = System.Text.ASCIIEncoding.ASCII.GetBytes(JsonUtility.ToJson(this));
            file.Write(bytes, 0, bytes.Length);
            file.Close();
        }

        public static void Delete(string filename)
        {
            path = ResourceUtility.FindFolder(Application.dataPath, "Dreamteck/Splines/Presets");
            if (!Directory.Exists(path))
            {
                Debug.LogError("Directory " + path + " does not exist");
                return;
            }
            File.Delete(path + "/" + filename);
        }

        public static SplinePreset[] LoadAll()
        {
            path = ResourceUtility.FindFolder(Application.dataPath, "Dreamteck/Splines/Presets");
            if (!Directory.Exists(path))
            {
                Debug.LogError("Directory " + path + " does not exist");
                return null;
            }
            string[] files = Directory.GetFiles(path, "*.jsp");
            SplinePreset[] presets = new SplinePreset[files.Length];
            for (int i = 0; i < files.Length; i++)
            {

                FileStream file = File.Open(files[i], FileMode.Open);
                byte[] bytes = new byte[file.Length];
                file.Read(bytes, 0, bytes.Length);
                string json = System.Text.ASCIIEncoding.ASCII.GetString(bytes);
                presets[i] = JsonUtility.FromJson<SplinePreset>(json);
                file.Close();
            }
            return presets;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/SplinePreset.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Tools/BakeTool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 659dbb6c3db842b4bbe63915d9097d5a
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using UnityEditor;
    using System.Collections.Generic;
    using System.IO;

    public class BakeTool : SplineTool
    {
        public enum BakeGroup { All, Selected, AllExcluding }
        BakeGroup bakeGroup = BakeGroup.All;
        MeshGenerator[] found = new MeshGenerator[0];
        List<MeshGenerator> selected = new List<MeshGenerator>();
        List<MeshGenerator> excluded = new List<MeshGenerator>();

        bool isStatic = true;
        bool removeComputer = false;
        bool permanent = false;
        bool copy = false;
        BakeMeshWindow.SaveFormat format = BakeMeshWindow.SaveFormat.MeshAsset;

        string savePath = "";

        DirectoryInfo dirInfo;

        Vector2 scroll1, scroll2;

        public override string GetName()
        {
            return "Bake Meshes";
        }

        public override void Draw(Rect windowRect)
        {
            bakeGroup = (BakeGroup)EditorGUILayout.EnumPopup("Bake Mode", bakeGroup);
            if (bakeGroup == BakeGroup.Selected)
            {
                MeshGenSelector(ref selected, "Selected");
            } else if(bakeGroup == BakeGroup.AllExcluding)
            {
                MeshGenSelector(ref excluded, "Excluded");
            }


            format = (BakeMeshWindow.SaveFormat)EditorGUILayout.EnumPopup("Save Format", format);
            bool saveMesh = format != BakeMeshWindow.SaveFormat.Scene;

            if (format != BakeMeshWindow.SaveFormat.Scene)
            {
                copy = EditorGUILayout.Toggle("Save without baking", copy);
            }
            bool isCopy = format != BakeMeshWindow.SaveFormat.Scene && copy;
            switch (format)
            {
                case BakeMeshWindow.SaveFormat.Scene: EditorGUILayout.HelpBox("Saves the mesh inside the scene", MessageType.Info); break;
                case BakeMeshWindow.SaveFormat.MeshAsset: EditorGUILayout.HelpBox("Saves the mesh as an .asset file inside the project. This makes using the mesh in prefabs and across scenes possible.", MessageType.Info); break;
                case BakeMeshWindow.SaveFormat.OBJ: EditorGUILayout.HelpBox("Exports the mesh as an OBJ file which can be imported in a third-party modeling application.", MessageType.Info); break;
            }
            EditorGUILayout.Space();

            if (!isCopy)
            {
                isStatic = EditorGUILayout.Toggle("Make Static", isStatic);
                permanent = EditorGUILayout.Toggle("Permanent", permanent);
                if (permanent)
                {
                    removeComputer = EditorGUILayout.Toggle("Remove SplineComputer", removeComputer);
                    if (removeComputer) EditorGUILayout.HelpBox("WARNING: Removing Spline Computers may cause other SplineUsers to stop working. Select this if you are sure that no other SplineUser uses the selected Spline Computers.", MessageType.Warning);
                }
            }

            if (GUILayout.Button("Bake"))
            {
                if (saveMesh)
                {
                    savePath = EditorUtility.OpenFolderPanel("Save Directory", Application.dataPath, "folder");
                    if (!Directory.Exists(savePath) || savePath == "")
                    {
                        EditorUtility.DisplayDialog("Save error", "Invalid save directory. Please select a valid save directory and try again", "OK");
                        return;
                    }
                    if (format == BakeMeshWindow.SaveFormat.OBJ && !savePath.StartsWith(Application.dataPath) && !copy)
                    {
                        EditorUtility.DisplayDialog("Save error", "OBJ files can be saved outside of the project folder only when \"Save without baking\" is selected. Please select a directory inside the project in order to save.", "OK");
                        return;
                    }
                    if (format == BakeMeshWindow.SaveFormat.MeshAsset && !savePath.StartsWith(Application.dataPath))
                    {
                        EditorUtility.DisplayDialog("Save error", "Asset files cannot be saved outside of the project directory. Please select a path inside the project directory.", "OK");
                        return;
                    }
                }
                string suff = "all";
                if (bakeGroup == BakeGroup.Selected) suff = "selected";
                if (bakeGroup == BakeGroup.AllExcluding) suff = "all excluding";
                if(EditorUtility.DisplayDialog("Bake " + suff, "This operation cannot be undone. Are you sure you want to bake the meshes?", "Yes", "No"))
                {
                    switch (bakeGroup)
                    {
                        case BakeGroup.All: BakeAll(); break;
                        case BakeGroup.Selected: BakeSelected(); break;
                        case BakeGroup.AllExcluding: BakeExcluding(); break;
                    }
                }
            }
        }

        private void BakeAll()
        {
            EditorUtility.ClearProgressBar();
            for (int i = 0; i < found.Length; i++)
            {
                float percent = (float)i / (found.Length - 1);
                EditorUtility.DisplayProgressBar("Baking progress", "Baking generator " + i, percent);
                Bake(found[i]);
            }
            EditorUtility.ClearProgressBar();
        }

        private void BakeSelected()
        {
            EditorUtility.ClearProgressBar();
            for (int i = 0; i < selected.Count; i++)
            {
                float percent = (float)i / (selected.Count - 1);
                EditorUtility.DisplayProgressBar("Baking progress", "Baking generator " + i, percent);
                Bake(selected[i]);
            }
            EditorUtility.ClearProgressBar();
        }

        private void BakeExcluding()
        {
            EditorUtility.ClearProgressBar();
            for (int i = 0; i < found.Length; i++)
            {
                float percent = (float)i / (found.Length - 1);
                EditorUtility.DisplayProgressBar("Baking progress", "Baking generator " + i, percent);
                Bake(found[i]);
            }
            EditorUtility.ClearProgressBar();
        }

        private void Bake(MeshGenerator gen)
        {
            MeshFilter filter = gen.GetComponent<MeshFilter>();
            if(filter == null)
            {
                EditorUtility.DisplayDialog("Save error", "No mesh present in " + gen.name, "OK");
                return;
            }
            if (copy)
            {
                UnityEditor.MeshUtility.Optimize(filter.sharedMesh);
               Unwrapping.GenerateSecondaryUVSet(filter.sharedMesh);
            }
            else gen.Bake(isStatic, true);

            if(format == BakeMeshWindow.SaveFormat.OBJ)
            {
                MeshRenderer renderer = gen.GetComponent<MeshRenderer>();
                dirInfo = new DirectoryInfo(savePath);
                FileInfo[] files = dirInfo.GetFiles(filter.sharedMesh.name + "*.obj");
                string meshName = filter.sharedMesh.name;
                if (files.Length > 0) meshName += "_" + files.Length;
                string path = savePath + "/" + meshName + ".obj";
                string objString = Dreamteck.MeshUtility.ToOBJString(filter.sharedMesh, renderer.sharedMaterials);
                File.WriteAllText(path, objString);
                if (copy)
                {
                    string relativepath = "Assets" + path.Substring(Application.dataPath.Length);
                    AssetDatabase.ImportAsset(relativepath, ImportAssetOptions.ForceSynchronousImport);
                    filter.sharedMesh = AssetDatabase.LoadAssetAtPath<Mesh>(relativepath);
                }
            }

            if(format == BakeMeshWindow.SaveFormat.MeshAsset)
            {
                dirInfo = new DirectoryInfo(savePath);
                FileInfo[] files = dirInfo.GetFiles(filter.sharedMesh.name + "*.asset");
                string meshName = filter.sharedMesh.name;
                if (files.Length > 0) meshName += "_" + files.Length;
                string path = savePath + "/" + meshName + ".asset";
                string relativepath = "Assets" + path.Substring(Application.dataPath.Length);
                if (copy)
                {
                    Mesh assetMesh = Dreamteck.MeshUtility.Copy(filter.sharedMesh);
                    AssetDatabase.CreateAsset(assetMesh, relativepath);
                } else AssetDatabase.CreateAsset(filter.sharedMesh, relativepath);
            }

            if (permanent && !copy)
            {
                SplineComputer meshGenComputer = gen.spline;
                if (permanent)
                {
                    meshGenComputer.Unsubscribe(gen);
                    Object.DestroyImmediate(gen);
                }
                if (removeComputer)
                {
                    if (meshGenComputer.GetComponents<Component>().Length == 2) Object.DestroyImmediate(meshGenComputer.gameObject);
                    else Object.DestroyImmediate(meshGenComputer);
                }
            }
        }

        private void Refresh()
        {
            found = Object.FindObjectsOfType<MeshGenerator>();
        }

        void OnFocus()
        {
            Refresh();
        }

        public override void Open(EditorWindow window)
        {
            base.Open(window);
            isStatic = LoadBool("isStatic", true);
            format = (BakeMeshWindow.SaveFormat)LoadInt("format", 0);
            removeComputer = LoadBool("removeComputer", false);
            copy = LoadBool("copy", false);
            Refresh();
        }

        public override void Close()
        {
            base.Close();
            SaveBool("isStatic", isStatic);
            SaveInt("format", (int)format);
            SaveBool("copy", copy);
            SaveBool("removeComputer", removeComputer);
        }

        protected override string GetPrefix()
        {
            return "BakeTool";
        }

        private void MeshGenSelector(ref List<MeshGenerator> list, string title)
        {
            List<MeshGenerator> availalbe = new List<MeshGenerator>(found);
            for (int i = availalbe.Count-1; i >= 0; i--)
            {
                for (int n = 0; n < list.Count; n++)
                {
                    if (list[n] == availalbe[i])
                    {
                        availalbe.RemoveAt(i);
                        break;
                    }
                }
            }
            GUILayout.Box("Available", GUILayout.Width(Screen.width - 15 - Screen.width/3f), GUILayout.Height(100));
            Rect rect = GUILayoutUtility.GetLastRect();
            rect.y += 15;
            rect.height -= 15;
            scroll1 = GUI.BeginScrollView(rect, scroll1, new Rect(0, 0, rect.width, 22 * availalbe.Count));
            for (int i = 0; i < availalbe.Count; i++)
            {
                GUI.Label(new Rect(5, 22 * i, rect.width - 30, 22), availalbe[i].name);
                if (GUI.Button(new Rect(rect.width - 29, 22 * i, 22, 22), "+"))
                {
                    list.Add(availalbe[i]);
                    availalbe.RemoveAt(i);
                    break;
                }
            }
                GUI.EndScrollView();
            EditorGUILayout.Space();
            GUILayout.Box(title, GUILayout.Width(Screen.width - 15 - Screen.width / 3f), GUILayout.Height(100));

            rect = GUILayoutUtility.GetLastRect();
            rect.y += 15;
            rect.height -= 15;
            scroll2 = GUI.BeginScrollView(rect, scroll2, new Rect(0, 0, rect.width, 22 * list.Count));
            for (int i = list.Count-1; i >= 0; i--)
            {
                GUI.Label(new Rect(5, 22 * i, rect.width - 30, 22), list[i].name);
                if (GUI.Button(new Rect(rect.width - 29, 22 * i, 22, 22), "x"))
                {
                    list.RemoveAt(i);
                }
            }
            GUI.EndScrollView();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Tools/BakeTool.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Tools/CatenaryTool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 62aeb649c30348f4ea6cec4a6481b8fd
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using System.IO;

namespace Dreamteck.Splines
{
    public class CatenaryTool : SplineTool
    {
        protected GameObject obj;
        protected ObjectController spawner;
        private float _sag = 0f;
        private float _minSagDistance = 0f;
        private float _maxSagDistance = 10f;
        private Dictionary<SplineComputer, SplinePoint[]> _editSplines = new Dictionary<SplineComputer, SplinePoint[]>();

        public override string GetName()
        {
            return "Catenary Tool";
        }

        protected override string GetPrefix()
        {
            return "CatenaryTool";
        }

        public override void Open(EditorWindow window)
        {
            base.Open(window);
            _sag = EditorPrefs.GetFloat("DreamteckSplines.CatenaryTool._sag", 0f);
            _minSagDistance = EditorPrefs.GetFloat("DreamteckSplines.CatenaryTool._minSagDistance", 0f);
            _maxSagDistance = EditorPrefs.GetFloat("DreamteckSplines.CatenaryTool._maxSagDistance", 10f);
        }

        public override void Close()
        {
            base.Close();
            EditorPrefs.SetFloat("DreamteckSplines.CatenaryTool._sag", _sag);
            EditorPrefs.SetFloat("DreamteckSplines.CatenaryTool._minSagDistance", _minSagDistance);
            EditorPrefs.SetFloat("DreamteckSplines.CatenaryTool._maxSagDistance", _minSagDistance);
        }

        public override void Draw(Rect windowRect)
        {
            base.Draw(windowRect);
            if(_editSplines.Keys.Count == 0 && splines.Count > 0)
            {
                if(GUILayout.Button("Convert Selected"))
                {
                    ConvertSelected();
                }
            } else
            {
                EditorGUI.BeginChangeCheck();
                _sag = EditorGUILayout.FloatField("Sag", _sag);
                _minSagDistance = EditorGUILayout.FloatField("Min Distance", _minSagDistance);
                _maxSagDistance = EditorGUILayout.FloatField("Max Distance", _maxSagDistance);

                var keys = _editSplines.Keys;
                if (EditorGUI.EndChangeCheck())
                {
                    SceneView.RepaintAll();
                    foreach (var key in keys)
                    {
                        for (int i = 0; i < key.pointCount; i++)
                        {
                            ModifyPoint(key, i);
                        }
                        key.SetPoints(_editSplines[key]);
                    }
                }
                
                if (GUILayout.Button("Apply"))
                {
                    foreach (var key in keys)
                    {
                        EditorUtility.SetDirty(key);
                    }
                    _editSplines.Clear();
                }
            }
        }

        private void ModifyPoint(SplineComputer spline, int index)
        {
            var current = _editSplines[spline][index];
            if(index > 0)
            {
                var previous = _editSplines[spline][index - 1];
                Vector3 prevDirection = (previous.position - current.position)/3f;
                float sagAmount = Mathf.InverseLerp(_minSagDistance, _maxSagDistance, prevDirection.magnitude) * _sag;
                current.SetTangentPosition(current.position + prevDirection + Vector3.down * sagAmount);
            }

            if(index < _editSplines[spline].Length - 1)
            {
                var next = _editSplines[spline][index + 1];
                Vector3 nextDirection = (next.position - current.position) / 3f;
                float sagAmount = Mathf.InverseLerp(_minSagDistance, _maxSagDistance, nextDirection.magnitude) * _sag;
                current.SetTangent2Position(current.position + nextDirection + Vector3.down * sagAmount);
            }
            _editSplines[spline][index] = current;
        }

        private void ConvertSelected()
        {
            _editSplines.Clear();
            foreach(var spline in splines)
            {
                var points = spline.GetPoints();
                for (int i = 0; i < points.Length; i++)
                {
                    points[i].type = SplinePoint.Type.Broken;
                }
                spline.type = Spline.Type.Bezier;
                _editSplines.Add(spline, points);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Tools/CatenaryTool.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Tools/Explorer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: aa5e1620a9cb5114c9f0581fbafceb67
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---

namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEditor;

    public class Explorer : SplineTool
    {
        GUIStyle normalRow;
        GUIStyle selectedRow;
        List<SplineComputer> sceneSplines = new List<SplineComputer>();
        List<int> selected = new List<int>();
        Vector2 scroll = Vector2.zero;
        bool mouseLeft = false;

        public override string GetName()
        {
            return "Spline Explorer";
        }

        protected override string GetPrefix()
        {
            return "SplineExplorer";
        }

        public override void Open(EditorWindow window)
        {
            base.Open(window);
            normalRow = new GUIStyle(GUI.skin.box);
            normalRow.normal.background = null;
            normalRow.alignment = TextAnchor.MiddleLeft;
            selectedRow = new GUIStyle(normalRow);
            selectedRow.normal.background = SplineEditorGUI.white;
            selectedRow.normal.textColor = SplinePrefs.highlightContentColor;
            GetSceneSplines();
#if UNITY_2019_1_OR_NEWER
            SceneView.duringSceneGui += OnScene;
#else
            SceneView.onSceneGUIDelegate += OnScene;
#endif

        }

        public override void Close()
        {
            base.Close();
#if UNITY_2019_1_OR_NEWER
            SceneView.duringSceneGui -= OnScene;
#else
            SceneView.onSceneGUIDelegate -= OnScene;
#endif

        }

        void OnScene(SceneView current)
        {
            if(selected.Count > 1)
            {
                for (int i = 0; i < selected.Count; i++)
                {
                    if (!sceneSplines[selected[i]].editorAlwaysDraw)
                    {
                        DSSplineDrawer.DrawSplineComputer(sceneSplines[selected[i]]);
                    }
                }
            }
        }

        void GetSceneSplines()
        {
            sceneSplines = new List<SplineComputer>(Resources.FindObjectsOfTypeAll<SplineComputer>());
        }

        public override void Draw(Rect rect)
        {
            switch (Event.current.type)
            {
                case EventType.MouseDown:
                    if (Event.current.button == 0) mouseLeft = true; 
                    break;
                case EventType.MouseUp: if (Event.current.button == 0) mouseLeft = false; break;
            }

            Rect lastRect;
            scroll = EditorGUILayout.BeginScrollView(scroll, GUILayout.Width(rect.width), GUILayout.Height(rect.height));
            EditorGUILayout.BeginHorizontal(normalRow);
            EditorGUILayout.LabelField("Name", EditorStyles.boldLabel, GUILayout.Width(rect.width - 200));
            EditorGUILayout.LabelField("Color", EditorStyles.boldLabel, GUILayout.Width(65));
            EditorGUILayout.LabelField("Draw", EditorStyles.boldLabel, GUILayout.Width(40));
            EditorGUILayout.LabelField("Thickness", EditorStyles.boldLabel, GUILayout.Width(60));
            EditorGUILayout.EndHorizontal();
            EditorGUI.BeginChangeCheck();
            for (int i = 0; i < sceneSplines.Count; i++)
            {
                bool isSelected = selected.Contains(i);
                if (isSelected) GUI.backgroundColor = SplinePrefs.highlightColor;
                
                EditorGUILayout.BeginHorizontal(isSelected ? selectedRow : normalRow);
                EditorGUILayout.LabelField(sceneSplines[i].name, isSelected ? selectedRow : normalRow, GUILayout.Width(rect.width-200));
                GUI.backgroundColor = Color.white;
                Color pathColor = sceneSplines[i].editorPathColor;
                pathColor = EditorGUILayout.ColorField(pathColor, GUILayout.Width(65));
                if(pathColor != sceneSplines[i].editorPathColor)
                {
                    foreach (int index in selected) sceneSplines[index].editorPathColor = pathColor;
                }
                bool alwaysDraw = sceneSplines[i].editorAlwaysDraw;
                alwaysDraw = EditorGUILayout.Toggle(alwaysDraw, GUILayout.Width(40));
                if(alwaysDraw != sceneSplines[i].editorAlwaysDraw)
                {
                    foreach (int index in selected)
                    {
                        if (alwaysDraw)
                        {
                            DSSplineDrawer.RegisterComputer(sceneSplines[index]);
                        }
                        else
                        {
                            DSSplineDrawer.UnregisterComputer(sceneSplines[index]);
                        }
                    }
                }
                bool thickness = sceneSplines[i].editorDrawThickness;
                thickness = EditorGUILayout.Toggle(thickness, GUILayout.Width(40));
                if(thickness != sceneSplines[i].editorDrawThickness)
                {
                    foreach (int index in selected) sceneSplines[index].editorDrawThickness = thickness;
                }
                EditorGUILayout.EndHorizontal();
                lastRect = GUILayoutUtility.GetLastRect();
                if (mouseLeft)
                {
                    if (lastRect.Contains(Event.current.mousePosition))
                    {
                        if (Event.current.control)
                        {
                            if (!selected.Contains(i)) selected.Add(i);
                        }
                        else if (selected.Count > 0 && Event.current.shift)
                        {
                            int closest = selected[0];
                            int delta = sceneSplines.Count;
                            for (int j = 0; j < selected.Count; j++)
                            {
                                int d = Mathf.Abs(i - selected[j]);
                                if (d < delta)
                                {
                                    delta = d;
                                    closest = selected[j];
                                }
                            }
                            if (closest < i)
                            {
                                for (int j = closest + 1; j <= i; j++)
                                {
                                    if (selected.Contains(j)) continue;
                                    selected.Add(j);
                                }
                            }
                            else
                            {
                                for (int j = closest - 1; j >= i; j--)
                                {
                                    if (selected.Contains(j)) continue;
                                    selected.Add(j);
                                }
                            }
                        }
                        else selected = new List<int>(new int[] { i });
                        List<GameObject> selectGo = new List<GameObject>();
                        foreach(int index in selected) selectGo.Add(sceneSplines[index].gameObject);
                        Selection.objects = selectGo.ToArray();
                        Repaint();
                    }
                }
            }
            if (EditorGUI.EndChangeCheck()) SceneView.RepaintAll();
            EditorGUILayout.EndScrollView();
            if(Event.current.type == EventType.KeyDown)
            {
                if (Event.current.keyCode == KeyCode.DownArrow)
                {
                    if (selected.Count > 0) selected = new List<int>(new int[] { selected[0] });
                    else selected[0]++;
                }
                else if (Event.current.keyCode == KeyCode.UpArrow)
                {
                    if (selected.Count > 0) selected = new List<int>(new int[] { selected[selected.Count - 1] });
                    else selected[0]++;
                }
                if (selected.Count == 0) return;
                if (selected[0] < 0) selected[0] = sceneSplines.Count - 1;
                if (selected[0] >= sceneSplines.Count) selected[0] = 0;
                if (sceneSplines.Count > 0) Selection.activeGameObject = sceneSplines[selected[0]].gameObject;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Tools/Explorer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Tools/ImportTool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 9fac175ae39d238478fae9bbe2683559
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using System.Collections.Generic;
    using UnityEditor;
    using System.IO;
    using Dreamteck.Splines.IO;

    public class ImportExportTool : SplineTool
    {
        private float scaleFactor = 1f;
        private bool alwaysDraw = true;
        private string importPath = "";
        private string exportPath = "";
        List<SplinePoint[]> originalPoints = new List<SplinePoint[]>();
        List<SplineComputer> imported = new List<SplineComputer>();
        List<SplineComputer> exported = new List<SplineComputer>();
        GameObject importedParent = null;

        enum Mode { None, Import, Export }
        enum ExportFormat { SVG, CSV }
        enum Axis { X, Y, Z }

        Mode mode = Mode.None;
        ExportFormat format = ExportFormat.SVG;
        Axis importAxis = Axis.Z;
        Axis exportAxis = Axis.Z;

        bool importOptions = false;

        List<CSV.ColumnType> exportColumns = new List<CSV.ColumnType>();
        List<CSV.ColumnType> importColumns = new List<CSV.ColumnType>();
        bool flatCSV = false;

        public override string GetName()
        {
            return "Import/Export";
        }

        protected override string GetPrefix()
        {
            return "ImportExport";
        }

        public override void Open(EditorWindow window)
        {
            base.Open(window);
            importPath = LoadString("importPath", "");
            exportPath = LoadString("exportPath", "");
            alwaysDraw = LoadBool("alwaysDraw", true);
            flatCSV = LoadBool("flatCSV", false);
            importAxis = (Axis)LoadInt("importAxis", 2);
            exportAxis = (Axis)LoadInt("exportAxis", 2);
            LoadColumns("importColumns", ref importColumns);
            LoadColumns("exportColumns", ref exportColumns);
        }

        void LoadColumns(string name, ref List<CSV.ColumnType> destination)
        {
            string text = LoadString(name, "");
            destination = new List<CSV.ColumnType>();
            if (text == "")
            {
                destination.Add(CSV.ColumnType.Position);
                destination.Add(CSV.ColumnType.Tangent);
                destination.Add(CSV.ColumnType.Tangent2);
                destination.Add(CSV.ColumnType.Normal);
                destination.Add(CSV.ColumnType.Size);
                destination.Add(CSV.ColumnType.Color);
                return;
            }
            string[] elements = text.Split(',');
            foreach (string element in elements)
            {
                int i = 0;
                if (int.TryParse(element, out i)) destination.Add((CSV.ColumnType)i);
            } 
        }

        public override void Close()
        {
            base.Close(); 
            if(importPath != "") SaveString("importPath", Path.GetDirectoryName(importPath));
            if (exportPath != "")  SaveString("exportPath", Path.GetDirectoryName(exportPath));
            string columnString = ""; 
            foreach(CSV.ColumnType col in importColumns)
            {
                if (columnString != "") columnString += ",";
                columnString += ((int)col).ToString();
            }
            SaveString("importColumns", columnString);
            columnString = "";
            foreach (CSV.ColumnType col in exportColumns)
            {
                if (columnString != "") columnString += ",";
                columnString += ((int)col).ToString();
            }
            SaveString("exportColumns", columnString);
            SaveBool("alwaysDraw", alwaysDraw);
            SaveBool("flatCSV", flatCSV);
            SaveInt("importAxis", (int)importAxis);
            SaveInt("exportAxis", (int)exportAxis);

#if UNITY_2019_1_OR_NEWER
            SceneView.duringSceneGui -= OnScene;
#else
            SceneView.onSceneGUIDelegate -= OnScene;
#endif

        } 

        protected override void Save()
        {
            base.Save();
            if (importedParent != null)
            {
                Selection.activeGameObject = importedParent;
                importedParent = null;
            } else
            {
                foreach(SplineComputer comp in imported)
                {
                    if(comp != null)
                    {
                        Selection.activeGameObject = comp.gameObject;
                        break;
                    }
                }
            }
            imported.Clear();
#if UNITY_2019_1_OR_NEWER
            SceneView.duringSceneGui -= OnScene;
#else
            SceneView.onSceneGUIDelegate -= OnScene;
#endif

            mode = Mode.None;
        }

        protected override void Cancel()
        {
            base.Cancel();
            foreach (SplineComputer spline in imported) GameObject.DestroyImmediate(spline.gameObject);
            GameObject.DestroyImmediate(importedParent);
            imported.Clear();
            SceneView.RepaintAll();
#if UNITY_2019_1_OR_NEWER
            SceneView.duringSceneGui -= OnScene;
#else
            SceneView.onSceneGUIDelegate -= OnScene;
#endif

            mode = Mode.None;
        }

        void CSVColumnUI(List<CSV.ColumnType> columns)
        {
            EditorGUILayout.LabelField("Dataset Columns");
            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button("-", GUILayout.MaxWidth(30)) && columns.Count > 0) columns.RemoveAt(columns.Count - 1);
            for (int i = 0; i < columns.Count; i++)
            {
                columns[i] = (CSV.ColumnType)EditorGUILayout.EnumPopup(columns[i]);
            }
            if (GUILayout.Button("+", GUILayout.MaxWidth(30)) && columns.Count > 0) columns.Add(CSV.ColumnType.Position);
            EditorGUILayout.EndHorizontal();
        }

        void OnScene(SceneView current)
        {
            for (int i = 0; i < imported.Count; i++)
            {
                DSSplineDrawer.DrawSplineComputer(imported[i]);
            }
        }

        void ImportUI()
        {
            EditorGUI.BeginChangeCheck();
            scaleFactor = EditorGUILayout.FloatField("Scale Factor", scaleFactor);
            importAxis = (Axis)EditorGUILayout.EnumPopup("Facing Axis", importAxis);
            alwaysDraw = EditorGUILayout.Toggle("Always Draw", alwaysDraw);
            if (EditorGUI.EndChangeCheck()) ApplyPoints();
            SaveCancelUI();
        }

        void ExportUI()
        {
            if(exported.Count == 0)
            {
                mode = Mode.None;
                return;
            }
            EditorGUILayout.Space();
            format = (ExportFormat)EditorGUILayout.EnumPopup("Format", format);
            if (format == ExportFormat.SVG)
            {
                exportAxis = (Axis)EditorGUILayout.EnumPopup("Projection Axis", exportAxis);
                EditorGUILayout.HelpBox("The SVG is a 2D vector format so the exported spline will be flattened along the selected axis", MessageType.Info);
            }
            else
            {
                CSVColumnUI(exportColumns);
                flatCSV = EditorGUILayout.Toggle("Flat", flatCSV);
                if(flatCSV) exportAxis = (Axis)EditorGUILayout.EnumPopup("Projection Axis", exportAxis);
                EditorGUILayout.HelpBox("The exported splined will be flattened along the selected axis.", MessageType.Info);

            }

            if (GUILayout.Button("Save File"))
            {
                string extension = "*";
                switch (format)
                {
                    case ExportFormat.SVG: extension = "svg"; break;
                    case ExportFormat.CSV: extension = "csv"; break;
                }
                exportPath = EditorUtility.SaveFilePanel("Export splines", exportPath, "spline", extension);
                if (exportPath != "")
                {
                    if (Directory.Exists(Path.GetDirectoryName(exportPath)))
                    {
                        switch (format)
                        {
                            case ExportFormat.SVG: ExportSVG(exportPath); break;
                            case ExportFormat.CSV: ExportCSV(exportPath); break;
                        }
                    }
                }
            }
        }

        public override void Draw(Rect windowRect)
        {
            if (mode == Mode.Import)
            {
                ImportUI();
            } 
            else
            {
                importOptions = EditorGUILayout.Foldout(importOptions, "Import Options");
                if (importOptions) CSVColumnUI(importColumns);
                if (GUILayout.Button("Import"))
                {
                    importPath = EditorUtility.OpenFilePanel("Browse File", importPath, "svg,csv");
                    if (File.Exists(importPath))
                    {
                        splines.Clear();
                        string ext = Path.GetExtension(importPath).ToLower();
                        switch (ext)
                        {
                            case ".svg": ImportSVG(importPath); break;
                            case ".csv": ImportCSV(importPath); break;
                            case ".xml": ImportSVG(importPath); break;
                        }
                    }
                }
                exported = GetSelectedSplines();
                if (exported.Count == 0) GUI.color = new Color(1f, 1f, 1f, 0.5f);
                if (mode == Mode.Export) ExportUI();
                if (mode != Mode.Export)
                {
                    if (GUILayout.Button("Export") && exported.Count > 0) mode = Mode.Export;
                }
            }
        }

        List<SplineComputer> GetSelectedSplines()
        {
            List<SplineComputer> selected = new List<SplineComputer>();
            foreach(GameObject obj in Selection.gameObjects)
            {
                SplineComputer comp = obj.GetComponent<SplineComputer>();
                if (comp != null) selected.Add(comp);
            }
            return selected;
        }

        void ApplyPoints()
        {
            if (originalPoints.Count != imported.Count) return;
            if (imported.Count == 0) return;
            Quaternion lookRot = Quaternion.identity;
            switch (importAxis)
            {
                case Axis.X: lookRot = Quaternion.LookRotation(Vector3.right); break;
                case Axis.Y: lookRot = Quaternion.LookRotation(Vector3.down); break;
                case Axis.Z: lookRot = Quaternion.LookRotation(Vector3.forward); break;
            }
            for (int i = 0; i < imported.Count; i++)
            {
                SplinePoint[] transformed = new SplinePoint[originalPoints[i].Length];
                originalPoints[i].CopyTo(transformed, 0);
                for (int j = 0; j < transformed.Length; j++)
                {
                    transformed[j].position *= scaleFactor;
                    transformed[j].tangent *= scaleFactor;
                    transformed[j].tangent2 *= scaleFactor;

                    transformed[j].position = lookRot * transformed[j].position;
                    transformed[j].tangent = lookRot * transformed[j].tangent;
                    transformed[j].tangent2 = lookRot * transformed[j].tangent2;
                    transformed[j].normal = lookRot * transformed[j].normal;
                }
                imported[i].SetPoints(transformed);
                if (alwaysDraw)
                {
                    DSSplineDrawer.RegisterComputer(imported[i]);
                }
                else
                {
                    DSSplineDrawer.UnregisterComputer(imported[i]);
                }
            }
            SceneView.RepaintAll();
        }

        void GetImportedPoints()
        {
            foreach (SplineComputer comp in imported)
            {
                if (comp != null)
                {
                    originalPoints.Add(comp.GetPoints(SplineComputer.Space.Local));
                    mode = Mode.Import;
                } else imported.Remove(comp);
            }
        }

        void ImportSVG(string file)
        {
            SVG svg = new SVG(file);
            originalPoints.Clear();
            imported = svg.CreateSplineComputers(Vector3.zero, Quaternion.identity);
            if (imported.Count == 0) return;
            importedParent = new GameObject(svg.name);
            foreach (SplineComputer comp in imported) comp.transform.parent = importedParent.transform;
#if UNITY_2019_1_OR_NEWER
            SceneView.duringSceneGui += OnScene;
#else
            SceneView.onSceneGUIDelegate += OnScene;
#endif

            GetImportedPoints();
            ApplyPoints();
            promptSave = true;
        }

        void ExportSVG(string file)
        {
            SVG svg = new SVG(exported);
            svg.Write(file, (SVG.Axis)((int)exportAxis));
        }

        void ExportCSV(string file)
        {
            CSV csv = new CSV(exported[0]);
            csv.columns = exportColumns;
            if (flatCSV)
            { 
                switch (exportAxis)
                {
                    case Axis.X: csv.FlatX(); break;
                    case Axis.Y: csv.FlatY(); break;
                    case Axis.Z: csv.FlatZ(); break;
                }
            }
            csv.Write(file);
        }


        void ImportCSV(string file)
        {
            CSV csv = new CSV(file, importColumns);
            originalPoints.Clear();
            imported.Clear();
            imported.Add(csv.CreateSplineComputer(Vector3.zero, Quaternion.identity));
            if (imported.Count == 0) return;
#if UNITY_2019_1_OR_NEWER
            SceneView.duringSceneGui += OnScene;
#else
            SceneView.onSceneGUIDelegate += OnScene;
#endif

            GetImportedPoints();
            ApplyPoints();
            promptSave = true;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Tools/ImportTool.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Tools/LevelTerrainTool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 055df9d61bd3d9e4382c517846ff1502
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using UnityEditor;

namespace Dreamteck.Splines
{
    public class LevelTerrainTool : SplineTool
    {
        public override string GetName()
        {
            return "Level Terrain";
        }

        protected override string GetPrefix()
        {
            return "LevelTerrainTool";
        }

        public struct Point
        {
            public int x;
            public int y;

            public Vector2 vector
            {
                get { return new Vector2(x, y); }
                set {
                    x = (int)value.x;
                    y = (int)value.y;
                }
            }

            public Point(int newX, int newY)
            {
                x = newX;
                y = newY;
            }

            public Point(Vector2 input)
            {
                x = Mathf.RoundToInt(input.x);
                y = Mathf.RoundToInt(input.y);
            }
        }

        public class TerrainPaintPoint
        {
            public Point leftPoint;
            public Point rightPoint;
            public float leftHeight = 0f;
            public float rightHeight = 0f;
            public Point center;
            public float floatDiameter = 0f;

            public float GetHeight(float percent)
            {
                return Mathf.Lerp(leftHeight, rightHeight, percent);
            }
        }

        public float size = 1f;
        public int feather = 1;
        public float offset = 0f;
        public float clipFrom = 0f;
        public float clipTo = 1f;
        private float[,] heights = null;
        private Texture2D brushPreview = null;
        private Texture2D basePreview = null;
        private Texture2D drawPreview = null;

        private float maxDrawHeight = 0f;


        private bool init = false;

        Terrain terrain = null;


        void GetSplinesAndTerrain()
        {
            if(splines.Count == 0) GetSplines();
            for (int i = 0; i < Selection.gameObjects.Length; i++)
            {
                if (terrain == null)  terrain = Selection.gameObjects[i].GetComponent<Terrain>();
            }

            Terrain[] terrains = GameObject.FindObjectsOfType<Terrain>();
            if(terrains.Length == 1)
            {
                //if there is only one terrain in the scene, automatically select it
                terrain = terrains[0];
            }
        }

        void OnGUI()
        {
           // Draw();
        }

        public override void Open(EditorWindow window)
        {
            base.Open(window);
            GetSplinesAndTerrain();
        }

        public override void Close()
        {
            base.Close();
            if (promptSave)
            {
                if (EditorUtility.DisplayDialog("Apply changes?", "Changes to the terrain have been made. Do you want to keep them?", "Yes", "No"))
                {
                    SaveChanges();
                }
                else RevertToBase();
            }
        }

        public override void Draw(Rect windowRect)
        {
            base.Draw(windowRect);

            EditorGUILayout.Space();
            EditorGUI.BeginChangeCheck();
            terrain = (Terrain)EditorGUILayout.ObjectField("Terrain", terrain, typeof(Terrain), true);
            if (EditorGUI.EndChangeCheck())
            {
                heights = null;
            }

            if (splines.Count == 0) EditorGUILayout.HelpBox("No spline selected! Select an object with a SplineComputer component.", MessageType.Warning);
            if (terrain == null) EditorGUILayout.HelpBox("No terrain selected! You need to select a terrain.", MessageType.Warning);
            if (splines.Count == 0 || terrain == null) return;
            if (!init)
            {
                init = true;
                brushPreview = GenerateBrushThumbnail();
            }
            if (heights == null)
            {
                GetBase();
            }
            GUILayout.BeginHorizontal();
            GUILayout.BeginVertical();
            float lastSize = size;
            size = EditorGUILayout.FloatField("Brush radius", size);
            if (size < 0f) size = 0f;
            if(lastSize != size) brushPreview = GenerateBrushThumbnail();
            int lastBlur = feather;
            int maxFeatherCount = Mathf.Max(heights.GetLength(0)/64, 2);
            feather = EditorGUILayout.IntSlider("Feather", feather, 0, maxFeatherCount);
            if (lastBlur != feather) brushPreview = GenerateBrushThumbnail();
            GUILayout.EndVertical();
            GUILayout.Box("", GUILayout.Width(64), GUILayout.Height(64));
            Rect rect = GUILayoutUtility.GetLastRect();
            GUI.DrawTexture(rect, brushPreview);
            GUILayout.EndHorizontal();
            offset = EditorGUILayout.FloatField("Height offset", offset);
            EditorGUILayout.MinMaxSlider(new GUIContent("Spline range"), ref clipFrom, ref clipTo, 0f, 1f);
            if (GUILayout.Button("Level")) CarveTerrain();
            GUILayout.BeginHorizontal();
            GUILayout.Label("Terrain heightmap:");
            GUILayout.Label("Path heightmap:");
            GUILayout.EndHorizontal();
            GUILayout.BeginHorizontal();
            GUILayout.Box("", GUILayout.Width((windowRect.width-10)/2), GUILayout.Height((windowRect.width - 10) / 2));
            rect = GUILayoutUtility.GetLastRect();
            GUI.DrawTexture(rect, basePreview);
            GUILayout.Box("", GUILayout.Width((windowRect.width - 10) / 2), GUILayout.Height((windowRect.width - 10) / 2));
            rect = GUILayoutUtility.GetLastRect();
            GUI.DrawTexture(rect, drawPreview);
            GUILayout.EndHorizontal();

            if (promptSave)
            {
                GUILayout.BeginHorizontal();
                if (GUILayout.Button("Revert")) RevertToBase();
                if (GUILayout.Button("Apply")) SaveChanges();
                GUILayout.EndHorizontal();
            }
        }

        void OnFocus()
        {
            GetSplinesAndTerrain();
            if (promptSave)
            {
                bool isChanged = false;
                float[,] newHeights = terrain.terrainData.GetHeights(0, 0, terrain.terrainData.heightmapResolution, terrain.terrainData.heightmapResolution);
                if (newHeights.GetLength(0) != heights.GetLength(0) || newHeights.GetLength(1) != heights.GetLength(1))
                {
                    isChanged = true;
                } else {
                    for (int x = 0; x < heights.GetLength(0); x++)
                    {
                        for (int y = 0; y < heights.GetLength(1); y++)
                        {
                            if (heights[x,y] != newHeights[x, y])
                            {
                                isChanged = true;
                                break;
                            }
                        }
                    }
                }
                if (isChanged)
                {
                    if (EditorUtility.DisplayDialog("Preserve terrain ?", "The terrain has been edited from outside. Do you want to load the new height data? \r\n WARNING: Doing so will apply your leveled data to the terrain.", "Yes", "No"))
                    {
                        GetBase();
                    }
                }
            }
          
        }

        void OnLostFocus()
        {
           // RevertToBase();
        }

        void CarveTerrain()
        {
            float[,] drawLayer = new float[terrain.terrainData.heightmapResolution, terrain.terrainData.heightmapResolution];
            float[,] alphaLayer = new float[terrain.terrainData.heightmapResolution, terrain.terrainData.heightmapResolution];
            Undo.RecordObject(terrain, "Carve");
            for (int i = 0; i < splines.Count; i++)
            {
                PaintHeightMap(terrain, splines[i], ref drawLayer, ref alphaLayer);
            }

            float[,] blurLayer = new float[drawLayer.GetLength(0), drawLayer.GetLength(1)];
            GaussBlur(ref drawLayer, ref blurLayer, feather);
            float[,] blurAlphaLayer = new float[drawLayer.GetLength(0), drawLayer.GetLength(1)];
            GaussBlur(ref alphaLayer, ref blurAlphaLayer, feather);
            float[,] finalLayer = new float[drawLayer.GetLength(0), drawLayer.GetLength(1)];


            Color[] pixels = drawPreview.GetPixels();


            drawPreview = new Texture2D(drawLayer.GetLength(0), drawLayer.GetLength(1));
            for (int x = 0; x < drawLayer.GetLength(0); x++)
            {
                for (int y = 0; y < drawLayer.GetLength(1); y++)
                {
                    finalLayer[x, y] = Mathf.Lerp(heights[x, y], blurLayer[x, y], blurAlphaLayer[x,y]);
                    pixels[x * drawPreview.width + y] = Color.Lerp(Color.black, Color.white, blurLayer[x, y]/maxDrawHeight*blurAlphaLayer[x,y]);
                } 
            }
            terrain.terrainData.SetHeights(0, 0, finalLayer);
            drawPreview.SetPixels(pixels);
            drawPreview.Apply();
        }

        Texture2D GenerateBrushThumbnail()
        {
            Texture2D tex = new Texture2D(65, 65, TextureFormat.RGB24, false);
            Color[] colors = tex.GetPixels();
            for (int i = 0; i < colors.Length; i++)
            {
                colors[i] = Color.white;
            }
            //Get the brush size, compared to the blur amount
            int hmSize = ToHeightmapSize(size);
            float percent = 1f;
            if(hmSize > 0) percent = Mathf.Clamp01((float)(feather* feather) / hmSize);
            int r = Mathf.RoundToInt(30 * (1f - percent));
            int center = 32;
            for (int x = center - 30; x <= center; x++)
            {
                for (int y = center - 30; y <= center; y++)
                {
                    float value = (x - center) * (x - center) + (y - center) * (y - center);
                    int xSym = center - (x - center);
                    int ySym = center - (y - center);

                    if (value <= r * r)
                    {
                        colors[x * tex.width + y] = Color.black;
                        colors[xSym * tex.width + y] = Color.black;
                        colors[x * tex.width + ySym] = Color.black;
                        colors[xSym * tex.width + ySym] = Color.black;
                    } else 
                    if (value <= 30 * 30 && value > r*r)
                    {
                        float rr = r * r;
                        float val = value - rr;
                        float div = 30 * 30 - rr;
                        float alpha = Mathf.Clamp01(val / div);
                        //Debug.Log(val + "/" + div + " = " + alpha);
                        Color col = Color.Lerp(Color.black, Color.white, alpha);
                        colors[x * tex.width + y] = col;
                        colors[xSym * tex.width + y] = col;
                        colors[x * tex.width + ySym] = col;
                        colors[xSym * tex.width + ySym] = col;
                    }
                    if (value <= 30 * 30 && value >= 29 * 29)
                    {
                        Color col = Color.Lerp(Color.gray, Color.white, 1f-percent);
                        colors[x * tex.width + y] = col;
                        colors[xSym * tex.width + y] = col;
                        colors[x * tex.width + ySym] = col;
                        colors[xSym * tex.width + ySym] = col;
                    }
                }
            }


            tex.SetPixels(colors);
            tex.Apply();
            return tex;
        }

        void GetBase()
        {
            GetSplinesAndTerrain();
            if (terrain == null) return;
            heights = terrain.terrainData.GetHeights(0, 0, terrain.terrainData.heightmapResolution, terrain.terrainData.heightmapResolution);
            basePreview = new Texture2D(heights.GetLength(0), heights.GetLength(1));
            drawPreview = new Texture2D(heights.GetLength(0), heights.GetLength(1));
            Color[] pixels = new Color[basePreview.width * basePreview.height];
            Color[] blackPixels = new Color[basePreview.width * basePreview.height];
            float maxHeight = 0f;
            for (int x = 0; x < basePreview.width; x++)
            {
                for(int y = 0; y < basePreview.height; y++)
                {
                    if (heights[x, y] > maxHeight) maxHeight = heights[x, y];
                    pixels[x * basePreview.width + y] = Color.Lerp(Color.black, Color.white, heights[x, y]);
                    blackPixels[x * basePreview.width + y] = Color.black;
                }
            }
            if(maxHeight > 0f)
            {
                for (int x = 0; x < basePreview.width; x++)
                {
                    for (int y = 0; y < basePreview.height; y++)
                    {
                        pixels[x * basePreview.width + y] /= maxHeight;
                    }
                }
            }
            basePreview.SetPixels(pixels);
            basePreview.Apply();
            drawPreview.SetPixels(blackPixels);
            drawPreview.Apply();
            promptSave = false;
        }

        void SaveChanges()
        {
            GetBase();
        }

        void RevertToBase()
        {
            if (terrain == null) return;
            terrain.terrainData.SetHeights(0, 0, heights);
            heights = null;
        }

        void PaintHeightMap(Terrain terrain, SplineComputer computer, ref float[,] drawLayer, ref float[,] alphaLayer)
        {
            if (heights == null) GetBase();
            SplineSample[] results = new SplineSample[computer.iterations];
            computer.Evaluate(ref results, clipFrom, clipTo);
            Draw(results, ref drawLayer, ref alphaLayer);          
        }


        int ToHeightmapSize(float value)
        {
            float avgSize = (terrain.terrainData.size.x + terrain.terrainData.size.z) / 2f;
            int result = Mathf.RoundToInt(value / avgSize * terrain.terrainData.heightmapResolution);
            return result;
        }

        Point ToHeightmapCoords(Vector3 pos)
        {
            Vector3 terrainPos = pos - terrain.transform.position;
            terrainPos.x /= terrain.terrainData.size.x;
            terrainPos.z /= terrain.terrainData.size.z;
            terrainPos.x = Mathf.Clamp01(terrainPos.x);
            terrainPos.z = Mathf.Clamp01(terrainPos.z);
            int x = Mathf.RoundToInt(terrainPos.z * terrain.terrainData.heightmapResolution);
            int y = Mathf.RoundToInt(terrainPos.x * terrain.terrainData.heightmapResolution);
            return new Point(x, y);
        }

        float ToHeightmapValue(float y)
        {
            float terrainHeight = y - terrain.transform.position.y;
            terrainHeight /= terrain.terrainData.size.y;
            return terrainHeight;
        }

        void PaintSegment(TerrainPaintPoint fromPoint, TerrainPaintPoint toPoint, ref float[,] layer, ref float[,] alphaLayer, bool writeAlpha = true, bool overWriteHeight = true)
        {
            //Flip the points if the forward one has a bigger radius so the lerp can work well
            if (Vector2.Distance(fromPoint.leftPoint.vector, fromPoint.rightPoint.vector) < Vector2.Distance(toPoint.leftPoint.vector, toPoint.rightPoint.vector))
            {
                TerrainPaintPoint temp = fromPoint;
                fromPoint = toPoint;
                toPoint = temp;
            }

            List<Point> drawn = new List<Point>();
            Vector2 currentPosition = fromPoint.leftPoint.vector;
            Vector2 fromRight = fromPoint.rightPoint.vector;

            float alphaStartPercent = 0f;
            float alphaEndPercent = 1f;
            if(feather > 0)
            {
                currentPosition += (fromPoint.leftPoint.vector - fromPoint.center.vector).normalized * feather * 4f;
                fromRight += (fromPoint.rightPoint.vector - fromPoint.center.vector).normalized * feather * 4f;
                float span = (fromPoint.leftPoint.vector - fromPoint.rightPoint.vector).magnitude / (fromRight - currentPosition).magnitude;
                float rest = (1f - span) / 2f;
                alphaStartPercent = rest;
                alphaEndPercent = 1f - rest;
            }
            float armLength = Vector2.Distance(currentPosition, fromRight);
            if (armLength < 1f) return;
            while (true)
            {
                float armDistance = Vector2.Distance(currentPosition, fromRight);
                float armPercent = 1f-armDistance / armLength;
                //This can be optimized, take it outside of the cycle
                Point fromPos = new Point(currentPosition);
                Vector2 leftvector = toPoint.leftPoint.vector;
                Vector2 rightVector = toPoint.rightPoint.vector;
                if (feather > 0)
                {
                    leftvector += (toPoint.leftPoint.vector - toPoint.center.vector).normalized * feather * 4f;
                    rightVector += (toPoint.rightPoint.vector - toPoint.center.vector).normalized * feather * 4f;
                }
                Vector2 toArm = Vector2.Lerp(leftvector, rightVector, armPercent);

                Point toPos = new Point(toArm);
                int dx = Mathf.Abs(toPos.x - fromPos.x), sx = fromPos.x < toPos.x ? 1 : -1;
                int dy = -Mathf.Abs(toPos.y - fromPos.y), sy = fromPos.y < toPos.y ? 1 : -1;
                int err = dx + dy, e2;
                Point current = fromPos;
                Vector2 target = new Vector2(toPos.x - fromPos.x, toPos.y - fromPos.y);
                
                float fromHeight = fromPoint.GetHeight(armPercent);
                float toHeight = toPoint.GetHeight(armPercent);
                while (true)
                {
                    if (current.x >= 0 && current.x < layer.GetLength(0) && current.y >= 0 && current.y < layer.GetLength(1))
                    {
                        if (overWriteHeight || layer[current.x, current.y] == 0f)
                        {
                            if (!ContainsPoint(ref drawn, current))
                            {
                                Vector2 currentDist = new Vector2(current.x - fromPos.x, current.y - fromPos.y);
                                float positionPercent = Mathf.Clamp01(currentDist.magnitude / target.magnitude);
                                float height = Mathf.Lerp(fromHeight, toHeight, positionPercent);
                                float alphaValue = 0f;
                                if (armPercent >= alphaStartPercent && armPercent <= alphaEndPercent) alphaValue = 1f;
                                if (writeAlpha) Plot(current.x, current.y, height, alphaValue, ref alphaLayer, ref layer);
                                else Plot(current.x, current.y, height, alphaLayer[current.x, current.y], ref alphaLayer, ref layer);
                                drawn.Add(current);
                            }
                        }
                    }
                    if (current.x == toPos.x && current.y == toPos.y) break;
                    e2 = 2 * err;
                    if (e2 > dy)
                    {
                        err += dy;
                        current.x += sx;
                    } else if (e2 < dx)
                    {
                        err += dx;
                        current.y += sy;
                    }
                }
                if (currentPosition == fromRight) break;
                currentPosition = Vector2.MoveTowards(currentPosition, fromRight, 1f);
            }
         }

        private bool ContainsPoint(ref List<Point> list, Point point)
        {
            for(int i = 0; i < list.Count; i++)
            {
                if (list[i].x == point.x && list[i].y == point.y) return true;
            }
            return false;
        }

        void Draw(SplineSample[] points, ref float[,] drawLayer, ref float[,] alphaLayer)
        {
            List<SplineSample> selectedPoints = new List<SplineSample>();
            Point last = new Point();
            //Filter out points that are too close to each other
            for (int i = 0; i < points.Length; i++)
            {
                Point current = ToHeightmapCoords(points[i].position + points[i].up * offset);
                if (i == 0 || i == points.Length-1)
                {
                    last = new Point(current.x, current.y);
                    selectedPoints.Add(points[i]);
                } else if (Vector2.Distance(new Vector2(current.x, current.y), new Vector2(last.x, last.y)) >= 1.5f)
                {
                    selectedPoints.Add(points[i]);
                    last = new Point(current.x, current.y);
                }
            }
            if (selectedPoints.Count <= 1) return;
            TerrainPaintPoint[] paintPoints = new TerrainPaintPoint[selectedPoints.Count];
            for (int i = 0; i < selectedPoints.Count; i++)
            {
                ConvertToPaintPoint(selectedPoints[i], ref paintPoints[i]);
            }
            //Paint the points
            for (int i = 0; i < paintPoints.Length - 1; i++)
            {
                promptSave = true;
                PaintSegment(paintPoints[i], paintPoints[i + 1], ref drawLayer, ref alphaLayer);
            }

            SplineSample exResult = selectedPoints[0];
            exResult.position += exResult.position - selectedPoints[1].position;
            TerrainPaintPoint exPoint = null;
            ConvertToPaintPoint(exResult, ref exPoint);
            PaintSegment(paintPoints[0], exPoint, ref drawLayer, ref alphaLayer, false, false);

            exResult = selectedPoints[selectedPoints.Count-1];
            exResult.position += exResult.position - selectedPoints[selectedPoints.Count - 2].position;
            ConvertToPaintPoint(exResult, ref exPoint);
            PaintSegment(paintPoints[paintPoints.Length-1], exPoint, ref drawLayer, ref alphaLayer, false, false);
            //Extrapolate the ending and the begining
        }

        TerrainPaintPoint ConvertToPaintPoint(SplineSample result, ref TerrainPaintPoint paintPoint)
        {
            paintPoint = new TerrainPaintPoint();
            Vector3 right = -Vector3.Cross(result.forward, result.up).normalized * size * 0.5f * result.size;
            Vector3 leftPoint = result.position - right + result.up * offset;
            Vector3 rightPoint = result.position + right + result.up * offset;
            paintPoint.center = ToHeightmapCoords(result.position + result.up * offset);
            paintPoint.leftPoint = ToHeightmapCoords(leftPoint);
            paintPoint.rightPoint = ToHeightmapCoords(rightPoint);
            paintPoint.leftHeight = ToHeightmapValue(leftPoint.y);
            paintPoint.rightHeight = ToHeightmapValue(rightPoint.y);
            paintPoint.floatDiameter = Vector2.Distance(new Vector2(leftPoint.x, leftPoint.z), new Vector2(rightPoint.x, rightPoint.z));
            if (paintPoint.leftHeight > maxDrawHeight) maxDrawHeight = paintPoint.leftHeight;
            if (paintPoint.rightHeight > maxDrawHeight) maxDrawHeight = paintPoint.rightHeight;
            return paintPoint;
        }


        Point Project(Point fromPoint, Point toPoint, int x, int y)
        {
            Vector2 dir = toPoint.vector - fromPoint.vector;
            Vector2 point = new Vector2(x, y);
            dir.Normalize();
            Vector2 v = point - fromPoint.vector;
            float d = Vector2.Dot(v, dir);
            return new Point(fromPoint.vector + dir * d);
        }

        void GaussBlur(ref float[,] source, ref float[,] target, int r)
        {
            int w = source.GetLength(0);
            int h = source.GetLength(1);
            int[] bxs = GBGetBoxes(r, 3);
            float[] flatSource = new float[source.GetLength(0) * source.GetLength(1)];
            float[] flatTarget = new float[source.GetLength(0) * source.GetLength(1)];
            for (int x = 0; x < source.GetLength(0); x++)
            {
                for (int y = 0; y < source.GetLength(1); y++)
                {
                    if (r == 0) target[x, y] = source[x, y];
                    else flatSource[x * source.GetLength(0) + y] = source[x, y];
                }
            }
            if (r == 0) return;
            BoxBlur(ref flatSource, ref flatTarget, w, h, (bxs[0] - 1) / 2);
            BoxBlur(ref flatTarget, ref flatSource, w, h, (bxs[1] - 1) / 2);
            BoxBlur(ref flatSource, ref flatTarget, w, h, (bxs[2] - 1) / 2);

            for (int i = 0; i < flatSource.Length; i++)
            {
                int x = Mathf.FloorToInt(i / source.GetLength(0));
                int y = i - x * source.GetLength(0);
                target[x, y] = flatTarget[i];
            }
        }

        int[] GBGetBoxes(int sigma, int n)
        {
            float wIdeal = Mathf.Sqrt((12 * sigma * sigma / n) + 1);
            int wl = Mathf.FloorToInt(wIdeal); if (wl % 2 == 0) wl--;
            int wu = wl + 2;

            float mIdeal = (12 * sigma * sigma - n * wl * wl - 4 * n * wl - 3 * n) / (-4 * wl - 4);
            float m = Mathf.Round(mIdeal);

            int[] sizes = new int[n];
            for (int i = 0; i < n; i++) sizes[i] = i < m ? wl : wu;
            return sizes;
        }

        void BoxBlur(ref float[] source, ref float[] target, int w, int h, int r)
        {
            for (int i = 0; i < source.Length; i++) target[i] = source[i];
            HorizontalBlur(ref target, ref source, w, h, r);
            VerticalBlur(ref source, ref target, w, h, r);
        }

        void HorizontalBlur(ref float[] source, ref float[] target, int w, int h, int r)
        {
            float iarr = 1f / (r*2f + 1f);
            for (int i = 0; i < h; i++)
            {
                int ti = i * w, li = ti, ri = ti + r;
                float fv = source[ti], lv = source[ti + w - 1], val = (r + 1) * fv;
                for (int j = 0; j < r; j++) val += source[ti + j];
                for (int j = 0; j <= r; j++) { val += source[ri++] - fv; target[ti++] = val * iarr; }
                for (int j = r + 1; j < w - r; j++) { val += source[ri++] - source[li++]; target[ti++] = val * iarr; }
                for (int j = w - r; j < w; j++) { val += lv - source[li++]; target[ti++] = val * iarr; }
            }
        }

        void VerticalBlur(ref float[] source, ref float[] target, int w, int h, int r)
        {
            float iarr = 1f / (r * 2f + 1f);
            for (int i = 0; i < w; i++)
            {
                int ti = i, li = ti, ri = ti + r * w;
                float fv = source[ti], lv = source[ti + w * (h - 1)], val = (r + 1) * fv;
                for (var j = 0; j < r; j++) val += source[ti + j * w];
                for (var j = 0; j <= r; j++) { val += source[ri] - fv; target[ti] = val * iarr; ri += w; ti += w; }
                for (var j = r + 1; j < h - r; j++) { val += source[ri] - source[li]; target[ti] = val * iarr; li += w; ri += w; ti += w; }
                for (var j = h - r; j < h; j++) { val += lv - source[li]; target[ti] = val * iarr; li += w; ti += w; }
            }
        }


        private void Plot(int x, int y, float value, float alpha, ref float[,] alphaTarget, ref float[,] target)
        {
            if (x < 0 || x >= target.GetLength(0)) return;
            if (y < 0 || y >= target.GetLength(1)) return;
            if (value > target[x, y])
            {
                target[x, y] = value;
                alphaTarget[x, y] = alpha;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Tools/LevelTerrainTool.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Tools/ObjectSpawnTool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 3e6dd39825fd0634e9f633f90371a585
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System.Collections;
    using System.Collections.Generic;
    using UnityEditor;
    using System.IO;

    public class ObjectSpawnTool : SplineTool
    {
        internal class SpawnCollection
        {
            public class SpawnObject
            {
                public GameObject instance;
                public GameObject source;

                public SpawnObject(GameObject instance, GameObject source)
                {
                    this.instance = instance;
                    this.source = source;
                }
            }

            internal SplineComputer spline;
            internal List<SpawnObject> objects = new List<SpawnObject>();

            internal void Clear()
            {
                for (int i = 0; i < objects.Count; i++) Object.DestroyImmediate(objects[i].instance);
                objects.Clear();
            }

            internal void Spawn(GameObject obj, Vector3 position, Quaternion rotation)
            {
                GameObject go = null;
                bool isPrefab = PrefabUtility.GetPrefabAssetType(obj) != PrefabAssetType.NotAPrefab;

                if (isPrefab) go = (GameObject)PrefabUtility.InstantiatePrefab(obj);
                else go = Object.Instantiate(obj, position, rotation);
                go.transform.parent = spline.transform;
                objects.Add(new SpawnObject(go, obj));
            }

            internal void Destroy(int index)
            {
                Object.DestroyImmediate(objects[index].instance);
                objects.RemoveAt(index);
            }

            internal SpawnCollection(SplineComputer spline)
            {
                this.spline = spline;
            }
        }

        internal List<SpawnCollection> collections = new List<SpawnCollection>();
        double clipFrom = 0.0, clipTo = 1.0;
        List<GameObject> objects = new List<GameObject>();
        int spawnCount = 1;
        enum Iteration { Ordered, Random }
        Iteration iteration = Iteration.Ordered;
        private int offsetSeed = 0;
        private int rotationSeed = 0;
        private int scaleSeed = 0;
        private int orderSeed = 0;
        private float positionOffset = 0f;
        private Vector2 randomSize = Vector2.one;
        private Vector2 offset = Vector2.zero;
        private Vector3 minRotationOffset = Vector3.zero;
        private Vector3 maxRotationOffset = Vector3.zero;
        private Vector3 minScaleMultiplier = Vector3.one;
        private Vector3 maxScaleMultiplier = Vector3.one;
        private bool randomizeOffset = false;
        private bool useRandomOffsetRotation = false;
        private bool shellOffset = true;
        private bool applyRotation = true;
        private bool applyScale = false;
        bool uniform = false;

        SplineSample result = new SplineSample();

        System.Random orderRandom, offsetRandom, rotationRandom, scaleRandom;

        public override string GetName()
        {
            return "Spawn Objects";
        }

        protected override string GetPrefix()
        {
            return "ObjectSpawnTool";
        }

        public override void Close()
        {
            base.Close();
            for (int i = 0; i < splines.Count; i++) splines[i].onRebuild -= Rebuild;
            if (promptSave)
            {
                if (EditorUtility.DisplayDialog("Save changes?", "You are about to close the Object Spawn Tool, do you want to save the generated objects?", "Yes", "No")) Save();
                else Cancel();
            }
            else Cancel();
            promptSave = false;
#if UNITY_2019_1_OR_NEWER
            SceneView.duringSceneGui -= OnScene;
#else
            SceneView.onSceneGUIDelegate -= OnScene;
#endif

        }

        public override void Open(EditorWindow window)
        {
            base.Open(window);
            GetSplines();
            collections.Clear();
            for (int i = 0; i < splines.Count; i++)
            {
                collections.Add(new SpawnCollection(splines[i]));
                splines[i].onRebuild += Rebuild;
            }
            Rebuild();
#if UNITY_2019_1_OR_NEWER
            SceneView.duringSceneGui += OnScene;
#else
            SceneView.onSceneGUIDelegate += OnScene;
#endif

        }

        void OnScene(SceneView current)
        {
            for (int i = 0; i < collections.Count; i++)
            {
                if (collections[i].spline != null) DSSplineDrawer.DrawSplineComputer(collections[i].spline);
            }
        }

        protected override void OnSplineAdded(SplineComputer spline)
        {
            base.OnSplineAdded(spline);
            collections.Add(new SpawnCollection(spline));
            spline.onRebuild += Rebuild;
            Rebuild();
        }

        protected override void OnSplineRemoved(SplineComputer spline)
        {
            base.OnSplineRemoved(spline);
            for (int i = 0; i < collections.Count; i++)
            {
                if (collections[i].spline == spline)
                {
                    collections[i].Clear();
                    collections.RemoveAt(i);
                    spline.onRebuild -= Rebuild;
                    Rebuild();
                    return;
                }
            }
        }

        public override void Draw(Rect windowRect)
        {
            base.Draw(windowRect);
            if (splines.Count == 0)
            {
                EditorGUILayout.HelpBox("No spline selected! Select an object with a SplineComputer component.", MessageType.Warning);
                return;
            }
            EditorGUI.BeginChangeCheck();
            ClipUI(ref clipFrom, ref clipTo);
            uniform = EditorGUILayout.Toggle("Uniform Samples", uniform);
            EditorGUILayout.Space();
            float labelWidth = EditorGUIUtility.labelWidth;
            float fieldWidth = EditorGUIUtility.fieldWidth;
            EditorGUIUtility.labelWidth = 0;
            EditorGUIUtility.fieldWidth = 0;

            EditorGUILayout.BeginVertical();
            for (int i = 0; i < objects.Count; i++)
            {
                EditorGUILayout.BeginHorizontal();
                objects[i] = (GameObject)EditorGUILayout.ObjectField(objects[i], typeof(GameObject), true);
                if (GUILayout.Button("x", GUILayout.Width(20)))
                {
                    objects.RemoveAt(i);
                    i--;
                    Rebuild();
                    Repaint();
                    continue;
                }
                if (i > 0)
                {
                    if (GUILayout.Button("▲", GUILayout.Width(20)))
                    {
                        GameObject temp = objects[i - 1];
                        objects[i - 1] = objects[i];
                        objects[i] = temp;
                        Rebuild();
                    }
                }
                if (i < objects.Count - 1)
                {
                    if (GUILayout.Button("▼", GUILayout.Width(20)))
                    {
                        GameObject temp = objects[i + 1];
                        objects[i + 1] = objects[i];
                        objects[i] = temp;
                        Rebuild();
                    }
                }
                EditorGUILayout.EndHorizontal();
            }
            EditorGUILayout.EndVertical();
            GameObject newObj = null;
            newObj = (GameObject)EditorGUILayout.ObjectField("Add Object", newObj, typeof(GameObject), true);
            if (newObj != null)
            {
                objects.Add(newObj);
                Rebuild();
            }
            EditorGUILayout.Space();

            EditorGUIUtility.labelWidth = labelWidth;
            EditorGUIUtility.fieldWidth = fieldWidth;
            bool hasObj = false;
            for (int i = 0; i < objects.Count; i++)
            {
                if (objects[i] != null)
                {
                    hasObj = true;
                    break;
                }
            }

            if (hasObj) spawnCount = EditorGUILayout.IntField("Spawn count", spawnCount);
            else spawnCount = 0;
            iteration = (Iteration)EditorGUILayout.EnumPopup("Iteration", iteration);
            if (iteration == Iteration.Random) orderSeed = EditorGUILayout.IntField("Order Seed", orderSeed);

            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Transform", EditorStyles.boldLabel);
            applyRotation = EditorGUILayout.Toggle("Apply Rotation", applyRotation);
            if (applyRotation)
            {
                EditorGUI.indentLevel++;
                minRotationOffset = EditorGUILayout.Vector3Field("Min. Rotation Offset", minRotationOffset);
                maxRotationOffset = EditorGUILayout.Vector3Field("Max. Rotation Offset", maxRotationOffset);
                rotationSeed = EditorGUILayout.IntField("Rotation Seed", rotationSeed);
                EditorGUI.indentLevel--;
            }
            applyScale = EditorGUILayout.Toggle("Apply Scale", applyScale);
            if (applyScale)
            {
                EditorGUI.indentLevel++;
                minScaleMultiplier = EditorGUILayout.Vector3Field("Min. Scale Multiplier", minScaleMultiplier);
                maxScaleMultiplier = EditorGUILayout.Vector3Field("Max. Scale Multiplier", maxScaleMultiplier);
                scaleSeed = EditorGUILayout.IntField("Scale Seed", scaleSeed);
                EditorGUI.indentLevel--;
            }

            positionOffset = EditorGUILayout.Slider("Evaluate Offset", positionOffset, -1f, 1f);

            offset = EditorGUILayout.Vector2Field("Offset", offset);
            randomizeOffset = EditorGUILayout.Toggle("Randomize Offset", randomizeOffset);
            if (randomizeOffset)
            {
                randomSize = EditorGUILayout.Vector2Field("Size", randomSize);
                offsetSeed = EditorGUILayout.IntField("Offset Seed", offsetSeed);
                shellOffset = EditorGUILayout.Toggle("Shell", shellOffset);
                useRandomOffsetRotation = EditorGUILayout.Toggle("Apply offset rotation", useRandomOffsetRotation);
            }

            if (EditorGUI.EndChangeCheck())
            {
                promptSave = true;
                Rebuild();
            }

            EditorGUILayout.BeginHorizontal();
            if(collections.Count > 0)
            {
                if (GUILayout.Button("Save"))
                {
                    Save();
                }
                if (GUILayout.Button("Cancel"))
                {
                    Cancel();
                }
            } else
            {
                if (GUILayout.Button("New")) Open(windowInstance);
            }
            EditorGUILayout.EndHorizontal();
        }

        protected override void Save()
        {
            base.Save();
            //register created object undo for each object in collections
            collections.Clear();
            //Set scene dirty
        }

        protected override void Cancel()
        {
            base.Cancel();
            foreach (SpawnCollection collection in collections) collection.Clear();
            collections.Clear();
        }

        void InitializeRandomization()
        {
            orderRandom = new System.Random(orderSeed);
            if (randomizeOffset) offsetRandom = new System.Random(offsetSeed);
            if(applyRotation) rotationRandom = new System.Random(rotationSeed);
            if(applyScale) scaleRandom = new System.Random(scaleSeed);
        }

        protected override void Rebuild()
        {
            base.Rebuild();
            if (objects.Count == 0) return;
            InitializeRandomization();
            foreach (SpawnCollection c in collections)
            {
                if(c == null) continue;
                if (c.spline == null || spawnCount <= 0)
                {
                    c.Clear();
                    continue;
                }
                HandleCollection(c);
            }
        }

        void HandleCollection(SpawnCollection collection)
        {
            collection.Clear();
            if (collection.spline == null) return;
            while(collection.objects.Count > spawnCount && collection.objects.Count >= 0) collection.Destroy(collection.objects.Count - 1);
            int orderIndex = 0;
            while (collection.objects.Count < spawnCount)
            {
                switch (iteration)
                {
                    case Iteration.Ordered:
                        collection.Spawn(objects[orderIndex], Vector3.zero, Quaternion.identity);
                        orderIndex++;
                        if (orderIndex >= objects.Count) orderIndex = 0;
                        break;
                    case Iteration.Random:
                        collection.Spawn(objects[orderRandom.Next(objects.Count)], Vector3.zero, Quaternion.identity);
                        break;
                }
            }
            float splineLength = 0f;
            if (uniform) splineLength = collection.spline.CalculateLength() * (float)(clipTo - clipFrom);
            for (int i = 0; i < spawnCount; i++)
            {
                double percent = 0.0;
                if(spawnCount > 1) percent = (double)i / (spawnCount - 1);
                double evaluate = 0.0;
                if (uniform) evaluate = collection.spline.Travel(clipFrom, splineLength * (float)percent, Spline.Direction.Forward);
                else evaluate = DMath.Lerp(clipFrom, clipTo, percent);
                //Handle uniform splines
                evaluate += positionOffset;
                if (evaluate > 1f) evaluate -= 1f;
                else if (evaluate < 0f) evaluate += 1f;
                collection.spline.Evaluate(evaluate, ref result);
                HandleObject(collection.objects[i]);
            }
        }

        void HandleObject(SpawnCollection.SpawnObject obj)
        {
            Transform instanceTransform = obj.instance.transform;
            Transform sourceTransform = obj.source.transform;
            Vector3 right = result.right;
            instanceTransform.position = result.position;
            instanceTransform.position += -right * offset.x + result.up * offset.y;
            Quaternion offsetRot = Quaternion.Euler(minRotationOffset);

            if (applyRotation)
            {
                offsetRot = Quaternion.Euler(Mathf.Lerp(minRotationOffset.x, maxRotationOffset.x, (float)rotationRandom.NextDouble()), Mathf.Lerp(minRotationOffset.y, maxRotationOffset.y, (float)rotationRandom.NextDouble()), Mathf.Lerp(minRotationOffset.z, maxRotationOffset.z, (float)rotationRandom.NextDouble()));
                instanceTransform.rotation = result.rotation * offsetRot;
            }

            if (randomizeOffset)
            {
                float distance = (float)offsetRandom.NextDouble();
                float angleInRadians = (float)offsetRandom.NextDouble() * 360f * Mathf.Deg2Rad;
                Vector2 randomCircle = new Vector2(distance * Mathf.Cos(angleInRadians), distance * Mathf.Sin(angleInRadians));
                if (shellOffset) randomCircle.Normalize();
                else randomCircle = Vector2.ClampMagnitude(randomCircle, 1f);
                instanceTransform.position += randomCircle.x * right * randomSize.x * result.size * 0.5f + randomCircle.y * result.up * randomSize.y * result.size * 0.5f;
                if (useRandomOffsetRotation) instanceTransform.rotation = Quaternion.LookRotation(result.forward, instanceTransform.position - result.position) * offsetRot;
            }

            if (applyScale)
            {
                Vector3 scale = sourceTransform.localScale * result.size;
                scale.x *= Mathf.Lerp(minScaleMultiplier.x, maxScaleMultiplier.x, (float)scaleRandom.NextDouble());
                scale.y *= Mathf.Lerp(minScaleMultiplier.y, maxScaleMultiplier.y, (float)scaleRandom.NextDouble());
                scale.z *= Mathf.Lerp(minScaleMultiplier.z, maxScaleMultiplier.z, (float)scaleRandom.NextDouble());
                instanceTransform.localScale = scale;
            } else instanceTransform.localScale = sourceTransform.localScale;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Tools/ObjectSpawnTool.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Tools/SplineTool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d43ab6043eb5d1a429ba1bfac215730e
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using UnityEditor;

namespace Dreamteck.Splines
{
    public class SplineTool
    {
        protected List<SplineComputer> splines = new List<SplineComputer>();
        protected bool promptSave = false;
        protected EditorWindow windowInstance = null;

        public virtual string GetName()
        {
            return "Tool";
        }

        public virtual void Open(EditorWindow window)
        {
            windowInstance = window;
            GetSplines();
        }

        public virtual void Close()
        {
            if(promptSave) ClosingDialog();
        }

        private void ClosingDialog()
        {
            if (EditorUtility.DisplayDialog("Unsaved Changes", ClosingDialogText(), "Yes", "No")) Save();
            else Cancel();
        }

        protected virtual string ClosingDialogText()
        {
            return "There are unsaved changes. Do you wish to save them?";
        }

        protected virtual void Save()
        {
            promptSave = false;
        }

        protected virtual void Cancel()
        {
            promptSave = false;
        }

        protected virtual string GetPrefix()
        {
            return "SplineTool";
        }

        public virtual void Draw(Rect rect)
        {
            //EditorGUILayout.LabelField("Spline User", EditorStyles.boldLabel);

            EditorGUILayout.LabelField("Selected Splines", EditorStyles.boldLabel);
            for (int i = 0; i < splines.Count; i++)
            {
                SplineComputer lastComputer = splines[i];
                splines[i] = (SplineComputer)EditorGUILayout.ObjectField(splines[i], typeof(SplineComputer), true);
                if (splines[i] == null)
                {
                    splines.RemoveAt(i);
                    i--;
                    OnSplineRemoved(lastComputer);
                    continue;
                }
                if (lastComputer != splines[i])
                {
                    for (int j = 0; j < splines.Count; j++)
                    {
                        if (j == i) continue;
                        if (splines[j] == splines[i])
                        {
                            splines[i] = lastComputer;
                            break;
                        }
                    }
                }
            }
            SplineComputer newComp = null;
            newComp = (SplineComputer)EditorGUILayout.ObjectField(newComp, typeof(SplineComputer), true);
            if(newComp != null)
            {
                for (int i = 0; i < splines.Count; i++)
                {
                    if (splines[i] == newComp)
                    {
                        newComp = null;
                        break;
                    }
                }
                if (newComp != null)
                {
                    splines.Add(newComp);
                    OnSplineAdded(newComp);
                }
            }
            EditorGUILayout.Space();
        }

        protected virtual void OnSplineAdded(SplineComputer spline)
        {

        }

        protected virtual void OnSplineRemoved(SplineComputer spline)
        {

        }

        protected void ClipUI(SplineUser user)
        {
            float fclipFrom = (float)user.clipFrom, fclipTo = (float)user.clipTo;
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.MinMaxSlider(new GUIContent("Clip range:"), ref fclipFrom, ref fclipTo, 0f, 1f);
            EditorGUILayout.BeginHorizontal(GUILayout.MaxWidth(30));
            user.clipFrom = EditorGUILayout.FloatField(fclipFrom);
            user.clipTo = EditorGUILayout.FloatField(fclipTo);
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.EndHorizontal();
        }

        protected void ClipUI(ref double from, ref double to)
        {
            float fclipFrom = (float)from, fclipTo = (float)to;
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.MinMaxSlider(new GUIContent("Clip range:"), ref fclipFrom, ref fclipTo, 0f, 1f);
            EditorGUILayout.BeginHorizontal(GUILayout.MaxWidth(30));
            from = EditorGUILayout.FloatField(fclipFrom);
            to = EditorGUILayout.FloatField(fclipTo);
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.EndHorizontal();
        }

        protected void SaveCancelUI()
        {
            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button("Save")) Save();
            if (GUILayout.Button("Cancel")) Cancel();
            EditorGUILayout.EndHorizontal();
        }

        protected virtual void Rebuild()
        {
            
        }

        protected void Repaint()
        {
            windowInstance.Repaint();
        }

        protected void GetSplines()
        {
            splines.Clear();
            for (int i = 0; i < Selection.gameObjects.Length; i++)
            {
                splines.Add(Selection.gameObjects[i].GetComponent<SplineComputer>());
            }
        }

        protected float LoadFloat(string name, float d)
        {
            return EditorPrefs.GetFloat(GetPrefix() + "_" + name, d);
        }

        protected string LoadString(string name, string d)
        {
            return EditorPrefs.GetString(GetPrefix() + "_" + name, d);
        }

        protected bool LoadBool(string name, bool d)
        {
            return EditorPrefs.GetBool(GetPrefix() + "_" + name, d);
        }

        protected int LoadInt(string name, int d)
        {
            return EditorPrefs.GetInt(GetPrefix() + "_" + name, d);
        }

        protected void SaveFloat(string name, float value)
        {
             EditorPrefs.SetFloat(GetPrefix() + "_" + name, value);
        }

        protected void SaveString(string name, string value)
        {
             EditorPrefs.SetString(GetPrefix() + "_" + name, value);
        }

        protected void SaveBool(string name, bool value)
        {
             EditorPrefs.SetBool(GetPrefix() + "_" + name, value);
        }

        protected void SaveInt(string name, int value)
        {
             EditorPrefs.SetInt(GetPrefix() + "_" + name, value);
        }
    }

}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Tools/SplineTool.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Tools/SplineToolsWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e87a0b749a684c34c84ee3aab5993592
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using UnityEngine;
    using System;
    using System.Collections.Generic;
    using UnityEditor;

    public class SplineToolsWindow : EditorWindow
    {
        private static SplineTool[] tools;
        private int toolIndex = -1;
        private Vector2 scroll = Vector2.zero;
        private const float menuWidth = 150f;
        [MenuItem("Window/Dreamteck/Splines/Tools")]
        static void Init()
        {
            SplineToolsWindow window = (SplineToolsWindow)EditorWindow.GetWindow(typeof(SplineToolsWindow));
            window.Show();
        }

        private void Awake()
        {
            titleContent = new GUIContent("Spline Tools");
            name = "Spline tools";
            autoRepaintOnSceneChange = true;

            List<Type> types = FindDerivedClasses.GetAllDerivedClasses(typeof(SplineTool));
            tools = new SplineTool[types.Count];
            int count = 0;
            foreach (Type t in types)
            {
                tools[count] = (SplineTool)Activator.CreateInstance(t);
                count++;
            } 
            if (toolIndex >= 0 && toolIndex < tools.Length) tools[toolIndex].Open(this);
        }

        void OnDestroy()
        {
            if (toolIndex >= 0 && toolIndex < tools.Length) tools[toolIndex].Close();
        }

        void OnGUI()
        {
            if (tools == null) Awake(); 
            GUI.color = new Color(0f, 0f, 0f, 0.15f);
            GUI.DrawTexture(new Rect(0, 0, menuWidth, position.height), SplineEditorGUI.white, ScaleMode.StretchToFill);
            GUI.color = Color.white;
            GUILayout.BeginHorizontal();
            GUILayout.BeginScrollView(scroll, GUILayout.Width(menuWidth), GUILayout.Height(position.height-10));
            if (tools == null) Init();
            SplineEditorGUI.SetHighlightColors(SplinePrefs.highlightColor, SplinePrefs.highlightContentColor);
            for (int i = 0; i < tools.Length; i ++)
            {
                if (SplineEditorGUI.EditorLayoutSelectableButton(new GUIContent(tools[i].GetName()), true, toolIndex == i))
                {
                    if (toolIndex >= 0 && toolIndex < tools.Length) tools[toolIndex].Close();
                    toolIndex = i;
                    if (toolIndex < tools.Length) tools[toolIndex].Open(this);
                }
            }
            GUILayout.EndScrollView();

           
            if(toolIndex >= 0 && toolIndex < tools.Length)
            {
                GUILayout.BeginVertical();
                tools[toolIndex].Draw(new Rect(menuWidth, 0, position.width - menuWidth - 5f, position.height - 10));
                GUILayout.EndVertical();
            }
            GUILayout.EndHorizontal();
        }
        
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Tools/SplineToolsWindow.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Tools/UpdateTool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1b86089eb8b849648b253ed7b5be27a7
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
using UnityEngine;
using System.Collections;
using UnityEditor;
using System.IO;

namespace Dreamteck.Splines
{
    public class UpdateTool : SplineTool
    {
        protected GameObject obj;
        protected ObjectController spawner;
        private string updated = "";

        public override string GetName()
        {
            return "Update Components";
        }

        protected override string GetPrefix()
        {
            return "UpdateTool";
        }

        public override void Draw(Rect windowRect)
        {
            if (GUILayout.Button("Update All Spline Components"))
            {
                updated = "";
                UpdateComputers();
                UpdateNodes();
                UpdateUsers();
            }
            if (GUILayout.Button("Update SplineUsers"))
            {
                updated = "";
                UpdateUsers();
            }
            if (GUILayout.Button("Update MeshGenerators"))
            {
                updated = "";
                UpdateMeshGenerators();
            }
            if (GUILayout.Button("Update SplineComputers"))
            {
                updated = "";
                UpdateComputers();
            }
            if (GUILayout.Button("Update Nodes In Scene"))
            {
                updated = "";
                UpdateNodes();
            }

            EditorGUILayout.Space();
            GUILayout.Label(updated);
        }

        private void UpdateNodes()
        {
            Node[] nodes = GameObject.FindObjectsOfType<Node>();
            EditorUtility.ClearProgressBar();
            for (int i = 0; i < nodes.Length; i++)
            {
                EditorUtility.DisplayProgressBar("Updating nodes", "Updating node " + nodes[i].name, (float)i / (nodes.Length - 1));
                nodes[i].UpdateConnectedComputers();
                EditorUtility.SetDirty(nodes[i]);
                updated += i + " - " + nodes[i].name + System.Environment.NewLine;
            }
            EditorUtility.ClearProgressBar();
            if (nodes.Length == 0) updated += System.Environment.NewLine+"No active Nodes found in the scene.";
        }

        private void UpdateUsers()
        {
            SplineUser[] users = GameObject.FindObjectsOfType<SplineUser>();
            EditorUtility.ClearProgressBar();
            for (int i = 0; i < users.Length; i++)
            {
                EditorUtility.DisplayProgressBar("Updating users", "Updating user " + users[i].name, (float)i/(users.Length-1));
                users[i].Rebuild();
                EditorUtility.SetDirty(users[i]);
                updated += i + " - " + users[i].name + System.Environment.NewLine;
            }
            EditorUtility.ClearProgressBar();
            if (users.Length == 0) updated += System.Environment.NewLine+"No active SplineUsers found in the scene.";
        }

        private void UpdateMeshGenerators()
        {
            MeshGenerator[] users = GameObject.FindObjectsOfType<MeshGenerator>();
            EditorUtility.ClearProgressBar();
            for (int i = 0; i < users.Length; i++)
            {
                EditorUtility.DisplayProgressBar("Updating mesh generators", "Updating generator " + users[i].name, (float)i / (users.Length - 1));
                users[i].Rebuild();
                EditorUtility.SetDirty(users[i]);
                updated += i + " - " + users[i].name + System.Environment.NewLine;
            }
            EditorUtility.ClearProgressBar();
            if (users.Length == 0) updated += System.Environment.NewLine + "No active MeshGenerators found in the scene.";
        }

        private void UpdateComputers()
        {
            SplineComputer[] computers = GameObject.FindObjectsOfType<SplineComputer>();
            EditorUtility.ClearProgressBar();
            for (int i = 0; i < computers.Length; i++)
            {
                EditorUtility.DisplayProgressBar("Updating spline computers", "Updating computer " + computers[i].name, (float)i / (computers.Length - 1));
                computers[i].RebuildImmediate();
                EditorUtility.SetDirty(computers[i]);
                updated += i + " - " + computers[i].name + System.Environment.NewLine;
            }
            EditorUtility.ClearProgressBar();
            if (computers.Length == 0) updated += System.Environment.NewLine+"No active SplineComputers found in the scene.";
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/Tools/UpdateTool.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/TransformModuleEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 0172f84d624277e4ba118d7c915b3935
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEditor;
    using UnityEngine;

    public class TransformModuleEditor : SplineUserSubEditor
    {
        private TransformModule motionApplier;
        private string[] toolStrings = new string[] { "3D", "2D" };

        public TransformModuleEditor(SplineUser user, SplineUserEditor parent, TransformModule input) : base(user, parent)
        {
            title = "Motion";
            motionApplier = input;
        }

        public override void DrawInspector()
        {
            base.DrawInspector();
            if (!isOpen) return;
            EditorGUI.indentLevel = 1;
     
            int selected = GUILayout.Toolbar(motionApplier.is2D ? 1 : 0, toolStrings);
            motionApplier.is2D = selected == 1;

            if (motionApplier.is2D)
            {
                motionApplier.applyPosition2D = EditorGUILayout.Toggle("Apply Position", motionApplier.applyPosition2D);
            }
            else
            {
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.LabelField("Position", GUILayout.Width(EditorGUIUtility.labelWidth));
                motionApplier.applyPositionX = EditorGUILayout.Toggle(motionApplier.applyPositionX, GUILayout.Width(30));
                GUILayout.Label("X", GUILayout.Width(20));
                motionApplier.applyPositionY = EditorGUILayout.Toggle(motionApplier.applyPositionY, GUILayout.Width(30));
                GUILayout.Label("Y", GUILayout.Width(20));
                motionApplier.applyPositionZ = EditorGUILayout.Toggle(motionApplier.applyPositionZ, GUILayout.Width(30));
                GUILayout.Label("Z", GUILayout.Width(20));
                EditorGUILayout.EndHorizontal();
                EditorGUIUtility.labelWidth = 150;
                motionApplier.retainLocalPosition = EditorGUILayout.Toggle("Retain Local Position", motionApplier.retainLocalPosition);
                EditorGUIUtility.labelWidth = 0;
                if (motionApplier.retainLocalPosition)
                {
                    EditorGUILayout.HelpBox("Retain Local Position is an experimental feature and will always accumulate an offset error based on how fast the follower is going.", MessageType.Info);
                }
            }

            if (motionApplier.applyPosition)
            {
                EditorGUI.indentLevel = 2;
                if (motionApplier.is2D)
                {
                    Vector2 offset2d = motionApplier.offset;
                    offset2d.y = EditorGUILayout.FloatField("Offset", offset2d.y);
                    motionApplier.offset = offset2d;
                } else
                {
                    motionApplier.offset = EditorGUILayout.Vector2Field("Offset", motionApplier.offset);
                }
                
            }
            EditorGUI.indentLevel = 1;

            if (motionApplier.is2D)
            {
                motionApplier.applyRotation2D = EditorGUILayout.Toggle("Apply Rotation", motionApplier.applyRotation2D);
            } else
            {
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.LabelField("Rotation", GUILayout.Width(EditorGUIUtility.labelWidth));
                motionApplier.applyRotationX = EditorGUILayout.Toggle(motionApplier.applyRotationX, GUILayout.Width(30));
                GUILayout.Label("X", GUILayout.Width(20));
                motionApplier.applyRotationY = EditorGUILayout.Toggle(motionApplier.applyRotationY, GUILayout.Width(30));
                GUILayout.Label("Y", GUILayout.Width(20));
                motionApplier.applyRotationZ = EditorGUILayout.Toggle(motionApplier.applyRotationZ, GUILayout.Width(30));
                GUILayout.Label("Z", GUILayout.Width(20));
                EditorGUILayout.EndHorizontal();

                EditorGUIUtility.labelWidth = 150; 
                motionApplier.retainLocalRotation = EditorGUILayout.Toggle("Retain Local Rotation", motionApplier.retainLocalRotation);
                EditorGUIUtility.labelWidth = 0;
                if (motionApplier.retainLocalRotation)
                {
                    EditorGUILayout.HelpBox("Retain Local Rotation is an experimental feature and will always accumulate an offset error based on how fast the follower is going.", MessageType.Info);
                }
            }

            if (motionApplier.applyRotation)
            {
                EditorGUI.indentLevel = 2;
                if (motionApplier.is2D)
                {
                    Vector3 rot2d = motionApplier.rotationOffset;
                    rot2d.z = EditorGUILayout.FloatField("Offset", rot2d.z);
                    motionApplier.rotationOffset = rot2d;
                } else
                {
                    motionApplier.rotationOffset = EditorGUILayout.Vector3Field("Offset", motionApplier.rotationOffset);
                }
            }
            EditorGUI.indentLevel = 1;
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("Scale", GUILayout.Width(EditorGUIUtility.labelWidth));
            motionApplier.applyScaleX = EditorGUILayout.Toggle(motionApplier.applyScaleX, GUILayout.Width(30));
            GUILayout.Label("X", GUILayout.Width(20));
            motionApplier.applyScaleY = EditorGUILayout.Toggle(motionApplier.applyScaleY, GUILayout.Width(30));
            GUILayout.Label("Y", GUILayout.Width(20));
            motionApplier.applyScaleZ = EditorGUILayout.Toggle(motionApplier.applyScaleZ, GUILayout.Width(30));
            GUILayout.Label("Z", GUILayout.Width(20));
            EditorGUILayout.EndHorizontal();

            if (motionApplier.applyScale)
            {
                EditorGUI.indentLevel = 2;
                motionApplier.baseScale = EditorGUILayout.Vector3Field("Base scale", motionApplier.baseScale);
            }

            motionApplier.velocityHandleMode = (TransformModule.VelocityHandleMode)EditorGUILayout.EnumPopup("Velocity Mode", motionApplier.velocityHandleMode);
            EditorGUI.indentLevel = 0;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/TransformModuleEditor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/WelcomeScreen.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: cb2fa0bb0a93dcc4e88002670fc87b70
# ASMDEF: Dreamteck.Splines.Editor.dll
# ---
namespace Dreamteck.Splines.Editor
{
    using Dreamteck.Editor;
    using System.Collections.Generic;
    using System.IO;
    using UnityEditor;
    using UnityEngine;
    using UnityEngine.Networking;

    [InitializeOnLoad]
    public static class PluginInfo
    {
        public static string version = "3.0.6";
        private static bool open = false;

        static PluginInfo()
        {
            if (open) return;
            bool showInfo = EditorPrefs.GetString("Dreamteck.Splines.Info.version", "") != version;

            if (!showInfo)
            {
                var url = "https://dreamteck.io/plugins/splines/welcome.json";
                var prefKey = "Dreamteck.Splines.welcomeScreenVersion";
                var welcomeScreenVersion = EditorPrefs.GetInt(prefKey, -1);

                using (var mainDataReq = UnityWebRequest.Get(url))
                {
                    mainDataReq.SendWebRequest();

                    while (!mainDataReq.isDone || mainDataReq.result == UnityWebRequest.Result.InProgress)
                    {

                    }

                    if (mainDataReq.result == UnityWebRequest.Result.ProtocolError ||
                        mainDataReq.result == UnityWebRequest.Result.DataProcessingError ||
                        mainDataReq.result == UnityWebRequest.Result.ConnectionError)
                    {
                        Debug.LogError("An error occured while fetching the banners data.");
                    }
                    else if(!showInfo)
                    {
                        var jObj = JsonUtility.FromJson<WelcomeWindow.Data>(mainDataReq.downloadHandler.text);
                        welcomeScreenVersion = jObj.version;

                        var currentVersion = EditorPrefs.GetInt(prefKey, -1);

                        showInfo = currentVersion < welcomeScreenVersion;
                    }
                }
            }

            if (!showInfo) return;
            EditorPrefs.SetString("Dreamteck.Splines.Info.version", version);
            EditorApplication.update += OpenWindowOnUpdate;
        }

        private static void OpenWindowOnUpdate()
        {
            EditorApplication.update -= OpenWindowOnUpdate;
            EditorWindow.GetWindow<WelcomeScreen>(true);
            open = true;
        }
    }

    [InitializeOnLoad]
    public static class AddScriptingDefines
    {
        static AddScriptingDefines(){
            ScriptingDefineUtility.Add("DREAMTECK_SPLINES", EditorUserBuildSettings.selectedBuildTargetGroup, true);
        }
    }

    public class WelcomeScreen : WelcomeWindow
    {
        protected override Vector2 _windowSize => new Vector2(450, 620);
        private ModuleInstaller _tmproInstaller;
        private ModuleInstaller _playmakerInstaller;
        private ModuleInstaller _examplesInstaller;

        [MenuItem("Window/Dreamteck/Splines/Start Screen")]
        public static void OpenWindow()
        {
            GetWindow<WelcomeScreen>(true);
        }

        protected override void GetHeader()
        {
            header = ResourceUtility.EditorLoadTexture("Splines/Editor/Icons", "plugin_header");
        }

        public override void Load()
        {
            base.Load();

            SetTitle("Dreamteck Splines " + PluginInfo.version, "");
            panels = new WindowPanel[7];
            panels[0] = new WindowPanel("Home", true, 0.25f);
            panels[1] = new WindowPanel("Changelog", false, panels[0], 0.25f);
            panels[2] = new WindowPanel("Learn", false, panels[0], 0.25f);
            panels[3] = new WindowPanel("Support", false, panels[0], 0.25f);
            panels[4] = new WindowPanel("Examples", false, panels[2], 0.25f);
            panels[5] = new WindowPanel("Playmaker", false, panels[0], 0.25f);
            panels[6] = new WindowPanel("Text Mesh Pro", false, panels[0], 0.25f);

            panels[0].elements.Add(new WindowPanel.Space(400, 10));
            panels[0].elements.Add(new WindowPanel.Thumbnail("Utilities/Editor/Images", "changelog", "What's new?", "See all new features, important changes and bugfixes in " + PluginInfo.version, new ActionLink(panels[1], panels[0])));
            panels[0].elements.Add(new WindowPanel.Thumbnail("Utilities/Editor/Images", "get_started", "Get Started + Packages", "Learn how to use Dreamteck Splines and install core packages", new ActionLink(panels[2], panels[0])));
            panels[0].elements.Add(new WindowPanel.Thumbnail("Utilities/Editor/Images", "support", "Community", "Got a problem or a feature request? Join the community!", new ActionLink(panels[3], panels[0])));

            _bannerData = LoadBannersData("https://dreamteck.io/plugins/splines/welcome.json", "Dreamteck.Splines.welcomeScreenVersion");

            if (_bannerData != null)
            {
                _textureWebRequests = new List<UnityWebRequest>();

                for (int i = 0; i < _bannerData.banners.Length; i++)
                {
                    var request = UnityWebRequestTexture.GetTexture(_bannerData.banners[i].bannerUrl);
                    request.SendWebRequest();
                    _textureWebRequests.Add(request);
                    _hasSentImageRequest = true;
                }

                if (_hasSentImageRequest)
                {
                    EditorApplication.update -= OnEditorUpdate;
                    EditorApplication.update += OnEditorUpdate;
                }
            }
            else
            {
                DrawFooter();
            }

            string path = ResourceUtility.FindFolder(Application.dataPath, "Dreamteck/Splines/Editor");
            string changelogText = "Changelog file not found.";
            if (Directory.Exists(path))
            {
                if (File.Exists(path + "/changelog.txt"))
                {
                    string[] lines = File.ReadAllLines(path + "/changelog.txt");
                    changelogText = "";
                    for (int i = 0; i < lines.Length; i++)
                    {
                        changelogText += lines[i] + "\r\n";
                    }
                }
            }
            panels[1].elements.Add(new WindowPanel.Space(400, 20));
            panels[1].elements.Add(new WindowPanel.ScrollText(400, 500, changelogText));

            panels[2].elements.Add(new WindowPanel.Space(400, 10));
            panels[2].elements.Add(new WindowPanel.Thumbnail("Utilities/Editor/Images", "manual", "User Manual", "Read a thorough documentation of the whole package along with a list of API methods.", new ActionLink("https://dreamteck-splines.netlify.app/")));
            panels[2].elements.Add(new WindowPanel.Thumbnail("Utilities/Editor/Images", "tutorials", "Video Tutorials", "Watch a series of Youtube videos to get started.", new ActionLink("https://www.youtube.com/playlist?list=PLkZqalQdFIQ6zym8RwSWWl3PZJuUdvNK6")));
            panels[2].elements.Add(new WindowPanel.Thumbnail("Utilities/Editor/Images", "examples", "Examples", "Install example scenes", new ActionLink(panels[4], panels[2])));

            panels[2].elements.Add(new WindowPanel.Thumbnail("Utilities/Editor/Images", "playmaker", "Playmaker Actions", "Install Playmaker actions for Dreamteck Splines", new ActionLink(panels[5], panels[2])));
            panels[2].elements.Add(new WindowPanel.Thumbnail("Utilities/Editor/Images", "tmpro", "Text Mesh Pro Support", "Manage components for working with Text Mesh Pro", new ActionLink(panels[6], panels[2])));

            panels[3].elements.Add(new WindowPanel.Space(400, 10));
            panels[3].elements.Add(new WindowPanel.Thumbnail("Utilities/Editor/Images", "discord", "Discord Server", "Join our Discord community and chat with other developers who use Splines.", new ActionLink("https://discord.gg/bkYDq8v")));

            panels[4].elements.Add(new WindowPanel.Space(400, 10));
            panels[4].elements.Add(new WindowPanel.Button(400, 30, "Install Examples", new ActionLink(InstallExamples)));
            panels[4].elements.Add(new WindowPanel.Button(400, 30, "Uninstall Examples", new ActionLink(UnInstallExamples)));

            panels[5].elements.Add(new WindowPanel.Space(400, 10));

            panels[6].elements.Add(new WindowPanel.Button(400, 30, "Install TMPro Support", new ActionLink(InstallTMPro)));
            panels[6].elements.Add(new WindowPanel.Button(400, 30, "Uninstall TMPro Support", new ActionLink(UninstallTMPro)));

            panels[5].elements.Add(new WindowPanel.Button(400, 30, "Install Actions", new ActionLink(InstallPlaymaker)));
            panels[5].elements.Add(new WindowPanel.Button(400, 30, "Uninstall Actions", new ActionLink(UninstallPlaymaker)));

            _playmakerInstaller = new ModuleInstaller("Splines", "PlaymakerActions");
            _playmakerInstaller.AddUninstallDirectory("Splines/PlaymakerActions");

            _examplesInstaller = new ModuleInstaller("Splines", "Examples");
            _examplesInstaller.AddUninstallDirectory("Splines/Examples");

            _tmproInstaller = new ModuleInstaller("Splines", "TMPro");
            _tmproInstaller.AddAssemblyLink("Splines", "Dreamteck.Splines", "Unity.TextMeshPro");
            _tmproInstaller.AddScriptingDefine("DREAMTECK_SPLINES_TMPRO");
            _tmproInstaller.AddUninstallDirectory("Splines/Components/TMPro");
            _tmproInstaller.AddUninstallDirectory("Splines/Editor/Components/TMPro");
        }

        protected override void DrawFooter()
        {
            panels[0].elements.Add(new WindowPanel.Space(400, 10));
            panels[0].elements.Add(new WindowPanel.Label("This window will not appear again automatically. To open it manually go to Window/Dreamteck/Splines/Start Screen", wrapText, new Color(1f, 1f, 1f, 0.5f), 400, 50));
        }

        private void InstallExamples()
        {
            _examplesInstaller.Install();
            panels[5].Back();
        }

        private void UnInstallExamples()
        {
            _examplesInstaller.Uninstall();
            panels[5].Back();
        }

        private void InstallTMPro()
        {
            _tmproInstaller.Install();
            panels[6].Back();
        }

        private void UninstallTMPro()
        {
            _tmproInstaller.Uninstall();
            panels[6].Back();
        }

        private void InstallPlaymaker()
        {
            _playmakerInstaller.Install();
            panels[5].Back();
        }

        private void UninstallPlaymaker()
        {
            _playmakerInstaller.Uninstall();
            panels[5].Back();
        }

        private static void AddAssemblyReference(string dreamteckAssemblyName, string addedAssemblyName)
        {
            string localDir = ResourceUtility.FindFolder(Application.dataPath, "Dreamteck/Splines");
            var path = Path.Combine(Application.dataPath, localDir, dreamteckAssemblyName + ".asmdef");
            var data = "";
            using (var reader = new StreamReader(path))
            {
                data = reader.ReadToEnd();
            }

            var asmDef = AssemblyDefinition.CreateFromJSON(data);
            foreach (var reference in asmDef.references)
            {
                if (reference == addedAssemblyName) return;
            }

            ArrayUtility.Add(ref asmDef.references, addedAssemblyName);
            using (var writer = new StreamWriter(path, false))
            {
                writer.Write(asmDef.ToString());
            }
        }
    }

    [System.Serializable]
    public struct AssemblyDefinition
    {
        public string name;
        public string rootNamespace;
        public string[] references;
        public string[] includePlatforms;
        public string[] exludePlatforms;
        public bool allowUnsafeCode;
        public bool overrideReferences;
        public string precompiledReferences;
        public bool autoReferenced;
        public string[] defineConstraints;
        public string[] versionDefines;
        public bool noEngineReferences;

        public static AssemblyDefinition CreateFromJSON(string json)
        {
            return JsonUtility.FromJson<AssemblyDefinition>(json);
        }

        public override string ToString()
        {
            return JsonUtility.ToJson(this, true);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Editor/WelcomeScreen.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Editor/DreamteckEditorGUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: ee0eafe76311d094680308d7a6735a26
# ASMDEF: Dreamteck.Utilities.Editor.dll
# ---
namespace Dreamteck
{
    using UnityEditor;
    using UnityEngine;
    using System.Collections.Generic;

    public static class DreamteckEditorGUI
    {
        public static Texture2D blankImage
        {
            get
            {
                if (_blankImage == null)
                {
                    _blankImage = new Texture2D(1, 1);
                    _blankImage.SetPixel(0, 0, Color.white);
                    _blankImage.Apply();
                }
                return _blankImage;
            }
        }
        private static Texture2D _blankImage = null;

        public static readonly Color backgroundColor = new Color(0.95f, 0.95f, 0.95f);
        public static Color iconColor = Color.black;

        public static readonly Color highlightColor = new Color(0f, 0.564f, 1f, 1f);
        public static readonly Color highlightContentColor = new Color(1f, 1f, 1f, 0.95f);


        public static readonly Color inactiveColor = new Color(0.7f, 0.7f, 0.7f, 0.5f);
        public static readonly Color activeColor = new Color(1f, 1f, 1f, 1f);

        public static readonly Color baseColor = Color.white;
        public static readonly Color lightColor = Color.white;
        public static readonly Color lightDarkColor = Color.white;
        public static readonly Color darkColor = Color.white;
        public static readonly Color borderColor = Color.white;

        private static List<int> layerNumbers = new List<int>();

        public static readonly GUIStyle labelText = null;
        private static float scale = -1f;

        static DreamteckEditorGUI()
        {
            baseColor = EditorGUIUtility.isProSkin ? new Color32(56, 56, 56, 255) : new Color32(194, 194, 194, 255);
            lightColor = EditorGUIUtility.isProSkin ? new Color32(84, 84, 84, 255) : new Color32(222, 222, 222, 255);
            lightDarkColor = EditorGUIUtility.isProSkin ? new Color32(30, 30, 30, 255) : new Color32(180, 180, 180, 255);
            darkColor = EditorGUIUtility.isProSkin ? new Color32(15, 15, 15, 255) : new Color32(152, 152, 152, 255);
            borderColor = EditorGUIUtility.isProSkin ? new Color32(5, 5, 5, 255) : new Color32(100, 100, 100, 255);
            backgroundColor = baseColor;
            backgroundColor -= new Color(0.1f, 0.1f, 0.1f, 0f);
            iconColor = GUI.skin.label.normal.textColor;

            labelText = new GUIStyle(GUI.skin.GetStyle("label"));
            labelText.fontStyle = FontStyle.Bold;
            labelText.alignment = TextAnchor.MiddleRight;
            labelText.normal.textColor = Color.white;
            SetScale(1f);
        }

        public static void SetScale(float newScale)
        {
            if (scale == newScale) return;
            scale = newScale;
            labelText.fontSize = Mathf.RoundToInt(12f * scale);
        }

        public static void Label(Rect position, string text, bool active = true, GUIStyle style = null)
        {
            if (style == null) style = labelText;
            if (!active) GUI.color = inactiveColor;
            else GUI.color = activeColor;
            GUI.color = new Color(0f, 0f, 0f, GUI.color.a * 0.5f);
            GUI.Label(new Rect(position.x - 1, position.y + 1, position.width, position.height), text, style);
            if (!active) GUI.color = inactiveColor;
            else GUI.color = activeColor;
            GUI.Label(position, text, style);
        }

        public static LayerMask LayermaskField(string label, LayerMask layerMask)
        {
            string[] layers = UnityEditorInternal.InternalEditorUtility.layers;

            layerNumbers.Clear();

            for (int i = 0; i < layers.Length; i++)
            {
                layerNumbers.Add(LayerMask.NameToLayer(layers[i]));
            }

            int maskWithoutEmpty = 0;
            for (int i = 0; i < layerNumbers.Count; i++)
            {
                if (((1 << layerNumbers[i]) & layerMask.value) > 0)
                {
                    maskWithoutEmpty |= (1 << i);
                }
            }

            maskWithoutEmpty = EditorGUILayout.MaskField(label, maskWithoutEmpty, layers);

            int mask = 0;
            for (int i = 0; i < layerNumbers.Count; i++)
            {
                if ((maskWithoutEmpty & (1 << i)) > 0)
                {
                    mask |= (1 << layerNumbers[i]);
                }
            }

            layerMask.value = mask;

            return layerMask;
        }

        public static bool DropArea<T>(Rect rect, out T[] content, bool acceptProjectAssets = false)
        {
            content = new T[0];
            switch (Event.current.type)
            {
                case EventType.DragUpdated:
                case EventType.DragPerform:
                    if (!rect.Contains(Event.current.mousePosition)) return false;

                    DragAndDrop.visualMode = DragAndDropVisualMode.Copy;

                    if (Event.current.type == EventType.DragPerform)
                    {
                        DragAndDrop.AcceptDrag();
                        List<T> contentList = new List<T>();
                        foreach (object dragged_object in DragAndDrop.objectReferences)
                        {
                            if (dragged_object is GameObject)
                            {
                                GameObject gameObject = (GameObject)dragged_object;
                                if (acceptProjectAssets || !AssetDatabase.Contains(gameObject))
                                {
                                    if (gameObject.GetComponent<T>() != null) contentList.Add(gameObject.GetComponent<T>());
                                }
                            }
                        }
                        content = contentList.ToArray();
                        return true; 
                    }
                    else return false;
            }
            return false;
        }


        public static Gradient GradientField(string label, Gradient gradient, params GUILayoutOption[] options)
        {
            return EditorGUILayout.GradientField(label, gradient, options);
        }

        public static void DrawSeparator()
        {
            EditorGUILayout.Space();
            EditorGUILayout.BeginHorizontal();
            GUILayout.FlexibleSpace();
            Rect rect = GUILayoutUtility.GetRect(Screen.width / 2f, 2f);
            EditorGUI.DrawRect(rect, darkColor);
            GUILayout.FlexibleSpace();
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.Space();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Editor/DreamteckEditorGUI.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Editor/EditorGUIEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 15a36dd80a7895246ae6870b7124a571
# ASMDEF: Dreamteck.Utilities.Editor.dll
# ---
using UnityEngine;
using UnityEditor;

namespace Dreamteck
{
    public class EditorGUIEvents
    {
        public bool mouseLeft = false;
        public bool mouseRight = false;
        public bool mouseLeftDown = false;
        public bool mouseRightDown = false;
        public bool mouseLeftUp = false;
        public bool mouseRightUp = false;
        public bool control = false;
        public bool shift = false;
        public bool alt = false;
        public bool enterDown = false;
        public bool v = false;
        public Vector2 mousPos = Vector2.zero;
        public Vector2 lastClickPoint = Vector2.zero;
        public Vector2 mouseClickDelta
        {
            get
            {
                return Event.current.mousePosition - lastClickPoint;
            }
        }

        public delegate void CommandHandler(string command);
        public delegate void KeyCodeHandler(KeyCode code);
        public delegate void MouseHandler(int button);
        public delegate void EmptyHandler();

        public event CommandHandler onCommand;
        public event KeyCodeHandler onkeyDown;
        public event KeyCodeHandler onKeyUp;
        public event MouseHandler onMouseDown;
        public event MouseHandler onMouseUp;

        public void Use()
        {
            mouseLeft = false;
            mouseRight = false;
            mouseLeftDown = false;
            mouseRightDown = false;
            mouseLeftUp = false;
            mouseRightUp = false;
            control = false;
            shift = false;
            alt = false;
            Event.current.Use();
        }

        public void Update()
        {
            ListenInput(Event.current);
        }

        public void Update(Event current)
        {
            ListenInput(current);
        }

        void ListenInput(Event e)
        {
            //int controlID = GUIUtility.GetControlID(FocusType.Passive);
            mousPos = e.mousePosition;
            mouseLeftDown = mouseLeftUp = mouseRightDown = mouseRightUp = false;
            control = e.control;
            shift = e.shift;
            alt = e.alt;
            enterDown = false;
            switch (e.type)
            {
                case EventType.MouseDown:
                    if (e.button == 0)
                    {
                        mouseLeftDown = true;
                        mouseLeft = true;
                        lastClickPoint = e.mousePosition;
                    }
                    if (e.button == 1) mouseRightDown = mouseRight = true;
                    if (onMouseDown != null) onMouseDown(e.button);
                    break;
                case EventType.MouseUp:
                    if (e.button == 0)
                    {
                        mouseLeftUp = true;
                        mouseLeft = false;
                    }
                    if (e.button == 1)
                    {
                        mouseRightDown = true;
                        mouseRight = false;
                    }
                    if (onMouseUp != null) onMouseUp(e.button);
                    break;

                case EventType.KeyDown:
                    if (onkeyDown != null) onkeyDown(e.keyCode);
                    if (e.keyCode == KeyCode.Return || e.keyCode == KeyCode.KeypadEnter) enterDown = true;
                    if (e.keyCode == KeyCode.V) v = true;
                    break;

                case EventType.KeyUp:
                    if (onKeyUp != null) onKeyUp(e.keyCode);
                    if (e.keyCode == KeyCode.V) v = false;
                    break;
            }
            if (onCommand != null && e.commandName != "") onCommand(e.commandName);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Editor/EditorGUIEvents.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Editor/FindDerivedClasses.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 12a29dbe4d6c3f648aae86fce0402487
# ASMDEF: Dreamteck.Utilities.Editor.dll
# ---
namespace Dreamteck
{
    using UnityEngine;
    using System;
    using System.Reflection;
    using System.Collections.Generic;
    public static class FindDerivedClasses
    {
        public static List<Type> GetAllDerivedClasses(this Type aBaseClass, string[] aExcludeAssemblies)
        {
            List<Type> result = new List<Type>();
            foreach (Assembly A in AppDomain.CurrentDomain.GetAssemblies())
            {
                bool exclude = false;
                foreach (string S in aExcludeAssemblies)
                {
                    if (A.GetName().FullName.StartsWith(S))
                    {
                        exclude = true;
                        break;
                    }
                }
                if (exclude)
                {
                    continue;
                }
                try
                {
                    if (aBaseClass.IsInterface)
                    {
                        foreach (Type C in A.GetExportedTypes())
                        {
                            foreach (Type I in C.GetInterfaces())
                            {
                                if (aBaseClass == I)
                                {
                                    result.Add(C);
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        foreach (Type C in A.GetExportedTypes())
                        {
                            if (C.IsSubclassOf(aBaseClass))
                            {
                                result.Add(C);
                            }
                        }
                    }
                } catch
                {
                    Debug.LogWarning("Dreamteck was unable to scan " + A.FullName + " for derived classes");
                }
            }
            return result;
        }

        public static List<Type> GetAllDerivedClasses(this Type aBaseClass)
        {
            return GetAllDerivedClasses(aBaseClass, new string[0]);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Editor/FindDerivedClasses.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Editor/ModuleInstaller.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b1655cfc85dfb3d48a70c4544adfbfcf
# ASMDEF: Dreamteck.Utilities.Editor.dll
# ---
namespace Dreamteck.Editor
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using System.IO;
    using UnityEditor;

    public class ModuleInstaller
    {
        protected const string DREAMTECK_FOLDER_NAME = "Dreamteck";

        /// <summary>
        /// Local directory within the Dreamteck folder of the unitypackage
        /// </summary>
        private string _packageDirectory = "";
        private string _packageName = "";
        private List<string> _scriptingDefines = new List<string>();
        private List<string> _uninstallDirectories = new List<string>();
        private Dictionary<string, List<string>> _assemblyLinks = new Dictionary<string, List<string>>();

        public ModuleInstaller(string packageDirectory, string packageName)
        {
            _packageDirectory = packageDirectory;
            _packageName = packageName;
        }

        public void AddAssemblyLink(string dreamteckAssemblyDirectory, string dreamteckAssemblyName, string addedAssemblyName)
        {
            string localFilePath = Path.Combine(DREAMTECK_FOLDER_NAME, dreamteckAssemblyDirectory, dreamteckAssemblyName + ".asmdef");
            if (_assemblyLinks.ContainsKey(localFilePath))
            {
                _assemblyLinks[localFilePath].Add(addedAssemblyName);
            } else
            {
                _assemblyLinks.Add(localFilePath, new List<string>(new string[] { addedAssemblyName }));
            }
        }

        public void AddUninstallDirectory(string dreamteckLocalDirectory)
        {
            if (!_uninstallDirectories.Contains(dreamteckLocalDirectory))
            {
                _uninstallDirectories.Add(dreamteckLocalDirectory);
            }
        }

        public void AddScriptingDefine(string define)
        {
            if (!_scriptingDefines.Contains(define))
            {
                _scriptingDefines.Add(define);
            }
        }

        public void Install()
        {
            string globalPath = ResourceUtility.FindFolder(Application.dataPath, DREAMTECK_FOLDER_NAME + "/" + _packageDirectory);
            if (!Directory.Exists(globalPath))
            {
                EditorUtility.DisplayDialog("Missing Package", "Package directory not found: " + _packageDirectory, "OK");
                return;
            }
            globalPath = Path.Combine(globalPath, _packageName + ".unitypackage");
            if (!File.Exists(globalPath))
            {
                EditorUtility.DisplayDialog("Missing Package", "Package file not found: " + _packageDirectory, "OK");
                return;
            }

            foreach (var key in _assemblyLinks.Keys)
            {
                for (int i = 0; i < _assemblyLinks[key].Count; i++)
                {
                    AddAssemblyReference(key, _assemblyLinks[key][i]);
                }
            }

            AssetDatabase.ImportPackage(globalPath, false);
            EditorUtility.DisplayDialog("Import Complete", _packageName + " is now installed.", "OK");
            for (int i = 0; i < _scriptingDefines.Count; i++)
            {
                ScriptingDefineUtility.Add(_scriptingDefines[i], EditorUserBuildSettings.selectedBuildTargetGroup, true);
            }
        }

        public void Uninstall()
        {
            string dialogText = "The assets in the following folders will be removed: \n";
            for (int i = 0; i < _uninstallDirectories.Count; i++)
            {
                dialogText += _uninstallDirectories[i] + "\n";
            }
            bool result = EditorUtility.DisplayDialog("Uninstalling", dialogText, "OK", "Cancel");
            if (!result) return;

            for (int i = 0; i < _uninstallDirectories.Count; i++)
            {
                string globalPath = ResourceUtility.FindFolder(Application.dataPath, DREAMTECK_FOLDER_NAME + "/" + _uninstallDirectories[i]);
                string relativePath = "Assets" + globalPath.Substring(Application.dataPath.Length);
                Debug.Log("Uninstalling " + relativePath);
                AssetDatabase.DeleteAsset(relativePath);
            }

            foreach (var key in _assemblyLinks.Keys)
            {
                for (int i = 0; i < _assemblyLinks[key].Count; i++)
                {
                    RemoveAssemblyReference(key, _assemblyLinks[key][i]);
                }
            }

            

            for (int i = 0; i < _scriptingDefines.Count; i++)
            {
                ScriptingDefineUtility.Remove(_scriptingDefines[i], EditorUserBuildSettings.selectedBuildTargetGroup, true);
            }
        }

        private static void AddAssemblyReference(string dreamteckAssemblyPath, string addedAssemblyName)
        {
            var path = Path.Combine(Application.dataPath, dreamteckAssemblyPath);
            var data = "";
            using (var reader = new StreamReader(path))
            {
                data = reader.ReadToEnd();
            }

            var asmDef = AssemblyDefinition.CreateFromJSON(data);
            foreach (var reference in asmDef.references)
            {
                if (reference == addedAssemblyName) return;
            }

            ArrayUtility.Add(ref asmDef.references, addedAssemblyName);
            Debug.Log("Adding " + addedAssemblyName + " to assembly " + dreamteckAssemblyPath);
            using (var writer = new StreamWriter(path, false))
            {
                writer.Write(asmDef.ToString());
            }
        }
        
        private static void RemoveAssemblyReference(string dreamteckAssemblyPath, string addedAssemblyName)
        {
            var path = Path.Combine(Application.dataPath, dreamteckAssemblyPath);
            var data = "";
            using (var reader = new StreamReader(path))
            {
                data = reader.ReadToEnd();
            }

            var asmDef = AssemblyDefinition.CreateFromJSON(data);
            bool contains = false;
            foreach (var reference in asmDef.references)
            {
                if (reference != addedAssemblyName) continue;
                contains = true;
                break;
            }
            if (!contains) return;

            ArrayUtility.Remove(ref asmDef.references, addedAssemblyName);
            Debug.Log("Removing " + addedAssemblyName + " from assembly " + dreamteckAssemblyPath);
            using (var writer = new StreamWriter(path, false))
            {
                writer.Write(asmDef.ToString());
            }
        }

        [System.Serializable]
        public struct AssemblyDefinition
        {
            public string name;
            public string rootNamespace;
            public string[] references;
            public string[] includePlatforms;
            public string[] exludePlatforms;
            public bool allowUnsafeCode;
            public bool overrideReferences;
            public string precompiledReferences;
            public bool autoReferenced;
            public string[] defineConstraints;
            public string[] versionDefines;
            public bool noEngineReferences;

            public static AssemblyDefinition CreateFromJSON(string json)
            {
                return JsonUtility.FromJson<AssemblyDefinition>(json);
            }

            public override string ToString()
            {
                return JsonUtility.ToJson(this, true);
            }
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Editor/ModuleInstaller.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Editor/ResourceUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7e9dc735344bf0e43ba98718f54e0656
# ASMDEF: Dreamteck.Utilities.Editor.dll
# ---
using UnityEngine;
using System.Collections;
using System.IO;
using UnityEditor;

namespace Dreamteck
{
    public static class ResourceUtility
    {
        private static string dreamteckFolder;
        private static string dreamteckLocalFolder;
        private static bool directoryIsValid = false;

        static ResourceUtility()
        {
            string defaultPath = Application.dataPath + "/Dreamteck";
            dreamteckFolder = EditorPrefs.GetString("Dreamteck.ResourceUtility.dreamteckProjectFolder", defaultPath);
            if (!dreamteckFolder.StartsWith(Application.dataPath))
            {
                dreamteckFolder = defaultPath;
            }
            if (!Directory.Exists(dreamteckFolder))
            {
                dreamteckFolder = FindFolder(Application.dataPath, "Dreamteck");
                directoryIsValid = Directory.Exists(dreamteckFolder);
            }
            else
            {
                directoryIsValid = true;
            }
            if (directoryIsValid)
            {
                dreamteckLocalFolder = dreamteckFolder.Substring(Application.dataPath.Length + 1);
                EditorPrefs.SetString("Dreamteck.ResourceUtility.dreamteckProjectFolder", dreamteckFolder);
            }
        }

        //Attempts to find the input directory pattern inside a given directory and if it fails, proceeds with looking up all subfolders
        public static string FindFolder(string dir, string folderPattern)
        {
            if (folderPattern.StartsWith("/")) folderPattern = folderPattern.Substring(1);
            if (!dir.EndsWith("/")) dir += "/";
            if (folderPattern == "") return "";
            string[] folders = folderPattern.Split('/');
            if (folders.Length == 0) return "";
            string foundDir = "";
            try
            {
                foreach (string d in Directory.GetDirectories(dir))
                {
                    DirectoryInfo dirInfo = new DirectoryInfo(d);
                    if (dirInfo.Name == folders[0])
                    {
                        foundDir = d;
                        string searchDir = FindFolder(d, string.Join("/", folders, 1, folders.Length - 1));
                        if (searchDir != "")
                        {
                            foundDir = searchDir;
                            break;
                        }
                    }
                }
                if (foundDir == "")
                {
                    foreach (string d in Directory.GetDirectories(dir))
                    {
                        foundDir = FindFolder(d, string.Join("/", folders));
                        if (foundDir != "") break;
                    }
                }
            }
            catch (System.Exception excpt)
            {
                Debug.LogError(excpt.Message);
                return "";
            }
            return foundDir;
        }

        public static Texture2D LoadTexture(string dreamteckPath, string textureFileName)
        {
            string path = Application.dataPath + "/Dreamteck/" + dreamteckPath;
            if (!Directory.Exists(path))
            {
                path = FindFolder(Application.dataPath, "Dreamteck/" + dreamteckPath);
                if (!Directory.Exists(path)) return null;
            }
            if (!File.Exists(path + "/" + textureFileName)) return null;
            byte[] bytes = File.ReadAllBytes(path + "/" + textureFileName);
            Texture2D result = new Texture2D(1, 1);
            result.name = textureFileName;
            result.LoadImage(bytes);
            return result;
        }

        public static Texture2D LoadTexture(string path)
        {
            if (!File.Exists(path)) return null;
            byte[] bytes = File.ReadAllBytes(path);
            Texture2D result = new Texture2D(1, 1);
            FileInfo finfo = new FileInfo(path);
            result.name = finfo.Name;
            result.LoadImage(bytes);
            return result;
        }

        public static Texture2D[] EditorLoadTextures(string dreamteckLocalPath)
        {
            string path = "Assets/" + dreamteckLocalFolder + "/" + dreamteckLocalPath;
            string[] textureGUIDs = AssetDatabase.FindAssets("t:texture2d", new string[] { path });
            Texture2D[] textures = new Texture2D[textureGUIDs.Length];
            for (int i = 0; i < textureGUIDs.Length; i++)
            {
                textures[i] = AssetDatabase.LoadAssetAtPath<Texture2D>(AssetDatabase.GUIDToAssetPath(textureGUIDs[i]));
            }
            return textures;
        }

        public static Texture2D EditorLoadTexture(string dreamteckLocalPath, string textureName)
        {
            string path = "Assets/" + dreamteckLocalFolder + "/" + dreamteckLocalPath + "/" + textureName + ".png";
            Texture2D texture = AssetDatabase.LoadAssetAtPath(path, typeof(Texture2D)) as Texture2D;
            return texture;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Editor/ResourceUtility.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Editor/ScriptingDefineUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 22ded5f1b11037c4aa36ec0f0e85c71e
# ASMDEF: Dreamteck.Utilities.Editor.dll
# ---
namespace Dreamteck.Editor
{
    using UnityEngine;
    using UnityEditor;

    public static class ScriptingDefineUtility 
    {
        public static void Add(string define, BuildTargetGroup target, bool log = false)
        {
            string definesString = PlayerSettings.GetScriptingDefineSymbolsForGroup(target);
            if (definesString.Contains(define)) return;
            string[] allDefines = definesString.Split(';');
            ArrayUtility.Add(ref allDefines, define);
            definesString = string.Join(";", allDefines);
            PlayerSettings.SetScriptingDefineSymbolsForGroup(target, definesString);
            Debug.Log("Added \"" + define + "\" from " + EditorUserBuildSettings.selectedBuildTargetGroup + " Scripting define in Player Settings");
        }

        public static void Remove(string define, BuildTargetGroup target, bool log = false)
        {
            string definesString = PlayerSettings.GetScriptingDefineSymbolsForGroup(target);
            if (!definesString.Contains(define)) return;
            string[] allDefines = definesString.Split(';');
            ArrayUtility.Remove(ref allDefines, define);
            definesString = string.Join(";", allDefines);
            PlayerSettings.SetScriptingDefineSymbolsForGroup(target, definesString);
            Debug.Log("Removed \""+ define + "\" from " + EditorUserBuildSettings.selectedBuildTargetGroup + " Scripting define in Player Settings");
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Editor/ScriptingDefineUtility.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Editor/Toolbar.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a9993d76bca1dcd47a94ad14a6eaf2f5
# ASMDEF: Dreamteck.Utilities.Editor.dll
# ---
namespace Dreamteck.Editor
{
    using UnityEngine;
    using UnityEditor;

    public class Toolbar
    {
        GUIContent[] shownContent;
        GUIContent[] allContent;
        public bool center = true;
        public bool newLine = true;
        public float elementWidth = 0f;
        public float elementHeight = 23f;

        public Toolbar(GUIContent[] iconsNormal, GUIContent[] iconsSelected, float elementWidth = 0f)
        {
            this.elementWidth = elementWidth;
            if(iconsNormal.Length != iconsSelected.Length)
            {
                Debug.LogError("Invalid icon count for toolbar ");
                return;
            }
            allContent = new GUIContent[iconsNormal.Length * 2];
            shownContent = new GUIContent[iconsNormal.Length];
            iconsNormal.CopyTo(allContent, 0);
            iconsSelected.CopyTo(allContent, iconsNormal.Length);
        }

        public Toolbar(GUIContent[] contents, float elementWidth = 0f)
        {
            this.elementWidth = elementWidth;
            allContent = new GUIContent[contents.Length * 2];
            shownContent = new GUIContent[contents.Length];
            contents.CopyTo(allContent, 0);
            contents.CopyTo(allContent, contents.Length);
        }

        public void SetContent(int index, GUIContent content)
        {
            allContent[index] = content;
            allContent[shownContent.Length + index] = content;
        }

        public void SetContent(int index, GUIContent content, GUIContent contentSelected)
        {
            allContent[index] = content;
            allContent[shownContent.Length + index] = contentSelected;
        }

        public void Draw(ref int selected)
        {
            for (int i = 0; i < shownContent.Length; i++)
            {
                shownContent[i] = selected == i ? allContent[shownContent.Length + i] : allContent[i];
            }
            if(newLine) EditorGUILayout.BeginHorizontal();
            if(center) GUILayout.FlexibleSpace();
            if(elementWidth > 0f) selected = GUILayout.Toolbar(selected, shownContent, GUILayout.Width(elementWidth * shownContent.Length), GUILayout.Height(elementHeight));
            else selected = GUILayout.Toolbar(selected, shownContent, GUILayout.Height(elementHeight));
            if (center) GUILayout.FlexibleSpace();
            if (newLine) EditorGUILayout.EndHorizontal();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Editor/Toolbar.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Editor/WelcomeWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: bada76b30269a9144848e487cf253360
# ASMDEF: Dreamteck.Utilities.Editor.dll
# ---
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using UnityEngine.Networking;

namespace Dreamteck
{
    public class WelcomeWindow : EditorWindow
    {
        public delegate void EmptyHandler();
        protected WindowPanel[] panels = new WindowPanel[0];
        protected Texture2D header;
        protected static GUIStyle wrapText;
        protected static GUIStyle buttonTitleText;
        protected static GUIStyle warningText;
        protected static GUIStyle titleText;
        protected bool _hasSentImageRequest;
        protected List<UnityWebRequest> _textureWebRequests;
        protected Data _bannerData;
        protected string headerTitle = "";
        private static bool init = true;
        protected virtual Vector2 _windowSize => new Vector2(450, 500);

        public virtual void Load()
        {
            minSize = maxSize = _windowSize;
            buttonTitleText = new GUIStyle(GUI.skin.GetStyle("label"));
            buttonTitleText.fontStyle = FontStyle.Bold;
            titleText = new GUIStyle(GUI.skin.GetStyle("label"));
            titleText.fontSize = 25;
            titleText.fontStyle = FontStyle.Bold;
            titleText.alignment = TextAnchor.MiddleLeft;
            titleText.normal.textColor = Color.white;
            warningText = new GUIStyle(GUI.skin.GetStyle("label"));
            warningText.fontSize = 18;
            warningText.fontStyle = FontStyle.Bold;
            warningText.normal.textColor = Color.red;
            warningText.alignment = TextAnchor.MiddleCenter;
            wrapText = new GUIStyle(GUI.skin.GetStyle("label"));
            wrapText.wordWrap = true;
            init = false;
        }

        protected virtual void SetTitle(string titleBar, string header)
        {
            titleContent = new GUIContent(titleBar);
            headerTitle = header;
        }

        protected virtual void GetHeader()
        {
            header = null;
        }

        protected void OnEnable()
        {
            init = true;
        }

        protected void OnGUI()
        {
            if (init)
            {
                Load();
            }
            if (header == null) GetHeader();
            GUI.DrawTexture(new Rect(0, 0, maxSize.x, 82), header, ScaleMode.StretchToFill);
            GUI.Label(new Rect(90, 15, Screen.width - 95, 50), headerTitle, titleText);
            for (int i = 0; i < panels.Length; i++)
            {
                panels[i].Draw();
            }
            Repaint();

        }

        protected Data LoadBannersData(string url, string savePrefKey)
        {
            var data = default(Data);

            using (var mainDataReq = UnityWebRequest.Get(url))
            {
                mainDataReq.SendWebRequest();

                while (!mainDataReq.isDone || mainDataReq.result == UnityWebRequest.Result.InProgress)
                {

                }

                if (mainDataReq.result == UnityWebRequest.Result.ProtocolError ||
                    mainDataReq.result == UnityWebRequest.Result.DataProcessingError ||
                    mainDataReq.result == UnityWebRequest.Result.ConnectionError)
                {
                    Debug.LogError("An error occured while fetching the banners data.");
                }
                else
                {
                    var jObj = JsonUtility.FromJson<Data>(mainDataReq.downloadHandler.text);

                    data = new Data();
                    data.version = jObj.version;
                    data.banners = jObj.banners;

                    var currentVersion = EditorPrefs.GetInt(savePrefKey, -1);

                    if (currentVersion < 0 || currentVersion < data.version)
                    {
                        EditorPrefs.SetInt(savePrefKey, data.version);
                    }
                }
            }

            return data;
        }

        protected void OnEditorUpdate()
        {
            if (!_hasSentImageRequest)
            {
                _hasSentImageRequest = false;
                EditorApplication.update -= OnEditorUpdate;
                return;
            }

            for (int i = 0; i < _textureWebRequests.Count; i++)
            {
                var request = _textureWebRequests[i];

                if (!request.isDone || request.result == UnityWebRequest.Result.InProgress)
                {
                    if (request.result == UnityWebRequest.Result.ConnectionError ||
                        request.result == UnityWebRequest.Result.ProtocolError ||
                        request.result == UnityWebRequest.Result.DataProcessingError)
                    {
                        _textureWebRequests.RemoveAt(i);
                        i--;
                        Debug.LogError("A banner request failed for the spline welcome screen! Please investigate!");
                    }

                    return;
                }
            }

            for (int i = 0; i < _textureWebRequests.Count; i++)
            {
                var request = _textureWebRequests[i];

                if (request.result == UnityWebRequest.Result.Success)
                {
                    var texture = DownloadHandlerTexture.GetContent(request);
                    var data = _bannerData.banners[i];
                    var banner = new WindowPanel.Banner(texture, data.title, data.description, 400f, 70f, new ActionLink(data.forwardUrl));

                    panels[0].elements.Add(new WindowPanel.Space(400, 10));
                    panels[0].elements.Add(banner);
                    request.Dispose();
                }
            }

            DrawFooter();
            _hasSentImageRequest = false;
            _textureWebRequests.Clear();
            _textureWebRequests = null;
            EditorApplication.update -= OnEditorUpdate;
        }

        protected virtual void DrawFooter()
        {
        }

        public class WindowPanel
        {
            public WindowPanel back = null;
            public float slideStart = 0f;
            public float slideDuration = 1f;
            public enum SlideDiretion { Left, Right, Up, Down }
            public SlideDiretion openDirection = SlideDiretion.Left;
            public SlideDiretion closeDirection = SlideDiretion.Right;
            private Vector2 origin = Vector2.zero;
            private bool open = false;
            private bool goingBack = false;
            public List<Element> elements = new List<Element>();

            public WindowPanel(string title, bool o, float slideDur = 1f)
            {
                slideDuration = slideDur;
                SetState(o, false);
            }

            public WindowPanel(string title, bool o, WindowPanel backPanel, float slideDur = 1f)
            {
                slideDuration = slideDur;
                SetState(o, false);
                back = backPanel;
            }

            public bool isActive
            {
                get
                {
                    return open || Time.realtimeSinceStartup - slideStart <= slideDuration;
                }
            }

            public void Back()
            {
                Close(true, true);
                back.Open(true, true);
            }

            public void Close(bool useTransition, bool goBack = false)
            {
                SetState(false, useTransition, goBack);
            }

            public void Open(bool useTransition, bool goBack = false)
            {
                goingBack = false;
                SetState(true, useTransition, goBack);
            }

            Vector2 GetSize()
            {
                return new Vector2(Screen.width, Screen.height- 82);
            }

            void HandleOrigin()
            {
                float percent = Mathf.Clamp01((Time.realtimeSinceStartup - slideStart) / slideDuration);
                Vector2 size = GetSize();
                SlideDiretion dir = openDirection;
                if (goingBack) dir = closeDirection;
                if (open)
                {
                    switch (dir)
                    {
                        case SlideDiretion.Left:
                            origin.x = Mathf.SmoothStep(size.x, 0f, percent);
                            origin.y = 0f;
                            break;

                        case SlideDiretion.Right:
                            origin.x = Mathf.SmoothStep(-size.x, 0f, percent);
                            origin.y = 0f;
                            break;

                        case SlideDiretion.Up:
                            origin.x = 0f;
                            origin.y = Mathf.SmoothStep(size.y, 0f, percent);
                            break;

                        case SlideDiretion.Down:
                            origin.x = 0f;
                            origin.y = Mathf.SmoothStep(-size.y, 0f, percent);
                            break;
                    }
                }
                else
                {
                    switch (dir)
                    {
                        case SlideDiretion.Left:
                            origin.x = Mathf.SmoothStep(0f, -size.x, percent);
                            origin.y = 0f;
                            break;

                        case SlideDiretion.Right:
                            origin.x = Mathf.SmoothStep(0f, size.x, percent);
                            origin.y = 0f;
                            break;

                        case SlideDiretion.Up:
                            origin.x = 0f;
                            origin.y = Mathf.SmoothStep(0f, -size.y, percent);
                            break;

                        case SlideDiretion.Down:
                            origin.x = 0f;
                            origin.y = Mathf.SmoothStep(0f, -size.y, percent);
                            break;
                    }
                }
            }

            void SetState(bool state, bool useTransition, bool goBack = false)
            {
                if (open == state) return;
                open = state;
                if (useTransition) slideStart = Time.realtimeSinceStartup;
                else slideStart = Time.realtimeSinceStartup + slideDuration;
                goingBack = goBack;
            }

            public void Draw()
            {
                if (!isActive) return;
                HandleOrigin();
                Vector2 size = GetSize();
                GUILayout.BeginArea(new Rect(origin.x + 25, origin.y + 85, size.x - 25, size.y));
                //Back button
                if (back != null)
                {
                    if (GUILayout.Button("◄", GUILayout.Width(45), GUILayout.Height(25)))
                    {
                        Back();
                    }
                }

                for (int i = 0; i < elements.Count; i++) elements[i].Draw();
                GUILayout.EndArea();
            }

            public class Element
            {
                protected Vector2 size = Vector2.zero;
                public ActionLink action = null;

                public Element(float x, float y, ActionLink a = null)
                {
                    size = new Vector2(x, y);
                    action = a;
                }

                internal virtual void Draw()
                {
                }
            }

            public class Space : Element
            {
                public Space(float x, float y) : base(x, y)
                {

                }

                internal override void Draw()
                {
                    GUILayoutUtility.GetRect(size.x, size.y);
                }
            }

            public class Button : Element
            {
                string text = "";

                public Button(float x, float y, string t, ActionLink a) : base(x, y, a)
                {
                    text = t;
                }

                internal override void Draw()
                {
                    base.Draw();
                    if(GUILayout.Button(text, GUILayout.Width(size.x), GUILayout.Height(size.y)))
                    {
                        if (action != null) action.Do();
                    }
                }
            }

            public class Banner : Element
            {
                private string _title;
                private string _description;
                private Texture _image;

                public Banner(float x, float y, ActionLink a = null) : base(x, y, a) { }

                public Banner(Texture image, string title, string description, float x, float y, ActionLink a = null) : this(x, y, a)
                {
                    _title = title;
                    _description = description;
                    _image = image;
                    size = new Vector2(image.width, image.height);
                }

                internal override void Draw()
                {
                    Rect rect = GUILayoutUtility.GetRect(size.x, size.y);

                    EditorGUIUtility.AddCursorRect(rect, MouseCursor.Link);

                    GUI.BeginGroup(rect);
                    if (GUI.Button(new Rect(0, 0, size.x, size.y), "")) action.Do();

                    GUI.DrawTexture(new Rect(Vector2.one, size), _image, ScaleMode.StretchToFill);

                    var hoverRect = new Rect(0, 0, size.x, size.y);
                    if (hoverRect.Contains(Event.current.mousePosition))
                    {
                        EditorGUI.DrawRect(hoverRect, new Color(1, 1, 1, 0.5f));
                    }

                    var titleStyle = new GUIStyle();
                    titleStyle.fontSize = 19;
                    titleStyle.fontStyle = FontStyle.Bold;
                    titleStyle.alignment = TextAnchor.MiddleLeft;
                    titleStyle.normal.textColor = Color.white;
                    EditorGUI.DropShadowLabel(new Rect(6, 5, 370 - 65, 18), _title, titleStyle);

                    var descriptionStyle = new GUIStyle();
                    descriptionStyle.fontSize = 11;
                    descriptionStyle.wordWrap = true;
                    descriptionStyle.fontStyle = FontStyle.Bold;
                    descriptionStyle.alignment = TextAnchor.MiddleLeft;
                    descriptionStyle.normal.textColor = Color.white;

                    EditorGUI.DropShadowLabel(new Rect(6, 20, 380, 40), _description, descriptionStyle);

                    GUI.EndGroup();
                    GUILayout.Space(5);
                }
            }

            public class Thumbnail : Element
            {
                private string thumbnailPath = "";
                private string thumbnailName = "";
                private Texture2D thumbnail = null;
                public string title = "";
                public string description = "";

                public Thumbnail(string path, string fileName, string t, string d, ActionLink a, float x = 400, float y = 60) : base(x, y, a)
                {
                    title = t;
                    description = d;
                    thumbnailPath = path;
                    thumbnailName = fileName;

                    thumbnail = ResourceUtility.EditorLoadTexture(thumbnailPath, thumbnailName);
                }

                internal override void Draw()
                {
                    Rect rect = GUILayoutUtility.GetRect(size.x, size.y);
                    Color buttonColor = Color.clear;
                    if (rect.Contains(Event.current.mousePosition)) buttonColor = Color.white;
                    GUI.BeginGroup(rect);
                    GUI.color = buttonColor;
                    if (GUI.Button(new Rect(0, 0, size.x, size.y), "")) action.Do();
                    GUI.color = Color.white;
                    if (thumbnail != null)
                    {
                        Vector2 offset = new Vector2(5, (size.y - 50) / 2);
                        GUI.DrawTexture(new Rect(offset, Vector2.one * 50), thumbnail, ScaleMode.StretchToFill);
                    }
                    GUI.Label(new Rect(60, 5, 370 - 65, 16), title, buttonTitleText);
                    GUI.Label(new Rect(60, 20, 370 - 65, 40), description, wrapText);
                    GUI.EndGroup();
                    GUILayout.Space(5);
                }
            }

            public class ScrollText : Element
            {
                Vector2 scroll = Vector2.zero;
                string text = "";

                public ScrollText(float x, float y, string t) : base(x, y)
                {
                    text = t;
                }

                internal override void Draw()
                {
                    base.Draw();
                    scroll = GUILayout.BeginScrollView(scroll, GUILayout.Width(size.x), GUILayout.MaxHeight(size.y));
                    EditorGUILayout.LabelField(text, wrapText, GUILayout.Width(size.x - 30));
                    GUILayout.EndScrollView();
                }
            }

            public class Label : Element
            {
                string text = "";
                Color color;
                GUIStyle style = null;
                public Label(string t, GUIStyle s, Color col) : base(400, 30)
                {
                    color = col;
                    text = t;
                    style = s;
                }

                public Label(string t, GUIStyle s, Color col, float x, float y) : base(x, y)
                {
                    color = col;
                    text = t;
                    style = s;
                }

                internal override void Draw()
                {
                    base.Draw();
                    Color prev = GUI.color;
                    GUI.color = color;
                    if(style == null) EditorGUILayout.LabelField(text, GUILayout.Width(size.x), GUILayout.Height(size.y));
                    else EditorGUILayout.LabelField(text, style, GUILayout.Width(size.x), GUILayout.Height(size.y));
                    GUI.color = prev;
                }
            }
        }

        public class ActionLink {
            private string URL = "";
            private WindowPanel currentPanel = null;
            private WindowPanel targetPanel = null;
            private EmptyHandler customHandler = null;

            public ActionLink(string u)
            {
                URL = u;
            }

            public ActionLink(EmptyHandler handler)
            {
                customHandler = handler;
            }

            public ActionLink(WindowPanel target, WindowPanel current)
            {
                currentPanel = current;
                targetPanel = target;
            }

            public void Do()
            {
                if (customHandler != null) customHandler();
                else if(URL != "") Application.OpenURL(URL);
                else if(targetPanel != null && currentPanel != null)
                {
                    currentPanel.Close(true);
                    targetPanel.Open(true);
                }
            }
        }

        [System.Serializable]
        public class Data
        {
            public BannerData[] banners;
            public int version;
        }

        [System.Serializable]
        public class BannerData
        {
            public string title;
            public string description;
            public string bannerUrl;
            public string forwardUrl;
            public int height;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Editor/WelcomeWindow.cs

