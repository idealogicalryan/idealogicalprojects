# CONSOLIDATED: Framework.Runtime
# GENERATED: 2025-11-17 11:55:11
# PART: 1
# FILE COUNT (part): 681
# LINE ENDINGS: LF
# ENCODING: UTF-8 (no BOM)
# INDEX BEGIN
# SYSTEM: com_ldx_frameworkSystem (681 files)
#   Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Attributes/MetricConfigContainerAttribute.cs
#   Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Attributes/ObjectiveIDSelectionAttribute.cs
#   Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Config/BaseMetricConfig.cs
#   Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Config/FieldConfig.cs
#   Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Config/ProjectMetricDefinitions.cs
#   Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Config/TimeMetricConfig.cs
#   Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Core/AnalyticsConfigData.cs
#   Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Core/AnalyticsController.cs
#   Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Core/ObjectiveMetrics.cs
#   Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Core/ProjectIDMap.cs
#   Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Core/ScenarioMetrics.cs
#   Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Entries/BaseMetricEntry.cs
#   Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Entries/TimeMetricEntry.cs
#   Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Trackers/BaseMetricTracker.cs
#   Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Trackers/TimeMetricTracker.cs
#   Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Data/ControllerFreeAddOnConfig.cs
#   Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Data/GesturesExtensionIDDefinition.cs
#   Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Features/Machinery/GestureMachineryInputModule.cs
#   Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/ControllerFreeAddOnModule.cs
#   Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/DebugFeature/DebugGestureSystemFeature.cs
#   Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/Gestures/ControllerFreeInputModule.cs
#   Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/Gestures/GestureConfig.cs
#   Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/Gestures/GestureDetectionZone.cs
#   Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/Gestures/GestureHandler.cs
#   Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/Gestures/GestureNotifier.cs
#   Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/Gestures/RequiredGestureBlocker.cs
#   Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/Gestures/TeleportationHandGesture.cs
#   Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/HandTracking/LdxOpenXRAutoHandTracking.cs
#   Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/UI/ButtonHandTouchEvent.cs
#   Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/UI/ControllerFreeUIInteractionModule.cs
#   Packages/com_ldx_framework/AddOns/SeuratCapture/Runtime/Scripts/CaptureBuilder.cs
#   Packages/com_ldx_framework/AddOns/SeuratCapture/Runtime/Scripts/CaptureHeadbox.cs
#   Packages/com_ldx_framework/AddOns/SeuratCapture/Runtime/Scripts/JsonManifest.cs
#   Packages/com_ldx_framework/AddOns/SeuratCapture/Runtime/Scripts/SeuratCaptureController.cs
#   Packages/com_ldx_framework/AddOns/SeuratCapture/Runtime/Scripts/SeuratCaptureHeadbox.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Animation/AnimationObject.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Drawing/DrawableSurface.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Drawing/DrawingMark.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Drawing/DrawingTool.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Drawing/ErasingTool.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/EventImageDisplay/EventImageCombo.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/GhostController/GhostController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/GhostController/GhostControllerDisplayModule.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/GhostHandGuide/GhostHandGuide.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/GhostHandGuide/GhostHandGuideTracker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Hazards/DangerTrigger.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Hazards/DangerTriggerController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Hazards/InvisibleHazard.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Hazards/InvisibleHazardsController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Hazards/LdxHazardTypeReporter.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Hierarchy/HierarchyInfo.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Hierarchy/HierarchyStateSaver.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/HighlightableObject.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/HighlightingGlobalSettings.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/HighlightingLineRenderer.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/HighlightingMethod.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/HighlightOutlinePulser.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/HighlightOverlayPulser.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/HoverHighlightProcessor.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/ObjectHighlighterController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Inspection/InspectableObject.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Inspection/InspectionFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/InstallObjectFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/HologramObjectHighlighting.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/ILockable.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/InteractableObject.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/InteractableObjectManager.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/InteractableObjectsGlobalSettings.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/InteractionIconFeature/InteractionIconRenderPass.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/InteractionIconFeature/InteractionIconRenderPassFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/KinematicGrabbable.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/ObjectHighlighting.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/PlayerTriggerInteractableBag.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/SlidingMechanism.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/SplineMeshKinematicGrabbable.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/TransformKinematicGrabbable.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/TransformValuesCache.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/LdxBlendShapeCollision.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Linerenderers/WireSimulator.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/AutomatedMachineryInputModule.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/BaseMachineryController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/BaseRotationModule.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/BoomExtendModule.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/BoomRaiseModule.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/CableRopeModule.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/KeyboardMachineryInputModule.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/MachineModuleBase.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/MachineryInputModuleBase.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/IDMagnetFilter.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/IMagneticPullSystem.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/MagnetFilter.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/MagneticObject.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/MagneticPull.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/MagneticPullSystem.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/MagneticPullSystemSimplified.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/MagneticSystemController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Measurements/RulerController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Measurements/RulerMaker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Measurements/RulerMark.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Movement/MovePositionRelative.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Movement/MoveToPlayerView.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/ObjectiveFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Painting/LdxPaintableSurface.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Painting/LdxPaintCleanlinessCheck.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Painting/LdxPainter.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Painting/LdxPaintingObject.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Painting/LdxProceduralPainter.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/PhysicsButtons/Dial.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/PhysicsButtons/PhysicsButton.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/PhysicsButtons/PhysicsSwitchButton.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/PhysicsButtons/ThreeStageSwitchButton.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/PPE/PPEFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/PPE/PPEObject.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/PPE/PPEOnGrabAction.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/SimpleSwitch.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/SocketFilter/HolsterSpawnData.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Splines/SplineCableSimulator.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Splines/SplineInfo.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Splines/SplineMasterController/Features/AnimationSplineFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Splines/SplineMasterController/Features/GrabbingSplineFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Splines/SplineMasterController/Features/StaticVisualSplineFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Splines/SplineMasterController/SplineFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Splines/SplineMasterController/SplineMasterController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Timer/LdxTimer.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Tutorial/TutorialControllerGhost.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Tutorial/TutorialControllerHand.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Tutorial/TutorialHandGhost.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Visual/ChangeMaterialOnEvent.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Visual/FadeEffect/FadeEffect.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Visual/FadeEffect/HighlightPulseEffect.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Visual/ScaleOnEnable.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Visual/Tweening/ObjectTweener.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Visual/Tweening/TweenContainers.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Features/Visual/Tweening/TweenOperation.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/AddOns/AddOnConfig.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/AddOns/AddOnModule.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/AmbientSound.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/Audio.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/AudioEmitter.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/AudioEmitterFeatures.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/AudioEnums.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/AudioGlobalSettings.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/AudioRuntimeManager.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/BitCrushFilter.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/LdxSoundManagerExtension.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/LocalizedAudioClip.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/PlacePointAudio.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/PlayAudioBetweenScenarios.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/PlayOnEnable.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/SceneAudioManager.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/Sound.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/SoundInstance.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/SoundManifest.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/AutoHand/ParentingDispenserPoint.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugConsole.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/CompleteObjectiveDebugFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/DebugConsoleFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/DebugScoringSystemFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/NameSelectionDebugFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/ScenarioAvgFpsLogDebugFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/ScreenshotDebugFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/SendLogDebugFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/ShowFPSDebugFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/UploadDebugFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugToolController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugUsers.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugWebHelper.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/FpsDisplay.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/ILocalizable.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LanguageData.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LanguageSelectionScreenBlocker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LdxHelpers.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationEntry.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationGlobalSettings.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationKeyAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationModel.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationTable.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationTableData.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationTableExtensions.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationUtilities.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/NoLocalizationFrameworkTable.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Attributes/GlobalOnlyAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Attributes/ObjectiveTypesFilterAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/BaseObjective.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/AnyObjectAnyWaistSocketPlacedCondition.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/CheckCrouchingCondition.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/CheckKeyCondition.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/DialogCompleteCondition.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/GrabbedAnyObjectCondition.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/KeyboardPressCondition.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/SystemMenuOpenedOrClosedCondition.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/TrackingEventCondition.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/VideoFinishedCondition.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/AnimationEventDatas.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/AudioEventDatas.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/ControlsEventDatas.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/FlowControlObjectiveEventDatas.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/HighlighterObjectInfo.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/HighlightingEventDatas.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/InstallObjectFeatureEventData.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/MiscEventDatas.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/ObjectivesEventDatas.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/ObjectsAndTransformsEventDatas.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/PlayerEventDatas.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/PPEFeatureEventData.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/ReactiveDialogData.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/ScenarioEventDatas.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/SetWorldObjectiveStepEventData.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/SeuratEventDatas.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/StepsFlowEventData.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/TeleportationEventDatas.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/TetherActionEventDatas.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/TimersEventDatas.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/TransitionEventDatas.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/UIEventDatas.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/VisualFeedbackEventDatas.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Feedback/ObjectiveFeedbackData.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Feedback/ObjectiveFeedbackManager.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ID/ExtensionIDDefinition.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ID/ExtensionIDInfoContainer.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ID/IDHelpers.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ID/IdTypeWrapper.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/InteractableID.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/InteractableIDEditorConfig.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/IObjective.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/LdxIdSettings.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveCondition.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveEventData.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveOption.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveOptions/DisplayAsHierarchyParentObjectiveOption.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveOptions/FinishesWithChildObjectivesObjectiveOption.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveOptions/HideTickObjectiveOption.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveOptions/ShowInRequirementsObjectiveOption.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveOptions/ShowNotificationObjectiveOption.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveOptions/StartDelayObjectiveOption.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveProcessor.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveSystem.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveTransform.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveType.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/SpawnPoint.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/AnimationEventsTracker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/AudioEventTracker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/CollisionEnums.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/CollisionTrackingKeySetter.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/CollisionTrackingKeySetterEverySecond.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/DialogAnswersTrackingFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/EventCounterTrackingFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/EventDataTracker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/HighlighterEventsTracker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/HighlightStateSetter.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/InteractableEventsTracker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/IObjectGroupInitializer.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/KeySetterOnPlayerTrigger.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxEventNotifierOnCollision.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxObjectGroup.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxObjectiveEventsTracker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxReferenceIDTracker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxSpawnResetEventTracker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxTimerEventNotifier.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxTrackingEventArgument.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxTrackingManager.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxTrackingUnityEventListener.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/PlayerActionTracker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/ScenarioLoadEventTracker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/SetTrackingKeyBasedOnLocalRotation.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/SeuratEventsTracker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/Socketing/SocketableArrowMarker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/Socketing/SocketToHolsterGuideTracker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TetherEventsTracker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TrackingEventBlocker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TrackingEventInteractableNotifier.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TrackingEventListener.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TrackingEventNotifier.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TrackingFeature.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TrackingKeyController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TrackingKeySetter.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TransformEventsTracker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/UIEventsTracker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/WorldObjective/IStepController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/WorldObjective/WorldObjectiveStep.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/WorldObjective/WorldObjectiveStepManager.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/Hands/ApplyHandPoseBehaviour.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/Hands/HandFeedback.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/Hands/HandsController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/Hands/HandVisualChangeZone.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/IdealogicalAutoHandPlayer.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/Input/ControllersInputModule.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/Input/IInputModule.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/PlayerController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/PlayerFallController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/PlayerGlobalSettings.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/PlayerMovementRequest.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/PlayerPositionMarker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/PlayerRig/MaxDropData.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/PlayerRig/PlayerRigOverrides.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/StartPoint/BaseStartPointMarker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/StartPoint/CustomCameraPreview.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/StartPoint/CustomStartPoint.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/StartPoint/CustomStartPointKeyBased.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/StartPoint/PlayerStartPoint.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/StartPoint/RandomizedStartPointController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/StartPoint/SegmentCustomStartPoint.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/TeleportMarkerHolder.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/Waist/WaistController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Save/LdxSaveSystem.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/ActiveMainMenuBlocker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/BaseScenario.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/Global/BootstrapperProvider.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/Global/BootstrapperType.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/GlobalData.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/ObjectiveData.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/ObjectiveDataSessionHelper.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/PlayerRigData.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/Scenario/GlobalScenarioOption.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/Scenario/ScenarioDataInfo.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/Scenario/ScenarioDataType.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/Scenario/ScenarioEndTypes.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/ScenarioData.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/StartupLoadingMode.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/IScenarioResult.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/LdxScenarioConfig.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/LobbyScenario.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Scenario.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/ScenarioLoadingBlocker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/ScenarioLoadingParameters.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/ScenarioManager.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/ScenarioParameters.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/ScenarioUtiltites/RenderSettingsCache.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/ScenarioUtiltites/ScenarioHelper.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/TutorialScenario.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/SceneManagement/SceneReference.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Scoring/ScoringData.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Scoring/ScoringSystem.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Settings/EditorGlobalSettings.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/PlayerTeleporter.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/TeleportationModeBlocker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/TeleportationSnapZone.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/TeleportationZone.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/TeleportationZonesManager.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/TeleporterVisuals.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/TeleportMarker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/XRTeleporterInput.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Tethers/InteractableTetherOrb.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Tethers/TetherController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Tethers/TransformTarget.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/Tethers/TransformTether.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/AddInputCanvas.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Appearance/ButtonStyleProfile.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Appearance/IAppearanceUpdateableUI.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/AutoRestartWindow.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Buttons/ActionButton.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Buttons/ButtonBehaviour.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Buttons/ButtonStateVisualBehaviour.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Buttons/UIButton.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Components/CustomHorizontalScrollRect.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/ConfirmationWindow.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/ControllerButtonChangeUIElementVisibility.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/DialogParameters.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/DialogueWindow.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/EndScreenBlocker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/FadeOverrideConfig.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Fading/ScreenFadeConsts.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Fading/ScreenFadeTimer.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Feedback/ProgressCircle.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Feedback/ProgressCirclesController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Font/FontStyleData.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Font/LanguageFonts.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/HideUIElementWhenOutsideView.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/HighlightProcessors/HighlightOutlineProcessor.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/HighlightProcessors/HighlightPlusProcessor.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/HighlightProcessors/HighlightProcessor.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/HighlightProcessors/HighlightProcessorParam.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/IAnchorParent.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Input/InputValidators.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Interaction/CanvasHitPointMarker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Interaction/CanvasPointerLineRenderer.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Interaction/IUIPointer.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Interaction/LdxHandCanvasPointer.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Interaction/LdxInputModule.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/InventoryHandler.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/KeyboardWindow.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/LdxObjectInfoController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/LocalizedElement.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/LocalizedTextUGUI.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/MainMenu/HandCameraController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/MainMenu/MainMenuBlocker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/AutoRestart/AutoRestartModule.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Inspection/InspectionProgressUI.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Inspection/InspectionUIModule.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/IUIModule.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Tooltip/DisplayTooltips.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Tooltip/ObjectTooltip.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Tooltip/TooltipController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Tooltip/TooltipService.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Tooltip/WorldTooltip.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Wrist/WristUI.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Wrist/WristUIShownBlocker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Notifier/UINotify.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Notifier/UINotifyMessage.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/RadialButtonActionBase.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/RadialSystemMenu.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/ScenarioEndWindow.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/ScenarioTransitionUI.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/ScreenTextureChanger.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/SegmentAnchorController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/SpriteAnimation.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/AnimatedLineRenderer.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/BaseStepElement.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/CompletedStepElement.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/CurrentStepElement.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/FutureStepElement.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/ProgressBar.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/StepsFlowDisplay.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/StepsFlowEventsTracker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIAnchor.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIAnchorController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIAnchorGroup.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIArrowPointToTarget.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIDistanceScaler.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIElement.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIGlobalSettings.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIOverlayFade.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIToggle.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UITweenedStates.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Video/LdxVideoPlayer.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Video/LdxVideoPlayerControlPanel.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Video/LdxVideoPlayerControlType.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/VFX/AlignmentLineRenderer.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/VFX/DynamicLineRenderer.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/VFX/FXFeedbackUtility.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/VFX/LdxFxController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/VFX/LdxFxEventsTracker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Systems/VFX/VisualEffect.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/ActiveObjectWithDelay.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenCanvasGroupFadeBehaviour.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenGraphicColorChangeBehaviour.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenGraphicFadeBehaviour.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenLineRendererFadeBehaviour.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenLineRendererPointToPositionBehaviour.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenRectTransformDeltaSizeBehaviour.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenTransformMoveBehaviour.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenTransformRotateBehaviour.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenTransformScaleBehaviour.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Common/DoTweenBaseBehaviour.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Common/DoTweenCanvasGroupBaseBehaviour.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Common/DoTweenGraphicBaseBehaviour.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Common/DoTweenLineRendererBaseBehaviour.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Common/DoTweenRectTransformBaseBehaviour.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Common/DoTweenTransformBaseBehaviour.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/DoTweenAnimation.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/DoTweenAnimationController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Async/AsyncOperationGroup.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/ConvertsToAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/GroupAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/HelpBoxAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/HideAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/IDSelectionAllAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/IDSelectionAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/IDSelectionShowIfEventTypeAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/InheritedClassContainerAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/InheritedClassDropdownAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/NodeMenuItemAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/NoteAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/ObjectiveCategoryAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/ObjectiveInspectorAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/ObjectiveSelectionAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/ReadOnlyAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/RequireComponentInSceneAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/RequireInterfaceAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/RequireTrackerAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/SavePathAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/SceneSavingAddOnAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/SceneSetupLinkAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/SerializableContainerAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/ShowIfAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/ShowWhenAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/SingletonSpawnableAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/SoundReferenceAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/TrackedReferenceAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/WizardCategoryAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Axis.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Blockers/IBlocker.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/CollisionUtilities.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Constants.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/ConstrainAxis.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/CoroutineUtilities.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/DrawGizmo.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/EditorNote.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/AnimationCurveExtensions.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/AssemblyUtilities.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/CameraExtensions.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/ColorExtensions.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/Colors.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/ComponentUtilities.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/FloatExtensions.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/GameObjectExtensions.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/HighlighterHelper.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/LayerExtensions.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/LdxFileHandler.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/ListUtilities.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/NumberUtilities.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/PathUtilities.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/PlacePointExtensions.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/PrefabHelper.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/ProjectUtilities.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/RectExtensions.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/ReflectionHelpers.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/ReflectionUtilities.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/SceneUtilities.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/ScriptableObjectUtilities.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/SerializableDictionaryExtensions.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/SerializedObjectUtilities.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/StringUtilities.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/TaskExtensions.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/TextureExtensions.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/TimeUtilities.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/TransformUtilities.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/VectorExtensions.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/VisualElementExtensions.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/GlobalSettings.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Graphics/SwapShaderIfSRP.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/HasFrameworkDefaultAttribute.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Hierarchy/HierarchyColor.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Hierarchy/HierarchyColorSettings.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/InputUtilities/ControllerButtonInput.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/ISaveSceneListener.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/LdxDebugUI.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Logging/BatteryLogger.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Logging/DebugExtensions.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Logging/LogCategories.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Logging/LogGlobalSettings.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Logging/LogVerbosity.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Logging/LogVerbosityCollection.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Logging/Reporters/CollisionReporter.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Misc/LdxCollisionEvents.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Misc/Outline.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Misc/PlayerHolster.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Misc/ReturnToTargetPosition.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/PathFinding/AStarPathfinding.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/PathFinding/GraphNode.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/PriorityQueue.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Range.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Reactive/ReactiveProperty.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/ReferenceBank.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Routines/Routine.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Routines/RoutineManager.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/ScriptableSingleton.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Serializable/ListHashSet.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Serializable/SerializableDictionary.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Serializable/SerializableHashSet.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/SerializedObjectUtilities.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Seurat/EnvironmentTransitionController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Seurat/EnvironmentTransitionZone.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Seurat/SeuratEnvironment.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Singleton.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/SyncTransformWithTarget.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/AlwaysFaceCamera.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/AudioRuntimeEditorDebug.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/ConstrainMotion.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/DestroyAfter.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/DestroyObjectOnUnloading.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/DisableScriptsWhenHandSideGrabs.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/EventOnCollision.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/EventOnTrigger.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/IgnoreCollision.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LayerSwap.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxAddPersistentVelocity.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxAdjustHeightToObject.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxAlwaysFaceCamera.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxAnimate.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxCollisionGroupInvisibleInGame.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxDisableAfterSeconds.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxLifecycleUnityEvents.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxMaterialSwap.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxMoveTransform.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxOnDisableEnable.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxOnEnableDisable.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxPlaceBetweenTransforms.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxRendererEnabler.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxReturnObjectAfterFall.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxScaleOnCollision.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxScaleRelativeToDistance.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LookAtTarget.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/OverrideCanvasOrder.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/PhysicsTargetDetectorBase.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/ReplaceHierarchyChildrenShaders.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/Resocketing/ResocketableItem.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/Resocketing/ResocketOptions.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/Resocketing/SocketResocketingInfo.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/SetParentOnTrackingEvent.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/SmoothPlayerFollower.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/StickToPlayerPosition.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/StickToTargetPosition.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/StickToTargetsPosition.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/WebConnection/EmailController.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/WebConnection/Hashing.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/WebConnection/WebRequests.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Wizard/ColliderTypes.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Wizard/SetupWizard.cs
#   Packages/com_ldx_framework/Runtime/Scripts/Utilities/Wizard/WizardOperation.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryAlwaysRender.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryDirectLight.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryLightmapGroup.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryLightmapGroupSelector.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryLightmappedPrefab.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryLightMesh.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryPackAsSingleSquare.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryPointLight.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryProjectSettings.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakerySector.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakerySectorCapture.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakerySharedLodUv.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakerySkyLight.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryVolume.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/examples/scripts/BakeryVolumeReceiver.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/examples/scripts/BakeryVolumeTrigger.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/examples/scripts/VolumeTestScene2.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/ftGlobalStorage.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/ftLightmaps.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/ftLightmapsStorage.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/ftLocalStorage.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/ftSettingsAsset.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Bakery/ftStorageAsset.cs
#   Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModuleAudio.cs
#   Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModuleEPOOutline.cs
#   Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModulePhysics.cs
#   Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModulePhysics2D.cs
#   Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModuleSprite.cs
#   Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModuleUI.cs
#   Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModuleUnityVersion.cs
#   Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModuleUtils.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/BoxAttribute.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/ConditionalAttributes.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/ConditionDescriptor.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/DisableIfGroupAttribute.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/EndGroupAttribute.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/FoldoutAttribute.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/HideIfGroupAttribute.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/HorizontalGroupAttribute.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/InlineEditorAttribute.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/LayoutGroupAttribute.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/MarkedUpTypeAttribute.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/TabAttribute.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/TabScopeAttribute.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/TitleGroupAttribute.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/ToggleGroupAttribute.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/VerticalGroupAttribute.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Rope/Core/DisableInPlayModeAttribute.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Rope/Core/PointsExtensions.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Rope/Core/RigidbodyExtensions.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Rope/Rope.cs
#   Packages/com_ldx_framework/Runtime/Third Party/Rope/RopeConnection.cs
#   Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Bezier/CubicBezierCurve.cs
#   Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Bezier/CurveSample.cs
#   Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Bezier/Spline.cs
#   Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Bezier/SplineNode.cs
#   Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Bezier/SplineSmoother.cs
#   Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Example/ExampleContortAlong.cs
#   Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Example/ExampleFollowSpline.cs
#   Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Example/ExampleGrowingRoot.cs
#   Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Example/ExampleSower.cs
#   Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Example/ExampleTentacle.cs
#   Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Example/ExampleTrack.cs
#   Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Example/RopeBuilder.cs
#   Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/MeshProcessing/ExtrusionSegment.cs
#   Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/MeshProcessing/MeshBender.cs
#   Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/MeshProcessing/MeshVertex.cs
#   Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/MeshProcessing/SourceMesh.cs
#   Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/MeshProcessing/SplineExtrusion.cs
#   Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/MeshProcessing/SplineMeshTiling.cs
#   Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Utils/CameraUtility.cs
#   Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Utils/MeshUtility.cs
#   Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Utils/UOUtility.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Arrays Pooling/ArrayPoolsProvider.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Arrays Pooling/Collections/SubArray.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Arrays Pooling/Collections/SubArrayList.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Arrays Pooling/Pools/ArrayPool.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Arrays Pooling/Pools/ArrayPoolUsageData.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/Base/ScalingModule.cs
# INDEX END
#
# FILE: Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Attributes/MetricConfigContainerAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6e7d6599f24f4a948150d13c3cf9ee54
# ASMDEF: ldx.analytics.runtime.dll
# ---
using System;
using Ldx.Framework.Utilities.Attributes;

namespace Ldx.Framework.AddOns.Analytics.Attributes
{
    /// <summary>
    /// Marks the container of metric configs
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    public class MetricConfigContainerAttribute : SerializableContainerAttribute
    {
    }
}
# --- end Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Attributes/MetricConfigContainerAttribute.cs

# FILE: Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Attributes/ObjectiveIDSelectionAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c32162c7ae2c4d8bb800004a70624f95
# ASMDEF: ldx.analytics.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Utilities.Attributes;

namespace Ldx.Framework.AddOns.Analytics.Attributes
{
    /// <summary>
    /// Custom attribute that provides a dropdown of the ID selections tied
    /// to a specific scenario
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    public class ObjectiveIDSelectionAttribute : IDSelectionAttribute
    {
        public string ScenarioIDFieldName { get; }
        
        public ObjectiveIDSelectionAttribute(LdxIdSettings.IdType idType, string scenarioIDFieldName) : base(idType)
        {
            ScenarioIDFieldName = scenarioIDFieldName;
        }
    }
}
# --- end Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Attributes/ObjectiveIDSelectionAttribute.cs

# FILE: Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Config/BaseMetricConfig.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 20ae65be70ac4c6ca80a42ab9ad90713
# ASMDEF: ldx.analytics.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.AddOns.Analytics.Trackers;
using Newtonsoft.Json;

namespace Ldx.Framework.AddOns.Analytics.Config
{
    /// <summary>
    /// A metric is a piece of information collected for analytics
    /// A metric config is the definition for said metric, used
    /// to define the name and expected fields for the metric to
    /// configure the backend to know what to expect
    /// </summary>
    [Serializable]
    public abstract class BaseMetricConfig
    {
        [JsonIgnore]
        public abstract string SerializationKeyName { get; }
        [JsonProperty("fields")]
        public abstract List<FieldConfig> Fields { get; }

        public abstract BaseMetricTracker GetNewTracker();
    }
}
# --- end Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Config/BaseMetricConfig.cs

# FILE: Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Config/FieldConfig.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 04ef20bb90874890bccf694e1f9398ff
# ASMDEF: ldx.analytics.runtime.dll
# ---
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Ldx.Framework.AddOns.Analytics.Config
{
    /// <summary>
    /// Defines a field for a metric to be serialized into JSON
    /// </summary>
    public abstract class FieldConfig
    {
        [JsonProperty("name", Order = 1)]
        public string Name { get; protected set; }
        [JsonProperty("type", Order = 2)]
        public abstract string TypeName { get; }
        [JsonProperty("isList", Order = 3)] 
        public virtual bool IsList => false;
    }

    public abstract class FieldConfig<T> : FieldConfig
    {
        public FieldConfig(string name)
        {
            Name = name;
        }
    }

    public class IntFieldConfig : FieldConfig<int>
    {
        public override string TypeName => "number";

        public IntFieldConfig(string name) : base(name)
        {
        }
    }

    public class FloatFieldConfig : FieldConfig<float>
    {
        public override string TypeName => "number";

        public FloatFieldConfig(string name) : base(name)
        {
        }
    }

    public class StringFieldConfig : FieldConfig<string>
    {
        public override string TypeName => "string";

        public StringFieldConfig(string name) : base(name)
        {
        }
    }

    public class StringListFieldConfig : FieldConfig<List<string>>
    {
        public override string TypeName => "string";
        public override bool IsList => true;

        public StringListFieldConfig(string name) : base(name)
        {
        }
    }
}
# --- end Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Config/FieldConfig.cs

# FILE: Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Config/ProjectMetricDefinitions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a1aa5937aac748e9ae98a30f05e8867f
# ASMDEF: ldx.analytics.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Reflection;

namespace Ldx.Framework.AddOns.Analytics.Config
{
    /// <summary>
    /// Class for getting a json-friendly serialized version of the metric definitions
    /// </summary>
    public class ProjectMetricDefinitions
    {
        public static Dictionary<string, BaseMetricConfig> GetProjectMetricDefinitions()
        {
            Dictionary<string, BaseMetricConfig> map = new();
            List<Type> types = new List<Type>();
            foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                foreach (Type type in assembly.GetTypes())
                {
                    if (!type.IsSubclassOf(typeof(BaseMetricConfig)) || type.IsAbstract)
                    {
                        continue;
                    }

                    types.Add(type);
                }
            }
            
            List<BaseMetricConfig> configs = new List<BaseMetricConfig>();
            foreach (Type type in types)
            {
                BaseMetricConfig instance = Activator.CreateInstance(type) as BaseMetricConfig;
                if (instance == null)
                {
                    continue;
                }
                map.Add(instance.SerializationKeyName, instance);
            }

            return map;
        }
    }
}
# --- end Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Config/ProjectMetricDefinitions.cs

# FILE: Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Config/TimeMetricConfig.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 25edccd9928b4c918372a857f962aab8
# ASMDEF: ldx.analytics.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.AddOns.Analytics.Trackers;
using Newtonsoft.Json;

namespace Ldx.Framework.AddOns.Analytics.Config
{
    /// <summary>
    /// Config definition of the time metric
    /// </summary>
    [Serializable]
    public class TimeMetricConfig : BaseMetricConfig
    {
        public override string SerializationKeyName => "timeMetric";
        [JsonProperty("fields")]
        public override List<FieldConfig> Fields { get; } = new() { new FloatFieldConfig("recordedTime") };
        
        public override BaseMetricTracker GetNewTracker()
        {
            return new TimeMetricTracker(this);
        }
    }
}
# --- end Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Config/TimeMetricConfig.cs

# FILE: Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Core/AnalyticsConfigData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 208c88e329ee81341bc07f9cd6da8363
# ASMDEF: ldx.analytics.runtime.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.AddOns.Analytics.Config;
using Ldx.Framework.Utilities;
using Newtonsoft.Json;
using UnityEngine;
using UnityEngine.Serialization;

namespace Ldx.Framework.AddOns.Analytics.Core
{
    /// <summary>
    /// The config data ScriptableObject for the analytics definitions
    /// Used to configure the analytics for this project
    /// </summary>
    [CreateAssetMenu(menuName = "AnalyticsConfigData", fileName = "AnalyticsConfigData", order = 0)]
    public class AnalyticsConfigData : GlobalSettings<AnalyticsConfigData>
    {
        [SerializeField]
        private List<ScenarioMetrics> scenarioMetrics = new();

        [JsonProperty("idMaps")]
        public ProjectIDMap IDMap => ProjectIDMap.GetProjectIDMap();
        [JsonProperty("metricDefinitions")]
        public Dictionary<string, BaseMetricConfig> TrackingDefinitions =>
            ProjectMetricDefinitions.GetProjectMetricDefinitions(); 
        [JsonProperty("scenarioMetrics")]
        public List<ScenarioMetrics> ScenarioMetrics => scenarioMetrics;

#if UNITY_EDITOR
        [ContextMenu("Log JSON Config")]
        public void LogJSONConfig()
        {
            JsonSerializerSettings settings = new JsonSerializerSettings
            {
                Formatting = Formatting.Indented, // For pretty-printing
            };

           Debug.Log(JsonConvert.SerializeObject(this, settings));
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Core/AnalyticsConfigData.cs

# FILE: Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Core/AnalyticsController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 83c241ec651141b6abfe4e892fe29bca
# ASMDEF: ldx.analytics.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.AddOns.Analytics.Config;
using Ldx.Framework.AddOns.Analytics.Entries;
using Ldx.Framework.AddOns.Analytics.Trackers;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Utilities;
using Newtonsoft.Json;
using UnityEngine;

namespace Ldx.Framework.AddOns.Analytics.Core
{
    /// <summary>
    /// The runtime controller for the analytics
    /// </summary>
    public class AnalyticsController : Singleton<AnalyticsController>
    {
        private string currentScenarioId;
        private List<BaseMetricTracker> activeTrackers = new();
        private Dictionary<string, List<BaseMetricTracker>> objectiveIdToTrackerMap = new();
        private Dictionary<string, AnalyticsContainer> objectiveIdToConfigMap = new ();
        private TrackingEntriesContainer entriesContainer = new();
        
        private AnalyticsConfigData Config => AnalyticsConfigData.Instance;

        
        /// <summary>
        /// Runs on runtime when the analytics package is included
        /// Instantiates the analytics controller
        /// </summary>
        [RuntimeInitializeOnLoadMethod]
        public static void InitializeOnRuntime()
        {
            AnalyticsController analyticsController =
                new GameObject("AnalyticsController").AddComponent<AnalyticsController>();
            DontDestroyOnLoad(analyticsController.gameObject);
        }

        private IEnumerator Start()
        {
            yield return new WaitUntil(() => ScenarioManager.IsValid);
            ScenarioManager.Instance.OnScenarioStarted += HandleScenarioStarted;
            ScenarioManager.Instance.OnScenarioCompleted += HandleScenarioCompleted;
            LdxObjective.OnAnyObjectiveBegan += HandleLdxObjectiveBegan;
            LdxObjective.OnAnyObjectiveComplete += HandleLdxObjectiveCompleted;
            ObjectiveSystem.Instance.OnAnyObjectiveBegin += HandleObjectiveBegan;
            ObjectiveSystem.Instance.OnAnyObjectiveComplete += HandleObjectiveCompleted;
        }

        private void OnDestroy()
        {
            ScenarioManager.Instance.OnScenarioStarted -= HandleScenarioStarted;
            ScenarioManager.Instance.OnScenarioCompleted -= HandleScenarioCompleted;
            LdxObjective.OnAnyObjectiveBegan -= HandleLdxObjectiveBegan;
            LdxObjective.OnAnyObjectiveComplete -= HandleLdxObjectiveCompleted;
            ObjectiveSystem.Instance.OnAnyObjectiveBegin -= HandleObjectiveBegan;
            ObjectiveSystem.Instance.OnAnyObjectiveComplete -= HandleObjectiveCompleted;
        }

        private void Update()
        {
            foreach (BaseMetricTracker tracker in activeTrackers)
            {
                tracker.Tick();
            }
        }

        private void ProcessObjectiveBegan(string id)
        {
            if (!objectiveIdToConfigMap.TryGetValue(id, out AnalyticsContainer container))
            {
                return;
            }

            List<BaseMetricTracker> trackers = new List<BaseMetricTracker>();
            foreach (BaseMetricConfig config in container)
            {
                BaseMetricTracker tracker = config.GetNewTracker();
                activeTrackers.Add(tracker);
                trackers.Add(tracker);
            }

            objectiveIdToTrackerMap[id] = trackers;
        }

        private void ProcessObjectiveCompleted(string id)
        {
            if (!objectiveIdToTrackerMap.TryGetValue(id, out List<BaseMetricTracker> trackers))
            {
                return;
            }

            foreach (BaseMetricTracker tracker in trackers)
            {
                entriesContainer.Add(tracker.GetResult());
                LogContainer();
                tracker.Terminate();
                activeTrackers.Remove(tracker);
            }

            objectiveIdToTrackerMap.Remove(id);
        }

        private void LogContainer()
        {
            JsonSerializerSettings settings = new JsonSerializerSettings
            {
                Formatting = Formatting.Indented, // For pretty-printing
            };

            Debug.Log(JsonConvert.SerializeObject(entriesContainer, settings));
        }
        
        private void HandleLdxObjectiveBegan(LdxObjective objective)
        {
            ProcessObjectiveBegan(objective.ObjectiveID);
        }
        
        private void HandleObjectiveBegan(ObjectiveSystem objectiveSystem, Objective objective)
        {
            ProcessObjectiveBegan(objective.ObjectiveID);
        }
        
        private void HandleLdxObjectiveCompleted(LdxObjective objective)
        {
            ProcessObjectiveCompleted(objective.ObjectiveID);
        }
        
        private void HandleObjectiveCompleted(ObjectiveSystem objectiveSystem, Objective objective)
        {
            ProcessObjectiveCompleted(objective.ObjectiveID);
        }
        
        
        private void HandleScenarioStarted(ScenarioManager mgr, ScenarioDataType dataType)
        {
            activeTrackers.Clear();
            objectiveIdToConfigMap.Clear();
            objectiveIdToTrackerMap.Clear();
            currentScenarioId = mgr.LoadedScenarioData.ScenarioID;
            if (String.IsNullOrEmpty(currentScenarioId))
            {
                return;
            }
            ScenarioMetrics metrics = Config.ScenarioMetrics.FirstOrDefault(s => s.ScenarioID == currentScenarioId);
            if (metrics == null)
            {
                return;
            }

            foreach (ObjectiveMetrics objectiveAnalytics in metrics.ObjectiveMetrics)
            {
                objectiveIdToConfigMap.Add(objectiveAnalytics.ObjectiveID, objectiveAnalytics.Analytics);
            }
        }

        private void HandleScenarioCompleted(ScenarioManager mgr, ScenarioResultType resultType, IScenarioCompletionResult result)
        {
        }
    }
}
# --- end Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Core/AnalyticsController.cs

# FILE: Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Core/ObjectiveMetrics.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b4dc1a3f90f44772a5d150e707d9c023
# ASMDEF: ldx.analytics.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.AddOns.Analytics.Attributes;
using Ldx.Framework.AddOns.Analytics.Config;
using Ldx.Framework.Systems.Objectives;
using Newtonsoft.Json;
using UnityEngine;

namespace Ldx.Framework.AddOns.Analytics.Core
{
    /// <summary>
    /// Configurations of objective-related metrics
    /// </summary>
    [Serializable]
    public class ObjectiveMetrics
    {
        [ObjectiveIDSelection(LdxIdSettings.IdType.Objective, "scenarioId")]
        [SerializeField]
        private string objectiveId;
        [JsonProperty("objectiveId")]
        public string ObjectiveID => objectiveId;

        [MetricConfigContainer]
        [SerializeField]
        private AnalyticsContainer analytics;
        [JsonIgnore]
        public AnalyticsContainer Analytics => analytics;

        [JsonProperty("metrics")]
        public List<string> SerializedMetricConfigs => Analytics.Select(config => config.SerializationKeyName).ToList();
    }
    
    [Serializable]
    public class AnalyticsContainer : IEnumerable<BaseMetricConfig>
    {
        [SerializeReference]
        private List<BaseMetricConfig> analyticsConfigs;

        public IEnumerator<BaseMetricConfig> GetEnumerator()
        {
            return analyticsConfigs.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
}
# --- end Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Core/ObjectiveMetrics.cs

# FILE: Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Core/ProjectIDMap.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 20040b75110644f3bac8584c498e9d7a
# ASMDEF: ldx.analytics.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.Objectives;
using Newtonsoft.Json;

namespace Ldx.Framework.AddOns.Analytics.Core
{
    /// <summary>
    /// A map representing all the stored IDs in the project
    /// </summary>
    public class ProjectIDMap
    {
        public class IDMapItem
        {
            [JsonProperty("id")]
            public string ID { get; }
            [JsonProperty("name")]
            public string Name { get; }
            
            public IDMapItem(string id, string name)
            {
                ID = id;
                Name = name;
            }
        }

        [JsonProperty("scenarios")]
        public List<IDMapItem> ScenarioIDMap { get; }
        [JsonProperty("objectives")]
        public List<IDMapItem> ObjectiveIDMap { get; }

        public ProjectIDMap(List<IDMapItem> scenarios, List<IDMapItem> objectives)
        {
            ScenarioIDMap = scenarios;
            ObjectiveIDMap = objectives;
        }

        public static ProjectIDMap GetProjectIDMap()
        {
            return new ProjectIDMap(GetIDMap(LdxIdSettings.IdType.Scenario), GetIDMap(LdxIdSettings.IdType.Objective));
        }
        
        public static List<IDMapItem> GetIDMap(LdxIdSettings.IdType type)
        {
            List<IDMapItem> result = new List<IDMapItem>();
            List<LdxIdSettings> allIdSettings = LdxIdSettings.GetAllIDSettings();
            List<IDInfoContainer> allIdInfoContainers =
                allIdSettings.Select(s => LdxIdSettings.GetIDListForSettings(s, type)).ToList();
            foreach (IDInfoContainer container in allIdInfoContainers)
            {
                foreach (IDInfo info in container)
                {
                    result.Add(new IDMapItem(info.ID, info.Description));
                }
            }

            return result;
        }
    }
}
# --- end Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Core/ProjectIDMap.cs

# FILE: Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Core/ScenarioMetrics.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a68b48f117f54ce7a28275bc4b87fc09
# ASMDEF: ldx.analytics.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Utilities.Attributes;
using Newtonsoft.Json;
using UnityEngine;

namespace Ldx.Framework.AddOns.Analytics.Core
{
    /// <summary>
    /// Configurations of scenario-related metrics
    /// </summary>
    [Serializable]
    public class ScenarioMetrics
    {
        [IDSelection(LdxIdSettings.IdType.Scenario)]
        [SerializeField]
        private string scenarioId;
        [JsonProperty("scenarioId")]
        public string ScenarioID => scenarioId;

        [SerializeField]
        private List<ObjectiveMetrics> objectiveMetrics = new();
        [JsonProperty("objectiveMetrics")]
        public List<ObjectiveMetrics> ObjectiveMetrics => objectiveMetrics;
    }
}
# --- end Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Core/ScenarioMetrics.cs

# FILE: Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Entries/BaseMetricEntry.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ec9efd5d378c45d68a8f1c36cfcb7df8
# ASMDEF: ldx.analytics.runtime.dll
# ---
using System.Collections;
using System.Collections.Generic;
using Ldx.Framework.AddOns.Analytics.Config;
using Newtonsoft.Json;

namespace Ldx.Framework.AddOns.Analytics.Entries
{
    /// <summary>
    /// The entry recorded by the tracker
    /// </summary>
    public abstract class BaseMetricEntry
    {
        [JsonProperty("config")]
        public abstract string ConfigName { get; } 
    }

    public abstract class BaseMetricEntry<TConfig, TValue> : BaseMetricEntry
    where TConfig : BaseMetricConfig
    {
        [JsonProperty("config", Order = 1)] 
        public override string ConfigName => Config.SerializationKeyName;
        public abstract TValue Value { get; set; }
        [JsonIgnore]
        public TConfig Config;

        public BaseMetricEntry(TValue value, TConfig config)
        {
            Value = value;
            Config = config;
        }
    }

    public class TrackingEntriesContainer : IEnumerable<BaseMetricEntry>
    {
        private List<BaseMetricEntry> entries = new();

        public void Add(BaseMetricEntry entry)
        {
            entries.Add(entry);
        }

        public void Clear()
        {
            entries.Clear();
        }
        
        public IEnumerator<BaseMetricEntry> GetEnumerator()
        {
            return entries.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
}
# --- end Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Entries/BaseMetricEntry.cs

# FILE: Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Entries/TimeMetricEntry.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8c491e87ec3c409b9e16a32ec3035e42
# ASMDEF: ldx.analytics.runtime.dll
# ---
using Ldx.Framework.AddOns.Analytics.Config;
using Newtonsoft.Json;

namespace Ldx.Framework.AddOns.Analytics.Entries
{
    public class TimeMetricEntry : BaseMetricEntry<TimeMetricConfig, float>
    {
        [JsonProperty("recordedTime")]
        public override float Value { get; set; }

        public TimeMetricEntry(float value, TimeMetricConfig config) : base(value, config)
        {
        }
    }
}
# --- end Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Entries/TimeMetricEntry.cs

# FILE: Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Trackers/BaseMetricTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e496f3c64e12490e976fd7d0e1c07dad
# ASMDEF: ldx.analytics.runtime.dll
# ---
using Ldx.Framework.AddOns.Analytics.Config;
using Ldx.Framework.AddOns.Analytics.Entries;
using Newtonsoft.Json;

namespace Ldx.Framework.AddOns.Analytics.Trackers
{
    public abstract class BaseMetricTracker
    {
        public abstract BaseMetricEntry GetResult();

        public virtual void Tick(){}
        public virtual void Terminate(){}
    }

    public abstract class BaseMetricTracker<TEntry, TConfig> : BaseMetricTracker
        where TEntry : BaseMetricEntry
        where TConfig : BaseMetricConfig
    {
        protected TConfig Config { get; }
        
        public BaseMetricTracker(TConfig config)
        {
            Config = config;
        }

        [JsonProperty("value")]
        public abstract TEntry ValueEntry { get; set; }
    }
    
}
# --- end Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Trackers/BaseMetricTracker.cs

# FILE: Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Trackers/TimeMetricTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4fac5193c27b4816ad0e9a06a04241f6
# ASMDEF: ldx.analytics.runtime.dll
# ---
using Ldx.Framework.AddOns.Analytics.Config;
using Ldx.Framework.AddOns.Analytics.Entries;
using UnityEngine;

namespace Ldx.Framework.AddOns.Analytics.Trackers
{
    public class TimeMetricTracker : BaseMetricTracker<TimeMetricEntry, TimeMetricConfig>
    {
        private float elapsedTime;
        
        public override TimeMetricEntry ValueEntry { get; set; }

        public TimeMetricTracker(TimeMetricConfig config) : base(config)
        {
            elapsedTime = 0.0f;
        }
        
        public override void Tick()
        {
            elapsedTime += Time.deltaTime;
        }

        public override BaseMetricEntry GetResult()
        {
            ValueEntry = new TimeMetricEntry(elapsedTime, Config);
            return ValueEntry;
        }
    }
}
# --- end Packages/com_ldx_framework/AddOns/Analytics/Runtime/Scripts/Trackers/TimeMetricTracker.cs

# FILE: Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Data/ControllerFreeAddOnConfig.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4469401cddaa47edb5406b15f40705bb
# ASMDEF: ldx.controllerfree.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.AddOns;
using UnityEngine;

namespace Ldx.Framework.AddOns.ControllerFree.Data
{
    /// <summary>
    /// Config in GlobalData for Controller Free settings
    /// </summary>
    [Serializable]
    public class ControllerFreeAddOnConfig : AddOnConfig
    {
        [SerializeField] private bool enableHandTracking = true;
        public bool EnableHandTracking => enableHandTracking;
    }
}
# --- end Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Data/ControllerFreeAddOnConfig.cs

# FILE: Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Data/GesturesExtensionIDDefinition.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4f0a985d5b9a4c1692a6104af687683f
# ASMDEF: ldx.controllerfree.runtime.dll
# ---
using Ldx.Framework.Systems.Objectives.ID;

namespace Ldx.Framework.AddOns.ControllerFree.Data
{
    /// <summary>
    /// This definition will add a Gestures tab to ID settings 
    /// </summary>
    public class GesturesExtensionIDDefinition : ExtensionIDDefinition<GesturesExtensionIDDefinition>
    {
        public override string DisplayName => "Gestures";
    }
}
# --- end Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Data/GesturesExtensionIDDefinition.cs

# FILE: Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Features/Machinery/GestureMachineryInputModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cabe5eefe928411ea6e81420096739bb
# ASMDEF: ldx.controllerfree.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using AddOns.ControllerFree.Systems.Gestures;
using Ldx.Framework.AddOns.ControllerFree.Data;
using Ldx.Framework.Features.Machinery;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;

namespace AddOns.ControllerFree.Features.Machinery
{
    /// <summary>
    /// A <see cref="MachineryInputModuleBase"/> implementation that translates specific hand gestures into machinery operation commands.
    /// This module listens to global gesture events and maps them to machinery operations like 'Move' or 'Rotate'.
    /// It features a "latching" mode where an operation, once started, will continue until a 'Stop' gesture is performed
    /// or another operation's gesture is initiated, ensuring only one action is active at a time.
    /// </summary>
    [CreateAssetMenu(menuName = "Idealogical/Machinery Input Module/Gesture", fileName = "GestureMachineryInputModule")]
    public class GestureMachineryInputModule : MachineryInputModuleBase
    {
        /// <summary>
        /// Defines the directional key bindings for a single machinery operation.
        /// </summary>
        [Serializable]
        public class OperationInput
        {
            /// <summary>
            /// Represents a single mapping between a gesture ID and an input direction for an operation.
            /// </summary>
            [Serializable]
            public class InputDirectionGesture
            {
                public OperationInputDirection inputDirection;
                [IDSelection(typeof(GesturesExtensionIDDefinition))] 
                public string gestureID;
                [Tooltip("If true, this gesture stops all other operations. If false, it can run alongside others.")]
                public bool isExclusive = true; 
            }
            
            public List<InputDirectionGesture> inputDirectionMap = new();
        }
        
        [SerializeField]
        private SerializableDictionary<OperationType, OperationInput> operationInputsMap = new();
        public SerializableDictionary<OperationType, OperationInput> OperationInputsMap => operationInputsMap;

        [SerializeField] private bool onlyChangeInputOnStopGesture = true;
        
        /// <summary>
        /// Used only for debug visualization in the inspector.
        /// Shows the last resolved input direction for each operation.
        /// </summary>
        [SerializeField] [ReadOnly]
        private SerializableDictionary<OperationType, OperationInputDirection> lastInputStateMap = new();
        public SerializableDictionary<OperationType, OperationInputDirection> LastInputStateMap => lastInputStateMap;

        private bool onlyChangeOnStop;
        private bool hasStopGesture;
        private List<OperationInput.InputDirectionGesture> stopGestures = new();
        private string activeGestureID;

        /// <summary>
        /// Initializes the module. Caches stop gesture configurations and subscribes to gesture system events.
        /// This method should be called once before the module is used.
        /// </summary>
        public override void Initialize()
        {
            base.Initialize();
            stopGestures = operationInputsMap.TryGetValue(OperationType.Stop, out OperationInput stopOperationInput) ? 
                stopOperationInput.inputDirectionMap : new List<OperationInput.InputDirectionGesture>();
            
            hasStopGesture = stopGestures.Count > 0;
            onlyChangeOnStop = onlyChangeInputOnStopGesture && hasStopGesture;

            lastInputStateMap.Clear();
            foreach (KeyValuePair<OperationType,OperationInput> operationInput in operationInputsMap)
            {
                lastInputStateMap.Add(operationInput.Key, OperationInputDirection.None);
            }

            GestureHandler.OnGestureStarted += HandleGestureStarted;
            GestureHandler.OnGestureEnded += HandleGestureEnded;
        }

        /// <summary>
        /// Cleans up the module. Unsubscribes from gesture system events to prevent memory leaks.
        /// This method should be called when the module is no longer needed.
        /// </summary>
        public override void OnDestroy()
        {
            base.OnDestroy();
            GestureHandler.OnGestureStarted -= HandleGestureStarted;
            GestureHandler.OnGestureEnded -= HandleGestureEnded;
        }

        /// <summary>
        /// Handles the <see cref="GestureHandler.OnGestureStarted"/> event.
        /// Records the ID of the currently active gesture.
        /// </summary>
        /// <param name="gestureID">The ID of the gesture that has started.</param>
        private void HandleGestureStarted(string gestureID)
        {
            activeGestureID = gestureID;
        }
        
        /// <summary>
        /// Handles the <see cref="GestureHandler.OnGestureEnded"/> event.
        /// Clears the active gesture ID if it matches the one that just ended.
        /// </summary>
        /// <param name="gestureID">The ID of the gesture that has ended.</param>
        private void HandleGestureEnded(string gestureID)
        {
            if (activeGestureID == gestureID)
            {
                activeGestureID = null;
            }
        }

        /// <summary>
        /// Called by the <see cref="BaseMachineryController"/> every update cycle to determine the current input state.
        /// This method implements the core logic: it checks for stop gestures, resolves the currently active gesture to a
        /// specific operation, and updates the state of all operations accordingly. If a new gesture command is given,
        /// it will override and stop any previously latched operation.
        /// </summary>
        /// <param name="currentInputState">
        /// A reference to the dictionary that will be populated with the calculated input state for each operation.
        /// </param>
        public override void ProcessMachineryInputs(ref Dictionary<OperationType, OperationInputDirection> currentInputState)
        {
            if (GestureHandler.IgnoreGestures)
            {
                ForceStopInputs(ref currentInputState);
                return;
            }
            
            // --- Priority 1: Check for an active "Stop" gesture ---
            bool stopGestureIsActive = hasStopGesture && stopGestures.Any(x => x.gestureID == activeGestureID);
            
            if (stopGestureIsActive)
            {
                ForceStopInputs(ref currentInputState);
                return; 
            }
            
            // --- Priority 2: Find which operation is commanded by the current gesture ---
            List<(OperationType opType, OperationInputDirection direction)> commandedOperations = new();
            bool isCurrentGestureExclusive = false;
            
            if (!string.IsNullOrWhiteSpace(activeGestureID))
            {
                // Find the first operation that matches the active gesture
                foreach ((OperationType opType, OperationInput opInput) in operationInputsMap)
                {
                    if (opType == OperationType.Stop) continue;

                    OperationInput.InputDirectionGesture matchedGesture = opInput.inputDirectionMap.FirstOrDefault(g => g.gestureID == activeGestureID);
                    if (matchedGesture != null)
                    {
                        commandedOperations.Add((opType, matchedGesture.inputDirection));
                        if (matchedGesture.isExclusive)
                        {
                            isCurrentGestureExclusive = true;
                        }
                    }
                }
            }
            
            // --- Priority 3: Update all states based on the command found (or not found) ---
            bool isGestureActive = commandedOperations.Count > 0;
            
            // Case A: A new command gesture is active.
            if (isGestureActive && isCurrentGestureExclusive)
            {
                // Case A: An EXCLUSIVE gesture is active. Stop everything not explicitly commanded.
                HashSet<OperationType> commandedTypes = new(commandedOperations.Select(c => c.opType));
                
                foreach (OperationType opType in operationInputsMap.Keys.Where(k => k != OperationType.Stop))
                {
                    if (commandedTypes.Contains(opType))
                    {
                        (OperationType opType, OperationInputDirection direction) command = commandedOperations.First(c => c.opType == opType);
                        lastInputStateMap[opType] = command.direction;
                        currentInputState[opType] = command.direction;
                    }
                    else
                    {
                        lastInputStateMap[opType] = OperationInputDirection.None;
                        currentInputState[opType] = OperationInputDirection.None;
                    }
                }
            }
            // Case B: A NON-EXCLUSIVE gesture is active, OR no gesture is active.
            // We respect the existing latched states and only layer on new commands.
            else 
            {
                // No new command is active, so we rely on the latching or direct behavior.
                foreach (OperationType operationType in operationInputsMap.Keys)
                {
                    if (operationType == OperationType.Stop) continue;

                    if (onlyChangeOnStop)
                    {
                        // LATCHING MODE: Maintain the last known state.
                        currentInputState[operationType] = lastInputStateMap[operationType];
                    }
                    else
                    {
                        // DIRECT MODE: If no gesture is active, everything stops.
                        lastInputStateMap[operationType] = OperationInputDirection.None;
                        currentInputState[operationType] = OperationInputDirection.None;
                    }
                }
                
                if (isGestureActive)
                {
                    foreach ((OperationType opType, OperationInputDirection direction) in commandedOperations)
                    {
                        lastInputStateMap[opType] = direction;
                        currentInputState[opType] = direction;
                    }
                }
            }
        }

        public override void ForceStopInputs(ref Dictionary<OperationType, OperationInputDirection> currentInputState)
        {
            foreach (OperationType operationType in operationInputsMap.Keys)
            {
                if (operationType == OperationType.Stop) continue;
            
                lastInputStateMap[operationType] = OperationInputDirection.None;
                currentInputState[operationType] = OperationInputDirection.None;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Features/Machinery/GestureMachineryInputModule.cs

# FILE: Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/ControllerFreeAddOnModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 53bc012612f74cfe840978608d2838db
# ASMDEF: ldx.controllerfree.runtime.dll
# ---
using AddOns.ControllerFree.Systems.Gestures;
using Ldx.Framework.AddOns.ControllerFree.Data;
using Ldx.Framework.Systems.AddOns;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.ScenarioManagement.Data;

namespace Ldx.Framework.AddOns.ControllerFree.Systems
{
    /// <summary>
    /// Injects the controller-free setup in the rig
    /// </summary>
    public class ControllerFreeAddOnModule : AddOnModule
    {
        public static bool IsInitialized = false;
        
        public override void Setup()
        {
            if (!GlobalData.Instance.AddOnsConfigs.TryGet(out ControllerFreeAddOnConfig config))
            {
                return;
            }

            if (!config.EnableHandTracking)
            {
                return;
            }

            IsInitialized = true;
            PlayerController.Instance.HandsController.SetActiveInputModule<ControllerFreeInputModule>();
        }
    }
}
# --- end Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/ControllerFreeAddOnModule.cs

# FILE: Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/DebugFeature/DebugGestureSystemFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 91be8d7bec7b47e89b2637b39e9fef6d
# ASMDEF: ldx.controllerfree.runtime.dll
# ---
#if LDX_INTERNAL_DEBUG
using System;
using System.Collections.Generic;
using System.Text;
using AddOns.ControllerFree.Systems.Gestures;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Player;
using TMPro;
using UnityEngine;

namespace Ldx.Framework.AddOns.ControllerFree.Systems.DebugFeature
{
    public class DebugGestureSystemFeature : Framework.Systems.InternalDebug.DebugFeature
    {
        private const string FEATURE_NAME = "Debug Gesture System";
        private const float DISPLAY_TIME = 10f; // Gestures are more transient, so a shorter display time is good
        private const int MAX_MESSAGES = 10;
        private const float FONT_SIZE = .3f;

        private readonly Color gestureStartColor = Color.cyan;
        private readonly Color gestureEndColor = Color.yellow;
        private readonly Color defaultColor = Color.white;
        
        private readonly Vector2 tmpSizeDelta = new(2.5f, 1.25f);
        private readonly Vector3 localOffset = new(0, -0.3f, 1.25f);
        
        private GameObject messageRoot;
        private Transform messageParent;
        private TextMeshPro messageText;

        private readonly List<string> activeMessages = new();
        private readonly StringBuilder stringBuilder = new();

        private Camera mainCamera;
        private string cachedDefaultColorHex;
        private string cachedStartColorHex;
        private string cachedEndColorHex;

        public override string DisplayName { get; protected set; } = FEATURE_NAME;

        public override void Initialize()
        {
            base.Initialize();
            cachedDefaultColorHex = ColorUtility.ToHtmlStringRGBA(defaultColor);
            cachedStartColorHex = ColorUtility.ToHtmlStringRGBA(gestureStartColor);
            cachedEndColorHex = ColorUtility.ToHtmlStringRGBA(gestureEndColor);

            UpdateDisplayName();
            CreateMessageRoot().Forget();
        }

        public override void PerformAction()
        {
            base.PerformAction();
            IsActive = !IsActive;
            UpdateDisplayName();
            if (IsActive)
            {
                SubscribeToEvents();
            }
            else
            {
                UnsubscribeFromEvents();
            }
        }

        public override void Terminate()
        {
            base.Terminate();
            UnsubscribeFromEvents();
        }

        public override void Tick()
        {
            base.Tick();
            UpdateRootPosition();
        }

        private void SubscribeToEvents()
        {
            GestureHandler.OnGestureStarted += HandleGestureStarted;
            GestureHandler.OnGestureEnded += HandleGestureEnded;
        }

        private void UnsubscribeFromEvents()
        {
            GestureHandler.OnGestureStarted -= HandleGestureStarted;
            GestureHandler.OnGestureEnded -= HandleGestureEnded;
        }

        private void UpdateDisplayName()
        {
            DisplayName = $"{FEATURE_NAME}: {(IsActive ? "Active" : "Inactive")}";
        }
        
        private void HandleGestureStarted(string gestureID)
        {
            if (!IsActive) return;
            string timecode = DateTime.Now.ToString("HH:mm:ss");
            string message = $"Gesture Started: {gestureID}";
            
            // Using pre-cached hex colors
            string formattedMessage = $"<color=#{cachedDefaultColorHex}>[{timecode}]</color> <color=#{cachedStartColorHex}>{message}</color>";

            AddMessageToList(formattedMessage);
        }

        private void HandleGestureEnded(string gestureID)
        {
            if (!IsActive) return;
            string timecode = DateTime.Now.ToString("HH:mm:ss");
            string message = $"Gesture Ended: {gestureID}";

            // Using pre-cached hex colors
            string formattedMessage = $"<color=#{cachedDefaultColorHex}>[{timecode}]</color> <color=#{cachedEndColorHex}>{message}</color>";

            AddMessageToList(formattedMessage);
        }
        
        private void AddMessageToList(string formattedMessage)
        {
            activeMessages.Add(formattedMessage);

            if (activeMessages.Count > MAX_MESSAGES)
            {
                activeMessages.RemoveAt(0);
            }

            RebuildDisplayText();
            StartRemoveMessageTask().Forget();
        }

        private async UniTaskVoid CreateMessageRoot()
        {
            await UniTask.WaitUntil(() => PlayerController.IsValid);
            mainCamera = PlayerController.Instance.MainCamera;
            messageRoot = new GameObject("GestureSystemDebugMessageRoot");
            UnityEngine.Object.DontDestroyOnLoad(messageRoot);

            messageParent = new GameObject("Messages").transform;
            messageParent.SetParent(messageRoot.transform);
            messageParent.localPosition = localOffset;
            messageParent.localRotation = Quaternion.identity;

            messageText = CreateTextObject();
        }

        private TextMeshPro CreateTextObject()
        {
            GameObject tmpObject = new("DebugMessages");
            TextMeshPro tmp = tmpObject.AddComponent<TextMeshPro>();
            tmp.alignment = TextAlignmentOptions.TopLeft;
            tmp.fontSize = FONT_SIZE;
            tmp.color = defaultColor;
            tmp.textWrappingMode = TextWrappingModes.NoWrap; // Gesture IDs can be long
            tmp.rectTransform.sizeDelta = tmpSizeDelta;
            tmp.raycastTarget = false;
            tmpObject.SetActive(true);
            tmp.transform.SetParent(messageParent, false);
            return tmp;
        }

        private void RebuildDisplayText()
        {
            if (messageText == null) return;
            
            stringBuilder.Clear();
            for (int i = 0; i < activeMessages.Count; i++)
            {
                if (i > 0) stringBuilder.AppendLine();
                stringBuilder.Append(activeMessages[i]);
            }

            messageText.text = stringBuilder.ToString();
        }

        private async UniTaskVoid StartRemoveMessageTask()
        {
            await UniTask.Delay(TimeSpan.FromSeconds(DISPLAY_TIME));
            if (activeMessages.Count > 0)
            {
                activeMessages.RemoveAt(0);
                RebuildDisplayText();
            }
        }

        private void UpdateRootPosition()
        {
            if (mainCamera != null && messageRoot != null)
            {
                messageRoot.transform.position = mainCamera.transform.position;
                messageRoot.transform.rotation = mainCamera.transform.rotation;
            }
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/DebugFeature/DebugGestureSystemFeature.cs

# FILE: Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/Gestures/ControllerFreeInputModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 583b9cb82ed242178f2bec029cc30a90
# ASMDEF: ldx.controllerfree.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Autohand;
using Autohand.Demo;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.Player.Hands;
using Ldx.Framework.Systems.Player.Input;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;

namespace AddOns.ControllerFree.Systems.Gestures
{
    public class ControllerFreeInputModule : Singleton<ControllerFreeInputModule>, IInputModule
    {
        [Serializable]
        public class HandData
        {
            public OpenXRAutoHandTracking openXRAutoHandTracking;
            public OpenXRHandControllerLink handControllerLink;
        }

        [SerializeField]
        private SerializableDictionary<HandSide, HandData> handDatas = new();
        
        [SerializeField]
        private SerializableDictionary<HandSide, OpenXRAutoHandTracking> handSideToOpenXRTracking = new();
        public SerializableDictionary<HandSide, OpenXRAutoHandTracking> HandSideToOpenXRTracking => handSideToOpenXRTracking;

        private readonly Dictionary<HandSide, bool> wasHandTracked = new();
        
        public bool TryGetTrackingBySide(HandSide side, out OpenXRAutoHandTracking tracking)
        {
            if (handSideToOpenXRTracking.TryGetValue(side, out tracking))
            {
                return true;
            }

            return false;
        }

        public void Initialize(SerializableDictionary<HandSide, HandsController.HandReferences> hands)
        {
            foreach ((HandSide side, HandData data) in handDatas)
            {
                if (hands.TryGetValue(side, out HandsController.HandReferences handReference))
                {
                    data.openXRAutoHandTracking.hand = handReference.hand;
                    data.handControllerLink.hand = handReference.hand;
                }
                
                wasHandTracked[side] = true;
            }
        }
        
        private void LateUpdate()
        {
            foreach ((HandSide side, HandData data) in handDatas)
            {
                if(data.openXRAutoHandTracking.hand != null && wasHandTracked.ContainsKey(side))
                {
                    ProcessHandState(side, data);
                }
            }
        }
        
        private void ProcessHandState(HandSide side, HandData data)
        {
            bool isTrackedNow = data.openXRAutoHandTracking.handTrackingActive;
            bool wasTracked = wasHandTracked[side];
            
            switch (wasTracked)
            {
                case true when !isTrackedNow:
                    PlayerController.Instance.HandsController.EnableHandRenderer(side, false);
                    break;
                case false when isTrackedNow:
                    PlayerController.Instance.HandsController.EnableHandRenderer(side, true);
                    break;
            }
            
            wasHandTracked[side] = isTrackedNow;
        }

    }
}
# --- end Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/Gestures/ControllerFreeInputModule.cs

# FILE: Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/Gestures/GestureConfig.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4f6834b286a8499aa256edc7e7cc6ed7
# ASMDEF: ldx.controllerfree.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Autohand;
using Ldx.Framework.AddOns.ControllerFree.Data;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Player.Hands;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;
using Utilities.Serializable;

namespace AddOns.ControllerFree.Systems.Gestures
{
    [Serializable]
    public class GestureConfig
    {
        [Header("Identification")]
        [IDSelection(typeof(GesturesExtensionIDDefinition))]
        [Tooltip("Unique identifier used to reference this gesture configuration from other systems.")]
        public string ID;

        [LocalizationKey] public string Name;

        [Header("Primary Gesture")]
        [Tooltip("Primary gesture(s) to detect. Map each hand side to its corresponding gesture event.")]
        public SerializableDictionary<HandSide, HandGestureEvent> primaryGestures = new();

        [Tooltip("If enabled, the primary gesture must be satisfied for both hands to be considered active.")]
        public bool requiresBothHands;

        [Header("Secondary Gesture (Optional)")]
        [Tooltip("Optional follow-up gesture(s) that can keep the gesture active (eg. Animated gestures like Boom Up/ Load Down).")]
        public SerializableDictionary<HandSide, HandGestureEvent> secondaryGestures = new();

        [Tooltip("Time window (in seconds) where none or the secondary gesture can be active in order for the gesture to stay active.")]
        [Min(0f)]
        public float secondaryGestureTimeout;

        [Header("Debug")]
        [SerializeField, Tooltip("When enabled, prints diagnostic information about gesture state changes to the console.")]
        private bool showDebugLogs = false;
        
        public bool IsActive { get; private set; }
        public float SecondaryGestureTime { get; set; }
        public string GestureName { get; private set; }
        public bool IsLoading { get; private set; } = false;
        public float LoadingStartTime { get; set; }
        public float LoadingDuration { get; set; }

        public void Initialize(OpenXRAutoHandTracking left, OpenXRAutoHandTracking right)
        {
            AssignTracking(primaryGestures, left, right);
            AssignTracking(secondaryGestures, left, right);
            GestureName = GetGestureName();
        }

        private string GetGestureName()
        {
            string localizedName = LocalizationModel.GetTextString(Name);
            if (localizedName != Name)
            {
                return Name;
            }
            
            if (LdxIdSettings.TryGetIDDescription(ID, GesturesExtensionIDDefinition.GetIdTypeWrapper(), out string description))
            {
                return description;
            }

            return primaryGestures.FirstOrDefault(x => !string.IsNullOrEmpty(x.Value.poseName)).Value.poseName;
        }
            
        private void AssignTracking(SerializableDictionary<HandSide, HandGestureEvent> gestures, 
            OpenXRAutoHandTracking left, OpenXRAutoHandTracking right)
        {
            if (gestures == null) return;
                
            foreach ((HandSide handSide, HandGestureEvent gestureEvent) in gestures)
            {
                if (gestureEvent == null)
                {
                    continue;
                }
                    
                OpenXRAutoHandTracking tracking = handSide == HandSide.Left ? left : right;
                if (tracking != null && !gestureEvent.trackingHands.Contains(tracking))
                {
                    gestureEvent.trackingHands.Add(tracking);
                }
            }
        }
            
        public bool IsPrimaryGestureActive(List<Hand> availableHands)
        {
            return IsGestureActive(availableHands, primaryGestures);
        }
            
        public bool IsSecondaryGestureActive(List<Hand> availableHands)
        {
            return IsGestureActive(availableHands, secondaryGestures);
        }
            
        private bool IsGestureActive(List<Hand> availableHands, SerializableDictionary<HandSide, HandGestureEvent> gestures)
        {
            if (gestures == null || gestures.Count == 0) return false;

            if (requiresBothHands)
            {
                if (availableHands.Count < 2) return false;
                    
                Hand leftHand = availableHands.FirstOrDefault(h => h.left);
                Hand rightHand = availableHands.FirstOrDefault(h => !h.left);

                if (leftHand == null || rightHand == null)
                {
                    return false;
                }
                    
                return gestures.TryGetValue(HandSide.Left, out HandGestureEvent leftGesture) && leftGesture != null && IsGestureActivated(leftGesture, leftHand) &&
                       gestures.TryGetValue(HandSide.Right, out HandGestureEvent rightGesture) && rightGesture != null && IsGestureActivated(rightGesture, rightHand);
            }

            foreach (HandGestureEvent gestureEvent in gestures.Values)
            {
                if (availableHands.Any(x => IsGestureActivated(gestureEvent, x)))
                {
                    return true;
                }
            }

            return false;
        }
        
        public bool IsGestureActivated(HandGestureEvent gestureEvent, Hand hand)
        {
            HandPoseGestureData data = gestureEvent.GetCurrentGestureData(hand);
            return data is { currentActivatedPoseState: true };
        }

        public void SetActive(bool state)
        {
            IsActive = state;
        }

        public bool IsDoneLoading()
        {
            return IsLoading && Time.time - LoadingStartTime > LoadingDuration;
        }

        public void ResetLoadingState()
        {
            IsLoading = false;
            IsActive = false;
            SecondaryGestureTime = 0;
        }

        public bool UpdateAndCheckGestureLoading(List<Hand> availableHands, bool allowNewLoading = true)
        {
            if (primaryGestures == null || primaryGestures.Count == 0)
                return false;

            SetActive(IsDoneLoading());

            bool anyPrimaryActive = false;
            bool allPrimaryActive = true;
            float maxPrimaryHoldTime = 0f;

            // Evaluate primary gestures
            foreach (HandGestureEvent gestureEvent in primaryGestures.Values)
            {
                bool active = IsGestureActiveOnAnyAvailableHand(gestureEvent, availableHands);
                if (active)
                {
                    anyPrimaryActive = true;
                    if (gestureEvent.requiredPoseHoldActivationTime > maxPrimaryHoldTime)
                        maxPrimaryHoldTime = gestureEvent.requiredPoseHoldActivationTime;
                }
                else
                {
                    allPrimaryActive = false;
                }
            }

            // Refresh secondary window when any primary gesture is active
            if (anyPrimaryActive)
                SecondaryGestureTime = Time.time + secondaryGestureTimeout;

            // Evaluate secondary gestures only if no primary is currently active
            bool hasSecondary = secondaryGestures != null && secondaryGestures.Count > 0;
            bool anySecondaryActive = false;
            if (!anyPrimaryActive && hasSecondary && Time.time < SecondaryGestureTime)
            {
                foreach (HandGestureEvent gestureEvent in secondaryGestures.Values)
                {
                    if (IsGestureActiveOnAnyAvailableHand(gestureEvent, availableHands))
                    {
                        anySecondaryActive = true;
                        break;
                    }
                }
            }

            bool anyGestureActive = anyPrimaryActive || anySecondaryActive;
            bool withinSecondaryWindow = hasSecondary && Time.time <= SecondaryGestureTime;

            bool canLoad = allowNewLoading &&
                           (allPrimaryActive ||
                            (!requiresBothHands && anyGestureActive) ||
                            withinSecondaryWindow);

            if (canLoad)
            {
                if (!IsLoading)
                {
                    LoadingStartTime = Time.time;
                    LoadingDuration = maxPrimaryHoldTime;
                }

                IsLoading = true;
                if (showDebugLogs)
                    Debug.Log($"[GestureConfig] {GestureName} is loading");

                if (Time.time - LoadingStartTime > 0.1f)
                    return true;
            }
            else
            {
                if (showDebugLogs)
                    Debug.Log($"[GestureConfig] {GestureName} is NOT loading anymore");

                IsLoading = false;
            }

            return false;
        }
        
        // Checks if this gesture event is active on any available hand 
        private bool IsGestureActiveOnAnyAvailableHand(HandGestureEvent gestureEvent, List<Hand> hands)
        {
            foreach (OpenXRAutoHandTracking tracking in gestureEvent.trackingHands)
            {
                Hand hand = tracking.hand;
                if (!hands.Contains(hand))
                    continue;

                if (gestureEvent.IsGestureActive(hand))
                    return true;
            }
            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/Gestures/GestureConfig.cs

# FILE: Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/Gestures/GestureDetectionZone.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d23fab4130889f2428778547258c899e
# ASMDEF: ldx.controllerfree.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Autohand;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using Utilities.Blockers;

namespace AddOns.ControllerFree.Systems.Gestures
{
    [RequireComponent(typeof(HandTriggerAreaEvents))]
    public class GestureDetectionZone : MonoBehaviour
    {
        public event Action<GestureDetectionZone, Hand> OnHandEntered;
        public event Action<GestureDetectionZone, Hand> OnHandExited;
        
        [Space]
        [Header("References")]
        [SerializeField] private HandTriggerAreaEvents handTrigger;
        [SerializeField] private Collider triggerCollider;
        
        [Space]
        [Header("Debug")]
        [SerializeField] private bool enableDebugLogs;
        [SerializeField] [ReadOnly] private List<Hand> handsInsideTheZone = new();
        
        private readonly List<OpenXRAutoHandTracking> handTrackings = new();
        private CancellationTokenSource cancellationTokenSource;
        
        [Header("Blockers")] 
        [SerializeField]
        [ReadOnly]
         private List<MonoBehaviour> blockers = new List<MonoBehaviour>();
         private List<IBlocker> blockersList = new List<IBlocker>();

        private void OnValidate()
        {
            if (handTrigger == null)
            {
                handTrigger = GetComponent<HandTriggerAreaEvents>();
            }
            
            if (triggerCollider == null)
            {
                triggerCollider = GetComponent<Collider>();
            }
            
            blockers = GetComponents<IBlocker>()
                .Cast<MonoBehaviour>() // must cast back to MonoBehaviour for serialization
                .ToList();
        }

        private void Awake()
        {
            blockersList.Clear();
            blockersList.AddRange(blockers.Cast<IBlocker>());
            foreach (IBlocker blocker in blockersList)
            {
                blocker.OnBlockChanged += HandleBlockerChanged;
            }
        }

        private void Start()
        {
            handTrackings.Clear();
            handTrackings.AddRange(ControllerFreeInputModule.Instance.HandSideToOpenXRTracking.Values);
            handTrigger.HandEnter.AddListener(HandleHandEntered);
            handTrigger.HandExit.AddListener(HandleHandExited);
        }
        
        private void OnDestroy()
        {
            handTrigger.HandEnter.RemoveListener(HandleHandEntered);
            handTrigger.HandExit.RemoveListener(HandleHandExited);
            foreach (IBlocker blocker in blockersList)
            {
                blocker.OnBlockChanged -= HandleBlockerChanged;
            }
        }

        private void Update()
        {
            if (triggerCollider == null || !triggerCollider.enabled)
            {
                return;
            }
            
            foreach(OpenXRAutoHandTracking tracking in handTrackings)
            {
                if (tracking.hand == null) continue;
                
                Hand hand = tracking.hand;
                bool isCurrentlyInZone = handsInsideTheZone.Contains(hand);
                bool isPhysicallyInside = triggerCollider.bounds.Contains(hand.palmTransform.position);
                bool shouldBeInZone = tracking.handTrackingActive && isPhysicallyInside;
                
                if (shouldBeInZone && !isCurrentlyInZone)
                {
                    // The hand entered the zone without a trigger event, or regained tracking inside.
                    LogIfEnabled($"<color=cyan>[GestureZone '{name}']</color> <color=green>Update</color> detected <color=white>{hand.name}</color> should be inside. Adding.");
                    AddHand(hand);
                }
                else if (!shouldBeInZone && isCurrentlyInZone)
                {
                    // The hand left the zone without a trigger event, or lost tracking.
                    LogIfEnabled(!tracking.handTrackingActive
                        ? $"<color=orange>[GestureZone '{name}']</color> Hand tracking for {hand.name} became inactive. Forcibly removing from zone."
                        : $"<color=cyan>[GestureZone '{name}']</color> <color=green>Update</color> detected <color=white>{hand.name}</color> should be outside. Removing.");
                    RemoveHand(hand);
                }
            }
        }

        private void SetActive(bool isActive)
        {
            if(gameObject.activeSelf == isActive) return;
            
            if (isActive)
            {
                LogIfEnabled($"<color=lime>[GestureZone '{name}']</color> Activating GameObject.");
            }
            else
            {
                LogIfEnabled($"<color=orange>[GestureZone '{name}']</color> Deactivating GameObject.");
                foreach (Hand hand in handsInsideTheZone.ToList())
                {
                    RemoveHand(hand);
                }
            }
            
            gameObject.SetActive(isActive);
        }
        
        private void HandleHandEntered(Hand hand)
        {
            LogIfEnabled($"<color=cyan>[GestureZone '{name}']</color> <color=yellow>HandTriggerAreaEvents</color> detected <color=white>{hand.name}</color> entered the trigger.");
            AddHand(hand);
        }

        private void HandleHandExited(Hand hand)
        {
            LogIfEnabled($"<color=cyan>[GestureZone '{name}']</color> <color=yellow>HandTriggerAreaEvents</color> detected <color=white>{hand.name}</color> exited the trigger.");
            RemoveHand(hand);
        }

        private void AddHand(Hand hand)
        {
            if (handsInsideTheZone.Contains(hand))
            {
                LogIfEnabled($"<color=grey>[GestureZone '{name}']</color> Hand <color=white>{hand.name}</color> is already in the zone. Ignoring AddHand call.");
                return;
            }
            
            LogIfEnabled($"<color=lime>[GestureZone '{name}']</color> Adding <color=white>{hand.name}</color> to the list of hands inside.");
            handsInsideTheZone.Add(hand);
            OnHandEntered?.Invoke(this, hand);
        }

        private void RemoveHand(Hand hand)
        {
            if (handsInsideTheZone.Contains(hand))
            {
                LogIfEnabled($"<color=orange>[GestureZone '{name}']</color> Removing <color=white>{hand.name}</color> from the list of hands inside.");
                handsInsideTheZone.Remove(hand);
                OnHandExited?.Invoke(this, hand);
            }
        }

        private void HandleBlockerChanged(IBlocker blocker, bool state)
        {
            if (state || blockersList.Any(x => x.IsBlocked))
            {
                SetActive(false);
            }
            else
            {
                SetActive(true);
            }
        }
        
        /// <summary>
        /// A helper method to log messages only when debugging is enabled.
        /// </summary>
        /// <param name="message">The message object to log.</param>
        private void LogIfEnabled(object message)
        {
            if (!enableDebugLogs) return;
            
            Debug.Log(message);
        }
    }
}
# --- end Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/Gestures/GestureDetectionZone.cs

# FILE: Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/Gestures/GestureHandler.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 09cf3079029331b4fbf56d99ec50cecd
# ASMDEF: ldx.controllerfree.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Autohand;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.Player.Hands;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using Systems.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;
using Utilities.Blockers;

namespace AddOns.ControllerFree.Systems.Gestures
{
    /// <summary>
    /// Main per-frame loop:
    /// 1) Early-out if gestures are currently ignored (teleport/cooldown) or if no relevant hands are in zones
    /// 2) Evaluate gesture configurations to determine loading/active states
    /// 3) Update progress UI and active-gesture text; optionally keep last gesture visible if configured
    /// </summary>
    public class GestureHandler : MonoBehaviour
    {
        public static event Action<string> OnGestureStarted;
        public static event Action<string> OnGestureEnded;
        public static event Action<string> OnNewGestureConfirmed; // Gesture ID

        public static bool IgnoreGestures;
        private static GestureConfig activeGestureConfig;

        [SerializeField, Tooltip("Configured gestures to track and evaluate. Priority is determined by the order in the array.")]
        private GestureConfig[] gestureConfigs;

        [LocalizationKey] [SerializeField] private string noGestureTextKey;
        [ShowIf(nameof(useLineOfSight), MultiOp.Equals, true)]
        [LocalizationKey] [SerializeField] private string cantSeeOperatorTextKey;

        [Header("Optional")]
        [SerializeField, Tooltip("Optional zones that gate detection; gestures are processed only when a hand is inside one of these zones.")]
        private GestureDetectionZone[] detectionZones;

        [SerializeField, Tooltip("UI Image used as a radial progress indicator for gesture loading.")]
        private Image progressCircle;

        [SerializeField, Tooltip("Maps normalized loading progress (01) to the progress circle fill amount.")]
        private AnimationCurve circleFillCurve;

        [SerializeField, Tooltip("Text element that displays the currently active gesture name.")]
        private LocalizedTextUGUI activeGestureDisplayText;

        [Tooltip("When enabled, keeps the most recently recognized gesture active/visible until the gesture system is " +
                 "explicitly stopped. Disable to clear the gesture when no current gesture is detected.")]
        [SerializeField] private bool showLastGestureIfNotStopped;

        [Space]
        [Header("Audio")]
        [SerializeField] [SoundReference] private string handEnterSound;
        [SerializeField] [SoundReference] private string handExitSound;
        [SerializeField] [SoundReference] private string gestureRecognizedStartSound;
        [SerializeField] [SoundReference] private string gestureRecognizedSound;

        [Space] 
        [Header("Line of Sight Settings")]
        [SerializeField] private bool useLineOfSight;
        [ShowIf(nameof(useLineOfSight), MultiOp.Equals, true)]
        [SoundReference]
        [SerializeField] private string lineOfSightLostSound; // Moved down because it's logically in this section
        [ShowIf(nameof(useLineOfSight), MultiOp.Equals, true)]
        [SerializeField] private Transform lineOfSightOrigin; // Transform of gesture detection zone or alternate origin
        [ShowIf(nameof(useLineOfSight), MultiOp.Equals, true)]
        [SerializeField] private LayerMask lineOfSightIgnoredLayers; // Layers to ignore (checked = won't block)
        [ShowIf(nameof(useLineOfSight), MultiOp.Equals, true)]
        [SerializeField] private QueryTriggerInteraction lineOfSightTriggerInteraction = QueryTriggerInteraction.Ignore;
        [ShowIf(nameof(useLineOfSight), MultiOp.Equals, true)]
        [SerializeField] private Transform operatorTarget;
        [ShowIf(nameof(useLineOfSight), MultiOp.Equals, true)]
        [SerializeField] private float checkIntervalSeconds = 0.2f;
        [ShowIf(nameof(useLineOfSight), MultiOp.Equals, true)]
        [SerializeField] private int requiredConsecutiveMisses = 2;
        
        [Space]
        [Header("Debugging")]
        [SerializeField, Tooltip("Optional debug text that shows which gesture is currently loading or recognized.")]
        private TextMeshPro loadingGestureDisplayText;
        
        [Header("Blockers")] 
        [SerializeField]
        [ReadOnly]
        private List<MonoBehaviour> blockers = new List<MonoBehaviour>();
        private List<IBlocker> blockersList = new List<IBlocker>();
        
        private readonly List<Hand> handsAvailableForTracking = new();
        
        private GestureConfig currentGestureConfig;
        private CancellationTokenSource cts;
        private CancellationTokenSource losCts;
        
        public bool CanSeeOperator { get; private set; } = true;
        

        private float newGestureStartTime = 0;
        private float newGestureTimingEndTime = 999;

        private void OnValidate()
        {
            blockers = GetComponents<IBlocker>()
                .Cast<MonoBehaviour>() // must cast back to MonoBehaviour for serialization
                .ToList();
        }

        private void OnEnable()
        {
            if (detectionZones.Length < 1)
            {
                handsAvailableForTracking.AddRange(PlayerController.IsValid
                    ? new List<Hand>()
                    {
                        PlayerController.Instance.HandsController.LeftHand,
                        PlayerController.Instance.HandsController.RightHand
                    }
                    : FindObjectsByType<Hand>(FindObjectsSortMode.None).ToList());
            }
            
            foreach (GestureDetectionZone zone in detectionZones)
            {
                zone.OnHandEntered += HandleHandEnteredZone;
                zone.OnHandExited += HandleHandExitedZone;
            }
            
            losCts = new CancellationTokenSource();
            if(useLineOfSight)
                CheckLineOfSightAsync(losCts.Token).Forget();
            
            UpdateDisplayText();
        }

        private void Awake()
        {
            foreach (IBlocker blocker in blockers)
            {
                blockersList.Add(blocker);
            }
        }

        private void Start()
        {
            ControllerFreeInputModule.Instance.TryGetTrackingBySide(HandSide.Left, out OpenXRAutoHandTracking leftHand);
            ControllerFreeInputModule.Instance.TryGetTrackingBySide(HandSide.Right, out OpenXRAutoHandTracking rightHand);
            
            foreach (GestureConfig config in gestureConfigs)
            {
                config.Initialize(leftHand, rightHand);
            }
            
            if(activeGestureDisplayText != null)
                activeGestureDisplayText.SetString(noGestureTextKey);
        }

        private void OnDisable()
        {
            cts.SafeCancelAndDispose();
            cts = null;
            losCts.SafeCancelAndDispose();
            losCts = null;
            
            foreach (GestureDetectionZone zone in detectionZones)
            {
                if (zone == null)
                {
                    continue;
                }
                
                zone.OnHandEntered -= HandleHandEnteredZone;
                zone.OnHandExited -= HandleHandExitedZone;
            }
        }
        
        /// <summary>
        /// Main per-frame loop:
        /// 1) Early-out if gestures are currently ignored (teleport/cooldown) or if no relevant hands are in zones
        /// 2) Evaluate gesture configurations to determine loading/active states
        /// 3) Update progress UI and active-gesture text; optionally keep last gesture visible if configured
        /// </summary>
        private void Update()
        {
            if (CheckForBlockers() || handsAvailableForTracking.Count < 1 || !CanSeeOperator)
            {
                if (activeGestureConfig != null)
                {
                    activeGestureConfig.SetActive(false);
                    OnGestureEnded?.Invoke(activeGestureConfig.ID);
                    activeGestureConfig = null;
                }
                if(progressCircle != null)
                    progressCircle.fillAmount = 0;
                UpdateDisplayText();

                foreach (GestureConfig config in gestureConfigs)
                {
                    config.ResetLoadingState();
                }
                
                return;
            }
            
            //Check for gesture loading
            bool foundLoadingGesture = false;
            foreach (GestureConfig config in gestureConfigs)
            {
                if (!foundLoadingGesture && config.UpdateAndCheckGestureLoading(handsAvailableForTracking, !foundLoadingGesture))
                {
                    foundLoadingGesture = true;

                    if (config.IsDoneLoading())
                    {
                        currentGestureConfig = config;
                        if (progressCircle != null)
                            progressCircle.fillAmount = 1;
                    }
                        
                    else if (progressCircle != null)
                    {
                        if(!config.IsDoneLoading())
                        {
                            float newFillAmount = circleFillCurve.Evaluate((Time.time - config.LoadingStartTime) /
                                                                           config.LoadingDuration);
                            progressCircle.fillAmount = newFillAmount;
                        }
                    }
                        
                    if(loadingGestureDisplayText != null)
                        loadingGestureDisplayText.text = config.GestureName;
                }
                else
                {
                    config.SecondaryGestureTime = 0;
                }
            }

            if (!foundLoadingGesture)
            {
                if(loadingGestureDisplayText != null)
                    loadingGestureDisplayText.text = "No gesture loading";
                if(progressCircle != null)
                    progressCircle.fillAmount = 0;
            }
            
            if (activeGestureConfig != currentGestureConfig)
            {
                if (activeGestureConfig != null)
                {
                    OnGestureEnded?.Invoke(activeGestureConfig.ID);
                }

                activeGestureConfig = currentGestureConfig;
                
                if (activeGestureConfig != null)
                {
                    OnGestureStarted?.Invoke(activeGestureConfig.ID);
                    PlaySoundEffect(gestureRecognizedSound);
                }
        
                UpdateDisplayText();
            }
        }

        private void HandleHandEnteredZone(GestureDetectionZone zone, Hand hand)
        {
            if (handsAvailableForTracking.Contains(hand))
            {
                return;
            }
            
            handsAvailableForTracking.Add(hand);
            PlaySoundEffect(handEnterSound);
        }
        
        private void HandleHandExitedZone(GestureDetectionZone zone, Hand hand)
        {
            handsAvailableForTracking.Remove(hand);
            PlaySoundEffect(handExitSound);
        }

        private bool CheckForBlockers()
        {
            if (blockersList.Any(x => x.IsBlocked))
            {
                IgnoreGestures = true;
                return true;
            }
            else
            {
                IgnoreGestures = false;
                return false;
            }
        }

        private void UpdateDisplayText(bool forceNoGestureText = false)
        {
            if (activeGestureDisplayText == null)
            {
                return;
            }

            string previousGestureText = activeGestureDisplayText.LocalizedText;
            string newGestureText = "";

            if (forceNoGestureText)
            {
                newGestureText = noGestureTextKey;
            }
            else if (!CanSeeOperator)
            {
                newGestureText = cantSeeOperatorTextKey;
            }
            else if (showLastGestureIfNotStopped && activeGestureConfig != null)
            {
                newGestureText = activeGestureConfig.GestureName;
            }
            else if (showLastGestureIfNotStopped && IgnoreGestures)
            {
                newGestureText = noGestureTextKey;
            }
            else if(!showLastGestureIfNotStopped)
            {
                newGestureText = activeGestureConfig == null
                    ? noGestureTextKey
                    : activeGestureConfig.GestureName;
            }
            // Only updates text if different from previous
            if (previousGestureText != newGestureText && newGestureText != "")
            {
                OnNewGestureConfirmed?.Invoke(activeGestureConfig != null ? activeGestureConfig.ID : "null"); // Sends null if config is null to differentiate from empty string if gesture ID is "None".
                activeGestureDisplayText.SetString(newGestureText);
                activeGestureDisplayText.DOKill();
                activeGestureDisplayText.transform.localScale = Vector3.one;
                activeGestureDisplayText.transform.DOPunchScale(Vector3.one, 0.2f).OnComplete(() => activeGestureDisplayText.transform.localScale = Vector3.one);
            }
        }

        private void PlaySoundEffect(string sound)
        {
            Audio.PlayOneShot(sound, transform.position);
        }

        #region Line of Sight Detection
        private async UniTaskVoid CheckLineOfSightAsync(CancellationToken token)
        {
            CanSeeOperator = EvaluateLineOfSight();

            int missStreak = 0;

            while (!token.IsCancellationRequested)
            {
                try
                {
                    await UniTask.Delay(
                        TimeSpan.FromSeconds(Mathf.Max(0.01f, checkIntervalSeconds)),
                        cancellationToken: token
                    );

                    bool visibleNow = EvaluateLineOfSight();

                    if (visibleNow)
                    {
                        // Any hit (clear line) breaks the miss streak and sets true immediately.
                        missStreak = 0;
                        if (CanSeeOperator == false)
                            UpdateDisplayText(true);
                        CanSeeOperator = true;
                    }
                    else
                    {
                        missStreak += 1;
                        if (missStreak >= Mathf.Max(1, requiredConsecutiveMisses))
                        {
                            Audio.PlayOneShot(lineOfSightLostSound, operatorTarget.transform);
                            CanSeeOperator = false;
                        }
                    }
                }
                catch (OperationCanceledException)
                {
                    // Swallow expected cancellation (disable/destroy).
                }
                catch (Exception ex)
                {
                    Debug.LogException(ex);
                }
            }
        }

        /// <summary>
        /// Raw (unsmoothed) line-of-sight: true if target is null or no solid collider blocks the direct line.
        /// </summary>
        private  bool EvaluateLineOfSight()
        {
            // If no target set, bypass (always visible).
            if (!operatorTarget)
            {
                return true;
            }

            // Determine origin (prefer explicit LOS origin; fall back to this component's transform).
            Transform originT = lineOfSightOrigin ? lineOfSightOrigin : transform;
            if (originT == null)
            {
                return true;
            }

            Vector3 origin = originT.position;
            Vector3 targetPos = operatorTarget.position;
            Vector3 delta = targetPos - origin;

            float dist = delta.magnitude;
            if (dist <= Mathf.Epsilon)
            {
                return true;
            }

            int losMask = ~lineOfSightIgnoredLayers; // hit everything EXCEPT the checked layers
            bool didHit = Physics.Linecast(origin, targetPos, out RaycastHit hit, losMask, lineOfSightTriggerInteraction);
            Debug.DrawLine(origin, targetPos, Color.red, checkIntervalSeconds);

            if (!didHit)
            {
                // Nothing in between, so clear LOS
                return true;
            }

            // If the thing we hit is actually the operator target itself, LOS is clear
            if (hit.collider != null && hit.collider.transform == operatorTarget)
            {
                return true;
            }

            // Otherwise, some other object is in the way
            return false;
        }
        #endregion
    }
}
# --- end Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/Gestures/GestureHandler.cs

# FILE: Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/Gestures/GestureNotifier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1c248dd86f4b4308833a9e1e344a30c2
# ASMDEF: ldx.controllerfree.runtime.dll
# ---
using System.Threading;
using Cysharp.Threading.Tasks;
using Ldx.Framework.AddOns.ControllerFree.Data;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace AddOns.ControllerFree.Systems.Gestures
{
    public class GestureNotifier : MonoBehaviour
    {
        [IDSelection(typeof(GesturesExtensionIDDefinition))]
        [SerializeField] private string targetGestureId;
        [SerializeField] private float delayAfterGesture = 1f;
        [SerializeField] private bool broadcastOnlyOnce = true;
        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string eventOnGestureRecognized;

        private bool wasRecognized;
        private CancellationTokenSource cts;

        private void OnEnable()
        {
            GestureHandler.OnGestureStarted += HandleGestureStarted;
        }

        private void OnDisable()
        {
            GestureHandler.OnGestureStarted -= HandleGestureStarted;
            cts.SafeCancelAndDispose();
            cts = null;
        }

        private void HandleGestureStarted(string id)
        {
            if (targetGestureId == id)
            {
                if (broadcastOnlyOnce && wasRecognized)
                {
                    return;
                }
                
                wasRecognized = true;
                cts.SafeCancelAndDispose();
                cts = new CancellationTokenSource();
                BroadcastTrackingEventAfterDelayAsync(cts.Token).Forget();
            }
        }

        private async UniTask BroadcastTrackingEventAfterDelayAsync(CancellationToken token)
        {
            await UniTask.Delay(delayAfterGesture.ToMilliseconds(), cancellationToken: token);
            LdxTrackingManager.Instance.BroadcastTrackingEvent(eventOnGestureRecognized);
            cts = null;
        }
    }
}
# --- end Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/Gestures/GestureNotifier.cs

# FILE: Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/Gestures/RequiredGestureBlocker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 77b61c515920c0644adb4dfcca942d27
# ASMDEF: ldx.controllerfree.runtime.dll
# ---
using System;
using Autohand;
using Ldx.Framework.Systems.Player.Hands;
using UnityEngine;
using Utilities.Blockers;

namespace AddOns.ControllerFree.Systems.Gestures
{
    public class RequiredGestureBlocker : MonoBehaviour, IBlocker
    {
        public event Action<IBlocker, bool> OnBlockChanged;
        
        [SerializeField]
        private HandGestureEvent requiredGesture;
        [SerializeField]
        private HandSide handSide;
        
        public bool IsBlocked { get; private set; }

        private void Start()
        {
            IsBlocked = true;

            if (ControllerFreeInputModule.IsValid)
            {
                if(ControllerFreeInputModule.Instance.TryGetTrackingBySide(handSide, out OpenXRAutoHandTracking hand))
                    requiredGesture.trackingHands.Add(hand);
            }

            requiredGesture.OnGestureStartEvent.AddListener(HandleGestureStarted);
            requiredGesture.OnGestureStopEvent.AddListener(HandleGestureEnded);
        }

        private void OnDestroy()
        {
            requiredGesture.OnGestureStartEvent.RemoveListener(HandleGestureStarted);
            requiredGesture.OnGestureStopEvent.RemoveListener(HandleGestureEnded);
        }

        private void HandleGestureStarted(Hand hand, HandPoseGestureData gestureData)
        {
            IsBlocked = false;
            OnBlockChanged?.Invoke(this, IsBlocked);
        }

        private void HandleGestureEnded(Hand hand, HandPoseGestureData gestureData)
        {
            IsBlocked = true;
            OnBlockChanged?.Invoke(this, IsBlocked);
        }

    }
}
# --- end Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/Gestures/RequiredGestureBlocker.cs

# FILE: Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/Gestures/TeleportationHandGesture.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b2ebb6bb91b84eca9cf3e81bc127da3d
# ASMDEF: ldx.controllerfree.runtime.dll
# ---
using Autohand;
using Ldx.Framework.Systems.Player;
using UnityEngine;

namespace AddOns.ControllerFree.Systems.Gestures
{
    public class TeleportationHandGesture : MonoBehaviour
    {
        [SerializeField] private HandGestureEvent showTeleportGesture;
        [SerializeField] private HandFingerGestureEvent triggerTeleportGesture;

        private Hand currentHand;
        
        private void Start()
        {
            showTeleportGesture.OnGestureStartEvent.AddListener(HandleShowTeleportGestureStart);
            showTeleportGesture.OnGestureStopEvent.AddListener(HandleShowTeleportGestureStopped);
            triggerTeleportGesture.OnFingerTouchStartEvent.AddListener(HandleTriggerTeleportGestureStart);
        }
        
        private void OnDestroy()
        {
            showTeleportGesture.OnGestureStartEvent.RemoveListener(HandleShowTeleportGestureStart);
            showTeleportGesture.OnGestureStopEvent.RemoveListener(HandleShowTeleportGestureStopped);
            triggerTeleportGesture.OnFingerTouchStartEvent.RemoveListener(HandleTriggerTeleportGestureStart);
        }

        private void HandleShowTeleportGestureStart(Hand hand, HandPoseGestureData gestureData)
        {
            currentHand = hand;
            PlayerController.Instance.Teleporter.StartAiming(hand);
        }
        
        private void HandleShowTeleportGestureStopped(Hand hand, HandPoseGestureData gestureData)
        {
            PlayerController.Instance.Teleporter.StopAiming(hand, true);
        }
        
        private void HandleTriggerTeleportGestureStart(HandFingerGestureTracker tracker, FingerEnum finger1, FingerEnum finger2)
        {
            if (currentHand == null)
            {
                return;
            }
            
            PlayerController.Instance.Teleporter.StopAiming(currentHand);
        }
    }
}
# --- end Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/Gestures/TeleportationHandGesture.cs

# FILE: Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/HandTracking/LdxOpenXRAutoHandTracking.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ae010171d55f6a144be58d7c54606915
# ASMDEF: ldx.controllerfree.runtime.dll
# ---
using Autohand;
using Autohand.Demo;
using UnityEngine;

namespace Ldx.Framework.AddOns.ControllerFree.Systems.HandTracking
{
    /// <summary>
    /// Keeps the last tracked pose on tracking loss without modifying vendor code.
    /// Lets the base class drive hand pose/flags; in Update override it prevents the
    /// fallback to controller space by reapplying the cached tracking follow.
    /// </summary>
    public class LdxOpenXRAutoHandTracking : OpenXRAutoHandTracking
    {
        private Transform cachedTrackingFollow;

        protected override void OnEnable()
        {
            base.OnEnable();

            if (!controllerLink && hand)
                controllerLink = hand.gameObject.GetComponentInChildren<OpenXRHandControllerLink>(true);

            // Base OnEnable points hand.follow to its internal tracking offset; cache it.
            if (hand && hand.follow)
                cachedTrackingFollow = hand.follow;

            if (controllerLink)
                controllerLink.enabled = false;
        }

        protected override void Update()
        {
            base.Update();
            if (!hand)
                return;

            if (handTrackingActive)
            {
                // While tracked, keep a fresh reference to the tracking-follow transform.
                if (hand.follow)
                    cachedTrackingFollow = hand.follow;

                if (controllerLink)
                    controllerLink.enabled = false;
            }
            else
            {
                // When untracked, force-follow the last tracking-follow transform.
                if (cachedTrackingFollow)
                    hand.follow = cachedTrackingFollow;

                if (controllerLink)
                    controllerLink.enabled = false;
            }
        }

        protected override void OnDisable()
        {
            base.OnDisable();

            if (hand)
            {
                if (cachedTrackingFollow)
                    hand.follow = cachedTrackingFollow;

                if (controllerLink)
                    controllerLink.enabled = false;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/HandTracking/LdxOpenXRAutoHandTracking.cs

# FILE: Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/UI/ButtonHandTouchEvent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0b6865ab471249d1809beceeb1be8dae
# ASMDEF: ldx.controllerfree.runtime.dll
# ---
using Autohand;
using Ldx.Framework.Systems.UI;
using UnityEngine;

namespace Ldx.Framework.AddOns.ControllerFree.Systems.UI
{
    public class ButtonHandTouchEvent : HandTouchEvent
    {
        private const float PRESS_COOLDOWN = 0.25f;

        [SerializeField] private UIButton button;

        private float lastPressTime = 0;

        public override void Touch(Hand hand)
        {
            base.Touch(hand);
            
            if (button == null ||
                enabled == false ||
                handType == HandType.none ||
                (hand.left && handType == HandType.right) ||
                (!hand.left && handType == HandType.left) ||
                Time.time < lastPressTime + PRESS_COOLDOWN)
                return;
            
            button.PressActions();
        }

        public override void Untouch(Hand hand)
        {
            base.Untouch(hand);
            if (button == null || 
                enabled == false || 
                handType == HandType.none ||
                (hand.left && handType == HandType.right) || 
                (!hand.left && handType == HandType.left) ||
                Time.time < lastPressTime + PRESS_COOLDOWN)
                return;
            
            lastPressTime = Time.time;
            button.ReleaseActions();
        }

        public void SetButton(UIButton newButton)
        {
            button = newButton;
        }
    }
}
# --- end Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/UI/ButtonHandTouchEvent.cs

# FILE: Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/UI/ControllerFreeUIInteractionModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7735e305798945318c646cdc0bf5b605
# ASMDEF: ldx.controllerfree.runtime.dll
# ---
using Autohand;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Systems.UI;
using Ldx.Framework.Systems.UI.Modules;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;
using UnityEngine.UI;

namespace Ldx.Framework.AddOns.ControllerFree.Systems.UI
{
    /// <summary>
    /// Manages the setup of physical interaction for UI elements at runtime.
    /// It provides a static method to dynamically equip UIButtonBase components
    /// with colliders and touch event handlers.
    /// </summary>
    public class ControllerFreeUIInteractionModule : MonoBehaviour, IUIModule
    {
        [Tooltip("If true, buttons will be set up for physical interaction.")]
        [SerializeField] private bool enablePhysicalUI = true;
        [Tooltip("The depth of the trigger collider created behind the button.")]
        [SerializeField] private float colliderDepth = 0.01f;
        [SerializeField] private LayerMask interactionLayers;
        [SerializeField] private bool enableBackCollidersOnWindows = true;
        
        private void Awake()
        {
            if (!ControllerFreeAddOnModule.IsInitialized)
            {
                DestroyImmediate(gameObject);
            }

            UIButton.OnAnyUIButtonStart += HandleAnyButtonStart;
        }

        private void OnDestroy()
        {
            UIButton.OnAnyUIButtonStart -= HandleAnyButtonStart;
        }

        public void ScenarioStarted(ScenarioManager scenarioManager, ScenarioDataType scenarioDataType)
        {
            if (!ControllerFreeAddOnModule.IsInitialized || !UIController.IsValid)
            {
                return;
            }

            foreach (UIElement uiWindow in UIController.Instance.AllWindows)
            {
                uiWindow.SetBackColliderActive(enableBackCollidersOnWindows);
            }
        }

        public void UnloadingScenarioOrLobby(ScenarioManager scenarioManager) { }
        
        private void HandleAnyButtonStart(UIButton button)
        {
            EquipButtonForPhysicalInteraction(button);
        }
        
        private void EquipButtonForPhysicalInteraction(UIButton button)
        {
            if (!enablePhysicalUI || button == null) return;
            if (button.TryGetComponent<HandTouchEvent>(out _)) return;
            BoxCollider buttonCollider = button.gameObject.AddComponent<BoxCollider>();
            RectTransform rectTransform = button.transform as RectTransform;

            if (rectTransform != null)
            {
                LayoutRebuilder.ForceRebuildLayoutImmediate(rectTransform);
                buttonCollider.size = new Vector3(
                    rectTransform.rect.width,
                    rectTransform.rect.height,
                    colliderDepth
                );

                buttonCollider.center = new Vector3(0, 0, colliderDepth / 2f);
                buttonCollider.includeLayers = interactionLayers;
            }

            ButtonHandTouchEvent touchEvent = button.gameObject.GetOrAddComponent<ButtonHandTouchEvent>();
            touchEvent.handType = HandType.both;
            touchEvent.oneHanded = true;
            touchEvent.SetButton(button);
        }
    }
}
# --- end Packages/com_ldx_framework/AddOns/ControllerFree/Runtime/Scripts/Systems/UI/ControllerFreeUIInteractionModule.cs

# FILE: Packages/com_ldx_framework/AddOns/SeuratCapture/Runtime/Scripts/CaptureBuilder.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4190c999356bec34394ad0b5260e8878
# ASMDEF: runtime.seurat.capture.dll
# ---
/*
Copyright 2017 Google Inc. All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

using UnityEngine;
using UnityEngine.Rendering;
using System.Collections.Generic;
using System.IO;

// Defines notification interface for various Seurat pipeline tasks.
public class CaptureStatus {
  public virtual void SendProgress(string message, float fraction_complete) {
  }
  public virtual bool TaskContinuing() {
    return true;
  }
}

// Implements image capture with a state machine, to allow incremental capture
// with an interactive GUI.
public class CaptureBuilder {

  // -- Capture Rendering data. --

  Camera color_camera_;
  Camera depth_camera_;
  GameObject depth_camera_object_;
  // Captures data from the render device and provides access to the pixels for
  // export to disk.
  Texture2D texture_;
  Texture2D texture_fp16_;
  Texture2D texture_fp32_;
  // The capture process renders to these render texture targets then reads back
  // into the various Texture2D objects.
  RenderTexture color_render_texture_;
  RenderTexture depth_render_texture_;
  // Overrides shaders defined in the scene to capture eye space depth as
  // shader output.
  Shader render_depth_shader_;
  // Provides capture settings.
  CaptureHeadbox headbox_;
  // Indicates capture precision.
  CaptureDynamicRange dynamic_range_;
  // Stores the count of camera samples taken inside the headbox; each sample
  // requires an image per face.
  int samples_per_face_;
  // Indicates root storage location for capture images and manifest.
  string capture_dir_;
  // Defines the capture sample positions distributed throughout the headbox in
  // world space.
  List<Vector3> samples_;

  // -- Incremental capture state machine members. --

  // Current frame of the capture. Always 0 for static captures, relative to
  // max_frames_ for animation capture.
  int capture_frame_;
  // Total number of frames being captured; always 1 for static captures.
  int max_frames_ = 1;
  // Current sample of the capture.
  int sample_index_;
  // Current cube face direction being captured.
  int current_side_;
  // The view group of the current sample of the current frame accumulates each
  // face rendering as the capture progresses.
  JsonManifest.ViewGroup view_group_;
  // Accumulates the view groups as capture progresses.
  JsonManifest.Capture capture_manifest_;

  // Receives status reports as the capture progresses and provides cancellation
  // signal.
  public CaptureStatus status_interface_;

  // Per frame or per sample capture output path.
  string export_path_;
  float start_time_;
  float start_sample_time_;


  public bool IsCaptureComplete() {
    return capture_frame_ >= max_frames_;
  }

  public bool IsHighDynamicRange() {
    return dynamic_range_ != CaptureDynamicRange.kSDR;
  }

  RenderTextureFormat RenderTargetFormatFromDynamicRange() {
    RenderTextureFormat format;
    switch (dynamic_range_) {
      case CaptureDynamicRange.kHDR16:
        format = RenderTextureFormat.ARGBHalf;
        break;

      case CaptureDynamicRange.kHDR:
        format = RenderTextureFormat.ARGBHalf;
        break;

      default:
      case CaptureDynamicRange.kSDR:
        format = RenderTextureFormat.ARGB32;
        break;
    }
    return format;
  }

  Texture2D Texture2DFromDynamicRange() {
    Texture2D texture_for_dynamic_range;
    switch (dynamic_range_) {
      case CaptureDynamicRange.kHDR16:
        texture_for_dynamic_range = texture_fp16_;
        break;

      case CaptureDynamicRange.kHDR:
        texture_for_dynamic_range = texture_fp32_;
        break;

      default:
      case CaptureDynamicRange.kSDR:
        texture_for_dynamic_range = texture_;
        break;
    }
    return texture_for_dynamic_range;
  }

  private static string PathCombine(params string[] parts)
  {
    if (parts.Length == 0) return "";

    string result = parts[0];
    for (int i = 1; i < parts.Length; i++)
    {
      result = Path.Combine(result, parts[i]);
    }
    return result;
  }

  // Computes the radical inverse base |digit_base| of the given value |a|.
  private static float RadicalInverse(ulong a, ulong digit_base) {
    float inv_base = 1.0f / digit_base;
    ulong reversed_digits = 0;
    float inv_base_n = 1.0f;
    // Compute the reversed digits in the base entirely in integer arithmetic.
    while (a != 0) {
      ulong next = a / digit_base;
      ulong digit = a - next * digit_base;
      reversed_digits = reversed_digits * digit_base + digit;
      inv_base_n *= inv_base;
      a = next;
    }
    // Only when done are the reversed digits divided by base^n.
    return Mathf.Min(reversed_digits * inv_base_n, 1.0f);
  }

  public void BeginCapture(CaptureHeadbox headbox, string capture_dir, int max_frames, CaptureStatus status_interface) {
    start_time_ = Time.realtimeSinceStartup;

    headbox_ = headbox;
    dynamic_range_ = headbox_.dynamic_range_;
    samples_per_face_ = (int)headbox_.samples_per_face_;
    capture_dir_ = capture_dir;
    capture_frame_ = 0;
    status_interface_ = status_interface;
    max_frames_ = max_frames;
    status_interface_.SendProgress("Capturing Images...", 0.0f);
    List<Vector3> samples = new List<Vector3>();

    // Use Hammersly point set to distribute samples.
    for (int position_sample_index = 0; position_sample_index < samples_per_face_; ++position_sample_index)
    {
      Vector3 headbox_position = new Vector3(
        (float)position_sample_index / (float)(samples_per_face_ - 1),
        RadicalInverse((ulong)position_sample_index, 2),
        RadicalInverse((ulong)position_sample_index, 3));
      headbox_position.Scale(headbox.size_);
      headbox_position -= headbox.size_ * 0.5f;
      // Headbox samples are in camera space; transform to world space.
      headbox_position = headbox.transform.TransformPoint(headbox_position);
      samples.Add(headbox_position);
    }

    // Sort samples by distance from center of the headbox.
    samples.Sort(delegate (Vector3 a, Vector3 b) {
      float length_a = a.sqrMagnitude;
      float length_b = b.sqrMagnitude;
      return length_a.CompareTo(length_b);
    });
    // Replace the sample closest to the center of the headbox with a sample at
    // exactly the center. This is important because Seurat requires
    // sampling information at the center of the headbox.
    samples[0] = headbox.transform.position;

    samples_ = samples;
    // Note this uses a modified version of Unity's standard internal depth
    // capture shader. See the shader in Assets/builtin_shaders/
    // DefaultResourcesExtra/Internal-DepthNormalsTexture.shader.
    render_depth_shader_ = Shader.Find("GoogleVR/Seurat/CaptureEyeDepth");

    capture_manifest_ = new JsonManifest.Capture();

    // Setup cameras
    color_camera_ = headbox_.ColorCamera;

    depth_camera_object_ = new GameObject("Depth Camera");
    depth_camera_ = depth_camera_object_.AddComponent<Camera>();
    //Checks if we are using HDRP, if so, we need to add additional components.
    #if UNITY_RENDER_PIPELINE_HDRP
    OverrideMaterialRenderer overrideMaterialRenderer = depth_camera_object_.AddComponent<OverrideMaterialRenderer>();
    overrideMaterialRenderer.EnableOverride();
    #endif
  }

  public void EndCapture()
  {
    if (capture_manifest_ != null)
    {
      string json_data = JsonUtility.ToJson(capture_manifest_, true);
      File.WriteAllText(PathCombine(export_path_, "manifest.json"), json_data);
      capture_manifest_ = null;

      GameObject.DestroyImmediate(depth_camera_object_);
      color_camera_ = null;

      Debug.Log("Total Capture time: " + (Time.realtimeSinceStartup - start_time_ + " seconds."));

      DestroyRenderTargets();
    }
  }

  public void StartCaptureSamples()
  {
    export_path_ = capture_dir_;
    if (max_frames_ > 1)
    {
      // When capturing animation, make a directory per frame.
      export_path_ = export_path_ + "/frame_" + capture_frame_.ToString() + "/";
      Directory.CreateDirectory(export_path_);
    }

    start_sample_time_ = Time.realtimeSinceStartup;
  }

  public void RunCapture()
  {
    // Setup cameras; save, modify, and restore camera settings around each
    // captured face.
    color_camera_ = headbox_.ColorCamera;

    float original_aspect = color_camera_.aspect;
    float original_fov = color_camera_.fieldOfView;
    int original_culling_mask = color_camera_.cullingMask;

    if (color_render_texture_ == null) {
      BuildRenderTargets();
    }

    color_camera_.targetTexture = color_render_texture_;
    color_camera_.fieldOfView = 90f;
    color_camera_.aspect = 1f;
    // Propagate settings to the depth camera.
    depth_camera_.CopyFrom(color_camera_);
    depth_camera_.allowHDR = IsHighDynamicRange();
    depth_camera_.targetTexture = depth_render_texture_;
    depth_camera_.renderingPath = RenderingPath.Forward;
    depth_camera_.clearFlags = CameraClearFlags.Color;
    depth_camera_.backgroundColor = new Color(0f, 0f, 0f, 0f);

    CaptureSample();

    color_camera_.ResetReplacementShader();
    color_camera_.targetTexture = null;
    color_camera_.aspect = original_aspect;
    color_camera_.fieldOfView = original_fov;
    color_camera_.cullingMask = original_culling_mask;
  }

  private void CaptureSample()
  {
    // Transforms all cameras from world space to the eye space
    // of the reference camera.
    Matrix4x4 reference_from_world = color_camera_.worldToCameraMatrix;
    const string base_image_name = "Cube";

    string[] cube_face_names = {
      "Front",
      "Back",
      "Right",
      "Left",
      "Top",
      "Bottom",
    };

    int num_sides = cube_face_names.Length;
    if (current_side_ == 0)
    {
      StartCaptureSamples();
      view_group_ = new JsonManifest.ViewGroup();
      view_group_.views = new JsonManifest.View[6];
    }

    int side = current_side_;
    Quaternion face_rotation;

    switch (side)
    {
      case 0:
        face_rotation = Quaternion.identity;
        break;
      case 1:
        face_rotation = Quaternion.AngleAxis(180f, Vector3.up);
        break;
      case 2:
        face_rotation = Quaternion.AngleAxis(90f, Vector3.up);
        break;
      case 3:
        face_rotation = Quaternion.AngleAxis(-90f, Vector3.up);
        break;
      case 4:
        face_rotation = Quaternion.AngleAxis(-90f, Vector3.right);
        break;
      case 5:
      default:
        face_rotation = Quaternion.AngleAxis(90f, Vector3.right);
        break;
    }

    string progress_status = "Baking " + (sample_index_ + 1) + "/ " + samples_per_face_ + " Frame " + (capture_frame_ + 1) + "/" + max_frames_;
    int capture_task_index = sample_index_ * num_sides + side;
    int total_capture_tasks = samples_per_face_ * num_sides * max_frames_;
    status_interface_.SendProgress(progress_status,
      (float)capture_task_index / total_capture_tasks);
    if (!status_interface_.TaskContinuing())
    {
      return;
    }

    // Use cached samples
    JsonManifest.View view = Capture(
      base_image_name + "_" + cube_face_names[side] + "_" + sample_index_,
      face_rotation,
      samples_[sample_index_],
      reference_from_world,
      export_path_);

    // Shows the task is complete.
    status_interface_.SendProgress(progress_status,
      (float)(capture_task_index + 1) / total_capture_tasks);

    switch (side)
    {
      case 0:
        view_group_.views[0] = view;
        break;
      case 1:
        view_group_.views[1] = view;
        break;
      case 2:
        view_group_.views[3] = view;
        break;
      case 3:
        view_group_.views[2] = view;
        break;
      case 4:
        view_group_.views[5] = view;
        break;
      case 5:
      default:
        view_group_.views[4] = view;
        break;
    }

    ++current_side_;
    if (current_side_ == num_sides)
    {
      if (sample_index_ == 0) {
        // Forces recreation of render targets at the normal resolution after
        // capturing the center headbox at the typically-higher resolution.
        DestroyRenderTargets();
      }

      current_side_ = 0;
      capture_manifest_.view_groups.Add(view_group_);
      EndCaptureSample();
    }
  }

  public void EndCaptureSample()
  {
    Debug.Log("Sample Capture time: " + (Time.realtimeSinceStartup - start_sample_time_ + " seconds."));
    ++sample_index_;
    if (sample_index_ >= samples_per_face_) {
      // Go to next frame.
      sample_index_ = 0;
      ++capture_frame_;
    }
  }

  public void EndCaptureFrame()
  {
    ++capture_frame_;
  }

  public void CaptureAllHeadboxSamples()
  {
    if (!status_interface_.TaskContinuing())
    {
      return;
    }

    // Iterate the capture statemachine to acquire all samples for this frame.
    for (int position_sample_index = 0; position_sample_index < samples_per_face_;
      ++position_sample_index) {
      if (!status_interface_.TaskContinuing()) {
        break;
      }
      RunCapture();
    }
  }

  private JsonManifest.View Capture(
    string base_image_name,
    Quaternion orientation,
    Vector3 position,
    Matrix4x4 reference_from_world,
    string export_path)
  {

    // Save initial camera state
    Vector3 initial_camera_position = color_camera_.transform.position;
    Quaternion initial_camera_rotation = color_camera_.transform.rotation;

    // Setup cameras
    color_camera_.transform.position = position;
    color_camera_.transform.rotation = orientation;
    depth_camera_.transform.position = position;
    depth_camera_.transform.rotation = orientation;

	 // Write out depth data
	string depth_image_name = base_image_name + "_Depth.exr";
	depth_camera_.SetReplacementShader(render_depth_shader_, "RenderType");
	depth_camera_.targetTexture = depth_render_texture_;
	depth_camera_.Render();


	// Write out color data
	string color_image_name = base_image_name + "_Color." +
	  (IsHighDynamicRange() ? "exr" : "png");
	color_camera_.ResetReplacementShader();
	color_camera_.targetTexture = color_render_texture_;
	color_camera_.Render();
	
	//Output image to file according to render pipeline.
	if (GraphicsSettings.currentRenderPipeline == null)
    {
		WriteImage(depth_render_texture_, texture_fp32_, PathCombine(export_path, depth_image_name), false);
	}
	else
	{
		WriteImage(color_render_texture_, Texture2DFromDynamicRange(), PathCombine(export_path, color_image_name), true);
	}	
	

    // Record the capture results.
    JsonManifest.View view = new JsonManifest.View();
    view.projective_camera.image_width = color_render_texture_.width;
    view.projective_camera.image_height = color_render_texture_.height;
    view.projective_camera.clip_from_eye_matrix = JsonManifest.MatrixToArray(color_camera_.projectionMatrix);
    view.projective_camera.world_from_eye_matrix = JsonManifest.MatrixToArray(reference_from_world * color_camera_.cameraToWorldMatrix);
    view.projective_camera.depth_type = "EYE_Z";
    view.depth_image_file.color.path = color_image_name;
    view.depth_image_file.color.channel_0 = "R";
    view.depth_image_file.color.channel_1 = "G";
    view.depth_image_file.color.channel_2 = "B";
    view.depth_image_file.color.channel_alpha = "CONSTANT_ONE";
    view.depth_image_file.depth.path = depth_image_name;
    view.depth_image_file.depth.channel_0 = "R";

    // Restore camera state
    color_camera_.transform.position = initial_camera_position;
    color_camera_.transform.rotation = initial_camera_rotation;

    return view;
  }

  private static void WriteImage(RenderTexture render_texture, Texture2D texture, string image_path, bool clear_alpha_to_one) {
    RenderTexture.active = render_texture;
    texture.ReadPixels(new Rect(0, 0, texture.width, texture.height), 0, 0);
    if (clear_alpha_to_one) {
      Color[] pixels = texture.GetPixels();
      int num_pixels = pixels.Length;
      for (int pixel = 0; pixel < num_pixels; ++pixel) {
        pixels [pixel].a = 1f;
      }
      texture.SetPixels(pixels);
    }
    texture.Apply();
    if (texture.format == TextureFormat.RGBAHalf
        || texture.format == TextureFormat.RGBAFloat
        || texture.format == TextureFormat.RFloat) {
      byte[] exr = texture.EncodeToEXR(texture.format == TextureFormat.RGBAHalf
          ? Texture2D.EXRFlags.None : (Texture2D.EXRFlags.OutputAsFloat | Texture2D.EXRFlags.CompressZIP));
      File.WriteAllBytes(image_path, exr);
    } else {
      byte[] png = texture.EncodeToPNG();
      File.WriteAllBytes(image_path, png);
    }
    RenderTexture.active = null;
  }

  private void BuildRenderTargets() {
    // Create scratch textures
    int resolution = (int)(sample_index_ == 0 ? headbox_.center_resolution_ : headbox_.resolution_);
    int depth_bits = 24;
    // Note this reads in linear or sRGB depending on project settings.
    color_render_texture_ = new RenderTexture(resolution, resolution, depth_bits, RenderTargetFormatFromDynamicRange());
    depth_render_texture_ = new RenderTexture(resolution, resolution, depth_bits, RenderTextureFormat.ARGBFloat, RenderTextureReadWrite.Linear);
    color_render_texture_.autoGenerateMips = false;
    depth_render_texture_.autoGenerateMips = false;
    texture_ = new Texture2D(resolution, resolution, TextureFormat.ARGB32, false);
    texture_fp16_ = new Texture2D(resolution, resolution, TextureFormat.RGBAHalf, false);
    texture_fp32_ = new Texture2D(resolution, resolution, TextureFormat.RGBAFloat, false);
  }

  private void DestroyRenderTargets() {
    color_render_texture_.Release();
    color_render_texture_ = null;
    depth_render_texture_.Release();
    depth_render_texture_ = null;
    texture_ = null;
    texture_fp16_ = null;
    texture_fp32_ = null;
  }
}
# --- end Packages/com_ldx_framework/AddOns/SeuratCapture/Runtime/Scripts/CaptureBuilder.cs

# FILE: Packages/com_ldx_framework/AddOns/SeuratCapture/Runtime/Scripts/CaptureHeadbox.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3fa279ab4b847324192b8606cde760cc
# ASMDEF: runtime.seurat.capture.dll
# ---
/*
Copyright 2017 Google Inc. All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
using System.IO;

public enum CubeFaceResolution
{
  k512 = 512,
  k1024 = 1024,
  k1536 = 1536,
  k2048 = 2048,
  k4096 = 4096,
  k8192 = 8192
}

public enum PositionSampleCount {
  k2 = 2,
  k4 = 4,
  k8 = 8,
  k16 = 16,
  k32 = 32,
  k64 = 64,
  k128 = 128,
  k256 = 256,
}

public enum CaptureDynamicRange {
  // Standard (or low) dynamic range, e.g. sRGB.
  kSDR = 0,
  // High dynamic range with medium precision floating point data; requires half float render targets.
  kHDR16 = 1,
  // High dynamic range with full float precision render targets.
  kHDR = 2,
}

[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
public class CaptureHeadbox : MonoBehaviour {
  // -- Capture Settings --

  [Tooltip("The dimensions of the headbox.")]
  public Vector3 size_ = Vector3.one;
  [Tooltip("The number of samples per face of the headbox.")]
  public PositionSampleCount samples_per_face_ = PositionSampleCount.k32;
  [Tooltip("The resolution of the center image, taken at the camera position at the center of the headbox. This should be 4x higher than the resolution of the remaining samples, for antialiasing.")]
  public CubeFaceResolution center_resolution_ = CubeFaceResolution.k4096;
  [Tooltip("The resolution of all samples other than the center.")]
  public CubeFaceResolution resolution_ = CubeFaceResolution.k1024;

  [Tooltip("Capture in standard (SDR) or high dynamic range (HDR). HDR requires floating-point render targets, the Camera Component have allow HDR enabled, and enables EXR output.")]
  public CaptureDynamicRange dynamic_range_ = CaptureDynamicRange.kSDR;

  // -- Processing Settings --

  [Tooltip("Root destination folder for capture data; empty instructs the capture to use an automatically-generated, unique folder in the project temp folder.")]
  public string output_folder_ = "";

  // Indicates location of most-recent capture artifacts.
  public string last_output_dir_;

  private Camera color_camera_;
  private CaptureBuilder capture_;

  public Camera ColorCamera {
    get {
      if (color_camera_ == null) {
        color_camera_ = GetComponent<Camera>();
      }
      return color_camera_;
    }
  }

  void Update() {
    if (IsCapturing()) {
      RunCapture();
    }

    if (Input.GetKeyDown(KeyCode.BackQuote)) {
      ToggleCaptureMode();
    }
  }

  public bool IsCapturing() {
    return capture_ != null;
  }

  void RunCapture() {
    Debug.Log("Capturing headbox samples...", this);
    capture_.CaptureAllHeadboxSamples();
    if (capture_.IsCaptureComplete()) {
      StopCapture();
    }
  }

  void ToggleCaptureMode() {
    if (IsCapturing()) {
      StopCapture();
    } else {
      StartCapture();
    }
  }

  public void StartCapture() {
    Debug.Log("Capture start - temporarily setting fixed framerate.", this);
    capture_ = new CaptureBuilder();

    string capture_output_folder = output_folder_;
    if (capture_output_folder.Length <= 0) {
#if UNITY_EDITOR
      capture_output_folder = FileUtil.GetUniqueTempPathInProject();

#else
      Debug.LogError("No path was specified");
      StopCapture();
      return;
#endif
    }
    Directory.CreateDirectory(capture_output_folder);
    capture_.BeginCapture(this, capture_output_folder, 1, new CaptureStatus());

    // See Time.CaptureFramerate example, e.g. here:
    // https://docs.unity3d.com/ScriptReference/Time-captureFramerate.html
    Time.captureFramerate = 60;
  }

  void StopCapture() {
    Debug.Log("Capture stop", this);
    if (capture_ != null) {
      capture_.EndCapture();
    }
    capture_ = null;
    Time.captureFramerate = 0;
  }

  void OnDrawGizmos()
  {
    // The headbox is defined in camera coordinates.
    Gizmos.matrix = transform.localToWorldMatrix;
    Gizmos.color = Color.blue;
    Gizmos.DrawWireCube(Vector3.zero, size_);
  }
}
# --- end Packages/com_ldx_framework/AddOns/SeuratCapture/Runtime/Scripts/CaptureHeadbox.cs

# FILE: Packages/com_ldx_framework/AddOns/SeuratCapture/Runtime/Scripts/JsonManifest.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2f1a74e3ec2f70a4fa9b7d87d183f50d
# ASMDEF: runtime.seurat.capture.dll
# ---
/*
Copyright 2017 Google Inc. All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

using UnityEngine;
using System.Collections.Generic;
using System;

// Defines types and functions to generate a JSON manifest for a Seurat
// capture.
public class JsonManifest {
  static public float[] MatrixToArray(Matrix4x4 other) {
    float[] elements = new float[16];
    for (int j = 0; j < 4; j++) {
      for (int i = 0; i < 4; i++) {
        elements[j * 4 + i] = other[j, i];
      }
    }
    return elements;
  }

  [Serializable]
  public struct Image4File {
    public string path;
    public string channel_0;
    public string channel_1;
    public string channel_2;
    public string channel_alpha;
  }

  [Serializable]
  public struct Image1File {
    public string path;
    public string channel_0;
  }

  // Indicates storage of one RGBAD image.
  [Serializable]
  public struct DepthImageFile {
    public Image4File color;
    public Image1File depth;
  }

  [Serializable]
  public struct ProjectiveCamera {
    public int image_width;
    public int image_height;
    public float[] clip_from_eye_matrix;
    public float[] world_from_eye_matrix;
    public string depth_type;
  }

  [Serializable]
  public struct View {
    public ProjectiveCamera projective_camera;
    public DepthImageFile depth_image_file;
  }

  [Serializable]
  public struct ViewGroup {
    public View[] views;
  }

  [Serializable]
  public class Capture {
    public List<ViewGroup> view_groups = new List<ViewGroup>();
  }
}
# --- end Packages/com_ldx_framework/AddOns/SeuratCapture/Runtime/Scripts/JsonManifest.cs

# FILE: Packages/com_ldx_framework/AddOns/SeuratCapture/Runtime/Scripts/SeuratCaptureController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0e3b146f9154f524c9c83934fb8437ea
# ASMDEF: runtime.seurat.capture.dll
# ---
using System;
using System.IO;
using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.SceneManagement;

#if UNITY_EDITOR
using UnityEditor;
#endif

public class SeuratCaptureController : MonoBehaviour
{
	public static event Action<float> OnProgressUpdated;
	public static event Action OnProgressComplete;


	public GameObject captureCameraPrefab;
	public GameObject captureZone;
	public Vector3 grid;
	public List<SeuratCaptureHeadbox> CurrentHeadboxList = new List<SeuratCaptureHeadbox>();
	private float colorLerp;
	private bool colorDirection;
	public int targetPolyCount = 30000;
	public string msvc2017location = "Location seurat-pipeline-msvc2017-x64.exe here!";

	[Tooltip(
		"Use the curly brackets if you want to change the order, or set it custom. Options are {project}/{scene}/{date}/{position}." +
		"Note, best not to change this.")]
	public string folderOutput = "C:/{project}/{scene}/{date}/{position}";

	#region Batch File

	const string BatchFileContentTemplate = @"
@echo off
setlocal enabledelayedexpansion

rem Set the path to the directory containing your subfolders.
set ""target_directory={0}""

rem Loop through subfolders and execute the Seurat compiler.
for /d %%D in (""%target_directory%\*"") do (
    cd ""%%D""
    if exist ""manifest.json"" (
        echo Compiling Seurat model in folder: %%~nxD
        {1} -input_path=manifest.json -output_path=output -triangle_count={2} -pixels_per_degree=13.0 -premultiply_alpha=false
        rename output.obj %%~nxD.obj
        rename output.png %%~nxD.png
        move %%~nxD.obj ""%target_directory%\models\""
        move %%~nxD.png ""%target_directory%\models\""
    ) else (
        echo Skipped folder without manifest.json: %%~nxD
    )
    cd ..
)

endlocal
";
	
	public string GetBatchFileContent(string baseDirectory)
	{
		// Order is 0 = target directory, 1 = exe location + name.format,  2 = poly count
		return string.Format(BatchFileContentTemplate, baseDirectory, msvc2017location, targetPolyCount.ToString());
	}

	#endregion


	[ContextMenu("Create Zone")]
	// Method to create the capture area
	public void CreateCaptureZone()
	{
		if (captureZone != null)
		{
			DestroyImmediate(captureZone);
		}

		captureZone = GameObject.CreatePrimitive(PrimitiveType.Cube);
		captureZone.name = "Capture Zone";
		captureZone.transform.parent = transform;
		captureZone.transform.localScale = Vector3.one;
		captureZone.transform.position = Vector3.zero;

		// Set the material or color to pink
		captureZone.GetComponent<Renderer>().enabled = false;
		ClearHeadboxes();
	}

	[ContextMenu("Create Grid")]
	// Method to create the grid of cameras
	public void CreateGrid()
	{
		if (captureZone == null)
		{
			Debug.LogError("Capture Zone is not created.");
			return;
		}

		ClearHeadboxes();

		Vector3 captureZoneScale = captureZone.transform.lossyScale;
		Vector3 colliderScale = new Vector3(captureZoneScale.x / grid.x, captureZoneScale.y / grid.y,
			captureZoneScale.z / grid.z);
		Vector3 captureZonePosition = captureZone.transform.position;

		for (int x = 0; x < grid.x; x++)
		{
			for (int y = 0; y < grid.y; y++)
			{
				for (int z = 0; z < grid.z; z++)
				{
					Vector3 positionOffset =
						new Vector3(x * colliderScale.x, y * colliderScale.y, z * colliderScale.z) -
						captureZoneScale / 2 + colliderScale / 2;
					Vector3 cameraPosition = captureZonePosition + positionOffset;
					GameObject camera = Instantiate(captureCameraPrefab, cameraPosition, Quaternion.identity,
						captureZone.transform);
					SeuratCaptureHeadbox headbox = camera.GetComponent<SeuratCaptureHeadbox>();
					CurrentHeadboxList.Add(headbox);
					//headbox.collider.size = colliderScale;
					string position = $"{x}-{y}-{z}";
					camera.name = $"Capture Camera {position}";
					headbox.headbox.output_folder_ = ReplacePlaceholders(new Vector3(x, y, z));
					// Configure the camera's collider here if needed
				}
			}
		}
	}

	[ContextMenu("Capture All Boxes")]
	public async Task CaptureAllHeadboxesAsync()
	{
		int complete = 0;
		int total = CurrentHeadboxList.Count;
		OnProgressUpdated?.Invoke(0f);
		Debug.Log($"Starting capture of {total} headboxes.");
		foreach (var headboxComponent in CurrentHeadboxList)
		{
			Debug.Log($"Capturing Headbox {headboxComponent.gameObject.name}");

			if (headboxComponent != null)
			{
				OnProgressUpdated?.Invoke((float)complete / (float)total);
				headboxComponent.headbox.StartCapture();

				// Await the completion of the capture
				await WaitForCaptureCompletionAsync(headboxComponent.headbox);
				complete += 1;
			}
		}

		OnProgressUpdated?.Invoke((float)complete / (float)total);
		OnProgressComplete?.Invoke();
		Debug.Log(
			$"Capturing of {CurrentHeadboxList.Count} headboxes complete! Please find them in {ReplacePlaceholders(Vector3.zero)}");
	}

	[ContextMenu("Select EXE")]
	public void SelectExe()
	{
		msvc2017location = FileSelector.SelectExeFile();
	}

	[ContextMenu("Create and Run Batch")]
	public async void RunBatchFile()
	{
		var bat = CreateBatchFile(BaseDirectory());
		await Task.Delay(1000);
		var process = new System.Diagnostics.Process();
		process.StartInfo.FileName = bat;
		process.StartInfo.UseShellExecute = false;
		process.StartInfo.RedirectStandardOutput = true;
		process.Start();

		// Optional: Read the output (if any)
		string output = process.StandardOutput.ReadToEnd();
		Debug.Log(output);

		process.WaitForExit(); // Wait for the batch file to complete
	}
	
	[ContextMenu("Preview Batch File")]
	public void PreviewBatchFile()
	{
		Debug.Log(GetBatchFileContent(BaseDirectory()));
	}

	// Async method to wait for a headbox capture to complete
	private async Task WaitForCaptureCompletionAsync(CaptureHeadbox headbox)
	{
		// Polling interval (e.g., 1 second)
		const int pollingInterval = 1000;

		// Poll the IsCapturing status every interval
		while (headbox.IsCapturing())
		{
			await Task.Delay(pollingInterval);
		}
	}

	private void ClearHeadboxes()
	{
		if (CurrentHeadboxList.Count > 0)
		{
			foreach (var headbox in CurrentHeadboxList)
			{
				if (headbox != null)
					DestroyImmediate(headbox.gameObject);
			}

			CurrentHeadboxList.Clear();
		}
	}

	#region String replacement

	public string ReplacePlaceholders(Vector3 position)
	{
		string projectName = GetProjectName();
		string sceneName = GetActiveSceneName();
		string currentDate = DateTime.Now.ToString("yyyy-MM-dd");
		string positionString = PositionToString(position);

		string result = folderOutput
			.Replace("{project}", projectName)
			.Replace("{scene}", sceneName)
			.Replace("{date}", currentDate)
			.Replace("{position}", positionString);

		return result;
	}
	
	public string BaseDirectory()
	{
		string projectName = GetProjectName();
		string sceneName = GetActiveSceneName();
		string currentDate = DateTime.Now.ToString("yyyy-MM-dd");

		string result = folderOutput
			.Replace("{project}", projectName)
			.Replace("{scene}", sceneName)
			.Replace("{date}", currentDate)
			.Replace("{position}", "");

		return result;
	}

	private string GetProjectName()
	{
		// Gets the name of the project
		string[] s = Application.dataPath.Split('/');
		return s[s.Length - 2];
	}

	private string GetActiveSceneName()
	{
		// Gets the name of the currently active scene
		return SceneManager.GetActiveScene().name;
	}

	private string PositionToString(Vector3 position)
	{
		// Converts the position to a string
		return $"{position.x}_{position.y}_{position.z}";
	}

	#endregion
	
	#region Batching
	public string CreateBatchFile(string filePath)
	{
		string fullPath = filePath + "Seurat.bat";
		Debug.Log($"filepath is {fullPath}");
		Debug.Log($"Content is {GetBatchFileContent(BaseDirectory())}");
		File.WriteAllText(fullPath, GetBatchFileContent(BaseDirectory()));
		return fullPath;
	}
	
#endregion

#if UNITY_EDITOR
	async void OnDrawGizmos()
	{
		colorLerp += colorDirection ? 0.001f : -0.001f;
		if (colorLerp <= 0 || colorLerp >= 1)
			colorDirection = !colorDirection;

		Color color = Color.cyan;
		color = new Color(color.r, color.g, color.b, colorLerp);

		if (captureZone != null)
		{
			Gizmos.color = color;
			Gizmos.DrawWireCube(captureZone.transform.position, captureZone.transform.lossyScale);
			colorLerp = Mathf.Clamp(colorLerp, 0, 1);
		}

		await Task.Delay(10);
	}
	#endif
}

public static class FileSelector
{
	public static string SelectExeFile()
	{
		#if UNITY_EDITOR
		string path = EditorUtility.OpenFilePanel("Select exe file", "", "exe");
		if (!string.IsNullOrEmpty(path))
		{
			return path;
		}
		#endif

		return string.Empty;
	}
}
# --- end Packages/com_ldx_framework/AddOns/SeuratCapture/Runtime/Scripts/SeuratCaptureController.cs

# FILE: Packages/com_ldx_framework/AddOns/SeuratCapture/Runtime/Scripts/SeuratCaptureHeadbox.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2c8097b8c86bc2f41883a0f2eb6f5370
# ASMDEF: runtime.seurat.capture.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SeuratCaptureHeadbox : MonoBehaviour
{
    public CaptureHeadbox headbox;
    public Camera camera;
    public BoxCollider collider;
}
# --- end Packages/com_ldx_framework/AddOns/SeuratCapture/Runtime/Scripts/SeuratCaptureHeadbox.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Animation/AnimationObject.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e76741f88d61485d8c2e3f6426f22db5
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Features.Animation
{
    [TrackedReference]
    [DisallowMultipleComponent]
    public class AnimationObject : MonoBehaviour, ISaveSceneListener
    {
        [IDSelection(LdxIdSettings.IdType.Dialog)] [SerializeField]
        private string dialogId;
        
        /// <summary>
        /// Gets or sets the dialog ID associated with the animation.
        /// </summary>
        public string DialogID
        {
            get => dialogId;
            set => dialogId = value;
        }

        [SerializeField]
        private Animator animator;
        public Animator Animator => animator;

        public enum AnimationAction
        {
            SetTrigger
        }
        
        [SerializeField]
        private AnimationAction action;
        public AnimationAction Action => action;

        [SerializeField]
        private string animationTrigger;
        
        [SerializeField]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string onCompletionTrackingEvent;
        
        public void OnSceneSaving()
        {
#if UNITY_EDITOR
            EDITOR_SanitizeSetup();
#endif
        }

        public void TriggerAnimation()
        {
            if (animator == null)
            {
                return;
            }
            
            switch (action)
            {
                case AnimationAction.SetTrigger:
                    animator.SetTrigger(animationTrigger);
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        public void BroadcastTriggerEvent()
        {
            LdxTrackingManager.Instance.BroadcastTrackingEvent(onCompletionTrackingEvent);
        }
        
#if UNITY_EDITOR
        private void EDITOR_SanitizeSetup()
        {
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Animation/AnimationObject.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Drawing/DrawableSurface.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3bf0648c733d9a14892375b695552c08
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Features.Drawing
{
    /// <summary>
    /// This is a drawable surface, which can be drawn on using a DrawingTool. You can use it to mark things, like measurements.
    /// Marking will be set.
    /// </summary>
    public class DrawableSurface : MonoBehaviour
    {
        public event Action<DrawableSurface, DrawingMark> OnMarkAdded; 
        public event Action<DrawableSurface, DrawingMark> OnMarkRemoved; 
        
        [SerializeField]
        private bool drawableOnStart;
        [SerializeField]
        private bool erasableOnStart;
        
        [IDSelection(LdxIdSettings.IdType.TrackingFeature)]
        [SerializeField]
        private string featureId;
        public string FeatureID => featureId;
        
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField]
        private string markedTrackingEvent;
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField]
        private string unmarkedTrackingEvent;

        [SerializeField][SoundReference]
        private string soundOnErase;
        
        [SerializeField]
        private Collider surfaceCollider;
        public Collider Collider => surfaceCollider;

        public List<DrawingMark> trackedMarks = new();
        public List<DrawingMark> TrackedMarks => trackedMarks;
        
        private Dictionary<DrawingMark, Vector3> lineRenderersToCentresMap = new();
        private float distanceToTrackErase = 0.01f;

        public bool IsMarked { get; private set; }
        public bool IsDrawable { get; private set; } = false;
        public bool IsErasable { get; private set; } = false;

        private void Awake()
        {
           LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
        }
        
        private void OnDestroy()
        {
            if (LdxTrackingManager.Instance != null)
            {
                LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
            }
        }

        private void Start()
        {
            IsDrawable = drawableOnStart;
            IsErasable = erasableOnStart;
        }
        
        private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            if (eventData is not ConfigureDrawableSurfacesEventData data)
            {
                return;
            }

            IsDrawable = data.DrawableSurfaces.Contains(featureId);
            IsErasable = data.ErasableSurfaces.Contains(featureId);
        }

        public void AddMark(DrawingMark drawingMark)
        {
            trackedMarks.Add(drawingMark);
            drawingMark.IsErasable = IsErasable;
        }

        public void EraseAllMarks()
        {
            for (int i = trackedMarks.Count - 1; i >= 0; i--)
            {
                RemoveMark(trackedMarks[i]);
            }
        }

        public void EraseNearestLine(Vector3 position)
        {
            if (trackedMarks.Count == 0)
            {
                return;
            }
            
            float closestSqrDist = Mathf.Infinity;
            DrawingMark closestMark = null;
            foreach (DrawingMark mark in trackedMarks)
            {
                if (mark == null)
                    trackedMarks.Remove(mark);
                
                TryAddLRCentre(mark);
                float sqrDist = (position - lineRenderersToCentresMap[mark]).sqrMagnitude;
                if (sqrDist < closestSqrDist && sqrDist < distanceToTrackErase)
                {
                    closestSqrDist = sqrDist;
                    closestMark = mark;
                }
            }
            
            if (closestMark == null || !closestMark.IsErasable)
            {
                Debug.LogError("No closest LR found");
                return;
            }
            
            RemoveMark(closestMark);
            SetMarked(false);
        }

        public void LineFinished(DrawingMark mark)
        {
            if (mark.LineRenderer.positionCount == 0)
            {
                return;
            }
            TryAddLRCentre(mark);
            OnMarkAdded?.Invoke(this, mark);
        }

        public void RemoveMark(DrawingMark mark)
        {
            trackedMarks.Remove(mark);
            if (lineRenderersToCentresMap.ContainsKey(mark))
            {
                lineRenderersToCentresMap.Remove(mark);
            }
            Destroy(mark.gameObject);
            OnMarkRemoved?.Invoke(this, mark);
            Audio.PlayOneShot(soundOnErase);
        }
        
        private void TryAddLRCentre(DrawingMark mark)
        {
            if (!lineRenderersToCentresMap.ContainsKey(mark))
            {
                lineRenderersToCentresMap.Add(mark, GetLineRendererCentre(mark));
            }
        }

        public void SetIsDrawable(bool state)
        {
            IsDrawable = state;
        }

        public void SetIsErasable(bool state)
        {
            IsErasable = state;
        }
        
        public void SetMarked(bool isMarked)
        {
            IsMarked = isMarked;
            
            if (isMarked)
            {
                LdxTrackingManager.Instance.BroadcastTrackingEvent(markedTrackingEvent);
            }
            else
            {
                LdxTrackingManager.Instance.BroadcastTrackingEvent(unmarkedTrackingEvent);
            }
        }
        
        private Vector3 GetLineRendererCentre(DrawingMark mark)
        {
            Vector3 sum = Vector3.zero;
            Vector3[] positions = new Vector3[mark.LineRenderer.positionCount];
            mark.LineRenderer.GetPositions(positions);
            foreach (Vector3 p in positions)
            {
                sum += p;
            }
            return sum / (float)mark.LineRenderer.positionCount;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Drawing/DrawableSurface.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Drawing/DrawingMark.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 502f86a874a647fb88647cfe247c04f7
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Features.Drawing
{
    /// <summary>
    /// Creates when drawing using DrawingTool ends
    /// </summary>
    public class DrawingMark : MonoBehaviour
    {
        public LineRenderer LineRenderer { get; set; }
        public float MarkingPlacementValue { get; set; }
        public bool IsErasable { get; set; }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Drawing/DrawingMark.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Drawing/DrawingTool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2badf9a372fc2a448b72f7edd08d0218
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Autohand;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Features.Drawing
{
	/// <summary>
	/// This is a simple component to convert a rigidbody to a drawing tool. Just drop a DrawingSurface on another object
	/// in order to use it!
	/// </summary>
	public class DrawingTool : MonoBehaviour
	{
		public static event Action<DrawingTool, bool> GrabbedTool;
		public event Action<DrawingMark, bool> Drawing;

		private const int DRAW_EVERY_FRAMES = 2;

		private const float DISTANCE_FROM_PEN = 0.005f;

		// Line renderer constants
		private const int LR_VERTICES_COUNT = 5;

		// This is the max difference an angle can be between start,mid,end to be considered straight.
		private const float STRAIGHT_ANGLE_MAX = 15;
		private const int LR_MIN_POINTS = 3;

		[SerializeField] private List<DrawableSurface> surfaces = new List<DrawableSurface>();

		// Material for the LineRenderer, use something dark/chalky
		[SerializeField] private Material lineMaterial;
		[SerializeField] private bool handleAddingLines = true;
		[SerializeField] private float lineRendererWidth = 0.003f;
		[SerializeField] private bool loopLine = false;
		[SerializeField][SoundReference]
		private string drawingLoop;
		[SerializeField] private Grabbable grabbable;

		private Dictionary<Collider, DrawableSurface> colliderToSurfaceMap = new();
		private Vector3 lastPoint; // The last point we added to the line
		private LineRenderer currentLineRenderer; // Reference to the currently active LineRenderer
		private DrawableSurface currentDrawableSurface = null;
		private Collider currentCollider = null;
		private SoundInstance drawingInstance;
		private Vector3 firstPoint;

		private DrawingMark currentDrawingMark;
		public DrawingMark DrawingMark => currentDrawingMark;

		private void Awake()
		{
			Init();
		}

		private void Init()
		{
			foreach (DrawableSurface surface in surfaces)
			{
				colliderToSurfaceMap.Add(surface.Collider, surface);
			}

			if (grabbable == null)
				grabbable = GetComponentInParent<Grabbable>();

			grabbable.OnGrabEvent += HandleGrabbed;
			grabbable.OnReleaseEvent += HandleReleased;
		}

		private void OnDestroy()
		{
			grabbable.OnGrabEvent -= HandleGrabbed;
			grabbable.OnReleaseEvent -= HandleReleased;
		}

		private void OnCollisionEnter(Collision collision)
		{
			CheckCollisionToCreateLine(collision);
		}

		private void CheckCollisionToCreateLine(Collision collision)
		{
			if (!colliderToSurfaceMap.TryGetValue(collision.collider, out DrawableSurface surface))
			{
				return;
			}

			if (!surface.IsDrawable)
			{
				return;
			}

			// Check if the collided object is a DrawableSurface
			GameObject lineObj = new GameObject("Line");
			currentDrawingMark = lineObj.AddComponent<DrawingMark>();
			currentDrawingMark.LineRenderer = currentLineRenderer = lineObj.AddComponent<LineRenderer>();
			currentDrawingMark.MarkingPlacementValue = surface.transform.position.z;
			currentCollider = collision.collider;
			currentDrawableSurface = surface;
			drawingInstance = Audio.CreateSoundInstance(drawingLoop);
			
			SetLr(currentLineRenderer, surface.transform);
			surface.AddMark(currentDrawingMark);
			Drawing?.Invoke(currentDrawingMark, true);
			
			if (drawingInstance != null)
				drawingInstance.Play();
		}

		private void OnCollisionStay(Collision collision)
		{
			if (currentDrawableSurface == null)
				CheckCollisionToCreateLine(collision);
			
			// Run it every x frames as it's somewhat expensive.
			if (!handleAddingLines || currentDrawableSurface == null || Time.frameCount % DRAW_EVERY_FRAMES != 0 ||
			    collision.collider != currentCollider)
				return;
			
			foreach (ContactPoint contact in collision.contacts)
			{
				Vector3 contactPoint = contact.point;

				if (IsOnSurface(contactPoint, collision.collider, out Vector3 newPoint))
				{
					if (currentLineRenderer.positionCount == 0 || contactPoint != lastPoint)
					{
						if (currentLineRenderer.positionCount == 0)
							firstPoint = newPoint;
						else newPoint.x = firstPoint.x;

						AddLinePoint(newPoint);
						lastPoint = contactPoint;
						return;
					}
				}
			}
		}

		private void OnCollisionExit(Collision collision)
		{
			if (collision.collider == currentCollider)
			{
				FinishDrawing();
			}
		}

		public void FinishDrawing()
		{
			currentDrawableSurface.LineFinished(currentDrawingMark);
			if (currentLineRenderer.positionCount == 0)
			{
				Destroy(currentLineRenderer.gameObject);
			}

			Drawing?.Invoke(currentDrawingMark, false);
			currentDrawingMark = null;
			currentLineRenderer = null;
			currentDrawableSurface = null;
			currentCollider = null;
			
						
			if (drawingInstance != null)
				drawingInstance.StopFadeOut();
		}

		public void AddLinePoint(Vector3 point)
		{
			if (currentLineRenderer == null || currentDrawingMark == null)
			{
				return;
			}

			currentLineRenderer.positionCount++;
			currentLineRenderer.SetPosition(currentLineRenderer.positionCount - 1, point);
		}

		private void SetLr(LineRenderer lineRenderer, Transform newParent)
		{
			lineRenderer.startWidth = lineRendererWidth;
			lineRenderer.endWidth = lineRendererWidth;
			lineRenderer.positionCount = 0; // Start empty
			lineRenderer.textureMode = LineTextureMode.Tile;
			lineRenderer.numCornerVertices = LR_VERTICES_COUNT;
			lineRenderer.numCapVertices = LR_VERTICES_COUNT;
			lineRenderer.useWorldSpace = true;
			lineRenderer.loop = loopLine;
			lineRenderer.transform.SetParent(newParent, true);

			if (lineMaterial != null)
			{
				lineRenderer.material = lineMaterial;
			}
		}

		/// <summary>
		/// This will check if a line is mostly straight, within a +- of {STRAIGHT_ANGLE_MAX}. If you want to extend this
		/// further, you could manually set the endPoint, which would confirm that the line is straight, and going in the
		/// correct direction.
		/// </summary>
		/// <param name="lineRenderer">the linerenderer you're looking for clarity on.</param>
		/// <param name="overrideEndPoint">If we want to set the end point, to dictate the direction the line must go.</param>
		/// <returns></returns>
		private bool IsMostlyStraightLine(LineRenderer lineRenderer, Vector3? overrideEndPoint = null)
		{
			if (lineRenderer.positionCount < LR_MIN_POINTS)
			{
				return false; // Not enough points to make a meaningful check
			}

			// Get positions
			Vector3 startPoint = lineRenderer.GetPosition(0);
			Vector3 middlePoint = lineRenderer.GetPosition(Mathf.FloorToInt(lineRenderer.positionCount / 2));
			Vector3 endPoint = overrideEndPoint ?? lineRenderer.GetPosition(lineRenderer.positionCount - 1);

			// Calculate directions
			Vector3 dir1 = (middlePoint - startPoint).normalized;
			Vector3 dir2 = (endPoint - middlePoint).normalized;

			// Calculate angle between directions
			float angle = Vector3.Angle(dir1, dir2);
			return angle < STRAIGHT_ANGLE_MAX;
		}

		private void HandleGrabbed(Hand hand, Grabbable _)
		{
			GrabbedTool?.Invoke(this, true);
		}

		private void HandleReleased(Hand hand, Grabbable _)
		{
			GrabbedTool?.Invoke(this, false);
		}

		private bool IsOnSurface(Vector3 point, Collider surfaceCollider, out Vector3 newPoint)
		{
			RaycastHit hit;
			Vector3 direction = surfaceCollider.transform.position - point; // Direction towards the object's surface
			if (Physics.Raycast(point, direction, out hit, DISTANCE_FROM_PEN))
			{
				if (hit.collider == surfaceCollider) // Verify that we hit the intended surface
				{
					newPoint = hit.point;
					return true;
				}
			}

			newPoint = Vector3.zero;
			return false;
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Drawing/DrawingTool.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Drawing/ErasingTool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e4abda4674aa431cafca376e3f06ba21
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using UnityEngine;

namespace Ldx.Framework.Features.Drawing
{
    /// <summary>
    /// Tool used to erase a line drawn on a DrawableSurface
    /// </summary>
    public class ErasingTool : MonoBehaviour
    {
        [SerializeField]
        private List<DrawableSurface> surfaces = new List<DrawableSurface>();
        [SerializeField]
        private float eraseContactTime = 0.4f;

        private Vector3 lastPosition;
        private float timer = 0.0f;
        private DrawableSurface currentSurface = null;
        private Dictionary<Collider, DrawableSurface> colliderToSurfaceMap = new();

        private bool IsInContact => currentSurface != null;

        private void Awake()
        {
            InitMap();
        }

        private void InitMap()
        {
            foreach (DrawableSurface surface in surfaces)
            {
                colliderToSurfaceMap.Add(surface.Collider, surface);
            }
        }

        private void Update()
        {
            if (IsInContact)
            {
                UpdateContact();
            }
            lastPosition = transform.position;
        }

        private void UpdateContact()
        {
            if (transform.position != lastPosition)
            {
                timer += Time.deltaTime;
            }

            if (timer < eraseContactTime)
            {
                return;
            }

            timer = 0.0f;
            currentSurface.EraseNearestLine(transform.position);
        }

        private void OnCollisionEnter(Collision collision)
        {
            if(!colliderToSurfaceMap.TryGetValue(collision.collider, out DrawableSurface surface))
            {
                return;
            }

            if (!surface.IsErasable)
            {
                return;
            }

            timer = 0.0f;
            currentSurface = surface;
        }
        
        private void OnCollisionExit(Collision collision)
        {
            if (currentSurface == null || collision.collider != currentSurface.Collider)
            {
                return;
            }

            timer = 0.0f;
            currentSurface = null;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Drawing/ErasingTool.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/EventImageDisplay/EventImageCombo.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0e6b76ad9ad54c2583eb924b932f27d9
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Features.EventImageDisplay
{
    [Serializable]
    public class EventImageCombo
    {
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)] 
        public string showImageEvent;
        public string windowTitle;
        public Sprite imageSprite;
    }

    [Serializable]
    public class EventImageTextureCombo : EventImageCombo
    {
        public Texture texture;
    }

}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/EventImageDisplay/EventImageCombo.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/GhostController/GhostController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b427cca5cc3266c40922e005d22ea122
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Threading;
using Autohand;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Features.GhostController
{
    /// <summary>
    /// Animates and highlights specific actions on an example controller that follows the hand.
    /// </summary>
    public class GhostController : MonoBehaviour
    {
        private readonly static int TriggerPress = Animator.StringToHash( "TriggerPress");
        private readonly static int GripPress = Animator.StringToHash( "GripPress");
        private readonly static int MediaButtonPress = Animator.StringToHash( "MediaButtonPress");
        private readonly static int PicoButtonPress = Animator.StringToHash( "PicoButtonPress");
        private readonly static int PrimaryButtonPress = Animator.StringToHash( "PrimaryButtonPress");
        private readonly static int SecondaryButtonPressed = Animator.StringToHash( "SecondaryButtonPressed");
        private readonly static int JoystickSnapTurn = Animator.StringToHash( "JoystickSnapTurn");
        private readonly static int JoystickPull = Animator.StringToHash( "JoystickPull");
        private readonly static int JoystickRelease = Animator.StringToHash( "JoystickRelease");

        [SerializeField] private Animator animator;
        [SerializeField] private Grabbable grabbable;

        private Hand currentHand;
        private CancellationTokenSource cts;

        private void OnDisable()
        {
            cts?.SafeCancelAndDispose();
            
            SetAnimatorBoolean(TriggerPress, false);
            SetAnimatorBoolean(GripPress, false);
            SetAnimatorBoolean(MediaButtonPress, false);
            SetAnimatorBoolean(PicoButtonPress, false);
            SetAnimatorBoolean(PrimaryButtonPress, false);
            SetAnimatorBoolean(SecondaryButtonPressed, false);
            SetAnimatorBoolean(JoystickSnapTurn, false);
            SetAnimatorBoolean(JoystickRelease, false);
            SetAnimatorBoolean(JoystickPull, false);
        }
        
        public void ShowController(Hand hand, ControllerAction action)
        {
            currentHand = hand;
            gameObject.SetActive(true);
            cts?.SafeCancelAndDispose();
            cts = new CancellationTokenSource();
            ForceGrabControllerAsync(cts.Token).Forget();

            switch (action)
            {
                case ControllerAction.TriggerPress:
                    SetAnimatorBoolean(TriggerPress, true);
                    break;
                case ControllerAction.GripPress:
                    SetAnimatorBoolean(GripPress, true);
                    break;
                case ControllerAction.MediaButtonPress:
                    SetAnimatorBoolean(MediaButtonPress, true);
                    break;
                case ControllerAction.PicoButtonPress:
                    SetAnimatorBoolean(PicoButtonPress, true);
                    break;
                case ControllerAction.PrimaryButtonPress:
                    SetAnimatorBoolean(PrimaryButtonPress, true);
                    break;
                case ControllerAction.SecondaryButtonPress:
                    SetAnimatorBoolean(SecondaryButtonPressed, true);
                    break;
                case ControllerAction.JoystickPull:
                    SetAnimatorBoolean(JoystickPull, true);
                    break;
                case ControllerAction.JoystickRelease:
                    SetAnimatorBoolean(JoystickRelease, true);
                    break;
                case ControllerAction.JoystickSnapTurn:
                    SetAnimatorBoolean(JoystickSnapTurn, true);
                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(action), action, null);
            }
        }

        private async UniTaskVoid ForceGrabControllerAsync(CancellationToken token)
        {
            currentHand.ForceReleaseGrab();
            
            while (!grabbable.IsHeld() && !token.IsCancellationRequested)
            {
                transform.position = currentHand.transform.position;
                currentHand.ForceGrab(grabbable);
                await UniTask.Yield();
            }
        }  

        public void Hide()
        {
            cts?.SafeCancelAndDispose();
            gameObject.SetActive(false);
            if (currentHand != null && currentHand.IsGrabbing() && currentHand.GetHeldGrabbable() == grabbable)
            {
                currentHand.ForceReleaseGrab();
            }
        }
        
        private void SetAnimatorBoolean(int parameterName, bool value)
        {
            animator.SetBool(parameterName, value);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/GhostController/GhostController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/GhostController/GhostControllerDisplayModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 93a649050fe3df34c8a6fb1aa1e275ba
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Threading;
using Autohand;
using Autohand.Demo;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.Player.Hands;
using Ldx.Framework.Systems.Player.Input;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Features.GhostController
{
    public enum ControllerAction
    {
        TriggerPress = 0,
        GripPress = 1,
        MediaButtonPress = 2,
        PicoButtonPress = 3,
        PrimaryButtonPress = 4,
        SecondaryButtonPress = 5,
        JoystickPull = 6,
        JoystickRelease = 7,
        JoystickSnapTurn = 8,
    }
    
    /// <summary>
    /// Controls the displaying of controllers in the user's hands and animations of desired actions.
    /// </summary>
    public class GhostControllerDisplayModule : MonoBehaviour
    {
        [Header("Action Thresholds")]
        [SerializeField, Range(0.1f, 1f)] private float joystickActivationThreshold = 0.8f;
        [SerializeField, Range(0f, 0.5f)] private float joystickDeadzoneThreshold = 0.1f;
        
        private readonly Dictionary<HandSide, GhostController> ghostControllersByHandSideSet = new();
        private readonly Dictionary<HandSide, Hand> handSideHandSet = new();
        private readonly Dictionary<GhostController, XRHandControllerLink> controllerLinkByGhostControllerSet = new();
        private Dictionary<ControllerAction, Func<XRHandControllerLink, bool>> actionCheckers;

        private bool controllersActive;
        private string broadcastOnHide;
        private CancellationTokenSource cts;

        private void Awake()
        {
            LdxTrackingManager.OnAnyObjectiveEvent += HandleObjectiveEvent;
        }

        private void Start()
        {
            InitializeActionCheckers();
            
            ghostControllersByHandSideSet.Clear();
            handSideHandSet.Clear();
            controllerLinkByGhostControllerSet.Clear();
            
            foreach (HandSide side in Enum.GetValues(typeof(HandSide)))
            {
                GhostController controller = PlayerController.Instance.HandsController.GetGhostControllerByHandSide(side);
                ghostControllersByHandSideSet.Add(side, controller);
                handSideHandSet.Add(side, PlayerController.Instance.HandsController.GetHand(side));
                controllerLinkByGhostControllerSet.Add(controller, side == HandSide.Left ? ControllersInputModule.LeftHand : ControllersInputModule.RightHand);
            }
            
            HideAllControllers(false, true);
        }

        private void OnDestroy()
        {
            cts?.SafeCancelAndDispose();
            LdxTrackingManager.OnAnyObjectiveEvent -= HandleObjectiveEvent;
        }

        /// <summary>
        /// Populates the dictionary with functions that check for specific controller inputs.
        /// This is called once in Start(), so the logic is cached.
        /// </summary>
        private void InitializeActionCheckers()
        {
            actionCheckers = new Dictionary<ControllerAction, Func<XRHandControllerLink, bool>>
            {
                [ControllerAction.TriggerPress] = (link) => link.ButtonPressed(CommonButton.triggerButton),
                [ControllerAction.GripPress] = (link) => link.ButtonPressed(CommonButton.gripButton),
                [ControllerAction.PrimaryButtonPress] = (link) => link.ButtonPressed(CommonButton.primaryButton),
                [ControllerAction.SecondaryButtonPress] = (link) => link.ButtonPressed(CommonButton.secondaryButton),
                
                // NOTE: Mapping Media/Pico buttons to 'menuButton' as a common equivalent.
                // You may need to adjust this based on your actual controller mappings.
                [ControllerAction.MediaButtonPress] = (link) => link.ButtonPressed(CommonButton.menuButton),
                [ControllerAction.PicoButtonPress] = (link) => link.ButtonPressed(CommonButton.menuButton),

                // Analog stick actions
                [ControllerAction.JoystickPull] = (link) => link.GetAxis2D(Common2DAxis.primaryAxis).y < -joystickActivationThreshold,
                [ControllerAction.JoystickRelease] = (link) => link.GetAxis2D(Common2DAxis.primaryAxis).magnitude < joystickDeadzoneThreshold,
                [ControllerAction.JoystickSnapTurn] = (link) => Mathf.Abs(link.GetAxis2D(Common2DAxis.primaryAxis).x) > joystickActivationThreshold
            };
        }
        
        private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            switch (eventData)
            {
                case ShowDemonstrationControllerEventData data:
                    ProcessDemonstrationControllersEventData(data);
                    break;
                case HideDemonstrationControllersEventData data:
                    ProcessHideDemonstrationControllersEventData(data);
                    break;
            }
        }

        private void ProcessDemonstrationControllersEventData(ShowDemonstrationControllerEventData actionData)
        {
            HideAllControllers();
            controllersActive = true;
            broadcastOnHide = actionData.EventBroadcastOnHide;
            List<XRHandControllerLink> activeControllerLinks = new();
            
            foreach (HandSide side in actionData.HandSides)
            {
                if (ghostControllersByHandSideSet.TryGetValue(side, out GhostController controller) &&
                    handSideHandSet.TryGetValue(side, out Hand hand))
                {
                    controller.ShowController(hand, actionData.ActionToDemonstrate);
                    activeControllerLinks.Add(controllerLinkByGhostControllerSet[controller]);
                }
            }

            cts?.SafeCancelAndDispose();
            if (actionData.HideOnActionExecuted)
            {
                cts = new CancellationTokenSource();
                CheckForActionAsync(actionData.ActionToDemonstrate, activeControllerLinks, cts.Token).Forget();
            }
        }

        private async UniTaskVoid CheckForActionAsync(ControllerAction action,
            List<XRHandControllerLink> controllerLinks,
            CancellationToken token)
        {
            if (!actionCheckers.TryGetValue(action, out Func<XRHandControllerLink, bool> actionChecker))
            {
                Debug.LogError($"No action checker defined for {action}. Cannot check for input.", this);
                return;
            }
            
            bool actionWasPerformed = false;
            while (!token.IsCancellationRequested && !actionWasPerformed)
            {
                foreach (XRHandControllerLink controllerLink in controllerLinks)
                {
                    if (actionChecker(controllerLink))
                    {
                        actionWasPerformed = true;
                        break;
                    }
                }
                
                await UniTask.Yield();
            }
            
            if (actionWasPerformed)
            {
                HideAllControllers();
            }
        } 

        private void ProcessHideDemonstrationControllersEventData(HideDemonstrationControllersEventData actionData)
        {
            if (actionData.AnyControllers)
            {
                HideAllControllers();
            }
            else
            {
                foreach (HandSide side in actionData.HandSides)
                {
                    if (ghostControllersByHandSideSet.TryGetValue(side, out GhostController controller))
                    {
                        controller.Hide();
                    }
                }
            }
        }
        
        private void HideAllControllers(bool broadcastEvent = true, bool force = false)
        {
            cts?.SafeCancelAndDispose();
            
            if (!controllersActive && !force)
            {
                return;
            }
            
            controllersActive = false;
            
            foreach (GhostController controller in ghostControllersByHandSideSet.Values)
            {
                controller.Hide();
            }

            if (broadcastEvent)
            {
                LdxTrackingManager.Instance.BroadcastTrackingEvent(broadcastOnHide);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/GhostController/GhostControllerDisplayModule.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/GhostHandGuide/GhostHandGuide.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ce0eafe57c144a4286ccdc0a974bc5a3
# ASMDEF: ldx.framework.runtime.dll
# ---
using Cysharp.Threading.Tasks;
using DG.Tweening;
using HighlightPlus;
using JetBrains.Annotations;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Features.GhostHandGuide
{
    public class GhostHandGuide : MonoBehaviour
    {
        private const int INITIAL_DELAY = 1000;
        
        [SerializeField] private GameObject ghostHand;
        [SerializeField] private HighlightEffect ghostHandHighlight;

        private Transform startTransform;
        private bool displaying;
        private float spawnDist = .4572f;
        private float handSpeed = 1;
        private float restartDelay = 1;
        private Vector3 StartTransform
        {
            get
            {
                if (startTransform != null)
                {
                    return startTransform.position;
                }
                
                return mainCameraTransform.position + mainCameraTransform.forward.normalized * spawnDist;
            }
        }

        private Transform targetTransform;
        
        private Tween animateGhostHand;
        private Transform mainCameraTransform;

        private void Start()
        {
            mainCameraTransform = PlayerController.Instance.MainCamera.transform;
        }

        private void OnDestroy()
        {
            animateGhostHand?.Kill();
        }
        
        public void AnimateHand(Transform targetPoint, 
            float handSpeedData = 1, 
            float handDistanceData = 2, 
            float restartDelayData = 0.5f, 
            Transform startPoint = null)
        {
            handSpeed = handSpeedData;
            spawnDist = handDistanceData;
            restartDelay = restartDelayData;
            startTransform = startPoint ? startPoint 
                : transform;
            targetTransform = targetPoint;
            displaying = true;
            ghostHand.SetActive(true);
            ghostHandHighlight.SetHighlighted(true);
            AnimateHandTweenAsync().Forget();
        }

        public void AnimateHand(string targetPoint, 
            float handSpeedData, 
            float handDistanceData, 
            float restartDelayData, 
            [CanBeNull] string startPoint = null)
        {
            handSpeed = handSpeedData;
            spawnDist = handDistanceData;
            restartDelay = restartDelayData;
            startTransform = string.IsNullOrWhiteSpace(startPoint) ? null 
                : LdxReferenceIDTracker.Instance.GetTransform(startPoint);
            targetTransform = LdxReferenceIDTracker.Instance.GetTransform(targetPoint);
            displaying = true;
            ghostHand.SetActive(true);
            ghostHandHighlight.SetHighlighted(true);
            AnimateHandTweenAsync().Forget();
        }

        public void ResetHand()
        {
            ghostHandHighlight.SetHighlighted(false);
            ghostHand.SetActive(false);
            displaying = false;
            animateGhostHand?.Kill();
        }
        
        private async UniTaskVoid AnimateHandTweenAsync()
        {
            await UniTask.Delay(INITIAL_DELAY);
            animateGhostHand?.Kill();
            while (displaying)
            {
                animateGhostHand = DOTween.Sequence()
                    .Append(ghostHand.transform.DOMove(StartTransform, 0))
                    .Append(ghostHand.transform.DOMove(targetTransform.position, handSpeed))
                    .Join(ghostHand.transform.DORotateQuaternion(targetTransform.rotation, handSpeed))
                    .SetEase(Ease.InOutSine);
                await animateGhostHand.AsyncWaitForCompletion();
                await UniTask.Delay(restartDelay.ToMilliseconds()); // Switched to loop so position of start updates
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/GhostHandGuide/GhostHandGuide.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/GhostHandGuide/GhostHandGuideTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 31be994592a440e990142a2bfd12277c
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.Player.Hands;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;

namespace Ldx.Framework.Features.GhostHandGuide
{
    public class GhostHandGuideTracker : MonoBehaviour
    {
        [Serializable]
        public class GhostHandSettings
        {
            [HideInInspector] public string resetTrackingEvent;
            [HideInInspector] public bool resetOnObjectiveEnd;
            public GhostHandGuide ghostHandGuide;
        }
        
        [SerializeField] private SerializableDictionary<HandSide, GhostHandSettings> ghostHands = new();

        private void Start()
        {
            ScenarioManager.Instance.OnUnloadingScenarioOrLobby += HandleUnloadingScenarioOrLobby;
            ScenarioManager.Instance.OnScenarioStarted += HandleScenarioStarted;
            LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
            LdxTrackingManager.OnAnyObjectiveComplete += HandleObjectiveComplete;

            ResetGhostHands();
        }
        
        private void OnDestroy()
        {
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }
            
            LdxTrackingManager.OnAnyObjectiveComplete -= HandleObjectiveComplete;

            if (ScenarioManager.IsValid)
            {
                ScenarioManager.Instance.OnUnloadingScenarioOrLobby -= HandleUnloadingScenarioOrLobby;
                ScenarioManager.Instance.OnScenarioStarted -= HandleScenarioStarted;
            }
        }

        private void HandleScenarioStarted(ScenarioManager scenarioManager, ScenarioDataType data)
        {
            LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
        }
        
        private void HandleUnloadingScenarioOrLobby(ScenarioManager scenarioManager)
        {
            LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
        }
        
        private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            if (eventData is GhostHandGuideEventData actionData)
            {
                ShowGhostHand(actionData);
            }
        }
        
        private void HandleTrackingEvent(string eventId)
        {
            foreach (KeyValuePair<HandSide, GhostHandSettings> ghostHand in ghostHands)
            {
                if (eventId == ghostHand.Value.resetTrackingEvent)
                {
                    ResetGhostHand(ghostHand.Key);
                }
            }
        }
        
        private void HandleObjectiveComplete(IObjective obj)
        {
            foreach (KeyValuePair<HandSide, GhostHandSettings> ghostHand in ghostHands)
            {
                if (ghostHand.Value.resetOnObjectiveEnd)
                {
                    ResetGhostHand(ghostHand.Key);
                }
            }
        }

        private void ShowGhostHand(GhostHandGuideEventData eventData)
        {
            if (ghostHands.TryGetValue(eventData.HandSide, out GhostHandSettings ghostHandSettings))
            {
                if (!string.IsNullOrEmpty(eventData.ResetTrackingEvent))
                {
                    ghostHandSettings.resetTrackingEvent = eventData.ResetTrackingEvent;
                }

                if (eventData.ResetOnObjectiveEnd)
                {
                    ghostHandSettings.resetOnObjectiveEnd = eventData.ResetOnObjectiveEnd;
                }

                if (ghostHandSettings.ghostHandGuide != null)
                {
                    ghostHandSettings.ghostHandGuide.AnimateHand(eventData.TargetPosition, eventData.HandMoveTime, 
                        eventData.HandDistanceFromEyes, eventData.RestartDelay,  
                        eventData.StartPositionType == GhostHandGuideEventData.StartPositionTypes.StartTransform 
                            ? eventData.StartPosition : null);
                }
            }
        }

        private void ResetGhostHands()
        {
            foreach (KeyValuePair<HandSide,GhostHandSettings> ghostHand in ghostHands)
            {
                ResetGhostHand(ghostHand.Key);
            }
        }
        
        private void ResetGhostHand(HandSide handSide)
        {
            if (ghostHands.TryGetValue(handSide, out GhostHandSettings ghostHandSettings))
            {
                ghostHandSettings.resetTrackingEvent = string.Empty;
                ghostHandSettings.resetOnObjectiveEnd = false;

                if (ghostHandSettings.ghostHandGuide != null)
                {
                    ghostHandSettings.ghostHandGuide.ResetHand();
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/GhostHandGuide/GhostHandGuideTracker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Hazards/DangerTrigger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 643b1d15fb0d42dcaffff3d457653b7e
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using UnityEngine;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine.Serialization;

namespace Ldx.Framework.Features.Hazards
{
    public enum DangerType
    {
        Electrocution,
        Falling,
        Drowning,
        Fire,
        GeneralWarning
    }

    [RequireComponent(typeof(Collider))]
    public class DangerTrigger : MonoBehaviour
    {
        private const int WARNING_CHECK_FRAMES = 60; // Because transform position moves are unreliable

        public static event Action<DangerTrigger> OnEnterDangerZone;
        public static event Action<DangerTrigger> OnExitDangerZone;

        [SerializeField] private DangerType dangerType = DangerType.Electrocution;
        public DangerType DangerType => dangerType;

        [SerializeField] private bool vibrateHands = true;
        public bool VibrateHands => vibrateHands;

        [SerializeField] private bool flashScreen = true;
        public bool FlashScreen => flashScreen;

        [SerializeField] private bool restartScene;
        public bool RestartScene => restartScene;

        [SerializeField] private float minTimeBetween = 3f;

        [FormerlySerializedAs("eventOnTriggered")] 
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)] 
        [SerializeField] private string eventOnEnterTrigger;

        [IDSelection(LdxIdSettings.IdType.TrackingEvent)] 
        [SerializeField] private string eventOnExitTrigger;

        private float nextTimer;
        private bool entered;
        private Collider enteredCollider;
        private Collider thisCollider;

        private void Start()
        {
            thisCollider = GetComponent<Collider>();
        }

        private void Update()
        {
            if (!entered)
            {
                return;
            }

            WarningCheck();
        }

        private void WarningCheck()
        {
            // Check every x frames for optimization's sake
            if (Time.frameCount % WARNING_CHECK_FRAMES == 0)
            {
                if (enteredCollider != null && thisCollider != null)
                {
                    // Check if enteredCollider is still within thisCollider
                    if (thisCollider.bounds.Intersects(enteredCollider.bounds))
                    {
                        return;
                    }

                    CallExit();
                }
            }
        }

        private void CallExit()
        {
            // Adding an extra entered check, just in the event that code is changed in the future.
            if (!entered)
                return;
            
            OnExitDangerZone?.Invoke(this);
            LdxTrackingManager.Instance.BroadcastTrackingEvent(eventOnExitTrigger);
            entered = false;
            enteredCollider = null;
        }

        private void OnTriggerEnter(Collider other)
        {
            if (Time.time < nextTimer)
                return;

            if (((1 << other.gameObject.layer) & DangerTriggerController.Instance.LayersToDetect) != 0)
            {
                if (other.isTrigger)
                    return;

                OnEnterDangerZone?.Invoke(this);
                LdxTrackingManager.Instance.BroadcastTrackingEvent(eventOnEnterTrigger);
                nextTimer = Time.time + minTimeBetween;
                entered = true;
                enteredCollider = other;
            }
        }

        private void OnTriggerExit(Collider other)
        {
            if (!entered || other.isTrigger || other != enteredCollider)
                return;

            CallExit();
        }

        #region Testing

        [ContextMenu("Test danger zone")]
        public void TestTriggerEnter()
        {
            OnEnterDangerZone?.Invoke(this);
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Hazards/DangerTrigger.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Hazards/DangerTriggerController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c8676c86233ecd647b78f10300dab18b
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Threading.Tasks;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.UI;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using Debug = Ldx.Framework.Utilities.Logging.Debug;
using Quaternion = UnityEngine.Quaternion;

namespace Ldx.Framework.Features.Hazards
{
    public class DangerTriggerController : Singleton<DangerTriggerController>
    {
        [SerializeField][SoundReference] private string electrocutionSound;

        [SerializeField] private GameObject fxOnElectrocution;

        [SerializeField] private LayerMask layersToDetect;
        public LayerMask LayersToDetect => layersToDetect;

        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField]
        private string eventOnTriggered;

        private void Start()
        {
            DangerTrigger.OnEnterDangerZone += HandleEnterDangerZone;
        }

        private void OnDestroy()
        {
            DangerTrigger.OnEnterDangerZone -= HandleEnterDangerZone;
        }

        private async void HandleEnterDangerZone(DangerTrigger dangerTrigger)
        {
            if (dangerTrigger.DangerType == DangerType.Electrocution)
            {
                if (electrocutionSound != null)
                {
                    Audio.PlayOneShot(electrocutionSound);
                }

                if (fxOnElectrocution != null)
                {
                    Instantiate(fxOnElectrocution, dangerTrigger.transform.position, Quaternion.identity);
                }

                if (dangerTrigger.VibrateHands)
                {
                    PlayerController.Instance.HandsController.VibrateHands(duration: 1.5f);
                }

                if (dangerTrigger.FlashScreen)
                {
                    UIController.Instance.FadeOutScreen(overrideTime: 1f);
                    await Task.Delay(TimeSpan.FromSeconds(1.5f));

                    if (!dangerTrigger.RestartScene)
                        UIController.Instance.FadeInScreen(overrideTime: 2f);
                }

                if (dangerTrigger.RestartScene)
                {
                    await Task.Delay(TimeSpan.FromSeconds(1));
                    ScenarioManager.Instance.ReloadCurrentScenario();
                }

                LdxTrackingManager.Instance.BroadcastTrackingEvent(eventOnTriggered);
                Debug.LogVerbose("Called Handle Enter Danger Zone!");
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Hazards/DangerTriggerController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Hazards/InvisibleHazard.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7d0db6aa93b04b2e927b19482c13f24a
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Features.Highlighting;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Features.Hazards
{
    /// <summary>
    /// Controller for an invisible hazard
    /// </summary>
    public class InvisibleHazard : MonoBehaviour
    {
        public event Action<InvisibleHazard> OnHazardIdentified; 

        [SerializeField]
        private HighlightableObject modalHighlighter;

        [SerializeField]
        private List<MeshRenderer> meshRenderers = new List<MeshRenderer>();
        public List<MeshRenderer> MeshRenderers => meshRenderers;

        private void Awake()
        {
            modalHighlighter.OnHighlightingFinished += HandleHighlightingFinished;
        }

        private void OnDestroy()
        {
            modalHighlighter.OnHighlightingFinished -= HandleHighlightingFinished;
        }

        public void SetAlpha(float a)
        {
            foreach (MeshRenderer r in meshRenderers)
            {
                r.sharedMaterial.color = r.sharedMaterial.color.Modify(a: a);
            }
        }

        private void HandleHighlightingFinished(HighlightableObject highlighter)
        {
            OnHazardIdentified?.Invoke(this);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Hazards/InvisibleHazard.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Hazards/InvisibleHazardsController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: da0c3a6149f74473936afd681bc5c975
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Features.Hazards
{
    /// <summary>
    /// Controller for invisible hazards, syncs their visibility animation
    /// </summary>
    public class InvisibleHazardsController : MonoBehaviour
    {
        readonly private List<InvisibleHazard> activeInvisibleHazards = new List<InvisibleHazard>();
        
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string eventToActivate;
        [SerializeField] private float maxAlpha = 0.5f;
        [SerializeField] private float duration = 1;
        [SerializeField] private InvisibleHazard[] invisibleHazards;

        private float alpha;
        private float timer;
        private bool isShowing = true;

        private bool IsActive { get; set; }

        private void Awake()
        {
            LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
        }
        
        private void Start()
        {
            foreach (InvisibleHazard r in invisibleHazards)
            {
                AddActiveHazard(r);
            }
        }
        
        private void OnDestroy()
        {
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }

            foreach (InvisibleHazard hazard in activeInvisibleHazards)
            {
                hazard.OnHazardIdentified -= HandleHazardIdentified;
            }
        }

        public void Activate()
        {
            IsActive = true;
        }

        private void HandleTrackingEvent(string id)
        {
            if (id == eventToActivate)
            {
                Activate();
            }
        }

        private void AddActiveHazard(InvisibleHazard hazard)
        {
            if (hazard == null)
            {
                return;
            }
            
            hazard.OnHazardIdentified += HandleHazardIdentified;
            activeInvisibleHazards.Add(hazard);
        }
        
        private void HandleHazardIdentified(InvisibleHazard hazard)
        {
            hazard.OnHazardIdentified -= HandleHazardIdentified;
            hazard.SetAlpha(maxAlpha);
            activeInvisibleHazards.Remove(hazard);
        }

        private void Update()
        {
            UpdateColor();
            foreach (InvisibleHazard r in activeInvisibleHazards)
            {
                r.SetAlpha(alpha);
            }
        }

        private void UpdateColor()
        {
            if (!IsActive)
            {
                alpha = 0.0f;
                return;
            }

            timer += Time.deltaTime;
            if (timer >= duration)
            {
                timer = 0.0f;
                isShowing = !isShowing;
            }

            float t = isShowing ? (timer / duration) : 1 - (timer / duration);
            alpha = Mathf.Lerp(0, maxAlpha, t);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Hazards/InvisibleHazardsController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Hazards/LdxHazardTypeReporter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 15508576b5b047bb8269562f8ad6ec6b
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Features.Hazards
{
    /// <summary>
    /// When a hazard is identified, this reports an event with its type
    /// </summary>
    public class LdxHazardTypeReporter : MonoBehaviour
    {
        public enum HazardTypes
        {
            Tripping = 0,
            FallingHazard,
            UnsafeEquipment,
            FallingObject,
            ImproperInstallation
        }

        public static event Action<HazardTypes> OnAnyHazardIdentified;
        public event Action<LdxHazardTypeReporter> OnHazardIdentified;

        [SerializeField]
        private HazardTypes hazardType = HazardTypes.Tripping;
        
        private void HandleAnswered()
        {
            OnAnyHazardIdentified?.Invoke(hazardType);   
            OnHazardIdentified?.Invoke(this);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Hazards/LdxHazardTypeReporter.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Hierarchy/HierarchyInfo.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c01e25d71385475d95f66af79d5e4c94
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;

namespace Ldx.Framework.Features.Hierarchy
{
    /// <summary>
    /// Info of hierarchy state
    /// </summary>
    [Serializable]
    public class HierarchyInfo
    {
        [SerializeField]
        private string name;
        public string Name
        {
            get => name;
            set => name = value;
        }

        [Hide]
        [SerializeField]
        private SerializableDictionary<GameObject, bool> objectToStateMap = new();
        public SerializableDictionary<GameObject, bool> ObjectToStateMap => objectToStateMap;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Hierarchy/HierarchyInfo.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Hierarchy/HierarchyStateSaver.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 098a9622ce6e489cab387458cd364f5b
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Ldx.Framework.Features.Hierarchy
{
    /// <summary>
    /// A script for saving/applying the hierarchy state
    /// </summary>
    public class HierarchyStateSaver : MonoBehaviour
    {
        [SerializeField]
        private List<GameObject> trackedParentObjects = new();

        [SerializeField]
        private List<HierarchyInfo> hierarchyInfoList = new List<HierarchyInfo>();
        public List<HierarchyInfo> HierarchyInfoList => hierarchyInfoList;


#if UNITY_EDITOR
        public void EDITOR_CaptureState(HierarchyInfo info)
        {
            info.ObjectToStateMap.Clear();
            foreach (Transform[] transforms in trackedParentObjects.Select(o => o.GetComponentsInChildren<Transform>(includeInactive:true)))
            {
                foreach (Transform t in transforms)
                {
                    info.ObjectToStateMap.Add(t.gameObject, t.gameObject.activeSelf);
                }
            }
        }

        public void EDITOR_ApplyState(HierarchyInfo info)
        {
            foreach (GameObject obj in info.ObjectToStateMap.Keys)
            {
                if (obj == null)
                {
                    continue;
                }

                bool state = info.ObjectToStateMap[obj];
                if (obj.activeSelf == state)
                {
                    continue;
                }

                UnityEditor.Undo.RecordObject (obj, "Changed object active");
                obj.SetActive(state);
            }
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Hierarchy/HierarchyStateSaver.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/HighlightableObject.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bb100fdd9464421fab54fd20ba1224a8
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using HighlightPlus;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Misc;
using Ldx.Framework.Systems.UI.HighlightProcessors;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Ldx.Framework.Features.Highlighting
{
    public enum HighlightingMode
    {
        HoverOnly,
        HoverAndIdentification
    }

    /// <summary>
    /// Represents a modal highlighter for objects in the scene.
    /// </summary>
    [TrackedReference]
    [DisallowMultipleComponent]
    public class HighlightableObject : MonoBehaviour, ISaveSceneListener
    {
        private const float MIN_AMOUNT_OF_TIME_BEFORE_PLAYING_HOVER_SOUND = 0.5f;
        
        private static float lastHoverSoundTime;
        
        /// <summary>
        /// Event triggered when the highlighting is finished.
        /// </summary>
        public event Action<HighlightableObject> OnHighlightingFinished;

        public event Action<HighlightableObject> OnHighlightingStarted;
        public event Action<HighlightableObject, bool> OnHoverStateChanged;
        public event Action<HighlightableObject, HighlightProfile> OnHighlightProfileChanged;

        [IDSelection(LdxIdSettings.IdType.Dialog)] [SerializeField]
        private string dialogId;

        /// <summary>
        /// Gets or sets the dialog ID associated with the highlighter.
        /// </summary>
        public string DialogID
        {
            get => dialogId;
            set => dialogId = value;
        }
        
        [SerializeField] 
        private HighlightingMode mode = HighlightingMode.HoverAndIdentification;
        public HighlightingMode Mode => mode;

        [SerializeField] private bool displayDescription;
        public bool DisplayDescription => displayDescription;

        [SerializeField][LocalizationKey]
        private string description;
        public string Description => description;

        [SerializeField] private Vector3 descriptionWindowOffset = Vector3.up;
        public Vector3 DescriptionWindowOffset => descriptionWindowOffset;

        [SerializeField] private bool highlightCorrectOnFinish;

        [SerializeField] private HighlightEffect outline;

        [SerializeField] private List<HighlightEffect> additionalOutlines = new List<HighlightEffect>();

        [SerializeField] private bool allowReopen;

        [SerializeField] private bool playSoundEffectOnHover = true;

        [SerializeField] private bool activateOnStart = false;

        [SerializeField] private bool overrideStartHighlightProfile;

        [SerializeField] private HighlightProfile profileToOverrideWithOnStart;

        [SerializeField][ReadOnly]
        private bool highlightingEnabled = false;
        private bool didBroadcastHighlight;
        private HighlightProfile currentProfile;
        private bool isHovered;

        public HighlightProcessor HighlightProcessor { get; private set; }
        private LdxTrackingManager TrackingManager => LdxTrackingManager.Instance;
        public bool DeselectOnFinished => string.IsNullOrEmpty(dialogId) || DeselectOnFinishedOverrideNullable == true;

        public bool HighlightingEnabled => highlightingEnabled;

        public bool FinishedHighlighting => didBroadcastHighlight;

        /// <summary>
        /// Optional override for deselecting once finished.
        /// </summary>
        public bool? DeselectOnFinishedOverrideNullable { get; set; }

        public bool CanHighlight => CanBroadcastHighlightFinished && !FinishedHighlighting && HighlightingEnabled;
        private bool PreventingReopenAfterBroadcasting => !allowReopen && didBroadcastHighlight;
        public bool CanBroadcastHighlightFinished => !PreventingReopenAfterBroadcasting && HighlightingEnabled;

        private void OnValidate()
        {
            AssignReferences();
        }

        public void OnSceneSaving()
        {
            AssignReferences();
#if UNITY_EDITOR
            EDITOR_SanitizeSetup();
#endif
        }

        private void AssignReferences()
        {
            if (outline == null)
            {
                outline = GetComponent<HighlightEffect>();
            }
        }

        private void Awake()
        {
            Initialize();
        }

        private void Initialize()
        {
            if (HighlightProcessor != null)
            {
                return;
            }
            
            switch (HighlightingGlobalSettings.HighlightingMethod)
            {
                case HighlightingMethod.HighlightPlus:
                    if (outline == null)
                    {
                        outline = gameObject.GetOrAddComponent<HighlightEffect>();
                    }

                    HighlightEffect hoverHighlightEffect = outline;
                    
                    if (overrideStartHighlightProfile && profileToOverrideWithOnStart != null)
                    {
                        hoverHighlightEffect.ProfileLoad(profileToOverrideWithOnStart);
                    }
                    else
                    {
                        hoverHighlightEffect.ProfileLoad(HighlightingGlobalSettings.HoverHighlightingProfile);
                    }
                    
                    HighlightProcessor =
                        new HighlightPlusProcessor(new HighlightPlusProcessorParam(outline, hoverHighlightEffect));
                    break;
                case HighlightingMethod.Outline:
                    if (outline != null)
                    {
                        outline.enabled = false;
                    }

                    Outline outlineHighlight = gameObject.AddComponent<Outline>();
                    outlineHighlight.OutlineMode = Outline.Mode.OutlineVisible;
                    HighlightProcessor = new HighlightOutlineProcessor(
                        new HighlightOutlineProcessorParam(outlineHighlight,
                            HighlightingGlobalSettings.HoverHighlightingProfile));
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            HighlightProcessor.Initialize();
        }

        private void Start()
        {
            if (activateOnStart)
            {
                SetHighlightingEnabled(true);
            }
        }

        private void OnDestroy()
        {
            HighlightProcessor?.Terminate();
        }

        /// <summary>
        /// Signals that the highlight has finished.
        /// </summary>
        public void HighlightFinished()
        {
            if (string.IsNullOrEmpty(DialogID) || !CanBroadcastHighlightFinished)
            {
                return;
            }

            if (highlightCorrectOnFinish)
            {
                SetCorrectHighlighterProfile();
                if (HighlightProcessor.IsHighlighted)
                {
                    WaitThenEnableHighlighter().Forget();
                }
            }

            TrackingManager.BroadcastDialogHighlighterActivated(DialogID);
            OnHighlightingFinished?.Invoke(this);
            didBroadcastHighlight = true;
        }

        public void SetNewOverrideProfile(HighlightProfile newOverrideProfile)
        {
            overrideStartHighlightProfile = true;
            profileToOverrideWithOnStart = newOverrideProfile;
        }

        private async UniTaskVoid WaitThenEnableHighlighter()
        {
            await UniTask.WaitUntil(() => !HighlightProcessor.IsHighlighted);
            EnableHighlighter(force: true);
        }

        #region Profiles

        /// <summary>
        /// Sets the profile using the correct highlighting profile from HighlightingGlobalSettings.
        /// </summary>
        public void SetCorrectHighlighterProfile()
        {
            SetHighlightingProfile(HighlightingGlobalSettings.CorrectHighlightingProfile);
        }

        /// <summary>
        /// Sets the profile using the wrong highlighting profile from HighlightingGlobalSettings.
        /// </summary>
        public void SetWrongHighlighterProfile()
        {
            SetHighlightingProfile(HighlightingGlobalSettings.WrongHighlightingProfile);
        }

        /// <summary>
        /// Sets the highlighting profile for the object.
        /// If the given profile is the same as the current profile, no changes are made.
        /// Otherwise, it updates the current profile and applies it to the outline.
        /// </summary>
        /// <param name="profile">The highlighting profile to be set.</param>
        public void SetHighlightingProfile(HighlightProfile profile)
        {
            if (currentProfile == profile)
            {
                return;
            }

            currentProfile = profile;
            HighlightProcessor.SetHighlightingProfile(currentProfile);
            OnHighlightProfileChanged?.Invoke(this, profile);
        }

        #endregion
        
        #region Tooltip

        public void OverrideTooltip(bool display, string tooltip)
        {
            displayDescription = display;
            description = tooltip;
        }

        #endregion

        #region Hover

        /// <summary>
        /// Enables the hover highlight effect.
        /// </summary>
        public void EnableHoverHighlight()
        {
            if (isHovered)
            {
                return;
            }

            isHovered = true;
            HighlightProcessor.SetHoverHighlightState(true);
            
            if (playSoundEffectOnHover)
            {
                float now = Time.time;
                if (now - lastHoverSoundTime < MIN_AMOUNT_OF_TIME_BEFORE_PLAYING_HOVER_SOUND)
                {
                    return;
                }

                lastHoverSoundTime = now;
                Audio.PlayOneShot(HighlightingGlobalSettings.HoverSound);
            }
            
            OnHoverStateChanged?.Invoke(this, true);
        }

        /// <summary>
        /// Disables the hover highlight effect.
        /// </summary>
        public void DisableHoverHighlight(bool force = false)
        {
            if (!isHovered && !force)
            {
                return;
            }

            isHovered = false;
            HighlightProcessor.SetHoverHighlightState(false);
            OnHoverStateChanged?.Invoke(this, false);
        }

        #endregion

        /// <summary>
        /// Enables the main highlight effect.
        /// </summary>
        [ContextMenu("Enable Highlight")]
        public void EnableHighlighter(bool force = false)
        {
            if (HighlightProcessor == null)
            {
                Initialize();
            }

            if (!force && HighlightProcessor.IsHighlighted && !HighlightProcessor.IsHovered)
            {
                return;
            }

            HighlightProcessor.EnableHighlighter();

            foreach (HighlightEffect highlight in additionalOutlines)
            {
                highlight.profile = currentProfile;
                highlight.fadeInDuration = HighlightingGlobalSettings.HighlightingFadeDuration;
                highlight.highlighted = true;
            }

            OnHighlightingStarted?.Invoke(this);
        }

        /// <summary>
        /// Resets the highlighter to its initial state.
        /// </summary>
        /// <param name="resetDidBroadcast">If true, resets the broadcasting status.</param>
        /// <param name="setEnabled">If true, sets the highlighter to enabled</param>
        public void ResetHighlighter(bool resetDidBroadcast = false, bool setEnabled = false)
        {
            if (resetDidBroadcast)
            {
                didBroadcastHighlight = false;
            }

            HighlightProcessor.ResetHighlighter();
            
            foreach (HighlightEffect highlight in additionalOutlines)
            {
                highlight.profile = outline.profile;
                highlight.fadeOutDuration = HighlightingGlobalSettings.TimeToHold;
                highlight.highlighted = false;
            }
            
            SetHighlightingEnabled(setEnabled);
            
            currentProfile = HighlightingGlobalSettings.CorrectHighlightingProfile;
            HighlightProcessor.SetHighlightingProfile(HighlightingGlobalSettings.HoverHighlightingProfile);

            DisableHoverHighlight(true);
        }
        
        public void SetHighlightingEnabled(bool setEnabled)
        {
            highlightingEnabled = setEnabled;
        }

#if UNITY_EDITOR
        private void EDITOR_SanitizeSetup()
        {
            int highlightLayer = HighlightingGlobalSettings.GetHighlightingLayer();
            if (highlightLayer == -1 || highlightLayer == 0)
            {
                return;
            }
            
            bool isWrongLayer = gameObject.layer != highlightLayer;
            bool isStatic = gameObject.isStatic;

            List<string> warnings = new();
            
            if (isWrongLayer)
            {
                warnings.Add("Object is not on the correct layer");
            }

            if (isStatic)
            {
                warnings.Add("Object is static");
            }

            if (warnings.Count < 1)
            {
                return;
            }

            string message = $"Found the following issues with identification setup of object \"{gameObject.name}\":\n";
            
            foreach (string w in warnings)
            {
                message += $"\t-{w}\n";
            }

            message += "\nWould you like to apply fixes?";

            if (!EditorUtility.DisplayDialog("Warning", message, "Ok", "Cancel"))
            {
                return;
            }

            if (isStatic)
            {
                gameObject.isStatic = false;
                foreach (Transform t in transform)
                {
                    t.gameObject.isStatic = false;
                }
            }

            if (isWrongLayer)
            {
                gameObject.layer = highlightLayer;
                foreach (Transform t in transform)
                {
                    t.gameObject.layer = highlightLayer;
                }
            }
            EditorUtility.SetDirty(gameObject);
            EditorUtility.DisplayDialog("Success", $"Setup fixes applied to \"{gameObject.name}\"", "Ok");
            Selection.activeObject = gameObject;
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/HighlightableObject.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/HighlightingGlobalSettings.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8a8ee9f24b494b0e8a2c04553113ef80
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using HighlightPlus;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Ldx.Framework.Features.Highlighting
{
    [HasFrameworkDefault]
    public class HighlightingGlobalSettings : GlobalSettings<HighlightingGlobalSettings>
    {
#if UNITY_EDITOR
        private static readonly string[] possibleLayerPrefixes = 
        { 
            "ObjectLayer", "Object Layer", 
            "Identifiable", "Identification", "Identify",
            "Highlightable", "Highlighting", "Highlight"
        };
#endif
        
        [SerializeField] private Material hologramMaterial;
        public static Material HologramMaterial => Instance.hologramMaterial;

        [Tooltip("This is the tool or package used for identification.")]
        [SerializeField] private HighlightingMethod highlightingMethod;
        public static HighlightingMethod HighlightingMethod => Instance.highlightingMethod;
        
        [Tooltip("This is the layer that identifiable objects MUST be on.")]
        [SerializeField] private LayerMask objectTargetLayer;
        public static LayerMask ObjectTargetLayer => Instance.objectTargetLayer;
        
        [SerializeField] private HighlightProfile selectedHighlightingProfile;
        public static HighlightProfile SelectedHighlightingProfile => Instance.selectedHighlightingProfile;
        
        [SerializeField] private HighlightProfile correctHighlightingProfile;
        public static HighlightProfile CorrectHighlightingProfile => Instance.correctHighlightingProfile;
        
        [SerializeField] private HighlightProfile wrongHighlightingProfile;
        public static HighlightProfile WrongHighlightingProfile => Instance.wrongHighlightingProfile;

        [SerializeField] private bool shouldHoldToHighlight;
        public static bool ShouldHoldToHighlight => Instance.shouldHoldToHighlight;
        
        [ShowIf("shouldHoldToHighlight", Op.Equals, true)]
        [Tooltip("This is how long the player must hold the button in order to ID an object (1s by default)")]
        [Min(0f)]
        [SerializeField] private float timeToHold = 1f;
        public static float TimeToHold => ShouldHoldToHighlight? Instance.timeToHold : 0;

        [SerializeField] private float minHighlightingFadeDuration = 0.25f;
        public static float MinHighlightingFadeDuration => Instance.minHighlightingFadeDuration;

        public static float HighlightingFadeDuration => Mathf.Max(TimeToHold, MinHighlightingFadeDuration);

        [Header("Highlighting line")]
        [SerializeField] private Material idMaterial;
        public static Material IDMaterial => Instance.idMaterial;

        [SerializeField] private AnimationCurve idCurve = AnimationCurve.Linear(0f, 1f, 1f, 1f);
        public static AnimationCurve IDCurve => Instance.idCurve;
        
        [Header("Hover")]
        [SerializeField] private bool showHoverHighlight = true;
        public static bool ShowHoverHighlight => Instance.showHoverHighlight;

        [SerializeField] private HighlightProfile hoverHighlightingProfile;
        public static HighlightProfile HoverHighlightingProfile => Instance.hoverHighlightingProfile;
        
        [SoundReference] [SerializeField] private string hoverSound;
        public static string HoverSound => Instance.hoverSound;

        [Header("Audio")] 
        [SoundReference] [SerializeField]
        private string simpleHazardContinueAudio;
        public static string SimpleHazardContinueAudio => Instance.simpleHazardContinueAudio;
        
        [Serializable]
        public enum PointingSource
        {
            Camera = 0, // only left hand will be used
            LeftHand,
            RightHand,
            BothHands
        }
        
        [Header("Controls")]
        [SerializeField]
        private PointingSource highlightingPointingSource = PointingSource.BothHands;
        public static PointingSource HighlightingPointingSource => Instance.highlightingPointingSource;

        public static int GetHighlightingLayer()
        {
            ObjectTargetLayer.TryGetFirstLayer(out int layer);
            return layer;
        }
        
#if UNITY_EDITOR
        [SettingsProvider]
        public static SettingsProvider CreateSettingsProvider()
        {
            return CreateGlobalSettingsProvider("Project/LDX/Systems/Highlighting");
        }

        // NOTE: called on save by HighlightingLayerSanitizationSavingAddOn
        public static void EDITOR_AutoSanitizeHighlightLayer()
        {
            int currentLayer = GetHighlightingLayer();
            
            // Check if not default layer or no layer, means it was set before
            if (currentLayer != 0 && currentLayer != -1)
            {
                return;
            }

            int highlightLayer = findHighlightLayer();
            if (highlightLayer == -1)
            {
                if (EditorUtility.DisplayDialog("Warning",
                        "Highlighting layer is set to Default. Tried to correct it but couldn't find matching layer.\n" +
                        "Would you like to review manually?", "Ok", "Cancel"))
                {
                    Selection.activeObject = Instance;
                }
                return;
            }
            
            Instance.objectTargetLayer = 1 << highlightLayer;
            
            EditorUtility.SetDirty(Instance);
            
            EditorUtility.DisplayDialog("Message", $"HighlightingGlobalSettings layer was corrected to:" +
                                                   $" \"{LayerMask.LayerToName(highlightLayer)}\"", "Ok");

            int findHighlightLayer()
            {
                // Find the highlighting layer 
                // Maximum layer index is 31
                for (int i = 0; i < 32; i++)
                {
                    string layerName = LayerMask.LayerToName(i);
                    
                    if (String.IsNullOrEmpty(layerName))
                    {
                        continue;
                    }

                    foreach (string prefix in possibleLayerPrefixes)
                    {
                        if (layerName.StartsWith(prefix))
                        {
                            return i;
                        }
                    }
                }

                return -1;
            }
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/HighlightingGlobalSettings.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/HighlightingLineRenderer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 18cca9fa12ed45a68430a3c2dcbf425e
# ASMDEF: ldx.framework.runtime.dll
# ---
using Cysharp.Threading.Tasks;
using UnityEngine;

namespace Ldx.Framework.Features.Highlighting
{
    ///<summary>
    /// Represents a specialized LineRenderer for highlighting purposes.
    /// This class manages the properties and behaviors of the LineRenderer for effective highlighting.
    ///</summary>
    [RequireComponent(typeof(LineRenderer))]
    public class HighlightingLineRenderer : MonoBehaviour
    {
        [SerializeField]
        private LineRenderer lineRenderer;

        private Transform startingPoint;
        private Vector3 lastEndPosition = Vector3.zero;

        public Vector3 StartPosition => startingPoint != null ? startingPoint.position : Vector3.zero;
        public Vector3 EndPosition => lastEndPosition;
        public bool IsEnabled => gameObject.activeSelf;

        private void Awake()
        {
            lineRenderer = GetComponent<LineRenderer>();
            SetupLineRenderer();
            EnableLineRenderer(false);
        }

        private void OnEnable()
        {
            UpdateLineRendererStartPointAsync().Forget();
        }

        private void OnDestroy()
        {
            UpdateLineRendererStartPointAsync().Forget();
        }

        ///<summary>
        /// Setup the properties for the line renderer component.
        ///</summary>
        private void SetupLineRenderer()
        {
            lineRenderer.material = HighlightingGlobalSettings.IDMaterial;
            lineRenderer.widthCurve = HighlightingGlobalSettings.IDCurve;
        }

        [ContextMenu("Disable")]
        public void DisableLineRenderer()
        {
            EnableLineRenderer(false);
        }
        
        [ContextMenu("Enable")]
        public void EnableLineRenderer()
        {
            EnableLineRenderer(true);
        }

        ///<summary>
        /// Enables or disables the LineRenderer based on the provided state.
        /// </summary>
        /// <param name="setEnabled">State to set the LineRenderer's enabled property to.</param>
        public void EnableLineRenderer(bool setEnabled)
        {
            if (gameObject.activeSelf == setEnabled)
            {
                return;
            }
            
            gameObject.SetActive(setEnabled);
        }

        ///<summary>
        /// Sets the starting position of the LineRenderer.
        /// </summary>
        private async UniTaskVoid UpdateLineRendererStartPointAsync()
        {
            while (lineRenderer != null && gameObject.activeSelf)
            {
                if (startingPoint != null)
                {
                    lineRenderer.SetPosition(0, startingPoint.position);
                }

                await UniTask.Yield();
            }
        }
        
        ///<summary>
        /// Sets the ending position of the LineRenderer.
        /// </summary>
        /// <param name="start">Starting transform for the line.</param>
        public void SetLineRendererStartPoint(Transform start)
        {
            startingPoint = start;
        }

        ///<summary>
        /// Sets the ending position of the LineRenderer.
        /// </summary>
        /// <param name="end">Ending position vector for the line.</param>
        public void SetLineRendererEndPoint(Vector3 end)
        {
            lastEndPosition = end;
            lineRenderer.SetPosition(1, lastEndPosition);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/HighlightingLineRenderer.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/HighlightingMethod.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 372e8010cadc4d15aa4e29e82749e40f
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;

namespace Ldx.Framework.Features.Highlighting
{
    /// <summary>
    /// The used highlighting method in the project
    /// </summary>
    [Serializable]
    public enum HighlightingMethod
    {
        HighlightPlus = 0,
        Outline
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/HighlightingMethod.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/HighlightOutlinePulser.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cc645540006f4dfbbc6866dc35ac4afe
# ASMDEF: ldx.framework.runtime.dll
# ---
using DG.Tweening;
using HighlightPlus;
using UnityEngine;

namespace Ldx.Framework.Features.Highlighting
{
    [RequireComponent(typeof(HighlightEffect))]
    public class HighlightOutlinePulser : MonoBehaviour
    {
        [SerializeField] private HighlightEffect highlightEffect;
        [Min(0.0f)]
        [SerializeField] private float pulseLength = 1;
        [SerializeField] private float minWidthValue = 0;
        [SerializeField] private float maxWidthValue = 0.1f;
        [SerializeField] private Ease ease = Ease.InOutSine;
        [SerializeField] private bool pulseAutomaticallyWhileActive;

        private Tween pulsingTween;
        
        private void OnValidate()
        {
            if (highlightEffect == null)
            {
                highlightEffect = GetComponent<HighlightEffect>();
            }
        }

        private void Awake()
        {
            highlightEffect.OnObjectHighlightStart += HandleObjectHighlightStart;
            highlightEffect.OnObjectHighlightEnd += HandleObjectHighlightEnd;
        }

        private void OnDestroy()
        {
            pulsingTween?.Kill();
            if (highlightEffect != null)
            {
                highlightEffect.OnObjectHighlightStart -= HandleObjectHighlightStart;
                highlightEffect.OnObjectHighlightEnd -= HandleObjectHighlightEnd;
            }
        }

        private bool HandleObjectHighlightStart(GameObject highlightObject)
        {
            if (pulseAutomaticallyWhileActive)
            {
                PulseHighlight();
            }

            return true;
        }

        private bool HandleObjectHighlightEnd(GameObject highlightObject)
        {
            pulsingTween?.Kill();
            return true;
        }

        /// <summary>
        /// Pulses the attached highlight effect's overlay value between the min and max values until the highlighting
        /// stops or is manually stopped.
        /// </summary>
        public void PulseHighlight()
        {
            highlightEffect.outlineWidth = minWidthValue;
            pulsingTween?.Kill();
            pulsingTween = DOTween.To(
                    () => highlightEffect.outlineWidth,
                    x => highlightEffect.outlineWidth = x,
                    maxWidthValue,
                    pulseLength)
                .SetLoops(-1, LoopType.Yoyo)
                .SetEase(ease);
        }

        /// <summary>
        /// Manually stops the pulsing effect and sets the overlay either to the minimum or the maximum, depending
        /// on what you need. Default is minimum.
        /// </summary>
        /// <param name="setValueToMinimum">If you want to set the pulsing value to minimum or maximum on stop.</param>
        public void StopPulsing(bool setValueToMinimum = true)
        {
            pulsingTween?.Kill();
            float valueToSet = setValueToMinimum ? minWidthValue : maxWidthValue;
            pulsingTween = DOTween.To(
                    () => highlightEffect.outlineWidth,
                    x => highlightEffect.outlineWidth = x,
                    valueToSet,
                    pulseLength)
                .SetEase(ease);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/HighlightOutlinePulser.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/HighlightOverlayPulser.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8621faa0bad0d4c4696d376399321d07
# ASMDEF: ldx.framework.runtime.dll
# ---
using DG.Tweening;
using HighlightPlus;
using UnityEngine;

namespace Ldx.Framework.Features.Highlighting
{
    /// <summary>
    /// Attach to any object with a Highlight Effect. Pulses the overlay between the min and max value.
    /// </summary>
    [RequireComponent(typeof(HighlightEffect))]
    public class HighlightOverlayPulser : MonoBehaviour
    {
        [SerializeField] private HighlightEffect highlightEffect;
        [SerializeField] private float startDelay = 0.2f;
        [SerializeField] private float pulseLength = 1;
        [SerializeField] private float minOverlayValue;
        [SerializeField] private float maxOverlayValue = 0.5f;
        [SerializeField] private Ease ease = Ease.InOutSine;
        [SerializeField] private bool pulseAutomaticallyWhileActive;

        private Tween pulsingTween;
        
        private void OnValidate()
        {
            if (highlightEffect == null)
            {
                highlightEffect = GetComponent<HighlightEffect>();
            }
        }

        private void Awake()
        {
            highlightEffect.OnObjectHighlightStart += HandleObjectHighlightStart;
            highlightEffect.OnObjectHighlightEnd += HandleObjectHighlightEnd;
        }

        private void Start()
        {
            TryToStartPulse(false);
        }

        private void OnDestroy()
        {
            pulsingTween?.Kill();
            if (highlightEffect != null)
            {
                highlightEffect.OnObjectHighlightStart -= HandleObjectHighlightStart;
                highlightEffect.OnObjectHighlightEnd -= HandleObjectHighlightEnd;
            }
        }

        private bool HandleObjectHighlightStart(GameObject highlightObject)
        {
            TryToStartPulse(true);
            return true;
        }

        private void TryToStartPulse(bool force)
        {
            if (pulseAutomaticallyWhileActive && (force || highlightEffect.highlighted))
            {
                PulseHighlight();
            }
        }

        private bool HandleObjectHighlightEnd(GameObject highlightObject)
        {
            StopPulsing();
            return true;
        }

        /// <summary>
        /// Pulses the attached highlight effect's overlay value between the min and max values until the highlighting
        /// stops or is manually stopped.
        /// </summary>
        public void PulseHighlight()
        {
            highlightEffect.overlay = minOverlayValue;
            pulsingTween?.Kill();
            pulsingTween = DOTween.To(
                    () => highlightEffect.overlay,
                    x => highlightEffect.overlay = x,
                    maxOverlayValue,
                    pulseLength)
                .SetDelay(startDelay)
                .SetLoops(-1, LoopType.Yoyo)
                .SetEase(ease);
        }

        /// <summary>
        /// Manually stops the pulsing effect and sets the overlay either to the minimum or the maximum, depending
        /// on what you need. Default is minimum.
        /// </summary>
        /// <param name="setValueToMinimum">If you want to set the pulsing value to minimum or maximum on stop.</param>
        public void StopPulsing(bool setValueToMinimum = true)
        {
            pulsingTween?.Kill();
            float valueToSet = setValueToMinimum ? minOverlayValue : maxOverlayValue;
            pulsingTween = DOTween.To(
                    () => highlightEffect.overlay,
                    x => highlightEffect.overlay = x,
                    valueToSet,
                    pulseLength)
                .SetEase(ease);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/HighlightOverlayPulser.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/HoverHighlightProcessor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e8d4de03e2c54aa89f33db6293599a37
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Features.Highlighting
{
    ///<summary>
    /// A processor that handles hover highlighting functionalities for modal highlighters.
    ///</summary>
    public class HoverHighlightProcessor
    {
        public static event Action<HoverHighlightProcessor, Transform> OnHoverTargetStateChanged;
        public static event Action<HoverHighlightProcessor, HighlightableObject> OnHoverStarted;
        public static event Action<HoverHighlightProcessor, HighlightableObject> OnHoverEnded;

        private Vector3 lastRaycastHit;
        private float nextHoverTime;

        public HighlightableObject ActiveHoverTarget { get; private set; }
        public bool IsHovering => ActiveHoverTarget != null;
        public Vector3 LastRaycastHit => lastRaycastHit;

        /// <summary>
        ///  Processes hover actions based on the raycast source transform. If a hoverable highlighter is detected within the delay threshold, 
        ///  it will enable hover highlighting. If a new hover target is detected, it disables the current hover target.
        /// </summary>
        /// <param name="raycastSourceTransform">The transform from which the raycast originates.</param>
        /// <param name="raycastHit"></param>
        public bool TryProcessHover(Transform raycastSourceTransform, out Vector3 raycastHit) 
        {
            if (TryGetHighlightFromRaycast(raycastSourceTransform, out HighlightableObject highlighter, out lastRaycastHit))
            {
                raycastHit = lastRaycastHit;
                HandleNewHoverTarget(highlighter, raycastSourceTransform);
                return true;
            }

            raycastHit = lastRaycastHit;
            DisableCurrentHoverTarget(raycastSourceTransform);
            return false;
        }

        ///<summary>
        /// Attempts to retrieve a highlighter object from a raycast originating from a given source transform.
        /// If successful, it also checks if the retrieved highlighter is capable of highlighting.
        /// </summary>
        /// <param name="raycastSourceTransform">The transform from which the raycast originates.</param>
        /// <param name="highlighter">Out parameter to return the retrieved ObjectModalHighlighter, if found.</param>
        /// <param name="raycastHit">Out parameter to return the point where the raycast hit an object.</param>
        /// <returns>Returns true if a highlighter was successfully retrieved and is capable of highlighting, otherwise false.</returns>
        private bool TryGetHighlightFromRaycast(Transform raycastSourceTransform,
            out HighlightableObject highlighter,
            out Vector3 raycastHit)
        {
            return HighlighterHelper.TryGetHighlighterFromRaycast(raycastSourceTransform,
                       out highlighter, out raycastHit) && highlighter.CanHighlight;
        }

        ///<summary>
        /// Handles the logic for a newly detected hover target. If it's different from the previous target, the previous one is disabled.
        ///</summary>
        ///<param name="highlighter">The detected hover highlighter.</param>
        private void HandleNewHoverTarget(HighlightableObject highlighter, Transform pointingSourceTransform)
        {
            if (ActiveHoverTarget == highlighter)
            {
                return;
            }

            DisableCurrentTarget();

            ActiveHoverTarget = highlighter;
            ActiveHoverTarget.EnableHoverHighlight();
            OnHoverStarted?.Invoke(this, ActiveHoverTarget);
            OnHoverTargetStateChanged?.Invoke(this, pointingSourceTransform);
        }

        ///<summary>
        /// Disables hover highlighting for the current hover target, if there's any.
        ///</summary>
        public void DisableCurrentHoverTarget(Transform pointingSourceTransform)
        {
            if (ActiveHoverTarget == null)
            {
               return;
            }

            DisableCurrentTarget();
            OnHoverTargetStateChanged?.Invoke(this, pointingSourceTransform);
        }

        private void DisableCurrentTarget()
        {
            if (ActiveHoverTarget == null)
            {
                return;
            }
            
            ActiveHoverTarget.DisableHoverHighlight();
            OnHoverEnded?.Invoke(this, ActiveHoverTarget);
            ActiveHoverTarget = null;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/HoverHighlightProcessor.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/ObjectHighlighterController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 700c6946e56145938fbc2b3cf8be23c2
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;
using Ldx.Framework.Systems.Objectives.Feedback;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Features.Highlighting
{
    ///<summary>
    /// A controller for managing and visually representing the highlighting of objects with ModalHighlighters
    ///</summary>
    public class ObjectHighlighterController : Singleton<ObjectHighlighterController>
    {
        public static bool DialogBlockingHighlighting { get; set; }
        private static bool needsHoverHighlighterDisable;

        private const float ALMOST_FULL_PERCENTAGE = 0.99f;

        ///<summary>
        /// An event that's invoked when the object highlighting process starts.
        ///</summary>
        public static event Action<bool> OnDialogBlockingHighlightingChanged;
        ///<summary>
        /// An event that's invoked when the object highlighting process starts.
        ///</summary>
        public static event Action<ObjectHighlighterController> OnObjectHighlightStarted;
        ///<summary>
        /// An event that's invoked when the object highlighting process ends.
        ///</summary>
        public static event Action<ObjectHighlighterController> OnObjectHighlightEnded;
        ///<summary>
        /// An event that's invoked when the object highlighting percentage is updated.
        ///</summary>
        public static event Action<ObjectHighlighterController, float> OnObjectHighlightPercentageUpdated;
        ///<summary>
        /// An event that's invoked when any modal is highlighted
        ///</summary>
        public static event Action<ObjectHighlighterController, HighlightableObject> OnAnyModalHighlighted;

        [SerializeField]
        private ObjectiveFeedbackData hoverFeedbackData;
        
        private bool isHoverEnabled;
        private Coroutine highlightingRoutine;
        private Transform highlightingPointer;
        private float highlightedPercentage;
        private HighlightableObject lastTarget;
        private bool waitForDialogWindow;
        private readonly List<HighlightableObject> currentHighlighted = new List<HighlightableObject>();
        
        private class HighlightGroup
        {
            public HoverHighlightProcessor hoverHighlightProcessor;
            public HighlightingLineRenderer highlightingLineRenderer;
        }
        
        private readonly Dictionary<Transform, HighlightGroup> pointingHighlightGroupSet =
            new Dictionary<Transform, HighlightGroup>();

        public List<HighlightingLineRenderer> AllLineRenderers { get; } = new();

        ///<summary>
        /// Represents the current percentage value of how much an object is highlighted.
        ///</summary>
        private float HighlightedPercentage
        {
            get => highlightedPercentage;
            set
            {
                highlightedPercentage = Mathf.Clamp01(value);
                OnObjectHighlightPercentageUpdated?.Invoke(this, highlightedPercentage);
            }
        }

        private void Start()
        {
            isHoverEnabled = HighlightingGlobalSettings.ShowHoverHighlight;
            HoverHighlightProcessor.OnHoverTargetStateChanged += HandleHoverStateChanged;
        }

        private void OnDestroy()
        {
            HoverHighlightProcessor.OnHoverTargetStateChanged -= HandleHoverStateChanged;
            
            if(LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnDialogCompleted -= HandleDialogCompleted;
            }
        }
        
        public static void SetDialogBlocking(bool blocking)
        {
            DialogBlockingHighlighting = blocking;
            needsHoverHighlighterDisable = DialogBlockingHighlighting;
            OnDialogBlockingHighlightingChanged?.Invoke(DialogBlockingHighlighting);
        }

        #region Highlight Group

        public void RegisterPointer(Transform pointer)
        {
            CreateHighlightGroup(pointer);
        }

        // Use if reassigning pointer at runtime to prevent duplicates
        public void ClearPointersAndLineRenderers()
        {
            foreach (HighlightingLineRenderer line in AllLineRenderers)
            {
                Destroy(line.gameObject);
            }
            
            AllLineRenderers.Clear();
            
            foreach (KeyValuePair<Transform, HighlightGroup> entry in pointingHighlightGroupSet)
            {
                entry.Value.hoverHighlightProcessor.DisableCurrentHoverTarget(entry.Key);
            }

            pointingHighlightGroupSet.Clear();
        }

        ///<summary>
        /// Creates a new hover highlight processor for the given pointer or returns the existing one.
        ///</summary>
        /// <param name="pointer">The transform of the pointer.</param>
        /// <returns>The HoverHighlightProcessor associated with the pointer.</returns>
        private void CreateHighlightGroup(Transform pointer)
        {
            if (!pointingHighlightGroupSet.ContainsKey(pointer))
            {
                HighlightGroup highlightGroup = new()
                {
                    hoverHighlightProcessor = new HoverHighlightProcessor(),
                    highlightingLineRenderer = CreateLineRendererObject(pointer),
                };
                
                pointingHighlightGroupSet.Add(pointer, highlightGroup);
                AllLineRenderers.Add(highlightGroup.highlightingLineRenderer);
            }
        }

        ///<summary>
        /// Creates a Line Renderer game object and attaches it to the current transform.
        /// This Line Renderer is used for highlighting purposes.
        ///</summary>
        /// <param name="pointer">The starting point for the Line Renderer.</param>
        /// <returns>Returns an instance of the HighlightingLineRenderer attached to the created game object.</returns>
        private HighlightingLineRenderer CreateLineRendererObject(Transform pointer)
        {
            GameObject lineGameObject = new GameObject("Line Renderer");
            lineGameObject.transform.SetParent(transform);
            lineGameObject.AddComponent<LineRenderer>();
            HighlightingLineRenderer highlightingLineRenderer =
                lineGameObject.AddComponent<HighlightingLineRenderer>();
            highlightingLineRenderer.SetLineRendererStartPoint(pointer);
            return highlightingLineRenderer;
        }
        
        #endregion

        #region Hover
        
        ///<summary>
        /// Process the hover state for a given pointing transform.
        /// </summary>
        /// <param name="pointingTransform">The transform that's pointing/hovering over an object.</param>
        public void ProcessHover(Transform pointingTransform)
        {
            if (!isHoverEnabled || DialogBlockingHighlighting)
            {
                if (needsHoverHighlighterDisable)
                {
                    DisableHoverOnBlockingStateChanged();
                }
                return;
            }

            if (TryGetHighlightGroup(pointingTransform, out HighlightGroup group) && 
                group.hoverHighlightProcessor.TryProcessHover(pointingTransform, out Vector3 hit))
            {
                group.highlightingLineRenderer.SetLineRendererEndPoint(hit);
            }
        }
        
        public void DisableHoverOnBlockingStateChanged()
        {
            foreach (KeyValuePair<Transform,HighlightGroup> highlightGroupSet in pointingHighlightGroupSet)
            {
                highlightGroupSet.Value.hoverHighlightProcessor.DisableCurrentHoverTarget(highlightGroupSet.Key);
            }
            
            needsHoverHighlighterDisable = false;
        }
        
        ///<summary>
        /// Attempts to retrieve the HighlightGroup associated with the given pointer.
        ///</summary>
        /// <param name="pointer">The transform used as a key to look up the HighlightGroup.</param>
        /// <param name="group">Output parameter to store the retrieved HighlightGroup, if found.</param>
        /// <returns>Returns true if the HighlightGroup was successfully retrieved, otherwise false.</returns>
        private bool TryGetHighlightGroup(Transform pointer, out HighlightGroup group)
        {
            group = null;
            
            if(!pointingHighlightGroupSet.ContainsKey(pointer))
            {
                return false;
            }

            group = pointingHighlightGroupSet[pointer];
            return true;
        }

        /// <summary>
        ///  Creates a new hover highlight processor for the given pointer or returns the existing one.
        /// </summary>
        ///  <param name="pointer">The transform of the pointer.</param>
        /// <param name="processor"></param>
        /// <returns>The HoverHighlightProcessor associated with the pointer.</returns>
        private bool TryGetHoverHighlightProcessor(Transform pointer, out HoverHighlightProcessor processor)
        {
            processor = null;
            if(!pointingHighlightGroupSet.ContainsKey(pointer))
            {
                return false;
            }

            processor = pointingHighlightGroupSet[pointer].hoverHighlightProcessor;
            return true;
        }

        ///<summary>
        /// Handles the change in hover state for the given pointing transform and processes its highlighting.
        ///</summary>
        /// <param name="hoveringProcessor">The processor responsible for hover highlighting.</param>
        /// <param name="pointingTransform">The transform that is being pointed at or hovered over.</param>
        private void HandleHoverStateChanged(HoverHighlightProcessor hoveringProcessor, Transform pointingTransform)
        {
            if (TryGetHighlightGroup(pointingTransform, out HighlightGroup group))
            {
                if (hoveringProcessor.IsHovering)
                {
                    group.highlightingLineRenderer.EnableLineRenderer(true);
                }
                else if(highlightingRoutine == null)
                {
                    group.highlightingLineRenderer.EnableLineRenderer(false);
                }
            }
        }

        #endregion

        ///<summary>
        /// Initiates the object identification process for the specified pointing transform.
        /// This method checks certain conditions and based on them, it starts an identification routine.
        ///</summary>
        /// <param name="pointingTransform">The transform that points or aims at an object to be identified.</param>
        public void StartObjectIdentification(Transform pointingTransform)
        {
            // Return early if dialog blocking highlighting is active or if there's an ongoing highlighting routine
            if (DialogBlockingHighlighting || highlightingRoutine != null)
            {
                return;
            }
            
            highlightingPointer = pointingTransform;

            // If hover highlighting is enabled, retrieve the associated hover highlight processor
            if (isHoverEnabled && TryGetHoverHighlightProcessor(pointingTransform, out HoverHighlightProcessor processor))
            {
                if (processor.IsHovering)
                {
                    startIdentificationRoutine(processor.ActiveHoverTarget);
                }
            }
            else
            {
                if (HighlighterHelper.TryGetHighlighterFromRaycast(pointingTransform, out HighlightableObject highlighter, out Vector3 hitPosition)
                    && highlighter.CanHighlight && !currentHighlighted.Contains(highlighter))
                {
                    startIdentificationRoutine(highlighter);
                }
            }

            void startIdentificationRoutine(HighlightableObject target)
            {
                if (target.Mode is HighlightingMode.HoverOnly)
                {
                    return;
                }
                CoroutineUtilities.ReplaceAndStartCoroutine(ref highlightingRoutine, IdentificationRoutine(target), this);
            }
        }

        ///<summary>
        /// Executes the identification routine for the specified target highlighter.
        /// This coroutine gradually increases the highlight percentage until it reaches a defined threshold (almost full).
        /// Once reached, if the target can broadcast that the highlighting has finished, it will do so.
        ///</summary>
        /// <param name="target">The ObjectModalHighlighter that needs to be identified.</param>
        private IEnumerator IdentificationRoutine(HighlightableObject target)
        {
            lastTarget = target;
            OnObjectHighlightStarted?.Invoke(this);
            target.EnableHighlighter();

            HighlightedPercentage = 0;
            
            while(HighlightingGlobalSettings.ShouldHoldToHighlight && HighlightedPercentage < ALMOST_FULL_PERCENTAGE)
            {
                UpdateHighlightPercentage();
                yield return null;
            }
            
            if (target.CanBroadcastHighlightFinished)
            {
                FinishHighlighter(target);
            }
        }
        
        ///<summary>
        /// Checks if the provided pointing transform is valid for the highlighting process.
        ///</summary>
        /// <param name="pointingTransform">The pointing transform to be validated.</param>
        /// <returns>True if the pointing transform is valid, false otherwise.</returns>
        private bool IsValidPointingTransform(Transform pointingTransform)
        {
            return highlightingPointer == null || highlightingPointer == pointingTransform;
        }

        ///<summary>
        /// Updates the highlighted percentage value.
        ///</summary>
        private void UpdateHighlightPercentage()
        {
            if (HighlightingGlobalSettings.TimeToHold > 0)
            {
                HighlightedPercentage += Time.deltaTime / HighlightingGlobalSettings.TimeToHold;
            }
            else
            {
                HighlightedPercentage = 1f;
            }
        }

        ///<summary>
        /// Completes the highlighting process for the given highlighter.
        ///</summary>
        /// <param name="highlighter">The target object's highlighter component to be completed.</param>
        private void FinishHighlighter(HighlightableObject highlighter)
        {
            highlighter.HighlightFinished();
            currentHighlighted.Add(highlighter);
            OnAnyModalHighlighted?.Invoke(this, highlighter);

            if (highlighter.DeselectOnFinished)
            {
                waitForDialogWindow = false;
                ResetAndDeselect();
            }
            else
            {
                waitForDialogWindow = true;
                LdxTrackingManager.Instance.OnDialogCompleted -= HandleDialogCompleted;
                LdxTrackingManager.Instance.OnDialogCompleted += HandleDialogCompleted;
            }

            foreach (Transform pointingTransform in pointingHighlightGroupSet.Keys)
            {
                ResetHighlightState(pointingTransform,highlighter.DeselectOnFinished);
            }

            HighlightedPercentage = 0f;
        }

        /// <summary>
        ///  Event handler for when a dialog completion event occurs.
        /// </summary>
        ///  <param name="id">The ID of the completed dialog.</param>
        /// <param name="correct">True of dialog is the correct one</param>
        private void HandleDialogCompleted(string id, bool correct)
        {
            if (lastTarget == null || lastTarget.DialogID != id)
            {
                return;
            }
            
            LdxTrackingManager.Instance.OnDialogCompleted -= HandleDialogCompleted;
            waitForDialogWindow = false;
            ResetAndDeselect();
        }
        
        #region Resetting

        /// <summary>
        ///  Resets the highlight state asynchronously for the provided pointing transform.
        ///  </summary>
        ///  <param name="pointingTransform">The transform pointing to the object.</param>
        /// <param name="deselect">If true will call ResetAndDeselect after delay</param>
        public async void ResetHighlightState(Transform pointingTransform, bool deselect = true)
        {
            if (!IsValidPointingTransform(pointingTransform))
            {
                return;
            }

            CoroutineUtilities.StopAndNullCoroutine(ref highlightingRoutine, this);

            if (TryGetHighlightGroup(pointingTransform, out HighlightGroup group))
            {
                group.highlightingLineRenderer.EnableLineRenderer(false);
            }
            
            await Task.Delay(100);
            if (deselect)
            {
                ResetAndDeselect();
            }
            
            OnObjectHighlightEnded?.Invoke(this);
        }
        
        ///<summary>
        /// Resets the current highlighter and deselects the target if applicable.
        /// </summary>
        /// <param name="disableHighlight">Indicates whether to disable the highlight on the target object or not.</param>
        private void ResetAndDeselect(bool disableHighlight = true)
        {
            highlightingPointer = null;
            
            if (waitForDialogWindow)
            {
                return;
            }

            if (lastTarget != null && !lastTarget.FinishedHighlighting && disableHighlight)
            {
                lastTarget.ResetHighlighter();
            }
            
            currentHighlighted.Remove(lastTarget);
            lastTarget = null;
            HighlightedPercentage = 0;
        }
        
        ///<summary>
        /// Clears all active highlighters and resets relevant properties.
        /// </summary>
        public void ClearHighlighters()
        {
            currentHighlighted.Clear();
            lastTarget = null;
            highlightingPointer = null;
            HighlightedPercentage = 0;
        } 
        
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Highlighting/ObjectHighlighterController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Inspection/InspectableObject.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7fc698280ac542b494951b3ac1165f4b
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Ldx.Framework.Features.Inspection
{
    public class InspectableObject : MonoBehaviour
    {
        public event Action<InspectableObject> OnInspectionCompleted;
        
        [SerializeField] private List<Collider> colliders = new();
        public List<Collider> Colliders => colliders;

        [SerializeField] private Vector3 progressUIOffset;
        public Vector3 ProgressUIOffset => progressUIOffset;

        [SerializeField, Tooltip("Fire only once; disable further inspections after completion.")]
        private bool oneShot = true;
        
        public bool Completed { get; private set; }

        private void OnValidate()
        {
            if (colliders.Count < 1)
            {
                colliders.AddRange(GetComponentsInChildren<Collider>());
            }
        }

        public void CompleteInspection()
        {
            if (Completed && oneShot)
            {
                return;
            }
            
            Completed = true;
            OnInspectionCompleted?.Invoke(this);
        }
        
        public void ResetInspection()
        {
            Completed = false;
        }

        private void OnDrawGizmos()
        {
            Gizmos.DrawIcon(transform.position + progressUIOffset, "Inspection.png", true);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Inspection/InspectableObject.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Inspection/InspectionFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a0566ab6ea0b40a6935d09e932ba10ed
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Features.Inspection
{
    /// <summary>
    /// Gaze-driven inspection controller that only works with the provided list of Inspectable targets.
    /// Raycasts from playerCamera; fills UI while looking at a listed target until its RequiredSeconds elapse.
    /// </summary>
    public class InspectionFeature : ObjectiveFeature
    {
        private const float DEFAULT_RAY_DISTANCE = 5f;
        private const float DEFAULT_PROGRESS_DROP_SPEED = 3f;
        private const float TICK_HZ = 30f;               
        private const float LOS_RECHECK_INTERVAL = 0.12f;
        private const float ANGLE_DEG = 5.0f;
        
        private static readonly RaycastHit[] oneHit = new RaycastHit[1];

        public static event Action<InspectionFeature, InspectableObject> OnInspectionStarted;
        public static event Action<InspectionFeature, InspectableObject, float> OnInspectionProgressUpdated;
        public static event Action<InspectionFeature, InspectableObject, bool> OnInspectionCompleted;
        
        [Header("Targets")]
        [SerializeField, Tooltip("Targets that can be inspected by this feature.")]
        private List<InspectableObject> targets = new();
        [SerializeField, Tooltip("Seconds required to complete inspection.")]
        private float requiredSeconds = 1.75f;
        
        [Header("Raycast")]
        [SerializeField] private LayerMask inspectableMask = ~0;
        [SerializeField] private float rayDistance = DEFAULT_RAY_DISTANCE;
        
        [Header("Tuning")]
        [SerializeField] float progressDropSpeed = DEFAULT_PROGRESS_DROP_SPEED;
        
        private readonly HashSet<InspectableObject> targetSet = new();
        private readonly Dictionary<Collider, InspectableObject> colliderOwnerMap = new();
        private InspectableObject current;
        private float timer;
        private Vector3 lastHitPoint;
        private bool hadTarget;
        private float losTimer;
        private float losAmount;
        private int tickDelay;
        private CancellationTokenSource cts;
        
        private Camera playerCamera;
        private Camera PlayerCamera =>
            playerCamera == null ? playerCamera = PlayerController.Instance.MainCamera : playerCamera;

        private void Awake()
        {
            losAmount = 1f / TICK_HZ;
            tickDelay = Mathf.Max(1, Mathf.RoundToInt(1000f / TICK_HZ));
        }

        protected override void StartFeature()
        {
            BuildCaches();
            
            cts?.SafeCancelAndDispose();
            cts = new CancellationTokenSource();
            InspectionLoopAsync(cts.Token).Forget();
        }
        
        private void BuildCaches()
        {
            targetSet.Clear();
            colliderOwnerMap.Clear();

            foreach (InspectableObject t in targets)
            {
                if (t == null) continue;
                targetSet.Add(t);
                foreach (Collider col in t.Colliders)
                {
                    colliderOwnerMap.TryAdd(col, t);
                }
            }
        }

        protected override void StopFeature(bool isInitialization = false)
        {
            base.StopFeature(isInitialization);
            cts?.SafeCancelAndDispose();
            ClearTarget();
        }

        private async UniTaskVoid InspectionLoopAsync(CancellationToken token)
        {
            if (PlayerCamera == null)
            {
                return;
            }
            
            bool advanced;
            bool needRaycast;

            while (!token.IsCancellationRequested)
            {
                advanced = false;
                
                Vector3 origin = playerCamera.transform.position;
                Vector3 dir = playerCamera.transform.forward;
                needRaycast = true;

                if (current != null && !current.Completed)
                {
                    losTimer -= losAmount;
                    if (losTimer > 0f)
                    {
                        Vector3 to = current.transform.position - origin;
                        float dist = to.magnitude;
                        if (dist <= rayDistance && Vector3.Angle(dir, to) <= ANGLE_DEG)
                        {
                            Accumulate(current, lastHitPoint);
                            advanced = true;
                            needRaycast = false;
                        }
                    }
                }

                if (needRaycast)
                {
                    int hitCount = Physics.RaycastNonAlloc(
                        origin, dir, oneHit, rayDistance, inspectableMask, QueryTriggerInteraction.Ignore);

                    if (hitCount > 0)
                    {
                        RaycastHit hit = oneHit[0]; 
                        lastHitPoint = hit.point;

                        if (colliderOwnerMap.TryGetValue(hit.collider, out InspectableObject target) && target != null && !target.Completed && targetSet.Contains(target))
                        {
                            if (current != target)
                            {
                                BeginTarget(target);
                            }
                            
                            Accumulate(target, hit.point);
                            advanced = true;
                            losTimer = LOS_RECHECK_INTERVAL;
                        }
                    }
                }
                
                if (!advanced)
                {
                    DecayOrClear();
                }
                
                await UniTask.Delay(tickDelay, DelayType.DeltaTime, PlayerLoopTiming.Update, token);
            }
        }

        private void BeginTarget(InspectableObject target)
        {
            if (current != null && current != target)
            {
                ClearTarget();
            }
            
            current = target;
            timer = 0f;
            OnInspectionStarted?.Invoke(this, target);
        }
        
        private void Accumulate(InspectableObject t, Vector3 hitPoint)
        {
            lastHitPoint = hitPoint;
            timer += Time.deltaTime;
            float p = Mathf.Clamp01(timer / requiredSeconds);
            OnInspectionProgressUpdated?.Invoke(this, t, p);

            if (p >= 1f)
            {
                t.CompleteInspection();
                OnInspectionCompleted?.Invoke(this, t, true);
                ClearTarget();
                if (AllCompleted())
                {
                    CompleteFeature();
                }
            }
            
            hadTarget = true;
        }
        
        private void DecayOrClear()
        {
            if (hadTarget)
            {
                timer = Mathf.Max(0f, timer - progressDropSpeed * Time.deltaTime);
                float p = current != null && requiredSeconds > 0f ? Mathf.Clamp01(timer / requiredSeconds) : 0f;
                OnInspectionProgressUpdated?.Invoke(this, current, p);
                
                if (timer <= 0.001f)
                {
                    ClearTarget();
                    OnInspectionCompleted?.Invoke(this, current, false);
                }
            }
            else
            {
                ClearTarget();
                OnInspectionCompleted?.Invoke(this, null, false);
            }
            
            hadTarget = false;
        }

        private void ClearTarget()
        {
            current = null;
            hadTarget = false;
            timer = 0f;
        }
        
        public void AddTarget(InspectableObject inspectableObject)
        {
            if (inspectableObject == null || targetSet.Contains(inspectableObject))
            {
                return;
            }
            
            targets.Add(inspectableObject);
            BuildCaches();
        }
        
        public void RemoveTarget(InspectableObject inspectableObject)
        {
            if (inspectableObject == null)
            {
                return;
            }
            targets.Remove(inspectableObject);
            BuildCaches();
            
            if (current == inspectableObject) ClearTarget();
            if (AllCompleted()) CompleteFeature();
        }
        
        private bool AllCompleted()
        {
            return targets.All(t => t == null || t.Completed);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Inspection/InspectionFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/InstallObjectFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d89520a7de0245c297d1eb0463ac824c
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Autohand;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using Ldx.Framework.Features.Interaction;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;

namespace Ldx.Framework.Features
{
    public class InstallObjectFeature : ObjectiveFeature
    {
        private const float HOVER_THRESHOLD = 0.5f;
        private const float HIGHLIGHT_DISTANCE_CHECK_INTERVAL = .33f;
        
        [SerializeField] protected InteractableObject objectToInstall;

        [SerializeField]
        protected SerializableDictionary<PlacePoint, HologramObjectHighlighting> placePointHologramMap = new();

        [Tooltip("If true, doesn't highlight when grabbed, only when near a place point.")]
        [SerializeField] private bool highlightOnlyWhenNearPlacePoint;
        [ShowIf(nameof(highlightOnlyWhenNearPlacePoint), Op.Equals, true)]
        [SerializeField] private bool useHighlightingRangeOnGrabbale = true;
        [ShowIf(nameof(highlightOnlyWhenNearPlacePoint), Op.Equals, true)]
        [Min(0)]
        [Tooltip("Distance to show highlight.")]
        [SerializeField] private float highlightRange = 0.1f;
        [SerializeField] private bool ignoreHighlights;

        [Space]
        [SerializeField] protected List<GameObject> objectsToEnableOnComplete;
        [SerializeField] protected List<GameObject> objectsToDisableOnComplete;

        private CancellationTokenSource hoverCts;
        private CancellationTokenSource highlightTrackingCts;
        private PlacePoint installedSocket;
        private float highlightRangeSquared;

        protected override void Start()
        {
            highlightRangeSquared = highlightRange * highlightRange;
            foreach (KeyValuePair<PlacePoint, HologramObjectHighlighting> placePointHologramPair in placePointHologramMap)
            {
                placePointHologramPair.Key.OnHighlightEvent += HandleSocketHoverEnter;
                placePointHologramPair.Key.OnStopHighlightEvent += HandleSocketHoverExit;
                placePointHologramPair.Key.OnPlaceEvent += HandleObjectPlaced;
                placePointHologramPair.Key.gameObject.SetActive(false);
                placePointHologramPair.Value.SetVisible(false);
            }
            
            base.Start();
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
            hoverCts.SafeCancelAndDispose();
            Unsubscribe();
        }

        private void Unsubscribe()
        {
            foreach (PlacePoint socket in placePointHologramMap.Keys)
            {
                socket.OnHighlightEvent -= HandleSocketHoverEnter;
                socket.OnStopHighlightEvent -= HandleSocketHoverExit;
                socket.OnPlaceEvent -= HandleObjectPlaced;
            }

            if (objectToInstall != null)
            {
                objectToInstall.OnInteractableObjectGrabbed -= HandleInteractableObjectGrabbed;
                objectToInstall.OnInteractableObjectReleased -= HandleInteractableObjectReleased;
            }
        }
        
        protected override void StartFeature()
        {
            objectToInstall.OnInteractableObjectGrabbed += HandleInteractableObjectGrabbed;
            objectToInstall.OnInteractableObjectReleased += HandleInteractableObjectReleased;
            foreach (PlacePoint socket in placePointHologramMap.Keys)
            {
                socket.gameObject.SetActive(true);
            }

            objectToInstall.ActivateObject();
        }

        private void HandleInteractableObjectGrabbed(InteractableObject _)
        {
            if (!highlightOnlyWhenNearPlacePoint)
            {
                SetAllHologramsVisible(true);
            }
            else if(highlightOnlyWhenNearPlacePoint && !useHighlightingRangeOnGrabbale)
            {
                highlightTrackingCts.SafeCancelAndDispose();
                highlightTrackingCts = new CancellationTokenSource();
                TrackHighlightingAsync(highlightTrackingCts.Token).Forget();
            }
        }
        
        private void HandleInteractableObjectReleased(InteractableObject _)
        {
            SetAllHologramsVisible(false);
        }
        
        private void HandleSocketHoverEnter(PlacePoint point, Grabbable grabbable)
        {
            if (grabbable != objectToInstall.Grabbable)
            {
                return;
            }
            
            if (highlightOnlyWhenNearPlacePoint && useHighlightingRangeOnGrabbale && !point.ignoreMe)
            {
                if (placePointHologramMap.TryGetValue(point, out HologramObjectHighlighting placePointHologram))
                {
                    placePointHologram.SetVisible(true);
                }
            }
            
            TaskExtensions.DisposeAndReplaceTokenSource(ref hoverCts);
            AwaitForThreshold(point).Forget();
        }

        private async UniTaskVoid TrackHighlightingAsync(CancellationToken token)
        {
            if (ignoreHighlights)
                return;
            
            while (!token.IsCancellationRequested)
            {
                foreach (KeyValuePair<PlacePoint, HologramObjectHighlighting> placePointHologramPair in
                         placePointHologramMap)
                {
                    if (!placePointHologramPair.Key.ignoreMe)
                    {
                        placePointHologramPair.Value.SetVisible(
                            IsObjectWithinThreshold(placePointHologramPair.Key.transform.position));
                    }
                }

                await UniTask.Delay(HIGHLIGHT_DISTANCE_CHECK_INTERVAL.ToMilliseconds(), cancellationToken: token);
            }
        }

        private async UniTask AwaitForThreshold(PlacePoint point)
        {
            await UniTask.WaitUntil(() => objectToInstall.CanBeInstalled, cancellationToken: hoverCts.Token);
            
            if (hoverCts.IsCancellationRequested)
            {
                return;
            }
            
            await UniTask.Delay(HOVER_THRESHOLD.ToMilliseconds(), cancellationToken: hoverCts.Token);
            await UniTask.WaitUntil(() => objectToInstall.CanBeInstalled, cancellationToken: hoverCts.Token);

            if (hoverCts.IsCancellationRequested)
            {
                return;
            }
            
            objectToInstall.ForceRelease();
            point.TryPlace(objectToInstall.Grabbable);
        }
        
        private void HandleSocketHoverExit(PlacePoint point, Grabbable grabbable)
        {
            if (grabbable != objectToInstall.Grabbable)
            {
                return;
            }

            if (highlightOnlyWhenNearPlacePoint && useHighlightingRangeOnGrabbale && !point.ignoreMe)
            {
                if (placePointHologramMap.TryGetValue(point, out HologramObjectHighlighting placePointHologram))
                {
                    placePointHologram.SetVisible(false);
                }
            }

            hoverCts.SafeCancelAndDispose();
        }
        
        private void HandleObjectPlaced(PlacePoint point, Grabbable grabbable)
        {
            if (grabbable != objectToInstall.Grabbable)
            {
                return;
            }

            point.ignoreMe = true;
            installedSocket = point;
            CompleteFeature();
        }
        
        protected override void CompleteFeature()
        {
            highlightTrackingCts.SafeCancelAndDispose();
            hoverCts.SafeCancelAndDispose();
            SetAllHologramsVisible(false);
            objectToInstall.DeactivateObject(false);
            ToggleObjects();
            installedSocket.ignoreMe = true;
            base.CompleteFeature();
            Unsubscribe();
        }

        private void ToggleObjects()
        {
            foreach (GameObject o in objectsToDisableOnComplete)
            {
                o.SetActive(false);
            }
            
            foreach (GameObject o in objectsToEnableOnComplete)
            {
                o.SetActive(true);
            }
        }

        private void SetAllHologramsVisible(bool setVisible)
        {
            if (ignoreHighlights)
                return;
            
            foreach (KeyValuePair<PlacePoint, HologramObjectHighlighting> placePointHologramPair in placePointHologramMap)
            {
                if (!placePointHologramPair.Key.ignoreMe || setVisible == false)
                {
                    placePointHologramPair.Value.SetVisible(setVisible);
                }
            }
        }

        private bool IsObjectWithinThreshold(Vector3 socketPosition)
        {
            if (!objectToInstall.CanBeInstalled)
            {
                return false;
            }
            
            return Vector3.SqrMagnitude(objectToInstall.transform.position - socketPosition) <= highlightRangeSquared;
        }
        
#if UNITY_EDITOR
        public void EDITOR_AssignReferences(InteractableObject obj, PlacePoint[] skts, HologramObjectHighlighting[] hlgms)
        {
            objectToInstall = obj;
            for (int i = 0; i < skts.Length; i++)
            {
                placePointHologramMap.Add(skts[i], hlgms[i]);
            }
        }
        
        [ContextMenu("Install Object")]
        public override void EDITOR_ForceComplete()
        {
            Rigidbody rb = objectToInstall.GetComponent<Rigidbody>();
            rb.isKinematic = true;

            Tween tween = DOTween.Sequence()
                .Append(objectToInstall.transform.DOMove(placePointHologramMap.First().Key.transform.position, 0.5f))
                .Join(objectToInstall.transform.DORotateQuaternion(placePointHologramMap.First().Key.transform.rotation, 0.5f))
                .OnComplete(() =>
                {
                    placePointHologramMap.First().Key.TryPlace(objectToInstall.transform.GetComponent<Grabbable>());
                    CompleteFeature();
                });
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/InstallObjectFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/HologramObjectHighlighting.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c118d94833414bafad7c5a0cac7bae7a
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Features.Highlighting;
using UnityEngine;

namespace Ldx.Framework.Features.Interaction
{
    public class HologramObjectHighlighting : MonoBehaviour
    {
        [SerializeField] [HideInInspector]
        private Renderer[] renderers;
        
        private void OnValidate()
        {
            if (HighlightingGlobalSettings.HologramMaterial == null)
            {
                Debug.LogWarning("HologramMaterial is not set in HighlightingGlobalSettings. Cannot validate materials.", this);
                return;
            }
            
            renderers = GetComponentsInChildren<Renderer>();

            if (renderers != null)
            {
                foreach (Renderer r in renderers)
                {
                    Material[] currentMaterials = r.sharedMaterials;
                    bool needsUpdate = false;
                    
                    foreach (Material mat in currentMaterials)
                    {
                        if (mat != HighlightingGlobalSettings.HologramMaterial)
                        {
                            needsUpdate = true;
                            break;
                        }
                    }
                    
                    if (needsUpdate)
                    {
                        Material[] newMaterials = new Material[currentMaterials.Length];
                        for (int i = 0; i < newMaterials.Length; i++)
                        {
                            newMaterials[i] = HighlightingGlobalSettings.HologramMaterial;
                        }
                        
                        r.sharedMaterials = newMaterials;
                    }
                }
            }
        }

        public void SetVisible(bool visible)
        {
            if (gameObject)
            {
                gameObject.SetActive(visible);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/HologramObjectHighlighting.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/ILockable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 71f558ffb200fa840baf4649f4aaf076
# ASMDEF: ldx.framework.runtime.dll
# ---
public interface ILockable
{
    bool IsLocked { get; }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/ILockable.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/InteractableObject.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b787159de1fd4d969d22f27b020089ce
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Autohand;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.UI.Modules.Tooltip;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Tools.Resocketing;
using UnityEngine;

namespace Ldx.Framework.Features.Interaction
{
    /// <summary>
    /// Represents an interactable object that can be grabbed, highlighted, and triggered for specific actions. 
    /// Includes activation, deactivation, and interaction handling with optional visual and audio effects.
    /// </summary>
    [RequireComponent(typeof(Grabbable))]
    public class InteractableObject : MonoBehaviour
    {
        private const float RETURN_DURATION = 0.5f;
        
        public event Action<InteractableObject> OnInteractableObjectGrabbed;
        public event Action<InteractableObject> OnInteractableObjectReleased;
        public event Action<InteractableObject, PlacePoint> OnInteractableObjectSocketed;
        
        [ReadOnly] [SerializeField] protected Rigidbody rb;
        [ReadOnly] [SerializeField] protected Grabbable grabbable;
        public Grabbable Grabbable => grabbable;
        [ShowIf(nameof(grabbableLocksOnGrab), Op.Equals, true)]
        [SerializeField] protected GrabLock grabLock;
        [ReadOnly] [SerializeField] protected ObjectHighlighting highlight;
        
        [SerializeField] protected ResocketableItem resocketableItem;
        [SerializeField] protected List<Renderer> renderers = new();
        
        [Flags]
        private enum ActivateDeactivateAction
        {
            SetGameObjectActive = 1 << 0,
            UseGravity = 1 << 1,
            SetKinematic = 1 << 2,
            SetGrabbable = 1 << 3,
            SetObjectTooltipActive = 1 << 5,
        }

        [Group("Interactions")][SerializeField] private bool disableOnStart;
        [Group("Interactions")][SerializeField] private bool disableKinematicOnGrab = true;
        [Group("Interactions")][SerializeField] private bool grabbableLocksOnGrab;
        [Group("Interactions")][SerializeField] private ActivateDeactivateAction actionsOnActivate;
        [Group("Interactions")][SerializeField] private ActivateDeactivateAction actionsOnDeactivate;

        [Group("Audio")][Obsolete, SerializeField] private AudioClip soundEffectOnGrab;
        [Group("Audio")][SerializeField] private AudioSource audioSource;
        [Group("Audio")][SerializeField] private ObjectTooltip objectTooltip;
        [Group("Audio")][SerializeField] private List<SoundOption> onGrabSounds = new();
        [Group("Audio")][SerializeField] private List<SoundOption> onReleaseSounds = new();
        
        [Header("Listen to:")] 
        [SerializeField, IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string activateObjectEvent;
        [SerializeField, IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string returnToOriginalPositionEvent;
        [SerializeField]
        private bool isKinematicAfterReturnToOrigin;

        [Header("Invoke:"), SerializeField, IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string onDisableObjectEvent;
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string onGrabbedObjectEvent;
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string onReleaseObjectEvent;
        
        private bool isInInteractionVisibleRange;
        public bool IsInInteractionVisibleRange
        {
            get => isInInteractionVisibleRange;
            set
            {
                isInInteractionVisibleRange = value;
                TryDoRimEffect(isInInteractionVisibleRange);
            }
        }

        public bool IsGrabbed => grabbable.IsHeld();
        private bool canRelease;
        public bool CanRelease
        {
            get => canRelease;
            set
            {
                canRelease = value;
                
                if (grabLock == null)
                {
                    grabLock = gameObject.GetOrAddComponent<GrabLock>();
                }
                
                grabLock.enabled = !canRelease;
            }
        }
        
        private bool canGrab;
        public bool CanGrab
        {
            get => canGrab;
            set
            {
                canGrab = value;
                grabbable.isGrabbable = false;
            }
        }

        public bool CanBeInstalled { get; protected set; } = true;
        public bool IsPlaced => grabbable.placePoint != null;

        private bool isInitialized;
        private Vector3 originalLocalPosition;
        private Quaternion originalLocalRotation;
        private Tween returnSequence;
        
        protected virtual void OnValidate()
        {
            if (grabbable == null)
            {
                grabbable = GetComponent<Grabbable>();
            }

            if (rb == null)
            {
                rb = GetComponentInChildren<Rigidbody>();
            }
            
            if (audioSource == null)
            {
                audioSource = GetComponent<AudioSource>();
            }

            if (objectTooltip == null)
            {
                objectTooltip = GetComponentInChildren<ObjectTooltip>();
            }

            if (resocketableItem == null)
            {
                resocketableItem = GetComponent<ResocketableItem>();
            }

            if (renderers.Count < 1)
            {
                renderers = GetComponentsInChildren<Renderer>().ToList();
            }

            if (highlight == null)
            {
                highlight = gameObject.GetOrAddComponent<ObjectHighlighting>();
            }

            if (grabLock == null)
            {
                grabLock = gameObject.GetOrAddComponent<GrabLock>();
            }
        }

        protected virtual void Awake()
        {
            CanRelease = !grabbableLocksOnGrab;
        }

        protected virtual void Start()
        {
            originalLocalPosition = transform.localPosition;
            originalLocalRotation = transform.localRotation;

            grabbable.OnHighlightEvent += HandleHoverEnter;
            grabbable.OnUnhighlightEvent += HandleHoverExit;
            grabbable.OnGrabEvent += HandleObjectGrabbed;
            grabbable.OnReleaseEvent += HandleObjectReleased;
            grabbable.OnPlacePointAddEvent += HandleObjectSocketed;

            if (disableOnStart)
            {
                gameObject.SetActive(false);
            }
            
            if (!string.IsNullOrEmpty(activateObjectEvent) || !string.IsNullOrEmpty(returnToOriginalPositionEvent))
            {
                LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
            }
        }
        
        protected virtual void OnDestroy()
        {
            grabbable.OnHighlightEvent -= HandleHoverEnter;
            grabbable.OnUnhighlightEvent -= HandleHoverExit;
            grabbable.OnGrabEvent -= HandleObjectGrabbed;
            grabbable.OnReleaseEvent -= HandleObjectReleased;
            grabbable.OnPlacePointAddEvent -= HandleObjectSocketed;
            
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }
        }
        
        private void HandleHoverEnter(Hand hand, Grabbable _)
        {
            if (IsGrabbed)
            {
                ProcessUnhover();
                return;
            }
            
            ProcessHover();
        }
        
        private void HandleHoverExit(Hand hand, Grabbable _)
        {
            ProcessUnhover();
        }

        #region Hover Unhover

        [ContextMenu("Test hover")]
        protected virtual void ProcessHover()
        {
            InteractableObjectManager.Instance.RegisterHover(this);

            if (highlight != null)
            {
                highlight.DoInteractableHighlight(true);
            }
        }
        
        [ContextMenu("Test unhover")]
        protected virtual void ProcessUnhover()
        {
            InteractableObjectManager.Instance.UnregisterHover(this);
            if (highlight != null)
            {
                highlight.DoInteractableHighlight(false);
                TryDoRimEffect(true);
            }
        }

        private void TryDoRimEffect(bool enable, bool immediate = false)
        {
            if (!enable && isInInteractionVisibleRange && !IsGrabbed)
            {
                return;
            }

            if(enable && IsGrabbed)
            {
                return;
            }

            if (highlight != null)
            {
                highlight.DoRimEffect(enable, immediate);
            }
        }
        
        #endregion
        
        /// <summary>
        /// Handles the event when the PPE object is grabbed, playing a sound,
        /// disabling the highlight, and performing additional actions asynchronously.
        /// </summary>
        protected virtual void HandleObjectGrabbed(Hand hand, Grabbable _)
        {
            if (disableKinematicOnGrab && rb != null)
            {
                rb.isKinematic = false;
            }
            
            if (soundEffectOnGrab != null)
            {
                audioSource.PlayOneShot(soundEffectOnGrab);
            }
            else
            {
                PlaySoundOneShotRandomFromList(onGrabSounds);
            }
           
            //HighlightObject(false);
            OnInteractableObjectGrabbed?.Invoke(this);
            LdxTrackingManager.Instance.BroadcastTrackingEvent(onGrabbedObjectEvent);
        }
        
        protected virtual void HandleObjectReleased(Hand hand, Grabbable _)
        {
            if (grabbable.HeldCount() < 1)
            {
                OnInteractableObjectReleased?.Invoke(this);
            }
            
            PlaySoundOneShotRandomFromList(onReleaseSounds);
            TryDoRimEffect(true);
            LdxTrackingManager.Instance.BroadcastTrackingEvent(onReleaseObjectEvent);
        }
        
        protected virtual void HandleObjectSocketed(PlacePoint point, Grabbable _)
        {
            OnInteractableObjectSocketed?.Invoke(this, point);
        }

        /// <summary>
        /// Toggles the object tooltip of the PPE object.
        /// If the component is on the same game object as this PPEObject class - will disable the component only.
        /// </summary>
        /// <param name="setActive">Indicates whether to set active or not.</param>
        protected void SetObjectTooltipActive(bool setActive)
        {
            if (objectTooltip == null)
            {
                return;
            }
            
            if (objectTooltip.gameObject == gameObject)
            {
                objectTooltip.enabled = setActive;
            }
            else
            {
                objectTooltip.gameObject.SetActive(setActive);
            }
        }
        
         /// <summary>
        /// Activates the interactable object by applying specified activation actions.
        /// </summary>
        public void ActivateObject()
        {
            ApplyActions(actionsOnActivate, true);
        }

        /// <summary>
        /// Deactivates the interactable object by applying specified deactivation actions.
        /// </summary>
        /// <param name="disableObject">Indicates if the object should be disabled.</param>
        public void DeactivateObject(bool disableObject)
        {
            ApplyActions(actionsOnDeactivate, false, disableObject);
        }
        
        /// <summary>
        /// Applies a set of actions to either activate or deactivate the interactable object.
        /// </summary>
        /// <param name="actions">The set of actions to apply.</param>
        /// <param name="activate">Indicates whether to activate or deactivate actions.</param>
        /// <param name="disableObject">Indicates if the object should be disabled.</param>
        private void ApplyActions(ActivateDeactivateAction actions, bool activate, bool disableObject = false)
        {
            if (actions.HasFlag(ActivateDeactivateAction.SetGameObjectActive))
            {
                gameObject.SetActive(activate || !disableObject);
            }
            
            if (actions.HasFlag(ActivateDeactivateAction.UseGravity))
            {
                rb.useGravity = activate;
            }
            
            if (actions.HasFlag(ActivateDeactivateAction.SetKinematic))
            {
                rb.isKinematic = !activate;
            }
            
            if (actions.HasFlag(ActivateDeactivateAction.SetGrabbable))
            {
                grabbable.isGrabbable = activate;
            }

            if (actions.HasFlag(ActivateDeactivateAction.SetObjectTooltipActive))
            {
                SetObjectTooltipActive(activate);
            }
        }

        /// <summary>
        /// Forces the object to be released by all grabbers.
        /// </summary>
        public void ForceRelease()
        {
            grabbable.ForceHandsRelease();
        }
        
        /// <summary>
        /// Handles a tracking event and activates the PPE object if the event ID matches.
        /// </summary>
        private void HandleTrackingEvent(string id)
        {
            if (id == activateObjectEvent)
            {
                ActivateObject();
            }
            else if (id == returnToOriginalPositionEvent)
            {
                ReturnToPositionAsync().Forget();
            }
        }

        /// <summary>
        /// Broadcasts a tracking event to signal that the object has been deactivated.
        /// </summary>
        protected void BroadcastInteractableObjectDeactivated()
        {
            LdxTrackingManager.Instance.BroadcastTrackingEvent(onDisableObjectEvent);
        }
        
        public void PlaySoundOneShotRandomFromList(List<SoundOption> options)
        {
            if (options == null || options.Count == 0)
            {
                return;
            }

            SoundOption option = options.Where(x => !string.IsNullOrEmpty(x.soundReference)).ToList().Random();
            Audio.PlayOneShot(option.soundReference, transform.position);
        }
        
        public async UniTask ReturnToPositionAsync(Transform overrideOrigin = null)
        {
            Vector3 endPosition = overrideOrigin ?  transform.parent.InverseTransformPoint(overrideOrigin.position) : originalLocalPosition;
            Quaternion endRotation = overrideOrigin ? overrideOrigin.rotation : originalLocalRotation;
           
            rb.isKinematic = true;
            grabbable.isGrabbable = false;
            returnSequence?.Kill();
            returnSequence = DOTween.Sequence()
                .Append(transform.DOLocalMove(endPosition, RETURN_DURATION))
                .Join(transform.DOLocalRotateQuaternion(endRotation, RETURN_DURATION));

            await returnSequence;
            rb.isKinematic = isKinematicAfterReturnToOrigin;
            grabbable.isGrabbable = true;
        }
        
        public void IgnoreResocket(bool ignore)
        {
            if (resocketableItem == null)
            {
                return;
            }

            resocketableItem.IgnoreReturn = ignore;
        }

        /// <summary>
        /// Calculates the combined world-space bounds of all *enabled* renderers associated with this object.
        /// </summary>
        /// <param name="combinedBounds">The resulting combined bounds.</param>
        /// <param name="isVisible"></param>
        /// <returns>True if bounds could be calculated (at least one enabled renderer found), false otherwise.</returns>
        public bool TryGetCombinedBounds(out Bounds combinedBounds, out bool isVisible)
        {
            isVisible = false;
            if (renderers == null || renderers.Count == 0)
            {
                combinedBounds = new Bounds(transform.position, Vector3.zero);
                return false;
            }

            bool boundsInitialized = false;
            combinedBounds = new Bounds(); // Default constructor

            foreach (Renderer r in renderers)
            {
                if (r != null && r.enabled)
                {
                    if (!boundsInitialized)
                    {
                        combinedBounds = r.bounds;
                        boundsInitialized = true;
                    }
                    else
                    {
                        combinedBounds.Encapsulate(r.bounds);
                    }

                    if (r.isVisible)
                    {
                        isVisible = true;
                    }
                }
            }

            return boundsInitialized;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/InteractableObject.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/InteractableObjectManager.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bc748752d40741859fab29ff1bcf155e
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Utilities;

namespace Ldx.Framework.Features.Interaction
{
    public class InteractableObjectManager : Singleton<InteractableObjectManager>
    {
        private readonly HashSet<InteractableObject> hoveredObjects = new();
        
        public static IEnumerable<InteractableObject> HoveredObjects => Instance.hoveredObjects;
        public static int HoveredObjectsCount => Instance.hoveredObjects.Count;
        
        public void ClearHovers()
        {
            hoveredObjects.Clear();
        }

        public void RegisterHover(InteractableObject obj)
        {
            if (obj != null)
            {
                hoveredObjects.Add(obj);
            }
        }

        public void UnregisterHover(InteractableObject obj)
        {
            if (obj != null)
            {
                hoveredObjects.Remove(obj);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/InteractableObjectManager.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/InteractableObjectsGlobalSettings.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1a76c49a706b4b4881177bf51ed81e9c
# ASMDEF: ldx.framework.runtime.dll
# ---
using HighlightPlus;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Misc;
using UnityEngine;

namespace Ldx.Framework.Features.Interaction
{
    [HasFrameworkDefault]
    public class InteractableObjectsGlobalSettings : GlobalSettings<InteractableObjectsGlobalSettings>
    {
        [SerializeField] private OutlineProfile outlineProfile = new OutlineProfile();
        public static OutlineProfile OutlineProfile => Instance.outlineProfile;

#if UNITY_EDITOR
        [UnityEditor.SettingsProvider]
        public static UnityEditor.SettingsProvider CreateSettingsProvider()
        {
            return CreateGlobalSettingsProvider("Project/LDX/Systems/Interactable Objects");
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/InteractableObjectsGlobalSettings.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/InteractionIconFeature/InteractionIconRenderPass.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ea05bc39a9174c789d029ca5f3ed1e62
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.RenderGraphModule;
using UnityEngine.Rendering.Universal;

namespace Ldx.Framework.Features.Interaction.InteractionIconFeature
{
    public class InteractionIconRenderPass : ScriptableRenderPass
    {
        private const string PROFILER_TAG = "Interaction Icons Pass";
        
        private readonly InteractionIconRenderPassFeature.PassSettings passSetting;
        private readonly ProfilingSampler profileSampler;
        
        class PassData
        {
            internal TextureHandle cameraColor;
            internal Camera camera;
        }

        public InteractionIconRenderPass(InteractionIconRenderPassFeature.PassSettings settings)
        {
            passSetting = settings;
            profileSampler = new ProfilingSampler(PROFILER_TAG);
        }
        
        public override void RecordRenderGraph(RenderGraph renderGraph, ContextContainer frameData)
        {
            if (!InteractableObjectManager.IsValid ||
                InteractableObjectManager.HoveredObjectsCount == 0 ||
                passSetting.iconMaterial == null || passSetting.quadMesh == null)
                return;
            
            UniversalResourceData resources = frameData.Get<UniversalResourceData>();
            UniversalCameraData cameraData = frameData.Get<UniversalCameraData>();

            using IRasterRenderGraphBuilder builder = renderGraph.AddRasterRenderPass(PROFILER_TAG, out PassData passData, profileSampler);

            passData.cameraColor = resources.activeColorTexture;
            passData.camera = cameraData.camera;

            builder.SetRenderAttachment(passData.cameraColor, 0);
            builder.AllowPassCulling(false);

            builder.SetRenderFunc((PassData data, RasterGraphContext ctx) =>
            {
                DrawIcons(ctx.cmd, data.camera);
            });
        }
        
        private void DrawIcons(RasterCommandBuffer cmd, Camera camera)
        {
            Transform cameraTransform = camera.transform;

            foreach (InteractableObject obj in InteractableObjectManager.HoveredObjects)
            {
                if (obj == null || !obj.isActiveAndEnabled) continue;
                if (!obj.TryGetCombinedBounds(out Bounds bounds, out bool visible) || !visible) continue;

                Vector3 topCenter = new(bounds.center.x, bounds.max.y, bounds.center.z);
                Vector3 worldPos = topCenter + Vector3.up * passSetting.verticalOffset;
                Quaternion rotation = Quaternion.LookRotation(worldPos - cameraTransform.position, cameraTransform.up);
                Vector3 scale = Vector3.one * passSetting.iconSize;

                cmd.DrawMesh(passSetting.quadMesh, Matrix4x4.TRS(worldPos, rotation, scale), passSetting.iconMaterial);
            }
        }

        /// <summary>
        /// Overrides the obsolete Execute method to silence the base class's "not implemented" warning.
        /// </summary>
        /// <remarks>
        /// **INTENTIONAL: This Render Pass is designed to work exclusively with the Render Graph system.**
        /// By providing an empty override, we are explicitly choosing not to support the legacy rendering path
        /// to avoid code duplication and enforce a modern rendering workflow.
        /// <br/><br/>
        /// **IMPORTANT:** For this feature to function correctly, "Use Render Graph" MUST be enabled in the
        /// project's URP Asset. If this feature is not working, that setting is the first thing to check.
        /// </remarks>
        [Obsolete(
            "This rendering path is for compatibility mode only (when Render Graph is disabled). Use Render Graph API instead.",
            false)]
        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
        {
            Debug.LogWarning(
                "<b>[InteractionIconRenderPass]</b> is running in legacy rendering mode... To fix this, please enable 'Use Render Graph' in your URP settings."
            );
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/InteractionIconFeature/InteractionIconRenderPass.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/InteractionIconFeature/InteractionIconRenderPassFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c0a784abfbc04f1282be7136afac22f7
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;
using UnityEngine.Rendering.Universal;

namespace Ldx.Framework.Features.Interaction.InteractionIconFeature
{
    public class InteractionIconRenderPassFeature : ScriptableRendererFeature
    {
        [System.Serializable]
        public class PassSettings
        {
            public Material iconMaterial;
            public Mesh quadMesh;
            public float iconSize = 0.2f;
            public float verticalOffset = 0.1f;
        }
        
        [SerializeField] private RenderPassEvent renderPassEvent = RenderPassEvent.AfterRenderingOpaques;
        [SerializeField] private PassSettings passSetting = new();

        private InteractionIconRenderPass renderPass;
        
        public override void Create()
        {
            renderPass = new InteractionIconRenderPass(passSetting)
            {
                renderPassEvent = renderPassEvent
            };
        }

        public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)
        {
            if (passSetting.iconMaterial == null || passSetting.quadMesh == null)
            {
                Debug.LogWarning("Interaction Icon Feature: Missing Material or Quad Mesh.");
                return;
            }
            
            renderer.EnqueuePass(renderPass);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/InteractionIconFeature/InteractionIconRenderPassFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/KinematicGrabbable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 873f39c5243b4697a3f8ca5c27cac63e
# ASMDEF: ldx.framework.runtime.dll
# ---
/*using System;
using System.Collections.Generic;
using Autohand;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.Player.Hands;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;
using UnityEngine.Events;

namespace Ldx.Framework.Features.Interaction
{
    /// <summary>
    /// Base class for grabbable area that given a start and a finish reference transforms, acts like a grab to
    /// lerp an aspect of the object that can be defined through implementation 
    /// </summary>
    public abstract class KinematicGrabbable : MonoBehaviour
    {
        public class GrabberInfo
        {           
            public Grabbable Grabber { get; }
            public bool ShouldUpdateGrabber { get; }
            public HVRTrackedController CurrentController =>
                Grabber == null ? null : Grabber.HVRTrackedController;
            public Vector3 LastControllerPosition { get; set; }
            public Vector3 ControllerPosition => CurrentController.transform.position;

            public GrabberInfo(HVRHandGrabber grabber, bool shouldUpdateGrabber)
            {
                Grabber = grabber;
                ShouldUpdateGrabber = shouldUpdateGrabber;
            }
        }

        public enum InitializeConfigTypes
        {
               InitOnStart = 0,
               InitOnProgressActive
        }
        
        private const float PROGRESS_TO_FINISH = 0.95f;
        private const float OFFSET_MULTIPLIER = 230f;
        
        public event Action<KinematicGrabbable> OnGrabbed;

        private static HashSet<HVRHandGrabber> allLockedHandsSet = new();
        /// <summary>
        /// Invoked when the grabbable is released
        /// Reports the kinematic grabbable ref and whether this
        /// release was due to the feature completing
        /// </summary>
        public event Action<KinematicGrabbable, bool> OnReleased;
        public event Action<KinematicGrabbable> OnFinished;
        public UnityEvent OnGrabbedUE;
        public UnityEvent OnReleasedUE;
        public UnityEvent OnFinishedUE;

        [SerializeField]
        private bool activeOnStart;
        [SerializeField]
        private string label;
        [Header("Events")]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField]
        private string activateEvent;
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField]
        private string completionEvent;

        [Header("Settings")] 
        [SerializeField] 
        private InitializeConfigTypes initializeConfig = InitializeConfigTypes.InitOnStart;
        [SerializeField]
        private bool onlyProgressForward;
        [SerializeField]
        private bool resetProgressOnRelease;
        [SerializeField]
        private bool registerSustainedGrip;
        [SerializeField]
        private bool allowReleaseBeforeCompletion = true;
        [SerializeField]
        private bool onlyCompleteManually;
        [SerializeField]
        private bool takesOverBothHands;
        [ShowIf("takesOverBothHands", Op.Equals, true)]
        [SerializeField]
        private bool usesEitherHandsForProgress;
        [SerializeField]
        private bool useAbsolutePositioning;
        [SerializeField] 
        private bool shouldPlayAnotherKinematicGrabbableAfter;
        [ShowIf("shouldPlayAnotherKinematicGrabbableAfter", Op.Equals, true)] 
        [SerializeField]
        private KinematicGrabbable kinematicGrabbableToPlayAfter;
        
        [Header("Movement")]
        [SerializeField]
        private Transform handStartReferenceTransform;
        [SerializeField]
        private Transform handEndReferenceTransform;

        [Header("Visuals")]
        [SerializeField]
        private bool hidePlayerHand = true;
        [SerializeField]
        private GhostHandGuide.GhostHandGuide handGuide;
        [SerializeField]
        private bool activateHandGuideOnInitialize;
        
        private HVRHandGrabber activeGrabber;
        public HVRHandGrabber ActiveGrabber => activeGrabber;

        private HVRHandGrabber lastValidGrabber;
        private float currentProgressDistance;
        private Vector3 startEndDir;
        private float startEndDistance;
        private Vector3 lastControllerPosition;
        private bool? wasGripButtonActive;
        private bool isWithinTrigger;
        private bool finished;

        private readonly List<GrabberInfo> possessedGrabbers = new List<GrabberInfo>();
        private readonly Dictionary<Collider, HVRHandGrabber> colliderToHandGrabberMap =
            new Dictionary<Collider, HVRHandGrabber>();

        public bool IsPaused { get; private set; }
        public bool IsActive { get; private set; }
        public bool IsFinished => finished;
        public bool IsHandLockedIn { get; private set; }
        public bool IsGrabbingBlocked { get; set; }
        public bool IsManuallyUpdatingProgress { get; set; }
        public bool UsesEitherHandsForProgress => takesOverBothHands && usesEitherHandsForProgress;
        private bool CanUpdateGrabbers => activeGrabber != null && possessedGrabbers.Count > 0;
        public HandsController HandsController => PlayerController.Instance.HandsController;
        public float Progress { get; protected set; }

        private void Awake()
        {
            if (LdxTrackingManager.Instance != null)
            {
                LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
            }

            if (ScenarioManager.Instance != null)
            {
                ScenarioManager.Instance.OnUnloadingScenarioOrLobby += HandleUnloading;
            }

            SetHandGuideActive(false);
            
            if (initializeConfig == InitializeConfigTypes.InitOnStart)
            {
                Initialize();
            }
            
            if (activeOnStart)
            {
                SetActive(true);
            }
        }

        private void OnDestroy()
        {
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }
            
            if (ScenarioManager.IsValid)
            {
                ScenarioManager.Instance.OnUnloadingScenarioOrLobby -= HandleUnloading;
            }
        }
        
        public virtual void Initialize()
        {
            Vector3 start = handStartReferenceTransform.position;
            Vector3 end = handEndReferenceTransform.position;
            startEndDir = (end - start).normalized;
            startEndDistance = Vector3.Distance(end, start);

            if (activateHandGuideOnInitialize)
            {
                SetHandGuideActive(true);
            }
            
            initAsync().Forget();

            async UniTaskVoid initAsync()
            {
                //TODO: 
                /*await UniTask.WaitUntil(()=>PlayerController.IsValid);
                colliderToHandGrabberMap.Clear();
                HVRHandGrabber leftGrabber = HandsController.LeftHand;
                HVRHandGrabber rightGrabber = HandsController.RightHand;
                leftGrabber.GetComponentsInChildren<FingerTipMarker>()
                    .ForEach(f => addCollider(f, leftGrabber));
                rightGrabber.GetComponentsInChildren<FingerTipMarker>()
                    .ForEach(f => addCollider(f, rightGrabber));#1#
            }

            void addCollider(FingerTipMarker f, HVRHandGrabber grabber)
            {
                if (!f.TryGetComponent(out Collider c))
                {
                    return;
                }
                colliderToHandGrabberMap.Add(c, grabber);
            }
        }

        public void ResetFeature()
        {
            finished = false;
            currentProgressDistance = 0.0f;
            UpdateProgress(0.0f);
            if (activeGrabber != null)
            {
                UnlockHand();
            }
        }
        
        private void Update()
        {
            if (activeGrabber != null)
            {
                lastValidGrabber = activeGrabber;
            }
            if (IsPaused)
            {
                UpdatePaused();
            }
            if (!IsActive || IsPaused)
            {
                return;
            }

            UpdateActive();

            if (!IsHandLockedIn)
            {
                return;
            }
            
            UpdateHandLockedIn();
        }

        public void SetPaused(bool isPaused)
        {
            IsPaused = isPaused;
        }

        public virtual void UpdateProgress(float progress)
        {
            if (onlyProgressForward)
            {
                progress = Mathf.Max(progress, Progress);
            }

            progress = Mathf.Clamp01(progress);
            Progress = progress;
        }
        
        private void OnTriggerEnter(Collider other)
        {
            ProcessTriggerEnterOrStay(other);
        }
        
        private void OnTriggerStay(Collider other)
        {
            ProcessTriggerEnterOrStay(other);
        }

        private void ProcessTriggerEnterOrStay(Collider other)
        {
            colliderToHandGrabberMap.TryGetValue(other, out HVRHandGrabber foundGrabber);
            
            if (!IsActive || IsHandLockedIn || foundGrabber == null)
            {
                return;
            }

            activeGrabber = foundGrabber;

            if (activeGrabber == null)
            {
                return;
            }
            
            isWithinTrigger = true;
        }
        
        private void OnTriggerExit(Collider other)
        {
            if (!IsActive || activeGrabber == null || IsHandLockedIn)
            {
                return;
            }

            HVRHandGrabber handGrabber = null;
            
            if (colliderToHandGrabberMap.TryGetValue(other, out HVRHandGrabber foundGrabber))
            {
                handGrabber = foundGrabber;
            }

            if (handGrabber == null)
            {
                return;
            }
            
            if (handGrabber == activeGrabber)
            {
                isWithinTrigger = false;
            }
        }
        
        private void UpdateActive()
        {
            if (activeGrabber == null || IsGrabbingBlocked )
            {
                return;
            }
            bool isGripButtonActive = HandsController.IsGripButtonActiveForHand(activeGrabber);
            bool isGripActive = false;
            if (isGripButtonActive)
            {
                // Sustained grip is when the hand enters the area while holding grip
                if (registerSustainedGrip)
                {
                    isGripActive = true;
                }
                else
                {
                    if (wasGripButtonActive != null
                        && !wasGripButtonActive.Value)
                    {
                        isGripActive = true;
                    }
                }
            }
            
            if (!IsHandLockedIn 
                && activeGrabber.GrabbedTarget == null 
                && isGripActive
                && !allLockedHandsSet.Contains(activeGrabber))
            {
                ActivateHandLockedIn();
            }

            wasGripButtonActive = isGripButtonActive;
        }

        private void UpdatePaused()
        {
            foreach (GrabberInfo g in possessedGrabbers)
            {
                g.LastControllerPosition = g.ControllerPosition;
            }
        }
        
        private void UpdateHandLockedIn()
        {
            if (allowReleaseBeforeCompletion 
                && CanUpdateGrabbers 
                && !HandsController.IsGripButtonActiveForHand(activeGrabber))
            {
                UnlockHand();
                return;
            }
            
            if (!IsManuallyUpdatingProgress)
            {
                if (useAbsolutePositioning)
                {
                    updateProgressThroughAbsolutePositioning();
                }
                else
                {
                    updateProgressThroughControllersOffset();
                }
            }

            if (Progress >= PROGRESS_TO_FINISH && !finished && !onlyCompleteManually)
            {
                CompleteFeature();
            }

            void updateProgressThroughAbsolutePositioning()
            {
                foreach (GrabberInfo g in possessedGrabbers)
                {
                    if (!g.ShouldUpdateGrabber)
                    {
                        continue;
                    }

                    Vector3 start = handStartReferenceTransform.position.Modify(y: g.ControllerPosition.y);
                    Vector3 end = handEndReferenceTransform.position.Modify(y: g.ControllerPosition.y);
                    UpdateProgress(VectorExtensions.InverseLerp( start,end, g.ControllerPosition));
                }
            }
            
            void updateProgressThroughControllersOffset()
            {
                float maxDotProduct = float.MinValue;
                Vector3 maxControllerOffset = Vector3.zero;
            
                foreach (GrabberInfo g in possessedGrabbers)
                {
                    if (!g.ShouldUpdateGrabber)
                    {
                        continue;
                    }
                    Vector3 controllerPosition = g.ControllerPosition;
                    Vector3 controllerOffset = controllerPosition - g.LastControllerPosition;
                    float dotProduct = Vector3.Dot(controllerOffset * OFFSET_MULTIPLIER, startEndDir);
                    g.LastControllerPosition = controllerPosition;
                    if (dotProduct > maxDotProduct)
                    {
                        maxDotProduct = dotProduct;
                        maxControllerOffset = controllerOffset;
                    }
                }

                updateProgress(maxDotProduct, maxControllerOffset);
            }
            
            void updateProgress(float dotProduct, Vector3 offset)
            {
                currentProgressDistance += dotProduct * offset.magnitude;
                currentProgressDistance = Mathf.Clamp(currentProgressDistance,0, startEndDistance);
                float progress = currentProgressDistance / startEndDistance;
                UpdateProgress(progress);
            }
        }

        public void ForceActivateAndGrab(HVRHandGrabber handGrabber)
        {
            if (allLockedHandsSet.Contains(handGrabber))
            {
                return;
            }
            activeGrabber = handGrabber;
            currentProgressDistance = 0.0f;
            SetActive(true);
            ActivateHandLockedIn();
            SetHandGuideActive(false);
        }

        public void ForceActiveAndPausedNoHands()
        {
            activeGrabber = null;
            currentProgressDistance = 0.0f;
            SetActive(true);
            SetPaused(true);
        }
        
        public void CompleteFeature()
        {
            finished = true;
            UnlockHand();
            BroadcastCompletion();
            SetActive(false);
            TryPlayNextKinematicGrabbable();
            SetHandGuideActive(false);
        }

        private void TryPlayNextKinematicGrabbable()
        {
            if (!shouldPlayAnotherKinematicGrabbableAfter || kinematicGrabbableToPlayAfter == null)
            {
                return;
            }
            kinematicGrabbableToPlayAfter.ForceActivateAndGrab(lastValidGrabber);
        }
        
        private void BroadcastCompletion()
        {
            OnFinished?.Invoke(this);
            OnFinishedUE?.Invoke();
            if (LdxTrackingManager.Instance != null)
            {
                LdxTrackingManager.Instance.BroadcastTrackingEvent(completionEvent);
            }
        }

        public void UnlockHand()
        {
            if (activeGrabber != null)
            {
                possessedGrabbers.ForEach(g => allLockedHandsSet.Remove(g.Grabber));
                if (IsHandLockedIn)
                {
                    OnReleased?.Invoke(this, finished);
                    OnReleasedUE?.Invoke();
                }

                //TODO: 
                /*foreach (GrabberInfo g in possessedGrabbers)
                {
                    g.Grabber.enabled = true;
                    Hand hand = HandsController.GetHand(g.Grabber.HandSide);
                    hand.SetRenderersEnabled(true);
                    hand.ResetCollision();
                }#1#
                possessedGrabbers.Clear();
                IsHandLockedIn = false;
                if (!isWithinTrigger)
                {
                    activeGrabber = null;
                }
                if (!finished && resetProgressOnRelease)
                {
                    currentProgressDistance = 0.0f;
                    UpdateProgress(0);
                }
            }
        }
        
        private void ActivateHandLockedIn()
        {
            if (!IsHandLockedIn)
            {
                OnGrabbed?.Invoke(this);
                OnGrabbedUE?.Invoke();
            }
            IsHandLockedIn = true;
            
            SetHandGuideActive(false);
            
            possessedGrabbers.Clear();
            possessedGrabbers.Add(new GrabberInfo(activeGrabber, shouldUpdateGrabber: true));

            //TODO: 
            /*if (takesOverBothHands)
            {
                HVRHandGrabber otherGrabber = activeGrabber == HandsController.LeftHand
                    ? HandsController.RightHand
                    : HandsController.LeftHand;

                if (!allLockedHandsSet.Contains(otherGrabber))
                {
                    possessedGrabbers.Add(new GrabberInfo(otherGrabber, shouldUpdateGrabber: UsesEitherHandsForProgress));
                }
            }#1#

            allLockedHandsSet.UnionWith(possessedGrabbers.Select(g=>g.Grabber));
            
            //TODO: 
            /*
            foreach (GrabberInfo g in possessedGrabbers)
            {
                g.Grabber.enabled = false;
                Hand hand = HandsController.GetHand(g.Grabber.HandSide);
                if (hidePlayerHand)
                {
                    hand.SetRenderersEnabled(false);
                }
                hand.DisableCollision();
                g.LastControllerPosition = g.ControllerPosition;
            }#1#
        }

        private void HandleTrackingEvent(string id)
        {
            if (id == activateEvent)
            {
                currentProgressDistance = 0.0f;
                SetActive(true);
            }
        }
        
        private void HandleUnloading(ScenarioManager scenarioManager)
        {
            allLockedHandsSet.Clear();
        }
        
        public void SetActive(bool isActive)
        {
            IsActive = isActive;
            if (!IsActive)
            {
                activeGrabber = null;
                IsHandLockedIn = false;
            }
            else
            {
                if (initializeConfig == InitializeConfigTypes.InitOnProgressActive)
                {
                    Initialize();
                }
            }
        }

        #region Hand Guide

        public void SetHandGuideActive(bool isActive)
        {
            if (handGuide == null)
            {
                return;
            }
            
            if (isActive)
            {
                handGuide.AnimateHand(handEndReferenceTransform, startPoint:handStartReferenceTransform);
            }
            else
            {
                handGuide.ResetHand();
            }
        }

        #endregion
    }
}*/
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/KinematicGrabbable.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/ObjectHighlighting.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4dc0aa0daaa1404bae86197d1b7606f7
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using DG.Tweening;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Misc;
using MarkupAttributes;
using UnityEngine;

namespace Ldx.Framework.Features.Interaction
{
    public class ObjectHighlighting : MonoBehaviour, ISaveSceneListener
    {
        private const float RIM_FADE_DURATION = 0.25f;
        private const float RIM_TARGET_VALUE = 0.3f;
        private const float OUTLINE_WIDTH = 5f;
        private const float OUTLINE_TWEEN_DURATION = 0.25f;
        
        private static readonly int RimAttenuation = Shader.PropertyToID("_RimAttenuation");
        
        [SerializeField] protected List<Renderer> renderers = new();

        [SerializeField]
        private bool useOutline = true;
        public bool UseOutline
        {
            get => useOutline;
            set => useOutline = value;
        }
        
        [SerializeField, Utilities.Attributes.ReadOnly][HideIf(nameof(useOutline), true)]
        private Outline outline;
        
        private readonly List<Material> materials = new();
        private Sequence rimSequence;
        private bool rimEffectOn = true;
        private Tween outlineTween;
        
        public void OnSceneSaving()
        {
            renderers = GetComponentsInChildren<Renderer>().ToList();
        }

        private void OnValidate()
        {
            switch (useOutline)
            {
                case true when outline == null:
                    outline = gameObject.GetOrAddComponent<Outline>();
                    break;
                case false when outline != null:
#if UNITY_EDITOR
                    UnityEditor.EditorApplication.delayCall -= handleDelayCall;
                    UnityEditor.EditorApplication.delayCall += handleDelayCall;

                    void handleDelayCall()
                    {
                        DestroyImmediate(outline);
                        outline = null;
                    }
#endif
                    break;
            }

            if (outline != null)
            {
                outline.LoadProfile(InteractableObjectsGlobalSettings.OutlineProfile);
            }
            
            if (renderers.Count < 1)
            {
                renderers = GetComponentsInChildren<Renderer>().ToList();
            }
        }

        private void Awake()
        {
            materials.Clear();
            
            foreach (Renderer rend in renderers)
            {
                materials.AddRange(rend.materials);
            }
            
            DoRimEffect(false, true);
            DoOutlineEffect(false, true);
        }

        private void OnDestroy()
        {
            rimSequence?.Kill();
            outlineTween?.Kill();
        }

        public void DoInteractableHighlight(bool enable, bool immediate = false)
        {
            DoRimEffect(enable, immediate);
            DoOutlineEffect(enable, immediate);
        }

        /// <summary>
        /// Applies a rim effect to materials, fading between on/off state using DoTween.
        /// </summary>
        /// <param name="enable">True to fade the rim effect in (to 1), false to fade out (to 0).</param>
        /// <param name="immediate">If true, sets the value instantly without animation and kills any running tween.</param>
        public void DoRimEffect(bool enable, bool immediate = false)
        {
            if (materials.Count == 0)
            {
                Debug.LogWarning("DoRimEffect called with no materials assigned.", this);
                return;
            }

            if (rimEffectOn == enable)
            {
                return;
            }

            rimEffectOn = enable;
            rimSequence?.Kill();
            if (!immediate)
            {
                rimSequence = DOTween.Sequence();
            }
            
            float targetValue = enable ? RIM_TARGET_VALUE : 0f;
            
            foreach (Material mat in materials)
            {
                if (mat == null) continue; // Skip if a material in the list is null
                
                if (immediate)
                {
                    mat.SetFloat(RimAttenuation, targetValue);
                }
                else
                {
                    rimSequence.Join(mat.DOFloat(targetValue, RimAttenuation, RIM_FADE_DURATION)
                        .SetEase(Ease.InOutSine));
                }
            }
        }
        
        public void DoOutlineEffect(bool enable, bool immediate = false)
        {
            if (outline == null)
            {
                Debug.LogWarning("DoOutlineEffect called with no outline assigned.", this);
                return;
            }
            
            outlineTween?.Kill();
            
            float targetValue = enable ? OUTLINE_WIDTH : 0f;
            
            if (immediate)
            {
                outline.OutlineWidth = targetValue;
                return;
            }
            
            outlineTween = DOTween.To(
                    () => outline.OutlineWidth,
                    x => outline.OutlineWidth = x,
                    targetValue,
                    OUTLINE_TWEEN_DURATION
                )
                .SetEase(Ease.OutQuad);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/ObjectHighlighting.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/PlayerTriggerInteractableBag.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d87c006399e24520843c5bfc2a31ad93
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Features.Interaction
{
    [RequireComponent(typeof(SphereCollider))]
    public class PlayerTriggerInteractableBag : MonoBehaviour
    {
        private const float MIN_DISTANCE = 1f;

        [SerializeField] [Min(MIN_DISTANCE)]
        private float maxRadius = 2f;

        [SerializeField] [HideInInspector]
        private SphereCollider triggerCollider;
        
        [SerializeField] [HideInInspector]
        private DrawGizmo gizmo;
        
        private readonly Dictionary<Collider, InteractableObject> interactableObjectsColliderMap = new();

        private void OnValidate()
        {
            if (triggerCollider == null)
            {
                triggerCollider = gameObject.GetOrAddComponent<SphereCollider>();
            }

            triggerCollider.isTrigger = true;
            triggerCollider.radius = Mathf.Max(MIN_DISTANCE, maxRadius);

            if (gizmo == null)
            {
                gizmo = gameObject.GetOrAddComponent<DrawGizmo>();
            }

            gizmo.Label = "Trigger: Interactable Objects Range";
            gizmo.DrawGizmos = true;
            gizmo.Type = DrawGizmo.GizmoType.Sphere;
            gizmo.Radius = maxRadius;
        }

        private void OnTriggerEnter(Collider other)
        {
            if (other.TryGetComponent(out InteractableObject interactable) || other.TryGetComponentInParent(out interactable))
            {
                interactable.IsInInteractionVisibleRange = true;
                interactableObjectsColliderMap.TryAdd(other, interactable);
            }
        }

        private void OnTriggerExit(Collider other)
        {
            if (interactableObjectsColliderMap.TryGetValue(other, out InteractableObject interactable))
            {
                interactable.IsInInteractionVisibleRange = false;
                interactableObjectsColliderMap.Remove(other);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/PlayerTriggerInteractableBag.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/SlidingMechanism.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 55e9d85c54063d84d97e7ef61f7f1ed2
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.VFX;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Tools;
using UnityEngine;

namespace Ldx.Framework.Features.Interaction
{
    /// <summary>
    /// A powerful, reusable sliding mechanism that can be used to create any physical mechanism that is meant to be
    /// grabbed and manipulated between two points. Locks, A-B movable objects, sliding doors, etc. will work perfectly
    /// with this with very little setup required. 
    /// </summary>
    public class SlidingMechanism : MonoBehaviour
    {
        private const int WAIT_UNTIL_UNLOCK_MS = 1000;

        public Action<SlidingMechanism> OnLock;
        public Action<SlidingMechanism> OnUnlock;
        public Action<SlidingMechanism, VisualEffect> OnSpawnedCheckmark;

        [Header("Simple lock")]
        [SerializeField]
        private EventOnTrigger handTrigger;

        [Header("General")]
        [SerializeField] private bool freezeRotation = true;
        [SerializeField] private bool useFxOnComplete = true;

        [Header("References")]
        [SerializeField] private Transform minTransform;
        [SerializeField] private Transform maxTransform;

        [SoundReference]
        [SerializeField] private string lockingSound;
        [SoundReference]
        [SerializeField] private string unlockingSound;
        [SerializeField] private Transform lockYOffset;

        [Header("Events")]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string eventOnMax;
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)] [SerializeField]
        private string eventOnMin; // Generally can leave this empty

        [Header("Movement")]
        [SerializeField] private AxisWithFlags movementAxis = AxisWithFlags.X;
        [SerializeField] private bool overrideStartOnMin = true; // Are we automatically "at min" when we start?
        [SerializeField] private bool immovableOnMaxLock;
        [SerializeField] private Transform transformToOffset; // Only max lock once?
        [SerializeField] private Vector3 offsetTransformOnMaxLock; // When locked in place, we can slightly move the entire model

        public bool BlockInteraction { get; set; }
        
        private bool isLocked;
        private Vector3 finalLocalPosition;
        private bool initialized;
        private Tween lockTween;
        private bool isLocking;

        private void OnEnable()
        {
            Initialize().Forget();
        }

        private async UniTaskVoid Initialize()
        {
            await UniTask.Delay(WAIT_UNTIL_UNLOCK_MS);

            handTrigger.OnTargetTriggerEnter -= HandleHandTriggerEnter;
            handTrigger.OnTargetTriggerEnter += HandleHandTriggerEnter;
            transform.localPosition = minTransform.localPosition;
        }

        private void OnDestroy()
        {
            handTrigger.OnTargetTriggerEnter -= HandleHandTriggerEnter;
        }

        private void HandleHandTriggerEnter(EventOnTrigger eventOnTrigger, Collider col)
        {
            if (BlockInteraction || isLocking || isLocked)
            {
                return;
            }

            isLocking = true;
            lockTween?.Kill();
            lockTween = transform.DOLocalMove(maxTransform.localPosition, 0.75f).OnComplete(CompleteLock);
        }

        private void CompleteLock()
        {
            isLocking = false;
            isLocked = true;
            OnLock?.Invoke(this);

            if (useFxOnComplete)
            {
                VisualEffect checkmark = LdxFxController.Instance.InstantiateFx(LdxFxController.FX.Complete, maxTransform, new Vector3(0, -0.1f, 0), Vector3.zero,
                    destroyOnObjectiveEnd: true);
                OnSpawnedCheckmark?.Invoke(this, checkmark);
            }
            
            if (LdxTrackingManager.Instance != null)
            {
                LdxTrackingManager.Instance.BroadcastTrackingEvent(eventOnMax);
            }

            if (!string.IsNullOrEmpty(lockingSound))
            {
                Audio.PlayOneShot(lockingSound);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/SlidingMechanism.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/SplineMeshKinematicGrabbable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3ae57c9eef1e4f21a67ae55a84c69b21
# ASMDEF: ldx.framework.runtime.dll
# ---
/*using Ldx.Framework.Features.Splines;
using SplineMesh;
using UnityEngine;

namespace Ldx.Framework.Features.Interaction
{
    public class SplineMeshKinematicGrabbable : KinematicGrabbable
    {
        [SerializeField] private Spline targetSpline;
        [SerializeField] private Spline startSpline;
        [SerializeField] private Spline endSpline;

        private SplineInfo startState;
        private SplineInfo endState;

        public override void Initialize()
        {
            base.Initialize();
            startState = SplineInfo.GetInfo(startSpline);
            endState = SplineInfo.GetInfo(endSpline);
        }

        public override void UpdateProgress(float progress)
        {
            base.UpdateProgress(progress);
            SplineInfo.LerpSpline(startState, endState, targetSpline, Progress);
        }
    }
}*/
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/SplineMeshKinematicGrabbable.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/TransformKinematicGrabbable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 06cb616c2aa34f8a948d49d775fb944a
# ASMDEF: ldx.framework.runtime.dll
# ---
/*using System;
using System.Collections.Generic;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Features.Interaction
{
    /// <summary>
    /// Implementation of TweenGrabbable that lerps the values of one or more transforms
    /// to simulate grabbing without physics for a kinematic object
    /// </summary>
    public class TransformKinematicGrabbable : KinematicGrabbable
    {
        [Serializable]
        public enum OperationTypes
        {
            /// <summary>
            /// Progress modifies local position or rotation with a value
            /// </summary>
            LocalValueTransform = 0,
            /// <summary>
            /// Progress moves the target towards a reference transform
            /// </summary>
            ReferenceTransform,
            /// <summary>
            /// Progress modifies local position or rotation with curve
            /// </summary>
            LocalCurveTransform
        }
        
        [Serializable]
        public enum TransformComponents
        {
            Position = 0,
            Rotation
        }
        
        /// <summary>
        /// A single target of this implementation
        /// </summary>
        [Serializable]
        public class LerpTarget
        {
            [Header("Kinematic Tween Settings")]
            [SerializeField]
            private OperationTypes operationType = OperationTypes.LocalValueTransform;
            public OperationTypes OperationType => operationType;
            
            [SerializeField]
            private TransformComponents targetComponent = TransformComponents.Position;
            public TransformComponents TargetComponent => targetComponent;

            [SerializeField]
            private Transform targetTransform;
            public Transform TargetTransform => targetTransform;
            
            [Header("Settings for: Local Value Transform")]
            [SerializeField]
            private Axis valueAxis;
            public Axis ValueAxis => valueAxis;
            [SerializeField]
            private float endAxisLocalValue;
            public float EndAxisLocalValue => endAxisLocalValue;

            [SerializeField]
            private bool rotateClockwise = true;
            public bool RotateClockwise => rotateClockwise;

            [Header("Settings for: Reference Transform")]
            [SerializeField]
            private Transform endReferenceTransform;
            public Transform EndReferenceTransform => endReferenceTransform;
            
            [Header("Settings for: Local Curve Transform")]
            [SerializeField]
            private AnimationCurve curve = AnimationCurve.Linear(0, 0, 1, 0);
            public AnimationCurve Curve => curve;

            [SerializeField]
            private Axis curveEffectAxis;
            public Axis CurveEffectAxis => curveEffectAxis;
            
            [SerializeField]
            private float curveEffectMultiplier = 1.0f;
            public float CurveEffectMultiplier => curveEffectMultiplier;
            
            public TransformValuesCache LerpStartValues { get; set; }
            public TransformValuesCache LerpEndValues { get; set; }   
        }

        [SerializeField]
        private List<LerpTarget> lerpTargets = new List<LerpTarget>();
        public List<LerpTarget> LerpTargets => lerpTargets;

        public override void Initialize()
        {
            foreach (LerpTarget t in lerpTargets)
            {
                switch (t.OperationType)
                {
                    case OperationTypes.LocalValueTransform:
                        InitializeLocalValueTransform(t);
                        break;
                    case OperationTypes.ReferenceTransform:
                        InitializeReferenceTransform(t);
                        break;
                    case OperationTypes.LocalCurveTransform:
                        InitializeLocalCurveTransform(t);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }   
            }
           
            base.Initialize();
        }

        private void InitializeLocalValueTransform(LerpTarget lerpTarget)
        {
            Vector3 startRotEuler = lerpTarget.TargetTransform.localRotation.eulerAngles;
            Vector3 startPos = lerpTarget.TargetTransform.localPosition;
                    
            lerpTarget.LerpStartValues = new TransformValuesCache(position: startPos, 
                rotationEuler: startRotEuler, 
                clockwise: lerpTarget.RotateClockwise);
                    
            lerpTarget.LerpEndValues 
                = new TransformValuesCache(position: startPos.Modify(lerpTarget.ValueAxis, lerpTarget.EndAxisLocalValue),
                rotationEuler: startRotEuler.Modify(lerpTarget.ValueAxis, lerpTarget.EndAxisLocalValue));
        }

        private void InitializeReferenceTransform(LerpTarget lerpTarget)
        {
            Vector3 startPos = lerpTarget.TargetTransform.position;
            Quaternion startRot = lerpTarget.TargetTransform.rotation;
                    
            Vector3 endPos = lerpTarget.EndReferenceTransform.position;
            Quaternion endRot = lerpTarget.EndReferenceTransform.rotation;
            
            lerpTarget.LerpStartValues = new TransformValuesCache(position: startPos, 
                rotation: startRot);
            
            lerpTarget.LerpEndValues = new TransformValuesCache(position: endPos, 
                rotation: endRot);
        }

        private void InitializeLocalCurveTransform(LerpTarget lerpTarget)
        {
            Vector3 startPos = lerpTarget.TargetTransform.position;
            Vector3 startEulerRot = lerpTarget.TargetTransform.localRotation.eulerAngles;
            Quaternion startRot = lerpTarget.TargetTransform.rotation;
            
            lerpTarget.LerpStartValues = new TransformValuesCache(position: startPos, 
                rotation: startRot, rotationEuler: startEulerRot);
        }

        public override void UpdateProgress(float progress)
        {
            base.UpdateProgress(progress);
            foreach (LerpTarget t in lerpTargets)
            {
                switch (t.OperationType)
                {
                    case OperationTypes.LocalValueTransform:
                        UpdateLocalValueTransform(t, Progress);
                        break;
                    case OperationTypes.ReferenceTransform:
                        UpdateReferenceTransform(t, Progress);
                        break;
                    case OperationTypes.LocalCurveTransform:
                        UpdateLocalCurveTransform(t, Progress);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
        }

        private void UpdateLocalValueTransform(LerpTarget lerpTarget, float progress)
        {
            switch (lerpTarget.TargetComponent)
            {
                case TransformComponents.Position:
                    if (lerpTarget.LerpStartValues?.Position == null || lerpTarget.LerpEndValues?.Position == null)
                    {
                        Debug.LogError("Lerp start or end caches have unassigned values");
                        return;
                    }
                    lerpTarget.TargetTransform.localPosition = Vector3.Lerp(lerpTarget.LerpStartValues.Position.Value,
                        lerpTarget.LerpEndValues.Position.Value,
                            progress);
                    break;
                case TransformComponents.Rotation:
                    if (lerpTarget.LerpStartValues?.RotationEuler == null || lerpTarget.LerpEndValues?.RotationEuler == null)
                    {
                        Debug.LogError("Lerp start or end caches have unassigned values");
                        return;
                    }
                    
                    Vector3 startRotation = lerpTarget.LerpStartValues.RotationEuler.Value;
                    Vector3 endRotation = lerpTarget.LerpEndValues.RotationEuler.Value;
                    bool rotateClockwise = lerpTarget.LerpStartValues.RotateClockwise ?? true; // Default to clockwise if not specified
                    
                    // Calculate the difference in angles
                    Vector3 angleDifference = endRotation - startRotation;

                    // Normalize the angle difference to the range of [-180, 180]
                    angleDifference.x = normalizeAngle(angleDifference.x);
                    angleDifference.y = normalizeAngle(angleDifference.y);
                    angleDifference.z = normalizeAngle(angleDifference.z);
                    
                    if (rotateClockwise)
                    {
                        if (angleDifference.x < 0) angleDifference.x += 360;
                        if (angleDifference.y < 0) angleDifference.y += 360;
                        if (angleDifference.z < 0) angleDifference.z += 360;
                    }
                    else
                    {
                        if (angleDifference.x > 0) angleDifference.x -= 360;
                        if (angleDifference.y > 0) angleDifference.y -= 360;
                        if (angleDifference.z > 0) angleDifference.z -= 360;
                    }

                    // Interpolating the rotation
                    Vector3 currentRotation = Vector3.Lerp(startRotation, startRotation + angleDifference, progress);

                    // Applying the rotation
                    lerpTarget.TargetTransform.localRotation = Quaternion.Euler(currentRotation);
                    
                    float normalizeAngle(float angle)
                    {
                        angle %= 360;
                        if (angle > 180)
                            angle -= 360;
                        if (angle < -180)
                            angle += 360;
                        return angle;
                    }
                    
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        private void UpdateReferenceTransform(LerpTarget lerpTarget, float progress)
        {
            switch (lerpTarget.TargetComponent)
            {
                case TransformComponents.Position:
                    if (lerpTarget.LerpStartValues?.Position == null || lerpTarget.LerpEndValues?.Position == null)
                    {
                        Debug.LogError("Lerp start or end caches have unassigned values");
                        return;
                    }
                    lerpTarget.TargetTransform.position = Vector3.Lerp(lerpTarget.LerpStartValues.Position.Value,
                        lerpTarget.LerpEndValues.Position.Value,
                        progress);
                    break;
                case TransformComponents.Rotation:
                    if (lerpTarget.LerpStartValues?.Rotation == null || lerpTarget.LerpEndValues?.Rotation == null)
                    {
                        Debug.LogError("Lerp start or end caches have unassigned values");
                        return;
                    }
                    lerpTarget.TargetTransform.rotation = Quaternion.Slerp(lerpTarget.LerpStartValues.Rotation.Value,
                        lerpTarget.LerpEndValues.Rotation.Value,
                        progress);
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
        
        private void UpdateLocalCurveTransform(LerpTarget lerpTarget, float progress)
        {
            Transform target = lerpTarget.TargetTransform;
            float value = lerpTarget.Curve.Evaluate(progress) * lerpTarget.CurveEffectMultiplier;

            switch (lerpTarget.TargetComponent)
            {
                case TransformComponents.Position:
                    if (lerpTarget.LerpStartValues?.Position == null)
                    {
                        Debug.LogError("Lerp start cache have unassigned values");
                        return;
                    }

                    target.localPosition = target.localPosition.Modify(lerpTarget.CurveEffectAxis, value);
                    break;
                case TransformComponents.Rotation:
                    if (lerpTarget.LerpStartValues?.RotationEuler == null)
                    {
                        Debug.LogError("Lerp start cache have unassigned values");
                        return;
                    }
                    target.localRotation 
                        = Quaternion.Euler(target.localRotation.eulerAngles.Modify(lerpTarget.CurveEffectAxis, value));
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
    }
}*/
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/TransformKinematicGrabbable.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/TransformValuesCache.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 28e4517c92c3483d99c0a9b26f0317b4
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Features.Interaction
{
    /// <summary>
    /// A value cache of a transform
    /// </summary>
    public class TransformValuesCache
    {
        public Vector3? Position { get; }
        public Quaternion? Rotation { get; }
        public Vector3? RotationEuler { get; }
        public Vector3? Scale { get; }
        public bool? RotateClockwise { get; }

        public TransformValuesCache(Vector3? position = null,
            Quaternion? rotation = null,
            Vector3? rotationEuler = null,
            Vector3? scale = null,
            bool? clockwise = null)
        {
            Position = position;
            Rotation = rotation;
            RotationEuler = rotationEuler;
            Scale = scale;
            RotateClockwise = clockwise;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Interaction/TransformValuesCache.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/LdxBlendShapeCollision.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6def5b54e1c53384d8e8549f44208cf8
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections;
using UnityEngine;
using UnityEngine.Serialization;

namespace Ldx.Framework.Features
{
    public class LdxBlendShapeCollision : MonoBehaviour
    {
        [SerializeField] private Transform endTransform;
        [SerializeField] private Vector2 distanceRange = new Vector2(1, 10);
        [FormerlySerializedAs("renderer")]
        [SerializeField] private SkinnedMeshRenderer meshRenderer;
        [SerializeField] private int blendShapeIndex = 0;
        [SerializeField] private LayerMask collisionLayerMask;
        [SerializeField] private float lerpBackSpeed = 1.5f;
        [SerializeField] private Collider colliderToToggle;
        [SerializeField] private string ignoreTag = "IgnoreBlendshape";

        private Collider otherCollider = null;
        private bool isGrabbed = false;

        private void OnTriggerEnter(Collider col)
        {
            if (!isGrabbed || col.CompareTag(ignoreTag) || collisionLayerMask != (collisionLayerMask | (1 << col.gameObject.layer))) return;

            otherCollider = col;
        }

        private void OnTriggerStay(Collider col)
        {
            if (otherCollider != col || !isGrabbed) return;

            Vector3 point = col.ClosestPoint(endTransform.position);
            float dist = Vector3.Distance(point, endTransform.position) - distanceRange.x;

            if (dist > distanceRange.y) return;

            float scale = (1 - (dist / distanceRange.y)) * 100;
            meshRenderer.SetBlendShapeWeight(blendShapeIndex, scale);

            //Debug.Log($"Scale: {scale}, {dist / distanceRange.y}, dist: {dist}, Range: {distanceRange}");
        }

        private void OnTriggerExit(Collider col)
        {
            if (otherCollider != col) return;

            meshRenderer.SetBlendShapeWeight(blendShapeIndex, 0);
            otherCollider = null;
        }

        [ContextMenu("Set is Grabbed")]
        public void SetIsGrabbed(bool grabbed = true)
        {
            isGrabbed = grabbed;
            colliderToToggle.enabled = !grabbed;

            if (!grabbed)
                StartCoroutine(LerpShapeWeight(blendShapeIndex, 0, meshRenderer.GetBlendShapeWeight(blendShapeIndex), lerpBackSpeed));
        }

        private IEnumerator LerpShapeWeight(int index, float endValue, float startValue, float speed)
        {
            float deltaTime = 0;
            while (deltaTime < 1)
            {
                yield return new WaitForEndOfFrame();
                deltaTime += Time.deltaTime * speed;
                meshRenderer.SetBlendShapeWeight(blendShapeIndex, Mathf.Lerp(startValue, endValue, deltaTime));
            }

            meshRenderer.SetBlendShapeWeight(blendShapeIndex, endValue);
        }
    }

}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/LdxBlendShapeCollision.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Linerenderers/WireSimulator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 69ab3657f532e71418d47e82180032f6
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;
using UnityEngine.Serialization;

namespace Ldx.Framework.Features.LineRenderers
{
	public enum AdjustmentAngle
	{
		FlatDirection,
		Vertical,
		Left,
		Right,
		None
	}

	[ExecuteInEditMode]
	[RequireComponent(typeof(LineRenderer))]
	public class WireSimulator : MonoBehaviour
	{
		private const float ANGLE_ADJUSTMENT_LENGTH = 0.1f;
		private const float UPDATE_EVERY_FRAMES = 2;


		[Header("References")] 
		[FormerlySerializedAs("baseGameObject")] 
		[SerializeField] private GameObject startObject;
		public GameObject StartObject
		{
			get => startObject;
			set => startObject = value;
		}

		[FormerlySerializedAs("targetGameObject")] 
		[SerializeField] private GameObject endObject;
		public GameObject EndObject
		{
			get => endObject;
			set => endObject = value;
		}

		[SerializeField] private Material lineMaterial;
		public Material LineMaterial
		{
			get => LineRenderer.material;
			set
			{
				lineMaterial = value;
				LineRenderer.material = lineMaterial;
			}
		}

		[Header("Setup")] 
		[SerializeField] private bool isStatic;
		public bool IsStatic
		{
			get => isStatic;
			set => isStatic = value;
		}

		[SerializeField] private float maxSag = 1.0f;
		public float MaxSag
		{
			get => maxSag;
			set => maxSag = value;
		}

		[SerializeField] private int minSegments = 5;
		public int MinSegments
		{
			get => minSegments;
			set => minSegments = value;
		}

		[SerializeField] private int maxSegments = 20;
		public int MaxSegments
		{
			get => maxSegments;
			set => maxSegments = value;
		}

		[SerializeField] private float segmentLength = 0.5f;
		public float SegmentLength
		{
			get => segmentLength;
			set => segmentLength = value;
		}

		[SerializeField] private AdjustmentAngle startingAngle = AdjustmentAngle.None;
		public AdjustmentAngle StartingAngle
		{
			get => startingAngle;
			set => startingAngle = value;
		}

		[SerializeField] private AdjustmentAngle endingAngle = AdjustmentAngle.None;
		public AdjustmentAngle EndingAngle
		{
			get => endingAngle;
			set => endingAngle = value;
		}

		[Space] 
		[SerializeField] private float startWidth = 0.03f;
		public float StartWidth
		{
			get => startWidth;
			set
			{
				startWidth = value;
				LineRenderer.startWidth = startWidth;
			}
		}

		[SerializeField] 
		private float endWidth = 0.03f;
		public float EndWidth
		{
			get => endWidth;
			set
			{
				endWidth = value;
				LineRenderer.endWidth = endWidth;
			}
		}

		private LineRenderer lineRenderer;

		public LineRenderer LineRenderer
		{
			get
			{
				if (lineRenderer == null)
				{
					lineRenderer = GetComponent<LineRenderer>();
				}

				return lineRenderer;
			}
		}

		private void Start()
		{
			SetupLine();
		}

		private void Update()
		{
			if (isStatic)
				return;

			UpdateLineRenderer();
		}

		private void SetupLine()
		{
			LineRenderer.material = lineMaterial;
			LineRenderer.startWidth = startWidth;
			LineRenderer.endWidth = endWidth;
		}

		private void UpdateLineRenderer()
		{
			if (Time.frameCount % UPDATE_EVERY_FRAMES != 0)
				return;

			float distance = Vector3.Distance(startObject.transform.position, endObject.transform.position);
			int segmentCount = Mathf.Clamp(Mathf.CeilToInt(distance / segmentLength), minSegments, maxSegments);

			int totalSegments = segmentCount + 1;

			if (startingAngle != AdjustmentAngle.None) totalSegments++;
			if (endingAngle != AdjustmentAngle.None) totalSegments++;

			LineRenderer.positionCount = totalSegments;

			int currentIndex = 0;
			Vector3 direction = (startObject.transform.position - endObject.transform.position).normalized;

			if (startingAngle != AdjustmentAngle.None)
			{
				Vector3 startPosition =
					GetAdjustedPosition(startObject.transform.position, direction, startingAngle);
				LineRenderer.SetPosition(currentIndex++, startPosition);
			}

			for (int i = 0; i <= segmentCount; i++)
			{
				float lerpValue = (float)i / segmentCount;
				Vector3 position = Vector3.Lerp(startObject.transform.position, endObject.transform.position,
					lerpValue);

				// Calculate sag
				float sagAmount = maxSag * Mathf.Sin(Mathf.PI * lerpValue);
				position += sagAmount * Vector3.down;

				LineRenderer.SetPosition(currentIndex++, position);
			}

			if (endingAngle != AdjustmentAngle.None)
			{
				Vector3 endPosition =
					GetAdjustedPosition(endObject.transform.position, -direction, endingAngle);
				LineRenderer.SetPosition(currentIndex, endPosition);
			}
		}

		private Vector3 GetAdjustedPosition(Vector3 basePosition, Vector3 direction, AdjustmentAngle adjustment)
		{
			switch (adjustment)
			{
				case AdjustmentAngle.FlatDirection:
					return basePosition + direction.Modify(y: 0) * ANGLE_ADJUSTMENT_LENGTH;
				case AdjustmentAngle.Vertical:
					return basePosition + Vector3.up * ANGLE_ADJUSTMENT_LENGTH;
				case AdjustmentAngle.Left:
					return basePosition + Vector3.left * ANGLE_ADJUSTMENT_LENGTH;
				case AdjustmentAngle.Right:
					return basePosition + Vector3.right * ANGLE_ADJUSTMENT_LENGTH;
				default:
					return basePosition;
			}
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Linerenderers/WireSimulator.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/AutomatedMachineryInputModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6b4562108ac0fb640997e92657749245
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;

namespace Ldx.Framework.Features.Machinery
{
    [CreateAssetMenu(menuName = "Idealogical/Machinery Input Module/Automated", fileName = "AutomatedMachineryInputModule")]
    public class AutomatedMachineryInputModule : MachineryInputModuleBase
    {
        [SerializeField]
        private SerializableDictionary<OperationType, OperationInputDirection> desired = new();
        public SerializableDictionary<OperationType, OperationInputDirection> Desired => desired;

        public override void Initialize()
        {
            base.Initialize();
            // Initialize all existing keys in the dictionary to None
            foreach (OperationType key in desired.Keys.ToList())
            {
                desired[key] = OperationInputDirection.None;
            }
        }

        public void Set(OperationType op, OperationInputDirection dir)
        {
            if (desired.ContainsKey(op))
            {
                desired[op] = dir;
            }
        }

        public void SetAllNone()
        {
            foreach (OperationType key in desired.Keys.ToList())
            {
                desired[key] = OperationInputDirection.None;
            }
        }

        public override void ProcessMachineryInputs(ref Dictionary<OperationType, OperationInputDirection> state)
        {
            foreach (KeyValuePair<OperationType, OperationInputDirection> kvp in desired)
            {
                state[kvp.Key] = kvp.Value;
            }
        }

        public override void ForceStopInputs(ref Dictionary<OperationType, OperationInputDirection> state)
        {
            SetAllNone();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/AutomatedMachineryInputModule.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/BaseMachineryController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0fa86f521ae1491ba2e17a1ccc2c5d9b
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using DG.Tweening;
using Ldx.Framework.Systems.Teleportation;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Features.Machinery
{
    /// <summary>
    /// Represents a direction for machine operation input.
    /// </summary>
    public enum OperationInputDirection
    {
        Positive, // e.g., Turn Right, Boom Up, Boom Extend, Hoist Up
        Negative, // e.g., Turn Left, Boom Down, Boom Retract, Hoist Down
        None
    }
    
    /// <summary>
    /// Base controller that manages machine modules and applies directional input to them.
    /// </summary>
    public abstract class BaseMachineryController : MonoBehaviour
    {
        [SerializeField]
        private MachineryInputModuleBase inputModule;
        public MachineryInputModuleBase InputModule => inputModule;

        [Space]
        [Header("Machinery Operation Modules")]
        [SerializeField] private List<MachineModuleContainer> moduleContainers = new();
        
        [Header("Movement Tuning (Shared)")]
        [SerializeField] private AnimationCurve accelerationCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);
        [SerializeField] private float accelerationTime = 0.5f;
        public float AccelerationTime => accelerationTime;
        [SerializeField] private float decelerationTime = 0.5f;
        public float DecelerationTime => decelerationTime;
        
        [SerializeField] private bool stopGesturesOnTeleportation = true;
        
        [Header("Audio")]
        [SerializeField] private AudioSource engineAudioSource;
        [SerializeField] private AudioClip engineLoopClip;
        [SerializeField] private float audioFadeDuration = 0.5f;
        
        private bool isEngineAudioPlaying = false;
        protected Dictionary<OperationType, OperationInputDirection> currentInputState = new();
        protected readonly List<MachineModuleBase> allModules = new();

        protected virtual void OnValidate()
        {
            foreach (MachineModuleContainer container in moduleContainers)
            {
                container.action?.OnValidateModule();
            }
            
            if (engineAudioSource == null)
            {
                engineAudioSource = gameObject.GetOrAddComponent<AudioSource>();
            }
        }

        protected virtual void Awake()
        {
            foreach (MachineModuleContainer container in moduleContainers)
            {
                if (container.action == null)
                {
                    continue;
                }
                
                container.action.Initialize(this, accelerationCurve);
                allModules.Add(container.action);
            }

            SetInputModule(inputModule);

            if (engineLoopClip != null)
            {
                engineAudioSource.clip = engineLoopClip;
                engineAudioSource.loop = true;
            }
        }

        protected void SetInputModule(MachineryInputModuleBase newInputModule)
        {
            inputModule = newInputModule;
            inputModule?.Initialize();
        }

        private void Start()
        {
            if (stopGesturesOnTeleportation)
            {
                PlayerTeleporter.OnTeleportActivateDeactive += HandleTeleportActivateDeactivate;
            }

            StartEngineSound();
        }

        protected virtual void OnDisable()
        {
            StopEngineSound();
        }

        protected virtual void OnDestroy()
        {
            foreach (MachineModuleBase module in allModules)
            {
                module.OnDestroy();
            }

            inputModule?.OnDestroy();
            PlayerTeleporter.OnTeleportActivateDeactive -= HandleTeleportActivateDeactivate;
            
            if (engineAudioSource != null)
            {
                engineAudioSource.Stop();
            }
        }

        protected virtual void Update()
        {
            UpdateInputModule();
            SetInputForModules();
        }

        /// <summary>
        /// Retrieves current input from the input module.
        /// </summary>
        protected virtual void UpdateInputModule()
        {
            inputModule?.ProcessMachineryInputs(ref currentInputState);
        }

        /// <summary>
        /// Sends the input state to all active machine modules.
        /// </summary>
        protected virtual void SetInputForModules()
        {
            foreach (MachineModuleBase module in allModules)
            {
                if (module.Enabled)
                {
                    module.SetInput(currentInputState[module.GetOperationType()]);
                }
            }
        }
        
        private void HandleTeleportActivateDeactivate(PlayerTeleporter teleporter, bool teleportationActive)
        {
            if (teleportationActive)
            {
                inputModule?.ForceStopInputs(ref currentInputState);
                foreach (MachineModuleBase module in allModules)
                {
                    module.ForceStop();
                }
            }
        }

        public void StartEngineSound()
        {
            float desiredVolume = engineAudioSource.volume;
            engineAudioSource.volume = 0;
            engineAudioSource.Play();
            engineAudioSource.DOFade(desiredVolume, audioFadeDuration);
        }
        
        public void StopEngineSound()
        {
            if (engineAudioSource == null)
            {
                return;
            }
            
            engineAudioSource.DOFade(0, audioFadeDuration).OnComplete(() =>
            {
                if (engineAudioSource != null)
                {
                    engineAudioSource.Stop();
                }
            });
        }

#if UNITY_EDITOR
        protected virtual void OnDrawGizmosSelected()
        {
            foreach (MachineModuleContainer container in moduleContainers)
            {
                container.action?.OnDrawGizmosSelected();
            }
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/BaseMachineryController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/BaseRotationModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c141cc5fbb674655b656e5f242846061
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Ldx.Framework.Features.Machinery
{
    /// <summary>
    /// A machine module that rotates a base transform around a specified local axis.
    /// This module is used for operations like turret turning or arm pivoting.
    /// It uses `localEulerAngles` and clamps the rotation within defined limits.
    /// </summary>
    [Serializable]
    public class BaseRotationModule : MachineModuleBase
    {
        [SerializeField] private Transform baseTransform;
        [SerializeField] private Axis rotationAxis = Axis.Y;

        public override OperationType GetOperationType() => OperationType.Turn;

        protected override void ApplyInternalValueToTransform(float angle)
        {
            if (baseTransform)
            {
                baseTransform.localEulerAngles = baseTransform.localEulerAngles.Modify(rotationAxis, angle);
            }
        }

        protected override float GetInitialValue()
        {
            CurrentValue = baseTransform ? baseTransform.localEulerAngles.GetAxis(rotationAxis) : 0f;
            return GetValueWithinLimits(CurrentValue);
        }
        
        protected override void SetCurrentInternalValue(float value)
        {
            CurrentValue = value;
        }

#if UNITY_EDITOR

        public override void OnDrawGizmosSelected()
        {
            if (baseTransform == null) return;
            
            Vector3 localRotationAxisVector = GetLocalExtendDirectionVector(rotationAxis);
            Vector3 arcReferenceStartDirection = Vector3.zero;
            switch (rotationAxis)
            {
                case Axis.X: arcReferenceStartDirection = Vector3.forward; break;
                case Axis.Y: arcReferenceStartDirection = Vector3.up; break;
                case Axis.Z: arcReferenceStartDirection = Vector3.forward; break;
            }
            
            Vector3 worldRotationAxisVector = baseTransform.TransformDirection(localRotationAxisVector);
            
            Handles.color = Color.cyan.Modify(a: 0.4f);
            float gizmoRadius = 2f; 
            Matrix4x4 originalHandlesMatrix = Handles.matrix;
            Handles.matrix = Matrix4x4.TRS(baseTransform.position, Quaternion.LookRotation(worldRotationAxisVector), Vector3.one);
            
            Handles.DrawSolidArc(
                Vector3.zero,
                Vector3.forward,
                Quaternion.AngleAxis(limits.x, Vector3.forward) * arcReferenceStartDirection, 
                limits.y - limits.x,
                gizmoRadius
            );

            Handles.matrix = originalHandlesMatrix;
            Gizmos.matrix = Matrix4x4.identity;

            Gizmos.color = Color.blue;
         
            Vector3 localReferenceForLines = baseTransform.forward; 
            if (Vector3.Dot(localReferenceForLines, localRotationAxisVector) > 0.99f) 
            {
                localReferenceForLines = rotationAxis is Axis.Y or Axis.Z ? Vector3.right : Vector3.forward;
            }
            Vector3 minDirWorld = baseTransform.TransformDirection(Quaternion.AngleAxis(limits.x, localRotationAxisVector) * localReferenceForLines.normalized);
            Gizmos.DrawLine(baseTransform.position, baseTransform.position + minDirWorld * (gizmoRadius + 0.5f));
            Gizmos.DrawSphere(baseTransform.position + minDirWorld * (gizmoRadius + 0.5f), 0.05f * gizmoRadius);
            
            Gizmos.color = Color.red;
            Vector3 maxDirWorld = baseTransform.TransformDirection(Quaternion.AngleAxis(limits.y, localRotationAxisVector) * localReferenceForLines.normalized);
            Gizmos.DrawLine(baseTransform.position, baseTransform.position + maxDirWorld * (gizmoRadius + 0.5f));
            Gizmos.DrawSphere(baseTransform.position + maxDirWorld * (gizmoRadius + 0.5f), 0.05f * gizmoRadius);
            
            Gizmos.color = Color.green;
            Vector3 currentDirWorld = baseTransform.TransformDirection(Quaternion.AngleAxis(CurrentValue, localRotationAxisVector) * localReferenceForLines.normalized);
            Gizmos.DrawLine(baseTransform.position, baseTransform.position + currentDirWorld * (gizmoRadius + 0.2f));
            Gizmos.DrawSphere(baseTransform.position + currentDirWorld * (gizmoRadius + 0.2f), 0.04f * gizmoRadius);
        }
        
        public override List<Transform> EDITOR_GetTransformsToRecordForUndo()
        {
            if (baseTransform != null)
            {
                return new List<Transform> { baseTransform };
            }
            
            return base.EDITOR_GetTransformsToRecordForUndo();
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/BaseRotationModule.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/BoomExtendModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 212e6d18e0014a91bc5672fac4b9b7f1
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Features.Machinery
{
    /// <summary>
    /// A machinery module responsible for handling telescopic boom extension.
    /// Supports multiple sequentially extending sections (inner to outer), each with configurable min/max extension.
    /// Tracks and updates the active section based on extension limits, user input, and direction of movement.
    /// </summary>
    [Serializable]
    public class BoomExtendModule : MachineModuleBase
    {
        /// <summary>
        /// Represents a single telescopic section of the boom, with its own transform and extension constraints.
        /// </summary>
        [Serializable]
        public class TelescopicSection
        {
            public Transform sectionTransform;
            [Tooltip("Minimum and Maximum extension for THIS section, relative to its own starting position (usually 0 for min).")]
            public Vector2 minMaxIndividualExtension = new Vector2(0, 2f); // Default: can extend 2 units from 0
            [HideInInspector] public float currentIndividualExtension;
        }
        
        [Tooltip("Define boom sections from innermost (closest to pivot) to outermost (boom tip).")]
        [SerializeField] private List<TelescopicSection> telescopicSections = new List<TelescopicSection>();
        [SerializeField] private Axis extendAxis = Axis.Z; // Assuming extension is always along local Z for now

        private int currentSectionIndex = -1; // -1 means not initialized or no sections
        private TelescopicSection ActiveSection => (currentSectionIndex >= 0 && currentSectionIndex < telescopicSections.Count) ? telescopicSections[currentSectionIndex] : null;

        public float TotalMaxExtension
        {
            get
            {
                if (telescopicSections == null) return 0f;
                float total = 0;
                foreach (TelescopicSection section in telescopicSections)
                {
                    total += section.minMaxIndividualExtension.y - section.minMaxIndividualExtension.x;
                }
                return total;
            }
        }
        
        public override OperationType GetOperationType() => OperationType.Extend;
        
        protected override float GetInitialValue()
        {
            if (telescopicSections == null || telescopicSections.Count == 0)
            {
                currentSectionIndex = -1;
                UpdateBaseLimitsForActiveSection();
                return 0f;
            }

            float currentTotalExtension = 0;
            foreach (TelescopicSection section in telescopicSections)
            {
                if (section.sectionTransform != null)
                {
                    float rawValue = section.sectionTransform.localPosition.GetAxis(extendAxis);
                    section.currentIndividualExtension = Mathf.Clamp(rawValue, section.minMaxIndividualExtension.x, section.minMaxIndividualExtension.y);
                    currentTotalExtension += section.currentIndividualExtension - section.minMaxIndividualExtension.x;
                }
                else
                {
                    section.currentIndividualExtension = section.minMaxIndividualExtension.x;
                }
            }

            // In EDITOR mode, CurrentValue is the normalized total extension (0-1)
            if (!Application.isPlaying)
            {
                float totalMax = TotalMaxExtension;
                CurrentValue = (totalMax > 0.001f) ? (currentTotalExtension / totalMax) : 0f;
                return CurrentValue;
            }
            
            // In PLAY mode, it's the value of the active section
            currentSectionIndex = 0;
            UpdateBaseLimitsForActiveSection();
            return ActiveSection?.currentIndividualExtension ?? 0f;
        }

        protected override void SetCurrentInternalValue(float valueForActiveSection)
        {
            if (ActiveSection != null)
            {
                // 'limits' in the base class are already set for the active section by UpdateBaseLimitsForActiveSection
                ActiveSection.currentIndividualExtension = Mathf.Clamp(valueForActiveSection, limits.x, limits.y);
                CurrentValue = ActiveSection.currentIndividualExtension; 
                ApplyInternalValueToTransform(CurrentValue);
            }
            else
            {
                CurrentValue = 0;
            }
        }
    
        protected override void ApplyInternalValueToTransform(float activeSectionTargetExtension)
        {
            if (ActiveSection?.sectionTransform != null)
            {
                ActiveSection.currentIndividualExtension = activeSectionTargetExtension;
                ActiveSection.sectionTransform.localPosition = ActiveSection.sectionTransform.localPosition.Modify(extendAxis, ActiveSection.currentIndividualExtension);
            }
        }
        
        public override void SetInput(OperationInputDirection direction)
        {
            if (telescopicSections == null || telescopicSections.Count == 0)
            {
                base.SetInput(OperationInputDirection.None);
                return;
            }

            base.SetInput(direction);
        }

        /// <summary>
        /// Updates internal clamp limits and value reference for the current active section.
        /// </summary>
        private void UpdateBaseLimitsForActiveSection()
        {
            if (ActiveSection != null)
            {
                limits = ActiveSection.minMaxIndividualExtension;
                SetBaseCurrentValue(ActiveSection.currentIndividualExtension);
            }
            else
            {
                limits = Vector2.zero;
                SetBaseCurrentValue(0);
            }
        }

        protected void SetBaseCurrentValue(float value)
        {
            CurrentValue = value;
        }

        /// <summary>
        /// Attempts to switch sections when a limit is reached.
        /// </summary>
        protected override bool ProcessLimitReached(OperationInputDirection attemptedMoveDirection)
        {
            if (ActiveSection == null)
            {
                return false;
            }

            if (attemptedMoveDirection == OperationInputDirection.Positive)
            {
                if (currentSectionIndex < telescopicSections.Count - 1)
                {
                    currentSectionIndex++;
                    TelescopicSection newActiveSection = ActiveSection;
                    UpdateBaseLimitsAndValueForNewActiveState(newActiveSection.minMaxIndividualExtension, newActiveSection.currentIndividualExtension);
                    return true;
                }
            }
            else if (attemptedMoveDirection == OperationInputDirection.Negative)
            {
                if (currentSectionIndex > 0)
                {
                    currentSectionIndex--;
                    TelescopicSection newActiveSection = ActiveSection;
                    UpdateBaseLimitsAndValueForNewActiveState(newActiveSection.minMaxIndividualExtension, newActiveSection.currentIndividualExtension);
                    return true;
                }
            }
            return false; // Limit not handled in a way that allows continuation (e.g., at overall boom limit)
        }
        
        protected void UpdateBaseLimitsAndValueForNewActiveState(Vector2 newLimits, float newCurrentValueWithinNewLimits)
        {
            limits = newLimits; // Update the 'limits' used by ApplyMovementDelta and MovementIterationAsync
            CurrentValue = Mathf.Clamp(newCurrentValueWithinNewLimits, limits.x, limits.y);
        }
        
#if UNITY_EDITOR
        public override void OnDrawGizmosSelected()
        {
            base.OnDrawGizmosSelected();

            if (telescopicSections == null || telescopicSections.Count == 0)
            {
                return;
            }
          
            Vector3 localExtendDirection = GetLocalExtendDirectionVector(extendAxis);
            
            for (int i = 0; i < telescopicSections.Count; i++)
            {
                TelescopicSection section = telescopicSections[i];
                if (section?.sectionTransform == null) continue;

                // Determine the world-space base position for *this* section's extension range
                Vector3 sectionRangeBaseWorldPos;
                Transform parentOfCurrentSection = section.sectionTransform.parent;

                if (i == 0)
                {
                    // The first section extends from its parent's origin (or this module's GO if no parent)
                    sectionRangeBaseWorldPos = parentOfCurrentSection != null ? parentOfCurrentSection.position : section.sectionTransform.position;
                }
                else
                {
                    // Subsequent sections extend from the *tip* of the previous section's *max possible extension*.
                    // This is for visualizing the full potential range.
                    // For current position, we'd use previousSection.currentIndividualExtension.
                    TelescopicSection previousSection = telescopicSections[i-1];
                    if (previousSection?.sectionTransform != null)
                    {
                        Vector3 previousSectionLocalTipAtMax = previousSection.sectionTransform.localPosition.Modify(extendAxis, previousSection.minMaxIndividualExtension.y);
                        sectionRangeBaseWorldPos = previousSection.sectionTransform.parent.TransformPoint(previousSectionLocalTipAtMax);
                    } 
                    else 
                    {
                        // Fallback if previous section is misconfigured
                        sectionRangeBaseWorldPos = parentOfCurrentSection != null ? parentOfCurrentSection.position : section.sectionTransform.position;
                    }
                }
                
                // World direction of extension for this section (based on its parent's orientation)
                Vector3 worldExtendDir = parentOfCurrentSection != null ? 
                    parentOfCurrentSection.TransformDirection(localExtendDirection) :
                    section.sectionTransform.TransformDirection(localExtendDirection);
                
                Vector3 minRangePointWorld = sectionRangeBaseWorldPos + worldExtendDir * section.minMaxIndividualExtension.x;
                Vector3 maxRangePointWorld = sectionRangeBaseWorldPos + worldExtendDir * section.minMaxIndividualExtension.y;

                Gizmos.color = (i == currentSectionIndex) ? Color.yellow : Color.gray;
                Gizmos.DrawLine(minRangePointWorld, maxRangePointWorld);
                Gizmos.DrawSphere(minRangePointWorld, 0.05f);
                Gizmos.DrawSphere(maxRangePointWorld, 0.05f);

                // Draw current actual extension for this specific section
                // The base for the *actual* current extension is the tip of the *actual* previous section's extension
                Vector3 actualSectionBaseWorldPos;
                if (i == 0)
                {
                    actualSectionBaseWorldPos = parentOfCurrentSection != null ? parentOfCurrentSection.position : section.sectionTransform.position;
                } 
                else 
                {
                    TelescopicSection previousSection = telescopicSections[i-1];
                    if (previousSection?.sectionTransform != null) 
                    {
                        Vector3 previousSectionLocalTipCurrent = previousSection.sectionTransform.localPosition.Modify(extendAxis, previousSection.currentIndividualExtension);
                        actualSectionBaseWorldPos = previousSection.sectionTransform.parent.TransformPoint(previousSectionLocalTipCurrent);
                    } 
                    else 
                    {
                        actualSectionBaseWorldPos = parentOfCurrentSection != null ? parentOfCurrentSection.position : section.sectionTransform.position;
                    }
                }

                Gizmos.color = Color.white;
                Vector3 currentSectionTipWorld = actualSectionBaseWorldPos + worldExtendDir * section.currentIndividualExtension;
                Gizmos.DrawLine(actualSectionBaseWorldPos, currentSectionTipWorld); // Line from actual base to actual tip
                Gizmos.DrawSphere(currentSectionTipWorld, 0.03f);
            }
        }

        public override void EDITOR_SetValueFromEditor(float normalizedValue)
        {
            normalizedValue = Mathf.Clamp01(normalizedValue);
            CurrentValue = normalizedValue;
            
            float totalMax = TotalMaxExtension;
            if (totalMax <= 0 || telescopicSections == null) return;

            float desiredTotalExtension = normalizedValue * totalMax;
            float remainingExtension = desiredTotalExtension;

            foreach (TelescopicSection section in telescopicSections)
            {
                float sectionRange = section.minMaxIndividualExtension.y - section.minMaxIndividualExtension.x;
                float extensionForThisSection = Mathf.Clamp(remainingExtension, 0, sectionRange);
                float newLocalPosValue = section.minMaxIndividualExtension.x + extensionForThisSection;
                
                section.currentIndividualExtension = newLocalPosValue;
                if (section.sectionTransform != null)
                {
                    section.sectionTransform.localPosition = section.sectionTransform.localPosition.Modify(extendAxis, newLocalPosValue);
                }

                remainingExtension -= extensionForThisSection;
            }
        }

        public override List<Transform> EDITOR_GetTransformsToRecordForUndo()
        {
            List<Transform> transforms = new List<Transform>();
            if (telescopicSections != null)
            {
                foreach (TelescopicSection section in telescopicSections)
                {
                    if (section?.sectionTransform != null)
                    {
                        transforms.Add(section.sectionTransform);
                    }
                }
            }
            return transforms;
        }
#endif

    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/BoomExtendModule.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/BoomRaiseModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6feef7e0c0e94cb1a82c0b21870496b9
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Features.Machinery
{
    /// <summary>
    /// A machinery module responsible for rotating a boom arm up and down around a specified local axis.
    ///
    /// This module is commonly used for boom raising/lowering functionality on cranes, lifts, etc.
    /// It rotates the assigned transform using local Euler angles, applies clamping within limits,
    /// and provides visual gizmos to preview the configured range of motion and current value.
    ///
    /// The axis of rotation can be configured, with Z being the default.
    /// </summary>
    [Serializable]
    public class BoomRaiseModule : MachineModuleBase
    {
        [SerializeField] private Transform boomTransform;
        [SerializeField] private Axis rotationAxis = Axis.Z;

        public override OperationType GetOperationType() => OperationType.Raise;

        protected override void ApplyInternalValueToTransform(float angle)
        {
            if (boomTransform)
            {
                boomTransform.localEulerAngles = boomTransform.localEulerAngles.Modify(rotationAxis, angle);
            }
        }

        protected override float GetInitialValue()
        {
            CurrentValue = boomTransform ? boomTransform.localEulerAngles.GetAxis(rotationAxis) : 0f;
            return Mathf.Clamp(CurrentValue, limits.x, limits.y);
        }
        
        protected override void SetCurrentInternalValue(float value)
        {
            CurrentValue = value;
        }

#if UNITY_EDITOR

      public override void OnDrawGizmosSelected()
        {
            if (boomTransform == null) return;
            
            Vector3 localRotationAxisVector = GetLocalExtendDirectionVector(rotationAxis);
            Vector3 arcReferenceStartDirection = Vector3.zero;
            switch (rotationAxis)
            {
                case Axis.X: arcReferenceStartDirection = Vector3.forward; break;
                case Axis.Y: arcReferenceStartDirection = Vector3.up; break;
                case Axis.Z: arcReferenceStartDirection = Vector3.forward; break;
            }
            
            Vector3 worldRotationAxisVector = boomTransform.TransformDirection(localRotationAxisVector);
            
            Handles.color = Color.cyan.Modify(a: 0.4f);
            float gizmoRadius = 2f; 
            Matrix4x4 originalHandlesMatrix = Handles.matrix;
            Handles.matrix = Matrix4x4.TRS(boomTransform.position, Quaternion.LookRotation(worldRotationAxisVector), Vector3.one);
            
            Handles.DrawSolidArc(
                Vector3.zero,
                Vector3.forward,
                Quaternion.AngleAxis(limits.x, Vector3.forward) * arcReferenceStartDirection, 
                limits.y - limits.x,
                gizmoRadius
            );

            Handles.matrix = originalHandlesMatrix;
            Gizmos.matrix = Matrix4x4.identity;

            Gizmos.color = Color.blue;
         
            Vector3 localReferenceForLines = boomTransform.forward; 
            if (Vector3.Dot(localReferenceForLines, localRotationAxisVector) > 0.99f) 
            {
                localReferenceForLines = rotationAxis is Axis.Y or Axis.Z ? Vector3.right : Vector3.forward;
            }
            Vector3 minDirWorld = boomTransform.TransformDirection(Quaternion.AngleAxis(limits.x, localRotationAxisVector) * localReferenceForLines.normalized);
            Gizmos.DrawLine(boomTransform.position, boomTransform.position + minDirWorld * (gizmoRadius + 0.5f));
            Gizmos.DrawSphere(boomTransform.position + minDirWorld * (gizmoRadius + 0.5f), 0.05f * gizmoRadius);
            
            Gizmos.color = Color.red;
            Vector3 maxDirWorld = boomTransform.TransformDirection(Quaternion.AngleAxis(limits.y, localRotationAxisVector) * localReferenceForLines.normalized);
            Gizmos.DrawLine(boomTransform.position, boomTransform.position + maxDirWorld * (gizmoRadius + 0.5f));
            Gizmos.DrawSphere(boomTransform.position + maxDirWorld * (gizmoRadius + 0.5f), 0.05f * gizmoRadius);
            
            Gizmos.color = Color.green;
            Vector3 currentDirWorld = boomTransform.TransformDirection(Quaternion.AngleAxis(CurrentValue, localRotationAxisVector) * localReferenceForLines.normalized);
            Gizmos.DrawLine(boomTransform.position, boomTransform.position + currentDirWorld * (gizmoRadius + 0.2f));
            Gizmos.DrawSphere(boomTransform.position + currentDirWorld * (gizmoRadius + 0.2f), 0.04f * gizmoRadius);
        }
                 
        public override List<Transform> EDITOR_GetTransformsToRecordForUndo()
        {
            if (boomTransform != null)
            {
                return new List<Transform> { boomTransform };
            }
            return base.EDITOR_GetTransformsToRecordForUndo();
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/BoomRaiseModule.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/CableRopeModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2e2dd57d34ed4fc9ba01106a85610e3f
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Utilities.Tools;
using UnityEngine;

namespace Ldx.Framework.Features.Machinery
{
    public class CableRopeModule : MachineModuleBase
    {
        [SerializeField] private StickToTargetPosition cableEndReference;
        
        public override OperationType GetOperationType() => OperationType.Hoist;

        protected override void ApplyInternalValueToTransform(float value)
        {
            if (cableEndReference == null)
            {
                return;
            }
            
            cableEndReference.SetOffset(new Vector3(0f, -value, 0f));
        }

        protected override float GetInitialValue()
        {
            CurrentValue = cableEndReference ? Mathf.Abs(cableEndReference.Offset.y) : 0f;
            return Mathf.Clamp(CurrentValue, limits.x, limits.y);
        }

        protected override void SetCurrentInternalValue(float value)
        {
            CurrentValue = value;
        }
        
#if UNITY_EDITOR
        public override List<Transform> EDITOR_GetTransformsToRecordForUndo()
        {
            if (cableEndReference != null)
            {
                return new List<Transform> { cableEndReference.transform };
            }
            return base.EDITOR_GetTransformsToRecordForUndo();
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/CableRopeModule.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/KeyboardMachineryInputModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 261dbfe10d1d49f7aa32bea86f69cdb4
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;
using UnityEngine.InputSystem;

namespace Ldx.Framework.Features.Machinery
{
    public interface IMachineryInputModule
    {
        List<(KeyCode key, string label)> GetInputs();
    }
    
    /// <summary>
    /// A machinery input module that maps keyboard inputs to operation directions for testing or editor use.
    /// </summary>
    [CreateAssetMenu(menuName = "Idealogical/Machinery Input Module/Keyboard", fileName = "KeyboardMachineryInputModule")]
    public class KeyboardMachineryInputModule : MachineryInputModuleBase
    {
        /// <summary>
        /// Defines the directional key bindings for a single machinery operation.
        /// </summary>
        [Serializable]
        public class OperationInput
        {
            public SerializableDictionary<OperationInputDirection, KeyCode> inputDirectionMap = new();
        }

        [SerializeField]
        private SerializableDictionary<OperationType, OperationInput> operationInputsMap = new();
        public SerializableDictionary<OperationType, OperationInput> OperationInputsMap => operationInputsMap;

        /// <summary>
        /// Used only for debug visualization in the inspector.
        /// Shows the last resolved input direction for each operation.
        /// </summary>
        [SerializeField] [ReadOnly]
        private SerializableDictionary<OperationType, OperationInputDirection> inputDebugsMap = new();
        public SerializableDictionary<OperationType, OperationInputDirection> InputDebugsMap => inputDebugsMap;

        private Keyboard keyboard;
        
        public override void Initialize()
        {
            base.Initialize();
            keyboard = Keyboard.current;
        }

        public override void ProcessMachineryInputs(ref Dictionary<OperationType, OperationInputDirection> currentInputState)
        {
            keyboard ??= Keyboard.current;
            if (keyboard == null)
            {
                return;
            }
            
            foreach ((OperationType operationType, OperationInput input) in operationInputsMap)
            {
                bool isNone = true;
                foreach ((OperationInputDirection inputDirection, KeyCode keyCode) in input.inputDirectionMap)
                {
                    string keyName = keyCode.ToString();
                    
                    // In the KeyCode enum, these keys are named KeypadPlus and KeypadMinus.
                    // However, in the new Key enum, they are referred to as NumpadPlus and NumpadMinus
                    if (keyName.StartsWith("Keypad"))
                    {
                        keyName = keyName.Replace("Keypad", "Numpad");
                    }
                    
                    if (Enum.TryParse(keyName, out Key keyToPress) && keyboard[keyToPress].isPressed)
                    {
                        inputDebugsMap[operationType] = inputDirection;
                        currentInputState[operationType] = inputDirection;
                        isNone = false;
                        break;
                    }
                }

                if (isNone)
                {
                    inputDebugsMap[operationType] = OperationInputDirection.None;
                    currentInputState[operationType] = OperationInputDirection.None;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/KeyboardMachineryInputModule.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/MachineModuleBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 287e6379092e4afda41f8687b6d48eb8
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Threading;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Ldx.Framework.Features.Machinery
{
    public enum OperationType
    {
        Turn = 0,       // Rotate turret
        Raise = 1,      // Boom up/down
        Extend = 2,     // Boom telescope in/out
        Hoist = 3,       // Hook up/down
        Stop = 4,
    }
    
    /// <summary>
    /// A container for assigning a list machinery modules in the inspector.
    /// </summary>
    [Serializable]
    public class MachineModuleContainer
    {
        [SerializeReference][InheritedClassDropdown(typeof(MachineModuleBase), "Module")]
        public MachineModuleBase action;
    }
    
    /// <summary>
    /// Abstract base class for all machinery movement modules.
    ///
    /// This class defines the core logic for:
    /// - Handling directional player input (positive/negative/none)
    /// - Applying movement over time with acceleration and deceleration
    /// - Respecting custom min/max movement boundaries
    /// - Playing optional audio cues during start/end of motion
    /// - Delegating actual transform changes to subclasses
    ///
    /// Derived classes are expected to implement how motion is applied (e.g., rotation, translation),
    /// define their initial state, and customize limit behavior if needed.
    ///
    /// This base logic is agnostic to what kind of machinery is being moved  it supports
    /// both continuous and one-shot modules (like a telescoping arm or a turret).
    /// </summary>
    [Serializable]
    public abstract class MachineModuleBase
    {
        private const float SPEED_STOP_THRESHOLD = 0.01f;
        private const float LIMIT_EDGE_TOLERANCE = 0.001f;
        
        [SerializeField] private bool enabled = true;
        public bool Enabled => enabled;
        [SerializeField] protected float maxSpeed;
        public float MaxSpeed => maxSpeed;
        [SerializeField] protected bool useLimits = true;
        public bool UseLimits => useLimits;
        [SerializeField] protected Vector2 limits;
        public Vector2 Limits => limits;

        [Range(0f, 1f)][Tooltip("Time in seconds to delay processing input changes (both for starting and stopping movement).")]
        [SerializeField] protected float inputProcessingDelay = 0.25f;
        
        [SerializeField] protected AudioSource startEndAudioSource;
        [SerializeField] protected AudioSource loopAudioSource;
        [SerializeField] protected AudioClip startClip;
        [SerializeField] protected AudioClip endClip;
        [SerializeField] protected AudioClip loopClip; 

        [SerializeField] [ReadOnly] private float currentValue;
        public float CurrentValue
        {
            get => currentValue;
            protected set => currentValue = value;
        }
        
        protected BaseMachineryController owner;
        protected AnimationCurve accelerationCurve;
        protected CancellationTokenSource cts;
        protected CancellationTokenSource inputCts;
        
        public OperationInputDirection CurrentInputDirection { get; protected set; } = OperationInputDirection.None;
        public OperationInputDirection RawInputDirection { get; protected set; } = OperationInputDirection.None;
        public float CurrentSmoothedSpeedFactor { get; protected set; } // -1 to 1
        public float AudioVolumeContribution { get; protected set; }

        public abstract OperationType GetOperationType();
        
        public virtual void OnValidateModule()
        {
#if UNITY_EDITOR
            // In the editor, always ensure the visual transform matches the serialized currentValue.
            // This is called on script reloads or when inspector values change.
            // It correctly re-applies limits if they were changed.
            if (!Application.isPlaying)
            {
                EDITOR_SetValueFromEditor(currentValue);
            }
#endif
        }
        
        /// <summary>
        /// Initializes this module with a controller reference and motion curve.
        ///
        /// This method is called once during Awake in <see cref="BaseMachineryController"/>.
        /// </summary>
        /// <param name="machine">The controller that owns this module.</param>
        /// <param name="accelCurve">The acceleration curve used for motion smoothing.</param>
        public virtual void Initialize(BaseMachineryController machine, AnimationCurve accelCurve)
        {
            owner = machine;
            accelerationCurve = accelCurve;
            SetCurrentInternalValue(GetInitialValue());
            CurrentInputDirection = OperationInputDirection.None;
        }
        
        /// <summary>
        /// Called when this module is destroyed.
        /// Cancels and disposes any running async tasks safely.
        /// </summary>
        public virtual void OnDestroy() 
        {
            cts.SafeCancelAndDispose();
            inputCts.SafeCancelAndDispose();
        }

        /// <summary>
        /// Updates the module's input direction and initiates the motion lifecycle if needed.
        ///
        /// This method manages the entry point for directional updates and starts an async
        /// task that performs acceleration, movement, and deceleration. Repeated calls with the
        /// same direction are ignored unless the state has changed.
        /// </summary>
        /// <param name="direction">The new input direction to apply.</param>
        public virtual void SetInput(OperationInputDirection direction)
        {
            if (!enabled)
            {
                if (CurrentInputDirection != OperationInputDirection.None || RawInputDirection != OperationInputDirection.None || CurrentSmoothedSpeedFactor != 0f)
                {
                    ForceStop();
                }
                
                return;
            }
            
            if (RawInputDirection == direction)
            {
                return;
            }

            if (direction == OperationInputDirection.None)
            {
                if (inputCts != null || cts == null)
                {
                    RawInputDirection = direction;
                    CurrentInputDirection = RawInputDirection;
                    
                    inputCts.SafeCancelAndDispose();
                    inputCts = null;
                    return;
                }
            }
            
            inputCts.SafeCancelAndDispose();
            inputCts = new CancellationTokenSource();
            ProcessInputWithDelayAsync(direction, inputCts.Token).Forget();
        }

        protected virtual float GetValueWithinLimits(float value)
        {
            if (useLimits)
            {
                return Mathf.Clamp(value, limits.x, limits.y);
            }
            
            return value;
        }

        private async UniTask ProcessInputWithDelayAsync(OperationInputDirection direction, CancellationToken token)
        {
            RawInputDirection = direction;
            await UniTask.Delay(inputProcessingDelay.ToMilliseconds(), cancellationToken: token);

            if (token.IsCancellationRequested)
            {
                inputCts = null;
                return;
            }
            
            CurrentInputDirection = RawInputDirection;
            
            inputCts.SafeCancelAndDispose();
            inputCts = null;
          
            cts.SafeCancelAndDispose();
            cts = null;

            if (direction != OperationInputDirection.None || Mathf.Abs(CurrentSmoothedSpeedFactor) > 0.01f)
            {
                cts = new CancellationTokenSource();
                MovementIterationAsync(cts.Token).Forget();
            }
        }

        /// <summary>
        /// Core motion task that smoothly accelerates, applies movement, and decelerates the module.
        /// This async task yields control each frame and is cancellable. It supports resuming motion
        /// when limits are reached and movement is allowed to continue (e.g., staged booms).
        /// </summary>
        /// <param name="token">Cancellation token to safely exit the motion loop.</param>
        protected async UniTask MovementIterationAsync(CancellationToken token)
        {
            bool keepLooping = true;
            bool playedStartSound = false;
            bool playedEndSound = false;

            while (keepLooping && !token.IsCancellationRequested)
            {
                keepLooping = false;

                int targetSign = GetDirectionSign();

                if (targetSign != 0)
                {
                    float initialSpeedT = (CurrentSmoothedSpeedFactor * targetSign > 0)
                        ? accelerationCurve.InverseEvaluate(Mathf.Abs(CurrentSmoothedSpeedFactor))
                        : 0f;

                    float accelElapsed = initialSpeedT * owner.AccelerationTime;
                    while (accelElapsed < owner.AccelerationTime && CurrentInputDirection != OperationInputDirection.None)
                    {
                        token.ThrowIfCancellationRequested();

                        if (!playedStartSound && startClip != null && startEndAudioSource != null)
                        {
                            startEndAudioSource.PlayOneShot(startClip);
                            playedStartSound = true;
                        }

                        float t = Mathf.Clamp01(accelElapsed / owner.AccelerationTime);
                        float speedFactor = accelerationCurve.Evaluate(t);
                        CurrentSmoothedSpeedFactor = targetSign * speedFactor;
                        AudioVolumeContribution = speedFactor;

                        ApplyMovementDelta(CurrentSmoothedSpeedFactor * maxSpeed * Time.deltaTime, out bool limitTriggered);
                        if (limitTriggered)
                        {
                            keepLooping = true;
                            break;
                        }

                        await UniTask.Yield(PlayerLoopTiming.Update, token);
                        accelElapsed += Time.deltaTime;
                    }

                    if (!keepLooping)
                    {
                        CurrentSmoothedSpeedFactor = targetSign * accelerationCurve.Evaluate(1f);
                        AudioVolumeContribution = accelerationCurve.Evaluate(1f);
                        while (CurrentInputDirection != OperationInputDirection.None)
                        {
                            token.ThrowIfCancellationRequested();
                            ApplyMovementDelta(CurrentSmoothedSpeedFactor * maxSpeed * Time.deltaTime, out bool limitTriggered);
                            if (limitTriggered)
                            {
                                keepLooping = true;
                                break;
                            }

                            await UniTask.Yield(PlayerLoopTiming.Update, token);
                        }
                    }
                }

                float initialSpeed = CurrentSmoothedSpeedFactor;
                if (Mathf.Abs(initialSpeed) > float.Epsilon)
                {
                    float decelerationElapsed = 0f;
                    while (decelerationElapsed < owner.DecelerationTime &&
                           (CurrentInputDirection == OperationInputDirection.None || GetDirectionSign() == 0))
                    {
                        token.ThrowIfCancellationRequested();

                        if (!playedEndSound && endClip != null && startEndAudioSource != null && playedStartSound)
                        {
                            startEndAudioSource.PlayOneShot(endClip);
                            playedEndSound = true;
                        }

                        float t = Mathf.Clamp01(decelerationElapsed / owner.DecelerationTime);
                        float fadeFactor = 1f - accelerationCurve.Evaluate(t);
                        CurrentSmoothedSpeedFactor = initialSpeed * fadeFactor;
                        AudioVolumeContribution = Mathf.Abs(initialSpeed) * fadeFactor;

                        if (Mathf.Abs(CurrentSmoothedSpeedFactor) < SPEED_STOP_THRESHOLD)
                        {
                            break;
                        }

                        ApplyMovementDelta(CurrentSmoothedSpeedFactor * maxSpeed * Time.deltaTime, out _);
                        await UniTask.Yield(PlayerLoopTiming.Update, token);
                        decelerationElapsed += Time.deltaTime;
                    }
                }

                CurrentSmoothedSpeedFactor = 0f;
                AudioVolumeContribution = 0f;
            }

            cts = null;
        }
        
        /// <summary>
        /// Calculates the current directional intent based on user input and the movement multiplier.
        /// </summary>
        /// <returns>
        /// Returns:
        /// - <c>1</c> if input is positive,
        /// - <c>-1</c> if input is negative,
        /// - <c>0</c> if there's no input.
        /// The result is also multiplied by <see cref="GetMovementDirectionMultiplier"/> to allow custom inversion.
        /// </returns>
        private int GetDirectionSign()
        {
            if (CurrentInputDirection == OperationInputDirection.Positive) return 1 * GetMovementDirectionMultiplier();
            if (CurrentInputDirection == OperationInputDirection.Negative) return -1 * GetMovementDirectionMultiplier();
            return 0;
        }

        /// <summary>
        /// Applies a delta to the current module value and checks for motion boundaries.
        /// Stops motion if a limit is reached and not handled.
        /// </summary>
        /// <param name="delta">Change in value to apply (positive or negative).</param>
        /// <param name="limitWasHandledAndCanContinue">
        /// Output: True if a limit was reached and handled in a way that allows continued motion.
        /// </param>
        protected virtual void ApplyMovementDelta(float delta, out bool limitWasHandledAndCanContinue)
        {
            limitWasHandledAndCanContinue = false;
            float newValue = CurrentValue + delta;

            if (useLimits)
            {
                CurrentValue = Mathf.Clamp(newValue, limits.x, limits.y);
                ApplyInternalValueToTransform(CurrentValue);

                bool atMaxLimit = CurrentValue >= limits.y - LIMIT_EDGE_TOLERANCE;
                bool atMinLimit = CurrentValue <= limits.x + LIMIT_EDGE_TOLERANCE;
                bool hitLimitThisFrame = false;

                OperationInputDirection attemptedMoveDirection = OperationInputDirection.None;
                if (delta > 0.0001f) attemptedMoveDirection = OperationInputDirection.Positive;
                else if (delta < -0.0001f) attemptedMoveDirection = OperationInputDirection.Negative;

                if ((atMaxLimit && delta > 0) || (atMinLimit && delta < 0))
                {
                    hitLimitThisFrame = true;
                }

                if (hitLimitThisFrame && attemptedMoveDirection != OperationInputDirection.None)
                {
                    limitWasHandledAndCanContinue = ProcessLimitReached(attemptedMoveDirection);

                    if (!limitWasHandledAndCanContinue)
                    {
                        if (Mathf.Approximately(Mathf.Sign(CurrentSmoothedSpeedFactor), Mathf.Sign(delta)))
                        {
                            CurrentSmoothedSpeedFactor = 0;
                            AudioVolumeContribution = 0f;
                        }
                    }
                }
            }
            else
            {
                CurrentValue = newValue;
                ApplyInternalValueToTransform(CurrentValue);
            }
        }
        
        /// <summary>
        /// Called when a limit is hit during motion. Override this to implement special
        /// behavior like staged extension or module handoff.
        /// </summary>
        /// <param name="attemptedMoveDirection">The direction that triggered the limit (Positive or Negative).</param>
        /// <returns>True if the limit was handled and motion should continue; otherwise, false.</returns>
        protected virtual bool ProcessLimitReached(OperationInputDirection attemptedMoveDirection)
        {
            return false;
        }
        
        /// <summary>
        /// Applies the current value (e.g., angle, length) to the object's transform.
        /// Derived classes must implement how the visual transformation happens.
        /// </summary>
        /// <param name="value">The value to apply to the transform.</param>
        protected abstract void ApplyInternalValueToTransform(float value);
        
        /// <summary>
        /// Provides the starting value for the module when it is initialized or reset.
        /// </summary>
        /// <returns>The initial internal value (angle, distance, etc.).</returns>
        protected abstract float GetInitialValue(); 
        
        /// <summary>
        /// Sets the internal motion value directly without triggering motion interpolation.
        /// Used during initialization or reset logic.
        /// </summary>
        /// <param name="value">The value to assign directly.</param>
        protected abstract void SetCurrentInternalValue(float value);

        /// <summary>
        /// Returns the movement direction multiplier (+1 or -1), optionally overridden by derived classes.
        /// Useful for inverting motion direction based on module configuration.
        /// </summary>
        /// <returns>Direction multiplier: 1 by default, can be overridden to -1.</returns>
        protected virtual int GetMovementDirectionMultiplier()
        {
            return 1;
        } 
        
        /// <summary>
        /// Returns the unit vector corresponding to the local axis direction.
        /// Used for determining rotation or extension directions.
        /// </summary>
        /// <param name="axis">The axis (X, Y, or Z).</param>
        /// <returns>Local unit direction vector for the given axis.</returns>
        protected Vector3 GetLocalExtendDirectionVector(Axis axis)
        {
            switch (axis)
            {
                case Axis.X: return Vector3.right;
                case Axis.Y: return Vector3.up;
                case Axis.Z: return Vector3.forward;
                default:     
                    return Vector3.forward; 
            }
        }
        
        /// <summary>
        /// Immediately halts all movement and cancels any pending input processing for this module.
        /// This method provides an immediate, hard stop, bypassing any deceleration logic.
        /// It will also play the 'end' sound clip if the module was in motion.
        /// </summary>
        public virtual void ForceStop()
        {
            if (!enabled || (CurrentSmoothedSpeedFactor == 0f && cts == null && inputCts == null))
            {
                return;
            }
            
            if (Mathf.Abs(CurrentSmoothedSpeedFactor) > SPEED_STOP_THRESHOLD && startEndAudioSource != null && endClip != null)
            {
                if (startEndAudioSource.isPlaying)
                {
                    startEndAudioSource.Stop();
                }
                startEndAudioSource.PlayOneShot(endClip);
            }
    
            // 1. Cancel any pending or active asynchronous operations.
            cts.SafeCancelAndDispose();
            cts = null;
            inputCts.SafeCancelAndDispose();
            inputCts = null;

            // 2. Reset all state variables to their idle/stopped values.
            RawInputDirection = OperationInputDirection.None;
            CurrentInputDirection = OperationInputDirection.None;
            CurrentSmoothedSpeedFactor = 0f;
            AudioVolumeContribution = 0f;
        }
        
#if UNITY_EDITOR
        public virtual void OnDrawGizmosSelected() { }
        
        /// <summary>
        /// Sets the module's value from an editor script (e.g., a custom slider).
        /// This applies the change directly to the transform for scene setup.
        /// It should only be called in Edit Mode.
        /// </summary>
        public virtual void EDITOR_SetValueFromEditor(float value)
        {
            if (useLimits)
            {
                value = Mathf.Clamp(value, limits.x, limits.y);
            }
            
            SetCurrentInternalValue(value);
            ApplyInternalValueToTransform(CurrentValue);

            foreach (Transform transform in EDITOR_GetTransformsToRecordForUndo())
            {
                EditorUtility.SetDirty(transform);
            }
        }

        /// <summary>
        /// Gets all transforms that are modified by this module.
        /// Used by editor scripts to correctly register Undo operations.
        /// </summary>
        /// <returns>A list of transforms affected by this module.</returns>
        public virtual List<Transform> EDITOR_GetTransformsToRecordForUndo()
        {
            return new List<Transform>();
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/MachineModuleBase.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/MachineryInputModuleBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: dca76d8f6c3b43e7b97ac939f3be2dde
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using UnityEngine;

namespace Ldx.Framework.Features.Machinery
{
    /// <summary>
    /// Base class for machinery input modules. 
    /// Modules extending this class should define how to process and translate player input into machinery operation directions.
    /// </summary>
    public class MachineryInputModuleBase : ScriptableObject
    {
        public virtual void Initialize() { }
        
        public virtual void OnDestroy() { }
        
        /// <summary>
        /// Processes inputs and updates the current input state for all machinery operations.
        /// </summary>
        /// <param name="currentInputState">
        /// A reference to a dictionary mapping each <see cref="OperationType"/> to its current <see cref="OperationInputDirection"/>.
        /// This dictionary is updated based on active input signals.
        /// </param>
        public virtual void ProcessMachineryInputs(
            ref Dictionary<OperationType, OperationInputDirection> currentInputState) { }
        
        public virtual void ForceStopInputs(ref Dictionary<OperationType, OperationInputDirection> currentInputState) { }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Machinery/MachineryInputModuleBase.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/IDMagnetFilter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 891bf10e2b8d425dad543ca66c7d36d7
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Features.Magnetic
{
    /// <summary>
    /// MagnetFilter for filtering through on a SocketableID on a MagneticObject
    /// </summary>
    public class IDMagnetFilter : MagnetFilter
    {
        [IDSelection(LdxIdSettings.IdType.Socketable)]
        [SerializeField]
        private List<string> acceptedSocketableIds = new();
        
        public override bool IsValid(MagneticObject magneticObject)
        {
            return acceptedSocketableIds.Contains(magneticObject.SocketableID);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/IDMagnetFilter.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/IMagneticPullSystem.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 224bee8f60bb4161b339c9d3128eaf63
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Features.Magnetic
{
    /// <summary>
    /// Interface for different kinds of magnetic pull systems
    /// </summary>
    public interface IMagneticPullSystem
    {
        public bool IsValid(MagneticObject magneticObject);
        public static Action<IMagneticPullSystem, MagneticObject> OnAnyMagneticObjectSocketed;
        public bool IsSocketed { get; }
        public void DisableSocket();
        public void UnsocketAndDisable();
        public bool TemporarilyLocked { get; set; } // Unlock and Lock to avoid Trigger enter/exit issues during animations
        public Transform EndTransform { get; }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/IMagneticPullSystem.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/MagnetFilter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: dcfc204cc2fd457cb766e14ae6b4d6c9
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Ldx.Framework.Features.Magnetic
{
    /// <summary>
    /// Base class for implementing a filter for MagneticObject
    /// </summary>
    [Serializable]
    public abstract class MagnetFilter
    {
        public abstract bool IsValid(MagneticObject magneticObject);
    }

    [Serializable]
    public class MagnetFilterContainer : IEnumerable<MagnetFilter>
    {
        [SerializeReference] private List<MagnetFilter> filters = new();

        public IEnumerator<MagnetFilter> GetEnumerator()
        {
            return filters.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public bool Filter(MagneticObject magneticObject)
        {
            foreach (var filter in filters)
            {
                if (filter.IsValid(magneticObject))
                    return true;
            }

            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/MagnetFilter.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/MagneticObject.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2cf7fde43ca821547aadb0338547dc2a
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Autohand;
using Cysharp.Threading.Tasks;
using UnityEngine;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Logging;
using Debug = Ldx.Framework.Utilities.Logging.Debug;

namespace Ldx.Framework.Features.Magnetic
{
    public class MagneticObject : MonoBehaviour
    {
        public static event Action<IMagneticPullSystem, MagneticObject> OnAnyMagneticObjectSocketed;
        public event Action<IMagneticPullSystem, MagneticObject> OnSocketed;

        [IDSelection(LdxIdSettings.IdType.Socketable)]
        [SerializeField]
        private string socketableID;

        public string SocketableID => socketableID;

        public Rigidbody LocalRigidbody { get; private set; }
        public Grabbable Grabbable { get; private set; }
        public bool IsSocketed { get; private set; }
        public IMagneticPullSystem SocketedToPullSystem { get; private set; }
        public bool IsEngaged { get; private set; } // So that it doesnt get pulled to two systems;

        private void Awake()
        {
            Initialize().Forget();
        }

        private async UniTaskVoid Initialize()
        {
            LocalRigidbody = GetComponentInParent<Rigidbody>();
            Grabbable = GetComponentInChildren<Grabbable>();

            if (LocalRigidbody == null)
            {
                Debug.LogError(LogCategory.Physics, $"{gameObject.name} does not have a Rigidbody component. Please add one.");
            }

            await UniTask.WaitUntil(() =>
                PlayerController.IsValid || (MagneticSystemController.Instance != null && MagneticSystemController.DebugMode));

            if (Grabbable == null)
            {
                Debug.LogError(LogCategory.Physics, $"{gameObject.name} does not have an HVRGrabbable component. Please add one.");
            }
        }

        public void SetSocketed(bool state, IMagneticPullSystem magneticPullSystem)
        {
            IsSocketed = state;
            LocalRigidbody.isKinematic = state;
            SocketedToPullSystem = state ? magneticPullSystem : null;
            OnSocketed?.Invoke(magneticPullSystem, this);
            OnAnyMagneticObjectSocketed?.Invoke(magneticPullSystem, this);
        }

        public void SetSocketedNoAction(bool state, IMagneticPullSystem magneticPullSystem)
        {
            IsSocketed = state;
            LocalRigidbody.isKinematic = state;
            SocketedToPullSystem = state ? magneticPullSystem : null;

            if (!state)
            {
                SetIsEngaged(false);
            }
        }

        public void ForceRelease()
        {
            if (Grabbable != null)
            {
                Grabbable.ForceHandsRelease();
            }
        }

        public void SetIsEngaged(bool state)
        {
            IsEngaged = state;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/MagneticObject.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/MagneticPull.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7713fb53d53319745b4fd32f674a54e5
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Features.Magnetic
{
    public class MagneticPull : MonoBehaviour
    {
        [Flags]
        public enum Axis
        {
            None = 0,
            X = 1 << 0,
            Y = 1 << 1,
            Z = 1 << 2
        }
        
        [SerializeField] private float radius;
        [SerializeField] private float pullForce;
        [SerializeField] private float minimumThresholdDistance = 0.1f;
        [Tooltip("Reference rotation that the object should align to")] 
        [SerializeField] private Transform referenceRotation;
        [Tooltip("The end transform that influences pull strength. Closer the object is to this, the stronger the pull")]
        [SerializeField] private Transform endTransform;
        [Tooltip("Lock movement on specific axes when within locking distance")] 
        [SerializeField] private Axis lockAxis = Axis.None;
        [SerializeField] private Collider innerPull; // This is the collider we check against to find nearest for multiplier calculations

        private MagneticPullSystem system;
        private Collider cachedMagneticCollider;
        private MagneticObject currentMagneticObject;
        
        public float Radius => radius;
        public float PullForce => pullForce;
        public Transform EndTransform => endTransform;
        public Transform ReferenceRotation => referenceRotation;
        public Axis LockAxis => lockAxis;
        public Collider InnerPull => innerPull;
        public float MinimumThresholdDistance => minimumThresholdDistance;
        
        private void OnTriggerEnter(Collider other)
        {
            if (system.TemporarilyLocked)
                return;
            
            // System only supports 1 at a time.
            if (currentMagneticObject != null)
            {
                if (currentMagneticObject.IsSocketed)
                {
                    SetMagneticState(null, null);
                }
                
                return; 
            }
            
            if (other.TryGetComponent(out MagneticObject magneticObject) && !magneticObject.IsSocketed && system.IsValid(magneticObject))
            {
                SetMagneticState(magneticObject, other);
            }
        }

        private void OnTriggerStay(Collider other)
        {
            if (system.TemporarilyLocked)
                return;
            
            if (other == cachedMagneticCollider)
            {
                system.ApplyMagneticForce(currentMagneticObject, this);
            }
        }

        private void OnTriggerExit(Collider other)
        {           
            if (system.TemporarilyLocked)
                return;
            
            if (other == cachedMagneticCollider)
            {
                SetMagneticState(null, null);
            }
        }
        
        public void SetSystem(MagneticPullSystem magneticPullSystem)
        {
            system = magneticPullSystem;
        }

        private void SetMagneticState(MagneticObject magneticObject, Collider cachedCollider)
        {
            if (currentMagneticObject != null && magneticObject == null)
            {
                currentMagneticObject.LocalRigidbody.constraints = RigidbodyConstraints.None;
                system.ClearMagneticObject();
            }
            
            cachedMagneticCollider = cachedCollider;
            currentMagneticObject = magneticObject;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/MagneticPull.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/MagneticPullSystem.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f7cbb59603ff6f24eb51138f798b5cc3
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Linq;
using Cysharp.Threading.Tasks;
using TMPro;
using UnityEngine;
using System.Threading;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.VFX;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;

namespace Ldx.Framework.Features.Magnetic
{
    public class MagneticPullSystem : MonoBehaviour, IMagneticPullSystem
    {
        private const float TIME_TO_LOCK = 5;

        public static event Action<IMagneticPullSystem, MagneticObject> OnAnyMagneticObjectSocketed;
        public event Action<IMagneticPullSystem, MagneticObject> OnMagneticObjectSocketed;

        [SerializeField] private MagneticPull magneticPull;

        [Header("Parameters")]
        [SerializeField] private float distanceMultiplier = 3;
        [SerializeField] private float minMultiplierToRotate = 2f;
        [SerializeField] private float minMultiplierToLock = 5f;

        [Header("Socketing")]
        [SerializeField] private float distanceBeforeSocket = 0.05f;

        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string onSocketComplete;
        [SoundReference]
        [SerializeField] private string soundOnSocketComplete;
        [SerializeField] private bool useFx;
        [SerializeField] private LdxFxController.FX fxOnSocketed;
        [SerializeField] private Transform fxLocation;
        [SerializeField] private bool enableGravityWhileMagnetized;

        [Header("Filtering")]
        [InheritedClassContainer(typeof(MagnetFilter), itemTitle: "Filter", suffixToRemove: "MagnetFilter")]
        [SerializeField]
        private MagnetFilterContainer filters = new();
#if UNITY_EDITOR
        [SerializeField] private TextMeshProUGUI multiplierDebug;
#endif

        private Vector3 lockedPosition;
        private CancellationTokenSource cancellationTokenSource;
        private UniTask? activeTask;
        private bool isLocked; // This refers to being locked into axis (the last stage before a socket)
        private float currentMultiplier;
        private float sqrDistanceBeforeSocket;
        private bool isSocketed;

        public bool IsSocketed => isSocketed;
        public bool TemporarilyLocked { get; set; }
        public MagneticObject CurrentMagneticObject { get; private set; }
        public Transform EndTransform => magneticPull.EndTransform;

        private void Start()
        {
            InitializeMagneticPull(magneticPull);
            magneticPull.SetSystem(this);
            sqrDistanceBeforeSocket = distanceBeforeSocket * distanceBeforeSocket;
        }

        private void InitializeMagneticPull(MagneticPull pull)
        {
            GameObject colliderObject = new GameObject($"Pull Zone");
            colliderObject.transform.SetParent(pull.transform);
            colliderObject.transform.localPosition = Vector3.zero;
            colliderObject.transform.localScale = Vector3.one;

            BoxCollider boxCollider = colliderObject.AddComponent<BoxCollider>();
            boxCollider.size = new Vector3(pull.Radius, 1, pull.Radius);
            boxCollider.isTrigger = true;
        }

        public void ApplyMagneticForce(MagneticObject magneticObject, MagneticPull pull)
        {
            if (pull == null || pull.EndTransform == null)
                return;

            CurrentMagneticObject = magneticObject;
            Vector3 closestPoint = pull.InnerPull.ClosestPoint(magneticObject.transform.position);
            float distanceToCollider = magneticObject.transform.position.GetDistance(closestPoint);
            Vector3 directionToPoint = (closestPoint - magneticObject.transform.position).normalized;
            float distanceToEndTransform = magneticObject.transform.position.GetDistance(pull.EndTransform.position);
            float endTransformMultiplier = 1 + Mathf.Max(0, 1 - distanceToEndTransform) * distanceMultiplier;
            float innerColliderMultiplier = 1 + Mathf.Max(0, 1 - distanceToCollider);

            currentMultiplier = endTransformMultiplier * innerColliderMultiplier;

#if UNITY_EDITOR
            EDITOR_LogDebug(distanceToEndTransform, endTransformMultiplier, innerColliderMultiplier);
#endif

            if (distanceToCollider < pull.MinimumThresholdDistance)
            {
                magneticObject.LocalRigidbody.linearVelocity = Vector3.zero;
            }
            else
            {
                magneticObject.LocalRigidbody.AddForce(directionToPoint * pull.PullForce * currentMultiplier);
            }

            if (activeTask == null && currentMultiplier > minMultiplierToRotate && !magneticObject.IsSocketed)
            {
                cancellationTokenSource = new CancellationTokenSource();
                activeTask = ManageRotationAndLock(magneticObject, pull, cancellationTokenSource.Token);
            }
            else if (activeTask != null && currentMultiplier < minMultiplierToLock && cancellationTokenSource != null)
            {
                cancellationTokenSource.Cancel();
                ResetConstraints(magneticObject);
            }
        }

        public bool IsValid(MagneticObject magneticObject)
        {
            return filters.Any(f => f.IsValid(magneticObject));
        }

        public void DisableSocket()
        {
            isSocketed = true;
            gameObject.SetActive(false);
        }

        private async UniTask ManageRotationAndLock(MagneticObject magneticObject, MagneticPull pull,
            CancellationToken token)
        {
            while (!token.IsCancellationRequested && magneticObject == CurrentMagneticObject)
            {
                if (currentMultiplier >= minMultiplierToLock)
                {
                    isLocked = true;
                    lockRotationAndAxis();

                    if (magneticObject.transform.position.GetSqrDistance(pull.EndTransform.position) <
                        sqrDistanceBeforeSocket)
                    {
                        socketObject().Forget();
                    }
                }
                else if (currentMultiplier >= minMultiplierToRotate)
                {
                    if (pull.ReferenceRotation != null)
                    {
                        Quaternion targetRotation = pull.ReferenceRotation.rotation;
                        magneticObject.transform.rotation = Quaternion.Slerp(magneticObject.transform.rotation,
                            targetRotation, Time.deltaTime);
                    }
                }
                else
                {
                    ResetConstraints(magneticObject);
                    break;
                }

                await UniTask.Yield();
            }

            activeTask = null;

            void lockRotationAndAxis()
            {
                if (pull.ReferenceRotation != null)
                {
                    magneticObject.transform.rotation = pull.ReferenceRotation.rotation;
                }

                RigidbodyConstraints constraints = RigidbodyConstraints.None;
                Vector3 newPosition = magneticObject.transform.position;

                if (pull.LockAxis.HasFlag(MagneticPull.Axis.X))
                {
                    constraints |= RigidbodyConstraints.FreezePositionX;
                    newPosition.x = pull.transform.position.x;
                }

                if (pull.LockAxis.HasFlag(MagneticPull.Axis.Y) && !enableGravityWhileMagnetized)
                {
                    constraints |= RigidbodyConstraints.FreezePositionY;
                    newPosition.y = pull.transform.position.y;
                }

                if (enableGravityWhileMagnetized)
                {
                    magneticObject.LocalRigidbody.useGravity = true;
                }

                if (pull.LockAxis.HasFlag(MagneticPull.Axis.Z))
                {
                    constraints |= RigidbodyConstraints.FreezePositionZ;
                    newPosition.z = pull.transform.position.z;
                }

                magneticObject.LocalRigidbody.constraints = constraints;
                magneticObject.transform.position = newPosition;
            }

            // The intention of this lock is to ensure if there are other forces trying to pull it out that we don't
            // allow that. A socket within this system is final.
            async UniTaskVoid socketObject()
            {
                magneticObject.SetSocketed(true, this);
                LdxTrackingManager.Instance.BroadcastTrackingEvent(onSocketComplete);
                OnMagneticObjectSocketed?.Invoke(this, magneticObject);
                OnAnyMagneticObjectSocketed?.Invoke(this, magneticObject);
                cancellationTokenSource.Cancel();
                float timer = 0;
                await UniTask.SwitchToMainThread();
                isSocketed = true;
                Audio.PlayOneShot(soundOnSocketComplete);

                if (useFx)
                {
                    Transform fxTransform = fxLocation == null ? pull.EndTransform : fxLocation;
                    LdxFxController.Instance.InstantiateFx(fxOnSocketed, fxTransform, Vector3.zero, Vector3.zero, parentTransform: false);
                }

                while (timer < TIME_TO_LOCK)
                {
                    timer += Time.deltaTime;
                    magneticObject.transform.position = pull.EndTransform.position;
                    magneticObject.transform.rotation = pull.EndTransform.rotation;
                    await UniTask.Yield();
                }
            }
        }

        private void ResetConstraints(MagneticObject magneticObject)
        {
            magneticObject.LocalRigidbody.constraints = RigidbodyConstraints.None;
            isLocked = false;
        }

        public void ClearMagneticObject()
        {
            CurrentMagneticObject = null;
            cancellationTokenSource?.Cancel();
        }

        public void UnsocketAndDisable()
        {
            CurrentMagneticObject.LocalRigidbody.constraints = RigidbodyConstraints.None;
            CurrentMagneticObject.LocalRigidbody.isKinematic = false;
            CurrentMagneticObject.SetSocketed(false, null);
        }

#if UNITY_EDITOR
        private void EDITOR_LogDebug(float distanceToEndTransform, float endTransformMultiplier,
            float innerColliderMultiplier)
        {
            if (multiplierDebug == null ||
                (MagneticSystemController.Instance != null && !MagneticSystemController.DebugMode))
                return;

            multiplierDebug.text =
                $"Distance->End: {distanceToEndTransform:F2}m\n" +
                $"->End Multiplier: {endTransformMultiplier:F2}x\n" +
                $"->Inner Multiplier: {innerColliderMultiplier:F2}x\n" +
                $"Final Multiplier: {currentMultiplier:F2}x\n" +
                $"Locked: {(isLocked ? "Y" : "N")}";
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/MagneticPullSystem.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/MagneticPullSystemSimplified.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a7b25b56cc9856f42be5952262c75e34
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Cysharp.Threading.Tasks;
using TMPro;
using UnityEngine;
using System.Threading;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using Debug = Ldx.Framework.Utilities.Logging.Debug;
using Ldx.Framework.Utilities.Logging;
using UnityEngine.Serialization;

namespace Ldx.Framework.Features.Magnetic
{
    public class MagneticPullSystemSimplified : MonoBehaviour, IMagneticPullSystem
    {
        public static event Action<IMagneticPullSystem, MagneticObject> OnAnyMagneticObjectBeginSocket;
        public static event Action<IMagneticPullSystem, MagneticObject> OnAnyMagneticObjectClearSocket;

        private const float TIME_TO_LOCK = 5f;

        private enum MagneticState
        {
            Waiting, // No object detected
            PullingAndRotating, // Pulling and rotating object towards target
            AxisLocked, // Lock movement on specific axes after position/rotation are nearly correct
            Socketed // Final stage when the object is fully socketed
        }

        private enum Movements
        {
            Everything, // Perform both rotation and position adjustments
            Rotation, // Only adjust rotation
            Position // Only adjust position
        }

        private enum AxisLockMode
        {
            LockPosition, // Lock position on the specified axes
            LockRotation // Lock rotation on the specified axes
        }

        [Header("Movement")] [SerializeField]
        private Movements movementMode = Movements.Everything; // Determines if rotation, position, or both are used

        /// <summary>
        /// When we move to axis lock mode, we fully lock one, and partially lock the other. When you see "LockAxis" below, if you're on
        /// "Position", then rotation will be fully locked, and "Position" will have the lockAxis locked and unlocked based on flags.
        /// </summary>
        [SerializeField] private AxisLockMode axisLockMode = AxisLockMode.LockPosition;

        [Tooltip("Lock movement on specific axis when within locking distance")] [SerializeField]
        private MagneticPull.Axis lockAxis = MagneticPull.Axis.None;

        [Header("Pull and Lock Parameters")] 
        [SerializeField] private float pullForce = 2f; // Reduce speed for smoother transition
        [SerializeField] private float rotationSpeed = 2f;
        [Tooltip("Delta (angle difference or distance) at which we lock axes when near socket position.")]
        [SerializeField] private float deltaBeforeLocking = 0.01f; // Delta (distance or angle) for locking the axis
        [Tooltip("Delta (angle difference or distance) at which we consider the object socketed.")] 
        [SerializeField] private float deltaBeforeSocket = 0.01f; // Delta (distance or angle) for considering the object socketed
        [SerializeField] private Transform firstRotationAndPosition; // First position to pull towards and align with
        [SerializeField] private Transform endTransform; // Final socket position and rotation
        [SerializeField] private bool kinematicOnDetectionUntilAxisLocked = true;
        [SerializeField] private bool enableGravityWhileMagnetized;

        [Header("Filtering")]
        [InheritedClassContainer(typeof(MagnetFilter), itemTitle: "Filter", suffixToRemove: "MagnetFilter")]
        [SerializeField] private MagnetFilterContainer filters = new();

        [FormerlySerializedAs("onSocketComplete")]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)] 
        [SerializeField] private string onSocketCompleteEvent;

        [Header("General")] 
        [SoundReference] 
        [SerializeField] private string socketCompleteSound;
        [SerializeField] private TextMeshProUGUI debugText; // Canvas Text element to display debug information

        [Header("Collision")] 
        [SerializeField] private bool disableCollisionOnPulling = true;
        [SerializeField] private Collider collidableObject;

        private List<Collider> magneticColliders = new();
        private MagneticState currentState = MagneticState.Waiting;
        private CancellationTokenSource cancellationTokenSource;
        private UniTask? activeTask;
        private MagneticObject currentMagneticObject;
        private bool isSocketed;

        public bool IsSocketed => isSocketed;
        public Transform EndTransform => endTransform;
        public MagneticObject CurrentMagneticObject => currentMagneticObject;
        public bool TemporarilyLocked { get; set; }

        private Quaternion cacheLastRotation = Quaternion.identity;
        private Vector3 cacheLastPosition = Vector3.zero;

        private void OnDestroy()
        {
            cancellationTokenSource?.Cancel();
        }

        private void OnTriggerEnter(Collider other)
        {
            if (isSocketed || TemporarilyLocked)
                return;

            if (currentState == MagneticState.Waiting && other.TryGetComponent(out MagneticObject magneticObject) && !magneticObject.IsEngaged &&
                !magneticObject.IsSocketed && filters.Filter(magneticObject))
            {
                currentMagneticObject = magneticObject;
#if UNITY_EDITOR
                EDITOR_LogDebug("$$ TRIGGER ENTER MAGNETIC OBJECT");
#endif
                magneticObject.SetIsEngaged(true);

                SetCollision(magneticObject, true);
                StartPulling(magneticObject);
            }
        }

        private void SetCollision(MagneticObject magneticObject, bool state)
        {
            if (!disableCollisionOnPulling || collidableObject == null)
                return;

            if (!state) // If were disabling, get the mthe first time - otherwise we should already have them
                magneticColliders = GetMagneticColliders(magneticObject);

            foreach (Collider magneticCollider in magneticColliders)
            {
                Physics.IgnoreCollision(magneticCollider, collidableObject, state);
            }
        }

        private void OnTriggerExit(Collider other)
        {
            if (TemporarilyLocked)
                return;

            if (currentMagneticObject != null && other.GetComponent<MagneticObject>() == currentMagneticObject)
            {
#if UNITY_EDITOR
                EDITOR_LogDebug("$$ TRIGGER _EXIT_ MAGNETIC OBJECT");
#endif
                SetCollision(currentMagneticObject, false);
                currentMagneticObject.SetIsEngaged(false);
                currentMagneticObject = null;
                ResetState();
            }
        }

        private void StartPulling(MagneticObject magneticObject)
        {
#if UNITY_EDITOR
            EDITOR_LogDebug("Starting Pulling Stage");
#endif
            if (cancellationTokenSource != null && activeTask != null)
                cancellationTokenSource.Cancel();

            if (kinematicOnDetectionUntilAxisLocked)
            {
                magneticObject.LocalRigidbody.isKinematic = true;
            }

            cancellationTokenSource = new CancellationTokenSource();
            OnAnyMagneticObjectBeginSocket?.Invoke(this, magneticObject);
            currentState = MagneticState.PullingAndRotating;
            activeTask = ManagePullAndLock(magneticObject, cancellationTokenSource.Token);
        }

        private async UniTask ManagePullAndLock(MagneticObject magneticObject, CancellationToken token)
        {
            while (!token.IsCancellationRequested)
            {
                switch (currentState)
                {
                    case MagneticState.PullingAndRotating:
                        HandleMovement(magneticObject, firstRotationAndPosition);
#if UNITY_EDITOR
                        EDITOR_LogDebug(
                            $"Pulling and Rotating - Distance: {magneticObject.transform.position.GetSqrDistance(firstRotationAndPosition.position):F2}");
#endif

                        if (IsWithinDelta(magneticObject, firstRotationAndPosition, deltaBeforeLocking))
                        {
                            currentState = MagneticState.AxisLocked;
#if UNITY_EDITOR
                            EDITOR_LogDebug("Entered AxisLocked State");
#endif
                        }

                        break;

                    case MagneticState.AxisLocked:
                        ApplyAxisLock(magneticObject);
                        cacheLastPosition = magneticObject.transform.position;
                        cacheLastRotation = magneticObject.transform.rotation;
                        
                        if (kinematicOnDetectionUntilAxisLocked)
                        {
                            magneticObject.LocalRigidbody.isKinematic = false;
                        }

                        if (IsWithinDelta(magneticObject, endTransform, deltaBeforeSocket))
                        {
#if UNITY_EDITOR
                            EDITOR_LogDebug("Entered Socketed");
#endif
                            currentState = MagneticState.Socketed;
                            SocketObject(magneticObject).Forget();
                        }

                        break;

                    case MagneticState.Socketed:
                        cancellationTokenSource.Cancel();
                        break;
                }

                await UniTask.Yield();
            }
        }

        private void HandleMovement(MagneticObject magneticObject, Transform target)
        {
            if (movementMode == Movements.Everything || movementMode.HasFlag(Movements.Position))
            {
                Vector3 targetPosition = target.position;

                magneticObject.transform.position = Vector3.Lerp(
                    magneticObject.transform.position,
                    targetPosition,
                    Time.deltaTime * pullForce);
            }

            if (movementMode == Movements.Everything || movementMode.HasFlag(Movements.Rotation))
            {
                magneticObject.transform.rotation = Quaternion.Slerp(
                    magneticObject.transform.rotation,
                    target.rotation,
                    Time.deltaTime * rotationSpeed
                );
            }
        }

        private bool IsWithinDelta(MagneticObject magneticObject, Transform targetTransform, float delta)
        {
            if (axisLockMode == AxisLockMode.LockPosition)
            {
                return magneticObject.transform.position.GetDistance(targetTransform.position) <= delta;
            }
            else if (axisLockMode == AxisLockMode.LockRotation)
            {
                Debug.Log(
                    $"delta angle is {GetRotationDeltaForLockedAxes(magneticObject.transform.localEulerAngles, targetTransform.localEulerAngles)}");
                return GetRotationDeltaForLockedAxes(magneticObject.transform.localEulerAngles,
                    targetTransform.localEulerAngles) <= delta;
            }

            return false;
        }

        private float GetRotationDeltaForLockedAxes(Vector3 currentRotation, Vector3 targetRotation)
        {
            float delta = 0f;

            if (!lockAxis.HasFlag(MagneticPull.Axis.X))
            {
                delta += Mathf.Abs(Mathf.DeltaAngle(currentRotation.x, targetRotation.x));
            }

            if (!lockAxis.HasFlag(MagneticPull.Axis.Y))
            {
                delta += Mathf.Max(delta, Mathf.Abs(Mathf.DeltaAngle(currentRotation.y, targetRotation.y)));
            }

            if (!lockAxis.HasFlag(MagneticPull.Axis.Z))
            {
                delta += Mathf.Max(delta, Mathf.Abs(Mathf.DeltaAngle(currentRotation.z, targetRotation.z)));
            }

            return delta;
        }

        public bool IsValid(MagneticObject magneticObject)
        {
            return filters.Any(f => f.IsValid(magneticObject));
        }

        private async UniTask SocketObject(MagneticObject magneticObject)
        {
            if (currentMagneticObject == null)
                currentMagneticObject = magneticObject;

            magneticObject.SetSocketed(true, this);
            isSocketed = true;
            ApplyAxisLock(magneticObject);
            IMagneticPullSystem.OnAnyMagneticObjectSocketed?.Invoke(this, magneticObject);
            LdxTrackingManager.Instance.BroadcastTrackingEvent(onSocketCompleteEvent);

#if UNITY_EDITOR
            EDITOR_LogDebug("Socketing Object...");
#endif

            if (!string.IsNullOrEmpty(socketCompleteSound))
            {
                Audio.PlayOneShot(socketCompleteSound);
            }

            float elapsedTime = 0f;
            while (elapsedTime < TIME_TO_LOCK)
            {
                elapsedTime += Time.deltaTime;
                magneticObject.transform.position = endTransform.position;
                magneticObject.transform.rotation = endTransform.rotation;
                await UniTask.Yield();
            }

            SetCollision(currentMagneticObject, false);
        }

        private void ApplyAxisLock(MagneticObject magneticObject)
        {
            RigidbodyConstraints constraints = RigidbodyConstraints.None;
            Vector3 newPosition = cacheLastPosition != Vector3.zero
                ? cacheLastPosition
                : magneticObject.transform.position;
            Quaternion newRotation = cacheLastRotation != Quaternion.identity
                ? cacheLastRotation
                : magneticObject.transform.rotation;

            if (axisLockMode == AxisLockMode.LockPosition)
            {
                if (lockAxis.HasFlag(MagneticPull.Axis.X))
                {
                    constraints |= RigidbodyConstraints.FreezePositionX;
                    newPosition.x = endTransform.position.x;
                }

                if (lockAxis.HasFlag(MagneticPull.Axis.Y) && !enableGravityWhileMagnetized)
                {
                    constraints |= RigidbodyConstraints.FreezePositionY;
                    newPosition.y = endTransform.position.y;
                }

                if (lockAxis.HasFlag(MagneticPull.Axis.Z))
                {
                    constraints |= RigidbodyConstraints.FreezePositionZ;
                    newPosition.z = endTransform.position.z;
                }
                
                if (enableGravityWhileMagnetized)
                {
                    magneticObject.LocalRigidbody.useGravity = true;
                }

                magneticObject.transform.rotation = endTransform.rotation;
                magneticObject.transform.position = newPosition;
            }
            else if (axisLockMode == AxisLockMode.LockRotation)
            {
                if (lockAxis.HasFlag(MagneticPull.Axis.X))
                {
                    newRotation.x = endTransform.rotation.x;
                }

                if (lockAxis.HasFlag(MagneticPull.Axis.Y))
                {
                    newRotation.y = endTransform.rotation.y;
                }

                if (lockAxis.HasFlag(MagneticPull.Axis.Z))
                {
                    newRotation.z = endTransform.rotation.z;
                }

                magneticObject.transform.position = endTransform.position; // Since we focus on one or the other, the other should be pre-set
                magneticObject.transform.rotation = newRotation;
            }

            magneticObject.LocalRigidbody.constraints = constraints;
        }

        private List<Collider> GetMagneticColliders(MagneticObject magneticObject)
        {
            if (magneticObject == null)
                return new List<Collider>();

            List<Collider> colliders = magneticObject.GetComponentsInChildren<Collider>().ToList();
            return colliders.Where(o => o.enabled).ToList();
        }

        private void ResetState()
        {
            if (currentMagneticObject != null)
            {
                currentMagneticObject.LocalRigidbody.constraints = RigidbodyConstraints.None;
                OnAnyMagneticObjectClearSocket?.Invoke(this, currentMagneticObject);
            }

            if (!isSocketed)
            {
#if UNITY_EDITOR
                EDITOR_LogDebug("Resetting to Waiting State");
#endif
                currentState = MagneticState.Waiting;
                currentMagneticObject = null; // Only clear currentMagneticObject if not socketed
            }

            activeTask = null;
            cancellationTokenSource?.Cancel();
        }

#if UNITY_EDITOR
        private void EDITOR_LogDebug(string message)
        {
            if (debugText != null)
            {
                debugText.text = $"State: {currentState}\n{message}";
            }

            Debug.Log(category: LogCategory.Inventory, message);
        }
#endif
        public void DisableSocket()
        {
            gameObject.SetActive(false);
        }

        public void UnsocketAndDisable()
        {
            Debug.Log("[MagneticPullSystemSimplified] UnsocketAndDisable called");
            isSocketed = false; // Reset isSocketed flag
            if (currentMagneticObject != null)
            {
                currentMagneticObject.LocalRigidbody.constraints = RigidbodyConstraints.None;
                currentMagneticObject.LocalRigidbody.isKinematic = false;
                currentMagneticObject.SetSocketedNoAction(false, null);
            }

            ResetState(); // Reset the state of the pull system
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/MagneticPullSystemSimplified.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/MagneticSystemController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c90f2ab71fdf86c48ae1856fc169d0f9
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities;
using UnityEngine;

namespace Ldx.Framework.Features.Magnetic
{
    public class MagneticSystemController : Singleton<MagneticSystemController>
    {
        [SerializeField] private bool debugMode;
        public static bool DebugMode => Instance.debugMode;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Magnetic/MagneticSystemController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Measurements/RulerController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 67c20df63d8e4fada4c68c73999137f4
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Features.Drawing;
using UnityEngine;
using TMPro;

namespace Ldx.Framework.Features.Measurement
{
	public class RulerController : MonoBehaviour
	{
		private const float MARGIN_FOR_ERROR_MARKING = 0.0375f; // Original: 0.075f;

		[SerializeField] private HighlightRounding highlighting = HighlightRounding.Round;
		[SerializeField] private float targetNumber; // Target number for highlighting
		[SerializeField] private RulerMaker rulerMaker;
		[SerializeField] private Color startingTextColor = Color.white;
		[SerializeField] private Color highlightedTextColor = Color.green;
		[SerializeField] private Color highlightedIncorrectColor = Color.red;

		private float startingSize;
		private string lastMark;
		private bool enableScanning;
		private DrawingTool currentDrawingTool;
		private float lastNumberScanned = -1;
		private List<bool> truthPool = new List<bool>(); //TODO: Make private

		[Range(-2, 2)] public float xOffset = -1.5f;
		private List<RulerMark> RulerMarks => rulerMaker.RulerMarks;
		private float largeFontSize => startingSize * 1.5f;

		void Start()
		{
			DrawingTool.GrabbedTool += HandleSetDrawingTool;
		}

		void OnDestroy()
		{
			DrawingTool.GrabbedTool -= HandleSetDrawingTool;
		}

		void Update()
		{
			if (enableScanning && currentDrawingTool != null)
			{
				RulerMark mark = GetMarkFromString(GetClosestMarkNumber(currentDrawingTool.transform.position));
				TruthPoolCheck();
				
				if (mark != null)
					HighlightMark(mark);
			}
		}

		private void TruthPoolCheck()
		{
			if (truthPool.Count >= 5)
			{
				truthPool.RemoveAt(0);
			}
			truthPool.Add(IsDrawingToolAtCorrectMark());
		}

		/// <summary>
		/// This checks a "truth pool" - sometimes it will return false (maybe 1/5 tries), but if that is the frame that
		/// the pen enters, the player will have to pull away and reposition. 
		/// </summary>
		public bool CanDrawingToolDraw()
		{
			if (truthPool.Contains(true))
				return true;
			
			return false;
		}

		public bool IsDrawingToolAtCorrectMark()
		{
			return IsCorrectMark(lastNumberScanned);
		}

		public RulerMark GetMarkFromString(string mark)
		{
			if (int.TryParse(mark, out int parsedMark))
				return FindMark(parsedMark);
			return null;
		}

		public void EnableMeasuring(bool state)
		{
			enableScanning = state;
		}

		public string GetClosestMarkNumber(Vector3 pencilPosition)
		{
			if (RulerMarks.Count == 0)
			{
				return "-3";
			}

			// Get the start and end positions of the ruler. We do this dynamically as conduit and ruler can move.
			float rulerStartX = RulerMarks[0].Number.transform.position.x;
			float rulerEndX = RulerMarks[RulerMarks.Count - 1].Number.transform.position.x;

			// Calculate the total length of the ruler
			float rulerLength = rulerEndX - rulerStartX;

			// Clamp the pencil position to the ruler's range
			float clampedPencilX = Mathf.Clamp(pencilPosition.x, rulerStartX, rulerEndX);

			// Normalize the clamped position relative to the ruler's length
			float normalizedPosition = (clampedPencilX - rulerStartX) / rulerLength;

			// Calculate the closest mark number based on the normalized position
			float newMark = (normalizedPosition * rulerMaker.numberOfMarks) + xOffset;
			lastNumberScanned = newMark;
			string closestMark = newMark.ToString("F1");

			if (highlighting != HighlightRounding.None && lastMark != closestMark)
			{
				HighlightMark(FindMark(highlighting == HighlightRounding.Round
					? Mathf.RoundToInt(newMark)
					: Mathf.FloorToInt(newMark)));
				lastMark = closestMark;
			}

			return closestMark;
		}

		/// <summary>
		/// Is the current number close enough to the intended number?
		/// </summary>
		/// <param name="num"></param>
		public bool IsCorrectMark(float num)
		{
			if (lastMark == null)
				return false;

			float mark = targetNumber > 0 ? targetNumber : float.Parse(lastMark);
			bool isInRange = (num < mark + MARGIN_FOR_ERROR_MARKING && num > mark - MARGIN_FOR_ERROR_MARKING);
			return mark.Equals(num) || isInRange;
		}

		public RulerMark FindMark(int num)
		{
			return RulerMarks.Find(o => o.Number.text == num.ToString());
		}

		public void SetTargetNumber(float num)
		{
			targetNumber = num;
		}

		public void HighlightMark(RulerMark mark)
		{
			ResetAllMarks();

			TextMeshPro highlightedNumber = mark.Number;
			highlightedNumber.fontSize = largeFontSize;

			if (targetNumber > 0)
			{
				if (float.TryParse(mark.Number.text, out float num) && IsCorrectMark(num))
				{
					highlightedNumber.color = highlightedTextColor;
					return;
				}

				highlightedNumber.color = highlightedIncorrectColor;
			}
		}

		public void ResetAllMarks()
		{
			foreach (RulerMark rulerMark in RulerMarks)
			{
				TextMeshPro number = rulerMark.Number;
				number.color = startingTextColor;
				number.fontSize = startingSize;
			}
		}

		private void HandleSetDrawingTool(DrawingTool arg, bool state)
		{
			enableScanning = state;
			currentDrawingTool = arg;
		}

		public void SetMark(float arg, bool state)
		{
			SetTargetNumber(arg);
			enableScanning = state;
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Measurements/RulerController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Measurements/RulerMaker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 25f9bef202bc48619b53a456b6b5be49
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using UnityEngine;
#if UNITY_EDITOR
#endif
using TMPro;
using Quaternion = UnityEngine.Quaternion;
using Vector2 = UnityEngine.Vector2;
using Vector3 = UnityEngine.Vector3;

namespace Ldx.Framework.Features.Measurement
{
	public enum MeasurementUnit
	{
		Inches,
		Centimeters
	}
	
	public enum HighlightRounding
	{
		None,
		FloorToInt,
		Round
	}

	/// <summary>
	/// This is an editor tool to create rulers.
	/// </summary>
	[ExecuteInEditMode]
	public class RulerMaker : MonoBehaviour
	{
		private const string FIRST_MARKING_RICH = "<size=1.5em>";
		private const string FIRST_MARKING_RICH_END = "</size>";

		public bool freezeRuler;
		public MeasurementUnit unit;
		public int numberOfMarks = 40;
		public int smallMarksPerBigMark = 8;
		public float markSpacing = 3;
		public RulerMark numberPrefab;
		public Material rulerMaterial; // Material for the cube ruler
		public List<RulerMark> RulerMarks = new List<RulerMark>();

		private GameObject currentRulerCube;
		private float startingSize;
		public float StartingSize => startingSize;

		public void CreateCube()
		{
			if (currentRulerCube != null)
				DestroyImmediate(currentRulerCube);

			// Check if the rulerMaterial is assigned
			if (rulerMaterial == null)
			{
				Debug.LogError("Ruler Material is not assigned to CubeRuler script.");
				return;
			}

			// Calculate the size of the cube based on the UI ruler's width
			float uiRulerWidth = GetComponent<RectTransform>().sizeDelta.x / 8;

			// Create a cube with the same width as the UI ruler
			currentRulerCube = GameObject.CreatePrimitive(PrimitiveType.Cube);
			currentRulerCube.transform.SetParent(transform);
			currentRulerCube.transform.localScale =
				new Vector3(uiRulerWidth + 0.02f, 0.13f, 0.01f);

			// Assign the rulerMaterial to the cube
			Renderer cubeRenderer = currentRulerCube.GetComponent<Renderer>();
			cubeRenderer.material = rulerMaterial;

			// Position the cube at the same location as the UI ruler, pull it back on the Z so that it doesnt overlap
			currentRulerCube.transform.localRotation = Quaternion.identity;
			currentRulerCube.transform.position = transform.position +
			                                      new Vector3(-0.01f, -0.07f,
				                                      0.011f);
		}

		public void CreateRulerMarks()
		{
			if (freezeRuler)
				return;

			CleanHierarchy();

			// Calculate the total length of the ruler based on the selected unit
			float totalLength = ((unit == MeasurementUnit.Inches) ? numberOfMarks : numberOfMarks * 2.54f); // *2

			// Calculate the spacing between small marks
			float smallMarkSpacing = totalLength / (numberOfMarks * smallMarksPerBigMark); // might need + 1

			for (int i = 0; i < numberOfMarks + 1; i++)
			{
				RulerMark rulerMark = CreateMark(smallMarkSpacing);

				// Adjust the character spacing based on the markSpacing property
				TextMeshPro markText = rulerMark.Lines;
				markText.text = "";
				markText.characterSpacing = markSpacing;


				// Create small marks as children
				CreateSmallMarks(rulerMark,
					i != numberOfMarks ? smallMarksPerBigMark : 1); // The last just needs 1 mark

				// Create the number TextMeshPro as a child of the mark
				TextMeshPro numberText = rulerMark.Number;
				startingSize = numberText.fontSize;

				if (i != 0)
					numberText.text = i.ToString();

				rulerMark.Number.fontSize = markText.fontSize;

				// Set the text and name based on the unit and index
				if (unit == MeasurementUnit.Inches)
				{
					rulerMark.gameObject.name = i + " inches";
				}
				else // Centimeters
				{
					rulerMark.gameObject.name = i + " cm";
				}
			}

			foreach (Transform child in transform)
			{
				RulerMark ruler = child.GetComponent<RulerMark>();

				if (RulerMarks.Contains(ruler))
					continue;

				DestroyImmediate(child.gameObject);
			}

			SetWidth(transform, totalLength);
			CreateCube();
		}

		private RulerMark CreateMark(float smallMarkSpacing)
		{
			RulerMark markObject = Instantiate(numberPrefab, transform);
			SetWidth(markObject.transform, smallMarkSpacing);
			RulerMarks.Add(markObject);
			return markObject;
		}

		public void SetWidth(Transform target, float newWidth)
		{
			RectTransform rectTransform = target.GetComponent<RectTransform>();

			if (rectTransform != null)
			{
				// Modify the width by changing the sizeDelta's x value
				Vector2 sizeDelta = rectTransform.sizeDelta;
				sizeDelta.x = newWidth;
				rectTransform.sizeDelta = sizeDelta;
			}
		}

		private void CreateSmallMarks(RulerMark rulerMark, int count)
		{
			TextMeshPro smallMarkText = rulerMark.Lines;

			if (smallMarkText != null)
			{
				smallMarkText.text = "";
				for (int i = 0; i < count; i++)
				{
					if (i == 0 && count != 1)
					{
						smallMarkText.text = FIRST_MARKING_RICH + "|" + FIRST_MARKING_RICH_END;
						continue;
					}

					smallMarkText.text += "|";
				}

				if (count == 1)
					smallMarkText.horizontalAlignment = HorizontalAlignmentOptions.Left;

				smallMarkText.transform.localPosition = Vector3.zero;
				smallMarkText.characterSpacing = markSpacing;
			}
		}

		public void CleanHierarchy()
		{
			foreach (Transform child in transform)
			{
				if (currentRulerCube != null && child != currentRulerCube.transform)
					DestroyImmediate(child.gameObject);
			}

			if (RulerMarks != null)
			{
				RulerMarks.Clear();
			}

			RulerMarks = new List<RulerMark>();

			foreach (Transform child in transform)
			{
				RulerMark ruler = child.GetComponent<RulerMark>();

				if (RulerMarks.Contains(ruler) || (currentRulerCube != null && child == currentRulerCube.transform))
					continue;

				DestroyImmediate(child.gameObject);
			}
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Measurements/RulerMaker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Measurements/RulerMark.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a21c274427004061a4782dcc61699960
# ASMDEF: ldx.framework.runtime.dll
# ---
using TMPro;
using UnityEngine;

namespace Ldx.Framework.Features.Measurement
{
	public class RulerMark : MonoBehaviour
	{
		public TextMeshPro Number;
		public TextMeshPro Lines;
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Measurements/RulerMark.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Movement/MovePositionRelative.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c8a000c149eafa04c960491b834fccd7
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Features.Movement
{
	public class MovePositionRelative : MonoBehaviour
	{
		public enum Axis
		{
			X,
			Y,
			Z,
			XY,
			XZ,
			YZ,
			XYZ
		}

		[IDSelection(LdxIdSettings.IdType.TrackingEvent)] [SerializeField]
		private string eventToStart;

		[IDSelection(LdxIdSettings.IdType.TrackingEvent)] [SerializeField]
		private string eventToEnd;

		[SerializeField] private Transform target;
		[SerializeField] private Axis axisToFollow = Axis.XYZ;
		[SerializeField] private bool onByDefault = true;
		[SerializeField] private float maxMovement; //use this
		[SerializeField] private Vector3 startPosition; // and use this

		private Vector3 lastTargetPosition;

		public bool IsActive { get; private set; }

		private void Start()
		{
			if (target == null)
			{
				Debug.LogError("No Target set for MovePositionRelative, disabling");
				enabled = false;
				return;
			}

			lastTargetPosition = startPosition = target.position;

			if (LdxTrackingManager.Instance != null)
			{
				LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
			}

			if (onByDefault)
			{
				IsActive = true;
			}
		}

		private void OnDestroy()
		{
			if (LdxTrackingManager.IsValid)
			{
				LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
			}
		}

		private void Update()
		{
			if (!IsActive)
				return;

			HandleMovement();
		}

		private void HandleMovement()
		{
			Vector3 targetDelta = target.position - lastTargetPosition;

			Vector3 newPosition = transform.position;
			Vector3 totalMovement = newPosition - startPosition;

			switch (axisToFollow)
			{
				case Axis.X:
					newPosition.x = Mathf.Clamp(startPosition.x + totalMovement.x + targetDelta.x,
						startPosition.x - maxMovement, startPosition.x + maxMovement);
					break;
				case Axis.Y:
					newPosition.y = Mathf.Clamp(startPosition.y + totalMovement.y + targetDelta.y,
						startPosition.y - maxMovement, startPosition.y + maxMovement);
					break;
				case Axis.Z:
					newPosition.z = Mathf.Clamp(startPosition.z + totalMovement.z + targetDelta.z,
						startPosition.z - maxMovement, startPosition.z + maxMovement);
					break;
				case Axis.XY:
					newPosition.x = Mathf.Clamp(startPosition.x + totalMovement.x + targetDelta.x,
						startPosition.x - maxMovement, startPosition.x + maxMovement);
					newPosition.y = Mathf.Clamp(startPosition.y + totalMovement.y + targetDelta.y,
						startPosition.y - maxMovement, startPosition.y + maxMovement);
					break;
				case Axis.XZ:
					newPosition.x = Mathf.Clamp(startPosition.x + totalMovement.x + targetDelta.x,
						startPosition.x - maxMovement, startPosition.x + maxMovement);
					newPosition.z = Mathf.Clamp(startPosition.z + totalMovement.z + targetDelta.z,
						startPosition.z - maxMovement, startPosition.z + maxMovement);
					break;
				case Axis.YZ:
					newPosition.y = Mathf.Clamp(startPosition.y + totalMovement.y + targetDelta.y,
						startPosition.y - maxMovement, startPosition.y + maxMovement);
					newPosition.z = Mathf.Clamp(startPosition.z + totalMovement.z + targetDelta.z,
						startPosition.z - maxMovement, startPosition.z + maxMovement);
					break;
				case Axis.XYZ:
					newPosition.x = Mathf.Clamp(startPosition.x + totalMovement.x + targetDelta.x,
						startPosition.x - maxMovement, startPosition.x + maxMovement);
					newPosition.y = Mathf.Clamp(startPosition.y + totalMovement.y + targetDelta.y,
						startPosition.y - maxMovement, startPosition.y + maxMovement);
					newPosition.z = Mathf.Clamp(startPosition.z + totalMovement.z + targetDelta.z,
						startPosition.z - maxMovement, startPosition.z + maxMovement);
					break;
			}

			transform.position = newPosition;
			lastTargetPosition = target.position;
		}

		private void HandleTrackingEvent(string id)
		{
			if (id == eventToStart)
			{
				IsActive = true;
			}
			else if (id == eventToEnd)
			{
				IsActive = false;
			}
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Movement/MovePositionRelative.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Movement/MoveToPlayerView.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: efc14d37adfa1254ca3c8d6978552dff
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;
using Autohand;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Utilities.Attributes;

namespace Ldx.Framework.Features.Movement
{
    /// <summary>
    /// Keeps an object aligned to the player's head (PlayerController.Instance.MainCamera) plus a local-space offset.
    /// Supports direct Transform motion or physics-based motion, and auto-disable on grab.
    /// </summary>
    public class MoveToPlayerView : MonoBehaviour
    {
        private enum Axis
        {
            X, Y, Z, NegativeX, NegativeY, NegativeZ
        }

        private enum UpMode
        {
            WorldUp, CameraUp
        }
        
        [Header("Mode")]
        [SerializeField] private bool moveWithPhysics;
        [SerializeField] private bool aimAxisAtPlayer;
        [ShowIf(nameof(aimAxisAtPlayer), Op.Equals, true)]
        [SerializeField] private Axis axisToAimAtCamera = Axis.Z;
        [ShowIf(nameof(aimAxisAtPlayer), Op.Equals, true)]
        [SerializeField] private UpMode upMode = UpMode.CameraUp;

        [Header("Target")]
        [ShowIf(nameof(moveWithPhysics), Op.Equals, false)]
        [SerializeField] private Transform transformToMove;
        [ShowIf(nameof(moveWithPhysics), Op.Equals, true)]
        [SerializeField] private Rigidbody rigidbodyToMove;
        [ShowIf(nameof(moveWithPhysics), Op.Equals, true)]
        [SerializeField] private float followSpring = 60;
        [ShowIf(nameof(moveWithPhysics), Op.Equals, true)]
        [SerializeField] private float followDamping = 10;
        [ShowIf(nameof(moveWithPhysics), Op.Equals, true)]
        [SerializeField] private float maxAcceleration = 100;

        [Header("Tracking")]
        [SerializeField] private Vector3 offset;
        [SerializeField] private bool startTrackingOnEnable = true;

        [Header("Stop Tracking View On Grab")]
        [SerializeField] private bool stopTrackingViewOnGrab;
        [ShowIf(nameof(stopTrackingViewOnGrab), Op.Equals, true)]
        [SerializeField] private Grabbable grabbable;

        private Transform cameraTransform;

        public bool TrackingView { get; set; } // Use to activate/deactivate from scripts

        private void OnValidate()
        {
            switch (moveWithPhysics)
            {
                case true when !rigidbodyToMove:
                {
                    Rigidbody rb = GetComponent<Rigidbody>();
                    if (rb)
                        rigidbodyToMove = rb;
                    break;
                }
                case false when !transformToMove:
                    transformToMove = transform;
                    break;
            }

            if (!stopTrackingViewOnGrab || grabbable) 
                return;
            
            Grabbable gb = GetComponent<Grabbable>();
            if (gb)
                grabbable = gb;
        }

        private void OnEnable()
        {
            CacheCamera();
            TrackingView = startTrackingOnEnable;

            if (!transformToMove)
                transformToMove = transform;

            if (stopTrackingViewOnGrab)
                TrySubscribeGrab();
        }

        private void OnDisable()
        {
            UnsubscribeGrab();
        }

        private void LateUpdate()
        {
            if (!TrackingView)
                return;
            
            if (!moveWithPhysics && cameraTransform)
            {
                Transform t = transformToMove ? transformToMove : transform;
                t.position = cameraTransform.TransformPoint(offset);
            }
            
            if (aimAxisAtPlayer)
                RotateAxisTowardCamera(transform);
        }

        private void FixedUpdate()
        {
            if (!moveWithPhysics || !TrackingView)
                return;

            if (!cameraTransform || !rigidbodyToMove)
                return;

            Vector3 targetPos = cameraTransform.TransformPoint(offset);
            Vector3 error = targetPos - rigidbodyToMove.position;
            Vector3 accel = error * followSpring - rigidbodyToMove.linearVelocity * followDamping;
            accel = Vector3.ClampMagnitude(accel, maxAcceleration);
            rigidbodyToMove.AddForce(accel, ForceMode.Acceleration);
        }

        private void RotateAxisTowardCamera(Transform t)
        {
            if (!cameraTransform) return;

            // 1) world-space direction we want to face
            Vector3 forwardDir = (cameraTransform.position - t.position);
            if (forwardDir.sqrMagnitude < 1e-6f) return;
            forwardDir.Normalize();

            // 2) choose an up reference to control roll
            Vector3 upRef = ResolveUp(forwardDir);

            // 3) base look so +Z points to camera with chosen up
            Quaternion baseRot = Quaternion.LookRotation(forwardDir, upRef);

            // 4) remap so the chosen local axis behaves like +Z
            Vector3 localAimAxis = AxisVector(axisToAimAtCamera);
            Quaternion axisToForward = Quaternion.FromToRotation(localAimAxis, Vector3.forward);

            Quaternion desired = baseRot * axisToForward;

            // 5) apply (physics or direct)
            if (moveWithPhysics && rigidbodyToMove)
                rigidbodyToMove.MoveRotation(desired);
            else
                t.rotation = desired;
        }


        private void CacheCamera()
        {
            if (PlayerController.Instance && PlayerController.Instance.MainCamera)
                cameraTransform = PlayerController.Instance.MainCamera.transform;
        }

        private void TrySubscribeGrab()
        {
            if (!grabbable)
                grabbable = GetComponent<Grabbable>();

            if (grabbable)
            {
                grabbable.onGrab.AddListener(OnGrabbed);
            }
        }

        private void UnsubscribeGrab()
        {
            if (grabbable)
                grabbable.onGrab.RemoveListener(OnGrabbed);
        }

        private void OnGrabbed(Hand hand, Grabbable grabbed)
        {
            TrackingView = false;
        }

        public void ForceStop()
        {
            TrackingView = false;
        }
        
        private static Vector3 AxisVector(Axis a) => a switch {
            Axis.X => Vector3.right,
            Axis.NegativeX => Vector3.left,
            Axis.Y => Vector3.up,
            Axis.NegativeY => Vector3.down,
            Axis.Z => Vector3.forward,
            _               => Vector3.back
        };
        
        private Vector3 ResolveUp(in Vector3 forwardDir)
        {
            Vector3 up = upMode switch {
                UpMode.WorldUp  => Vector3.up,
                UpMode.CameraUp => (cameraTransform ? cameraTransform.up : Vector3.up),
                _               => Vector3.up
            };

            // If forward ~ parallel to up, pick a safe fallback to avoid gimbal/NaNs.
            if (Vector3.Dot(forwardDir, up) > 0.999f)
            {
                // any vector not parallel to forward is fine; use right as a quick fallback
                up = Vector3.right;
            }
            
            return up;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Movement/MoveToPlayerView.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/ObjectiveFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3623c8ec794a4733b5b5a5e8aa761ee8
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.Objectives.WorldObjective;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Features
{
    public abstract class ObjectiveFeature : MonoBehaviour, IStepController
    {
        public event Action<ObjectiveFeature> OnFeatureCompleted;
        
        [Header("Listen to:")]
        [HelpBox("ObjectiveFeature implemented the IStepController so StartFeature can be also called via WorldObjectiveStep. " +
                 "Be careful not to use both systems")]
        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string startFeatureEvent;
        
        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string stopFeatureEvent;
        
        [Header("Broadcast:")]
        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string completedFeatureEvent;
        
        [SerializeField] private bool activateOnStart;
        
        [Header("Objects to disable on start")]
        [SerializeField] private List<GameObject> disableOnStart = new List<GameObject>();

        private bool isActivated;
        
        protected virtual void Start() 
        {
            LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;

            foreach (GameObject o in disableOnStart)
            {
                o.SetActive(false);
            }

            if (activateOnStart)
            {
                Activate();
            }
        }

        protected virtual void OnDestroy()
        {
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }

            Deactivate();
        }

        protected virtual void HandleTrackingEvent(string id)
        {
            if (id == startFeatureEvent)
            {
                Activate();
            }
            else if (id == stopFeatureEvent)
            {
                Deactivate();
            }
        }

        public void Activate()
        {
            if (isActivated)
            {
                return;
            }

            isActivated = true;
            StartFeature();
        }

        public void Deactivate(bool isInitialization = false)
        {
            if (!isActivated && !isInitialization)
            {
                return;
            }

            isActivated = false;
            StopFeature(isInitialization);
        }

        protected abstract void StartFeature();
        
        protected virtual void StopFeature(bool isInitialization = false) { }

        protected virtual void CompleteFeature()
        {
            LdxTrackingManager.Instance.BroadcastTrackingEvent(completedFeatureEvent);
            OnFeatureCompleted?.Invoke(this);
        }
        
#if UNITY_EDITOR

        [ContextMenu("Force Complete")]
        public virtual void EDITOR_ForceComplete()
        {
            CompleteFeature();
        }
        
#endif

    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/ObjectiveFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Painting/LdxPaintableSurface.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 712d9ac568491f14faf606e3c4944520
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;
using UnityEngine.Events;

namespace Ldx.Framework.Features.Painting
{
    public class LdxPaintableSurface : MonoBehaviour
    {
        const int TEXTURE_SIZE = 1024;

        public float extendsIslandOffset = 1;

        [Serializable]
        public class OnPaintablePaintEvent : UnityEvent<LdxPaintableSurface, Color>
        {
        }

        [Serializable]
        public class OnPaintableEvent : UnityEvent<LdxPaintableSurface>
        {
        }

        public OnPaintablePaintEvent OnSurfacePainting;
        public OnPaintableEvent OnSurfaceStopPainting;
        public OnPaintableEvent OnSurfaceCleaned;

        [HideInInspector] public Action OnSurfaceInitialized = () => { };

        private RenderTexture extendIslandsRenderTexture;
        private RenderTexture uvIslandsRenderTexture;
        private RenderTexture maskRenderTexture;
        private RenderTexture supportTexture;

        private Renderer surfaceRenderer;

        private int maskTextureID = Shader.PropertyToID("_MaskTexture");

        public RenderTexture getMask() => maskRenderTexture;
        public RenderTexture getUVIslands() => uvIslandsRenderTexture;
        public RenderTexture getExtend() => extendIslandsRenderTexture;
        public RenderTexture getSupport() => supportTexture;
        public Renderer getRenderer() => surfaceRenderer;

        [HideInInspector] public bool IsCleaned = false;

        void Start()
        {
            maskRenderTexture = new RenderTexture(TEXTURE_SIZE, TEXTURE_SIZE, 0);
            maskRenderTexture.filterMode = FilterMode.Bilinear;

            extendIslandsRenderTexture = new RenderTexture(TEXTURE_SIZE, TEXTURE_SIZE, 0);
            extendIslandsRenderTexture.filterMode = FilterMode.Bilinear;

            uvIslandsRenderTexture = new RenderTexture(TEXTURE_SIZE, TEXTURE_SIZE, 0);
            uvIslandsRenderTexture.filterMode = FilterMode.Bilinear;

            supportTexture = new RenderTexture(TEXTURE_SIZE, TEXTURE_SIZE, 0);
            supportTexture.filterMode = FilterMode.Bilinear;

            surfaceRenderer = GetComponent<Renderer>();
            surfaceRenderer.material.SetTexture(maskTextureID, extendIslandsRenderTexture);

            LdxPainter.initTextures(this);

            OnSurfaceInitialized.Invoke();
        }

        public void SetSurfaceCleaned(bool cleaned = true)
        {
            if (cleaned && !IsCleaned)
            {
                OnSurfaceCleaned.Invoke(this);

                LdxPainter.paint(this, transform.position, 100, 1, 1, Color.clear);
            }

            IsCleaned = cleaned;
        }

        void OnDisable()
        {
            maskRenderTexture.Release();
            uvIslandsRenderTexture.Release();
            extendIslandsRenderTexture.Release();
            supportTexture.Release();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Painting/LdxPaintableSurface.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Painting/LdxPaintCleanlinessCheck.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c25ce03f11f4a1346b2cb1188c017ace
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections;
using UnityEngine;

namespace Ldx.Framework.Features.Painting
{
    public class LdxPaintCleanlinessCheck : MonoBehaviour
    {
        [SerializeField] private float PercentageToPass = 0.999f;

        private Texture2D tempTexture2D = null;
        private bool isCalculatingColorPercentage = false;

        public void OnCleanedSurface(LdxPaintableSurface surface)
        {
            if (isCalculatingColorPercentage) return;

            RenderTexture mask = surface.getMask();
            RenderTexture.active = mask;

            tempTexture2D = new Texture2D(mask.width, mask.height);
            tempTexture2D.ReadPixels(new Rect(0, 0, mask.width, mask.height), 0, 0);

            RenderTexture.active = null;

            StartCoroutine(CalculateColorPercentage(surface, tempTexture2D.GetPixels()));
        }

        IEnumerator CalculateColorPercentage(LdxPaintableSurface surface, Color[] colors)
        {
            isCalculatingColorPercentage = true;
            yield return new WaitForEndOfFrame();

            int count = 0;
            int total = 0;

            foreach (var c in colors)
            {
                if (c.a > 0) count++;
                total++;
            }

            float percentage = (total - count) / (float)total;

            if (percentage >= PercentageToPass)
            {
                surface.SetSurfaceCleaned();
            }

            Debug.Log($"Surface clean: {count} dirty out of {total} total - {percentage * 100}%");

            isCalculatingColorPercentage = false;

            yield return null;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Painting/LdxPaintCleanlinessCheck.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Painting/LdxPainter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: eef76d4d5a0c30b49938357c37158828
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;
using UnityEngine.Rendering;

namespace Ldx.Framework.Features.Painting
{
    /// <summary>
    /// This class must be placed in the scene and texturePaint/extendIslands must be assigned.
    /// </summary>
    public class LdxPainter : MonoBehaviour
    {
        public Shader texturePaint;
        public Shader extendIslands;

        private static int prepareUVID = Shader.PropertyToID("_PrepareUV");
        private static int positionID = Shader.PropertyToID("_PainterPosition");
        private static int hardnessID = Shader.PropertyToID("_Hardness");
        private static int strengthID = Shader.PropertyToID("_Strength");
        private static int radiusID = Shader.PropertyToID("_Radius");
        private static int blendOpID = Shader.PropertyToID("_BlendOp");
        private static int colorID = Shader.PropertyToID("_PainterColor");
        private static int textureID = Shader.PropertyToID("_MainTex");
        private static int uvOffsetID = Shader.PropertyToID("_OffsetUV");
        private static int uvIslandsID = Shader.PropertyToID("_UVIslands");

        private static Material paintMaterial;
        private static Material extendMaterial;

        private static CommandBuffer command;

        public void Awake()
        {
            paintMaterial = new Material(texturePaint);
            extendMaterial = new Material(extendIslands);
            command = new CommandBuffer();
            command.name = "CommmandBuffer - " + gameObject.name;
        }

        public static void initTextures(LdxPaintableSurface paintable)
        {
            RenderTexture mask = paintable.getMask();
            RenderTexture uvIslands = paintable.getUVIslands();
            RenderTexture extend = paintable.getExtend();
            RenderTexture support = paintable.getSupport();
            Renderer rend = paintable.getRenderer();

            command.SetRenderTarget(mask);
            command.SetRenderTarget(extend);
            command.SetRenderTarget(support);

            paintMaterial.SetFloat(prepareUVID, 1);
            command.SetRenderTarget(uvIslands);
            command.DrawRenderer(rend, paintMaterial, 0);

            Graphics.ExecuteCommandBuffer(command);
            command.Clear();
        }


        public static void paint(LdxPaintableSurface paintable, Vector3 pos, float radius = 1f, float hardness = .5f,
            float strength = .5f, Color? color = null)
        {
            RenderTexture mask = paintable.getMask();
            RenderTexture uvIslands = paintable.getUVIslands();
            RenderTexture extend = paintable.getExtend();
            RenderTexture support = paintable.getSupport();
            Renderer rend = paintable.getRenderer();

            paintMaterial.SetFloat(prepareUVID, 0);
            paintMaterial.SetVector(positionID, pos);
            paintMaterial.SetFloat(hardnessID, hardness);
            paintMaterial.SetFloat(strengthID, strength);
            paintMaterial.SetFloat(radiusID, radius);
            paintMaterial.SetTexture(textureID, support);
            paintMaterial.SetColor(colorID, color ?? Color.red);
            extendMaterial.SetFloat(uvOffsetID, paintable.extendsIslandOffset);
            extendMaterial.SetTexture(uvIslandsID, uvIslands);

            command.SetRenderTarget(mask);
            command.DrawRenderer(rend, paintMaterial, 0);

            command.SetRenderTarget(support);
            command.Blit(mask, support);

            command.SetRenderTarget(extend);
            command.Blit(mask, extend, extendMaterial);

            Graphics.ExecuteCommandBuffer(command);
            command.Clear();

            paintable.OnSurfacePainting.Invoke(paintable, color ?? Color.red);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Painting/LdxPainter.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Painting/LdxPaintingObject.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b07884bcb9bdb00459f7f740cb958e24
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Features.Painting
{
    public class LdxPaintingObject : MonoBehaviour
    {
        [SerializeField]
        private Vector2 paintRadius = Vector2.one, paintHardness = Vector2.one, paintStrength = Vector2.one;

        [SerializeField] private Color cleanColor = Color.clear;
        
        [SerializeField] private LdxPaintableSurface surfaceToPaintBack = null;
        [SerializeField] private Color dirtyColor = Color.black;

        [SerializeField][SoundReference] private string collideSoundOil;
        [SerializeField][SoundReference] private string collideSoundGeneric;
        [SerializeField][SoundReference] private string collideEndOil;
        private Rigidbody rb;

        private bool EnteredCollision = false;
        private LdxPaintableSurface Paintable_Surface;

        private void Awake()
        {
            rb = GetComponent<Rigidbody>();
        }

        private void OnCollisionEnter(Collision col)
        {
            if (col.gameObject.TryGetComponent<LdxPaintableSurface>(out Paintable_Surface))
            {
                Audio.PlayOneShot(collideSoundOil, transform.position);
                EnteredCollision = true;
                PaintOntoSurface(col.contacts);
            }
            else
            {
                Audio.PlayOneShot(collideSoundGeneric, transform.position);
            }
        }

        private void OnCollisionStay(Collision col)
        {
            if (!EnteredCollision) return;

            PaintOntoSurface(col.contacts);
        }

        private void OnCollisionExit(Collision col)
        {
            if (!EnteredCollision) return;

            Audio.PlayOneShot(collideEndOil, transform.position);

            EnteredCollision = false;

            if (Paintable_Surface != null)
                Paintable_Surface.OnSurfaceStopPainting.Invoke(Paintable_Surface);

            Paintable_Surface = null;
        }

        void PaintOntoSurface(ContactPoint[] contacts)
        {
            if (Paintable_Surface == null || rb.linearVelocity == Vector3.zero || Time.frameCount %  3 != 0) return; //run every 3 frames and dont run if not moving
            foreach (var contact in contacts)
            {
                float radius = Random.Range(paintRadius.x, paintRadius.y);
                float hardness = Random.Range(paintHardness.x, paintHardness.y);
                float strength = Random.Range(paintStrength.x, paintStrength.y);
                LdxPainter.paint(Paintable_Surface, contact.point, radius, hardness, strength, cleanColor);

                if (surfaceToPaintBack != null)
                {
                    Vector3 point = contact.point;
                    if (surfaceToPaintBack.TryGetComponent<Collider>(out var paintableCollider))
                    {
                        point = paintableCollider.ClosestPoint(point);
                    }
                    LdxPainter.paint(surfaceToPaintBack, point, radius, hardness / 4, strength / 4, dirtyColor);
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Painting/LdxPaintingObject.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Painting/LdxProceduralPainter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8c36bef29dbdb504692abe06ed7989bb
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using UnityEngine;

namespace Ldx.Framework.Features.Painting
{
    public class LdxProceduralPainter : MonoBehaviour
    {
        [SerializeField] private LdxPaintableSurface PaintableSurface;
        [SerializeField] private Vector2 PaintRadius = new Vector2(0.03f, 0.5f);
        [SerializeField] private Vector2 PaintHardness = new Vector2(0.8f, 1f);
        [SerializeField] private Vector2 PaintStrength = new Vector2(0.5f, 1f);
        [SerializeField] private Color PaintColor;
        [SerializeField] private int Splotches = 10;

        private Collider painterCollider;
        private Collider surfaceCollider;

        private List<Vector3> paintedPoints = new List<Vector3>();

        private void Awake()
        {
            painterCollider = GetComponent<Collider>();
            surfaceCollider = PaintableSurface.GetComponent<Collider>();

            PaintableSurface.OnSurfaceInitialized += OnSurfaceInitialized;
        }

        private void OnSurfaceInitialized()
        {
            PaintSplotches();
            PaintableSurface.OnSurfaceInitialized -= OnSurfaceInitialized;
        }

        public void PaintSplotches()
        {
            for (int i = 0; i < Splotches; i++)
            {
                RandomlyPaint();
            }
        }

        private void RandomlyPaint()
        {
            Bounds bounds = painterCollider.bounds;
            Vector3 randomPointInBounds = new Vector3(Random.Range(bounds.min.x, bounds.max.x),
                Random.Range(bounds.min.y, bounds.max.y), Random.Range(bounds.min.z, bounds.max.z));

            Vector3 point = surfaceCollider.ClosestPoint(randomPointInBounds);

            LdxPainter.paint(PaintableSurface, point, Random.Range(PaintRadius.x, PaintRadius.y),
                Random.Range(PaintHardness.x, PaintHardness.y), Random.Range(PaintStrength.x, PaintStrength.y),
                PaintColor);

            paintedPoints.Add(point);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Painting/LdxProceduralPainter.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/PhysicsButtons/Dial.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 606b970039764e9698172a1a4e749fef
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Autohand;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Features.PhysicsButtons
{
    public class Dial : PhysicsGadgetHingeAngleReader
    {
        public event Action<Dial, int> OnStepChanged;
        
        [Header("Interaction")]
        [SerializeField] private Grabbable handleGrabbable;
        public Grabbable HandleGrabbable => handleGrabbable;

        [Serializable]
        public class DialStep
        {
            [Tooltip("A descriptive name for this step, shown in the Inspector.")]
            public string name;
            [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
            [Tooltip("The tracking event to broadcast when this step is reached.")]
            public string trackingEvent;
        }

        [SerializeField] private HingeJoint hinge;
        [SerializeField] private Rigidbody rb;
        
        [Tooltip("A list to configure properties for each step, like tracking events.")]
        [SerializeField] private List<DialStep> steps = new();
        
        [Header("Spring")]
        [SerializeField] private bool switchSpringTargetMidway;
        [Range(-1f, 1f)]
        [SerializeField] private float springTargetMidwayValue;
        [SerializeField] private bool invertedCheck;
        
        [Tooltip("The sound to play when the dial moves from one step to another.")]
        [SerializeField] private bool playOnlyOnLastStep = true;
        [SerializeField] [SoundReference] private string stepChangeSound;
        
        public int CurrentStep { get; private set; } = -1;

        private bool hasSpring;
        private bool isLocked;
        private JointLimits originalLimits;
        private float targetLockAngle;
        
        private void OnValidate()
        {
            if (hinge == null)
            {
                hinge = GetComponent<HingeJoint>();
            }

            if (rb == null)
            {
                rb = hinge.GetComponent<Rigidbody>();
            }

            if (handleGrabbable == null)
            {
                handleGrabbable = GetComponent<Grabbable>();
            }
            
            while (steps.Count < 2)
            {
                steps.Add(new DialStep { name = $"Step {steps.Count}" });
            }
        }

        private void Awake()
        {
            hasSpring = hinge.useSpring;          
            originalLimits = new JointLimits()
            {
                min = hinge.limits.min,
                max = hinge.limits.max,
            };
            
            if (hasSpring)
            {
                JointSpring spring = new()
                {
                    spring = hinge.spring.spring,
                    damper = hinge.spring.damper,
                };
                
                hinge.spring = spring;
                targetLockAngle = spring.targetPosition;
            }
        }

        protected override void Start()
        {
            base.Start();
            CurrentStep = GetStepFromValue(GetValue());

            if (handleGrabbable != null)
            {
                handleGrabbable.OnGrabEvent += HandleGrab;
                handleGrabbable.OnReleaseEvent += HandleRelease;
            }
        }
        
        private void OnDestroy()
        {
            if (handleGrabbable != null)
            {
                handleGrabbable.OnGrabEvent -= HandleGrab;
                handleGrabbable.OnReleaseEvent -= HandleRelease;
            }
        }

        private void FixedUpdate()
        {
            if (isLocked)
            {
                return;
            }
            
            float currentValue = GetValue();
            int newStep = GetStepFromValue(currentValue);
            
            if (hasSpring && switchSpringTargetMidway)
            {
                JointSpring spring = hinge.spring;
                spring.targetPosition = (invertedCheck
                    ? currentValue < springTargetMidwayValue
                    : currentValue > springTargetMidwayValue) ? 
                    originalLimits.max :
                    originalLimits.min;
                hinge.spring = spring;
                targetLockAngle = spring.targetPosition;
            }
            
            if (newStep != CurrentStep)
            {
                if (Application.isPlaying)
                {
                    OnStepChange(newStep);
                }
            }
        }

        /// <summary>
        /// Handles all logic associated with a step change.
        /// </summary>
        private void OnStepChange(int newStep)
        {
            if (newStep == CurrentStep)
            {
                return;
            }
            
            CurrentStep = newStep;
            
            if (CurrentStep >= 0 && CurrentStep < steps.Count)
            {
                if (!playOnlyOnLastStep || CurrentStep >= steps.Count - 2)
                {
                    Audio.PlayOneShot(stepChangeSound);
                }
               
                LdxTrackingManager.Instance.BroadcastTrackingEvent(steps[CurrentStep].trackingEvent);
                OnStepChanged?.Invoke(this, CurrentStep);
            }
        }

        /// <summary>
        /// Calculates the discrete step index from the continuous -1 to 1 value.
        /// </summary>
        private int GetStepFromValue(float v)
        {
            if (steps.Count < 2) return 0;
            
            float normalizedValue = (v + 1f) / 2f;
            int stepIndex = Mathf.RoundToInt(normalizedValue * (steps.Count - 1));
            return Mathf.Clamp(stepIndex, 0, steps.Count - 1);
        }
        
        /// <summary>
        /// Called by the Grabbable's OnGrabEvent.
        /// </summary>
        private void HandleGrab(Hand hand, Grabbable grabbable)
        {
            if (hinge.useSpring)
            {
                hinge.useSpring = false;
            }
        }
        
        /// <summary>
        /// Called by the Grabbable's OnReleaseEvent.
        /// </summary>
        private void HandleRelease(Hand hand, Grabbable grabbable)
        {
            if (!isLocked && hasSpring && !hinge.useSpring)
            {
                hinge.useSpring = true;
            }
        }

        /// <summary>
        /// Public method to lock or unlock the dial's rotation.
        /// </summary>
        /// <param name="locked">True to lock the dial, false to unlock.</param>
        public void SetLocked(bool locked)
        {
            if(isLocked == locked)
            {
                return;
            }
            
            isLocked = locked;
            
            if (isLocked)
            {
                if (rb != null)
                {
                    rb.angularVelocity = Vector3.zero;
                }

                hinge.useSpring = false;
                
                JointLimits lockedLimits = new()
                {
                    min = targetLockAngle,
                    max = targetLockAngle + 0.5f,
                };
                
                hinge.limits = lockedLimits;
            }
            else // Unlocking
            {
                hinge.limits = originalLimits;
                hinge.useSpring = hasSpring;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/PhysicsButtons/Dial.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/PhysicsButtons/PhysicsButton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 539470bbfd524e6980989af4f692e53d
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Threading;
using Autohand;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Features.PhysicsButtons
{
    public class PhysicsButton : PhysicsGadgetConfigurableLimitReader
    {
        public event Action<PhysicsButton> OnButtonPressed; 
        public event Action<PhysicsButton> OnButtonUnpressed; 
        
        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string pressedEvent;
        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string unpressedEvent;
        
        [Space]
        [Tooltip("The percentage (0-1) from the required value needed to call the event, if threshold is 0.1 OnPressed will be called at 0.9, and OnUnpressed at 0.1"), Min(0.01f)]
        [SerializeField] private float threshold = 0.1f;
        [SerializeField] private bool lockOnPressed;
        
        [Header("Button Cooldown")]
        [Tooltip("Should there be a delay between button presses to prevent spamming events?")]
        [SerializeField] private bool usePressDelay = true;
        [Tooltip("The time in seconds before the button can be pressed again.")]
        [SerializeField] private float pressDelay = 1.0f;
        
        [Header("Audio")]
        [SerializeField] [SoundReference] private string pressSound;
        [SerializeField] [SoundReference] private string unpressSound;
        
        [Header("Debugging")]
        [Tooltip("Enable to print debug messages to the console.")]
        [SerializeField] private bool showDebugs = false;
        
        private bool pressed;
        private bool isCoolingDown;
        private Vector3 pressedPos;
        private Rigidbody body;
        private CancellationTokenSource cooldownCts;

        protected override void Start()
        {
            base.Start();
            body = joint.GetComponent<Rigidbody>();
        }

        private void OnDestroy()
        {
            cooldownCts.SafeCancelAndDispose();
        }

        protected void FixedUpdate()
        {
            float value = GetValue();
            
            if (showDebugs)
            {
                Debug.Log($"[{gameObject.name}] Button Value: {value:F3} | Pressed State: {pressed}");
            }
            
            if(!pressed && !isCoolingDown && value + threshold >= 1)
            {
                if (showDebugs)
                {
                    Debug.Log($"<color=green>[{gameObject.name}] Press condition MET. Value ({value:F3}) + Threshold ({threshold}) >= 1. Firing PRESSED.</color>");
                }
                
                Pressed();
            }
            else if(!lockOnPressed && pressed && value - threshold <= 0)
            {
                if (showDebugs)
                {
                    Debug.Log($"<color=orange>[{gameObject.name}] Unpress condition MET. Value ({value:F3}) - Threshold ({threshold}) <= 0. Firing UNPRESSED.</color>");
                }
                
                Unpressed();
            }
        }
        
        private void Pressed() 
        {
            pressed = true;
            Audio.PlayOneShot(pressSound, transform);
            LdxTrackingManager.Instance.BroadcastTrackingEvent(pressedEvent);
            OnButtonPressed?.Invoke(this);
            if(lockOnPressed)
            {
                body.isKinematic = true;
            }
            
            if (usePressDelay)
            {
                if (showDebugs)
                {
                    Debug.Log($"[{gameObject.name}] Starting {pressDelay}s cooldown task.");
                }
                
                isCoolingDown = true;
                cooldownCts = new CancellationTokenSource();
                CooldownAsync(cooldownCts.Token).Forget();
            }
        }

        private void Unpressed()
        {
            pressed = false;
            Audio.PlayOneShot(unpressSound, transform);
            LdxTrackingManager.Instance.BroadcastTrackingEvent(unpressedEvent);
            OnButtonUnpressed?.Invoke(this);
        }

        public void Unlock() 
        {
            lockOnPressed = false;
            body.isKinematic = false;
            body.WakeUp();
        }
        
        private async UniTaskVoid CooldownAsync(CancellationToken token)
        {
            try
            {
                await UniTask.Delay(TimeSpan.FromSeconds(pressDelay), cancellationToken: token);
                
                if (showDebugs)
                {
                    Debug.Log($"[{gameObject.name}] Cooldown finished.");
                }
                
                isCoolingDown = false;
            }
            catch (OperationCanceledException)
            {
                if (showDebugs)
                {
                    Debug.Log($"[{gameObject.name}] Cooldown task was cancelled successfully.");
                }
            }
            finally
            {
                cooldownCts.SafeCancelAndDispose();
                cooldownCts = null;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/PhysicsButtons/PhysicsButton.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/PhysicsButtons/PhysicsSwitchButton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ee3954cef5914ace8ea1feb08d12b97f
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Serialization;
using UnityEngine.UI;

namespace Ldx.Framework.Features.PhysicsButtons
{
    /// <summary>
    /// The PhysicsSwitchButton class represents a physics-based VR switch button
    /// The class utilizes Unity's HingeJoint to simulate a realistic flipping mechanism. It can be configured to snap to an 'on' or 'off' position when the switch is within a certain threshold.
    /// Methods in this class manage hinge joint configuration, collision detection for player interactions, determining the target position of the switch, and invoking the appropriate events when the switch is toggled on or off.
    /// </summary>
    public class PhysicsSwitchButton : MonoBehaviour
    {
        [FormerlySerializedAs("hingeJoint")]
        [SerializeField]
        protected HingeJoint joint;
        [SerializeField]
        private bool overrideLimits;
        [SerializeField]
        protected float onAngle = -90f;
        [SerializeField]
        protected float offAngle = 90f;
        [SerializeField][Tooltip("The angle range within which the switch will snap to position")]
        protected float threshold = 30f;
        [SerializeField][Tooltip("How strongly to snap the switch to position")]
        protected float force = 10f;
        
        [SerializeField]
        private UnityEvent OnPhysicsButtonOn;
        [SerializeField]
        private UnityEvent OnPhysicsButtonOff;
        
        [SerializeField]
        protected Image[] lightImagesOn;
        
        [SerializeField]
        protected Color offColor;
        [SerializeField]
        protected Color onColor;
        
        [Header("Audio toggle")]
        [SerializeField][SoundReference]
        private string sfxSwitchOn;
        [SerializeField][SoundReference]
        private string sfxSwitchOff;

        private bool isInteracting = false; // to track whether the player is currently interacting with the switch
        protected float previousAngle = float.MinValue; // stores the previous angle of the switch
        private float targetAngle;
        private readonly HashSet<Collider> colliders = new HashSet<Collider>();
        protected JointLimits onOffLimits;
        protected bool isOn;
        
        private void OnValidate()
        {
            if (joint == null)
            {
                joint = GetComponent<HingeJoint>();
            }
        }

        protected virtual void Start()
        {
            joint.useMotor = true;
            SetLimits();
            SnapToNearestPosition();
        }

        private void Update()
        {
            SnapToNearestPosition();
        }

        protected virtual void SetLimits()
        {
            onOffLimits = new JointLimits()
            {
                min = offAngle,
                max = onAngle,
            };
            
            if (overrideLimits)
            {
                joint.limits = onOffLimits;
            }
        }

        protected void OnCollisionEnter(Collision other)
        {
            colliders.Add(other.collider);

            if (!isInteracting)
            {
                isInteracting = true;
                InteractionStarted();
            }
        }

        private void OnCollisionExit(Collision other)
        {
            colliders.Remove(other.collider);
            isInteracting = colliders.Count < 1;
            if (!isInteracting)
            {
                InteractionCompleted();
            }
        }

        protected virtual void InteractionStarted() { }

        protected virtual void InteractionCompleted()
        {
            SnapToNearestPosition();
        }

        protected virtual void SnapToNearestPosition()
        {
            // Get the current angle of the switch
            float currentAngle = joint.angle;

            if (previousAngle == currentAngle)
            {
                return;
            }
            
            previousAngle = joint.angle;
            
            // Determine the target angle and joint limits based on the current switch position
            targetAngle = GetTargetAngle(currentAngle);

            if (targetAngle == onAngle)
            {
                ButtonOn();
            }
            else if(targetAngle == offAngle)
            {
                ButtonOff();
            }

            if (isInteracting)
            {
                return;
            }
            
            // Calculate the angle difference
            float angleDiff = targetAngle - currentAngle;

            // Get the hinge joint's motor
            JointMotor motor = joint.motor;

            // If the switch is within the threshold angle of being 'on', 'off' or 'neutral', adjust the motor to go towards that position
            if (Mathf.Abs(angleDiff) < threshold)
            {
                motor.targetVelocity = force * Mathf.Sign(angleDiff);
                joint.motor = motor;
            }
        }

        protected virtual float GetTargetAngle(float currentAngle)
        {
            if (Mathf.Abs(currentAngle - onAngle) < threshold)
            {
                return onAngle;
            }

            if (Mathf.Abs(currentAngle - offAngle) < threshold)
            {
                return offAngle;
            }

            return onAngle;
        }

        protected virtual void ButtonOn()
        {
            if (isOn)
            {
                return;
            }

            isOn = true;
            foreach (Image lightImage in lightImagesOn)
            {
                lightImage.color = onColor;
            }
            
            PlayButtonSound(sfxSwitchOn);
            OnPhysicsButtonOn?.Invoke();
        }

        protected virtual void ButtonOff()
        {
            if (!isOn)
            {
                return;
            }

            isOn = false;
            foreach (Image lightImage in lightImagesOn)
            {
                lightImage.color = offColor;
            }
            
            PlayButtonSound(sfxSwitchOff);
            OnPhysicsButtonOff?.Invoke();
        }
        
        protected void PlayButtonSound(string soundReference)
        {
            Audio.PlayOneShot(soundReference, transform.position);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/PhysicsButtons/PhysicsSwitchButton.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/PhysicsButtons/ThreeStageSwitchButton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e6d0d71a747840ceab25fb9f8c390234
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

namespace Ldx.Framework.Features.PhysicsButtons
{
    public class ThreeStageSwitchButton : PhysicsSwitchButton
    {
        [SerializeField]
        private float neutralAngle = 0f;

        [SerializeField]
        private UnityEvent OnPhysicsButtonNeutral;
        [SerializeField][SoundReference]
        private string sfxSwitchNeutral;
        
        //Temp solution
        [SerializeField]
        private Image lightImageNeutral;
        [SerializeField]
        private Image[] lightImagesOff;

        private JointLimits currentLimits;
        private JointLimits offLimits;
        private JointLimits onLimits;

        private float previousTargetAngle; // stores the previous target angle of the switch
        
        protected override void SetLimits()
        {
            base.SetLimits();
            
            offLimits = new JointLimits()
            {
                min = offAngle,
                max = 0,
            };
            
            onLimits = new JointLimits()
            {
                min = 0,
                max = onAngle,
            };

            currentLimits = joint.limits;
            ButtonNeutral();
        }

        protected override void SnapToNearestPosition()
        {
            // Get the current angle of the switch
            float currentAngle = joint.angle;

            if (previousAngle == currentAngle)
            {
                return;
            }
            
            previousAngle = joint.angle;
            
            // Determine the target angle and joint limits based on the current switch position
            float targetAngle;
            
            if (Mathf.Abs(currentAngle - onAngle) < threshold)
            {
                // If the switch was on and is being moved towards the off position, target the neutral position
                targetAngle = onAngle;

                if (currentLimits.min != onLimits.min || currentLimits.max != onLimits.max)
                {
                    joint.limits = onLimits;
                }
            }
            else if (Mathf.Abs(currentAngle - offAngle) < threshold)
            {
                // If the switch was off and is being moved towards the on position, target the neutral position
                targetAngle = offAngle;
                
                if (currentLimits.min != offLimits.min || currentLimits.max != offLimits.max)
                {
                    joint.limits = offLimits;
                }
            }
            else
            {
                // Otherwise, target the neutral position
                targetAngle = neutralAngle;
                
                if (currentLimits.min != onOffLimits.min || currentLimits.max != onOffLimits.max)
                {
                    joint.limits = onOffLimits;
                }
            }
            
            if (previousTargetAngle != targetAngle)
            {
                if (targetAngle == neutralAngle)
                {
                    ButtonNeutral();
                }
                else if (targetAngle == offAngle)
                {
                    ButtonOff();
                }
                else
                {
                    ButtonOn();
                }
                
                previousTargetAngle = targetAngle;
            }

            currentLimits = joint.limits;
            
            // Calculate the angle difference
            float angleDiff = targetAngle - currentAngle;

            // Get the hinge joint's motor
            JointMotor motor = joint.motor;

            // If the switch is within the threshold angle of being 'on', 'off' or 'neutral', adjust the motor to go towards that position
            if (Mathf.Abs(angleDiff) < threshold)
            {
                motor.targetVelocity = force * Mathf.Sign(angleDiff);
                joint.motor = motor;
            }
        }

        private void ButtonNeutral()
        {
            foreach (Image lightImage in lightImagesOn)
            {
                lightImage.color = offColor;
            }

            foreach (Image lightImage in lightImagesOff)
            {
                lightImage.color = offColor;
            }
            
            lightImageNeutral.color = onColor;
            PlayButtonSound(sfxSwitchNeutral);
            OnPhysicsButtonNeutral?.Invoke();
        }

        protected override void ButtonOn()
        {
            if (isOn)
            {
                return;
            }
            
            foreach (Image lightImage in lightImagesOff)
            {
                lightImage.color = offColor;
            }
            
            lightImageNeutral.color = offColor;
            base.ButtonOn();
        }

        protected override void ButtonOff()
        {
            if (!isOn)
            {
                return;
            }
            
            foreach (Image lightImage in lightImagesOff)
            {
                lightImage.color = onColor;
            }
            
            lightImageNeutral.color = offColor;
            base.ButtonOff();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/PhysicsButtons/ThreeStageSwitchButton.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/PPE/PPEFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b1070968b4c34f55adf060393d23ed7e
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Features.Interaction;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.UI.Modules.Tooltip;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using Systems.Objectives.EventData;
using UnityEngine;
using UnityEngine.Serialization;

namespace Ldx.Framework.Features.PPE
{
    /// <summary>
    /// Manages a collection of PPE objects as part of a feature, handling their activation,
    /// deactivation, and tracking of objectives related to PPE usage.
    /// </summary>
    public class PPEFeature : MonoBehaviour
    {
        private const float OBJECT_DISABLE_DELAY = 0.5f;
        
        private readonly HashSet<PPEObject> remainingObjectsSet = new HashSet<PPEObject>();
        
        [SerializeField]
        private PPEObject[] ppeObjects;

        [FormerlySerializedAs("displayCentremostTooltip")]
        [SerializeField]
        private DisplayTooltips displayTooltips;

        [Space]
        [SerializeField][SoundReference] 
        private string equipSound;
        
        private int completionThreshold;
        private string eventToBroadcastOnComplete;
        private bool disableRemainingOnCompletion;
        
        private void OnValidate()
        {
            ppeObjects = GetComponentsInChildren<PPEObject>();
            if (displayTooltips == null)
            {
                displayTooltips = GetComponent<DisplayTooltips>();
            }
        }
        
        private void Start()
        {
            LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;

            foreach (PPEObject ppeObject in ppeObjects)
            {
                if (ppeObject == null)
                {
                    continue;
                }

                ppeObject.OnInteractableObjectGrabbed += HandlePpeObjectGrabbed;
                ppeObject.OnPpeDeactivated += HandlePpeDeactivated;
                ppeObject.DeactivateObject(false);
            }
        }

        private void OnDestroy()
        {
            foreach (PPEObject ppeObject in ppeObjects)
            {
                if (ppeObject == null)
                {
                    continue;
                }
                
                ppeObject.OnInteractableObjectGrabbed -= HandlePpeObjectGrabbed;
                ppeObject.OnPpeDeactivated -= HandlePpeDeactivated;
            }
            
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
            }
        }
        
        private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            if (eventData is PPEFeatureEventData data)
            {
                StartIDFeature(data);
            }
        }
        
        /// <summary>
        /// Initializes the PPE feature by activating all PPE objects, displaying tooltips, and setting completion criteria.
        /// </summary>
        /// <param name="data">Event data containing the completion event ID and object pickup requirements.</param>
        private void StartIDFeature(PPEFeatureEventData data)
        {
            eventToBroadcastOnComplete = data.InvokeEventOnCompletion;
            disableRemainingOnCompletion = data.DisableRemainingOnCompletion;
            remainingObjectsSet.Clear();
            
            foreach (PPEObject ppeObject in ppeObjects)
            {
                if (ppeObject == null)
                {
                    continue;
                }
                
                ppeObject.ActivateObject();
                remainingObjectsSet.Add(ppeObject);
            }
            
            if(displayTooltips != null)
            {
               displayTooltips.Activate(); 
            }

            completionThreshold = data.RequiresAllObjectsPickup ? 0 : remainingObjectsSet.Count - 1;
            TryCompleteFeatureAsync().Forget();
        }
         
        /// <summary>
        /// Handles the deactivation of a PPE object, removing it from the remaining objects set and checking for completion.
        /// </summary>
        private void HandlePpeDeactivated(PPEObject ppe)
        {
            TryCompleteFeatureAsync().Forget();
        }

        private void HandlePpeObjectGrabbed(InteractableObject ppe)
        {
            remainingObjectsSet.Remove(ppe as PPEObject);
            
            if (CanCompleteFeature())
            {
                if(displayTooltips != null)
                {
                    displayTooltips.Deactivate(); 
                }
            }
        }

        /// <summary>
        /// Checks if the completion criteria are met, and if so, broadcasts the completion event.
        /// </summary>
        private async UniTask TryCompleteFeatureAsync()
        {
            if (CanCompleteFeature())
            {
                Audio.PlayOneShot(equipSound);
                
                if (disableRemainingOnCompletion)
                {
                    foreach (PPEObject remainingObject in remainingObjectsSet)
                    {
                        await remainingObject.ProcessActionAsync();
                        await UniTask.Delay(OBJECT_DISABLE_DELAY.ToMilliseconds());
                    }
                
                    remainingObjectsSet.Clear();
                }
                
                LdxTrackingManager.Instance.BroadcastTrackingEvent(eventToBroadcastOnComplete);
            }
        }

        private bool CanCompleteFeature()
        {
            return remainingObjectsSet.Count <= completionThreshold;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/PPE/PPEFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/PPE/PPEObject.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8b39e60535434b2a9b8613a60a6c9814
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Autohand;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Features.Interaction;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Features.PPE
{
    /// <summary>
    /// Represents a personal protective equipment (PPE) object in a VR environment.
    /// The PPE object can be grabbed, activated, and deactivated with various behaviors,
    /// such as highlighting, applying physics properties, and triggering tracking events.
    /// </summary>
    public class PPEObject : InteractableObject
    {
        private const float DISABLE_TIME = 1f;
        
        /// <summary>
        /// Event triggered when the PPE object is deactivated by grabbing.
        /// </summary>
        public event Action<PPEObject> OnPpeDeactivated;
        
        [Space]
        [SerializeReference][InheritedClassDropdown(typeof(PPEOnGrabAction), "PPEOnGrabAction")]
        private PPEOnGrabAction onGrabAction = new AnimateTowardsChestPPEOnGrabAction();

        [SerializeField]
        private bool overrideActionDuration = false;

        [SerializeField][ShowIf(nameof(overrideActionDuration), Op.Equals, true)]
        private float customActionDuration = 0.75f;

        private bool disableAsyncStarted;
        
        private void OnDisable()
        {
            onGrabAction.TerminateAction();
            disableAsyncStarted = false;
        }

        protected override void HandleObjectGrabbed(Hand hand, Grabbable _)
        {
            base.HandleObjectGrabbed(hand, _);
            
            if (!disableAsyncStarted)
            {
                PerformActionOnGrabAndDisablePpeAsync().Forget();
            }
        }

        /// <summary>
        /// Performs an action on grab, waits for a delay, releases the grab, and disables the PPE object.
        /// </summary>
        private async UniTask PerformActionOnGrabAndDisablePpeAsync()
        {
            disableAsyncStarted = true;
            await UniTask.Delay(DISABLE_TIME.ToMilliseconds());

            ForceRelease();
            SetObjectTooltipActive(false);
            
            grabbable.isGrabbable = false;
            rb.useGravity = true;
            rb.isKinematic = true;

            await ProcessActionAsync();
            OnPpeDeactivated?.Invoke(this);
        }

        public async UniTask ProcessActionAsync()
        {
            await onGrabAction.ProcessActionAsync(this, overrideActionDuration ? customActionDuration : null);
            
            BroadcastInteractableObjectDeactivated();
            DeactivateObject(true);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/PPE/PPEObject.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/PPE/PPEOnGrabAction.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c546af9367934e3fb37810b9e49ed846
# ASMDEF: ldx.framework.runtime.dll
# ---
using Cysharp.Threading.Tasks;
using DG.Tweening;
using Ldx.Framework.Systems.Player;
using UnityEngine;

namespace Ldx.Framework.Features.PPE
{
    /// <summary>
    /// Defines the base action behavior for a PPE (Personal Protective Equipment) object 
    /// upon being grabbed. Classes derived from this define specific actions to execute 
    /// during the grab interaction. 
    /// </summary>
    public class PPEOnGrabAction
    {
        /// <summary>
        /// Asynchronously processes the action for the PPE when grabbed.
        /// Derived classes should override this method to specify the action.
        /// </summary>
        /// <param name="ppeObject">The PPE object being grabbed.</param>
#pragma warning disable CS1998
        public virtual async UniTask ProcessActionAsync(PPEObject ppeObject, float? durationOverride = null) { }
#pragma warning restore CS1998
        
        /// <summary>
        /// Terminates any ongoing action or animation related to the PPE grab.
        /// Derived classes can override this to handle specific termination requirements.
        /// </summary>
        public virtual void TerminateAction() { }
    }

    /// <summary>
    /// Defines an action where the PPE object animates towards the player's chest 
    /// when grabbed, simulating a move action to a predefined position at the waist.
    /// </summary>
    public class AnimateTowardsChestPPEOnGrabAction : PPEOnGrabAction
    {
        private const float TWEEN_DURATION = 0.25f;
        
        private Tween moveTween;
        
        public override async UniTask ProcessActionAsync(PPEObject ppeObject, float? durationOverride = null)
        {
            moveTween?.Kill();
            moveTween = ppeObject.transform.DOMove(PlayerController.Instance.WaistController.transform.position,
                durationOverride ?? TWEEN_DURATION);
            await moveTween;
        }

        public override void TerminateAction()
        {
            moveTween?.Kill();
        }
    }
    
    /// <summary>
    /// Defines an action where the PPE object animates towards the player's head 
    /// when grabbed, simulating movement toward the main camera view with vertical offset.
    /// </summary>
    public class AnimateTowardsHeadPPEOnGrabAction : PPEOnGrabAction
    {
        private const float TWEEN_DURATION = 0.25f;
        
        private Tween moveTween;
        
        public override async UniTask ProcessActionAsync(PPEObject ppeObject, float? durationOverride = null)
        {
            moveTween?.Kill();
            Vector3 endPosition = PlayerController.Instance.MainCamera.transform.position;
            endPosition.y += 0.25f;
            moveTween = ppeObject.transform.DOMove(endPosition, durationOverride ?? TWEEN_DURATION);
            await moveTween;
        }

        public override void TerminateAction()
        {
            moveTween?.Kill();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/PPE/PPEOnGrabAction.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/SimpleSwitch.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f478019444c7c004d8ecd0325bd8a3e2
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Serialization;


namespace Ldx.Framework.Features
{
    /// <summary>
    /// A lighter script than HVR's for simple switches, used to invoke things based on very simple parameters. Start it in the middle.
    /// </summary>
    public class SimpleSwitch : MonoBehaviour
    {
        #region Events

        public UnityEvent<bool> invokeOnSwitch;
        public UnityEvent invokeTurnedOn;
        public UnityEvent invokeTurnedOff;

        #endregion

        public bool isOn = false;
        [SerializeField] private float cutoffAngle;

        [SerializeField] private Axis axis;
        [SerializeField][SoundReference] private string switchSound;
        private bool prevBool;
        [SerializeField] private bool debug = false;
        [SerializeField] private float currentEulerAngle;

        [Header("Snap Only")] [Tooltip("Is there range between, or should this just flip on and off?")] [SerializeField]
        private bool snapOnly;

        [Tooltip("Be sure to start the angle tracked to either onAngle or offAngle")] [SerializeField]
        private float onAngle;

        [Tooltip("Be sure to start the angle tracked to either onAngle or offAngle")] [SerializeField]
        private float offAngle;

        [FormerlySerializedAs("rigidbody")]
        [SerializeField] private Rigidbody switchRigidbody;
        [SerializeField] private bool startOn;

        public bool debugMinMax = false;

        private float currentAngle;
        private float previousAngle;

        private HingeJoint hinge;
        
        private void Start()
        {
            Initialize();
        }
        
        private void Update()
        {
            if (debug) //For in-editor testing.
            {
                if (axis == Axis.Z)
                    currentEulerAngle = transform.localEulerAngles.z;
                else if (axis == Axis.X)
                    currentEulerAngle = transform.localEulerAngles.x;
                else if (axis == Axis.Y)
                    currentEulerAngle = transform.localEulerAngles.y;



                if (debugMinMax)
                    DebugMinMax();
            }

            //if (rigidbody.angularVelocity != Vector3.zero) // for performance reasons
            CheckAngle();

        }

        private void Initialize()
        {
            prevBool = isOn;

            hinge = GetComponent<HingeJoint>();

            if (switchRigidbody == null)
                switchRigidbody = GetComponent<Rigidbody>();

            StartOn();

            if (isOn)
            {
                invokeTurnedOn.Invoke();
            }
        }

        private void DebugMinMax()
        {
            onAngle = hinge.limits.max;
            offAngle = hinge.limits.min;
            debugMinMax = false;
        }

        private void StartOn()
        {
            var angles = transform.eulerAngles;

            if (axis == Axis.Z)
                transform.eulerAngles = startOn
                    ? new Vector3(angles.x, angles.y, onAngle)
                    : new Vector3(angles.x, angles.y, offAngle);
            else if (axis == Axis.X)
                transform.eulerAngles = startOn
                    ? new Vector3(onAngle, angles.y, angles.z)
                    : new Vector3(offAngle, angles.y, angles.z);
            else if (axis == Axis.Y)
                transform.eulerAngles = startOn
                    ? new Vector3(angles.x, onAngle, angles.z)
                    : new Vector3(angles.x, offAngle, angles.z);
        }

        public void CheckAngle()
        {
            // /* TODO: Remove this return + push when the issue is figured out.
            //  Right now it spams PlaySoundStereo, resulting in huge performance hiccups
            // */
            // return;
            isOn = (
                (axis == Axis.X && hinge.angle < (hinge.limits.min + hinge.limits.max) / 2) ||
                (axis == Axis.Y && hinge.angle < (hinge.limits.min + hinge.limits.max) / 2) ||
                (axis == Axis.Z && hinge.angle < (hinge.limits.min + hinge.limits.max) / 2)
            );

            //This marks a switch
            if (isOn != prevBool)
            {
                if (switchSound != null)
                    Audio.PlayOneShot(switchSound, transform.position);

                if (snapOnly)
                {
                    if (axis == Axis.X)
                    {
                        if (transform.localEulerAngles.x != onAngle)
                            transform.localEulerAngles = new Vector3(offAngle, transform.localEulerAngles.y,
                                transform.localEulerAngles.z);
                        else
                            transform.localEulerAngles = new Vector3(onAngle, transform.localEulerAngles.y,
                                transform.localEulerAngles.z);
                        currentAngle = transform.localEulerAngles.x;
                    }

                    else if (axis == Axis.Y)
                    {
                        if (transform.localEulerAngles.y != onAngle)
                            transform.localEulerAngles = new Vector3(transform.localEulerAngles.x, offAngle,
                                transform.localEulerAngles.z);
                        else
                            transform.localEulerAngles = new Vector3(transform.localEulerAngles.x, onAngle,
                                transform.localEulerAngles.z);
                        currentAngle = transform.localEulerAngles.y;
                    }

                    else if (axis == Axis.Z)
                    {
                        if (transform.localEulerAngles.z != onAngle)
                            transform.localEulerAngles = new Vector3(transform.localEulerAngles.x,
                                transform.localEulerAngles.y, offAngle);
                        else
                            transform.localEulerAngles = new Vector3(transform.localEulerAngles.x,
                                transform.localEulerAngles.y, onAngle);
                        currentAngle = transform.localEulerAngles.z;
                    }

                    switchRigidbody.linearVelocity = Vector3.zero;

                }


                prevBool = isOn;

                invokeOnSwitch.Invoke(isOn);

                if (isOn)
                    invokeTurnedOn.Invoke();
                else
                    invokeTurnedOff.Invoke();
            }
        }

        //Debug test this with events
        public void TurnedOn()
        {
            Debug.Log("Turned on!");
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/SimpleSwitch.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/SocketFilter/HolsterSpawnData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c5fb6767463a464ca21bb018ecbbc854
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Features.SocketFilter
{
    /// <summary>
    /// Used to define holster spawning configuration for a scenario
    /// </summary>
    [Serializable]
    public class HolsterSpawnData
    {
        [Serializable]
        public enum ColliderSettingsType
        {
            None = 0,
            ScaleSphere,
            BoxCollider
        }

        [SerializeField]
        private bool skipHolsterSlot;
        public bool SkipHolsterSlot => skipHolsterSlot;
        
        [SerializeField]
        private bool startInvisible;
        public bool StartInvisible => startInvisible;

        [SerializeField]
        private Vector3 offset;
        public Vector3 Offset => offset;
        
        [SerializeField] private bool useSocketedOffset;
        public bool UseSocketedOffset => useSocketedOffset;

        [SerializeField] private Vector3 socketedOffset;
        public Vector3 SocketedOffset => socketedOffset;
        
        [Header("Holster")] 
        [IDSelection(LdxIdSettings.IdType.Socketable)]
        [SerializeField]
        private List<string> holsterFilterIds = new List<string>();
        public List<string> HolsterFilterIDs => holsterFilterIds;

        [SerializeField] 
        private bool scaleGrabbable = true;
        public bool ScaleGrabbable => scaleGrabbable;
        
        [Header("Collider settings")]
        [SerializeField] private ColliderSettingsType colliderSettings;
        public ColliderSettingsType ColliderSettings => colliderSettings;
        
        [Tooltip("If collider settings is ScaleSphere")]
        [SerializeField] private float colliderRadius = 0.15f;
        public float ColliderRadius => colliderRadius;
        
        [Tooltip("If collider settings is BoxCollider")]
        [SerializeField] private BoxColliderSettings boxColliderSettings = new();
        public BoxColliderSettings BoxColliderSettings => boxColliderSettings;
        
        [Header("Socketed Item")]
        [SerializeField]
        private GameObject socketedItemPrefab;
        public GameObject SocketedItemPrefab => socketedItemPrefab;
        
        [IDSelection(LdxIdSettings.IdType.Socketable)]
        [SerializeField] 
        private string socketedItemFilterID;
        public string SocketedItemFilterID => socketedItemFilterID;

        [IDSelection(LdxIdSettings.IdType.Interactable)] [SerializeField]
        private string interactableId;
        public string InteractableID => interactableId;
    }
    
    [Serializable]
    public class HolsterSpawnDataContainer : IEnumerable<HolsterSpawnData>
    {
        [SerializeField] 
        private List<HolsterSpawnData> list = new List<HolsterSpawnData>();

        public IEnumerator<HolsterSpawnData> GetEnumerator()
        {
            return list.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
    
    [Serializable]
    public class BoxColliderSettings
    {
        [SerializeField] private Vector3 center;
        public Vector3 Center => center;

        [SerializeField] private Vector3 size = Vector3.one * 0.1f;
        public Vector3 Size => size;

        public void Apply(BoxCollider boxCollider)
        {
            boxCollider.center = Center;
            boxCollider.size = Size;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/SocketFilter/HolsterSpawnData.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Splines/SplineCableSimulator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: be6a4900007e4cb2b9c6a48fb3a06a59
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities.Attributes;
using SplineMesh;
using UnityEngine;

namespace Ldx.Framework.Features.Splines
{
    /*
     * The idea is to basically to record the curve's start nodes, and have that be t=0
     * Then if we can imagine its maximum length stretched, that's t=1
     * 
     * We can get the current t by comparing the current distance of the start/end nodes with
     * the start distance and maximum distance.
     * E.g. If the nodes start off with a distance of 1, and it can be stretched to a maximum
     * of 3, and the current distance between start/end is 2, then t = 0.5
     *
     * We can then use this t to lerp between the start spline and a straight spline in
     * the same direction
     */
    /// <summary>
    /// Maintains a curve's length even if pulled, use for simple ropes or cables
    /// </summary>
    [RequireComponent(typeof(Spline))]
    public class SplineCableSimulator : MonoBehaviour
    {
        private float MIN_SQR_MAG_STEP_TO_UPDATE = 5f;

        [SerializeField] private bool startActive = true;
        
        [SerializeField] private Spline spline;

        [HelpBox("The higher this multiplier, the higher the distance needs to be to update the spline")]
        [SerializeField] private float distanceUpdateSkipMultiplier = 1.0f;
        
        private SplineInfo startSplineInfo;
        private SplineInfo straightSplineInfo;

        private float lastSqrMag;
        private float startDistance;
        private float straightDistance;

        public bool IsActive { get; private set; }
        private float MinSqrMagToUpdate => MIN_SQR_MAG_STEP_TO_UPDATE * distanceUpdateSkipMultiplier;

        private void OnValidate()
        {
            if (spline == null)
            {
                spline = GetComponent<Spline>();
            }
        }

        private void Awake()
        {
            IsActive = startActive;
            // So we can access length
            spline.RefreshCurves();
            // Initialize the spline info so we can lerp when we need to
            startSplineInfo = SplineInfo.GetInfo(spline);
            straightSplineInfo = SplineInfo.GetInfo(spline);
            // Will use to compare so we can check if we should update yet
            lastSqrMag = Vector3.SqrMagnitude( spline.nodes[0].Position - spline.nodes[^1].Position);
            
            // The start distance between first and last node is where t=0
            startDistance = Vector3.Distance(spline.nodes[0].Position, spline.nodes[^1].Position);
            // When the distance between first/last node is equal to the total curve length at the beginning then t=1
            // so we can maintain its length as much as possible
            // Basically the final position is when the curve is stretched to its length meaning it's straight
            straightDistance = spline.Length;
        }

        private void FixedUpdate()
        {
            if (!IsActive)
            {
                return;
            }
            
            // Sqr dist between first and last node so we can check if we should update
            float sqrMag = Vector3.SqrMagnitude( spline.nodes[0].Position - spline.nodes[^1].Position);
            if (Mathf.Abs(sqrMag - lastSqrMag) < MinSqrMagToUpdate)
            {
                return;
            }
            
            UpdateSpline();            
            
            lastSqrMag = sqrMag;
        }
        

        private void UpdateSpline()
        {
            // We'll need the distance to get the value of t and use it to lerp between curves
            float distance = Vector3.Distance(spline.nodes[0].Position, spline.nodes[^1].Position);
            float t = Mathf.Clamp01(Mathf.InverseLerp(startDistance, straightDistance, distance));
            
            // We get direction from first => last node so we can get the stretched 
            // straight spline in that direction
            Vector3 direction = (spline.nodes[^1].Position - spline.nodes[0].Position).normalized;
            // Straight spline has equal segments in the direction we calculated. This is the segment's length.
            float segmentLength = straightDistance / (spline.nodes.Count - 1);
            // First and last nodes can be controlled. So we reset their positions at the end.
            Vector3 firstNodePos = spline.nodes[0].Position;
            Vector3 lastNodePos = spline.nodes[^1].Position;
            
            // Calculate a straight spline in this direction
            straightSplineInfo[0].Direction = straightSplineInfo[0].Position + (direction * (segmentLength / 2.0f));
            for (int i = 1; i < straightSplineInfo.Count; i++)
            {
                SplineNode prevNode = straightSplineInfo[i-1];
                SplineNode node = straightSplineInfo[i];
                node.Position = prevNode.Position + (direction * segmentLength);
                node.Direction = node.Position + (direction * (segmentLength/2.0f));
            }
            
            // Lerp between the start spline and a straight spline in this direction with the t we calculated
            // through distance between first/last node
            SplineInfo.LerpSpline(startSplineInfo, straightSplineInfo, spline, t, false);
            // Reset first and last node positions (so they can be controlled if needs be)
            spline.nodes[0].Position = firstNodePos;
            spline.nodes[^1].Position = lastNodePos;
            // Refresh the curve
            spline.RefreshCurves();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Splines/SplineCableSimulator.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Splines/SplineInfo.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 894c43cbf5be4ce786d5771ee9d32065
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Utilities.Logging;
using SplineMesh;
using UnityEngine;
using Debug = Ldx.Framework.Utilities.Logging.Debug;

namespace Ldx.Framework.Features.Splines
{
    /// <summary>
    /// Class for tracking a SplineMesh info
    /// </summary>
    public class SplineInfo
    {
        public List<SplineNode> Nodes { get; private set; }
        public int Count => Nodes.Count;

        public SplineNode this[int i]
        {
            get { return Nodes[i]; }
            set { Nodes[i] = value; }
        }

        protected SplineInfo(List<SplineNode> nodes)
        {
            Nodes = new List<SplineNode>();
            foreach (SplineNode node in nodes)
            {
                SplineNode n = new SplineNode(node.Position, node.Direction);
                n.Roll = node.Roll;
                Nodes.Add(n);
            }
        }

        public static SplineInfo GetInfo(Spline spline)
        {
            return new SplineInfo(spline.nodes);
        }

        public static SplineInfo GetInfo(List<SplineNode> nodes)
        {
            return new SplineInfo(nodes);
        }

        /// <summary>
        /// Lerps a spline between start a and end b by amount t 
        /// </summary>
        public static void LerpSpline(SplineInfo a, SplineInfo b, Spline spline, float t, bool refreshCurve = true)
        {
            if (a.Count != b.Count || b.Count != spline.nodes.Count)
            {
                Debug.LogError(LogCategory.Other, "Can't lerp spline, node count doesn't match");
                return;
            }

            t = Mathf.Clamp01(t);

            for (int i = 0; i < spline.nodes.Count; i++)
            {
                SplineNode nA = a.Nodes[i];
                SplineNode nB = b.Nodes[i];
                spline.nodes[i].Position = Vector3.Lerp(nA.Position, nB.Position, t);
                spline.nodes[i].Direction = Vector3.Lerp(nA.Direction, nB.Direction, t);
                spline.nodes[i].Roll = Mathf.Lerp(nA.Roll, nB.Roll, t);
            }

            if (refreshCurve)
            {
                spline.RefreshCurves();
            }
        }
    }

    public class WeighedSplineInfo : SplineInfo
    {
        public float Weight { get; }

        protected WeighedSplineInfo(List<SplineNode> nodes, float weight) : base(nodes)
        {
            Weight = weight;
        }

        public static WeighedSplineInfo GetInfo(Spline spline, float weight)
        {
            return new WeighedSplineInfo(spline.nodes, weight);
        }

        public static void LerpSpline(Spline spline, float t, params WeighedSplineInfo[] infoList)
        {
            WeighedSplineInfo a = null;
            WeighedSplineInfo b = null;
            float adjustedT = t;

            // First we get a and b, the two splines we're interpolating between
            for (int i = 0; i < infoList.Length; i++)
            {
                if (i >= infoList.Length - 1)
                {
                    Debug.LogError("Provided spline list has invalid weights");
                    return;
                }

                WeighedSplineInfo current = infoList[i];
                WeighedSplineInfo next = infoList[i + 1];
                if (current.Weight <= t && next.Weight > t)
                {
                    a = current;
                    b = next;
                    // The t between spline a and b
                    adjustedT = (t - current.Weight) / (next.Weight - current.Weight);
                    break;
                }
            }

            // We can now lerp normally
            LerpSpline(a, b, spline, adjustedT);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Splines/SplineInfo.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Splines/SplineMasterController/Features/AnimationSplineFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f88d2d147f445a647b68c878c462f5b2
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using SplineMesh;
using UnityEngine;

namespace Ldx.Framework.Features.Splines
{
    /// <summary>
    /// Allows animation of the end of the spline by adding nodes at the end and tweening the nodes between points
    /// that are designated by the list of reference transforms. Contains properties relevant to spline animation.
    /// </summary>
    [Serializable]
    public class AnimationSplineFeature : SplineFeature
    {
        [Header("Event to Broadcast After Animation is Complete:")]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string animationCompleteEvent;
        [Header("Event to Listen to to Start Animation(if playing on event):")]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string animationStartEvent;
        
        [SerializeField] private Transform[] animationNodeTransforms;
        [SerializeField] private bool loopAnimation;
        [SerializeField] private bool playAnimationOnEnable;
        [SerializeField] private bool playAnimationOnEvent = true;
        [SerializeField] private float animationRepeatDelay = 1f;

        private Tween animateNodeTween;
        private bool animationStarted;
        private bool animationComplete;
        
        public AnimationSplineFeature()
        {
            setupInstructions = "Animation nodes are located at the end of a spline and will play an animation that " +
                                "moves the spline from the first element of the animation nodes to the last " +
                                "animation node and can be toggled to loop as long as the spline is active for the " +
                                "current objective. \n \nAs with the Visual Nodes the reference transform's green Up " +
                                "arrow will correspond to the top of the spline's mesh.\nUse this for preventing " +
                                "twists or creating your own desired curve along the spline.";
        }

        protected override void OnFeatureEnabled()
        {
           EnableAnimationFeatureAsync().Forget();
        }

        private async UniTaskVoid EnableAnimationFeatureAsync()
        {
            if (playAnimationOnEvent)
            {
                await UniTask.WaitUntil(() => LdxTrackingManager.IsValid);
                LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
            }
            
            if (playAnimationOnEnable)
            {
                PlaySplineAnimation().Forget();
            }
        }

        protected override void OnFeatureDisabled()
        {
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }
        }

        private void HandleTrackingEvent(string eventId)
        {
            if (animationStarted)
            {
                return;
            }

            if (eventId == animationStartEvent)
            {
                PlaySplineAnimation().Forget();
            }
        }

        public async UniTask PlaySplineAnimation()
        {
            animationStarted = true;
            float nextUpdateTime;
            while (!animationComplete || loopAnimation)
            {
                if (IsTransformOrControllerInvalid(controller.transform))
                {
                    return;
                }
                
                await UniTask.WaitUntil(() => controller.InitializationComplete);

                int initialSize = controller.SplineSizeBeforeAnimation;
                if (CurrentSpline.nodes.Count > initialSize)
                {
                    CurrentSpline.nodes.RemoveRange(initialSize, animationNodeTransforms.Length);
                }

                animateNodeTween?.Kill();

                foreach (Transform t in animationNodeTransforms)
                {
                    if (IsTransformOrControllerInvalid(t))
                    {
                        return;
                    }
                    
                    bool animationStepComplete = false;
                    Vector3 startPosition = CurrentSpline.nodes[^1].Position;
                    SplineNode animationNode = new(startPosition, Vector3.zero)
                    {
                        Up = t.up
                    };
                    CurrentSpline.nodes.Add(animationNode);
                    animateNodeTween = DOTween.To(() => animationNode.Position,
                            x => animationNode.Position = x,
                            controller.GetInversePoint(t),
                            controller.MovementSpeed)
                        .SetEase(Ease.InOutSine)
                        .OnUpdate(() =>
                        {
                            if (IsTransformOrControllerInvalid(t))
                            {
                                animateNodeTween?.Kill();
                                animationStepComplete = true;
                            }
                        })
                        .OnComplete(() => animationStepComplete = true);

                    await UniTask.WaitUntil(() => animationStepComplete);
                }

                nextUpdateTime = Time.time + animationRepeatDelay;
                await UniTask.WaitUntil(() => Time.time > nextUpdateTime);
                if (loopAnimation)
                {
                    continue;
                }
                
                animationComplete = true;
                BroadcastEvent(animationCompleteEvent);
            }
        }

        private bool IsTransformOrControllerInvalid(Transform t)
        {
            return t == null || controller == null;
        }

        private void BroadcastEvent(string eventID)
        {
            LdxTrackingManager.Instance.BroadcastTrackingEvent(eventID);
        }
        
        public override Transform[] GetAnimationNodeTransforms() => animationNodeTransforms;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Splines/SplineMasterController/Features/AnimationSplineFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Splines/SplineMasterController/Features/GrabbingSplineFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7f6fb8f4374a9db44a150dd2dbf3cdeb
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Autohand;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Features.Splines
{
    [Serializable]
    public class GrabbingSplineFeature : SplineFeature
    {
        [Header("Event to Broadcast:")]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string grabPointGrabbedEvent;
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string grabbingCycleCompleteEvent;
        [Header("Event to Listen to:")]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string grabPointPositionedEvent;
        
        [Tooltip("The point that connects the rest of the spline(or the start) to the grab point.")]
        [SerializeField] private Transform grabStartNodeTransform;
        public Transform GrabStartNodeTransform
        {
            get => grabStartNodeTransform;
            set => grabStartNodeTransform = value;
        }

        [Tooltip("The grabbable point of the spline that will track the player's hand movement when held.")]
        [SerializeField] private Transform grabPointNodeTransform;
        [SerializeField] private Grabbable grabPointGrabbable;
        [Tooltip("The exact point the grab point node will move to after being positioned. Can be the target " +
                 "collider or another point altogether.")]
        [SerializeField] private Transform grabPointFinalTargetPosition;
        [SerializeField] private bool canRotateWhenGrabbed;
        [SerializeField] private bool moveGrabPointTransformOnComplete;
        [SerializeField] private bool startPointTransformMoves;

        private bool isTrackingGrabbed;
        private Sequence grabbableMoveSequence;
        
        private int grabbableNodeIndex;

        public GrabbingSplineFeature()
        {
            setupInstructions = "Enabling grabbing on your spline means that you can grab the end of the spline, or " +
                                "something that is attached to the end of the spline, and move it from one location " +
                                "to another. When enabled, the spline will make a connection from the grab start " +
                                "node, to the grab point node.\n - The Grab Start Node is the first node, or the " +
                                "node just after the visual nodes.\n - The Grab Point Node is the point that will be " +
                                "grabbed and have its movement tracked to maintain the connection from point to point.";
        } 

        protected override void OnFeatureEnabled()
        {
            EnableGrabFeatureAsync().Forget();
        }

        private async UniTaskVoid EnableGrabFeatureAsync()
        {
            await UniTask.WaitUntil(() => LdxTrackingManager.IsValid);
            LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
            grabPointGrabbable.OnGrabEvent += HandleGrabPointGrabbed;
            grabPointGrabbable.OnReleaseEvent += HandleGrabPointReleased;
            await UniTask.WaitUntil(() => controller.InitializationComplete);
            grabbableNodeIndex = CurrentSpline.nodes.Count - 1;
        }

        protected override void OnFeatureDisabled()
        {
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }
            
            grabPointGrabbable.OnGrabEvent -= HandleGrabPointGrabbed;
            grabPointGrabbable.OnReleaseEvent -= HandleGrabPointReleased;
            grabbableMoveSequence?.Kill();
        }

        private void HandleTrackingEvent(string eventId)
        {
            if (eventId == grabPointPositionedEvent)
            {
                GrabPositionedAsync().Forget();
            }
        }

        private async UniTaskVoid GrabPositionedAsync()
        {
            grabPointGrabbable.ForceHandsRelease();
            await UniTask.Yield();
            
            grabPointGrabbable.isGrabbable = false;
            MoveToTargetPosition();
            await UniTask.WaitUntil(IsGrabPositioned);
            
            BroadcastEvent(grabbingCycleCompleteEvent);
        }
        
        private void HandleGrabPointGrabbed(Hand hand, Grabbable grabbableHand)
        {
            isTrackingGrabbed = true;
            TrackGrabbedMovement().Forget();
            BroadcastEvent(grabPointGrabbedEvent);
        }

        private void HandleGrabPointReleased(Hand hand, Grabbable grabbableHand)
        {
            isTrackingGrabbed = false;
        }

        private async UniTaskVoid TrackGrabbedMovement()
        {
            float nextUpdateTime;
            while (isTrackingGrabbed)
            {
                CurrentSpline.nodes[grabbableNodeIndex].Position = controller.GetInversePoint(grabPointNodeTransform);
                if (!canRotateWhenGrabbed)
                {
                    grabPointNodeTransform.rotation = grabStartNodeTransform.rotation;
                }

                CurrentSpline.nodes[^1].Up = grabPointNodeTransform.up;

                nextUpdateTime = Time.time + controller.UpdateSpeed;
                await UniTask.WaitUntil(() => Time.time > nextUpdateTime);
            }
        }

        private void MoveToTargetPosition()
        {
            grabbableMoveSequence?.Kill();
            grabbableMoveSequence = DOTween.Sequence()
                .Append(DOTween.To(() => CurrentSpline.nodes[grabbableNodeIndex].Position,
                    x => CurrentSpline.nodes[grabbableNodeIndex].Position = x,
                    controller.GetInversePoint(grabPointFinalTargetPosition), controller.MovementSpeed))
                .Join(DOTween.To(() => CurrentSpline.nodes[grabbableNodeIndex].Up,
                    x => CurrentSpline.nodes[grabbableNodeIndex].Up = x,
                    grabPointFinalTargetPosition.up, controller.MovementSpeed))
                .SetEase(Ease.InOutSine);
            if (moveGrabPointTransformOnComplete)
            {
                grabbableMoveSequence
                    .Join(grabPointNodeTransform.DOMove(grabPointFinalTargetPosition.position,
                        controller.MovementSpeed))
                    .Join(grabPointNodeTransform.DORotateQuaternion(grabPointFinalTargetPosition.rotation,
                        controller.MovementSpeed));
            }
        }

        private void BroadcastEvent(string eventID)
        {
            LdxTrackingManager.Instance.BroadcastTrackingEvent(eventID);
        }
        
        private bool IsGrabPositioned()
        {
            return (
                controller.GetInversePoint(grabPointFinalTargetPosition) -
                CurrentSpline.nodes[grabbableNodeIndex].Position).sqrMagnitude < 0.01f;
        }

        public override void SetGrabbingReferences(Transform startPoint, Transform grabPoint, Transform finalPosition)
        {
            grabStartNodeTransform = startPoint;
            grabPointNodeTransform = grabPoint;
            grabPointGrabbable = grabPoint.gameObject.GetOrAddComponent<Grabbable>();
            grabPointFinalTargetPosition = finalPosition;
        }
        
        public override Transform GetGrabStartNodeTransform() => grabStartNodeTransform;
        public override Transform GetGrabPointNodeTransform() => grabPointNodeTransform;
        public override Transform GetGrabPointFinalTargetPosition() => grabPointFinalTargetPosition;
        public override Grabbable GetGrabbable() => grabPointGrabbable;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Splines/SplineMasterController/Features/GrabbingSplineFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Splines/SplineMasterController/Features/StaticVisualSplineFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 065c604cc75e60b4c93e110d1add8884
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Features.Splines
{
    [Serializable]
    public class StaticVisualSplineFeature : SplineFeature
    {
        [SerializeField] private Transform[] visualNodeTransforms;
        
        public StaticVisualSplineFeature()
        {
            setupInstructions = "Visual nodes are non-functional nodes that occur at the start of a spline. They are " +
                                "rendered and oriented upon initialization, but do not update their position or " +
                                "direction for the duration of the spline's existence.\n \nNote: The green 'Up' arrow " +
                                "of the reference transforms will correspond to the top of the spline's mesh. You can " +
                                "use this to account for or create bends and curves in the path of the spline.";
        }

        protected override void OnFeatureEnabled() { }

        protected override void OnFeatureDisabled() { }

        public override Transform[] GetVisualNodeTransforms() => visualNodeTransforms;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Splines/SplineMasterController/Features/StaticVisualSplineFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Splines/SplineMasterController/SplineFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 346426621143fe447a2204a4971c89f4
# ASMDEF: ldx.framework.runtime.dll
# ---
using Autohand;
using SplineMesh;
using UnityEngine;

namespace Ldx.Framework.Features.Splines
{
    /// <summary>
    /// Spline Feature Base class that the individual spline features inherit from and contains the types of features
    /// that are available to add as an enum.
    /// </summary>
    [System.Serializable]
    public abstract class SplineFeature
    {
        public enum SplineFeatureType
        {
            StaticVisualSplineFeature,
            AnimationSplineFeature,
            GrabbingSplineFeature
        }

        [SerializeField, TextArea] protected string setupInstructions;
        public string SetupInstructions => setupInstructions;

        protected SplineMasterController controller;
        protected Spline CurrentSpline => controller.CurrentSpline;

        public void EnableFeature(SplineMasterController controller)
        {
            this.controller = controller;
            OnFeatureEnabled();
        }
        
        public void DisableFeature()
        {
            OnFeatureDisabled();   
        }
        
        protected abstract void OnFeatureEnabled();
        protected abstract void OnFeatureDisabled();
        
        // Methods to get the necessary references for each feature
        public virtual Transform[] GetVisualNodeTransforms() => null;
        public virtual Transform[] GetAnimationNodeTransforms() => null;
        public virtual Transform GetGrabStartNodeTransform() => null;
        public virtual Transform GetGrabPointNodeTransform() => null;
        public virtual Transform GetGrabPointFinalTargetPosition() => null;
        public virtual Grabbable GetGrabbable() => null;

        public virtual void SetGrabbingReferences(Transform startPoint, Transform grabPoint, Transform finalPosition)
        {
            
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Splines/SplineMasterController/SplineFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Splines/SplineMasterController/SplineMasterController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ba9d2084413c7174da6b70d423e4bd39
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;
using SplineMesh;
using System.Collections.Generic;
using System.Linq;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Utilities.Extensions;

namespace Ldx.Framework.Features.Splines
{
    /// <summary>
    /// A master spline controller that allows you to add and remove features to adjust the functionality of a spline.
    /// </summary>
    public class SplineMasterController : MonoBehaviour
    {
        private const int VALIDATION_DELAY = 100;
        
        [SerializeField] private Spline currentSpline;
        public Spline CurrentSpline => currentSpline;
        [Tooltip("Low values make for more direct connections from node to node.")]
        [Range(0.001f, 1)]
        [SerializeField] private float curviness = 1f;
        [Tooltip("Used for automated spline movement. Each movement segment takes this amount of time.")]
        [SerializeField] private float movementSpeed = 1f;
        [Tooltip("Use if the reference transforms themselves are going to change position/rotation.")]
        [SerializeField] private bool matchReferencesOnUpdate;
        [Tooltip("The default is the last 2 nodes, but if you need to align from a specific index, set this to a " +
                 "number other than 0.")]
        [SerializeField] private int overrideAlignFromIndex;
        [Tooltip("Used if the end of the spline if connected to an extra visual piece and you want the spline to " +
                 "point towards that piece.")]
        [SerializeField] private Transform overrideEndPointAlignmentTransform;
        [SerializeField] private float updatesPerSecond = 24f;
        public float UpdateSpeed => 1 / updatesPerSecond;
        [SerializeField] private bool alwaysUpdate;

        public float MovementSpeed => movementSpeed;

        [SerializeReference]
        public List<SplineFeature> splineFeatures = new();

        public bool InitializationComplete { get; private set; }

        // Properties for which features are active to dictate what actions to perform
        private bool animationFeatureActive;
        public bool AnimationFeatureActive => animationFeatureActive;
        private bool grabbingActive;
        public bool GrabbingActive => grabbingActive;
        private bool visualsActive;
        public bool VisualsActive => visualsActive;

        public int SplineSizeBeforeAnimation { get; private set; }

        private SplineNode grabStartNode;
        private SplineNode grabPointNode;
        private float timeOfNextUpdate;
        private Vector3 lastNodePreviousPosition;
        private bool initialValidationDone;
        private bool continueUpdates = true;
        private StaticVisualSplineFeature activeStaticVisualSplineFeature;
        private GrabbingSplineFeature activeGrabbingSplineFeature;
        private AnimationSplineFeature activeAnimationSplineFeature;

        #region MonoBehaviourMethods

        private void OnValidate()
        {
            if (!initialValidationDone)
            {
                DelayedValidate().Forget();
            }
            else
            {
                EnsureComponents();
            }
            VerifyFeatureStatus();
        }
        
        private void OnEnable()
        {
            currentSpline.nodes.Clear();
            VerifyFeatureStatus();
            foreach (SplineFeature feature in splineFeatures)
            {
                feature.EnableFeature(this);
            }
            
            if (visualsActive)
            {
                activeStaticVisualSplineFeature = splineFeatures.OfType<StaticVisualSplineFeature>().Single();
            }

            if (grabbingActive)
            {
                activeGrabbingSplineFeature = splineFeatures.OfType<GrabbingSplineFeature>().Single();
            }

            if (animationFeatureActive)
            {
                activeAnimationSplineFeature = splineFeatures.OfType<AnimationSplineFeature>().Single();
            }

            InitializeSpline();
            CheckUpdateSpline().Forget();
        }

        private void OnDisable()
        {
            continueUpdates = false;
            foreach (SplineFeature feature in splineFeatures)
            {
                feature.DisableFeature();
            }
        }

        #endregion

        #region EditorAndSetupFunctionality

        public SplineFeature AddFeature(SplineFeature.SplineFeatureType featureType)
        {
            SplineFeature feature = CreateFeature(featureType);
            if (feature != null)
            {
                splineFeatures.Add(feature);
                VerifyFeatureStatus();
                MarkDirty();
            }

            return feature;
        }

        public async UniTaskVoid RemoveFeature(SplineFeature feature)
        {
            splineFeatures.Remove(feature);
            await UniTask.Yield();
            VerifyFeatureStatus();
            MarkDirty();
        }

        public void VerifyFeatureStatus()
        {
            // Sanitize the splineFeatures list to remove duplicates
            HashSet<Type> uniqueFeatures = new();
            splineFeatures = splineFeatures.Where(feature => uniqueFeatures.Add(feature.GetType())).ToList();

            // Update the booleans based on the sanitized feature list
            animationFeatureActive = splineFeatures.OfType<AnimationSplineFeature>().Any();
            grabbingActive = splineFeatures.OfType<GrabbingSplineFeature>().Any();
            visualsActive = splineFeatures.OfType<StaticVisualSplineFeature>().Any();
        }

        private static SplineFeature CreateFeature(SplineFeature.SplineFeatureType featureType)
        {
            return featureType switch
            {
                SplineFeature.SplineFeatureType.StaticVisualSplineFeature => new StaticVisualSplineFeature(),
                SplineFeature.SplineFeatureType.AnimationSplineFeature => new AnimationSplineFeature(),
                SplineFeature.SplineFeatureType.GrabbingSplineFeature => new GrabbingSplineFeature(),
                _ => null
            };
        }

        private void MarkDirty()
        {
#if UNITY_EDITOR
            UnityEditor.EditorUtility.SetDirty(this);
#endif
        }

        private async UniTaskVoid DelayedValidate()
        {
            await UniTask.Delay(VALIDATION_DELAY);
            if (this == null)
            {
                return;
            }
            EnsureComponents();
            initialValidationDone = true;
        }

        private void EnsureComponents()
        {
            currentSpline = gameObject.GetOrAddComponent<Spline>();
            gameObject.GetOrAddComponent<SplineMeshTiling>();
        }

        #endregion

        #region SplineFunctionalMethods

        private void InitializeSpline()
        {
            currentSpline.nodes.Clear();
            
            // Add visual nodes if visuals are active
            if (visualsActive)
            {
                foreach (Transform t in activeStaticVisualSplineFeature!.GetVisualNodeTransforms())
                {
                    currentSpline.nodes.Add(new SplineNode(GetInversePoint(t), Vector3.zero)
                    {
                        Up = t.up
                    });
                }
            }

            // Add grabbing nodes if grabbing is active
            if (grabbingActive)
            {
                Vector3 grabStartPoint = GetInversePoint(activeGrabbingSplineFeature.GetGrabStartNodeTransform());
                grabStartNode = new SplineNode(grabStartPoint, grabStartPoint)
                {
                    Up = activeGrabbingSplineFeature.GetGrabStartNodeTransform().up
                };
                Vector3 grabbablePoint = GetInversePoint(activeGrabbingSplineFeature.GetGrabPointNodeTransform());
                grabPointNode = new SplineNode(grabbablePoint, grabbablePoint)
                {
                    Up = activeGrabbingSplineFeature.GetGrabPointNodeTransform().up
                };
                currentSpline.nodes.Add(grabStartNode);
                currentSpline.nodes.Add(grabPointNode);
            }

            SplineSizeBeforeAnimation = currentSpline.nodes.Count;
            RefreshSplineFrom(0);
            InitializationComplete = true;
        }

        public void ForceRefreshFrom(int startIndex)
        {
            RefreshSplineFrom(startIndex);
        }

        private void RefreshSplineFrom(int startIndex)
        {
            if (overrideAlignFromIndex > 0)
            {
                startIndex = overrideAlignFromIndex;
            }
            
            AlignDirectionFrom(startIndex);
            if (matchReferencesOnUpdate)
            {
                MatchReferencesOnUpdate();
            }
            
            currentSpline.RefreshCurves();
        }

        private void MatchReferencesOnUpdate()
        {
            int grabStartIndex = 0;
            if (visualsActive)
            {
                Transform[] visualTransforms = activeStaticVisualSplineFeature.GetVisualNodeTransforms();
                grabStartIndex = visualTransforms.Length;
                for (int  i = 0;  i < grabStartIndex;  i++)
                {
                    currentSpline.nodes[i].Position = GetInversePoint(visualTransforms[i]);
                    currentSpline.nodes[i].Up = visualTransforms[i].up;
                }
            }

            if (grabbingActive)
            {
                Transform startNode = activeGrabbingSplineFeature.GetGrabStartNodeTransform();
                Transform grabNode = activeGrabbingSplineFeature.GetGrabPointNodeTransform();
                currentSpline.nodes[grabStartIndex].Position = GetInversePoint(startNode);
                currentSpline.nodes[grabStartIndex].Up = startNode.up;
                currentSpline.nodes[grabStartIndex + 1].Position = GetInversePoint(grabNode);
                currentSpline.nodes[grabStartIndex + 1].Up = grabNode.up;
            }

            if (animationFeatureActive)
            {
                Transform[] animationTransforms 
                    = activeAnimationSplineFeature.GetAnimationNodeTransforms();
                for (int  i = 0;  i < animationTransforms.Length;  i++)
                {
                    currentSpline.nodes[i].Position = GetInversePoint(animationTransforms[i]);
                    currentSpline.nodes[^(animationTransforms.Length - i)].Up = animationTransforms[i].up;
                }
            }
        }
        
        private void AlignDirectionFrom(int startIndex)
        {
            for (int i = startIndex; i < currentSpline.nodes.Count; i++)
            {
                if (i == 0)
                {
                    currentSpline.nodes[0].Direction = scaleDirection(currentSpline.nodes[0], alignFirstNode(currentSpline.nodes[0], currentSpline.nodes[1]));
                }
                else if (i == currentSpline.nodes.Count - 1)
                {
                    if (overrideEndPointAlignmentTransform != null)
                    {
                        currentSpline.nodes[i].Direction = scaleDirection(currentSpline.nodes[i],
                            overrideEndPointAlignment(
                                currentSpline.nodes[^1],
                                overrideEndPointAlignmentTransform));
                    } 
                    currentSpline.nodes[i].Direction = scaleDirection(currentSpline.nodes[i], alignLastNode(currentSpline.nodes[i - 1], currentSpline.nodes[i]));
                }
                else
                {
                    currentSpline.nodes[i].Direction = scaleDirection(currentSpline.nodes[i], alignMiddleNode(
                        currentSpline.nodes[i - 1], 
                        currentSpline.nodes[i], 
                        currentSpline.nodes[i + 1]));
                }
            }
            return;

            Vector3 scaleDirection(SplineNode node, Vector3 direction)
            {
                return Vector3.Lerp(node.Position, direction, curviness);
            }

            Vector3 alignFirstNode(SplineNode nodeToAlign, SplineNode nextNode)
            {
                // Direction from this end of the spline to the next node
                return (nodeToAlign.Position + nextNode.Position) / 2.0f;
            }
            
            Vector3 alignLastNode(SplineNode previousNode, SplineNode nodeToAlign)
            {
                Vector3 dPrevious = (previousNode.Position + nodeToAlign.Position) / 2.0f;
                return nodeToAlign.Position + (dPrevious - previousNode.Position);
            }
            
            Vector3 alignMiddleNode(SplineNode previousNode, SplineNode nodeToAlign, SplineNode nextNode)
            {
                Vector3 dPrevious = (previousNode.Position + nodeToAlign.Position) / 2.0f;
                Vector3 directionFromPrevious = nodeToAlign.Position + (dPrevious - previousNode.Position);
                Vector3 directionToNext = (nodeToAlign.Position + nextNode.Position) / 2.0f;
                
                // Get the weighted average of the two vectors with more weight being assigned to the shorter distance
                float previousMagnitude = directionFromPrevious.magnitude;
                float nextMagnitude = directionToNext.magnitude;
                float total = previousMagnitude + nextMagnitude;
                return directionFromPrevious * nextMagnitude / total + 
                       directionToNext * previousMagnitude / total;
            }

            // Provides a strong bias to align with the last point
            Vector3 overrideEndPointAlignment(SplineNode nodeToAlign,
                Transform overrideTransform)
            {
                Vector3 directionToNext = (nodeToAlign.Position + GetInversePoint(overrideTransform)) / 2.0f;
                
                return directionToNext;
            }
        }
        
        private async UniTaskVoid CheckUpdateSpline()
        {
            float nextUpdateTime;
            while (continueUpdates)
            {
                if (!alwaysUpdate && currentSpline.nodes[^1].Position == lastNodePreviousPosition)
                {
                    await UniTask.Delay(UpdateSpeed.ToMilliseconds());
                    continue;
                }
            
                RefreshSplineFrom(GetRefreshStartIndex());
                lastNodePreviousPosition = currentSpline.nodes[^1].Position;
                nextUpdateTime = Time.time + UpdateSpeed;
                await UniTask.WaitUntil(() => Time.time > nextUpdateTime);
            }
        }
        
        #endregion

        #region HelperMethods

        public Vector3 GetInversePoint(Transform t)
        {
            return transform.InverseTransformPoint(t.position);
        }
        
        private int GetRefreshStartIndex()
        {
            return currentSpline.nodes.Count > 2 
                ? currentSpline.nodes.Count - 2
                : 0;
        }

        public void SetGrabStart(Transform t)
        {
            activeGrabbingSplineFeature.GrabStartNodeTransform = t;
        }

        public Transform GetGrabStart()
        {
            return activeGrabbingSplineFeature.GrabStartNodeTransform;
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Splines/SplineMasterController/SplineMasterController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Timer/LdxTimer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1dc23ac508f79614c8b068a8a6ada49a
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using UnityEngine.Events;

namespace Ldx.Framework.Features.Timer
{
    [TrackedReference]
    public class LdxTimer : MonoBehaviour
    {
        #region Events

        public UnityEvent OnTimerStarted;
        public UnityEvent OnTimerStopped;
        public UnityEvent OnTimerFinished;
        public UnityEvent<float> OnTimerTicked;

		#endregion

		#region Fields and Properties

		[SerializeField]
        private CountMode countMode = CountMode.Down;

        [Space]
        [SerializeField]
        private float startTime;
        [SerializeField]
        private float stopTime;

        private float currentTick = 0;
        private float tickInterval = 1;

        private float itsTimeToStop;

        private float time;

        public float Time
        {
            get
            {
                if (countMode == CountMode.Up)
                {
                    return startTime + time;
                }
                else
                {
                    return startTime - time;
                }
            }
        }
        public bool IsStopped { get; private set; } = true;

        [Space]
        public bool startImmediately = true;
        public bool UseDebug;
        //[ReadOnly]
        public float currentTime;

		#endregion

		private void Start()
		{
            if (startImmediately)
            {
				StartTimer();
			}

            LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
        }

        private void HandleObjectiveEvent(IObjective arg1, ObjectiveEventData eventData)
        {
            if (eventData is TimerActionEventData actionData)
            {
                switch (actionData.TimerEvent)
                {
                    case TimerActionEventData.ActionType.Start:
                        FinishTimer();
                        SetUpTimer(actionData.CountMode, actionData.StartTime, actionData.StopTime);
                        StartTimer();
                        break;
                    case TimerActionEventData.ActionType.Pause:
                        StopTimer();
                        break;
                    case TimerActionEventData.ActionType.Resume:
                        ResumeTimer();
                        break;
                    case TimerActionEventData.ActionType.Finish:
                        FinishTimer();
                        break;
                }
                return;
            }
        }

        private void Update()
        {
            if (IsStopped)
                return;

            currentTick += UnityEngine.Time.deltaTime;

            if (currentTick > tickInterval)
                AddTick();

            if (UseDebug)
                currentTime = time;
        }

        public void SetUpTimer(CountMode countMode, float startTime, float stopTime, bool startImmediately = false)
        {
            this.countMode = countMode;
            this.startTime = startTime;
            this.stopTime = stopTime;
            this.startImmediately = startImmediately;
        }

        public void StartTimer()
        {
            if ((startTime > stopTime && countMode == CountMode.Up) || (startTime <= stopTime && countMode == CountMode.Down) || startTime < 0 || stopTime < 0)
            {
                Debug.LogError("Can't start timer");
                return;
            }

            time = 0;
            itsTimeToStop = countMode == CountMode.Up ? stopTime - startTime : startTime - stopTime;

            if (startTime == stopTime && countMode == CountMode.Up)
                itsTimeToStop = Mathf.Infinity;

            OnTimerStarted?.Invoke();
            IsStopped = false;
        }

        public void StopTimer()
        {
            OnTimerStopped?.Invoke();
            IsStopped = true;
        }

        public void ResumeTimer()
        {
            IsStopped = false;
        }

        public void FinishTimer()
        {
            IsStopped = true;
            OnTimerFinished?.Invoke();
            time = 0;
        }

        private void AddTick()
        {
            time += currentTick;
            currentTick = 0;

            OnTimerTicked?.Invoke(time);

            if (time >= itsTimeToStop)
            {
                IsStopped = true;
                time = 0;
                OnTimerFinished?.Invoke();
            }
        }
    }

    public enum CountMode
    {
        Up,
        Down
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Timer/LdxTimer.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Tutorial/TutorialControllerGhost.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2730353abfc7466aa87374bd2df89e87
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Features.Tutorial
{
    public class TutorialControllerGhost : MonoBehaviour
    {
        readonly static private int IsTriggerDown = Animator.StringToHash("IsTriggerDown");
        readonly static private int IsGripDown = Animator.StringToHash("IsGripDown");
        
        [SerializeField] private Animator controllerAnimator;
        
        private void OnValidate()
        {
            if (controllerAnimator == null)
            {
                controllerAnimator = GetComponent<Animator>();
            }
        }

        public void ToggleTrigger(ControllerButton type, bool isPressed)
        {
            switch (type)
            {
                case ControllerButton.Trigger:
                    SetTrigger(isPressed);
                    break;
                case ControllerButton.Grip:
                    SetGrip(isPressed);
                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(type), type, null);
            }
        }
        
        public void SetTrigger(bool isTriggerPressed)
        {
            controllerAnimator.SetBool(IsTriggerDown, isTriggerPressed);
        }
        
        public void SetGrip(bool isGripPressed)
        {
            controllerAnimator.SetBool(IsGripDown, isGripPressed);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Tutorial/TutorialControllerGhost.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Tutorial/TutorialControllerHand.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: debffe8d07174402b6231f3d9022b5cb
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Threading;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using HighlightPlus;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.UI.Modules.Tooltip;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;
using UnityEngine.Serialization;

namespace Ldx.Framework.Features.Tutorial
{
    public enum ControllerButton
    {
        Trigger,
        Grip
    }
    
    public class TutorialControllerHand : MonoBehaviour
    {
        private const float AFTER_SHOW_DELAY = 0.75f;
        private const float AFTER_TOOLTIP_ANIMATION_DELAY = 1f;
        private const float AFTER_ANIMATION_TRIGGER_DELAY = 1f;
        private const float HIGHLIGHT_SCALE_FACTOR = 1.2f;
        private const float HIGHLIGHT_SCALE_DURATION = 0.75f;
        
        [Header("Listen to:")]
        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string showTutorialHandWithController;
        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string hideTutorialHandWithController;
        
        [FormerlySerializedAs("ghostHand")]
        [Header("Params:")]
        [Space]
        [SerializeField] private TutorialHandGhost tutorialHandGhost;
        [FormerlySerializedAs("ghostController")]
        [SerializeField] private TutorialControllerGhost ghostControllerGhost;
        [SerializeField] private bool disableOnAwake = true;
        [SerializeField] private ControllerButton controllerButton = ControllerButton.Trigger;
        [SerializeField] private bool showTooltip = true;
        [SerializeField] private ObjectTooltip tooltip;

        [SerializeField]
        private SerializableDictionary<ControllerButton, HighlightEffect> buttonHighlightEffectMap = new();

        [Header("Animation:")]
        [Space]
        [SerializeField] private bool moveVertically = true;
        [SerializeField] private float verticalOffset = 0.05f;
        [SerializeField] private float duration = 4f;
        [SerializeField] private Ease movingEase = Ease.InOutQuad;

        [Header("Audio: ")]
        [SerializeField] private AudioSource audioSource;
        [SerializeField] private AudioClip showTutorialHandSound;
        [SerializeField] private AudioClip hideTutorialHandSound;

        private CancellationTokenSource cts;
        private Tween movementTween;
        private Tween showHideTween;
        private HighlightEffect highlightEffect;
        private float originalScale;
        private float pressedScale;
        private Tween highlightScaleTween;

        private void Awake()
        {
            if (disableOnAwake)
            {
                HideTutorialHand(true);
            }

            foreach ((ControllerButton button, HighlightEffect h) in buttonHighlightEffectMap)
            {
                if (button == controllerButton)
                {
                    highlightEffect = h;
                    originalScale = highlightEffect.transform.localScale.x;
                    pressedScale = originalScale * HIGHLIGHT_SCALE_FACTOR;
                }
                h.highlighted = false;
            }
        }

        private void Start() 
        {
            LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
        }

        private void OnDestroy()
        {
            showHideTween?.Kill();
            movementTween?.Kill();
            cts.SafeCancelAndDispose();
            
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }
        }

        private void HandleTrackingEvent(string id)
        {
            if (id == showTutorialHandWithController)
            {
                cts.SafeCancelAndDispose();
                cts = new CancellationTokenSource();
                ShowTutorialHandAsync(cts.Token).Forget();
            }
            else if (id == hideTutorialHandWithController)
            {
                HideTutorialHand();
            }
        }

        private async UniTask ShowTutorialHandAsync(CancellationToken token)
        {
            ShowTutorialHand();
            audioSource.PlayOneShot(showTutorialHandSound);
            await UniTask.Delay(AFTER_SHOW_DELAY.ToMilliseconds(), cancellationToken: token);
            
            if (highlightEffect != null)
            {
                ScaleButtonHighlight(false, true);
                highlightEffect.SetHighlighted(true);
            }

            if (showTooltip && tooltip != null)
            {
                tooltip.ShowTooltip();
                await UniTask.Delay(AFTER_TOOLTIP_ANIMATION_DELAY.ToMilliseconds(), cancellationToken: token);
            }

            StartMovementTween();
            RepeatAnimationAsync(token).Forget();
        }

        private async UniTask RepeatAnimationAsync(CancellationToken token)
        {
            bool isTriggering = true;
            while (token is { IsCancellationRequested: false })
            {
                ScaleButtonHighlight(isTriggering);
                tutorialHandGhost.ToggleTrigger(controllerButton, isTriggering);
                ghostControllerGhost.ToggleTrigger(controllerButton, isTriggering);
                isTriggering = !isTriggering;
                await UniTask.Delay(AFTER_ANIMATION_TRIGGER_DELAY.ToMilliseconds(), cancellationToken: token);
            }
        }
        
        private void ShowTutorialHand()
        {
            transform.localScale = Vector3.zero;
            SetObjectsActive(true);
            showHideTween?.Kill();
            showHideTween = transform.DOScale(1, 0.5f)
                .SetEase(Ease.InOutQuad);
        }

        private void HideTutorialHand(bool instant = false)
        {
            movementTween?.Kill();
            cts.SafeCancelAndDispose();

            if (highlightEffect != null)
            {
                highlightEffect.SetHighlighted(false);
            }

            if (showTooltip && tooltip != null)
            {
                tooltip.HideTooltip();
            }

            if (instant)
            {
                SetObjectsActive(false);
                transform.localScale = Vector3.zero;
                return;
            }
          
            audioSource.PlayOneShot(hideTutorialHandSound);
            showHideTween?.Kill();
            showHideTween = transform.DOScale(0, 0.5f)
                .SetEase(Ease.InOutQuad).OnComplete(() => SetObjectsActive(false));
        }

        private void SetObjectsActive(bool setActive)
        {
            tutorialHandGhost.gameObject.SetActive(setActive);
            ghostControllerGhost.gameObject.SetActive(setActive);
        }

        private void StartMovementTween()
        {
            if (!moveVertically)
            {
                return;
            }
            
            movementTween?.Kill();
            float currentY = transform.position.y;
            movementTween = DOTween.Sequence()
                .Append(transform.DOMoveY(currentY + verticalOffset, duration).SetEase(movingEase))
                .Append(transform.DOMoveY(currentY, duration).SetEase(movingEase))
                .SetLoops(-1);
        }

        private void ScaleButtonHighlight(bool isPressed, bool instant = false)
        {
            if (highlightEffect == null)
            {
                return;
            }
            
            highlightScaleTween?.Kill();
            highlightScaleTween = highlightEffect.transform
                .DOScale(isPressed ? pressedScale : originalScale, instant ? 0 : HIGHLIGHT_SCALE_DURATION)
                .SetEase(Ease.InOutQuad);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Tutorial/TutorialControllerHand.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Tutorial/TutorialHandGhost.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2773cc24125e4090a1a1d7577e989393
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Features.Tutorial
{
    public class TutorialHandGhost : MonoBehaviour
    {
        readonly static private int IsTriggerDown = Animator.StringToHash("IsTriggerDown");
        readonly static private int IsGripDown = Animator.StringToHash("IsGripDown");
        
        [SerializeField] private Animator controllerAnimator;
        
        private void OnValidate()
        {
            if (controllerAnimator == null)
            {
                controllerAnimator = GetComponent<Animator>();
            }
        }
        
        public void ToggleTrigger(ControllerButton type, bool isPressed)
        {
            switch (type)
            {
                case ControllerButton.Trigger:
                    SetTrigger(isPressed);
                    break;
                case ControllerButton.Grip:
                    SetGrip(isPressed);
                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(type), type, null);
            }
        }

        public void SetTrigger(bool isTriggerPressed)
        {
            controllerAnimator.SetBool(IsTriggerDown, isTriggerPressed);
        }
        
        public void SetGrip(bool isGripPressed)
        {
            controllerAnimator.SetBool(IsGripDown, isGripPressed);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Tutorial/TutorialHandGhost.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Visual/ChangeMaterialOnEvent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7693153b8dcd2484eb85de984b4c21d2
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Features.Visual
{
    /// <summary>
    /// Swaps a renderer's material when specific tracking events occur.
    /// One event applies a new material, another reverts back to the original.
    /// </summary>
    public class ChangeMaterialOnEvent : MonoBehaviour
    {
        [Header("Tracking Events")]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string applyEventId;

        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string revertEventId;

        [Header("Material Settings")]
        [SerializeField] private Material newMaterial;
        [SerializeField] private Renderer targetRenderer;
        private Material originalMaterial;

        private void OnValidate()
        {
            if (targetRenderer == null && TryGetComponent(out Renderer foundRenderer))
                targetRenderer = foundRenderer;
        }

        private void Awake()
        {
            if (targetRenderer && targetRenderer.sharedMaterial)
            {
                originalMaterial = targetRenderer.sharedMaterial;
            }
        }

        private void Start()
        {
            LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
        }

        private void OnDestroy()
        {
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }
        }

        private void HandleTrackingEvent(string eventId)
        {
            if (!targetRenderer)
                return;

            if (eventId == applyEventId && newMaterial)
            {
                targetRenderer.material = newMaterial;
            }
            else if (eventId == revertEventId && originalMaterial)
            {
                targetRenderer.material = originalMaterial;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Visual/ChangeMaterialOnEvent.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Visual/FadeEffect/FadeEffect.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d66db0857b97a5747a7726816d7f75a1
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using BrewedInk.MarkdownSupport.Markdown;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Features.Visual.FadeEffect
{
    /// <summary>
    /// Controls a fade effect applied to the object's materials, fading them in or out over time.
    /// Optionally plays sound effects during fade transitions and supports custom fade sounds.
    /// </summary>
    [DisallowMultipleComponent]
    public class FadeEffect : MonoBehaviour
    {
        public Action<FadeEffect> OnFadeInCompleted;
        public Action<FadeEffect> OnFadeOutCompleted;
        
        private const float FADE_VALUE_OFF = 0f;
        private const float FADE_VALUE_ON = 1f;
        private const float AUDIO_DELAY = 0.25f;
        private static readonly int FadeValue = Shader.PropertyToID("_FadeValue");
    
        [MarkdownSnippet("Requirements", RelativeMarkdownFile = "FadeEffect.markdown")]
        [SerializeField] private Renderer[] renderers;
        [SerializeField] private float duration = 2f;
        [SerializeField] private bool fadeOnEnable = true;
        [SerializeField] private bool fadeOnDisable = true;
        [SerializeField] private bool fadeOnFirstEnable = false;
        [SerializeField] private bool fadeOnFirstDisable = false;
        
        [Header("Sounds")]
        [MarkdownSnippet(InlineMarkdown = "These sounds will override the default sound effects in " +
                                          "`Edit/ProjectSettings/AudioGlobalSettings`: \n" +
                                          "- Object Fade In Effect Sound \n" +
                                          "- Object Fade Out Effect Sound", WithoutFoldout = true)]
        [SerializeField][SoundReference]
        private string overrideFadeInSound;
        [SerializeField][SoundReference]
        private string overrideFadeOutSound;
    
        private readonly List<Material> materials = new List<Material>();
        private bool blockFadeOnEnable;
        private Sequence fadeTween;
        private bool passedFirstEnable; 
        private bool passedFirstDisable; 
        
        private static SoundInstance fadeInSoundInstanceDefault;
        private static SoundInstance fadeOutSoundInstanceDefault;
    
        private void OnValidate()
        {
            renderers ??= GetComponentsInChildren<Renderer>();
        }

        private void Start()
        {
            fadeInSoundInstanceDefault ??= Audio.CreateSoundInstance(AudioGlobalSettings.ObjectFadeInEffectSound);
            fadeOutSoundInstanceDefault ??= Audio.CreateSoundInstance(AudioGlobalSettings.ObjectFadeOutEffectSound);
        }

        private void OnDestroy()
        {
            foreach (Material material in materials)
            {
                Destroy(material);
            }
            fadeTween?.Kill();
        }

        /// <summary>
        /// Assigns new instances of materials to the objects renderers, preparing them for fade transitions.
        /// </summary>
        private void AssignMaterials()
        {
            if (materials.Count > 0 || renderers == null)
            {
                return;
            }

            foreach (Renderer rend in renderers)
            {
                List<Material> sharedMaterials = rend.sharedMaterials.ToList();
                for (int i = 0; i < sharedMaterials.Count; i++)
                {
                    sharedMaterials[i] = Instantiate(sharedMaterials[i]);
                }
            
                rend.SetMaterials(sharedMaterials);
                materials.AddRange(sharedMaterials);
            }
        }

        /// <summary>
        /// Plays the fade-in effect when the object is enabled, if enabled and not blocked.
        /// </summary>
        private async void OnEnable()
        {
            if (fadeOnFirstEnable)
            {
                passedFirstEnable = true;
            }
            
            if (!fadeOnEnable || blockFadeOnEnable || !passedFirstEnable)
            {
                passedFirstEnable = true;
                return;
            }

            await UniTask.Yield();
            await PlayFadeInEffectAsync();
        }

        /// <summary>
        /// Plays the fade-in effect asynchronously.
        /// </summary>
        public async UniTask PlayFadeInEffectAsync()
        {
            await FadeInAsync();
            OnFadeInCompleted?.Invoke(this);
        }

        /// <summary>
        /// Plays the fade-out effect when the object is disabled, if enabled and not blocked.
        /// </summary>
        private void OnDisable()
        {
            if (fadeOnFirstDisable)
            {
                passedFirstDisable = true;
            }
            
            if (!fadeOnDisable || !passedFirstDisable)
            {
                passedFirstDisable = true;
                return;
            }
        
            if (blockFadeOnEnable)
            {
                blockFadeOnEnable = false;
            }
            else
            {
                if (Application.isPlaying)
                {
                    DisableFadeAsync().Forget();
                }
            }
        }

        /// <summary>
        /// Asynchronously plays the fade-out effect and disables the object once completed.
        /// </summary>
        private async UniTask DisableFadeAsync()
        {
            await UniTask.Yield();
            blockFadeOnEnable = true;

            if (this == null || gameObject == null)
            {
                return;
            }
            
            gameObject.SetActive(true);
            await FadeOutAsync();
            await UniTask.Yield();
            OnFadeOutCompleted?.Invoke(this);
            
            if (this == null || gameObject == null)
            {
                return;
            }
            
            gameObject.SetActive(false);
        }

        public async UniTask FadeInAsync(CancellationTokenSource cts = null) => await FadeAsync(FADE_VALUE_OFF, FADE_VALUE_ON, PlayFadeInSound, cts);
        
        public async UniTask FadeOutAsync(CancellationTokenSource cts = null) => await FadeAsync(FADE_VALUE_ON, FADE_VALUE_OFF, PlayFadeOutSound, cts);
    
        /// <summary>
        /// Handles the fade animation asynchronously between two values, optionally playing a sound during the effect.
        /// </summary>
        /// <param name="startValue">The starting fade value.</param>
        /// <param name="endValue">The ending fade value.</param>
        /// <param name="soundCallback">Optional sound callback to invoke during the fade.</param>
        /// <param name="cts">Optional cancellation token.</param>
        private async UniTask FadeAsync(float startValue, float endValue, Action soundCallback = null, CancellationTokenSource cts = null)
        {
            AssignMaterials();
            fadeTween?.Kill();
            fadeTween = DOTween.Sequence();

#pragma warning disable CS4014
            foreach (Material material in materials)
            {
                fadeTween
                    .InsertCallback(0, () => material.SetFloat(FadeValue, startValue))
                    .Join(material.DOFloat(endValue, FadeValue, duration))
                    .InsertCallback(AUDIO_DELAY, () => soundCallback?.Invoke());
            }
            
#pragma warning restore CS4014

            if (cts == null)
            {
                await fadeTween;
            }
            else
            {
                await fadeTween.WithCancellation(cts.Token);
            }
        }

        /// <summary>
        /// Plays the fade-in sound, using the override sound if provided, otherwise the default sound.
        /// </summary>
        private void PlayFadeInSound()
        {
            if (string.IsNullOrEmpty(overrideFadeInSound))
            {
                if (!fadeInSoundInstanceDefault.IsPlaying)
                {
                    fadeInSoundInstanceDefault.Play();
                }
            }
            else
            {
                Audio.PlayOneShot(overrideFadeInSound);
            }
        }
        
        /// <summary>
        /// Plays the fade-out sound, using the override sound if provided, otherwise the default sound.
        /// </summary>
        private void PlayFadeOutSound()
        {
            if (string.IsNullOrEmpty(overrideFadeOutSound))
            {
                if (!fadeOutSoundInstanceDefault.IsPlaying)
                {
                    fadeOutSoundInstanceDefault.Play();
                }
            }
            else
            {
                Audio.PlayOneShot(overrideFadeOutSound);
            }
        }

#if UNITY_EDITOR
        
        [ContextMenu("Test fade in")]
        public void EDITOR_TestFadeIn()
        {
#pragma warning disable CS4014
            FadeInAsync();
#pragma warning restore CS4014
        }
        
        [ContextMenu("Test fade out")]
        public void EDITOR_TestFadeOut()
        {
#pragma warning disable CS4014
            FadeOutAsync();
#pragma warning restore CS4014
        }
        
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Visual/FadeEffect/FadeEffect.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Visual/FadeEffect/HighlightPulseEffect.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 41fbfe8c175849d4a1f2f2157cdb7d8a
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Features.Visual.FadeEffect
{
    [DisallowMultipleComponent]
    public class HighlightPulseEffect : MonoBehaviour
    {
        private static readonly int UseHighlight = Shader.PropertyToID("_UseHighlighting");

        public event Action<HighlightPulseEffect, bool> OnEffectStateChanged;
        
        [SerializeField] private Renderer[] renderers;
        [SerializeField] private bool setUseHighlightValueOnStart = false;
        
        [Header("Events to listen to:")]
        [SerializeField][IDSelection(LdxIdSettings.IdType.TrackingEvent)] 
        private string activateEffectEvent;
        [SerializeField][IDSelection(LdxIdSettings.IdType.TrackingEvent)] 
        private string deactivateEffectEvent;
        
        private readonly List<Material> materials = new List<Material>();

        private void OnValidate()
        {
            renderers ??= GetComponentsInChildren<Renderer>();
        }

        private void Start()
        {
            AssignMaterials();
            if (setUseHighlightValueOnStart)
            {
                SetUseHighlight(true);
            }
            
            if (!string.IsNullOrEmpty(activateEffectEvent) || !string.IsNullOrEmpty(deactivateEffectEvent))
            {
                LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
            }
        }
        
        private void OnDestroy()
        {
            foreach (Material material in materials)
            {
                Destroy(material);
            }
            
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }
        }
        
        /// <summary>
        /// Assigns new instances of materials to the objects renderers, preparing them for fade transitions.
        /// </summary>
        private void AssignMaterials()
        {
            if (materials.Count > 0 || renderers == null)
            {
                return;
            }

            foreach (Renderer rend in renderers)
            {
                List<Material> sharedMaterials = rend.sharedMaterials.ToList();
                for (int i = 0; i < sharedMaterials.Count; i++)
                {
                    sharedMaterials[i] = Instantiate(sharedMaterials[i]);
                }
            
                rend.SetMaterials(sharedMaterials);
                materials.AddRange(sharedMaterials);
            }
        }
        
        private void HandleTrackingEvent(string id)
        {
            if (id == activateEffectEvent)
            {
                SetUseHighlight(true);
            }

            if (id == deactivateEffectEvent)
            {
                SetUseHighlight(false);
            }
        }

        public void SetUseHighlight(bool use)
        {
            OnEffectStateChanged?.Invoke(this, use);
            foreach (Material material in materials)
            {
                material.SetFloat(UseHighlight, use ? 1 : 0);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Visual/FadeEffect/HighlightPulseEffect.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Visual/ScaleOnEnable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1807756c4fa5b734da0662b561f4e289
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Features.Visual
{
	public class ScaleOnEnable : MonoBehaviour
	{
		[SerializeField] private Vector3 scaleFrom = Vector3.zero;
		[SerializeField] private Vector3 scaleTo = Vector3.one;
		[SerializeField] private float scaleTimeSeconds = 0.3f;
		[SerializeField] private float delay = 0;
		[Space, Tooltip("Change this curve to adjust the rate of scaling over time. Ensure time ranges from 0 to 1")]
		[SerializeField] private AnimationCurve smoothCurve = AnimationCurve.Linear(0, 0, 1, 1);

		float curScaleTime;

		private void OnEnable()
		{
			// By setting the scale as -delay, we force the lerp in Update to clamp the scale to scaleFrom until it reaches 0
			curScaleTime = -delay;
		}

		private void OnDisable()
		{
			transform.localScale = scaleFrom;
			curScaleTime = 0;
		}

		private void Update()
		{
			if (curScaleTime < scaleTimeSeconds)
			{
				curScaleTime += Time.deltaTime;

				if (curScaleTime < scaleTimeSeconds)
				{
					transform.localScale = Vector3.Lerp(scaleFrom, scaleTo,
						smoothCurve.Evaluate(curScaleTime / scaleTimeSeconds));
				}
				else
				{
					transform.localScale = scaleTo;
				}
			}
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Visual/ScaleOnEnable.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Visual/Tweening/ObjectTweener.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 44c4f097d479404481796730f2173a8b
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Features.Interaction;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Features.Visual.Tweening
{
    public interface IAnimationPlayble
    {
        event Action<IAnimationPlayble> OnFinishedPlaying;
        void Play();
        void Stop();
    }
    
    /// <summary>
    /// Animate objects by tweening, resulting in playing/looping 3D animations  
    /// </summary>
    public class ObjectTweener : MonoBehaviour, IAnimationPlayble
    {
        public event Action<IAnimationPlayble> OnFinishedPlaying;

        [Header("Events")]
        [SerializeField]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string playEvent;
        [SerializeField]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string stopEvent;
        [SerializeField]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string completedEventInvoke;

        [Header("Tween Properties")] 
        [SerializeField] private string label;
        [SerializeField] private bool playOnAwake = true;
        [SerializeField] private bool loop = true;
        public bool Loop => loop;
        [SerializeField] private bool playInReverse;

        [SerializableContainer("Step", startCountingFrom1: true)] [SerializeField]
        private TweenStepsContainer tweenSteps = new();

        private Dictionary<Transform, TransformValuesCache> transformToCacheValueMap = new();

        public int? CurrentIndex { get; private set; }
        public int LastIndex => tweenSteps.Count - 1;
        private int PlayedTweens { get; set; }
        private TweenStep ActiveTweenStep => CurrentIndex != null ? tweenSteps[CurrentIndex.Value] : null;

        public bool IsPlaying { get; private set; }

        private void Awake()
        {
            Initialize();
            if (playOnAwake)
            {
                Play();
            }
        }

        private void Start()
        {
            if (CheckPlayOrStopEventsAssigned() && LdxTrackingManager.Instance != null)
            {
                LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
            }
        }

        private void OnEnable()
        {
            if (playOnAwake)
            {
                Play();
            }
        }

        private void OnDisable()
        {
            Stop();
            ResetAllTweens();
        }

        private void OnDestroy()
        {
            Terminate();
            if (CheckPlayOrStopEventsAssigned() && LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }
        }

        public void Initialize()
        {
            CurrentIndex = null;
            
            foreach (TweenStep group in tweenSteps)
            {
                group.OnCompleted += HandleTweenGroupCompleted;
                foreach (TweenOperation tween in group)
                {
                    if (transformToCacheValueMap.ContainsKey(tween.TargetTransform))
                    {
                        continue;
                    }

                    recordTransformResetCache(tween.TargetTransform);
                }
            }

            void recordTransformResetCache(Transform t)
            {
                transformToCacheValueMap.Add(t,
                    new TransformValuesCache(position: t.localPosition, rotation: t.localRotation, scale: t.localScale));
            }
        }

        public void Terminate()
        {
            foreach (TweenStep group in tweenSteps)
            {
                group.OnCompleted -= HandleTweenGroupCompleted;
            }
        }

        private void Update()
        {
            if (!IsPlaying)
            {
                return;
            }

            ActiveTweenStep.Tick(Time.deltaTime);
        }

        public void Play()
        {
            if (IsPlaying || tweenSteps.Count < 1)
            {
                return;
            }

            IsPlaying = true;
            PlayedTweens = 0;
            PlayNextTweenGroup();
        }

        public void Stop()
        {
            PlayedTweens = 0;
            CurrentIndex = null;
            IsPlaying = false;
        }

        private void HandleTrackingEvent(string id)
        {
            if (id == playEvent)
            {
                Play();
            }
            else if (id == stopEvent)
            {
                Stop();
            }
        }
        
        private void PlayNextTweenGroup()
        {
            if (CurrentIndex == null)
            {
                CurrentIndex = playInReverse ? LastIndex : 0;
            }
            else
            {
                CurrentIndex = playInReverse ? CurrentIndex - 1 : CurrentIndex + 1;
                CurrentIndex = CurrentIndex.Value % tweenSteps.Count;
            }

            ActiveTweenStep.Initialize();
        }

        private void HandleTweenGroupCompleted(TweenStep step)
        {
            PlayedTweens++;
            if (PlayedTweens >= tweenSteps.Count)
            {
                if (!loop)
                {
                    Stop();
                    LdxTrackingManager.Instance.BroadcastTrackingEvent(completedEventInvoke);
                    OnFinishedPlaying?.Invoke(this);
                    return;
                }

                PlayedTweens = 0;
                ResetAllTweens();
            }

            PlayNextTweenGroup();
        }

        public void ResetAllTweens()
        {
            CurrentIndex = null;

            foreach (Transform t in transformToCacheValueMap.Keys)
            {
                TransformValuesCache cache = transformToCacheValueMap[t];
                t.localPosition = cache.Position.Value;
                t.localRotation = cache.Rotation.Value;
            }

            foreach (TweenStep t in tweenSteps)
            {
                t.Reset();
            }
        }

        private bool CheckPlayOrStopEventsAssigned()
        {
            return !String.IsNullOrEmpty(playEvent) || !String.IsNullOrEmpty(stopEvent);
        }

#if UNITY_EDITOR
        public void EDITOR_Update(float deltaTime)
        {
            ActiveTweenStep?.Tick(deltaTime);
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Visual/Tweening/ObjectTweener.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Visual/Tweening/TweenContainers.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3f87181314c14764b7dc7a934a9b199c
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Features.Visual.Tweening
{
    /// <summary>
    /// A representation of a list of tween operations
    /// </summary>
    [Serializable]
    public class TweenContainer : IEnumerable<TweenOperation>
    {
        [SerializeReference]
        private List<TweenOperation> tweens = new();

        public int Count => tweens.Count;
        public TweenOperation this[int i] => tweens[i];

        public IEnumerator<TweenOperation> GetEnumerator()
        {
            return tweens.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }

    /// <summary>
    /// A tween step describes the properties and definition of a step in tweening
    /// Contains a tween container for the list of operations, and other properties for the step
    /// </summary>
    [Serializable]
    public class TweenStep : IEnumerable<TweenOperation>
    {
        public event Action<TweenStep> OnCompleted;

        [SerializeField]
        private float duration;

        [SerializeField]
        private bool playInReverse;

        [InheritedClassContainer(typeof(TweenOperation), suffixToRemove: "TweenOperation")]
        [SerializeField]
        private TweenContainer tweens = new();

        public int Count => tweens.Count;

        public float Timer { get; protected set; }

        public float Progress
        {
            get
            {
                float t = Timer / duration;
                if (playInReverse)
                {
                    t = 1 - t;
                }

                return Math.Clamp(t, 0.0f, 1.0f);
            }
        }

        public void Initialize()
        {
            foreach (TweenOperation tween in tweens)
            {
                tween.Initialize();
            }
        }

        public void Tick(float deltaTime)
        {
            Timer +=  deltaTime;
            foreach (TweenOperation tween in tweens)
            {
                tween.UpdateProgress(Progress);
            }

            if (Timer >= duration)
            {
                OnCompleted?.Invoke(this);
            }
        }

        public void Reset()
        {
            Timer = 0;
            foreach (TweenOperation t in tweens)
            {
                t.Initialize();
                t.UpdateProgress(Progress);
            }
        }

        public IEnumerator<TweenOperation> GetEnumerator()
        {
            return tweens.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }

    /// <summary>
    /// A representation of a list of tween steps
    /// </summary>
    [Serializable]
    public class TweenStepsContainer : IEnumerable<TweenStep>
    {
        [SerializeField]
        private List<TweenStep> tweenSteps = new List<TweenStep>();

        public int Count => tweenSteps.Count;
        public TweenStep this[int i] => tweenSteps[i];

        public IEnumerator<TweenStep> GetEnumerator()
        {
            return tweenSteps.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Visual/Tweening/TweenContainers.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Features/Visual/Tweening/TweenOperation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3cb8179743704cb696ec5acbad6bc11b
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Features.Interaction;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Features.Visual.Tweening
{
    [Serializable]
    public enum TweenProperty
    {
        Position = 0,
        Rotation,
        Scale
    }

    /// <summary>
    /// Base class for a tween operation that can be used to animate objects
    /// in real time
    /// </summary>
    [Serializable]
    public abstract class TweenOperation
    {
        [SerializeField]
        private TweenProperty tweenProperty = TweenProperty.Position;

        public TweenProperty TweenProperty => tweenProperty;

        [SerializeField]
        private Transform targetTransform;

        public Transform TargetTransform => targetTransform;

        public TransformValuesCache LerpStartValues { get; set; }
        public TransformValuesCache LerpEndValues { get; set; }

        public abstract void Initialize();

        public abstract void UpdateProgress(float t);
    }
    
    /// <summary>
    /// A tween operation that lerps a tween target's value
    /// </summary>
    [Serializable]
    public class ValueTweenOperation : TweenOperation
    {
        [SerializeField]
        private Axis valueAxis;

        public Axis ValueAxis => valueAxis;

        [SerializeField]
        private float endAxisLocalValue;

        public float EndAxisLocalValue => endAxisLocalValue;

        [Header("If Rotation")]
        [SerializeField]
        private bool isClockwise = true;
        public bool IsClockwise => isClockwise;

        public override void Initialize()
        {
            Vector3 startRotEuler = TargetTransform.localRotation.eulerAngles;
            Vector3 startPos = TargetTransform.localPosition;
            Vector3 startScale = TargetTransform.localScale;

            LerpStartValues = new TransformValuesCache(position: startPos,
                rotationEuler: startRotEuler,
                scale: startScale,
                clockwise: IsClockwise);

            LerpEndValues = new TransformValuesCache(position: startPos.Modify(ValueAxis, EndAxisLocalValue),
                rotationEuler: startRotEuler.Modify(ValueAxis, EndAxisLocalValue),
                scale: startScale.Modify(ValueAxis, EndAxisLocalValue));
        }

        public override void UpdateProgress(float t)
        {
            switch (TweenProperty)
            {
                case TweenProperty.Position:
                    if (LerpStartValues?.Position == null || LerpEndValues?.Position == null)
                    {
                        Debug.LogError("Lerp start or end caches have unassigned values");
                        return;
                    }

                    TargetTransform.localPosition = Vector3.Lerp(LerpStartValues.Position.Value,
                        LerpEndValues.Position.Value,
                        t);
                    break;
                case TweenProperty.Rotation:
                    if (LerpStartValues?.RotationEuler == null || LerpEndValues?.RotationEuler == null)
                    {
                        Debug.LogError("Lerp start or end caches have unassigned values");
                        return;
                    }
                    
                    Vector3 startRotation = LerpStartValues.RotationEuler.Value;
                    Vector3 endRotation = LerpEndValues.RotationEuler.Value;
                    bool rotateClockwise = LerpStartValues.RotateClockwise ?? true; // Default to clockwise if not specified
                    
                    // Calculate the difference in angles
                    Vector3 angleDifference = endRotation - startRotation;

                    // Normalize the angle difference to the range of [-180, 180]
                    angleDifference.x = normalizeAngle(angleDifference.x);
                    angleDifference.y = normalizeAngle(angleDifference.y);
                    angleDifference.z = normalizeAngle(angleDifference.z);
                    
                    if (rotateClockwise)
                    {
                        if (angleDifference.x < 0) angleDifference.x += 360;
                        if (angleDifference.y < 0) angleDifference.y += 360;
                        if (angleDifference.z < 0) angleDifference.z += 360;
                    }
                    else
                    {
                        if (angleDifference.x > 0) angleDifference.x -= 360;
                        if (angleDifference.y > 0) angleDifference.y -= 360;
                        if (angleDifference.z > 0) angleDifference.z -= 360;
                    }
                    
                    // Interpolating the rotation
                    Vector3 currentRotation = Vector3.Lerp(startRotation, startRotation + angleDifference, t);

                    // Applying the rotation
                    TargetTransform.localRotation = Quaternion.Euler(currentRotation);
                    
                    float normalizeAngle(float angle)
                    {
                        angle %= 360;
                        if (angle > 180)
                            angle -= 360;
                        if (angle < -180)
                            angle += 360;
                        return angle;
                    }
                    
                    break;
                case TweenProperty.Scale:
                    if (LerpStartValues?.Scale == null || LerpEndValues?.Scale == null)
                    {
                        Debug.LogError("Lerp start or end caches have unassigned values");
                        return;
                    }

                    TargetTransform.localScale = Vector3.Lerp(LerpStartValues.Scale.Value,
                        LerpEndValues.Scale.Value,
                        t);
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
    }

    /// <summary>
    /// A tween operation that tweens towards a reference transform
    /// </summary>
    [Serializable]
    public class ReferenceTransformTweenOperation : TweenOperation
    {
        [SerializeField]
        private Transform endReferenceTransform;

        public Transform EndReferenceTransform => endReferenceTransform;


        public override void Initialize()
        {
            Vector3 startPos = TargetTransform.position;
            Quaternion startRot = TargetTransform.rotation;

            Vector3 endPos = EndReferenceTransform.position;
            Quaternion endRot = EndReferenceTransform.rotation;

            LerpStartValues = new TransformValuesCache(position: startPos,
                rotation: startRot);

            LerpEndValues = new TransformValuesCache(position: endPos,
                rotation: endRot);
        }

        public override void UpdateProgress(float t)
        {
            switch (TweenProperty)
            {
                case TweenProperty.Position:
                    if (LerpStartValues?.Position == null || LerpEndValues?.Position == null)
                    {
                        Debug.LogError("Lerp start or end caches have unassigned values");
                        return;
                    }

                    TargetTransform.position = Vector3.Lerp(LerpStartValues.Position.Value,
                        LerpEndValues.Position.Value,
                        t);
                    break;
                case TweenProperty.Rotation:
                    if (LerpStartValues?.Rotation == null || LerpEndValues?.Rotation == null)
                    {
                        Debug.LogError("Lerp start or end caches have unassigned values");
                        return;
                    }

                    TargetTransform.rotation = Quaternion.Slerp(LerpStartValues.Rotation.Value,
                        LerpEndValues.Rotation.Value,
                        t);
                    break;
                case TweenProperty.Scale:
                    if (LerpStartValues?.Scale == null || LerpEndValues?.Scale == null)
                    {
                        Debug.LogError("Lerp start or end caches have unassigned values");
                        return;
                    }

                    TargetTransform.localScale = Vector3.Lerp(LerpStartValues.Scale.Value,
                        LerpEndValues.Scale.Value,
                        t);
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
    }
    
    /// <summary>
    /// A tween operation that lerps a tween target over a curve
    /// </summary>
    [Serializable]
    public class CurveTweenOperation : TweenOperation
    {
        [SerializeField]
        private AnimationCurve curve = AnimationCurve.Linear(0, 0, 1, 0);
        public AnimationCurve Curve => curve;

        [SerializeField]
        private Axis curveEffectAxis;
        public Axis CurveEffectAxis => curveEffectAxis;
            
        [SerializeField]
        private float curveEffectMultiplier = 1.0f;
        public float CurveEffectMultiplier => curveEffectMultiplier;
        
        public override void Initialize()
        {
            Vector3 startPos = TargetTransform.position;
            Vector3 startScale = TargetTransform.localScale;
            Vector3 startEulerRot = TargetTransform.localRotation.eulerAngles;
            Quaternion startRot = TargetTransform.rotation;
            
            LerpStartValues = new TransformValuesCache(position: startPos, 
                rotation: startRot, 
                rotationEuler: startEulerRot,
                scale: startScale);
        }

        public override void UpdateProgress(float t)
        {
            Transform target = TargetTransform;
            float value = Curve.Evaluate(t) * CurveEffectMultiplier;

            switch (TweenProperty)
            {
                case TweenProperty.Position:
                    if (LerpStartValues?.Position == null)
                    {
                        Debug.LogError("Lerp start cache have unassigned values");
                        return;
                    }

                    target.localPosition = target.localPosition.Modify(CurveEffectAxis, value);
                    break;
                case TweenProperty.Rotation:
                    if (LerpStartValues?.RotationEuler == null)
                    {
                        Debug.LogError("Lerp start cache have unassigned values");
                        return;
                    }
                    target.localRotation 
                        = Quaternion.Euler(target.localRotation.eulerAngles.Modify(CurveEffectAxis, value));
                    break;
                case TweenProperty.Scale:
                    if (LerpStartValues?.Scale == null)
                    {
                        Debug.LogError("Lerp start cache have unassigned values");
                        return;
                    }

                    target.localScale = target.localScale.Modify(CurveEffectAxis, value);
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Features/Visual/Tweening/TweenOperation.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/AddOns/AddOnConfig.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f1fc8497c156449a87f304e8c4645411
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Ldx.Framework.Systems.AddOns
{
    /// <summary>
    /// Base class for configs that can be added to GlobalData
    /// </summary>
    [Serializable]
    public abstract class AddOnConfig
    {
    }

    [Serializable]
    public class AddOnConfigsContainer : IEnumerable<AddOnConfig>
    {        
        [SerializeReference] private List<AddOnConfig> configs = new();

        public void TryAdd<T>() where T : AddOnConfig
        {
            if (TryGet(out T found))
            {
                return;
            }
            
            configs.Add((T)Activator.CreateInstance(typeof(T)));
        }
        
        public bool TryGet<T>(out T config) where T : AddOnConfig
        {
            config = (T)configs.FirstOrDefault(o => o is T);
            return config != null;
        }
        
        public IEnumerator<AddOnConfig> GetEnumerator()
        {
            return configs.GetEnumerator();
        }
        
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/AddOns/AddOnConfig.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/AddOns/AddOnModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5a1d34966a3648c49992590206827249
# ASMDEF: ldx.framework.runtime.dll
# ---
namespace Ldx.Framework.Systems.AddOns
{
    /// <summary>
    /// A module script for an add-on in the framework
    /// Classes inherited from this will be auto-executed
    /// </summary>
    public abstract class AddOnModule
    {
        /// <summary>
        /// Sets up the module before the first scenario is loaded
        /// </summary>
        public abstract void Setup();
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/AddOns/AddOnModule.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/AmbientSound.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 30cf5bd0254e4407bebf3d5962a57c24
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.AudioSystem
{
    public class AmbientSound : MonoBehaviour
    {
        [SerializeField][SoundReference]
        private string soundReference;
        
        private void Start()
        {
            Audio.PlayAmbience(soundReference);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/AmbientSound.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/Audio.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2e818d3458906d545b02097e9f6659c8
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Utilities.Logging;
using UnityEngine;
using UnityEngine.Audio;
using Debug = Ldx.Framework.Utilities.Logging.Debug;

namespace Ldx.Framework.Systems.AudioSystem
{
    /// <summary>
    /// Static class that can be called from anywhere in the code to perform regular audio tasks.
    /// Code outside the audio namespace shouldn't be concerned with the inner workings of the audio system,
    /// and should only ever need to make calls to this class.
    /// </summary>
    public static class Audio
    {
        private static AudioSource dialogueAudioSource;

        private static AudioSource DialogueAudioSource
        {
            get
            {
                if (dialogueAudioSource == null)
                {
                    GameObject audioSourceGO = new ($"DialogueAudioSource")
                    {
                        transform =
                        {
                            parent = AudioRuntimeManager.Instance.transform
                        }
                    };
                    dialogueAudioSource = audioSourceGO.AddComponent<AudioSource>();
                    dialogueAudioSource.playOnAwake = false;
                }
                return dialogueAudioSource;
            }
        }

        public static bool IsDialogueAudioPlaying()
        {
            if (dialogueAudioSource == null)
            {
                return false;
            }

            return dialogueAudioSource.isPlaying;
        }
        
        /// <summary>
        /// General safety checks for audio runtime methods that need Sound path from a Sound reference.
        /// </summary>
        private static bool TryRuntimeChecksAndGetPath(string soundReference, out string path)
        {
            path = null;
            
            if (string.IsNullOrEmpty(soundReference))
            {
                return false;
            }
            
            if (!AudioRuntimeManager.IsValid && AudioRuntimeManager.Instance == null)
            {
                return false;
            }

            return AudioGlobalSettings.TryGetPathFromReference(soundReference, out path);
        }
        
        /// <summary>
        /// Get a Sound asset from a sound reference.
        /// Returns null if the reference is invalid or the sound doesn't exist.
        /// </summary>
        public static Sound GetSound(string soundReference)
        {
            if (!TryRuntimeChecksAndGetPath(soundReference, out string soundPath)) 
                return null;
                
            return Resources.Load<Sound>($"Sounds/{soundPath}");
        }
        
        /// <summary>
        /// Get the length of the first audio clip in a sound.
        /// Returns 0 if the sound or clips don't exist.
        /// </summary>
        public static float ClipLength(string soundReference)
        {
            Sound sound = GetSound(soundReference);
            if (sound == null || !sound.HasClips)
                return 0f;
                
            List<AudioClip> clips = sound.GetAudioClips();
            return clips[0].length;
        }
        
        /// <summary>
        /// Create and return an instance of the sound found by the given sound path.
        /// If the path does not correlate with any sound, returns null.
        /// </summary>
        public static SoundInstance CreateSoundInstance(string soundReference)
        {
            if (!TryRuntimeChecksAndGetPath(soundReference, out string soundPath)) return null;
            return AudioRuntimeManager.Instance.CreateSoundInstance(soundPath);
        }

        /// <summary>
        /// Play the sound corresponding to the given sound path, if it exists.
        /// If the sound is looping or the sound doesn't exist, nothing will happen (fail silently).
        /// </summary>
        public static void PlayOneShot(string soundReference,
            float? volume = null, 
            float? pitch = null, 
            float? stereoPan = null,
            bool allowOverlap = true)
        {
            if (!TryRuntimeChecksAndGetPath(soundReference, out string soundPath)) return;
            AudioRuntimeManager.Instance.PlayOneShot(soundPath, volume, pitch, stereoPan, allowOverlap);
        }

        /// <summary>
        /// Play the sound corresponding to the given sound path, if it exists.
        /// Will play the sound at the given world position (if 3D).
        /// If the sound is looping or the sound doesn't exist, nothing will happen (fail silently).
        /// </summary>
        public static void PlayOneShot(string soundReference, 
            Vector3 position, 
            float? volume = null, 
            float? pitch = null, 
            float? stereoPan = null,
            bool allowOverlap = true)
        {
            if (!TryRuntimeChecksAndGetPath(soundReference, out string soundPath)) return;
            AudioRuntimeManager.Instance.PlayOneShot(soundPath, position, volume, pitch, stereoPan, allowOverlap);
        }
        
        /// <summary>
        /// Play the sound corresponding to the given sound path, if it exists.
        /// Will attach the sound to the given transform for positional changes (if 3D).
        /// If the sound is looping or the sound doesn't exist, nothing will happen (fail silently).
        /// </summary>
        public static void PlayOneShot(string soundReference, 
            Transform transform, 
            float? volume = null, 
            float? pitch = null, 
            float? stereoPan = null,
            bool allowOverlap = true)
        {
            if (!TryRuntimeChecksAndGetPath(soundReference, out string soundPath)) return;
            AudioRuntimeManager.Instance.PlayOneShot(soundPath, transform, volume, pitch, stereoPan, allowOverlap);
        }
        
        /// <summary>
        /// Play the sound corresponding to the given sound path with modified volume.
        /// If the sound doesn't exist, nothing will happen.
        /// </summary>
        /// <param name="soundReference">The sound reference GUID</param>
        /// <param name="volume">Volume override</param>
        /// <param name="pitch">Pitch override</param>
        /// <param name="stereoPan">Stereo Pan Override</param>
        /// <returns>The created sound instance or null if failed</returns>
        public static void PlayWithOverrides(
            string soundReference, 
            float? volume = null, 
            float? pitch = null, 
            float? stereoPan = null)
        {
            SoundInstance instance = CreateSoundInstance(soundReference);
            if (instance == null)
            {
                return;
            }

            if (volume != null)
            {
                instance.SetVolume((float)volume);
            }

            if (pitch != null)
            {
                instance.SetPitch((float)pitch);
            }

            if (stereoPan != null)
            {
                instance.SetStereoPan((float)stereoPan);
            }
            
            instance.Play();
        }

        /// <summary>
        /// Play the sound corresponding to the given sound path, if it exists, in ambience mode:
        /// The previously playing ambience (if any) will crossfade into this new one.
        /// Non-looping sounds will not be played and the previous ambience will continue in this case.
        /// </summary>
        public static void PlayAmbience(string soundReference)
        {
            if (!TryRuntimeChecksAndGetPath(soundReference, out string soundPath)) return;
            AudioRuntimeManager.Instance.PlayAmbience(soundPath);
        }

        public static void PlayDialogue(AudioClip clip, AudioMixerGroup customMixerGroup = null)
        {
            StopDialogue();

            if (clip == null)
            {
                Debug.LogError(LogCategory.Audio,"Can't play dialogue - clip is null");
                return;
            }

            if (customMixerGroup != null)
            {
                DialogueAudioSource.outputAudioMixerGroup = customMixerGroup;
            }
            else if (AudioGlobalSettings.DialogueMixerGroup != null)
            {
                DialogueAudioSource.outputAudioMixerGroup = AudioGlobalSettings.DialogueMixerGroup;
            }

            DialogueAudioSource.clip = clip;
            dialogueAudioSource.Play();
        }

        public static void StopDialogue()
        {
            if (DialogueAudioSource.isPlaying)
            {
                DialogueAudioSource.Stop();
            }
        }
        
        public static SoundInstance PlayEventDataAudio(IPlayAudioEventData data)
        {
            SoundInstance eventDataAudioInstance = CreateSoundInstance(data.SoundReference);
            if (eventDataAudioInstance != null)
            {
                eventDataAudioInstance.Play();
            }
            return eventDataAudioInstance;
        }
        
        public static Sound LoadSound(string soundReference)
        {
            Sound sound = null;

            if (!string.IsNullOrEmpty(soundReference))
            {
                if (AudioGlobalSettings.TryGetPathFromReference(soundReference, out string soundsLocalPath))
                {
                    sound = Resources.Load<Sound>($"Sounds/{soundsLocalPath}");
                }
            }

            return sound;
        }
        
        public static void UnloadSound(Sound sound)
        {
            if (sound != null)
                Resources.UnloadAsset(sound);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/Audio.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/AudioEmitter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9168b0e4c66512241b833d2cfae77784
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using Autohand;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Logging;
using UnityEditor;
using UnityEngine;
using Debug = Ldx.Framework.Utilities.Logging.Debug;

namespace Ldx.Framework.Systems.AudioSystem
{
    /// <summary>
    /// Place on any object that needs to emit 3D sound originating from its transform position.
    /// 2D sounds will not be played by the emitter.
    /// </summary>
    public class AudioEmitter : MonoBehaviour
    {
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string playOnTrackingEvent;
        
        [SerializeField][SoundReference]
        private string mainSoundReference;
        [SerializeField][Tooltip("Plays the emitter's sound whenever OnEnable is called. Otherwise, StartSound must be called.")]
        private bool playOnEnable = true;
        [SerializeField][Tooltip("Plays the emitter's sound whenever Start is called. Otherwise, StartSound must be called.")]
        private bool playOnStart = true;
        
        [SerializeField][Header("Sound Modifiers")]
        [Tooltip("Volume multiplier for the sound (1.0 = normal volume)")]
        [Range(0, 2)] private float volumeModifier = 1.0f;
        
        [SerializeField][Tooltip("Pitch adjustment for the sound (-3 to 3 range)")]
        [Range(-2, 2)] private float pitchModifier;
        
        [SerializeField][Tooltip("Set to modify the default stereo pan")]
        private bool overrideStereoPan;
        
        [SerializeField][Tooltip("Stereo pan value (-1.0 = left, 0 = center, 1.0 = right)")]
        [Range(-1, 1)] private float stereoPan;
        
        [SerializeField][Tooltip("Set to modify the default reverb zone mix")]
        private bool overrideReverbZoneMix;
        
        [SerializeField][Tooltip("Reverb zone mix value (0 to 1.1)")]
        [Range(0, 1.1f)] private float reverbZoneMix = 1.0f;
        
        [SerializeField] private Grabbable grabbable;
        [Tooltip("Set this to trigger the 'Dropped Sound' otherwise primary collision sound will play")]
        [SerializeField] private Collider groundCollider;
        public Collider GroundCollider => groundCollider;

        [Header("Audio Emitter Features")]
        [SerializeReference] private List<AudioEmitterFeature> features = new();
        
        private readonly Dictionary<string, SoundInstance> soundInstances = new();
        private InteractionSoundsFeature interactionFeature;
        private CollisionSoundsFeature collisionFeature;
        private bool isGrabbable;
        private bool collisionsActive;
        private bool isInitialized;
        private bool isSubscribed;
        private float pausedTime;
        
#if UNITY_EDITOR
        [Header("Editor Only")]
        [SerializeField] private bool visualizeMinAndMaxDistances = true;
        
        private string editorCachedSoundReference;
        private Sound editorCachedSound;
#endif
        
        private void OnValidate()
        {
            InteractionSoundsFeature interaction = features.OfType<InteractionSoundsFeature>().FirstOrDefault();

            if (interaction is { IsGrabbable: true })
            {
                if (grabbable)
                {
                    return;
                }

                grabbable = gameObject.GetOrAddComponent<Grabbable>();
            }
            else
            {
                grabbable = null;
            }
        }

        private void Awake()
        {
            // We haven't initialized the features yet
            isInitialized = false;
        }

        private void OnEnable()
        {
            // Use delayed sound play to ensure proper initialization
            if (!isInitialized)
            {
                InitializeFeatures();
            }

            if (!isSubscribed)
            {
                SubscribeToEvents();
            }
            
            if (playOnEnable)
            {
                StartSound(mainSoundReference);
            }
        }

        private void Start()
        {
            InitializeFeatures();
            
            if (playOnStart && gameObject.activeInHierarchy)
            {
                StartSound(mainSoundReference);
            }
            
            SubscribeToEvents();
        }
        
        private void InitializeFeatures()
        {
            foreach (AudioEmitterFeature feature in features)
            {
                switch (feature)
                {
                    case InteractionSoundsFeature interaction:
                    {
                        interactionFeature = interaction;
                        if (interactionFeature.IsGrabbable)
                        {
                            isGrabbable = true;
                        }

                        break;
                    }
                    case CollisionSoundsFeature collision:
                        collisionsActive = true;
                        collisionFeature = collision;
                        break;
                }
            }
            
            isInitialized = true;
        }

        private void OnDisable()
        {
            foreach (KeyValuePair<string, SoundInstance> instance in soundInstances)
            {
                instance.Value.StopFadeOutAndRelease();
            }
            
            soundInstances.Clear();
        }

        private void OnDestroy()
        {
            UnsubscribeFromEvents();
        }

        private void OnCollisionEnter(Collision other)
        {
            if (!collisionsActive || !isInitialized || !gameObject.activeInHierarchy)
            {
                return;
            }
            
            StartSound(other.collider == groundCollider
                ? collisionFeature.DroppedSound
                : collisionFeature.PrimaryImpactSound);
        }

        private void OnTriggerEnter(Collider other)
        {
            if (interactionFeature == null || !isInitialized || isGrabbable || 
                !other.CompareTag("Hand") || !gameObject.activeInHierarchy)
            {
                return;
            }
            
            StartSound(interactionFeature.PressedSound);
        }

        /// <summary>
        /// Starts playing the main sound assigned to this emitter.
        /// </summary>
        public void StartSound()
        {
            StartSound(mainSoundReference);
        }

        /// <summary>
        /// Starts playing the specified sound with this emitter's parameters.
        /// </summary>
        /// <param name="soundRef">The sound reference GUID to play</param>
        public void StartSound(string soundRef)
        {
            // Skip if null/empty reference or GameObject not active
            if (string.IsNullOrEmpty(soundRef) || !gameObject.activeInHierarchy)
            {
                Debug.LogError(LogCategory.Audio, $"StartSound skipped: {gameObject.name} with sound {soundRef}, active: {gameObject.activeInHierarchy}");
                return;
            }
            
            // Check if sound exists and if it's meant to be played in 3D
            Sound sound = Audio.GetSound(soundRef);
            if (sound == null)
            {
                Debug.LogError(LogCategory.Audio, $"StartSound skipped: Sound not found for {soundRef}");
                return;
            }

            // Check if it has a spatial blend - all emitter sounds need some spatial component
            if (sound.SpatialBlend <= 0.01f)
            {
                Debug.LogError(LogCategory.Audio, $"StartSound skipped: Sound {sound.name} has no spatial blend (2D sound)");
                return;
            }
            
            if (TryPopulateSoundInstance(soundRef))
            {
                SoundInstance instance = soundInstances[soundRef];
                
                // Apply any parameter modifiers
                ApplyParametersToInstance(instance);
                
                instance.Play();
            }
            else
            {
                Debug.LogError(LogCategory.Audio, $"StartSound failed: Could not populate sound instance for {soundRef}");
            }
        }
        
        /// <summary>
        /// Pauses the main sound reference
        /// </summary>
        public void PauseSound()
        {
            PauseSound(mainSoundReference);
        }

        /// <summary>
        /// Pauses the specified sound reference
        /// </summary>
        /// <param name="soundRef">The sound reference GUID to pause</param>
        public void PauseSound(string soundRef)
        {
            SoundInstance instance = soundInstances[soundRef];
            pausedTime = instance.audioSource.time;
            instance.audioSource.Pause();
        }

        /// <summary>
        /// Resumes playing the main sound reference from the paused point.
        /// </summary>
        public void ResumeSound()
        {
            ResumeSound(mainSoundReference);
        }

        /// <summary>
        /// Resumes playing the specified sound reference from the paused point.
        /// </summary>
        /// <param name="soundRef">The sound reference GUID to resume</param>
        public void ResumeSound(string soundRef)
        {
            SoundInstance instance = soundInstances[soundRef];
            instance.audioSource.time = pausedTime;
            instance.audioSource.UnPause();
        }

        /// <summary>
        /// Stops playing the main sound assigned to this emitter.
        /// </summary>
        public void StopSound()
        {
            StopSound(mainSoundReference);
        }

        /// <summary>
        /// Stops playing the specified sound.
        /// </summary>
        /// <param name="soundRef">The sound reference GUID to stop</param>
        public void StopSound(string soundRef)
        {
            if (string.IsNullOrEmpty(soundRef))
                return;
                
            if (soundInstances.TryGetValue(soundRef, out SoundInstance instance))
            {
                instance.StopFadeOut();
            }
        }

        /// <summary>
        /// Adjusts the volume of the main sound.
        /// </summary>
        /// <param name="newVolumeModifier">Volume multiplier (1.0 = normal volume)</param>
        public void SetVolume(float newVolumeModifier)
        {
            volumeModifier = Mathf.Max(0, newVolumeModifier);
            
            // Apply to active sound
            if (soundInstances.TryGetValue(mainSoundReference, out SoundInstance instance))
            {
                instance.SetVolume(volumeModifier);
            }
        }

        /// <summary>
        /// Adjusts the pitch of the main sound.
        /// </summary>
        /// <param name="newPitchModifier">Pitch adjustment (-2 to 2 range recommended)</param>
        public void SetPitch(float newPitchModifier)
        {
            pitchModifier = newPitchModifier;
            
            // Apply to active sound
            if (soundInstances.TryGetValue(mainSoundReference, out SoundInstance instance))
            {
                instance.SetPitch(pitchModifier);
            }
        }

        /// <summary>
        /// Sets the stereo pan for the main sound.
        /// </summary>
        /// <param name="newStereoPan">Stereo pan value (-1 to 1 range)</param>
        public void SetStereoPan(float newStereoPan)
        {
            overrideStereoPan = true;
            stereoPan = Mathf.Clamp(newStereoPan, -1, 1);
            
            // Apply to active sound
            if (soundInstances.TryGetValue(mainSoundReference, out SoundInstance instance))
            {
                instance.SetStereoPan(stereoPan);
            }
        }

        /// <summary>
        /// Resets the stereo pan to use the default from the Sound asset.
        /// </summary>
        public void ResetStereoPan()
        {
            overrideStereoPan = false;
            
            // Apply to active sound
            if (soundInstances.TryGetValue(mainSoundReference, out SoundInstance instance))
            {
                instance.ResetStereoPan();
            }
        }

        /// <summary>
        /// Sets the reverb zone mix for the main sound.
        /// </summary>
        /// <param name="newReverbZoneMix">Reverb zone mix value (0 to 1.1 range)</param>
        public void SetReverbZoneMix(float newReverbZoneMix)
        {
            overrideReverbZoneMix = true;
            reverbZoneMix = Mathf.Clamp(newReverbZoneMix, 0, 1.1f);
            
            // Apply to active sound
            if (soundInstances.TryGetValue(mainSoundReference, out SoundInstance instance))
            {
                instance.SetReverbZoneMix(reverbZoneMix);
            }
        }

        /// <summary>
        /// Resets the reverb zone mix to use the default from the Sound asset.
        /// </summary>
        public void ResetReverbZoneMix()
        {
            overrideReverbZoneMix = false;
            
            // Apply to active sound
            if (soundInstances.TryGetValue(mainSoundReference, out SoundInstance instance))
            {
                instance.ResetReverbZoneMix();
            }
        }

        /// <summary>
        /// Resets all sound parameters to their default values.
        /// </summary>
        public void ResetAllParameters()
        {
            volumeModifier = 1.0f;
            pitchModifier = 0.0f;
            overrideStereoPan = false;
            overrideReverbZoneMix = false;
            
            // Apply to active sound
            if (soundInstances.TryGetValue(mainSoundReference, out SoundInstance instance))
            {
                instance.ResetAllParameters();
            }
        }

        /// <summary>
        /// Applies this emitter's parameter modifiers to the sound instance.
        /// </summary>
        private void ApplyParametersToInstance(SoundInstance instance)
        {
            if (instance == null)
                return;
                
            // Apply volume modifier
            instance.SetVolume(volumeModifier);
            
            // Apply pitch modifier
            instance.SetPitch(pitchModifier);
            
            // Apply stereo pan if overriding
            if (overrideStereoPan)
            {
                instance.SetStereoPan(stereoPan);
            }
            else
            {
                instance.ResetStereoPan();
            }
            
            // Apply reverb zone mix if overriding
            if (overrideReverbZoneMix)
            {
                instance.SetReverbZoneMix(reverbZoneMix);
            }
            else
            {
                instance.ResetReverbZoneMix();
            }
        }

        /// <summary>
        /// Attempts to create or reuse a 3D sound instance attached to this transform.
        /// Returns true if a valid 3D instance is available after the call.
        /// </summary>
        private bool TryPopulateSoundInstance(string soundRef)
        {
            // Early out for empty or null references
            if (string.IsNullOrEmpty(soundRef))
            {
                Debug.LogVerbose("TryPopulateSoundInstance: Sound reference is null or empty");
                return false;
            }
    
            // Check if we already have this instance
            if (soundInstances.TryGetValue(soundRef, out SoundInstance instance))
            {
                Debug.LogVerbose($"TryPopulateSoundInstance: Already have instance for {soundRef}, Is3D: {instance.Is3D}");
                return instance.Is3D;
            }

            // Load the sound asset
            Sound sound = Audio.GetSound(soundRef);
            if (sound == null)
            {
                Debug.LogVerbose($"TryPopulateSoundInstance: Could not load sound for {soundRef}");
                return false;
            }

            // Create a new instance
            SoundInstance newInstance = Audio.CreateSoundInstance(soundRef);
            if (newInstance == null)
            {
                Debug.LogVerbose($"TryPopulateSoundInstance: Could not create sound instance for {soundRef}");
                return false;
            }

            // Check if 3D, release if not
            bool is3D = newInstance.Is3D;
            if (!is3D)
            {
                Debug.LogVerbose($"TryPopulateSoundInstance: Releasing non-3D instance for {soundRef}");
                newInstance.Release();
                return false;
            }

            soundInstances.Add(soundRef, newInstance);
            newInstance.AttachToTransform(transform);
            return true;
        }

        private void SubscribeToEvents()
        {
            if (isGrabbable && grabbable != null)
            {
                grabbable.OnGrabEvent += HandleHandGrabbed;
                grabbable.OnReleaseEvent += HandleHandReleased;
                grabbable.OnPlacePointAddEvent += HandleSocketed;
                grabbable.OnPlacePointRemoveEvent += HandleUnSocketed;
                grabbable.OnSqueezeEvent += HandleActivated;
                grabbable.OnUnsqueezeEvent += HandleDeactivated;
            }

            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
            }

            isSubscribed = true;
        }

        private void UnsubscribeFromEvents()
        {
            if (isGrabbable && grabbable != null)
            {
                grabbable.OnGrabEvent -= HandleHandGrabbed;
                grabbable.OnReleaseEvent -= HandleHandReleased;
                grabbable.OnPlacePointAddEvent -= HandleSocketed;
                grabbable.OnPlacePointRemoveEvent -= HandleUnSocketed;
                grabbable.OnSqueezeEvent -= HandleActivated;
                grabbable.OnUnsqueezeEvent -= HandleDeactivated;
            }

            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }
        }

        private void HandleHandGrabbed(Hand hand, Grabbable _)
        {
            if (interactionFeature != null && gameObject.activeInHierarchy)
            {
                StartSound(interactionFeature.HandGrabbedSound);
            }
        }

        private void HandleHandReleased(Hand hand, Grabbable _)
        {
            if (interactionFeature != null && gameObject.activeInHierarchy)
            {
                StartSound(interactionFeature.HandReleasedSound);
            }
        }

        private void HandleSocketed(PlacePoint point, Grabbable _)
        {
            if (interactionFeature != null && gameObject.activeInHierarchy)
            {
                StartSound(interactionFeature.SocketedSound);
            }
        }

        private void HandleUnSocketed(PlacePoint point, Grabbable _)
        {
            if (interactionFeature != null && gameObject.activeInHierarchy)
            {
                StartSound(interactionFeature.RemovedFromSocketSound);
            }
        }

        private void HandleActivated(Hand hand, Grabbable _)
        {
            if (interactionFeature != null && gameObject.activeInHierarchy)
            {
                HandleActivatedAsync().Forget();
            }
        }

        private async UniTaskVoid HandleActivatedAsync()
        {
            StartSound(interactionFeature.ActivatedStartSound);
            float waitTime = Audio.ClipLength(interactionFeature.ActivatedStartSound) - 
                             interactionFeature.ActivatedLoopStartOverlapTime;
            await UniTask.Delay(waitTime.ToMilliseconds());
            
            // Check if still active before playing the loop sound
            if (gameObject != null && gameObject.activeInHierarchy)
            {
                StartSound(interactionFeature.ActivatedLoopSound);
            }
        }

        private void HandleDeactivated(Hand hand, Grabbable grabbableHand)
        {
            if (interactionFeature != null && gameObject.activeInHierarchy)
            {
                StopSound(interactionFeature.ActivatedLoopSound);
                StartSound(interactionFeature.DeactivatedSound);
            }
        }

        private void HandleTrackingEvent(string eventId)
        {
            if (eventId == playOnTrackingEvent)
            {
                StartSound();
            }
            
            if (!gameObject.activeInHierarchy || interactionFeature == null)
                return;
                
            if (eventId == interactionFeature.PlacedSoundTriggerEvent)
            {
                StartSound(interactionFeature.PlacedSound);
            }
            
            if (eventId == interactionFeature.CustomInteractionSoundTriggerEvent)
            {
                StartSound(interactionFeature.CustomInteractionSound);
            }
        }

#if UNITY_EDITOR
        private void OnDrawGizmos()
        {
            Gizmos.DrawIcon(transform.position, AudioGlobalSettings.EDITOR_LDX_SPEAKER_ICON_PATH, allowScaling: true);
        }
        
        private void OnDrawGizmosSelected()
        {
            if (!visualizeMinAndMaxDistances)
            {
                return;
            }

            if (editorCachedSound == null)
            {
                return;
            }

            Vector3 position = transform.position;
            Gizmos.color = Color.red;
            Gizmos.DrawWireSphere(position, editorCachedSound.MinDistance);
            Gizmos.color = Color.green;
            Gizmos.DrawWireSphere(position, editorCachedSound.MaxDistance);
        }
        
        [MenuItem ("GameObject/Audio/Audio Emitter")]
        private static void CreateAudioEmitter()
        {
            GameObject audioEmitterGO = new ("AudioEmitter");
            audioEmitterGO.AddComponent<AudioEmitter>();
            Selection.activeObject = audioEmitterGO;
        }

        public Sound EDITOR_LoadEditorCachedSound()
        {
            if (editorCachedSound == null || editorCachedSoundReference != mainSoundReference)
            {
                Audio.UnloadSound(editorCachedSound);
                editorCachedSound = Audio.LoadSound(mainSoundReference);
                editorCachedSoundReference = mainSoundReference;
            }

            return editorCachedSound;
        }
        
        public void EDITOR_UnloadEditorCachedSound()
        {
            if (editorCachedSound != null)
            {
                Audio.UnloadSound(editorCachedSound);
                editorCachedSound = null;
                editorCachedSoundReference = null;
            }
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/AudioEmitter.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/AudioEmitterFeatures.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a8f2fe7f7e9ae8841829682da0148067
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.AudioSystem
{
    [Serializable]
    public abstract class AudioEmitterFeature
    {
        public abstract string FeatureName { get; }
    }
    
    [Serializable]
    public class InteractionSoundsFeature : AudioEmitterFeature
    {
        public override string FeatureName => "Interaction Sounds";

        [SerializeField] private bool isGrabbable;
        public bool IsGrabbable => isGrabbable;

        [SerializeField][SoundReference] 
        private string handGrabbedSound;
        public string HandGrabbedSound
        {
            get => handGrabbedSound;
            set => handGrabbedSound = value;
        }
        
        [SerializeField][SoundReference]
        private string handReleasedSound;
        public string HandReleasedSound
        {
            get => handReleasedSound;
            set => handReleasedSound = value;
        }
        
        [SerializeField][SoundReference]
        private string socketedSound;
        public string SocketedSound
        {
            get => socketedSound;
            set => socketedSound = value;
        }
        
        [SerializeField][SoundReference]
        private string removedFromSocketSound;
        public string RemovedFromSocketSound
        {
            get => removedFromSocketSound;
            set => removedFromSocketSound = value;
        }
        
        [SerializeField][SoundReference]
        private string activatedStartSound;
        public string ActivatedStartSound
        {
            get => activatedStartSound;
            set => activatedStartSound = value;
        }
        
        [SerializeField][SoundReference]
        private string activatedLoopSound;
        public string ActivatedLoopSound
        {
            get => activatedLoopSound;
            set => activatedLoopSound = value;
        }
        
        [SerializeField][Min(0)]
        private float activatedLoopStartOverlapTime;
        public float ActivatedLoopStartOverlapTime
        {
            get => activatedLoopStartOverlapTime;
            set => activatedLoopStartOverlapTime = value;
        }
        
        [SerializeField][SoundReference]
        private string deactivatedSound;
        public string DeactivatedSound
        {
            get => deactivatedSound;
            set => deactivatedSound = value;
        }
        
        [SerializeField][SoundReference]
        private string placedSound;
        public string PlacedSound
        {
            get => placedSound;
            set => placedSound = value;
        }
        
        [SerializeField][SoundReference]
        private string customInteractionSound;
        public string CustomInteractionSound
        {
            get => customInteractionSound;
            set => customInteractionSound = value;
        }
        
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string placedSoundTriggerEvent;
        public string PlacedSoundTriggerEvent
        {
            get => placedSoundTriggerEvent;
            set => placedSoundTriggerEvent = value;
        }
        
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string customInteractionSoundTriggerEvent;
        public string CustomInteractionSoundTriggerEvent
        {
            get => customInteractionSoundTriggerEvent;
            set => customInteractionSoundTriggerEvent = value;
        }
        
        [SerializeField][SoundReference]
        private string pressedSound;
        public string PressedSound
        {
            get => pressedSound;
            set => pressedSound = value;
        }
    }

    [Serializable]
    public class CollisionSoundsFeature : AudioEmitterFeature
    {
        public override string FeatureName => "Collision Sounds";

        [SerializeField][SoundReference]
        private string droppedSound;
        public string DroppedSound
        {
            get => droppedSound;
            set => droppedSound = value;
        }
        
        [SerializeField]
        private Collider groundCollider;
        public Collider GroundCollider
        {
            get => groundCollider;
            set => groundCollider = value;
        }
        
        [SerializeField][SoundReference]
        private string primaryImpactSound;
        public string PrimaryImpactSound
        {
            get => primaryImpactSound;
            set => primaryImpactSound = value;
        }
        
        [SerializeField][SoundReference]
        private string secondaryImpactSound;
        public string SecondaryImpactSound
        {
            get => secondaryImpactSound;
            set => secondaryImpactSound = value;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/AudioEmitterFeatures.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/AudioEnums.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 752020eb9b029ba47a9721e134679e82
# ASMDEF: ldx.framework.runtime.dll
# ---
namespace Ldx.Framework.Systems.AudioSystem
{
    /// <summary>
    /// One shot or looping playback specification
    /// </summary>
    public enum PlaybackMode
    {
        OneShot,
        Loop
    }

    /// <summary>
    /// Behaviour of a Sound in determining which of its audio clips to use during playback
    /// </summary>
    public enum RepeatMode
    {
        FirstOnly,
        Random,
        RoundRobin
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/AudioEnums.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/AudioGlobalSettings.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 38dd7697b2b40a047b674ef4c3d51770
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine.Audio;

#if UNITY_EDITOR
using System.IO;
using UnityEditor;
#endif

namespace Ldx.Framework.Systems.AudioSystem
{
    /// <summary>
    /// Statically accessible global data and references for audio purposes.
    /// Controls parameters for the audio runtime manager, some globally used sound references,
    /// and is host to the GUID -> Sound path reference table that assists in loading Sound files in & out.
    /// </summary>
    [HasFrameworkDefault]
    public class AudioGlobalSettings : GlobalSettings<AudioGlobalSettings>
    {
        public const string SOUNDS_ASSET_PATH = "Assets/Resources/Sounds";
        public const string FRAMEWORK_SOUNDS_ASSET_PATH = "Packages/com_ldx_framework/Runtime/Assets/Sounds";
        private const string MANIFEST_PATH = "Assets/Resources/Audio/SoundManifest.asset";
        
        [Header("Sound Manifest")]
        [SerializeField]
        [Tooltip("Reference to the SoundManifest that holds all framework and project sounds.")]
        public SoundManifest soundManifest;
        public static SoundManifest SoundManifest => Instance.soundManifest;

        [Header("Dialogue Mixer Group")] [SerializeField]
        [Tooltip("If no audio mixer group is specified for event data audio, use this one. If this one is not assigned, skip groups (default Unity audio source behaviour)")]
        private AudioMixerGroup dialogueMixerGroup;
        public static AudioMixerGroup DialogueMixerGroup => Instance.dialogueMixerGroup;
        
        [Header("Runtime Manager Setup")]
        [SerializeField][Tooltip("Maximum number of audio sources the runtime manager is allowed to instantiate.")]
        private int audioSourcePoolMaxSize = 32;
        public static int AudioSourcePoolMaxSize => Instance.audioSourcePoolMaxSize;
        
        [SerializeField][Tooltip("Seconds interval between every cleanup of the audio source pool, beginning at pool creation.")]
        private float audioSourcePoolCleaningInterval = 5 * 60;
        public static float AudioSourcePoolCleaningInterval => Instance.audioSourcePoolCleaningInterval;

        [Header("Common Sound References")]
        [SerializeField] [SoundReference]
        private string objectiveCompleteSoundRef;
        public static string ObjectiveCompleteSoundRef => Instance.objectiveCompleteSoundRef;
        
        [Header("Global References")]
        [SerializeField][SoundReference]
        private string settingsButtonClick;
        public static string SettingsButtonClick => Instance.settingsButtonClick;
        
        [SerializeField][SoundReference]
        private string dropDownClickOpen;
        public static string DropDownClickOpen => Instance.dropDownClickOpen;
        
        [SerializeField][SoundReference]
        private string onWindowAppearSound;
        public static string OnWindowAppearSound => Instance.onWindowAppearSound;
        
        [SerializeField][SoundReference]
        private string onWindowSwapSound;
        public static string OnWindowSwapSound => Instance.onWindowSwapSound;
        
        [SerializeField][SoundReference]
        private string onWindowHideSound;
        public static string OnWindowHideSound => Instance.onWindowHideSound;
        
        [SerializeField][SoundReference]
        private string onClickSound;
        public static string OnClickSound => Instance.onClickSound;
        
        [SerializeField][SoundReference]
        private string onCorrectSound;
        public static string OnCorrectSound => Instance.onCorrectSound;
                
        [SerializeField][SoundReference]
        private string onHoverSound;
        public static string OnHoverSound => Instance.onHoverSound;
                        
        [SerializeField][SoundReference]
        private string onIncorrectSound;
        public static string OnIncorrectSound => Instance.onIncorrectSound;
        
        [SerializeField][SoundReference]
        private string onCompleteMinorSound;
        public static string OnCompleteMinorSound => Instance.onCompleteMinorSound;  
              
        [SerializeField][SoundReference]
        private string onCompleteMajorSound;
        public static string OnCompleteMajorSound => Instance.onCompleteMajorSound;
        [SerializeField] [SoundReference] 
        private string answersListShowSound;

        public static string AnswersListShowSound => Instance.answersListShowSound;
        
        [SerializeField][SoundReference]
        private string endOfScenarioSound;
        public static string EndOfScenarioSound => Instance.endOfScenarioSound;
        
        [SerializeField][SoundReference]
        private string startScenario;
        public static string StartScenario => Instance.startScenario;
        
        [SerializeField][SoundReference]
        private string objectFadeInEffectSound;
        public static string ObjectFadeInEffectSound => Instance.objectFadeInEffectSound;
        
        [SerializeField][SoundReference]
        private string objectFadeOutEffectSound;
        public static string ObjectFadeOutEffectSound => Instance.objectFadeOutEffectSound;
        
        [Header("Interaction Global Sounds")]
        [Tooltip("Plays when object grabbed by player")]
        [SerializeField][SoundReference]
        private string handGrabbedSound;
        public static string HandGrabbedSound => Instance.handGrabbedSound;
        
        [Tooltip("Plays when object released by player")]
        [SerializeField][SoundReference]
        private string handReleasedSound;
        public static string HandReleasedSound => Instance.handReleasedSound;
        
        [Tooltip("Plays when object is placed into a socket")]
        [SerializeField][SoundReference]
        private string socketedSound;
        public static string SocketedSound => Instance.socketedSound;
        
        [Tooltip("Plays when object is removed from a socket")]
        [SerializeField][SoundReference]
        private string removedFromSocketSound;
        public static string RemovedFromSocketSound => Instance.removedFromSocketSound;
        
        [Tooltip("Plays when held object is activated")]
        [SerializeField][SoundReference]
        private string activatedStartSound;
        public static string ActivatedStartSound => Instance.activatedStartSound;
        
        [Tooltip("Plays after the activated start sound for as long as it is activated")]
        [SerializeField][SoundReference]
        private string activatedLoopSound;
        public static string ActivatedLoopSound => Instance.activatedLoopSound;
        
        [Tooltip("This is the amount before the end of the activated start sound that the loop sound will start")]
        [SerializeField][Min(0)]
        private float activatedStartLoopOverlapTime;
        public static float ActivatedStartLoopOverlapTime => Instance.activatedStartLoopOverlapTime;
        
        [Tooltip("Plays when held object is deactivated")]
        [SerializeField][SoundReference]
        private string deactivatedSound;
        public static string DeactivatedSound => Instance.deactivatedSound;
        
        [Tooltip("Plays when object is positioned or returned to start/table")]
        [SerializeField][SoundReference]
        private string placedSound;
        public static string PlacedSound => Instance.placedSound;
        
        [Tooltip("Plays when triggered by a predetermined event related to the object")]
        [SerializeField][SoundReference]
        private string customInteractionSound;
        public static string CustomInteractionSound => Instance.customInteractionSound;
        
        [Tooltip("Event that will trigger the object placed sound")]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string placedSoundTriggerEvent;
        public static string PlacedSoundTriggerEvent => Instance.placedSoundTriggerEvent;
        
        [Tooltip("Event that will trigger the object custom interaction sound")]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string customInteractionSoundTriggerEvent;
        public static string CustomInteractionSoundTriggerEvent => Instance.customInteractionSoundTriggerEvent;
        
        [Tooltip("If object is a button or switch and the player presses/moves it, this sound plays")]
        [SerializeField][SoundReference]
        private string pressedSound;
        public static string PressedSound => Instance.pressedSound;
        
        [Space]
        [Header("Teleport")]
        [SerializeField][SoundReference]
        private string playerTeleportPullBackSound;
        public static string PlayerTeleportPullBackSound => Instance.playerTeleportPullBackSound;

        [SerializeField][SoundReference]
        private string playerTeleportFinishedSound;
        public static string PlayerTeleportFinishedSound => Instance.playerTeleportFinishedSound;
        
        [Space]
        [Header("World tooltip")]
        [SoundReference]
        [SerializeField] private string sfxWorldTooltipShow;
        public static string SfxWorldTooltipShow => Instance.sfxWorldTooltipShow;

        [SoundReference]
        [SerializeField] private string sfxWorldTooltipHide;
        public static string SfxWorldTooltipHide => Instance.sfxWorldTooltipHide;
        
        [Space]
        [Header("Scoring")]
        [SerializeField] [SoundReference] 
        private string scoringSystemMistakeSound;
        public static string ScoringSystemMistakeSound => Instance.scoringSystemMistakeSound;
        
        [SerializeField] [SoundReference] 
        private string scoringSystemCriticalMistakeSound;
        public static string ScoringSystemCriticalMistakeSound => Instance.scoringSystemCriticalMistakeSound;
        
        [SerializeField] [SoundReference] 
        private string scoringSystemOnScorableTaskSound;
        public static string ScoringSystemOnScorableTaskSound => Instance.scoringSystemOnScorableTaskSound;
        
        [SerializeField][ReadOnly]
        private SerializableDictionary<string, string> soundGUIDToPathTable = new ();

        public static bool TryGetPathFromReference(string soundReference, out string path)
        {
            AudioGlobalSettings instance = Instance;
            if (instance == null)
            {
                path = string.Empty;
                return false;
            }

            return instance.soundGUIDToPathTable.TryGetValue(soundReference, out path);
        }
        
#if UNITY_EDITOR
        public const string EDITOR_LDX_SPEAKER_ICON_PATH = "Packages/com_ldx_framework/Editor/Assets/Art/Sprites/ldx_speaker_icon.png";
        
        [SettingsProvider]
        public static SettingsProvider DisplayAudioSettings()
        {
            return CreateGlobalSettingsProvider("Project/LDX/Systems/Audio");
        }
                
        public static void EDITOR_HighlightAudioGlobalSettingsFile()
        {
            Selection.activeObject = Instance;
        }
        
        public static void CheckValidOrCreateSoundsPath()
        {
            if (!AssetDatabase.IsValidFolder(SOUNDS_ASSET_PATH))
            {
                AssetDatabase.CreateFolder("Assets/Resources", "Sounds");
            }
            
            if (!AssetDatabase.IsValidFolder(FRAMEWORK_SOUNDS_ASSET_PATH))
            {
                string[] parts = FRAMEWORK_SOUNDS_ASSET_PATH.Split('/');
                string current = parts[0];
                for(int i = 1; i < parts.Length; i++)
                {
                    if(!AssetDatabase.IsValidFolder(Path.Combine(current, parts[i])))
                    {
                        AssetDatabase.CreateFolder(current, parts[i]);
                    }
                    current = Path.Combine(current, parts[i]);
                }
            }
        }
        
        public static void EDITOR_UpdateSoundGUIDToPathTable()
        {
            CheckValidOrCreateSoundsPath();
            
            AudioGlobalSettings instance = Instance;
            
            if (instance.soundManifest == null)
            {
                Debug.LogWarning("SoundManifest was not assigned in AudioGlobalSettings. Attempting to create one automatically...");
                
                SoundManifest manifest = AssetDatabase.LoadAssetAtPath<SoundManifest>(MANIFEST_PATH);
                
                if (manifest == null)
                {
                    // Ensure the 'Audio' directory exists within 'Resources'
                    string directory = Path.GetDirectoryName(MANIFEST_PATH); // "Assets/Resources/Audio"
                    if (!AssetDatabase.IsValidFolder(directory))
                    {
                        AssetDatabase.CreateFolder("Assets/Resources", "Audio");
                    }

                    // Create the new manifest asset
                    manifest = CreateInstance<SoundManifest>();
                    AssetDatabase.CreateAsset(manifest, MANIFEST_PATH);
                    Debug.Log($"Successfully created SoundManifest at: {MANIFEST_PATH}");
                }
                else
                {
                    Debug.Log($"Found existing SoundManifest at: {MANIFEST_PATH}");
                }
                
                AssetDatabase.SaveAssets();
                AssetDatabase.Refresh();
                
                instance.soundManifest = manifest;
                EditorUtility.SetDirty(instance);
                Debug.Log($"Successfully created and assigned SoundManifest at: {MANIFEST_PATH}");
            }
            
            // Clear existing table
            instance.soundGUIDToPathTable.Clear();
            instance.soundManifest.ClearAllSounds();

            // Find all Sound assets in the sounds path
            string[] projectSoundsGuids = AssetDatabase.FindAssets($"t:{typeof(Sound).FullName}", new [] {SOUNDS_ASSET_PATH});
            string[] frameworkSoundsGuids = AssetDatabase.FindAssets($"t:{typeof(Sound).FullName}", new [] {FRAMEWORK_SOUNDS_ASSET_PATH});
            string[] allGuids = projectSoundsGuids.Concat(frameworkSoundsGuids).ToArray();

            // Format the paths in the readable manner and add them to the paths list
            foreach (string guid in allGuids)
            {
                string assetPath = AssetDatabase.GUIDToAssetPath(guid);
                string soundPath = EDITOR_GetSimplifiedPathFromAssetPath(assetPath);
                instance.soundGUIDToPathTable.Add(guid, soundPath);

                Sound soundAsset = AssetDatabase.LoadAssetAtPath<Sound>(assetPath);
                if (soundAsset != null)
                {
                    instance.soundManifest.AddSound(soundAsset);
                }
            }
            
            // Save the updated paths list
            EditorUtility.SetDirty(instance);
            EditorUtility.SetDirty(instance.soundManifest);
            AssetDatabase.SaveAssets();
            Debug.Log($"Updated Sound GUID Path table with {allGuids.Length} entries.");
        }
        
        /// <summary>
        /// If the path is "Assets/Resources/Sounds/path" or "Packages/.../Sounds/path", 
        /// where 'path' is itself a complete path inside the Sounds directory, returns just 'path'.
        /// </summary>
        public static string EDITOR_GetSimplifiedPathFromAssetPath(string assetPath)
        {
            if (assetPath.StartsWith(SOUNDS_ASSET_PATH))
            {
                return assetPath.Replace($"{SOUNDS_ASSET_PATH}/", string.Empty).Replace(".asset", string.Empty);
            }
            
            if (assetPath.StartsWith(FRAMEWORK_SOUNDS_ASSET_PATH))
            {
                return assetPath.Replace($"{FRAMEWORK_SOUNDS_ASSET_PATH}/", string.Empty).Replace(".asset", string.Empty);
            }
            
            return assetPath.Replace(".asset", string.Empty);
        }
        
        /// <summary>
        /// If the path is "Assets/Resources/Sounds/Path/FileOrFolder", where "FileOrFolder" is an
        /// asset or a folder, returns just "FileOrFolder" without any .asset suffix.
        /// </summary>
        public static string EDITOR_GetFileOrFolderNameFromAssetPath(string assetPath)
        {
            return Path.GetFileNameWithoutExtension(assetPath);
        }
        
        /// <summary>
        /// Get an asset path that AssetDatabase can use, from the given full disk path to the file
        /// </summary>
        /// <param name="diskPath"></param>
        /// <returns></returns>
        public static string EDITOR_GetAssetPathFromDiskPath(string diskPath)
        {
            int indexOfAssetsSubstring = diskPath.IndexOf("Assets/", StringComparison.Ordinal);
            if (indexOfAssetsSubstring != -1)
            {
                return diskPath.Remove(0, indexOfAssetsSubstring).Replace('\\', '/');
            }

            int indexOfPackagesSubstring = diskPath.IndexOf("Packages/", StringComparison.Ordinal);
            if (indexOfPackagesSubstring != -1)
            {
                return diskPath.Remove(0, indexOfPackagesSubstring).Replace('\\', '/');
            }
            
            return null;
        }

        /// <summary>
        /// Return two lists L1 and L2 of equal length n where i is in the interval [0, n) such that
        /// L1[i] is the guid corresponding to the Sound found at the path given by L2[i]
        /// </summary>
        public static void EDITOR_GetParallelGUIDAndPathLists(out List<string> guids, out List<string> paths)
        {
            guids = new List<string>();
            paths = new List<string>();
            
            AudioGlobalSettings instance = Instance;
            if (instance == null)
            {
                return;
            }

            SerializableDictionary<string, string> table = instance.soundGUIDToPathTable;
            foreach (string guid in table.Keys)
            {
                guids.Add(guid);
                paths.Add(table[guid]);
            }
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/AudioGlobalSettings.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/AudioRuntimeManager.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 46078abd9100b934599b67b9b2a04655
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.AudioSystem
{
    /// <summary>
    /// Class handling runtime management of sound instance creation & management, audio source pooling, playback & more.
    /// </summary>
    [SingletonSpawnable]
    public class AudioRuntimeManager : Singleton<AudioRuntimeManager>
    {
        #region Poolable Audio Source

        public class PoolableAudioSource
        {
            private readonly AudioSource audioSource;
            public AudioSource AudioSource => audioSource;
            public bool IsPlaying => audioSource.isPlaying;

            public PoolableAudioSource()
            {
                GameObject audioSourceGO = new ($"PoolableAudioSource")
                {
                    transform =
                    {
                        parent = Instance.transform
                    }
                };
                audioSource = audioSourceGO.AddComponent<AudioSource>();
                audioSource.playOnAwake = false;
            }

            public void DestroyGameObject()
            {
                Destroy(audioSource.gameObject);
            }
        }

        #endregion

        #region Properties & Fields

        private const float MIN_TIME_BETWEEN_SAME_SOUNDS = 0.1f;

        private readonly Dictionary<string, Sound> loadedSounds = new Dictionary<string, Sound>();
        private readonly Dictionary<string, int> instanceCounter = new Dictionary<string, int>();
        private readonly List<SoundInstance> allSoundInstances = new List<SoundInstance>();
        private List<PoolableAudioSource> audioSourcePool = new List<PoolableAudioSource>();
        private SoundInstance ambienceSoundInstance;
        private SoundInstance objectiveInterruptableSoundInstance;
        private float timeOfLastAudioSourcePoolCleaning;
        private float lastTimeAudioPlayed;
        private string lastSoundPathPlayed;

        #endregion

        #region Unity Event Functions

        /// <summary>
        /// Called in Singleton.Awake
        /// </summary>
        protected override void Init()
        {
            audioSourcePool = new List<PoolableAudioSource>(AudioGlobalSettings.AudioSourcePoolMaxSize);
            timeOfLastAudioSourcePoolCleaning = Time.time;
            if (AudioGlobalSettings.SoundManifest != null)
            {
                AudioGlobalSettings.SoundManifest.InitializeDictionary();
            }

            ScenarioManager.Instance.OnUnloadingScenarioOrLobby += HandleUnloadingScenarioOrLobby;
            LdxTrackingManager.OnAnyObjectiveComplete += HandleAnyObjectiveComplete;
        }

        private void OnDestroy()
        {
            StopAllCoroutines();
            StopAndReleaseAllInstances();
            ClearAudioSourcePool();

            if (ScenarioManager.IsValid)
            {
                ScenarioManager.Instance.OnUnloadingScenarioOrLobby -= HandleUnloadingScenarioOrLobby;
            }

            LdxTrackingManager.OnAnyObjectiveComplete -= HandleAnyObjectiveComplete;
        }

        private void LateUpdate()
        {
            UpdateInstances();

            if (Time.time - timeOfLastAudioSourcePoolCleaning >= AudioGlobalSettings.AudioSourcePoolCleaningInterval)
            {
                CleanUpAudioSourcePool();
                timeOfLastAudioSourcePoolCleaning = Time.time;
            }
        }

        #endregion

        #region Event Handlers
		
        private void HandleUnloadingScenarioOrLobby(ScenarioManager scenarioManager)
        {
            StopAndReleaseAllInstances();
        }

        private void HandleAnyObjectiveComplete(IObjective objective)
        {
            InterruptAndPlayObjectiveSound(AudioGlobalSettings.ObjectiveCompleteSoundRef);
        }
        
        public void InterruptAndPlayObjectiveSound(string soundReference, string eventOnFinish = "")
        {
            objectiveInterruptableSoundInstance?.StopFadeOutAndRelease();
            objectiveInterruptableSoundInstance = Audio.CreateSoundInstance(soundReference);

            if (objectiveInterruptableSoundInstance != null)
            {
                objectiveInterruptableSoundInstance.Play();
                objectiveInterruptableSoundInstance.Release();
            }
        }

        #endregion

        #region Instance Management

        public SoundInstance CreateSoundInstance(string soundPath)
        {
            Sound sound = LoadSound(soundPath);

            if (sound == null)
            {
                return null;
            }
            
            if (!sound.HasClips)
            {
                UnloadSound(soundPath);
                return null;
            }
            
            SoundInstance soundInstance = new (sound, soundPath);
            allSoundInstances.Add(soundInstance);
            IncrementInstanceCount(soundPath);
            lastSoundPathPlayed = soundPath;
            lastTimeAudioPlayed = Time.time;
            return soundInstance;
        }

        /// <summary>
        /// Returns the sound at the given path.
        /// If the sound is already loaded, we use it. If not, we load it first then use it.
        /// </summary>
        private Sound LoadSound(string soundPath)
        {
            if (loadedSounds.TryGetValue(soundPath, out Sound sound))
            {
                return sound;
            }
            
            SoundManifest manifest = AudioGlobalSettings.Instance.soundManifest;
            if (manifest != null)
            {
                string soundAssetName = Path.GetFileNameWithoutExtension(soundPath);
                sound = manifest.GetSound(soundAssetName);
            }

            if (sound == null)
            {
                sound = Resources.Load<Sound>($"Sounds/{soundPath}");
            }
            
            if (sound == null)
            {
                Debug.Log($"Couldn't load sound at path {soundPath}");
            }
            else
            {
                loadedSounds.Add(soundPath, sound);
            }
            
            return sound;
        }

        private void UnloadSound(string soundPath)
        {
            loadedSounds.Remove(soundPath);
        }

        private void IncrementInstanceCount(string soundPath)
        {
            if (!instanceCounter.TryAdd(soundPath, 1))
            {
                instanceCounter[soundPath] += 1;
            }
        }

        private void DecrementInstanceCount(string soundPath)
        {
            if (instanceCounter.ContainsKey(soundPath))
            {
                instanceCounter[soundPath] -= 1;
                if (instanceCounter[soundPath] <= 0)
                {
                    instanceCounter.Remove(soundPath);
                    UnloadSound(soundPath);
                }
            }
            else
            {
                Debug.LogError($"Trying to decrement loaded sound counter on {soundPath}, but it's not in the counter!");
            }
        }

        private void UnloadAllSounds()
        {
            foreach (string soundPath in instanceCounter.Keys)
            {
                UnloadSound(soundPath);
            }
            instanceCounter.Clear();
        }

        /// <summary>
        /// Update sound instance releases and sync them to tracked positions.
        /// </summary>
        private void UpdateInstances()
        {
            int i = 0;
            while (i < allSoundInstances.Count)
            {
                SoundInstance currentEntry = allSoundInstances[i];

                // If flagged for release and not playing, release it!
                if (currentEntry.FlaggedForRelease && !currentEntry.IsPlaying)
                {
                    if (!currentEntry.IsReleased)
                    {
                        DecrementInstanceCount(currentEntry.Path);
                        currentEntry.Release();
                    }

                    RemoveFromListFast(allSoundInstances, i);
                    continue;
                }

                // If 3D, update the position
                if (currentEntry.Is3D)
                {
                    currentEntry.UpdatePositionToTrackedTransform();
                }

                i++;
            }
        }
        
        /// <summary>
        /// Destroy and remove inactive audio sources from the pool.
        /// Will remove at most HALF of all the pooled audio sources.
        /// </summary>
        private void CleanUpAudioSourcePool()
        {
            int numRemoved = 0;
            int i = 0;
            int poolSize = audioSourcePool.Count;
            int halfPoolSize = poolSize / 2;
            while (i < poolSize && numRemoved < halfPoolSize)
            {
                PoolableAudioSource currentEntry = audioSourcePool[i];
                
                // Destroy and remove the audio source if not playing
                if (!currentEntry.IsPlaying)
                {
                    currentEntry.DestroyGameObject();
                    RemoveFromListFast(audioSourcePool, i);
                    numRemoved++;
                }
                else
                {
                    i++;
                }
            }
        }
        
        /// <summary>
        /// Remove the item at the given index from the list
        /// </summary>
        private void RemoveFromListFast<T>(List<T> list, int index)
        {
            int lastIndex = list.Count - 1;
            T entryToRemove = list[index];
            T lastEntry = list[lastIndex];
            list[index] = lastEntry;
            list[lastIndex] = entryToRemove;
            list.RemoveAt(lastIndex);
        }

        private void ClearAudioSourcePool()
        {
            foreach (PoolableAudioSource poolableAudioSource in audioSourcePool)
            {
                poolableAudioSource.DestroyGameObject();
            }
            audioSourcePool.Clear();
        }

        private void StopAndReleaseAllInstances()
        {
            foreach (SoundInstance soundInstance in allSoundInstances)
            {
                soundInstance.StopImmediateAndRelease();
            }
            allSoundInstances.Clear();
            UnloadAllSounds();
        }

        /// <summary>
        /// Get an audio source that isn't currently being used, or create a new one.
        /// Will only create a new one if doing so does not exceed the specified max pool size.
        /// Returns true if a valid poolable audio source was found.
        /// </summary>
        public bool TryGetValidPoolableAudioSource(out PoolableAudioSource poolableAudioSource)
        {
            poolableAudioSource = null;

            foreach (PoolableAudioSource existingPoolableAudioSource in audioSourcePool)
            {
                if (!existingPoolableAudioSource.IsPlaying)
                {
                    poolableAudioSource = existingPoolableAudioSource;
                    break;
                }
            }
            
            if (poolableAudioSource == null)
            {
                if (audioSourcePool.Count < AudioGlobalSettings.AudioSourcePoolMaxSize)
                {
                    poolableAudioSource = new PoolableAudioSource();
                    audioSourcePool.Add(poolableAudioSource);
                }
                else
                {
                    Debug.Log("Couldn't add another PoolableAudioSource to the AudioRuntimeManager pool: max pool size reached");
                }
            }
            
            return poolableAudioSource != null;
        }
        
        #endregion

        #region General Playback

        public void StopAllSounds(bool immediate = false)
        {
            foreach (SoundInstance soundInstance in allSoundInstances)
            {
                if (immediate)
                    soundInstance.StopImmediateAndRelease();
                else
                    soundInstance.StopFadeOutAndRelease();
            }
        }

        /// <summary>
        /// Used to get the length of the sound at the 0 index of the audio clips of that sound
        /// </summary>
        /// <param name="soundPath">Path to the sound being queried</param>
        /// <returns>A float representing the time in seconds of the duration of the sound's first audio clip</returns>
        public float SoundLength(string soundPath)
        {
            return LoadSound(soundPath).GetAudioClips()[0].length;
        }

        public void PlayOneShot(string soundPath,
            float? volume = null, 
            float? pitch = null, 
            float? stereoPan = null,
            bool allowOverlap = true)
        {
            if (allowOverlap)
            {
                if (soundPath == lastSoundPathPlayed && Time.time < lastTimeAudioPlayed + MIN_TIME_BETWEEN_SAME_SOUNDS)
                    return;
            }
            else
            {
                if (IsSoundPlaying(soundPath))
                {
                    return;
                }
            }
            
            CreatePlayOneShotReleaseInternal(soundPath, out SoundInstance _, volume, pitch, stereoPan);
        }
        
        public void PlayOneShot(string soundPath, 
            Vector3 position, 
            float? volume = null, 
            float? pitch = null, 
            float? stereoPan = null,
            bool allowOverlap = true)
        {
            if (allowOverlap)
            {
                if (soundPath == lastSoundPathPlayed && Time.time < lastTimeAudioPlayed + MIN_TIME_BETWEEN_SAME_SOUNDS)
                    return;
            }
            else
            {
                if (IsSoundPlaying(soundPath))
                {
                    return;
                }
            }
            
            CreatePlayOneShotReleaseInternal(soundPath, out SoundInstance soundInstance, volume, pitch, stereoPan);
            if (soundInstance == null)
            {
                return;
            }
            soundInstance.SetPosition(position);
        }
        
        public void PlayOneShot(string soundPath, 
            Transform transformToTrack,
            float? volume = null, 
            float? pitch = null, 
            float? stereoPan = null,
            bool allowOverlap = true)
        {
            if (allowOverlap)
            {
                if (soundPath == lastSoundPathPlayed && Time.time < lastTimeAudioPlayed + MIN_TIME_BETWEEN_SAME_SOUNDS)
                    return;
            }
            else
            {
                if (IsSoundPlaying(soundPath))
                {
                    return;
                }
            }
            
            CreatePlayOneShotReleaseInternal(soundPath, out SoundInstance soundInstance, volume, pitch, stereoPan);
            if (soundInstance == null)
            {
                return;
            }
            soundInstance.AttachToTransform(transformToTrack);
        }
        
        public void CreatePlayOneShotReleaseByReference(string soundReference, out SoundInstance soundInstance, string eventOnFinish = "")
        {
            soundInstance = Audio.CreateSoundInstance(soundReference);
            
            if (soundInstance == null)
            {
                return;
            }
            
            // Don't play loops!
            if (soundInstance.Sound.PlaybackMode == PlaybackMode.OneShot)
            {
                soundInstance.Play();
            }

            soundInstance.Release();
        }
        
         /// <summary>
        /// Internal method to handle playing a one-shot sound with overrides.
        /// This implementation assumes that the SoundInstance class provides methods for setting
        /// position and that the Sound class has a property to check for looping.
        /// </summary>
        private void CreatePlayOneShotReleaseInternal(
            string soundReference, 
            out SoundInstance soundInstance,
            float? volume = null, 
            float? pitch = null, 
            float? stereoPan = null)
        {
            soundInstance = CreateSoundInstance(soundReference);
            
            if (soundInstance == null)
            {
                return;
            }

            if (volume.HasValue)
            {
                soundInstance.SetVolume(volume.Value);
            }
            if (pitch.HasValue)
            {
                soundInstance.SetPitch(pitch.Value);
            }
            if (stereoPan.HasValue)
            {
                soundInstance.SetStereoPan(stereoPan.Value);
            }
            
            // Don't play loops!
            if (soundInstance.Sound.PlaybackMode == PlaybackMode.OneShot)
            {
                soundInstance.Play();
            }

            soundInstance.Release();
        }
         
        private bool IsSoundPlaying(string soundPath)
        {
            return allSoundInstances.Any(instance => instance.Path == soundPath && instance.IsPlaying);
        }

        #endregion

        #region Ambience
        
        /// <summary>
        /// Play the given Sound for ambience, crossfading between the prior ambience and the new one.
        /// The idea here is that ambience is either playing on loop as the "current" ambience, or is
        /// fading out to a hard stop. IE, there is a max of one ambience sound at any given time that
        /// does not have an instruction to fade out and be stopped.
        /// </summary>
        public void PlayAmbience(string soundPath)
        {
            SoundInstance newAmbienceInstance = CreateSoundInstance(soundPath);
            if (newAmbienceInstance != null && newAmbienceInstance.Sound.PlaybackMode == PlaybackMode.Loop)
            {
                ambienceSoundInstance?.StopFadeOutAndRelease();
                newAmbienceInstance.PlayWithFadeIn();
                ambienceSoundInstance = newAmbienceInstance;
            }
        }

        #endregion

        #region Editor
        
#if UNITY_EDITOR
        public Dictionary<string, Sound> EDITOR_GetLoadedSounds() => loadedSounds;
        public Dictionary<string, int> EDITOR_GetInstanceCounter() => instanceCounter;
        public List<SoundInstance> EDITOR_GetAllSoundInstances() => allSoundInstances;
        public List<PoolableAudioSource> EDITOR_GetAudioSourcePool() => audioSourcePool;
#endif
        
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/AudioRuntimeManager.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/BitCrushFilter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 950863bca50cbf14a8cefefcec6ab95d
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Systems.AudioSystem
{
    public class BitCrushFilter : MonoBehaviour
    {
        [SerializeField, Range(1, 16)] private int bitDepth = 16;
        public int BitDepth 
        { 
            get => bitDepth;
            set => bitDepth = value;
        }
        
        [SerializeField, Range(1, 32)] private int sampleRateReduction = 1;
        public int SampleRateReduction
        {
            get => sampleRateReduction;
            set => sampleRateReduction = value;
        }
        
        private void OnAudioFilterRead(float[] data, int channels)
        {
            float quantizationStep = 1f / (1 << bitDepth);
            float lastSample = 0f;
            int dataLength = data.Length;

            for (int i = 0; i < dataLength; i++)
            {
                if (i % sampleRateReduction == 0)
                {
                    lastSample = data[i];
                }
                else
                {
                    data[i] = lastSample;
                }

                data[i] = Mathf.Round(data[i] / quantizationStep) * quantizationStep;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/BitCrushFilter.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/LdxSoundManagerExtension.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 70a39b27541da134d8d070b29b07cd30
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.Sound;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Logging;
using UnityEngine;
using UnityEngine.Audio;
using Random = UnityEngine.Random;
using Debug = Ldx.Framework.Utilities.Logging.Debug;

namespace Ldx.Framework.Systems.AudioSystem
{
    /// <summary>
    /// Simple class to be able to see SoundReference-tagged strings correctly
    /// in an array in the inspector
    /// </summary>
    [Serializable]
    public class SoundOption
    {
        [SoundReference] public string soundReference;
    }
    
    /// <summary>
    /// Use this when sounds are being provided through the editor and not code.
    /// </summary>
    public class LdxSoundManagerExtension : MonoBehaviour
    {
        // Ask if this will break anything
        [SerializeField] private SoundOption[] soundOptionsNew;
        
        [Header("Backwards Compatibility")]
        [SerializeField] private AudioClip[] soundOptions;
        [SerializeField] private AudioMixerGroup audioMixer;
        
        private SoundManager soundManager => SoundManager.Instance;

        public void PlaySoundOneShotRandomFromList()
        {
            if (soundOptionsNew == null || soundOptionsNew.Length == 0)
            {
                return;
            }

            List<SoundOption> options = soundOptionsNew.Where(x => x != null).ToList();

            if (options.Count < 1)
            {
                return;
            }
            
            SoundOption soundOption = options[Random.Range(0, options.Count)];
            Audio.PlayOneShot(soundOption.soundReference, transform.position);
        }

        public void PlaySoundOneShotFromListAtIndex(int index)
        {
            if (soundOptions == null || soundOptions.Length == 0 || index < 0 || index > soundOptions.Length - 1)
            {
                return;
            }
            
            Audio.PlayOneShot(soundOptionsNew[index].soundReference, transform.position);
        }

        public void PlaySoundOnWindowAppear()
        {
            Audio.PlayOneShot(AudioGlobalSettings.OnWindowAppearSound);
        }

        public void PlaySoundOnWindowHide()
        {
            Audio.PlayOneShot(AudioGlobalSettings.OnWindowHideSound);
        }

        public void PlaySoundOnWindowSwap()
        {
            Audio.PlayOneShot(AudioGlobalSettings.OnWindowSwapSound);
        }

        public void PlaySoundOnClick()
        {
            Audio.PlayOneShot(AudioGlobalSettings.OnClickSound);
        }

        public void PlaySoundOnCorrect()
        {
            Audio.PlayOneShot(AudioGlobalSettings.OnCorrectSound);
        }

        public void PlaySoundOnIncorrect()
        {
            Audio.PlayOneShot(AudioGlobalSettings.OnIncorrectSound);
        }

        public void PlaySoundOnHover()
        {
            Audio.PlayOneShot(AudioGlobalSettings.OnHoverSound);
        }

        public void PlaySoundOnCompleteMinor()
        {
            Audio.PlayOneShot(AudioGlobalSettings.OnCompleteMinorSound);
        }

        public void PlaySoundOnCompleteMajor()
        {
            Audio.PlayOneShot(AudioGlobalSettings.OnCompleteMajorSound);
        }

        // This needs to be re-introduced as dozens of sounds/interactions no longer work that have been updated to recent
        // Framework versions.
        #region Backwards Compatibility

        /// <summary>
        /// This will play the sound selected in 3d sound at this object's location
        /// </summary>
        /// <param name="sound"></param>

        public void PlaySoundStereo(AudioClip sound)
        {
            SoundManager soundManager = SoundManager.Instance;
            if (sound == null || soundManager == null)
            {
                return;
            }
            
            soundManager.PlaySoundStereo(sound, transform.position, 1);
        }

        [ContextMenu("Play Sound From List")]
        public void PlaySoundStereoFromList()
        {
            SoundManager soundManager = SoundManager.Instance;
            
            if (soundManager == null)
            {
                return;
            }
            
            soundManager.PlaySoundStereo(ChooseSound(), transform.position, 1);

            if (audioMixer)
            {
                soundManager.ActiveSounds.Last().outputAudioMixerGroup = audioMixer;
            }
        }
        
        private AudioClip ChooseSound()
        {
            switch (soundOptions.Length)
            {
                case 0:
                    break;
                case 1:
                    return soundOptions[0];
                default:
                {
                    int num = Random.Range(0, soundOptions.Length);
                    return soundOptions[num];
                }
            }

            Debug.LogError(LogCategory.Audio,
                $"There are no sounds to choose from! Add sounds to the Sound List in your Sound Extension Component in Game Object {gameObject}.");
            return null;
        }

        public void PlaySoundMono(AudioClip sound)
        {
            if (soundManager != null)
            {
                soundManager.PlaySoundMono(sound);
            }
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/LdxSoundManagerExtension.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/LocalizedAudioClip.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: fb5c8fe051164d47bca6649d46c2e4a4
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Systems.Localization;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Systems.Sound
{
    /// <summary>
    /// Represents an audio clip with localization support, allowing multiple variations per language.
    /// </summary>
    [Serializable]
    public class LocalizedAudioClip
    {
        [SerializeField]
        private Language language = Language.English;
        public Language Language => language;

        [SerializeField]
        private List<AudioClip> audioClips = new List<AudioClip>();
        public List<AudioClip> AudioClips => audioClips;
        
        public AudioClip AudioClip => audioClips[Random.Range(0, audioClips.Count)];
        
        /// <summary>
        /// Initializes a new instance of the LocalizedAudioClip class with a single audio clip.
        /// </summary>
        /// <param name="l">The language of the audio clip.</param>
        /// <param name="clip">The audio clip.</param>
        public LocalizedAudioClip(Language l, AudioClip clip)
        {
            language = l;
            audioClips = new List<AudioClip>(){ clip };
        }
        
        /// <summary>
        /// Initializes a new instance of the LocalizedAudioClip class with multiple audio clips.
        /// </summary>
        /// <param name="l">The language of the audio clips.</param>
        /// <param name="clips">The list of audio clips.</param>
        public LocalizedAudioClip(Language l, List<AudioClip> clips)
        {
            language = l;
            audioClips = clips;
        }

        /// <summary>
        /// Sets the language for this audio clip.
        /// </summary>
        /// <param name="newLanguage">The new language to set.</param>
        public void SetLanguage(Language newLanguage)
        {
            language = newLanguage;
        }

        /// <summary>
        /// Sets the audio clips for this language.
        /// </summary>
        /// <param name="newClips">The new list of audio clips to set.</param>
        public void SetAudioClips(List<AudioClip> newClips)
        {
            audioClips = newClips;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/LocalizedAudioClip.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/PlacePointAudio.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5e2638e195e44372b060847e5414f738
# ASMDEF: ldx.framework.runtime.dll
# ---
using Autohand;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.AudioSystem
{
    public class PlacePointAudio : MonoBehaviour 
    {
        [SerializeField] private PlacePoint placePoint;
        [SerializeField] [SoundReference] private string highlightSound;
        [SerializeField] [SoundReference] private string unhighlightSound;
        [SerializeField] [SoundReference] private string placeSound;
        [SerializeField] [SoundReference] private string removeSound;

        private void OnValidate()
        {
            if (placePoint == null)
            {
                placePoint = GetComponent<PlacePoint>();
            }
        }

        private void OnEnable() 
        {
            placePoint.OnHighlight.AddListener(HandleHighlight);
            placePoint.OnStopHighlight.AddListener(HandleUnhighlight);
            placePoint.OnPlace.AddListener(HandlePlaced);
            placePoint.OnRemove.AddListener(HandleRemove);
        }

        private void OnDisable() 
        {
            placePoint.OnHighlight.RemoveListener(HandleHighlight);
            placePoint.OnStopHighlight.RemoveListener(HandleUnhighlight);
            placePoint.OnPlace.RemoveListener(HandlePlaced);
            placePoint.OnRemove.RemoveListener(HandleRemove);
        }

        private void HandleHighlight(PlacePoint _, Grabbable grabbable) 
        {
            Audio.PlayOneShot(highlightSound, transform);
        }
         
        private void HandleUnhighlight(PlacePoint _, Grabbable grabbable) 
        {
            Audio.PlayOneShot(unhighlightSound, transform);
        }

        private void HandlePlaced(PlacePoint _, Grabbable grabbable) 
        {
            Audio.PlayOneShot(placeSound, transform);
        }

        private void HandleRemove(PlacePoint _, Grabbable grabbable) 
        {
            Audio.PlayOneShot(removeSound, transform);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/PlacePointAudio.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/PlayAudioBetweenScenarios.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e4cd67c9b7f2f3140ab94037e3946396
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Systems.AudioSystem
{
    /// <summary>
    /// Place in scenario to play audio during loading screens before or after a scenario
    /// </summary>
    public class PlayAudioBetweenScenarios : MonoBehaviour
    {
        [Serializable]
        private enum PlayAtType
        {
            BeforeLoadingScenario = 0,
            AfterFinishingScenario
        }
        
        [IDSelection(LdxIdSettings.IdType.Scenario)]
        [SerializeField] 
        private string scenarioId;
        
        [SerializeField] 
        private PlayAtType playAt;

        [SoundReference] 
        [SerializeField]
        private string audioClip;

        [Min(0.0f)]
        [SerializeField] 
        private float delayTime;

        private SoundInstance soundInstance;

        private void Start()
        {
            soundInstance = Audio.CreateSoundInstance(audioClip);
            initAsync().Forget();

            async UniTaskVoid initAsync()
            {
                if (ScenarioManager.Instance == null)
                {
                    await UniTask.WaitUntil(() => ScenarioManager.Instance != null);
                }

                switch (playAt)
                {
                    case PlayAtType.BeforeLoadingScenario:
                        ScenarioManager.Instance.IsLoadingAndUnloadingBlocked = true;
                        PlayClipThenUnblockAsync().Forget();
                        break;
                    case PlayAtType.AfterFinishingScenario:
                        ScenarioManager.Instance.OnScenarioCompleted += HandleScenarioCompleted;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
        }
        
        private void OnDestroy()
        {
            if (ScenarioManager.IsValid)
            {
                ScenarioManager.Instance.OnScenarioCompleted -= HandleScenarioCompleted;
            }
            ScenarioManager.OnLoadingStarted -= HandleLoadingStarted;
        }

        // For after completion
        private void HandleScenarioCompleted(ScenarioManager scenarioManager, 
            ScenarioData.ScenarioEndBehaviourType _,
            IScenarioCompletionResult arg4)
        {
            scenarioManager.OnScenarioCompleted -= HandleScenarioCompleted;
            ScenarioManager.OnLoadingStarted += HandleLoadingStarted;
        }
        
        // For after completion
        private void HandleLoadingStarted(ScenarioLoadingParameters scenarioLoadingParameters)
        {
            ScenarioManager.OnLoadingStarted -= HandleLoadingStarted;
            
            // Not ideal that we can't infer this at the loading stage, but
            // this is to confirm that it's not restarting the same scenario
            if (scenarioLoadingParameters.ScenarioData.ScenarioID == scenarioId)
            {
                return;
            }

            ScenarioManager.Instance.IsLoadingAndUnloadingBlocked = true;
            PlayClipThenUnblockAsync().Forget();
        }

        private bool TryGetSoundDuration(out float duration)
        {
            duration = 0;
            List<AudioClip> clips = soundInstance?.Sound.GetAudioClips();
            AudioClip clip = clips!.FirstOrDefault();
            
            if (!clip)
            {
                return false;
            }

            duration = clip.length;
            return true;
        }

        private async UniTaskVoid PlayClipThenUnblockAsync()
        {
            await UniTask.Delay(delayTime.ToMilliseconds());
            
            try
            {
                if (!TryGetSoundDuration(out float duration))
                {
                    Debug.LogError($"Couldn't determine sound duration - {audioClip} on {name}", gameObject);
                    ScenarioManager.Instance.IsLoadingAndUnloadingBlocked = false;
                    return;
                }

                soundInstance?.Play();
                await UniTask.Delay(duration.ToMilliseconds());
            }
            catch (Exception e)
            {
                Debug.LogError($"Couldn't play sound with ID '{audioClip}'\n{e}", gameObject);
            }
            ScenarioManager.Instance.IsLoadingAndUnloadingBlocked = false;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/PlayAudioBetweenScenarios.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/PlayOnEnable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cc537b71cfdf4272b2fba29632a772bd
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Systems.AudioSystem
{
    public class PlayOnEnable : MonoBehaviour
    {
        [SerializeField] private AudioSource attentionAudioSource;
        [SerializeField] private bool skipFirstEnable = true;

        private bool isFirstEnable = true;
        
        private void OnValidate()
        {
            if (attentionAudioSource == null)
            {
                attentionAudioSource = GetComponent<AudioSource>();
            }
        }

        private void OnEnable()
        {
            if (skipFirstEnable && isFirstEnable)
            {
                isFirstEnable = false;
                return;
            }
            
            attentionAudioSource.Play();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/PlayOnEnable.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/SceneAudioManager.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c0a3f74cf9a83ae419f549bcc945de43
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Autohand;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.AudioSystem
{
    /// <summary>
    /// Scene-level audio hub that plays sounds for grab/release, place/remove, tracking events, and optional ambient-on-start.
    /// </summary>
    [DisallowMultipleComponent]
    public class SceneAudioManager : MonoBehaviour
    {
        [Serializable]
        public struct EventSound
        {
            [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
            [SerializeField] private string trackingEventId;
            [SoundReference] [SerializeField] private string soundReference;

            public string TrackingEventId => trackingEventId;
            public string SoundReference => soundReference;
        }

        [Serializable]
        public class ManagedSound
        {
            [SerializeField] private string description = "Description (optional)";

            [SerializeField] private Transform targetTransformFor3D;

            [SoundReference] [SerializeField] private string onGrab;
            [SoundReference] [SerializeField] private string onRelease;

            [SoundReference] [SerializeField] private string onPlace;
            [SoundReference] [SerializeField] private string onRemove;

            [Header("Tracking Events Sounds")]
            [SerializeField] private List<EventSound> eventSounds = new();

            [SerializeField] private bool isAmbientSound;
            [SoundReference] [SerializeField] private string ambientSound;

            [NonSerialized] public Grabbable Grabbable;
            [NonSerialized] public PlacePoint PlacePoint;
            [NonSerialized] public SoundInstance AmbientInstance;

            public string Description => description;
            public Transform TargetTransformFor3D => targetTransformFor3D;
            public string OnGrab => onGrab;
            public string OnRelease => onRelease;
            public string OnPlace => onPlace;
            public string OnRemove => onRemove;
            public List<EventSound> EventSounds => eventSounds;
            public bool IsAmbientSound => isAmbientSound;
            public string AmbientSound => ambientSound;
        }

        [Header("Managed Sounds")]
        [SerializeField] private List<ManagedSound> managedSounds = new();

        private readonly Dictionary<Grabbable, ManagedSound> grabbableToEntry = new();
        private readonly Dictionary<PlacePoint, ManagedSound> placePointToEntry = new();
        private readonly Dictionary<string, List<(ManagedSound entry, string sound)>> eventToBindings = new();

        private void OnEnable()
        {
            grabbableToEntry.Clear();
            placePointToEntry.Clear();

            for (int i = 0; i < managedSounds.Count; i++)
            {
                ManagedSound e = managedSounds[i];
                if (!e.TargetTransformFor3D)
                {
                    continue;
                }

                e.Grabbable = e.TargetTransformFor3D.GetComponent<Grabbable>();
                if (e.Grabbable)
                {
                    if (grabbableToEntry.TryAdd(e.Grabbable, e))
                    {
                        e.Grabbable.OnGrabEvent += HandleGrabbed;
                        e.Grabbable.OnReleaseEvent += HandleReleased;
                    }
                }

                e.PlacePoint = e.TargetTransformFor3D.GetComponent<PlacePoint>();
                if (e.PlacePoint)
                {
                    if (placePointToEntry.TryAdd(e.PlacePoint, e))
                    {
                        e.PlacePoint.OnPlace.AddListener(HandlePlaced);
                        e.PlacePoint.OnRemove.AddListener(HandleRemoved);
                    }
                }
            }
        }

        private void OnDisable()
        {
            foreach (KeyValuePair<Grabbable, ManagedSound> kvp in grabbableToEntry)
            {
                Grabbable g = kvp.Key;
                if (g)
                {
                    g.OnGrabEvent -= HandleGrabbed;
                    g.OnReleaseEvent -= HandleReleased;
                }
            }
            grabbableToEntry.Clear();

            foreach (KeyValuePair<PlacePoint, ManagedSound> kvp in placePointToEntry)
            {
                PlacePoint p = kvp.Key;
                if (p)
                {
                    p.OnPlace.RemoveListener(HandlePlaced);
                    p.OnRemove.RemoveListener(HandleRemoved);
                }
            }
            placePointToEntry.Clear();
        }

        private void Start()
        {
            eventToBindings.Clear();

            for (int i = 0; i < managedSounds.Count; i++)
            {
                ManagedSound e = managedSounds[i];

                if (e.IsAmbientSound && !string.IsNullOrEmpty(e.AmbientSound))
                {
                    e.AmbientInstance = Audio.CreateSoundInstance(e.AmbientSound);
                    if (e.AmbientInstance != null)
                    {
                        if (e.TargetTransformFor3D)
                        {
                            e.AmbientInstance.AttachToTransform(e.TargetTransformFor3D);
                        }
                        e.AmbientInstance.Play();
                    }
                }

                List<EventSound> list = e.EventSounds;
                if (list != null)
                {
                    for (int j = 0; j < list.Count; j++)
                    {
                        string id = list[j].TrackingEventId;
                        string snd = list[j].SoundReference;
                        if (string.IsNullOrEmpty(id) || string.IsNullOrEmpty(snd))
                        {
                            continue;
                        }

                        if (!eventToBindings.TryGetValue(id, out List<(ManagedSound, string)> bindings))
                        {
                            bindings = new List<(ManagedSound, string)>();
                            eventToBindings.Add(id, bindings);
                        }
                        bindings.Add((e, snd));
                    }
                }
            }

            if (eventToBindings.Count > 0)
            {
                LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
            }
        }

        private void OnDestroy()
        {
            if (eventToBindings.Count > 0 && LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }

            for (int i = 0; i < managedSounds.Count; i++)
            {
                ManagedSound e = managedSounds[i];
                if (e.AmbientInstance != null)
                {
                    e.AmbientInstance.StopFadeOutAndRelease();
                    e.AmbientInstance = null;
                }
            }
        }

        private void HandleGrabbed(Hand hand, Grabbable grabbable)
        {
            if (!grabbable)
            {
                return;
            }
            if (grabbableToEntry.TryGetValue(grabbable, out ManagedSound e))
            {
                PlayAt(e.OnGrab, e.TargetTransformFor3D);
            }
        }

        private void HandleReleased(Hand hand, Grabbable grabbable)
        {
            if (!grabbable)
            {
                return;
            }
            if (grabbableToEntry.TryGetValue(grabbable, out ManagedSound e))
            {
                PlayAt(e.OnRelease, e.TargetTransformFor3D);
            }
        }

        private void HandlePlaced(PlacePoint placePoint, Grabbable grabbable)
        {
            if (!placePoint)
            {
                return;
            }
            if (placePointToEntry.TryGetValue(placePoint, out ManagedSound e))
            {
                PlayAt(e.OnPlace, e.TargetTransformFor3D);
            }
        }

        private void HandleRemoved(PlacePoint placePoint, Grabbable grabbable)
        {
            if (!placePoint)
            {
                return;
            }
            if (placePointToEntry.TryGetValue(placePoint, out ManagedSound e))
            {
                PlayAt(e.OnRemove, e.TargetTransformFor3D);
            }
        }

        private void HandleTrackingEvent(string eventId)
        {
            if (string.IsNullOrEmpty(eventId))
            {
                return;
            }
            if (eventToBindings.TryGetValue(eventId, out List<(ManagedSound entry, string sound)> bindings))
            {
                for (int i = 0; i < bindings.Count; i++)
                {
                    (ManagedSound entry, string sound) b = bindings[i];
                    PlayAt(b.sound, b.entry.TargetTransformFor3D);
                }
            }
        }

        private static void PlayAt(string soundReference, Transform target)
        {
            if (string.IsNullOrEmpty(soundReference))
            {
                return;
            }

            if (target)
            {
                Audio.PlayOneShot(soundReference, target.position);
            }
            else
            {
                Audio.PlayOneShot(soundReference);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/SceneAudioManager.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/Sound.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c95d969bbd619ea4a958749fbf0af28c
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using UnityEngine.Audio;
using UnityEngine.Serialization;
using Debug = Ldx.Framework.Utilities.Logging.Debug;

namespace Ldx.Framework.Systems.AudioSystem
{
    /// <summary>
    /// Data class storing all information required for the audio system
    /// to know exactly how to play back a certain type of sound.
    /// </summary>
    [Serializable][CreateAssetMenu]
    public class Sound : ScriptableObject
    {
        // Pitch constants
        private const float MIN_PITCH_VALUE = 0.01f;
        private const float DEFAULT_PITCH_VALUE = 1.0f;
        private const float MAX_PITCH_VALUE = 3.0f;
        
        [SerializeField] private PlaybackMode playbackMode;
        public PlaybackMode PlaybackMode => playbackMode;
        
        [SerializeField] private RepeatMode repeatMode;
        public RepeatMode RepeatMode => repeatMode;
        
        [Tooltip("How long to fade in when using fade-in playback (not default)")]
        [SerializeField] private float startFadeTime = 0.25f;
        public float StartFadeTime => startFadeTime;

        [Tooltip("How long to fade out when using fade-out stopping (not default)")]
        [SerializeField] private float stopFadeTime = 0.25f;
        public float StopFadeTime => stopFadeTime;

        // Changed from array to list for better handling (Formerly Serialized for backward compatibility)
        [FormerlySerializedAs("audioClips")]
        [SerializeField] private List<AudioClip> audioClipsList = new();

        // Backward compatibility property, funnels old "audioClips" into new audioClipsList
        // Even though it's not used here, it serves a serialization function to ensure proper backward compatibility
        private AudioClip[] audioClips
        {
            get => audioClipsList?.ToArray() ?? Array.Empty<AudioClip>();
            set
            {
                if (value == null)
                {
                    audioClipsList?.Clear();
                    return;
                }
                
                audioClipsList = new List<AudioClip>(value);
            }
        }

        [SerializeField] private AudioMixerGroup overrideMixerGroup;
        public AudioMixerGroup OverrideMixerGroup => overrideMixerGroup;
        
        [SerializeField] private bool bypassEffects;
        public bool BypassEffects => bypassEffects;
        
        [SerializeField] private bool bypassListenerEffects;
        public bool BypassListenerEffects => bypassListenerEffects;
        
        [SerializeField] private bool bypassReverbZones;
        public bool BypassReverbZones => bypassReverbZones;
        
        [SerializeField][Range(0, 1)] private float volume = 1;
        public float Volume => Mathf.Clamp01(volume);
        
        [SerializeField][Range(MIN_PITCH_VALUE, MAX_PITCH_VALUE)] 
        private float pitch = DEFAULT_PITCH_VALUE;
        public float Pitch => Mathf.Clamp(pitch, MIN_PITCH_VALUE, MAX_PITCH_VALUE);
        
        [SerializeField][Range(-1, 1)] private float stereoPan;
        public float StereoPan => stereoPan;
        
        [SerializeField][Range(0, 1.1f)] private float reverbZoneMix = 1;
        public float ReverbZoneMix => reverbZoneMix;
        
        [SerializeField][Tooltip("0 = fully 2D, 1 = fully 3D")]
        [Range(0, 1)] private float spatialBlend;
        public float SpatialBlend => spatialBlend;

        [Header("3D Sound Settings")]
        [SerializeField][Range(0f, 5f)] private float dopplerLevel;
        public float DopplerLevel => dopplerLevel;
        
        [SerializeField][Range(0f, 360f)] private float spread;
        public float Spread => spread;
        
        [SerializeField] private AudioRolloffMode volumeRolloff;
        public AudioRolloffMode VolumeRolloff => volumeRolloff;

        [SerializeField] private float minDistance = 1.0f;
        public float MinDistance => minDistance;
        
        [SerializeField] private float maxDistance = 500.0f;
        public float MaxDistance => maxDistance;
        
        [ShowIf(nameof(volumeRolloff), Op.Equals, AudioRolloffMode.Custom)] 
        [SerializeField] private AnimationCurve customRolloffCurve = new (
            new Keyframe(0, 1),
            new Keyframe(1, 0)
        );
        public AnimationCurve CustomRolloffCurve => customRolloffCurve;

        [Header("Low Pass")]
        [SerializeField]
        private bool useLowPassFilter;
        public bool UseLowPassFilter => useLowPassFilter;

        [SerializeField]
        private float cutoffFrequency = 5000.0f;
        public float CutoffFrequency => cutoffFrequency;
        
        [SerializeField]
        private float lowpassResonanceQ = 1;
        public float LowpassResonanceQ => lowpassResonanceQ;
        
        [Header("High Pass")]
        [SerializeField]
        private bool useHighPassFilter;
        public bool UseHighPassFilter => useHighPassFilter;

        [SerializeField]
        private float highPassCutoffFrequency = 200.0f;
        public float HighPassCutoffFrequency => highPassCutoffFrequency;
    
        [SerializeField]
        private float highPassResonanceQ = 1;
        public float HighPassResonanceQ => highPassResonanceQ;

        [Header("Bit Crush")]
        [SerializeField]
        private bool useBitCrushFilter;
        public bool UseBitCrushFilter => useBitCrushFilter;

        [SerializeField]
        [Range(1, 16)]
        private int bitDepth = 16;
        public int BitDepth => bitDepth;

        [SerializeField]
        [Range(1, 32)]
        private int sampleRateReduction = 1;
        public int SampleRateReduction => sampleRateReduction;

        public bool HasClips => GetAudioClips() is { Count: > 0 };

        private void OnValidate()
        {
            pitch = Mathf.Clamp(pitch, MIN_PITCH_VALUE, MAX_PITCH_VALUE);
            
            maxDistance = Mathf.Max(minDistance, maxDistance);
        }

        public List<AudioClip> GetAudioClips()
        {
            return audioClipsList ?? new List<AudioClip>();
        }

        public void AddAudioClip(AudioClip newSound)
        {
            audioClipsList ??= new List<AudioClip>();

            if (newSound)
            {
                audioClipsList.Add(newSound);
            }
        }

        public void ClearAudioClips()
        {
            audioClipsList?.Clear();
        }

        public void SetCustomRolloffCurve(AnimationCurve curve)
        {
            customRolloffCurve = curve;
        }

        public void CopyFromSource(Sound source)
        {
            if (!source)
            {
                return;
            }
            
            volume = source.Volume;
            pitch = source.Pitch;
            stereoPan = source.StereoPan;
            reverbZoneMix = source.ReverbZoneMix;
            spatialBlend = source.SpatialBlend;
            volumeRolloff = source.VolumeRolloff;
            
            overrideMixerGroup = source.OverrideMixerGroup;            
            playbackMode = source.PlaybackMode;
            repeatMode = source.RepeatMode;
            
            minDistance = source.MinDistance;
            maxDistance = source.maxDistance;
            
            cutoffFrequency = source.CutoffFrequency;
            useLowPassFilter = source.UseLowPassFilter;
            lowpassResonanceQ = source.LowpassResonanceQ;
            
            useHighPassFilter = source.UseHighPassFilter;
            highPassCutoffFrequency = source.HighPassCutoffFrequency;
            highPassResonanceQ = source.HighPassResonanceQ;
            
            useBitCrushFilter = source.UseBitCrushFilter;
            bitDepth = source.BitDepth;
            sampleRateReduction = source.SampleRateReduction;
            
            spread = source.Spread;
            dopplerLevel = source.DopplerLevel;
            
            bypassReverbZones = source.BypassReverbZones;
            bypassEffects = source.BypassEffects;
            bypassListenerEffects = source.BypassListenerEffects;

            startFadeTime = source.startFadeTime;
            stopFadeTime = source.StopFadeTime;
            
            Debug.LogVerbose($"{name} has copied all sound settings from {source.name}");
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/Sound.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/SoundInstance.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d20f5f872568fa040bc58ac851369439
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using DG.Tweening;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Logging;
using UnityEngine;
using Debug = Ldx.Framework.Utilities.Logging.Debug;
using Random = UnityEngine.Random;

namespace Ldx.Framework.Systems.AudioSystem
{
    /// <summary>
    /// Managed class used for keeping track of Sounds that are actually playing
    /// and kept in memory, being stopped & started as desired, being sent new parameters,
    /// changing 3D position in the world etc.
    /// </summary>
    public class SoundInstance
    {
        private const float MIN_PITCH_VALUE = 0.01f;
        private const float MAX_PITCH_VALUE = 3.0f;
        
        public bool Is3D => Sound.SpatialBlend > 0;
        
        public bool IsPlaying => audioSource != null && audioSource.isPlaying;
        public bool FlaggedForRelease { get; private set; }
        public bool IsReleased { get; private set; }
        public Sound Sound { get; private set; }
        public string Path { get; private set; }
        public AudioSource audioSource { get; private set; }

        /// <summary>
        /// Sound parameter modifiers that can be adjusted at runtime
        /// </summary>
        private class SoundParameters
        {
            public float VolumeModifier { get; set; } = 1.0f;
            public float PitchModifier { get; set; }
            public float StereoPanOverride { get; set; } = float.MinValue;
            public float ReverbZoneMixOverride { get; set; } = float.MinValue;
            
            public bool HasStereoPanOverride => StereoPanOverride > float.MinValue;
            public bool HasReverbZoneMixOverride => ReverbZoneMixOverride > float.MinValue;
            
            public void Reset()
            {
                VolumeModifier = 1.0f;
                PitchModifier = 0.0f;
                StereoPanOverride = float.MinValue;
                ReverbZoneMixOverride = float.MinValue;
            }
        }

        private readonly SoundParameters parameters = new();
        private int rrIndex;
        private List<AudioClip> clipsRandom;
        private Transform trackedTransform;

        public SoundInstance(Sound sound, string path)
        {
            Sound = sound;
            Path = path;
            
            if (sound.RepeatMode is RepeatMode.Random)
            {
                List<AudioClip> audioClips = sound.GetAudioClips();
                clipsRandom = new List<AudioClip>(audioClips);
            }
            else
            {
                clipsRandom = new List<AudioClip>();
            }

            rrIndex = 0;
            audioSource = null;
            trackedTransform = null;
            FlaggedForRelease = false;
            IsReleased = false;
        }

        public void Release()   
        {
            FlaggedForRelease = true;

            if (IsPlaying)
            {
                return;
            }

            clipsRandom = null;
            rrIndex = 0;
            Sound = null;
            Path = null;
            
            if (audioSource)
            {
                audioSource.clip = null;
                audioSource.outputAudioMixerGroup = null;
                audioSource = null;
            }
            
            IsReleased = true;
        }

        public void AttachToTransform(Transform transformToTrack)
        {
            if (transformToTrack && transformToTrack.gameObject.activeInHierarchy)
            {
                trackedTransform = transformToTrack;
            }
            else
            {
                Debug.LogVerbose(LogCategory.Audio, $"Cannot attach sound to null or inactive transform");
                trackedTransform = null;
            }
        }

        public void UpdatePositionToTrackedTransform()
        {
            if (trackedTransform && trackedTransform.gameObject.activeInHierarchy)
            {
                SetPosition(trackedTransform.position);
            }
        }
        
        public void SetPosition(Vector3 position)
        {
            if (audioSource)
            {
                audioSource.transform.position = position;
            }
        }

        /// <summary>
        /// Applies a volume modifier to the sound.
        /// This is multiplied with the base volume.
        /// </summary>
        /// <param name="volumeModifier">The volume modifier (0-1 recommended, but can be higher)</param>
        public void SetVolume(float volumeModifier)
        {
            parameters.VolumeModifier = Mathf.Max(0f, volumeModifier);
            
            if (audioSource)
            {
                audioSource.volume = Sound.Volume * parameters.VolumeModifier;
            }
        }

        /// <summary>
        /// Sets the pitch of the sound.
        /// </summary>
        /// <param name="pitch">The pitch value (0.01 to 3, with 1 being normal pitch)</param>
        public void SetPitch(float pitch)
        {
            parameters.PitchModifier = pitch;

            if (audioSource)
            {
                float clampedPitch = Mathf.Clamp(pitch, MIN_PITCH_VALUE, MAX_PITCH_VALUE);
                audioSource.pitch = clampedPitch;
            }
        }
        
        /// <summary>
        /// Overrides the stereo pan of the sound.
        /// </summary>
        /// <param name="pan">The stereo pan value (-1 to 1)</param>
        public void SetStereoPan(float pan)
        {
            parameters.StereoPanOverride = Mathf.Clamp(pan, -1, 1);
            
            if (audioSource)
            {
                audioSource.panStereo = parameters.StereoPanOverride;
            }
        }
        
        /// <summary>
        /// Reset the stereo pan to the default value from the Sound asset.
        /// </summary>
        public void ResetStereoPan()
        {
            parameters.StereoPanOverride = float.MinValue;
            
            if (audioSource)
            {
                audioSource.panStereo = Sound.StereoPan;
            }
        }
        
        /// <summary>
        /// Overrides the reverb zone mix of the sound.
        /// </summary>
        /// <param name="mix">The reverb zone mix value (0 to 1.1)</param>
        public void SetReverbZoneMix(float mix)
        {
            parameters.ReverbZoneMixOverride = Mathf.Clamp(mix, 0, 1.1f);
            
            if (audioSource)
            {
                audioSource.reverbZoneMix = parameters.ReverbZoneMixOverride;
            }
        }
        
        /// <summary>
        /// Reset the reverb zone mix to the default value from the Sound asset.
        /// </summary>
        public void ResetReverbZoneMix()
        {
            parameters.ReverbZoneMixOverride = float.MinValue;
            
            if (audioSource)
            {
                audioSource.reverbZoneMix = Sound.ReverbZoneMix;
            }
        }
        
        /// <summary>
        /// Resets all parameters to their default values.
        /// </summary>
        public void ResetAllParameters()
        {
            parameters.Reset();
            
            if (audioSource)
            {
                ApplyParametersToAudioSource();
            }
        }

        public void Play() => PlayInternal(fadeIn: false);
        public void PlayWithFadeIn() => PlayInternal(fadeIn: true);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void PlayInternal(bool fadeIn)
        {
            if (IsReleased)
            {
                return;
            }
            
            if (trackedTransform && !trackedTransform.gameObject.activeInHierarchy)
            {
                Debug.LogVerbose(LogCategory.Audio,
                    $"Skipping PlayInternal - tracked GameObject {trackedTransform.name} is inactive");
                return;
            }

            if (audioSource)
            {
                audioSource.Stop();
            }
            else if (AudioRuntimeManager.Instance.TryGetValidPoolableAudioSource(
                         out AudioRuntimeManager.PoolableAudioSource poolableAudioSource))
            {
                audioSource = poolableAudioSource.AudioSource;
            }
            else
            {
                return;
            }

            audioSource.DOKill();
            SetUpAudioSource();
            
            audioSource.Play();
            if (fadeIn)
            {
                float targetVolume = Sound.Volume * parameters.VolumeModifier;
                audioSource.volume = 0;
                audioSource.DOFade(targetVolume, Sound.StartFadeTime);
            }
        }

        public void StopImmediate() => StopInternal(release: false, immediate: true);
        public void StopFadeOut() => StopInternal(release: false, immediate: false);
        public void StopImmediateAndRelease() => StopInternal(release: true, immediate: true);
        public void StopFadeOutAndRelease() => StopInternal(release: true, immediate: false);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void StopInternal(bool release, bool immediate)
        {
            if (!audioSource)
            {
                return;
            }
            
            audioSource.DOKill();
            
            if (immediate || IsReleased)
            {
                audioSource.Stop();
            }
            else
            {
                AudioSource audSrc = audioSource;
                audSrc.DOFade(0, Sound.StopFadeTime).OnComplete(() => audSrc.Stop());
            }
            
            if (release)
            {
                Release();
            }
        }

        private void SetUpAudioSource()
        {
            audioSource.clip = GetClip();
            if (Sound.OverrideMixerGroup)
            {
                audioSource.outputAudioMixerGroup = Sound.OverrideMixerGroup;
            }
                    
            audioSource.bypassEffects = Sound.BypassEffects;
            audioSource.bypassListenerEffects = Sound.BypassListenerEffects;
            audioSource.bypassReverbZones = Sound.BypassReverbZones;
            audioSource.playOnAwake = false;
            audioSource.loop = Sound.PlaybackMode is PlaybackMode.Loop;
            
            ApplyParametersToAudioSource();
            
            audioSource.spatialBlend = Sound.SpatialBlend;
            
            if (Sound.SpatialBlend > 0.01f)
            {
                audioSource.dopplerLevel = Sound.DopplerLevel;
                audioSource.spread = Sound.Spread;
                audioSource.rolloffMode = Sound.VolumeRolloff;
                audioSource.minDistance = Sound.MinDistance;
                audioSource.maxDistance = Sound.MaxDistance;
            }

            if (Sound.UseLowPassFilter)
            {
                AudioLowPassFilter lowPassFilter = audioSource.GetOrAddComponent<AudioLowPassFilter>();
                lowPassFilter.cutoffFrequency = Sound.CutoffFrequency;
                lowPassFilter.lowpassResonanceQ = Sound.LowpassResonanceQ;
            }
            else if(audioSource.TryGetComponent(out AudioLowPassFilter filter))
            {
                Object.Destroy(filter);
            }
            
            if (Sound.UseHighPassFilter)
            {
                AudioHighPassFilter highPassFilter = audioSource.GetOrAddComponent<AudioHighPassFilter>();
                highPassFilter.cutoffFrequency = Sound.HighPassCutoffFrequency;
                highPassFilter.highpassResonanceQ = Sound.HighPassResonanceQ;
            }
            else if(audioSource.TryGetComponent(out AudioHighPassFilter highPassFilter))
            {
                Object.Destroy(highPassFilter);
            }
            
            if (Sound.UseBitCrushFilter)
            {
                BitCrushFilter bitCrushFilter = audioSource.GetOrAddComponent<BitCrushFilter>();
                
                bitCrushFilter.BitDepth = Sound.BitDepth;
                bitCrushFilter.SampleRateReduction = Sound.SampleRateReduction;
            }
            else
            {
                if(audioSource.TryGetComponent(out BitCrushFilter filter))
                {
                    Object.Destroy(filter);
                }
            }
        }
        
        /// <summary>
        /// Applies the current parameter values to the audio source.
        /// </summary>
        private void ApplyParametersToAudioSource()
        {
            if (!audioSource)
            {
                return;
            }
                
            audioSource.volume = Sound.Volume * parameters.VolumeModifier;
            
            float pitch = parameters.PitchModifier != 0 ? parameters.PitchModifier : Sound.Pitch;
            audioSource.pitch = Mathf.Clamp(pitch, MIN_PITCH_VALUE, MAX_PITCH_VALUE);
            
            audioSource.panStereo = parameters.HasStereoPanOverride ? 
                parameters.StereoPanOverride : Sound.StereoPan;
            
            audioSource.reverbZoneMix = parameters.HasReverbZoneMixOverride ? 
                parameters.ReverbZoneMixOverride : Sound.ReverbZoneMix;
        }

        private AudioClip GetClip()
        {
            List<AudioClip> clips = Sound.GetAudioClips();
            
            if (clips.Count == 0)
            {
                return null;
            }
            
            if (clips.Count == 1)
            {
                return clips[0];
            }

            switch (Sound.RepeatMode)
            {
                case RepeatMode.Random:
                {
                    if (clipsRandom.Count <= 1)
                    {
                        return clips[0];
                    }
                    
                    int index = Random.Range(1, clipsRandom.Count);
                    AudioClip randomClip = clipsRandom[index];
                    AudioClip temp = clipsRandom[0];
                    clipsRandom[0] = randomClip;
                    clipsRandom[index] = temp;
                    return randomClip;
                }
                case RepeatMode.RoundRobin:
                {
                    if (rrIndex >= clips.Count)
                        rrIndex = 0;
                    AudioClip rrClip = clips[rrIndex];
                    rrIndex++;
                    return rrClip;
                }
                case RepeatMode.FirstOnly:
                default:
                {
                    return clips[0];
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/SoundInstance.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/SoundManifest.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 48674956b98e4b4691feb25f75bc18b4
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using UnityEngine;

namespace Ldx.Framework.Systems.AudioSystem
{
    /// <summary>
    /// A ScriptableObject that holds a direct reference to every Sound asset.
    /// This ensures they are included in a build and can be loaded at runtime from any location,
    /// bypassing the limitations of the Resources folder.
    /// </summary>
    [CreateAssetMenu(fileName = "SoundManifest", menuName = "LDX/Audio/Sound Manifest")]
    public class SoundManifest : ScriptableObject
    {
        [SerializeField] private List<Sound> allSounds = new List<Sound>();
        public List<Sound> AllSounds => allSounds;

        private readonly Dictionary<string, Sound> soundsBySoundAssetNameMap = new();

        public void InitializeDictionary()
        {
            soundsBySoundAssetNameMap.Clear();
            foreach (Sound soundAsset in allSounds)
            {
                soundsBySoundAssetNameMap.Add(soundAsset.name, soundAsset);
            }
        }
        
        public void ClearAllSounds()
        {
            allSounds.Clear();
        }

        public void AddSound(Sound sound)
        {
            allSounds.Add(sound);
        }

        public Sound GetSound(string soundAssetName)
        {
            return soundsBySoundAssetNameMap.GetValueOrDefault(soundAssetName);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/AudioSystem/SoundManifest.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/AutoHand/ParentingDispenserPoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4aa4156ac07555f419bb5ed95cd0556c
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Threading;
using Autohand;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using MarkupAttributes;
using UnityEngine;

namespace Ldx.Framework.Systems.AutoHand 
{
    /// <summary>
    /// Takes the DispenserPoint.cs script from AutoHand and changes the behaviour to have the dispensed object parent
    /// to the original parent of dispenseObject. This is useful for when you need the dispensed object to follow the
    /// position or scale of the parent. Also removes UnityEvents from inspector and code.
    /// </summary>
    public class ParentingDispenserPoint : MonoBehaviour
    {
        public static event Action<ParentingDispenserPoint, Grabbable> OnAnyItemGrabbed;
        
        [Tooltip("The object to be copied and dispensed")]
        [SerializeField] private Grabbable dispenseObject;
        [Tooltip("The maximum copies allowed to exist from this dispenser before they are destroyed or reset")]
        [SerializeField] private int maxCopies = 3;
        [Tooltip("The delay in seconds before the next dispense appears after the current dispense is taken")]
        [SerializeField] private float resetDelay;
        [Tooltip("Whether or not objects placed in the dispense point should be set to kinematic on placed or not")]
        [SerializeField] private bool disableBody;
        [HideIf("disableBody"), Tooltip("Whether or not objects placed in the dispense point should be set to kinematic on placed or not")]
        [SerializeField] private bool isKinematic = true;
        [Tooltip("If true the object will not just reset its position on reset it will be destroyed and a new copy will be placed. Less performant but important for things like ammo that should always respawn as new clips full")]
        [SerializeField] private bool destroyOnReset;
        
        [SerializeField] [SoundReference] private string placeObjectSound;

        private Grabbable currentDispense;
        private Grabbable lastDispense;
        private GameObject[] dispensePool;
        private int poolCount;
        private CancellationTokenSource cts;

        private void Start() 
        {
            dispensePool = new GameObject[maxCopies];
            dispenseObject.gameObject.SetActive(false);
            Dispense(true);
        }

        private void OnDisable() 
        {
            cts?.SafeCancelAndDispose();
            cts = null;
        }

        public void TryDispense()
        {
            if (currentDispense.body.transform.parent != dispenseObject.transform.parent)
            {
                Dispense();
            }
        }

        private void Dispense(bool ignoreDelay = false) 
        {
            if (cts != null)
                return;
            
            int poolIndex = (poolCount) % maxCopies;
            if(destroyOnReset) {
                Destroy(dispensePool[poolIndex]);
                dispensePool[poolIndex] = null;
            }

            if(poolCount < maxCopies || dispensePool[poolIndex] == null || dispensePool[poolIndex].activeInHierarchy == false)
                dispensePool[poolIndex] = Instantiate(dispenseObject.body.gameObject, dispenseObject.transform.parent);

            if(dispensePool[poolIndex].HasGrabbable(out Grabbable grab)) {
                grab.ForceHandsRelease();
                if(grab.placePoint != null)
                    grab.placePoint.Remove();
                if(grab.body == null)
                    grab.ActivateRigidbody();

                if(!disableBody && isKinematic)
                    grab.body.isKinematic = true;

                if(!grab.body.isKinematic) {
                    grab.body.linearVelocity = Vector3.zero;
                    grab.body.angularVelocity = Vector3.zero;
                }

                grab.OnGrabEvent += HandleObjectGrabbed;
                grab.originalParent = LdxTrackingManager.Instance.transform.transform;

                cts.SafeCancelAndDispose();
                cts = new CancellationTokenSource();
                DispenseResetDelay(grab, cts.Token, ignoreDelay).Forget();

                lastDispense = currentDispense;
                if(lastDispense != null)
                    lastDispense.OnGrabEvent -= HandleObjectGrabbed;
                currentDispense = grab;
            }
                
            poolCount++;
        }

        public void SetCurrentDispensedGrabbableState(bool canGrab)
        {
            //currentDispense.enabled = canGrab;
        }

        private void HandleObjectGrabbed(Hand hand, Grabbable grab) 
        {
            if(grab != null && isKinematic && grab.body != null)
                grab.body.isKinematic = false;
            grab.originalParent = LdxTrackingManager.Instance.transform.transform;
            OnAnyItemGrabbed?.Invoke(this, grab);
            Dispense();
        }

        private async UniTaskVoid DispenseResetDelay(Grabbable obj, CancellationToken token, bool ignoreDelay = false) 
        {
            obj.body.gameObject.SetActive(false);
            await UniTask.Delay(ignoreDelay ? 0 : resetDelay.ToMilliseconds(), cancellationToken: token);
            if (token.IsCancellationRequested)
                return;
            obj.body.gameObject.SetActive(true);
            if (lastDispense != null)
            {
                obj.IgnoreGrabbableCollisionUntilNone(lastDispense);
                foreach(Hand hand in lastDispense.GetHeldBy())
                    obj.IgnoreHandCollisionUntilNone(hand);
            }
            if(obj)
            {
                obj.DeactivateRigidbody();
            }
            cts.SafeCancelAndDispose();
            cts = null;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/AutoHand/ParentingDispenserPoint.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugConsole.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ce0bac1da3696864087a1e236bf8ee20
# ASMDEF: ldx.framework.runtime.dll
# ---
#if LDX_INTERNAL_DEBUG
using Ldx.Framework.Systems.InternalDebug.DebugFeatures;
#endif
using Ldx.Framework.Utilities;
using UnityEngine;
using Ldx.Framework.Utilities.Logging;
using TMPro;
using UnityEngine.UI;
using Debug = Ldx.Framework.Utilities.Logging.Debug;

namespace Ldx.Framework.Systems.InternalDebug
{
	public class DebugConsole : Singleton<DebugConsole>
	{
		private const float LARGE_FONT_MULTIPLIER = 1.5f;

		[SerializeField] private GameObject visualComponent;
		[SerializeField] private TextMeshProUGUI textPrefab;
		[SerializeField] private Transform parent;
		[SerializeField] private Color errorColor = Color.red;
		[SerializeField] private Color normalColor = Color.white;

		private float defaultFontSize;
		private float minLayoutSize;
		private TextMeshProUGUI lastLogEntry;

		protected override void Awake()
		{
			base.Awake();

			if (visualComponent != null)
			{
				HandleSetDebugState(false);
			}
		}

		private void OnEnable()
		{
			#if LDX_INTERNAL_DEBUG
			DebugConsoleFeature.OnSetDebugState += HandleSetDebugState;
			#endif
			Debug.OnDebugLog += HandleDebugLog;
		}

		private void OnDisable()
		{
			#if LDX_INTERNAL_DEBUG
			DebugConsoleFeature.OnSetDebugState -= HandleSetDebugState;
			#endif
			Debug.OnDebugLog -= HandleDebugLog;
		}

		private void Start()
		{
			defaultFontSize = textPrefab.fontSize;
			LayoutElement element = textPrefab.GetComponent<LayoutElement>();
			minLayoutSize = element == null ? 12 : element.minHeight;
		}
		
		
		private void HandleSetDebugState(bool state)
		{
			if (visualComponent != null)
				visualComponent.SetActive(state);
		}

		private void HandleDebugLog(LogVerbosity verbosity, string message)
		{
			TextMeshProUGUI newLogEntry = Instantiate(textPrefab, parent);
			newLogEntry.text = message;
			newLogEntry.color = verbosity == LogVerbosity.Error ? errorColor : normalColor;
			newLogEntry.transform.SetAsFirstSibling();

			if (lastLogEntry != null)
			{
				lastLogEntry.fontSize = defaultFontSize;
				SetLineSize(lastLogEntry, minLayoutSize);
			}

			newLogEntry.fontSize = defaultFontSize * LARGE_FONT_MULTIPLIER;
			SetLineSize(newLogEntry, minLayoutSize * 2f);
			lastLogEntry = newLogEntry;
		}

		private void SetLineSize(TextMeshProUGUI text, float size)
		{
			LayoutElement element = text.GetComponent<LayoutElement>();

			if (element == null)
				return;

			element.minHeight = size;
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugConsole.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 59c48d5e587447ce91c5e20f5c7df1c0
# ASMDEF: ldx.framework.runtime.dll
# ---
#if LDX_INTERNAL_DEBUG
using System;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.InternalDebug.DebugFeatures;
using UnityEngine;

namespace Ldx.Framework.Systems.InternalDebug
{
    public abstract class DebugFeature
    {
        public virtual float FeatureAvailableDelay => 1;
        
        public event Action<DebugUploadInfo> OnUploadRequest;
        public event Action<string> OnFeedbackReceived;
        
        public bool IsActive {get; protected set;}
        public virtual string DisplayName {get; protected set; }
        public virtual KeyCode? KeyCode { get; }
        public virtual bool HasButton => true;
        public bool IsAvailable { get; protected set; } = true;
        
        public virtual void Initialize(){}
        public virtual void PerformAction(){}

        public virtual void Tick()
        {
            if(!IsAvailable)
                return;
        }
        public virtual void Terminate(){}

        public virtual void SetFeatureAvailable(bool isAvailable)
        {
            IsAvailable = isAvailable;
        }
        
        protected void BroadcastUploadRequest(DebugUploadInfo info)
        {
            OnUploadRequest?.Invoke(info);
        }

        protected async UniTaskVoid DelayFeatureAvailable()
        {
            IsAvailable = false;
            await UniTask.Delay(TimeSpan.FromSeconds(FeatureAvailableDelay));
            IsAvailable = true;
        }
        
        protected void SendFeedback(string message)
        {
            OnFeedbackReceived?.Invoke(message);
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/CompleteObjectiveDebugFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: dbba69b036ce418a8d66fc4b0ef2bda0
# ASMDEF: ldx.framework.runtime.dll
# ---
#if LDX_INTERNAL_DEBUG
using Ldx.Framework.Systems.Objectives;
using UnityEngine;

namespace Ldx.Framework.Systems.InternalDebug.DebugFeatures
{
    public class CompleteObjectiveDebugFeature : DebugFeature
    {
        public override string DisplayName => "Complete objective";
        public override KeyCode? KeyCode { get; } = UnityEngine.KeyCode.F;

        public override void PerformAction()
        {
            base.PerformAction();
            ObjectiveSystem.Instance.ForceCompleteObjectiveStep();
            SendFeedback($"Objective has been completed");
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/CompleteObjectiveDebugFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/DebugConsoleFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 130732e05a1600a47b8b6008f48d6737
# ASMDEF: ldx.framework.runtime.dll
# ---
#if LDX_INTERNAL_DEBUG
using System;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Player;
using UnityEngine;

namespace Ldx.Framework.Systems.InternalDebug.DebugFeatures
{
	public class DebugConsoleFeature : DebugFeature
	{
		public static event Action<bool> OnSetDebugState;

		private const string PREFAB_PATH = "Debug/DebugConsole";
		private DebugConsole debugConsoleReference;
		public override KeyCode? KeyCode => UnityEngine.KeyCode.C;
		public override string DisplayName { get; protected set; } = "Debug Console: Hidden";

		public override void Initialize()
		{
			base.Initialize();
			SetDebugConsoleVisibility(false);

			initializePlayerDebugLogAsync().Forget();
			
			async UniTaskVoid initializePlayerDebugLogAsync()
			{
				await UniTask.WaitUntil(() => PlayerController.IsValid);
				
				debugConsoleReference = UnityEngine.Object.Instantiate(Resources.Load<DebugConsole>(path: PREFAB_PATH), parent: PlayerController.Instance.WaistController == null ? 
					PlayerController.Instance.HandsController.transform : 
					PlayerController.Instance.WaistController.transform);
				debugConsoleReference.transform.localPosition = Vector3.zero;
				UnityEngine.Object.DontDestroyOnLoad(debugConsoleReference);
			}
		}

		public override void PerformAction()
		{
			base.PerformAction();
			IsActive = !IsActive;
			string consoleStatusText = IsActive ? "Visible" : "Hidden";
			DisplayName = $"Debug Console: {consoleStatusText}";

			SetDebugConsoleVisibility(IsActive);
		}

		private void SetDebugConsoleVisibility(bool isVisible)
		{
			OnSetDebugState?.Invoke(isVisible);
		}

		public override void Terminate()
		{
			base.Terminate();
			SetDebugConsoleVisibility(false);
		}
	}
}
#endif
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/DebugConsoleFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/DebugScoringSystemFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d29aa8ed4b22cc54eab063071b424078
# ASMDEF: ldx.framework.runtime.dll
# ---
#if LDX_INTERNAL_DEBUG
using System;
using System.Collections.Generic;
using System.Text;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Scripts.Systems.Scoring;
using Ldx.Framework.Systems.Player;
using TMPro;
using UnityEngine;

namespace Ldx.Framework.Systems.InternalDebug.DebugFeatures
{
    public class DebugScoringSystemFeature : DebugFeature
    {
        private const string FEATURE_NAME = "Debug Scoring System";
        private const float DISPLAY_TIME = 20f;
        private const int MAX_MESSAGES = 10;
        private const float FONT_SIZE = .3f;

        private readonly Color defaultColour = Color.white;
        private readonly Vector2 tmpSizeDelta = new(2.5f, 1.25f);
        private readonly Vector3 localOffset = new(.58f, -0.3f, 1.25f);

        private GameObject messageRoot;
        private Transform messageParent;
        private TextMeshPro messageText;

        private readonly List<string> activeMessages = new();
        private readonly Dictionary<Color, string> usedColors = new();
        private readonly StringBuilder stringBuilder = new();

        private Camera mainCamera;
        private string cachedDefaultColorHex;

        public override string DisplayName { get; protected set; }

        public override void Initialize()
        {
            base.Initialize();
            cachedDefaultColorHex = ColorUtility.ToHtmlStringRGBA(defaultColour);
            UpdateDisplayName();
            CreateMessageRoot().Forget();
        }

        public override void PerformAction()
        {
            base.PerformAction();
            IsActive = !IsActive;
            UpdateDisplayName();
            if (IsActive)
            {
                SubscribeToEvents();
            }
            else
            {
                UnsubcribeFromEvents();
            }
        }

        public override void Terminate()
        {
            base.Terminate();
            UnsubcribeFromEvents();
        }

        public override void Tick()
        {
            base.Tick();
            UpdateRootPosition();
        }

        private void SubscribeToEvents()
        {
            ScoringSystem.OnReportScoringAction += HandleDebugReport;
            ScoringSystem.OnEvaluationResultsCreated += HandleEvaluationResult;
        }

        private void UnsubcribeFromEvents()
        {
            ScoringSystem.OnReportScoringAction -= HandleDebugReport;
            ScoringSystem.OnEvaluationResultsCreated -= HandleEvaluationResult;
        }

        private void UpdateDisplayName()
        {
            DisplayName = $"{FEATURE_NAME}: {(IsActive ? "Active" : "Inactive")}";
        }

        private async UniTaskVoid CreateMessageRoot()
        {
            await UniTask.WaitUntil(() => PlayerController.IsValid);
            mainCamera = PlayerController.Instance.MainCamera;
            messageRoot = new GameObject("ScoringSystemDebugMessageRoot");
            UnityEngine.Object.DontDestroyOnLoad(messageRoot);

            messageParent = new GameObject("Messages").transform;
            messageParent.SetParent(messageRoot.transform);
            messageParent.localPosition = localOffset;
            messageParent.localRotation = Quaternion.identity;

            messageText = CreateTextObject();
        }

        private TextMeshPro CreateTextObject()
        {
            GameObject tmpObject = new("DebugMessages");
            TextMeshPro tmp = tmpObject.AddComponent<TextMeshPro>();
            tmp.alignment = TextAlignmentOptions.TopLeft;
            tmp.fontSize = FONT_SIZE;
            tmp.color = defaultColour;
            tmp.textWrappingMode = TextWrappingModes.NoWrap;
            tmp.rectTransform.sizeDelta = tmpSizeDelta;
            tmp.raycastTarget = false;
            tmpObject.SetActive(true);
            tmp.transform.SetParent(messageParent, false);
            return tmp;
        }

        private void HandleDebugReport(ScoringSystem scoringSystem, ScoringData.ScoreRule rule, float scoreChange, float currentScore)
        {
            if (!IsActive) return;

            string timecode = DateTime.Now.ToString("HH:mm:ss");

            string message;
            Color color;

            if (rule != null)
            {
                color = rule.RuleEventType switch
                {
                    ScoringData.ScoreRule.EventType.ScorableTask => Color.green,
                    ScoringData.ScoreRule.EventType.Mistake or ScoringData.ScoreRule.EventType.CriticalMistake => Color.red,
                };

                message = rule.RuleEventType is ScoringData.ScoreRule.EventType.CriticalMistake
                    ? $"<b>[CRITICAL ERROR]</b>: {rule.EventName}": $"Event Triggered: {rule.EventName} ({rule.RuleEventType})";
                if (!Mathf.Approximately(scoreChange, 0f))
                {
                    float oldScore = currentScore - scoreChange;
                    message =
                        $"{message} - Score Updated: Old Score: {oldScore:F2}  New Score: {currentScore:F2} (Change: {scoreChange:+#;-#;0})";
                }
            }
            else
            {
                float oldScore = currentScore - scoreChange;
                message = !Mathf.Approximately(scoreChange, 0)
                    ? $"Score Updated: Old Score: {oldScore:F2}  New Score: {currentScore:F2} (Change: {scoreChange:+#;-#;0})"
                    : "Invalid scoring system report sent, no rule triggered and no score change.";

                color = scoreChange switch
                {
                    > 0f => Color.green,
                    < 0f => Color.red,
                    _ => scoringSystem.IsPassing ? Color.yellow : Color.red
                };
            }

            if (!usedColors.TryGetValue(color, out string messageColorHex))
            {
                messageColorHex = ColorUtility.ToHtmlStringRGBA(color);
                usedColors.Add(color, messageColorHex);
            }

            string formattedMessage =
                $"<color=#{cachedDefaultColorHex}>[{timecode}]</color> <color=#{messageColorHex}>{message}</color>";

            activeMessages.Add(formattedMessage);

            if (activeMessages.Count > MAX_MESSAGES)
            {
                activeMessages.RemoveAt(0);
            }

            RebuildDisplayText();
            StartRemoveMessageTask().Forget();
        }

        private void HandleEvaluationResult(ScoringSystem scoringSystem, ScoringSystem.EvaluationResult result)
        {
            if (!IsActive) return;

            string timecode = DateTime.Now.ToString("HH:mm:ss");
            Color resultColor = result.ScenarioResult == ScoringSystem.EvaluationResult.Result.Pass ? Color.green : Color.red;

            addEvaluationMessage($"Scenario Evaluation: Passed = {result.ScenarioResult}.", resultColor);
            addEvaluationMessage($"Score = {result.FinalDisplayScore:F2} {result.ScoreInterpretation}.", resultColor);

            foreach (string reason in result.FailureReasons)
            {
                addEvaluationMessage(reason, Color.red);
            }

            RebuildDisplayText();
            return;

            void addEvaluationMessage(string text, Color color)
            {
                if (!usedColors.TryGetValue(color, out string colorHex))
                {
                    colorHex = ColorUtility.ToHtmlStringRGBA(color);
                    usedColors.Add(color, colorHex);
                }

                string formattedMessage =
                    $"<color=#{cachedDefaultColorHex}>[{timecode}]</color> <color=#{colorHex}>{text}</color>";

                activeMessages.Add(formattedMessage);

                if (activeMessages.Count > MAX_MESSAGES)
                {
                    activeMessages.RemoveAt(0);
                }
            }
        }

        private void RebuildDisplayText()
        {
            stringBuilder.Clear();
            for (int i = 0; i < activeMessages.Count; i++)
            {
                if (i > 0) stringBuilder.AppendLine();
                stringBuilder.Append(activeMessages[i]);
            }

            if (messageText != null)
            {
                messageText.text = stringBuilder.ToString();
            }
        }

        private async UniTaskVoid StartRemoveMessageTask()
        {
            await UniTask.Delay(TimeSpan.FromSeconds(DISPLAY_TIME));
            if (activeMessages.Count > 0)
            {
                activeMessages.RemoveAt(0);
                RebuildDisplayText();
            }
        }

        private void UpdateRootPosition()
        {
            if (mainCamera != null && messageRoot != null)
            {
                messageRoot.transform.position = mainCamera.transform.position;
                messageRoot.transform.rotation = mainCamera.transform.rotation;
            }
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/DebugScoringSystemFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/NameSelectionDebugFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f345784396ba41ed8e9e2ac5646a6246
# ASMDEF: ldx.framework.runtime.dll
# ---
#if LDX_INTERNAL_DEBUG
using UnityEngine;

namespace Ldx.Framework.Systems.InternalDebug.DebugFeatures
{
    /// <summary>
    /// Internal feature. User name who sends debug.
    /// </summary>
    public class NameSelectionDebugFeature : DebugFeature
    {
        private const string KEY_DEBUG_USER = "DEBUG_SELECTED_USER";
        
        public DebugUsers CurrentUser { get; private set; }

        public override void Initialize()
        {
            base.Initialize();
            CurrentUser = (DebugUsers)PlayerPrefs.GetInt(KEY_DEBUG_USER, 0);
        }

        public void ChangeCurrentUser(DebugUsers chosenUser)
        {
            CurrentUser = chosenUser;
            PlayerPrefs.SetInt(KEY_DEBUG_USER, (int)chosenUser);
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/NameSelectionDebugFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/ScenarioAvgFpsLogDebugFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ed6166e9ac592a6449a4be936e4d6d10
# ASMDEF: ldx.framework.runtime.dll
# ---
#if LDX_INTERNAL_DEBUG
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;
using UnityEngine.Networking;
using Ldx.Framework.Systems.ScenarioManagement;
using Newtonsoft.Json;

namespace Ldx.Framework.Systems.InternalDebug.DebugFeatures
{
    public class ScenarioAvgFpsLogDebugFeature : DebugFeature
    {
        private class ScenarioFpsData
        {
            public string ScenarioName { get; set; }
            public float MinFps { get; set; }
            public float MaxFps { get; set; }
            public float AverageFps { get; set; }
        }
        
        private const float SAMPLE_INTERVAL = 5f; // In Seconds
        private const int SAMPLES_PER_SAVE = 6;
        private const string SAVE_FILENAME = "fps_log.json";
        private static readonly string SaveFilePath = Path.Combine(Application.persistentDataPath, SAVE_FILENAME);
        private const string WEBHOOK_URL = "https://prod-181.westus.logic.azure.com:443/workflows/a93316837f3046f39de9cd7444656e92/triggers/manual/paths/invoke?api-version=2016-06-01&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=6QOp0pU-e0SxOOEpjsoVpfTH6FsaGT2cglQNbDH6efE";
        
        private float timer;
        private string currentScenarioName;
        
        private readonly List<float> fpsSamples = new();
        private List<ScenarioFpsData> scenarioFpsHistory = new();
        
        public override bool HasButton => true;
        public override string DisplayName => $"Scenario FPS Logger: {(IsActive ? "Active" : "Inactive")}";

        public override void PerformAction()
        {
            IsActive = !IsActive;
            string status = IsActive ? "activated" : "deactivated";
            SendFeedback($"Scenario FPS Logger {status}.");
        }

        public override void Initialize()
        {
            ScenarioManager.OnLoadingFinished += HandleScenarioStarted;
            ScenarioManager.OnApplicationQuitting += HandleOnApplicationQuit;

            LoadExistingLog();
        }

        public override void Terminate()
        {
            ScenarioManager.OnLoadingFinished -= HandleScenarioStarted;
            ScenarioManager.OnApplicationQuitting += HandleOnApplicationQuit;
        }

        public override void Tick()
        {
            if (!IsActive || string.IsNullOrWhiteSpace(currentScenarioName))
                return;

            timer += Time.unscaledDeltaTime;
            if (timer >= SAMPLE_INTERVAL)
            {
                timer = 0f;
                float fps = 1f / Time.unscaledDeltaTime;
                fpsSamples.Add(fps);
                
                if (fpsSamples.Count >= SAMPLES_PER_SAVE)
                {
                    SaveCurrentScenarioData();
                }
            }
        }

        private void HandleScenarioStarted(ScenarioManager manager)
        {
            if (!manager.HasPreviousScenario)
            {
                if (File.Exists(SaveFilePath))
                {
                    SendFpsReport();
                }
            }
            
            currentScenarioName = manager.LoadedScenarioData?.ScenarioNameLocalized ?? "Unknown Scenario";
            fpsSamples.Clear();
            timer = 0f;
        }
        
        private void HandleOnApplicationQuit()
        {
            if (fpsSamples.Count > 0)
            {
                SaveCurrentScenarioData();
            }
            SendFpsReport();
        }
        
        private void SaveCurrentScenarioData()
        {
            float minFps = Mathf.Round(fpsSamples.Min());
            float maxFps = Mathf.Round(fpsSamples.Max());
            float avgFps = Mathf.Round(fpsSamples.Average());

            ScenarioFpsData existing = scenarioFpsHistory.FirstOrDefault(s => s.ScenarioName == currentScenarioName);
            if (existing != null)
            {
                existing.MinFps = minFps;
                existing.MaxFps = maxFps;
                existing.AverageFps = avgFps;
            }
            else
            {
                scenarioFpsHistory.Add(new ScenarioFpsData
                {
                    ScenarioName = currentScenarioName,
                    MinFps = minFps,
                    MaxFps = maxFps,
                    AverageFps = avgFps
                });
            }

            SaveLogToFile();
        }
        
        private void SaveLogToFile()
        {
            string json = JsonConvert.SerializeObject(scenarioFpsHistory, Formatting.Indented);
            File.WriteAllText(SaveFilePath, json);
        }
        
        private void LoadExistingLog()
        {
            if (File.Exists(SaveFilePath))
            {
                string json = File.ReadAllText(SaveFilePath);
                scenarioFpsHistory = JsonConvert.DeserializeObject<List<ScenarioFpsData>>(json) ?? new List<ScenarioFpsData>();
            }
        }
        
        private void SendFpsReport()
        {
            if (scenarioFpsHistory.Count == 0)
            {
                return;
            }

            string json = CreateTeamsAdaptiveCardJson(scenarioFpsHistory);
            
            using (UnityWebRequest request = new(WEBHOOK_URL, UnityWebRequest.kHttpVerbPOST))
            {
                byte[] bodyRaw = new System.Text.UTF8Encoding().GetBytes(json);
                request.uploadHandler = new UploadHandlerRaw(bodyRaw);
                request.downloadHandler = new DownloadHandlerBuffer();
                request.SetRequestHeader("Content-Type", "application/json");

                UnityWebRequestAsyncOperation operation = request.SendWebRequest();
                while (!operation.isDone) { } // Blocking if quitting using ldx's main menu
            }
            
            // Clear after sending
            File.Delete(SaveFilePath);
            scenarioFpsHistory.Clear();
            Debug.Log(" Scenario FPS Report Sent");
        }

        private string CreateTeamsAdaptiveCardJson(List<ScenarioFpsData> scenarioDataList)
        {
            string productName = Application.productName;
            string productVersion = Application.version;

            // Header row
            string headerRow = $@"
            {{
                ""type"": ""ColumnSet"",
                ""columns"": [
                    {{ ""type"": ""Column"", ""width"": ""2"", ""items"": [{{ ""type"": ""TextBlock"", ""text"": ""Scenario"", ""weight"": ""Bolder"" }}]}},
                    {{ ""type"": ""Column"", ""width"": ""2"", ""items"": [{{ ""type"": ""TextBlock"", ""text"": ""Lowest FPS"", ""weight"": ""Bolder"" }}]}},
                    {{ ""type"": ""Column"", ""width"": ""2"", ""items"": [{{ ""type"": ""TextBlock"", ""text"": ""Highest FPS"", ""weight"": ""Bolder"" }}]}},
                    {{ ""type"": ""Column"", ""width"": ""2"", ""items"": [{{ ""type"": ""TextBlock"", ""text"": ""Average FPS"", ""weight"": ""Bolder"" }}]}}
                ]
            }}";

            // Data rows
            string dataRows = string.Join(",", scenarioDataList.Select(data =>
                $@"
                {{
                    ""type"": ""ColumnSet"",
                    ""columns"": [
                        {{ ""type"": ""Column"", ""width"": ""2"", ""items"": [{{ ""type"": ""TextBlock"", ""text"": ""{EscapeJson(data.ScenarioName)}"" }}]}},
                        {{ ""type"": ""Column"", ""width"": ""2"", ""items"": [{{ ""type"": ""TextBlock"", ""text"": ""{data.MinFps}"" }}]}},
                        {{ ""type"": ""Column"", ""width"": ""2"", ""items"": [{{ ""type"": ""TextBlock"", ""text"": ""{data.MaxFps}"" }}]}},
                        {{ ""type"": ""Column"", ""width"": ""2"", ""items"": [{{ ""type"": ""TextBlock"", ""text"": ""{data.AverageFps}"" }}]}}
                    ]
                }}"
            ));

            return $@"{{
                ""type"": ""message"",
                ""attachments"": [
                    {{
                        ""contentType"": ""application/vnd.microsoft.card.adaptive"",
                        ""contentUrl"": null,
                        ""content"": {{
                            ""$schema"": ""https://adaptivecards.io/schemas/adaptive-card.json"",
                            ""type"": ""AdaptiveCard"",
                            ""version"": ""1.2"",
                            ""body"": [
                                {{
                                    ""type"": ""TextBlock"",
                                    ""text"": ""Scenario FPS Report"",
                                    ""weight"": ""Bolder"",
                                    ""size"": ""Large"",
                                    ""spacing"": ""Medium""
                                }},
                                {{
                                    ""type"": ""TextBlock"",
                                    ""text"": ""{EscapeJson(productName)}: Version #{EscapeJson(productVersion)}"",
                                    ""size"": ""Large"",
                                    ""spacing"": ""None""
                                }},
                                {headerRow},
                                {dataRows}
                            ]
                        }}
                    }}
                ]
            }}";
        }

        private static string EscapeJson(string text)
        {
            return text?.Replace("\\", "\\\\").Replace("\"", "\\\"") ?? "";
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/ScenarioAvgFpsLogDebugFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/ScreenshotDebugFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 05e81314ecdd42dc83c1239863967162
# ASMDEF: ldx.framework.runtime.dll
# ---
#if LDX_INTERNAL_DEBUG
using System.IO;
using Autohand.Demo;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;
using UnityEngine.XR;

namespace Ldx.Framework.Systems.InternalDebug.DebugFeatures
{
    /// <summary>
    /// Taking screenshot in playmode and send it to the teams channel
    /// </summary>
    public class ScreenshotDebugFeature : DebugFeature
    {
        private const string FILENAME = "Screenshot";
        private const float TIME_TO_DETECT = 2f;
        
        public override KeyCode? KeyCode => UnityEngine.KeyCode.G;
        public override string DisplayName { get; protected set; } = "Screenshot: Inactive";

        private float timer = 0f;
        
        private CommonButton trigger = CommonButton.triggerButton;

        private InputDevice rightController;
        private InputDevice leftController;

        public override void Initialize()
        {
            base.Initialize();
            rightController = InputDevices.GetDeviceAtXRNode(XRNode.RightHand);
            leftController = InputDevices.GetDeviceAtXRNode(XRNode.LeftHand);
        }
        
        public override void Tick()
        {
            base.Tick();
            if(!IsActive || !IsAvailable)
            {
                timer = 0.0f;
                return;
            }
            
            if (leftController.TryGetFeatureValue(XRHandControllerLink.GetCommonButton(trigger), 
                    out bool leftPressed)
                && rightController.TryGetFeatureValue(XRHandControllerLink.GetCommonButton(trigger),
                    out bool rightPressed))
            {
                if (rightPressed && leftPressed)
                {
                    timer += Time.deltaTime;

                    if (timer >= TIME_TO_DETECT)
                    {
                        TakeScreenshotAsync().Forget();
                        timer = 0f;
                    }
                }
                else
                {
                    timer = 0f;
                }
            }
        }

        public override void PerformAction()
        {
            base.PerformAction();
            IsActive = !IsActive;
            string screenshotStatusText = IsActive ? "Active" : "Inactive";
            DisplayName = $"Screenshot: {screenshotStatusText}";
        }

        private async UniTaskVoid TakeScreenshotAsync()
        {
            await UniTask.WaitForEndOfFrame(DebugToolController.Instance);
            string path = TakeScreenshot();
            BroadcastUploadRequest(new DebugUploadInfo(path, DebugUploadInfo.FileType.Image, completionCallback: HandleCompletedUpload));
        }

        private string TakeScreenshot()
        {
            string filename = $"{FILENAME}-{TimeUtilities.GetTimeNowEST().ToString("dMMMyyyy-HH'h'mm'm'")}.jpg";
            string path = Path.Combine(Application.persistentDataPath, filename);
            Texture2D img = ScreenCapture.CaptureScreenshotAsTexture();
            File.WriteAllBytes(path, img.EncodeToJPG());
            return path;
        }
        
        private void HandleCompletedUpload(bool obj)
        {
            SendFeedback($"Screenshot has been taken");
            DelayFeatureAvailable().Forget();
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/ScreenshotDebugFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/SendLogDebugFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e1e4b2562e734c8abdf2efcc67afe0ca
# ASMDEF: ldx.framework.runtime.dll
# ---
#if LDX_INTERNAL_DEBUG
using System.IO;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Systems.InternalDebug.DebugFeatures
{
    /// <summary>
    /// Send logs to the teams channel
    /// </summary>
    public class SendLogDebugFeature : DebugFeature
    {
        private const string FILENAME = "Log";
        public override string DisplayName => "Send Logs";
        public override KeyCode? KeyCode { get; } = UnityEngine.KeyCode.F;

        public override void PerformAction()
        {
            base.PerformAction();
            string path = WriteToInternalLog(GetFormattedLogContent());
            BroadcastUploadRequest(new DebugUploadInfo(path, DebugUploadInfo.FileType.Log, completionCallback: HandleCompletedUpload));
        }
        
        private string GetFormattedLogContent()
        {
            string result = "";
            foreach (Utilities.Logging.Debug.LogMessage log in Utilities.Logging.Debug.Logs)
            {
                if (log.LogType is not (LogType.Log or LogType.Error))
                {
                    continue;
                }

                string logIcon = log.LogType == LogType.Error ? "" : "";
                result += $"{logIcon}[{log.Time}]\n{log.Message}\n{log.StackTrace}\n------------\n";
            }
            
            return result;
        }
        
        private string WriteToInternalLog(string content)
        {
            string filename = $"{FILENAME}-{TimeUtilities.GetTimeNowEST().ToString("dMMMyyyy-HH'h'mm'm'")}.txt";
            string path = Path.Combine(Application.persistentDataPath, filename);
            File.WriteAllText(path, content);
            Debug.Log($"Log file saved to: {path}");
            return path;
        }

        private void HandleCompletedUpload(bool success)
        {
            DelayFeatureAvailable().Forget();
            string message;
            if (success)
            {
                message = $"Logs have been sent successfully";
            }
            else
            {
                message = $"Error while sending logs";
            }
            SendFeedback(message);
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/SendLogDebugFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/ShowFPSDebugFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6b5a1a40e40241ccb303a8670e9d85d4
# ASMDEF: ldx.framework.runtime.dll
# ---
#if LDX_INTERNAL_DEBUG
using System.Linq;
using UnityEngine;

namespace Ldx.Framework.Systems.InternalDebug.DebugFeatures
{
    /// <summary>
    /// Display FPS in playmode
    /// </summary>
    public class ShowFPSDebugFeature : DebugFeature
    {
        private const string FEATURE_NAME = "Show FPS";
        public override string DisplayName { get; protected set; } 
        
        public float AverageFps { get; private set; }
        public float HighestFps { get; private set; }
        public float LowestFps { get; private set; }

        private int frameRange = 60;

        private int[] fpsBuffer;
        private int fpsBufferIndex;
        private int sum = 0;

        public override void Initialize()
        {
            base.Initialize();
            UpdateName();
        }

        public override void Tick()
        {
            base.Tick();

            if (fpsBuffer == null || frameRange != fpsBuffer.Length)
            {
                InitializeBuffer();
            }
            CalculateFps();
        }

        private void UpdateName()
        {
            DisplayName = $"{FEATURE_NAME}: {(IsActive? "Active" : "Inactive")}";
        }
        
        public override void PerformAction()
        {
            base.PerformAction();
            IsActive = !IsActive;
            UpdateName();
            
            string feedbackStatusText = IsActive ? "Activated" : "Deactivated";
            SendFeedback($"FPS display has been {feedbackStatusText}");
        }

        private void InitializeBuffer()
        {
            if (frameRange <= 0)
            {
                frameRange = 1;
            }

            fpsBuffer = new int[frameRange];
            fpsBufferIndex = 0;
        }

        private void CalculateFps()
        {
            int newFps = (int)(1f / Time.unscaledDeltaTime);
            int oldestFps = fpsBuffer[fpsBufferIndex];
            fpsBuffer[fpsBufferIndex] = newFps;

            sum = sum - oldestFps + newFps;

            if (newFps > HighestFps)
                HighestFps = newFps;
            else if (oldestFps == HighestFps)
                HighestFps = fpsBuffer.Max();

            if (newFps < LowestFps)
                LowestFps = newFps;
            else if (oldestFps == LowestFps)
                LowestFps = fpsBuffer.Min();

            AverageFps = sum / frameRange;
            fpsBufferIndex = (fpsBufferIndex + 1) % frameRange;
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/ShowFPSDebugFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/UploadDebugFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f0e525e87ebe4ce9905d898321453a4b
# ASMDEF: ldx.framework.runtime.dll
# ---
#if LDX_INTERNAL_DEBUG
using System;
using System.IO;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Utilities.Extensions;

namespace Ldx.Framework.Systems.InternalDebug.DebugFeatures
{
    /// <summary>
    /// Internal feature. Send information to the specific channel.
    /// </summary>
    public class UploadDebugFeature : DebugFeature
    {
        private const int LOG_PREVIEW_LENGTH = 2800;
        
        private DebugWebHelper debugWebHelper;
        private string[] logTitles = {"New log", "New log alert!", "Loggy has a log for you!", "It's logging time ", 
            "It's a bird! It's a plane! (Jk, just a new log!)", "Master gave loggy a log! Loggy is a free bot!" };

        private string[] mediaTitles =
        {
            "New media", "Snappy has something for you!", "Did someone ask for new media?",
            "Snappy always delivers!", "Snap Snap Snap ", "Woah! What's going on in this snap?",
            "You sure like to snap! Here you go", "You sure you're not a director or something? Here's your snap!"
        };
        
        public override bool HasButton => false;

        public override void Initialize()
        {
            base.Initialize();
            debugWebHelper = new();
        }

        public void UploadFile(DebugUploadInfo info)
        {
            UploadFileAsync(info).Forget();
        }

        private async UniTaskVoid UploadFileAsync(DebugUploadInfo info)
        {
            bool success = false;
            switch (info.Type)
            {
                case DebugUploadInfo.FileType.Log:
                    success = await UploadAndSendLog(info);
                    break;
                case DebugUploadInfo.FileType.Image:
                    success = await UploadAndSendImage(info);
                    break;
                case DebugUploadInfo.FileType.Video:
                    break;
                case DebugUploadInfo.FileType.Other:
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            info.CompletionCallback?.Invoke(success);
            
            if (success)
            {
                if (info.DeleteAfter)
                {
                    File.Delete(info.FilePath);
                }
            }
        }

        private async UniTask<bool> UploadAndSendLog(DebugUploadInfo info)
        {
            string fileUrl = await debugWebHelper.UploadFileAndGetURLAsync(info.FilePath);
            if (fileUrl == null)
            {
                return false;
            }

            string title = logTitles.Random();
            string userName = info.ReportedBy;
            string logPreview = readLogPreview(info.FilePath)+"...";
            string fileName = Path.GetFileName(info.FilePath);
            
            return await debugWebHelper.SendLogToTeamsAsync(fileUrl, title,
                userName, logPreview, fileName);
             
            
            string readLogPreview(string filePath)
            {
                try
                {
                    using (StreamReader reader = new StreamReader(filePath))
                    {
                        char[] buffer = new char[LOG_PREVIEW_LENGTH];
                        int n = reader.ReadBlock(buffer, 0, LOG_PREVIEW_LENGTH);

                        return new string(buffer, 0, n);
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine("An error occurred: " + ex.Message);
                    return null;
                }
            }
        }

        public async UniTask<bool> UploadAndSendImage(DebugUploadInfo info)
        {
            await UniTask.Delay(1000);
            string imgUrl = await debugWebHelper.UploadFileAndGetURLAsync(info.FilePath);
            if (imgUrl == null)
            {
                return false;
            }
            
            string title = mediaTitles.Random();
            string userName = info.ReportedBy;
            string fileName = Path.GetFileName(info.FilePath);

            return await debugWebHelper.SendImageToTeamsAsync(imgUrl, title, userName, fileName);
        }
    }

    public class DebugUploadInfo
    {
        public enum FileType
        {
            Log = 0,
            Image,
            Video,
            Other
        }
        
        public string FilePath { get; }
        public FileType Type { get; }
        public bool DeleteAfter { get; }
        public string ReportedBy => DebugToolController.Instance.CurrentUsername;
        public Action<bool> CompletionCallback { get; set; }
        public string CompletionMessage { get; }

        public DebugUploadInfo(string filePath, FileType type, string completionMessage = null,
            Action<bool> completionCallback = null, bool deleteAfter = true)
        {
            FilePath = filePath;
            Type = type;
            CompletionMessage = completionMessage;
            CompletionCallback = completionCallback;
            DeleteAfter = deleteAfter;
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugFeatures/UploadDebugFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugToolController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 54ad67d72b0d42b98937ef4b7b8e3dde
# ASMDEF: ldx.framework.runtime.dll
# ---
#if LDX_INTERNAL_DEBUG
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Autohand.Demo;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.InternalDebug.DebugFeatures;
using Ldx.Framework.Systems.Player.Hands;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.XR;
using InputDevice = UnityEngine.XR.InputDevice;

namespace Ldx.Framework.Systems.InternalDebug
{
    /// <summary>
    /// Main internal debug tool controller
    /// </summary>
    public class DebugToolController : Singleton<DebugToolController>
    {
        private const int PATTERN_COUNT_TO_ACTIVATE = 5;
        private const int MS_TO_CLEAR_PATTERN_COUNTER = 3000;
        
        public static event Action OnDebugPatternActivated;
        public static event Action<string> OnFeedbackReceived;

        private CommonButton trigger = CommonButton.triggerButton;

        private InputDevice rightController;
        private InputDevice leftController;

        private bool leftWasReleased = true;
        private bool rightWasReleased = true;
        
        public List<DebugFeature> DebugFeatures { get;} = new();
        public string CurrentUsername
        {
            get
            {
                if (GetFeature<NameSelectionDebugFeature>() == null)
                    return DebugUsers.Other.ToString();
                
                return GetFeature<NameSelectionDebugFeature>().CurrentUser.ToString().SeparateWords();
            }
        }
        
        private HandSide? lastActivatedHand;
        private int patternSuccessCount;

        [RuntimeInitializeOnLoadMethod]
        private static void InitOnLoad()
        {
            try
            {
                DebugToolController controller = new GameObject(nameof(DebugToolController)).AddComponent<DebugToolController>();
                DontDestroyOnLoad(controller);
            }
            catch (Exception e)
            {
                Debug.LogError($"{nameof(DebugToolController)}: {e}");
            }
        }

        protected void Start()
        {
            rightController = InputDevices.GetDeviceAtXRNode(XRNode.RightHand);
            leftController = InputDevices.GetDeviceAtXRNode(XRNode.LeftHand);
            
            Assembly[] allAssemblies = AppDomain.CurrentDomain.GetAssemblies();
            Type debugFeatureType = typeof(DebugFeature);
            
            Type[] types = allAssemblies
                .SelectMany(assembly => assembly.GetTypes())
                .Where(t => debugFeatureType.IsAssignableFrom(t) && !t.IsInterface && !t.IsAbstract)
                .ToArray();
            
            foreach (Type type in types) 
            {
                DebugFeature feature = (DebugFeature)Activator.CreateInstance(type);
                feature.Initialize();
                feature.OnUploadRequest += HandleUploadRequest;
                feature.OnFeedbackReceived += HandleFeedbackReceived;
                DebugFeatures.Add(feature);
            }

            ClearPatternTimerAsync().Forget();
        }

        private void OnDestroy()
        {
            foreach(DebugFeature feature in DebugFeatures)
            {
                feature.OnUploadRequest -= HandleUploadRequest;
                feature.OnFeedbackReceived -= HandleFeedbackReceived;
                feature.Terminate();
            }
        }

        private void Update()
        {
            Keyboard keyboard = Keyboard.current;
            if (keyboard == null)
            {
                return;
            }
            
            foreach(DebugFeature feature in DebugFeatures)
            {
                if(feature.IsActive) 
                {
                    feature.Tick();
                }

                if (Application.isEditor)
                {
                    if (feature.KeyCode != null)
                    {
                        if(Enum.TryParse(feature.KeyCode.Value.ToString(), out Key keyToPress))
                        {
                            if(keyboard[keyToPress].wasPressedThisFrame)
                            {
                                feature.PerformAction();
                            }
                        }
                    }

                    if (keyboard.sKey.wasPressedThisFrame)
                    {
                        OnDebugPatternActivated?.Invoke();
                    }
                }
            }
            
            CheckOpenWindowPattern();
        }
        
        private async UniTaskVoid ClearPatternTimerAsync()
        {
            while (this != null)
            {
                await UniTask.Delay(MS_TO_CLEAR_PATTERN_COUNTER);
                patternSuccessCount = 0;
            }
        }

        private T GetFeature<T>() where T : DebugFeature
        {
            foreach (DebugFeature feature in DebugFeatures)
            {
                if (feature is T typedFeature)
                {
                    return typedFeature;
                }
            }

            return null;
        }

        private void CheckOpenWindowPattern()
        {
            HandSide? currentJustActivatedHand = null;

            if (leftController.TryGetFeatureValue(XRHandControllerLink.GetCommonButton(trigger), out bool leftPressed))
            {
                switch (leftPressed)
                {
                    case true when leftWasReleased:
                        leftWasReleased = false;
                        currentJustActivatedHand = HandSide.Left;
                        break;
                    case false:
                        leftWasReleased = true;
                        break;
                }
            }
            if (rightController.TryGetFeatureValue(XRHandControllerLink.GetCommonButton(trigger), out bool rightPressed))
            {
                switch (rightPressed)
                {
                    case true when rightWasReleased && currentJustActivatedHand == null:
                        rightWasReleased = false;
                        currentJustActivatedHand = HandSide.Right;
                        break;
                    case false:
                        rightWasReleased = true;
                        break;
                }
            }

            if(currentJustActivatedHand == null)
            {
                return;
            }
 
            if(currentJustActivatedHand != lastActivatedHand)
            {
                patternSuccessCount++;
                lastActivatedHand = currentJustActivatedHand;
            }
            else
            {
                patternSuccessCount = 0;
                lastActivatedHand = null;
            }
 
            if(patternSuccessCount >= PATTERN_COUNT_TO_ACTIVATE)
            {
                OnDebugPatternActivated?.Invoke();
                patternSuccessCount = 0;
            }
        }
        
        private void HandleUploadRequest(DebugUploadInfo info)
        {
            GetFeature<UploadDebugFeature>().UploadFile(info);
        }

        private void HandleFeedbackReceived(string message)
        {
            OnFeedbackReceived?.Invoke(message);
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugToolController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugUsers.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8d01cc72e4314831a78f9b809dda6f32
# ASMDEF: ldx.framework.runtime.dll
# ---
#if LDX_INTERNAL_DEBUG
namespace Ldx.Framework.Systems.InternalDebug
{
    /// <summary>
    /// Users who can send debugs to the teams channel
    /// </summary>
    public enum DebugUsers
    {
        Other = 0,
        Christophe,
        Tim,
        Brayden,
        Klea,
        BradM,
        BradL,
        Vlad,
        Jane,
        Mody,
    }
}
#endif
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugUsers.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugWebHelper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 99938c03cf68422ab907986e5b671fa3
# ASMDEF: ldx.framework.runtime.dll
# ---
#if LDX_INTERNAL_DEBUG
using System;
using Cysharp.Threading.Tasks;
using Newtonsoft.Json;
using UnityEngine;
using UnityEngine.Networking;

namespace Ldx.Framework.Systems.InternalDebug
{
    public class DebugWebHelper
    {
        public class FileUploadBody
        {
            [JsonProperty("file")]
            public string File { get; }
            [JsonProperty("filename")]
            public string FileName { get; }

            public FileUploadBody(string file, string fileName)
            {
                File = file;
                FileName = fileName;
            }
        }
        
        public class FileUploadResponse
        {
            [JsonProperty("message")]
            public string Message { get; }
            [JsonProperty("fileUrl")]
            public string FileURL { get; }

            public FileUploadResponse(string message, string fileURL)
            {
                Message = message;
                FileURL = fileURL;
            }
        }
        
        private const string API_GATEWAY_URL = "https://k5his2ftbl.execute-api.ca-central-1.amazonaws.com/upload-internal-file";
        private const string LOG_WEBHOOK_URL = "https://logicaldox.webhook.office.com/webhookb2/a213ddd7-425d-453b-9f67-d1fa0652dc36@c7492eb0-5af1-4beb-a126-ffbf0ba02352/IncomingWebhook/0091d9a9a44540fea5b45546f10b9be5/78012282-397f-4be3-97ef-02c33cbc76a3";

        private const string MEDIA_WEBHOOK_URL =
            "https://logicaldox.webhook.office.com/webhookb2/a213ddd7-425d-453b-9f67-d1fa0652dc36@c7492eb0-5af1-4beb-a126-ffbf0ba02352/IncomingWebhook/2d9d6b3cce8d4393b17a2e11fef1524b/78012282-397f-4be3-97ef-02c33cbc76a3";
        
        public async UniTask<bool> SendLogToTeamsAsync(string fileUrl, string titleMessage,
            string userName, string logPreview, string buttonPreviewName)
        {
            string json = @"{
                ""@type"": ""MessageCard"",
                ""@context"": ""http://schema.org/extensions"",
                ""summary"": ""#titleMessage"",
                ""themeColor"": ""0078D7"",
                ""title"": ""#titleMessage"",
                ""sections"": [
                    {
                        ""activityTitle"": ""Reported by: #userName"",
                        ""activitySubtitle"": ""#logPreview"",
                        ""markdown"": true
                    }
                ],
                ""potentialAction"": [
                    {
                        ""@type"": ""OpenUri"",
                        ""name"": ""View Full Log (#buttonPreviewName)"",
                        ""targets"": [
                            {
                                ""os"": ""default"",
                                ""uri"": ""#fileUrl""
                            }
                        ]
                    }
                ]
            }";

            json = json.Replace("#fileUrl", fileUrl)
                .Replace("#titleMessage", titleMessage)
                .Replace("#userName", userName)
                .Replace("#logPreview", logPreview)
                .Replace("#buttonPreviewName", buttonPreviewName);

            using (UnityWebRequest unityWebRequest =
                   new UnityWebRequest(LOG_WEBHOOK_URL, UnityWebRequest.kHttpVerbPOST))
            {
                byte[] jsonToSend = new System.Text.UTF8Encoding().GetBytes(json);
                unityWebRequest.uploadHandler = new UploadHandlerRaw(jsonToSend);
                unityWebRequest.downloadHandler = new DownloadHandlerBuffer();
                unityWebRequest.SetRequestHeader("Content-Type", "application/json");
                try
                {
                    await unityWebRequest.SendWebRequest();
                    return true;
                }
                catch (Exception e)
                {
                    Debug.LogError($"POST request failed: {e}");
                    return false;
                }
            }
        }

        public async UniTask<bool> SendImageToTeamsAsync(string imgUrl, 
            string titleMessage, string userName, string fileName)
        {
            string json = @"{
                ""@type"": ""MessageCard"",
                ""@context"": ""http://schema.org/extensions"",
                ""summary"": ""#titleMessage"",
                ""themeColor"": ""0076D7"",
                ""title"": ""#titleMessage"",
                ""sections"": [
                    {
                        ""activityTitle"": ""Reported by: #userName"",
                        ""images"": [
                            {
                                ""image"": ""#imgUrl""
                            }
                        ]
                    }
                ],
                ""potentialAction"": [
                    {
                        ""@type"": ""OpenUri"",
                        ""name"": ""View Image (#fileName)"",
                        ""targets"": [
                            {
                                ""os"": ""default"",
                                ""uri"": ""#imgUrl""
                            }
                        ]
                    }
                ]
            }
            ";
            json = json.Replace("#titleMessage", titleMessage)
                .Replace("#userName", userName)
                .Replace("#imgUrl", imgUrl)
                .Replace("#fileName", fileName);
            
            using (UnityWebRequest unityWebRequest = new UnityWebRequest(MEDIA_WEBHOOK_URL, UnityWebRequest.kHttpVerbPOST))
            {
                byte[] jsonToSend = new System.Text.UTF8Encoding().GetBytes(json);
                unityWebRequest.uploadHandler = new UploadHandlerRaw(jsonToSend);
                unityWebRequest.downloadHandler = new DownloadHandlerBuffer();
                unityWebRequest.SetRequestHeader("Content-Type", "application/json");
                try
                {
                    await unityWebRequest.SendWebRequest();
                    return true;
                }
                catch (Exception e)
                {
                    Debug.LogError($"POST request failed: {e}");
                    return false;
                }
            }
        }
        
        public async UniTask<string> UploadFileAndGetURLAsync(string filePath)
        {
            // Read the file bytes and convert to base64 string
            byte[] fileBytes = System.IO.File.ReadAllBytes(filePath);
            string fileBase64 = Convert.ToBase64String(fileBytes);
            string fileName = System.IO.Path.GetFileName(filePath);

            // Create JSON payload
            FileUploadBody payload = new FileUploadBody(fileBase64, fileName);
            string payloadJson = JsonConvert.SerializeObject(payload);

            // Create a UnityWebRequest for the POST request
            using (UnityWebRequest unityWebRequest = new UnityWebRequest(API_GATEWAY_URL, "POST"))
            {
                byte[] jsonToSend = new System.Text.UTF8Encoding().GetBytes(payloadJson);
            
                unityWebRequest.uploadHandler = new UploadHandlerRaw(jsonToSend);
                unityWebRequest.downloadHandler = new DownloadHandlerBuffer();
                unityWebRequest.SetRequestHeader("Content-Type", "application/json");

                try
                {
                    await unityWebRequest.SendWebRequest();
                    var response = JsonConvert.DeserializeObject<FileUploadResponse>(unityWebRequest.downloadHandler.text);
                    Debug.LogError("Uploaded to: " + response.FileURL);
                    return response.FileURL;
                }
                catch (Exception e)
                {
                    Debug.LogError("Error: " + e);
                    return null;
                }
            }
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/DebugWebHelper.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/FpsDisplay.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a9d38172d1aa4f0c9a0922997c4d73b9
# ASMDEF: ldx.framework.runtime.dll
# ---
using TMPro;
using UnityEngine;

namespace Ldx.Framework.Systems.InternalDebug
{
    public class FpsDisplay : MonoBehaviour
    {
        [SerializeField] private TextMeshProUGUI highestLabel;
        [SerializeField] private TextMeshProUGUI averageLabel;
        [SerializeField] private TextMeshProUGUI lowestLabel;

        [Space]
        [SerializeField] private Color highestFpsColor;
        [SerializeField] private Color lowestFpsColor;

        public void UpdateFps(float max, float avg, float min)
        {
            DisplayFps(highestLabel, max);
            DisplayFps(averageLabel, avg);
            DisplayFps(lowestLabel, min);
        }

        private void DisplayFps(TextMeshProUGUI label, float fps)
        {
            float normalizedFps = Mathf.Clamp01(fps / 99f);
            label.color = Color.Lerp(lowestFpsColor, highestFpsColor, normalizedFps);
            label.SetText($"{fps:00}fps");
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/InternalDebug/FpsDisplay.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/ILocalizable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c702d09e4b934f79a8b782b97a9cf100
# ASMDEF: ldx.framework.runtime.dll
# ---

namespace Ldx.Framework.Systems.Localization
{
    public interface ILocalizable
    {
        void ProcessLocalizationKeys(LocalizationTable table);
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/ILocalizable.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LanguageData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cb555d16fade49f8970e1fd9df174581
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;

namespace Ldx.Framework.Systems.Localization
{
    /// <summary>
    /// Manages language-specific data for localization, handling the storage and retrieval of localized strings.
    /// </summary>
    public class LanguageData : ScriptableObject
    {
        [SerializeField]
        private Language language;
        public Language Language => language;

        [SerializeField]
        private SerializableDictionary<string, string> localizationStringTable =
            new SerializableDictionary<string, string>();
        public SerializableDictionary<string, string> LocalizationStringTable => localizationStringTable;
        
        public bool ContainsKey(string key)
        {
            return LocalizationStringTable.ContainsKey(key);
        }
        
        /// <summary>
        /// Tries to get the localized string for the given key.
        /// </summary>
        /// <param name="key">The key for the localized string.</param>
        /// <param name="value">The localized string output if found.</param>
        /// <returns>True if the localized string was found, otherwise false.</returns>
        public bool TryGetLocalizedString(string key, out string value)
        {
            return localizationStringTable.TryGetValueOrDefault(key, key, out value);
        }
        
        /// <summary>
        /// Gets the localized string for a given key, or the key itself if not found.
        /// </summary>
        /// <param name="key">The key for the localized string.</param>
        /// <returns>The localized string or the key if not found.</returns>
        public string GetLocalizedString(string key)
        {
            if (localizationStringTable == null)
            {
                return key;
            }
            return localizationStringTable.GetValueOrDefault(key, key);
        }

#if UNITY_EDITOR
        
        /// <summary>
        /// Editor-only function to set the current language. Marks the object as dirty for persistence.
        /// </summary>
        /// <param name="newLanguage">The new language to be set.</param>
        public void EDITOR_SetLanguage(Language newLanguage)
        {
            language = newLanguage;
            EDITOR_SetDirtyAndSave();
        }
        
        /// <summary>
        /// Editor-only function to add a new language data entry. Marks the object as dirty for persistence.
        /// </summary>
        /// <param name="key">The key for the new entry.</param>
        /// <param name="result">The localized string for the new entry.</param>
        public void EDITOR_AddLanguageData(string key, string result)
        {
            localizationStringTable[key] = result;
            EDITOR_SetDirtyAndSave();
        }
        
        /// <summary>
        /// Editor-only function to copy language data from another LanguageData object. Marks the object as dirty for persistence.
        /// </summary>
        /// <param name="other">The LanguageData object to copy from.</param>
        public void EDITOR_CopyLanguageData(LanguageData other)
        {
            localizationStringTable = other.LocalizationStringTable;
            EDITOR_SetDirtyAndSave();
        }
        
        
        /// <summary>
        /// Marks the object as dirty and saves all changes to assets.
        /// </summary>
        public void EDITOR_SetDirtyAndSave()
        {
            if (this == null)
            {
                return;
            }
            
            UnityEditor.EditorUtility.SetDirty(this);
            UnityEditor.AssetDatabase.SaveAssets();
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LanguageData.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LanguageSelectionScreenBlocker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4a0e64a51e5305e45bd0fbbb062f40e4
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.UI;
using UnityEngine;
using Utilities.Blockers;

namespace Ldx.Framework.Systems.Localization
{
    public class LanguageSelectionScreenBlocker : MonoBehaviour, IBlocker
    {
        public event Action<IBlocker, bool> OnBlockChanged;
        public bool IsBlocked { get; private set; }

        private void Awake()
        {
            UIController.OnLanguageSelectionOpenClosed += HandleLanguageSelectionScreenShownHidden;
        }

        private void OnDestroy()
        {
            UIController.OnLanguageSelectionOpenClosed -= HandleLanguageSelectionScreenShownHidden;
        }

        private void HandleLanguageSelectionScreenShownHidden(UIController uiController, bool isOpen)
        {
            IsBlocked = isOpen;
            OnBlockChanged?.Invoke(this, IsBlocked);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LanguageSelectionScreenBlocker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LdxHelpers.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 99678abaecbbb10489059f957fe0bc47
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections;
using UnityEngine;


namespace Ldx.Framework.Systems.Localization
{
    public class LdxHelpers : MonoBehaviour
    {
        /*
        #region Custom Methods

        public static string TranslateString(string toTranslate, LocalizeStringEvent targetStringEvent)
        {
            if (!LdxSaveSystem.Instance.MultiLanguageSupport)
                return toTranslate;

            var reference = targetStringEvent.StringReference;
            //Try to find a key reference and translate.

            reference.TableEntryReference = toTranslate;
            return reference.GetLocalizedString();
            //}
            //Debug.Log($"No translation found for {toTranslate} but we see {reference.TableEntryReference}");
            //return toTranslate;
        }

        public List<string> TranslateListToLocale(List<string> newList, LocalizeStringEvent location)
        {
            List<string> tempList = new List<string>();
            foreach (var entry in newList)
            {
                tempList.Add(TranslateString(entry, location));
            }

            return tempList;
        }

        /// <summary>
        /// This will take in an already translated word and return it's key.
        /// </summary>
        /// <param name="translatedValue"></param>
        /// <param name="table"></param>
        /// <returns></returns>
        public static string TranslatedValueToKey(string translatedValue, StringTable table, LocalizedStringDatabase db)
        {
            if (LdxSaveSystem.Instance.MultiLanguageSupport)
                return translatedValue;

            StringTableEntry foundEntry = null;
            var english = LocalizationSettings.AvailableLocales.GetLocale("en");

            foreach (var entry in table.Values)
            {
                if (entry.LocalizedValue == translatedValue)
                {
                    foundEntry = entry;
                    break;
                }
            }

            if (foundEntry != null)
                return db.GetLocalizedString(foundEntry.KeyId, english);

            return "Translation not found";
        }



        public bool TranslateAndCheckEqual(LocalizeStringEvent loc, string a, string b)
        {
            string transA = TranslateString(a, loc);
            string transB = TranslateString(b, loc);
            return transA == transB;
        }

        /// <summary>
        /// This will translate a string in it's component location and return the new string.
        /// </summary>
        /// <param name="toTranslate"></param>
        /// <param name="targetStringLocation"></param>
        /// <returns></returns>
        public static string TranslateString(string toTranslate, Transform targetStringLocation)
        {
            var targetStringEvent = targetStringLocation.GetComponent<LocalizeStringEvent>();
            if (!targetStringEvent)
            {
                Debug.LogError(
                    $"You forgot to pass a transform with a targetStringEvent when passing {toTranslate}. Revisit this to translate correctly.");
                return "ERROR";
            }

            var reference = targetStringEvent.StringReference;
            reference.TableEntryReference = toTranslate;
            return reference.GetLocalizedString() == null? toTranslate : reference.GetLocalizedString();
        }

        public static string ReturnOriginalKey(string toTranslate, LocalizeStringEvent targetStringEvent)
        {
            var reference = targetStringEvent.StringReference;
            reference.TableEntryReference = toTranslate;
            return reference.TableEntryReference.Key;
        }
        
        #endregion
*/
        #region Coroutines

        static public IEnumerator MoveObject(Transform toMove, Vector3 Location, float time)
        {
            float curTime = 0f;
            var startingLoc = toMove.position;

            while (curTime < time)
            {
                toMove.position = Vector3.Lerp(startingLoc, Location, curTime / time);
                curTime += Time.deltaTime;
                yield return null;
            }
            toMove.position = Location;
        }
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LdxHelpers.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationEntry.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: edc856dfa66a4690a73ebaaf1e21321b
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Utilities.Serializable;

namespace Ldx.Framework.Systems.Localization
{
    /// <summary>
    /// Represents an entry in a localization system editor window for a specific key across multiple languages.
    /// </summary>
    /// <typeparam name="T">The type of the localized value.</typeparam>
    [Serializable]
    public class LocalizationEntry<T>
    {
        public string key;
        public SerializableDictionary<Language, T> languageValueSet;

        public LocalizationEntry(string key)
        {
            this.key = key;
            GenerateLanguageSet();
        }

        /// <summary>
        /// Generates a new set of language values, initializing all entries to their default values.
        /// </summary>
        private void GenerateLanguageSet()
        {
            languageValueSet = new SerializableDictionary<Language, T>();

            foreach (Language language in Enum.GetValues(typeof(Language)))
            {
                languageValueSet[language] = default(T);
            }
        }

        /// <summary>
        /// Retrieves the localized value for a specific language.
        /// </summary>
        /// <param name="language">The language for which to retrieve the value.</param>
        /// <returns>The localized value if found; otherwise, the default value for the type T.</returns>
        public T GetLanguageValue(Language language)
        {
            if (languageValueSet == null)
            {
                GenerateLanguageSet();
            }
            
            if (languageValueSet != null && languageValueSet.TryGetValue(language, out T value))
            {
                return value;
            }

            return default(T);
        }

        /// <summary>
        /// Updates the localized value for a specific language.
        /// </summary>
        /// <param name="language">The language for which to update the value.</param>
        /// <param name="newValue">The new value to set.</param>
        public void ChangeLanguageValue(Language language, T newValue)
        {
            if (languageValueSet == null)
            {
                GenerateLanguageSet();
            }

            if (languageValueSet != null)
            {
                languageValueSet[language] = newValue;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationEntry.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationGlobalSettings.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6ee938c42a024d77a42ace48c9a8106e
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Utilities;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Utilities.Attributes;
#if UNITY_EDITOR
using UnityEditor;
#endif
using UnityEngine;

namespace Ldx.Framework.Systems.Localization
{
    /// <summary>
    /// ScriptableObject that stores font and CSV location data
    /// </summary>
    [HasFrameworkDefault]
    public class LocalizationGlobalSettings : GlobalSettings<LocalizationGlobalSettings>, ILocalizable
    {
        [Serializable]
        public class LanguageInfo
        {
            public Language language;
            [LocalizationKey]
            public string languageName;
        }
        
        [SerializeField]
        private bool localizationEnabled;
        public static bool LocalizationEnabled => Instance.localizationEnabled;
        
        [ShowIf("localizationEnabled", Op.Equals, true)]
        [SerializeField]
        private bool showLanguageSelectionDialogue = true;

        public static bool ShowLanguageSelectionDialogue => IsValid
                                                            && LocalizationEnabled
                                                            && Instance.showLanguageSelectionDialogue;
        
        [Tooltip("Don't localize the language's names, it should be how it is")]
        [Space]
        [SerializeField]
        private List<LanguageInfo> languagesToInclude = new List<LanguageInfo>();
        public static List<Language> LanguagesToInclude => Instance.languagesToInclude.Select(x => x.language).ToList();

        [SerializeField]
        private List<LocalizationTable> localizationTables = new List<LocalizationTable>();
        public static List<LocalizationTable> LocalizationTables => Instance.localizationTables;

        [SerializeField]
        private string languageDataPath = "Localization/LanguageData/{0}";
        public static string LanguageDataPath => Instance.languageDataPath;
        public static string FullLanguageDataPath => $"Assets/Resources/{LanguageDataPath}.asset";

        [SerializeField]
        private string savePath = "Assets/Resources/Localization/Tables/{0}.asset";
        public static string SavePath => Instance.savePath;

        [Header("Objective system localization")]
        [SerializeField][LocalizationKey]
        private string objectiveStartedMessage;
        public static string ObjectiveStartedMessage => Instance.objectiveStartedMessage;

        [SerializeField]
        private DialogEventData.DialogInfo languageSelectionDialog;
        public static DialogEventData.DialogInfo LanguageSelectionDialog => Instance.languageSelectionDialog;

        public static List<string> GetAllLocalizationIds()
        {
            List<string> ids = new List<string>();

            foreach (LocalizationTable localizationTable in LocalizationTables)
            {
                foreach (LocalizationEntry<string> entry in localizationTable.TextLocalizationData.LocalizationEntries)
                {
                    ids.Add(entry.key);
                }
            }

            return ids;
        }
       
        public static List<LanguageInfo> GetAvailableLanguagesInfo()
        {
            return Instance.languagesToInclude;
        }

#if UNITY_EDITOR

        public static void EDITOR_RefreshLanguageDialog()
        {
            Instance.languageSelectionDialog.EDITOR_ClearAnswers();

            foreach (LanguageInfo languageInfo in GetAvailableLanguagesInfo())
            {
                Instance.languageSelectionDialog.EDITOR_AddAnswer(languageInfo.languageName, false);
            }
        }
        
        public static void EDITOR_EnableLocalization(bool setEnabled)
        {
            Instance.localizationEnabled = setEnabled;
            EditorUtility.SetDirty(Instance);
        }
        
        public static void EDITOR_ProcessLocalizationOnScene()
        {
            LocalizationTable table = LocalizationUtilities.EDITOR_GetCurrentScenarioTable();
            
            foreach (MonoBehaviour script in FindObjectsByType<MonoBehaviour>(FindObjectsInactive.Include, FindObjectsSortMode.None))
            {
                if (script is ILocalizable localizable)
                {
                    localizable.ProcessLocalizationKeys(table);
                }
            }
            
            EDITOR_SetDirtyAndSave();
        }

        public static void EDITOR_ProcessLocalizationForObjectiveData(ObjectiveData objectiveData,
            ScenarioData scenarioData)
        {
            LocalizationTable table = LocalizationUtilities.EDITOR_GetOrCreateNewTable(scenarioData.ID);
            
            foreach (Objective objective in objectiveData.Objectives)
            {
                foreach (ObjectiveEventData eventData in objective.EventDataContainer)
                {
                    if (eventData is ILocalizable localizable)
                    {
                        localizable.ProcessLocalizationKeys(table);
                    }
                }

                foreach (SubObjective childObjective in objective.ChildObjectives)
                {
                    foreach (ObjectiveEventData eventData in childObjective.EventDataContainer)
                    {
                        if (eventData is ILocalizable localizable)
                        {
                            localizable.ProcessLocalizationKeys(table);
                        }
                    }
                }
            }
            
            objectiveData.EDITOR_SetDirtyAndSave();
            table.EDITOR_SetDirtyAndSave();
        }
        
        public static void EDITOR_RemoveTable(LocalizationTable table)
        {
            if (table == null)
            {
                return;
            }
            
            Instance.localizationTables.Remove(table);
            EDITOR_SetDirtyAndSave();
        }
        
        public static void EDITOR_SetDirtyAndSave()
        {
            EditorUtility.SetDirty(Instance);
            AssetDatabase.SaveAssets();
        }
        
        [SettingsProvider]
        public static SettingsProvider CreateSettingsProvider()
        {
            return CreateGlobalSettingsProvider("Project/LDX/Systems/Localization");
        }
#endif
       
        public void ProcessLocalizationKeys(LocalizationTable table)
        {
            table.ProcessLocalizationKey(ref objectiveStartedMessage);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationGlobalSettings.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationKeyAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ffba24195eb540f1b338f7ff53251392
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Systems.Localization
{
    /// <summary>
    /// Marks a string field as a LocalizationKey.
    /// LocalizationKeys will display their english text from the key in the inspector
    /// </summary>
    [AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
    public class LocalizationKeyAttribute : PropertyAttribute { }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationKeyAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationModel.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4070a273d477446298abcb263cc8ce6c
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Logging;
using UnityEditor;
using UnityEngine;
using Debug = Ldx.Framework.Utilities.Logging.Debug;

namespace Ldx.Framework.Systems.Localization
{
    public enum Language
    {
        English = 0,
        French = 1,
        Japanese = 2, 
    }
    
    /// <summary>
    /// Class responsible for loading and retrieving all LocalizedTextStrings
    /// </summary>
    public static class LocalizationModel
    {
        public static event Action<Language> OnLanguageChanged;

        public static bool UseLocalization => LocalizationGlobalSettings.LocalizationEnabled;
        public static Language CurrentLanguage => languages[languageIndex];
        
        /// <summary>
        /// True when a language is successfully associated or chosen by user
        /// </summary>
        public static bool LanguageIsSet { get; private set; }
        
        private static LanguageData loadedLanguageData;
        private static LanguageData LoadedLanguageData
        {
            get
            {
                if (loadedLanguageData == null)
                {
                    LoadLocalizationData(CurrentLanguage);
                }

                return loadedLanguageData;
            }
        }
        
        private static readonly Language[] languages;
        private static int languageIndex;
        
        static LocalizationModel()
        {
            languages = (Language[])Enum.GetValues(typeof(Language));
        }
        
        /// <summary>
        /// Changes the active game language
        /// </summary>
        /// <param name="language">The language to display the game's text in</param>
        public static void SetLanguage(Language language)
        {
            Debug.Log(LogCategory.Localization, $"Language set to {language}");
            
            //Find language index
            for (int i = 0; i < LocalizationGlobalSettings.LanguagesToInclude.Count; i++)
            {
                if (LocalizationGlobalSettings.LanguagesToInclude[i] == language)
                {
                    languageIndex = i;
                    break;
                }
            }
            
            LoadLocalizationData(language);
            LanguageIsSet = true;
            OnLanguageChanged?.Invoke(CurrentLanguage);
        }

        /// <summary>
        /// Changes the active game language to the next available language
        /// </summary>
        public static void MoveToNextLanguage()
        {
            int nextIndex = languageIndex;
            for (int i = 0; i < LocalizationGlobalSettings.LanguagesToInclude.Count; i++)
            {
                if (LocalizationGlobalSettings.LanguagesToInclude[i] == CurrentLanguage)
                {
                    nextIndex = (i + 1) % LocalizationGlobalSettings.LanguagesToInclude.Count;
                    SetLanguage(LocalizationGlobalSettings.LanguagesToInclude[nextIndex]);
                    break;
                }
            }
            SetLanguage(languages[nextIndex]);
        }
        
        /// <summary>
        /// Checks to see if a given key exists in the loaded localization data
        /// </summary>
        /// <param name="key">The key to check for</param>
        /// <returns>Returns true if the key is found; false otherwise</returns>
        public static bool ContainsKey(string key)
        {
            return LoadedLanguageData.ContainsKey(key);
        }
        
        /// <summary>
        /// Gets the text associated with the specified key in the currently active language
        /// </summary>
        /// <param name="id">The key to use to retrieve associated text data</param>
        /// <returns>If the key is valid, returns the associated localized text in the current language; otherwise returns the key as a string</returns>
        public static string GetTextString(string id)
        {
            if (LoadedLanguageData == null)
            { 
                Debug.LogError("No language data was found. You must create at least one for English. Retuning the ID");
                return id;
            }
            
            return LoadedLanguageData.GetLocalizedString(id);
        }

        /// <summary>
        /// Gets the text associated with the specified key in the passed language
        /// </summary>
        /// <param name="id">The id to use to retrieve associated text data</param>
        /// <param name="languageToLoadFrom">Language to load from</param>
        /// <returns>If the key is valid, returns the associated localized text in passed language; otherwise returns the id as a string</returns>
        public static string GetTextString(string id, Language languageToLoadFrom)
        {
            Language current = CurrentLanguage;
            bool loadLanguage = current != languageToLoadFrom;

            if (loadLanguage)
            {
                SetLanguage(languageToLoadFrom);
            }
            
            string languageValue = LoadedLanguageData.GetLocalizedString(id);

            if (loadLanguage)
            {
                SetLanguage(current);
            }

            return languageValue;
        }
        
        /// <summary>
        /// Gets the text associated with the specified key in the currently active language
        /// </summary>
        /// <param name="key">The key to use to retrieve associated text data</param>
        /// <returns>If the key is valid, returns the associated localized text in the current language; otherwise returns the key as a string</returns>
        public static bool TryGetTextString(string key, Language languageToLoadFrom, out string value)
        {
            Language current = CurrentLanguage;
            bool loadLanguage = current != languageToLoadFrom;

            if (loadLanguage)
            {
                SetLanguage(languageToLoadFrom);
            }
            
            bool hasValue = LoadedLanguageData.TryGetLocalizedString(key, out value);

            if (loadLanguage)
            {
                SetLanguage(current);
            }
            
            return hasValue;
        }
        
        /// <summary>
        /// Gets the text associated with the specified key in the currently active language
        /// </summary>
        /// <param name="key">The key to use to retrieve associated text data</param>
        /// <returns>If the key is valid, returns the associated localized text in the current language; otherwise returns the key as a string</returns>
        public static bool TryGetTextString(string key, out string value)
        {
            return LoadedLanguageData.TryGetLocalizedString(key, out value);
        }
        
        /// <summary>
        /// Loads the localization data for a specific language, unloading the previous data if necessary.
        /// </summary>
        private static void LoadLocalizationData(Language language)
        {
            if (loadedLanguageData != null)
            {
                if (language == loadedLanguageData.Language)
                {
                    return;
                }
                
                Resources.UnloadAsset(loadedLanguageData);
                loadedLanguageData = null;
            }

            string resourcePath = string.Format(LocalizationGlobalSettings.LanguageDataPath, language);
            loadedLanguageData = Resources.Load<LanguageData>(resourcePath);
        }
        
#if UNITY_EDITOR
        
        /// <summary>
        /// Regenerates all localization data from the localization tables.
        /// </summary>
        [MenuItem("LogicalDox/Localization/Refresh Localization")]
        public static void EDITOR_RegenerateLocalizationData()
        {
            HashSet<string> loadedStringLocalizationKeys = new HashSet<string>();
            HashSet<string> loadedAudioClipLocalizationKeys = new HashSet<string>();
            HashSet<string> loadedTextureLocalizationKeys = new HashSet<string>();
            Dictionary<Language, LanguageData> languageData = new Dictionary<Language, LanguageData>(languages.Length);

            // Initialize language data for each language.
            foreach (Language language in languages)
            {
                LanguageData newData = ScriptableObject.CreateInstance<LanguageData>();
                newData.EDITOR_SetLanguage(language);
                languageData.Add(language, newData);
            }
            
            // Parse each localization table and populate language data.
            foreach (LocalizationTable localizationTable in LocalizationGlobalSettings.LocalizationTables)
            {
                if (localizationTable == null)
                {
                    Debug.LogError(LogCategory.Localization, $"Localization table not found!");
                    return;
                }

                EDITOR_ParseTable(loadedStringLocalizationKeys, loadedAudioClipLocalizationKeys, loadedTextureLocalizationKeys,
                    languageData, localizationTable);
            }

            // Save the generated language data.
            foreach (KeyValuePair<Language, LanguageData> kvp in languageData)
            {
                EDITOR_SaveLanguageData(kvp.Key, kvp.Value);
            }
            
            LocalizationGlobalSettings.EDITOR_RefreshLanguageDialog();
        }

        /// <summary>
        /// Parses a localization table and adds the data to the corresponding LanguageData objects.
        /// </summary>
        private static void EDITOR_ParseTable(
            HashSet<string> loadedStringLocalizationKeys, 
            HashSet<string> loadedAudioClipLocalizationKeys, 
            HashSet<string> loadedTextureLocalizationKeys, 
            Dictionary<Language, LanguageData> languageData,
            LocalizationTable localizationTable)
        {
            foreach ((string stringEntryKey, LocalizationEntry<string> localizationEntry) in localizationTable.TextLocalizationData.KeyEntrySet)
            {
                if (loadedStringLocalizationKeys.Contains(stringEntryKey))
                {
                    Debug.LogWarning(LogCategory.Localization,
                        $"Duplicated localization key {stringEntryKey} found in {localizationTable.TableName}");
                    continue;
                }
                
                foreach ((Language language, string localizedString) in localizationEntry.languageValueSet)
                {
                    if (string.IsNullOrEmpty(localizedString))
                    {
                        continue;
                    }
                    
                    languageData[language].EDITOR_AddLanguageData(stringEntryKey, localizedString);
                }
                
                loadedStringLocalizationKeys.Add(stringEntryKey);
            }
        }
        
        /// <summary>
        /// Saves the generated LanguageData to the specified path, overwriting existing data if necessary.
        /// </summary>
        private static void EDITOR_SaveLanguageData(Language language, LanguageData languageData)
        {
            string savePath = string.Format(LocalizationGlobalSettings.FullLanguageDataPath, language);
            LanguageData oldLanguageData = AssetDatabase.LoadAssetAtPath<LanguageData>(savePath);
            
            if (oldLanguageData != null)
            {
                oldLanguageData.EDITOR_CopyLanguageData(languageData);
            }
            else
            {
                ProjectUtilities.EnsureDirectoryExists(savePath);
                AssetDatabase.CreateAsset(languageData, savePath);
                languageData.EDITOR_SetDirtyAndSave();
            }
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationModel.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationTable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d122e835e3b74228b9e73cc632cf0e84
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Ldx.Framework.Systems.Localization
{
    /// <summary>
    /// Represents a table of localization data for various languages, primarily managing text entries (for now)
    /// </summary>
    public class LocalizationTable : ScriptableObject
    {
        [SerializeField]
        private string tableName = "New Localization Table";
        public string TableName => tableName;

        [SerializeField]
        private LocalizationTableData<string> textLocalizationData = new LocalizationTableData<string>();
        public LocalizationTableData<string> TextLocalizationData => textLocalizationData;

        /// <summary>
        /// Checks if an entry exists (will check for key, and all languages values) and retrieves its key.
        /// </summary>
        /// <param name="entry">The entry text to check.</param>
        /// <param name="key">The key of the found entry.</param>
        /// <returns>True if the entry exists, otherwise false.</returns>
        public bool ContainsEntry(string entry, out string key)
        {
            key = entry;
            
            foreach (LocalizationEntry<string> localizationEntry in textLocalizationData.LocalizationEntries)
            {
                if (localizationEntry.key.Equals(entry))
                {
                    key = localizationEntry.key;
                    return true;
                }

                foreach (string languageValue in localizationEntry.languageValueSet.Values)
                {
                    if (languageValue != null && languageValue.Equals(entry))
                    {
                        key = localizationEntry.key;
                        return true;
                    }
                }
            }

            return false;
        }
        
#if UNITY_EDITOR
        
        
        /// <summary>
        /// Checks if an English entry exists and retrieves its ID.
        /// </summary>
        /// <param name="engEntry">The English text to check.</param>
        /// <param name="foundID">The ID of the found entry.</param>
        /// <returns>True if the entry exists, otherwise false.</returns>
        public bool EDITOR_GetIDIfEngEntryExist(string engEntry, out string foundID)
        {
            LocalizationEntry<string> firstOrDefault = textLocalizationData.LocalizationEntries.FirstOrDefault(x => x.languageValueSet[Language.English] == engEntry);
            foundID = firstOrDefault == null ? string.Empty : firstOrDefault.key;
            return firstOrDefault != null;
        }
        
        /// <summary>
        /// Updates an existing entry or creates a new one if it doesn't exist.
        /// </summary>
        /// <param name="entryID">The ID of the entry to update.</param>
        /// <param name="engEntry">The new English text to assign.</param>
        public void EDITOR_UpdateEntry(string entryID, string engEntry, Language language)
        {
            LocalizationEntry<string> firstOrDefault = textLocalizationData.LocalizationEntries.FirstOrDefault(x => x.key == entryID);

            if (firstOrDefault == null)
            {
                LocalizationEntry<string> newEntry = textLocalizationData.EDITOR_AddNewEntry();
                textLocalizationData.EDITOR_ReplaceKey(newEntry.key, entryID);
            }
            
            firstOrDefault?.ChangeLanguageValue(language, engEntry);
            EditorUtility.SetDirty(this);
        }

        /// <summary>
        /// Updates an existing entry or creates a new one if it doesn't exist.
        /// </summary>
        /// <param name="entryID">The ID of the entry to update.</param>
        /// <param name="engEntry">The new English text to assign.</param>
        public void EDITOR_UpdateEntry(string entryID, List<(Language, string)> languageEntries, bool save = true)
        {
            LocalizationEntry<string> firstOrDefault = textLocalizationData.LocalizationEntries.FirstOrDefault(x => x.key == entryID);

            if (firstOrDefault == null)
            {
                LocalizationEntry<string> newEntry = textLocalizationData.EDITOR_AddNewEntry();
                textLocalizationData.EDITOR_ReplaceKey(newEntry.key, entryID);
            }

            foreach ((Language, string) languageEntry in languageEntries)
            {
                firstOrDefault?.ChangeLanguageValue(languageEntry.Item1, languageEntry.Item2);
            }

            if (save)
            {
                EDITOR_SetDirtyAndSave();
            }
        }

        public string EDITOR_GetEntryLanguageText(string key, Language language, bool returnEmptyIfNotFound = true)
        {
            string result = null;
            LocalizationEntry<string> entry = textLocalizationData.LocalizationEntries.FirstOrDefault(x => x.key == key);

            if (entry == null)
            {
                if (returnEmptyIfNotFound)
                {
                    result = "";
                }
                return result;
            }

            return entry.GetLanguageValue(language);
        }

        /// <summary>
        /// Adds a new English entry to the localization table.
        /// </summary>
        /// <param name="engEntry">The English text to add.</param>
        /// <returns>The key of the newly added entry.</returns>
        public string EDITOR_AddEngEntry(string engEntry)
        {
            LocalizationEntry<string> newEntry = textLocalizationData.EDITOR_AddNewEntry();
            textLocalizationData.EDITOR_ReplaceKey(newEntry.key, GUID.Generate().ToString());
            newEntry.ChangeLanguageValue(Language.English, engEntry);
            EDITOR_SetDirtyAndSave();
            return newEntry.key;
        }
        
        /// <summary>
        /// Sets the name of the localization table and updates the corresponding asset.
        /// </summary>
        /// <param name="newName">The new name for the table.</param>
        public void EDITOR_SetTableName(string newName)
        {
            tableName = newName;
            string assetPath =  AssetDatabase.GetAssetPath(GetInstanceID());
            AssetDatabase.RenameAsset(assetPath, newName);
            EDITOR_SetDirtyAndSave();
        }

        /// <summary>
        /// Marks the object as dirty and saves all changes to assets.
        /// </summary>
        public void EDITOR_SetDirtyAndSave()
        {
            if (this == null)
            {
                return;
            }
            
            EditorUtility.SetDirty(this);
            AssetDatabase.SaveAssets();
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationTable.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationTableData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d955810b6f0a4f3e87f32aab606df94e
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Utilities.Logging;
using UnityEngine;
using Debug = Ldx.Framework.Utilities.Logging.Debug;
#if UNITY_EDITOR
using Ldx.Framework.Utilities.Extensions;
#endif

namespace Ldx.Framework.Systems.Localization
{
    /// <summary>
    /// Represents the data structure for a localization table containing multiple localization entries.
    /// </summary>
    /// <typeparam name="T">The type of the localized value.</typeparam>
    [Serializable]
    public class LocalizationTableData<T>
    {
        [SerializeField]
        private List<LocalizationEntry<T>> localizationEntries = new List<LocalizationEntry<T>>();
        public List<LocalizationEntry<T>> LocalizationEntries => localizationEntries;
        
        private Dictionary<string, LocalizationEntry<T>> keyEntrySet;
        public Dictionary<string, LocalizationEntry<T>> KeyEntrySet => keyEntrySet ??= GenerateEntryDictionary();

        /// <summary>
        /// Generates a dictionary from the list of localization entries, ensuring each key is unique.
        /// </summary>
        /// <returns>A dictionary of localization entries.</returns>
        private Dictionary<string, LocalizationEntry<T>> GenerateEntryDictionary()
        {
            Dictionary<string, LocalizationEntry<T>> dictionary = new Dictionary<string, LocalizationEntry<T>>();

            foreach (LocalizationEntry<T> entry in localizationEntries)
            {
                if (dictionary.ContainsKey(entry.key))
                {
                    Debug.LogWarning(LogCategory.Localization, $"Localization table contains duplicating entry with the key {entry.key}");
                    continue;
                }

                dictionary[entry.key] = entry;
            }

            return dictionary;
        }

        /// <summary>
        /// Resets the dictionary, forcing it to regenerate on the next access.
        /// </summary>
        private void ResetDictionary()
        {
            keyEntrySet = null;
        }
        
#if UNITY_EDITOR
        
        /// <summary>
        /// Adds a new entry to the localization table and returns it.
        /// </summary>
        /// <returns>The newly added LocalizationEntry.</returns>
        public LocalizationEntry<T> EDITOR_AddNewEntry()
        {
            LocalizationEntry<T> entry = new LocalizationEntry<T>(StringUtilities.GenerateUniqueId(8, 10, exclude: LocalizationGlobalSettings.GetAllLocalizationIds()));
            localizationEntries.Add(entry);
            ResetDictionary();
            return entry;
        }
            
        /// <summary>
        /// Replaces the key for an existing entry.
        /// </summary>
        /// <param name="oldKey">The old key to replace.</param>
        /// <param name="newKey">The new key to use.</param>
        public void EDITOR_ReplaceKey(string oldKey, string newKey)
        {
            if(KeyEntrySet.TryGetValue(oldKey, out LocalizationEntry<T> value))
            {
                value.key = newKey;
                
                //Set to null so next time it is regenerated
                ResetDictionary();
            }
        }
        
        /// <summary>
        /// Removes a specific entry from the localization table.
        /// </summary>
        /// <param name="entry">The entry to remove.</param>
        public void EDITOR_Remove(LocalizationEntry<T> entry)
        {
            localizationEntries.Remove(entry);
            ResetDictionary();
        }
        
        /// <summary>
        /// Removes an entry based on its key.
        /// </summary>
        /// <param name="key">The key of the entry to remove.</param>
        public void EDITOR_Remove(string key)
        {
            if (KeyEntrySet.TryGetValue(key, out LocalizationEntry<T> value))
            {
                localizationEntries.Remove(value);
                ResetDictionary();
            }
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationTableData.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationTableExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f4317fbef3f8431fa1a4f11a8b6a7b5c
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities.Logging;

namespace Ldx.Framework.Systems.Localization
{
    public static class LocalizationTableExtensions
    {
        public static void ProcessLocalizationKey(this LocalizationTable table, ref string localizationKey)
        {
            if (string.IsNullOrWhiteSpace(localizationKey))
            {
                return;
            }
            
            Debug.Log(LogCategory.Localization, $"Processing localization key {localizationKey} in table {table.TableName}");
            
#if UNITY_EDITOR
            bool existsInLocalizationTable = false;
#endif
            string key = string.Empty;
            
            foreach (LocalizationTable localizationTable in LocalizationGlobalSettings.LocalizationTables)
            {
                if (localizationTable.ContainsEntry(localizationKey, out key))
                {
#if UNITY_EDITOR
                    existsInLocalizationTable = true;
#endif
                    break;
                }
            }
            
#if UNITY_EDITOR
            if (!existsInLocalizationTable)
            {
                if (!table.EDITOR_GetIDIfEngEntryExist(localizationKey, out key))
                {
                    key = table.EDITOR_AddEngEntry(localizationKey);
                }
            }
#endif

            if (string.IsNullOrEmpty(key))
            {
                return;
            }
            
            localizationKey = key;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationTableExtensions.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationUtilities.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e42e36ac219048ab92db3ec4f6655059
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Ldx.Framework.Systems.Localization
{
    /// <summary>
    /// Provides utility functions for managing localization in the Unity Editor.
    /// </summary>
    public static class LocalizationUtilities
    {
        public const string UI_TABLE_NAME = "UI";
        private const string SCENARIOS_TABLE_NAME = "Scenarios Data";
        private const string SCENARIOS_INVENTORY_TABLE_NAME = "{0} Inventory";
        private const string GENERAL_TABLE_NAME = "General";
        private const string NEW_LOCALIZATION_TABLE_NAME = "Localization Table {0}";

        private static Dictionary<string, LocalizationTable> entryKeyToLocalizationTableMap;

        private static void InitEntryKeyToLocalizationTableMap()
        {
            entryKeyToLocalizationTableMap = new();
            foreach (LocalizationTable localizationTable in LocalizationGlobalSettings.LocalizationTables)
            {
                foreach (LocalizationEntry<string> entry in localizationTable.TextLocalizationData.LocalizationEntries)
                {
                    entryKeyToLocalizationTableMap.Add(entry.key, localizationTable);
                }
            }
        }

        public static string GetAnyLocalizationEntry(string key, Language language)
        {
            if (entryKeyToLocalizationTableMap == null)
            {
                InitEntryKeyToLocalizationTableMap();
            }
            
            if (!entryKeyToLocalizationTableMap.TryGetValue(key, out LocalizationTable table))
            {
                return null;
            }
            
            LocalizationEntry<string> entry = table.TextLocalizationData.LocalizationEntries.FirstOrDefault(x => x.key == key);

            if (entry == null)
            {
                return null;
            }

            return entry.GetLanguageValue(language);
        }

        public static LocalizationTable GetLocalizationTableFromEntryKey(string key)
        {
            if (entryKeyToLocalizationTableMap == null)
            {
                InitEntryKeyToLocalizationTableMap();
            }
            
            if (!entryKeyToLocalizationTableMap.TryGetValue(key, out LocalizationTable table))
            {
                return null;
            }

            return table;
        }
        
#if UNITY_EDITOR
        
        /// <summary>
        /// Update any localization entry in any of the tables based on a key
        /// </summary>
        public static bool EDITOR_UpdateAnyLocalizationEntry(string key, string text, Language language)
        {
            if (!Application.isEditor || Application.isPlaying)
            {
                return false;
            }
            
            if (entryKeyToLocalizationTableMap == null)
            {
                InitEntryKeyToLocalizationTableMap();
            }

            if (!entryKeyToLocalizationTableMap.TryGetValue(key, out LocalizationTable table))
            {
                return false;
            }

            table.EDITOR_UpdateEntry(key, text, language);
            return true;
        }
        
        /// <summary>
        /// Changes the current language of the application to English.
        /// </summary>
        [MenuItem("LogicalDox/Localization/Change Language/English")]
        public static void EDITOR_ChangeLanguageToEng()
        {
            LocalizationModel.SetLanguage(Language.English);
        }
        
        /// <summary>
        /// Changes the current language of the application to French.
        /// </summary>
        [MenuItem("LogicalDox/Localization/Change Language/French")]
        public static void EDITOR_ChangeLanguageToFr()
        {
            LocalizationModel.SetLanguage(Language.French);
        }

        /// <summary>
        /// Generates unique IDs for all localizable text in the current scene.
        /// </summary>
        [MenuItem("LogicalDox/Localization/Generate localization ID for scene")]
        public static void GenerateIDsForScene()
        {
            LocalizationGlobalSettings.EDITOR_ProcessLocalizationOnScene();
        }
        
        /// <summary>
        /// Generates unique IDs for all localizable text in the current scene.
        /// </summary>
        public static void GenerateIDsForScenarioObjective(ObjectiveData objectiveData,
            ScenarioData scenarioData)
        {
            if (objectiveData == null || scenarioData == null)
            {
                return;
            }
            
            LocalizationGlobalSettings.EDITOR_ProcessLocalizationForObjectiveData(objectiveData, scenarioData);
        }
        
        /// <summary>
        /// Generates and updates localization data for scenario-based content.
        /// </summary>
        [MenuItem("LogicalDox/Localization/Generate Localization Scenario Data")]
        public static void EDITOR_GenerationLocalizationForScenarioData()
        {
            LocalizationTable table = EDITOR_GetOrCreateNewTable(SCENARIOS_TABLE_NAME);
            
            List<ScenarioData> scenarioDataList = GlobalData.Instance.GetScenarioDataList();
            if (GlobalData.Instance.BasicsTutorialData != null)
            {
                scenarioDataList.Add(GlobalData.Instance.BasicsTutorialData);
            }

            foreach (ScenarioData scenarioData in scenarioDataList)
            {
                scenarioData.ProcessLocalizationKeys(table);
            }
            
            GlobalData.Instance.ProcessLocalizationKeys(table);
        }
        
        /// <summary>
        /// Processes a single LocalizationString, updating or generating its ID as necessary.
        /// </summary>
        /// <param name="table">The LocalizationTable where the data will be stored.</param>
        /// <param name="localizationString">The LocalizationString to process.</param>
        public static bool EDITOR_TryGetLocalizationValue(string key, Language language, out string value)
        {
            value = string.Empty;
            if (LocalizationGlobalSettings.LocalizationTables == null)
            {
                return false;
            }
            foreach (LocalizationTable table in LocalizationGlobalSettings.LocalizationTables)
            {
                if (table == null || table.TextLocalizationData == null)
                {
                    continue;
                }
                LocalizationEntry<string> entry = table.TextLocalizationData.LocalizationEntries.FirstOrDefault(x => x.key == key);
                if (entry != null)
                {
                    value = entry.GetLanguageValue(language);
                    return true;
                }
            }

            return false;
        }


        /// <summary>
        /// Processes a single LocalizationString, updating or generating its ID as necessary.
        /// </summary>
        /// <param name="table">The LocalizationTable where the data will be stored.</param>
        /// <param name="localizationString">The LocalizationString to process.</param>
        public static bool EDITOR_TryUpdateLocalizationEntry(string entryID, string newEngValue, Language language)
        {
            foreach (LocalizationTable table in LocalizationGlobalSettings.LocalizationTables)
            {
                if (table.TextLocalizationData.LocalizationEntries.Any(x => x.key == entryID))
                {
                    table.EDITOR_UpdateEntry(entryID, newEngValue, language);
                    return true;
                }
            }

            return false;
        }
        
        public static LocalizationTable EDITOR_GetCurrentScenarioTable()
        {
            string tableName = GENERAL_TABLE_NAME;
            LdxScenarioConfig sceneScenario = LdxScenarioConfig.Instance;
            if (sceneScenario != null && !string.IsNullOrEmpty(sceneScenario.ScenarioName))
            {
                tableName = sceneScenario.ScenarioName;
            }

            return EDITOR_GetOrCreateNewTable(tableName);
        }

        #region Table Managment

        public static LocalizationTable EDITOR_GetOrCreateNewTable(string tableName)
        {
            LocalizationTable foundTable = LocalizationGlobalSettings.LocalizationTables.FirstOrDefault(x => x.TableName == tableName);
            if (foundTable)
            {
                return foundTable;
            }

            return EDITOR_CreateNewTable(tableName);
        }
        
        public static LocalizationTable EDITOR_CreateNewTable()
        {
            return EDITOR_CreateNewTable(string.Format(NEW_LOCALIZATION_TABLE_NAME, LocalizationGlobalSettings.LocalizationTables.Count + 1));
        }
        
        public static LocalizationTable EDITOR_CreateNewTable(string tableName)
        {
            string filePath = string.Format(LocalizationGlobalSettings.SavePath, tableName);
            LocalizationTable newTable = ScriptableObjectUtilities.CreateInstanceAndFile<LocalizationTable>(filePath);
            newTable.EDITOR_SetTableName(tableName);
            LocalizationGlobalSettings.LocalizationTables.Add(newTable);
            LocalizationGlobalSettings.EDITOR_SetDirtyAndSave();
            return newTable;
        }

        #endregion

#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/LocalizationUtilities.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/NoLocalizationFrameworkTable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 844836ed10c5402d868eb888e67b17e4
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;

namespace Ldx.Framework.Systems.Localization
{
    /// <summary>
    /// This table is used when localization isn't enabled
    /// Stores common framework localization IDs to be replaced at runtime with their corresponding text
    /// </summary>
    [SavePath("Assets/Resources/Data")]
    public class NoLocalizationFrameworkTable : Utilities.ScriptableSingleton<NoLocalizationFrameworkTable>
    {
        [SerializeField] private SerializableDictionary<string, string> table = new();

        public static void Set(string id, string value)
        {
            Instance.table[id] = value;
        }

        public static string GetValueOrDefault(string id)
        {
            if (!Application.isPlaying)
            {
                return id;
            }
            if (!Instance.table.TryGetValue(id, out string value))
            {
                return id;
            }

            return value;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Localization/NoLocalizationFrameworkTable.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Attributes/GlobalOnlyAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6cdc6de5e16547c2a2378a5b5f3a42bf
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Attributes
{
    [AttributeUsage(AttributeTargets.Enum | AttributeTargets.Field)]
    public class GlobalOnlyAttribute : PropertyAttribute
    {
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Attributes/GlobalOnlyAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Attributes/ObjectiveTypesFilterAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cdc1b892f51c43b0aef31112e4995111
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Attributes
{
    /// <summary>
    /// Attribute for filtering through objective types
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public class ObjectiveTypesFilterAttribute : PropertyAttribute
    {
        public List<ObjectiveType> AllowedTypes { get; set; } = new();
        public List<ObjectiveType> DisallowedTypes { get; set; } = new();

        public ObjectiveTypesFilterAttribute(params ObjectiveType[] allowedTypes)
        {
            AllowedTypes = allowedTypes.ToList();
        }
        
        public ObjectiveTypesFilterAttribute(ObjectiveType[] allowedTypes = null,
            ObjectiveType[] disallowedTypes = null)
        {
            AllowedTypes = allowedTypes?.ToList() ?? AllowedTypes;
            DisallowedTypes = disallowedTypes?.ToList() ?? DisallowedTypes;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Attributes/ObjectiveTypesFilterAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/BaseObjective.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 874c0b0f8c5c4cbc8a2865826a3cbe40
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
    [Serializable][NodeMenuItem("Child Objective")]
    public class SubObjective : BaseObjective
    {
        public SubObjective() { }
        public SubObjective(SubObjective copy) : base(copy) { }

#if UNITY_EDITOR
        /// <summary>
        /// Should be the way to instantiate a new objective in the editor
        /// </summary>
        /// <returns></returns>
        public static SubObjective EDITOR_CreateNewChildObjective()
        {
            return new SubObjective();
        }
#endif
    }
    
    public enum ObjectiveType
    {
        ParallelGroup = 1,
        InSequenceGroup = 2
    }
    
    [Serializable][NodeMenuItem("Objective")]
    public class Objective : BaseObjective
    {
        [SerializeField] 
        private List<SubObjective> childObjectives = new List<SubObjective>();

        /// <summary>
        /// Could be sub-objectives, parallel objectives, or any other kind of objectives.
        /// </summary>
        public List<SubObjective> ChildObjectives => childObjectives;
        
        [SerializeField][ObjectiveInspector]
        private ObjectiveType objectiveType = ObjectiveType.ParallelGroup;
        public ObjectiveType ObjectiveType
        {
            get => objectiveType;
            set => objectiveType = value;
        }

        public Objective() { }
        public Objective(Objective copy) : base(copy) { }
        
        public override void InitializeRuntime()
        {
            base.InitializeRuntime();
            
            foreach (SubObjective objective in childObjectives)
            {
                objective.InitializeRuntime();
            }
        }

        public override void AcquireStepsToQueue(ref Queue<List<BaseObjective>> steps)
        {
            foreach (ObjectiveCondition condition in Conditions)
            {
                if (condition.CheckType == ObjectiveCondition.ConditionalCheckType.SkipsObjectiveIfValid && condition.IsConditionValid())
                {
                    // If a skip condition is valid, we skip this entire objective and its children
                    // by not adding anything to the queue.
                    return;
                }
            }
            
            if (childObjectives.Count > 0)
            {
                switch (ObjectiveType)
                {
                    case ObjectiveType.ParallelGroup:
                        List<BaseObjective> parallels = childObjectives.Cast<BaseObjective>().ToList();
                        steps.Enqueue(parallels);
                        break;
                    case ObjectiveType.InSequenceGroup:
                        foreach (List<BaseObjective> step in childObjectives.Select(objective => new List<BaseObjective> { objective }))
                        {
                            steps.Enqueue(step);
                        }
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
                
                return;
            }
            
            steps.Enqueue(new List<BaseObjective> {this});
        }

#if UNITY_EDITOR
        /// <summary>
        /// Should be the way to instantiate a new objective in the editor
        /// </summary>
        /// <returns></returns>
        public static Objective EDITOR_CreateNewObjective(ObjectiveType type)
        {
            Objective baseObjective = new Objective
            {
                ObjectiveType = type
            };
            return baseObjective;
        }
        
        /// <summary>
        /// Should be the way to instantiate a new objective in the editor
        /// </summary>
        /// <returns></returns>
        public static SubObjective EDITOR_CreateNewSubObjective()
        {
            return new SubObjective();
        }
        
        /// <summary>
        /// Should be the way to instantiate a new objective in the editor
        /// </summary>
        /// <returns></returns>
        public void EDITOR_AddSubObjective(SubObjective subObjective)
        {
            childObjectives.Add(subObjective);
        }
#endif
    }
    
    /// <summary>
    /// A scenario objective, represented as serializable data
    /// Intended to be stored in ObjectiveData, to be processed by ObjectiveSystem
    /// </summary>
    [Serializable]
    public abstract class BaseObjective : IObjective
    {
        #region Node Editor

#if UNITY_EDITOR
        public event Action<BaseObjective> OnObjectiveConditionsChanged; 
#endif

        #endregion
        
        [SerializeField][ObjectiveInspector]
        private string name;
        public string Name
        {
            get => name;
            set => name = value;
        }
        
        [SerializeField][ReadOnly]
        [ObjectiveInspector]
        private string id = String.Empty;
        public string ID => id;

        [IDSelection(LdxIdSettings.IdType.Objective)]
        [SerializeField][ObjectiveInspector]
        private string objectiveId;
        public string ObjectiveID => objectiveId;
        
        [IDSelection(LdxIdSettings.IdType.TrackingFeature)]
        [SerializeField] private string worldObjectiveStepId;
        public string WorldObjectiveStepId => worldObjectiveStepId;
        
        [SerializeReference]
        private List<ObjectiveOption> objectiveOptions = new List<ObjectiveOption>();
        public List<ObjectiveOption> ObjectiveOptions => objectiveOptions;

        [SerializeReference][ObjectiveInspector] 
        private List<ObjectiveCondition> conditions = new List<ObjectiveCondition>();
        public List<ObjectiveCondition> Conditions => conditions;

        [SerializableContainer]
        [SerializeField] 
        private EventDataContainer eventDataContainer = new EventDataContainer();

        #region NodeEditor

        //Node view datas
        public Rect nodePosition = Rect.zero;
        public Rect masterNodePosition = Rect.zero;
        
        [SerializeField]
        private SerializableDictionary<TriggerEventInfo, Rect> triggerEventInfoNodePositions =
            new SerializableDictionary<TriggerEventInfo, Rect>();

        public Rect GetTriggerEventInfoNodePosition(TriggerEventInfo info)
        {
            foreach (KeyValuePair<TriggerEventInfo,Rect> keyValuePair in triggerEventInfoNodePositions)
            {
                if (keyValuePair.Key.Equals(info))
                {
                    return keyValuePair.Value;
                }
            }
            
            return Rect.zero;
        }

        public void SetTriggerEventInfoNodePosition(TriggerEventInfo info, Rect rect)
        {
            foreach (KeyValuePair<TriggerEventInfo, Rect> keyValuePair in triggerEventInfoNodePositions)
            {
                if (keyValuePair.Key.Equals(info))
                {
                    triggerEventInfoNodePositions[keyValuePair.Key] = rect;
                    return;
                }
            }

            triggerEventInfoNodePositions[info] = rect;
        }

        public void RemoveTriggerEventInfoPos(TriggerEventInfo info)
        {
            TriggerEventInfo toRemove = null;
            foreach (KeyValuePair<TriggerEventInfo, Rect> keyValuePair in triggerEventInfoNodePositions)
            {
                if (keyValuePair.Key.Equals(info))
                {
                    toRemove = keyValuePair.Key;
                    break;
                }
            }

            if (toRemove != null)
            {
                triggerEventInfoNodePositions.Remove(toRemove);
            }
        }

        #endregion
        public EventDataContainer EventDataContainer
        {
            get => eventDataContainer;
            set => eventDataContainer = value;
        }
        
        private Dictionary<Type, ObjectiveOption> TypeToObjectiveOptionMap { get; set; } 
            = new Dictionary<Type, ObjectiveOption>();

        public BaseObjective() { }
        
        public BaseObjective(BaseObjective copy)
        {
            name = copy.name + " Copy";
            TryGenerateId(true);
            objectiveId = copy.objectiveId;
            worldObjectiveStepId = copy.worldObjectiveStepId; 
            objectiveOptions = new List<ObjectiveOption>();
            foreach (ObjectiveOption option in copy.objectiveOptions)
            {
                Type dataType = option.GetType();
                ObjectiveOption newOption = (ObjectiveOption)Activator.CreateInstance(dataType, option);
                objectiveOptions.Add(newOption);
            }
            
            conditions = new List<ObjectiveCondition>();
            foreach (ObjectiveCondition condition in copy.conditions)
            {
                Type dataType = condition.GetType();
                ObjectiveCondition newOption = (ObjectiveCondition)Activator.CreateInstance(dataType, condition);
                conditions.Add(newOption);
            }

            eventDataContainer = new EventDataContainer(copy.eventDataContainer);
            
            nodePosition = copy.nodePosition;
            nodePosition.position += Vector2.right * 100;
            masterNodePosition = copy.masterNodePosition;
            triggerEventInfoNodePositions = new SerializableDictionary<TriggerEventInfo, Rect>(copy.triggerEventInfoNodePositions);
        }

        public virtual bool OnValidate()
        {
            return EventDataContainer.OnValidate();
        }

        /// <summary>
        /// Called on runtime to be initialized
        /// As a rule, since this is a data class, whatever
        /// runtime logic lives here shouldn't change core serialized
        /// values or have state
        /// </summary>
        public virtual void InitializeRuntime()
        {
            TypeToObjectiveOptionMap.Clear();
            foreach (ObjectiveOption option in objectiveOptions)
            {
                TypeToObjectiveOptionMap.Add(option.GetType(), option);
            }
        }
        
        public List<ObjectiveEventData> GetEvents(ObjectiveEventData.TriggerEventType eventType)
        {
            if(!EventDataContainer.TryGet(eventType, out List<ObjectiveEventData> list))
            {
                list = new List<ObjectiveEventData>();
            }

            return list;
        }
        
        public List<ObjectiveEventData> GetEvents(ObjectiveEventData.TriggerEventType eventType, string eventId)
        {
            if(!EventDataContainer.TryGet(eventType, eventId, out List<ObjectiveEventData> list))
            {
                list = new List<ObjectiveEventData>();
            }

            return list;
        }

        public List<ObjectiveEventData> GetInteractionEvents(ObjectiveEventData.InteractionEventType interactionType,
            string interactionId)
        {
            if(!EventDataContainer.TryGet(ObjectiveEventData.TriggerEventType.Interaction, interactionId,
                   out List<ObjectiveEventData> list))
            {
                list = new List<ObjectiveEventData>();
            }

            list.RemoveAll(e => e.TriggerEventInfo.InteractionEventType != interactionType);

            return list;
        }
        
        /// <summary>
        /// Checks to see if objective has a specific ObjectiveOption and
        /// tries to get it
        /// </summary>
        public bool TryGetObjectiveOption<T>(out T option) where T : ObjectiveOption
        {
            option = null;
            if (!TypeToObjectiveOptionMap.TryGetValue(typeof(T), out ObjectiveOption result))
            {
                return false;
            }

            option = result as T;
            return true;
        }

        public void TryGenerateId(bool force = false)
        {
            if (!force && !string.IsNullOrEmpty(id))
            {
                return;
            }   
            id = StringUtilities.GenerateUniqueId(minLength: 5, maxLength: 8);
        }

        public virtual void AcquireStepsToQueue(ref Queue<List<BaseObjective>> steps){}

#if UNITY_EDITOR

        public ObjectiveEventData EDITOR_AddNewEventData(Type eventType, TriggerEventInfo eventInfo)
        {
            if (!typeof(ObjectiveEventData).IsAssignableFrom(eventType) || eventType.IsAbstract)
            {
                Debug.LogError("Invalid event type specified.");
                return null;
            }

            // Create a new instance of the event data
            ObjectiveEventData data = Activator.CreateInstance(eventType) as ObjectiveEventData;
            if (data != null)
            {
                data.EDITOR_SetTriggerEventType(eventInfo);
                EventDataContainer.Add(data);
                data.TryGenerateId(true);
            }
            else
            {
                Debug.LogError("Failed to create event data instance.");
            }

            return data;
        }

        public void EDITOR_AddCondition(Type condition)
        {
            if(!condition.IsSubclassOf(typeof(ObjectiveCondition)) || condition.IsAbstract)
            {
                return;
            }
            
            conditions.Add(Activator.CreateInstance(condition) as ObjectiveCondition);
            OnObjectiveConditionsChanged?.Invoke(this);
            
        }
        
        public void EDITOR_RemoveCondition(int index)
        {
            if(index < 0 || index >= conditions.Count)
            {
                return;
            }
            
            conditions.RemoveAt(index);
            OnObjectiveConditionsChanged?.Invoke(this);
        }
        
        public void EDITOR_AddOption(Type option)
        {
            if(!option.IsSubclassOf(typeof(ObjectiveOption)) || option.IsAbstract)
            {
                return;
            }
            
            objectiveOptions.Add(Activator.CreateInstance(option) as ObjectiveOption);
        }

        /// <summary>
        /// For this objective type, gets a list of available
        /// option classes as types, excluding the ones
        /// that already exist
        /// </summary>
        public List<Type> EDITOR_GetAvailableObjectiveOptionTypes()
        {
            var options = new List<Type>();
            var existingTypesHashset = new HashSet<Type>(objectiveOptions.Select(o => o.GetType()).ToList()); 
            //TODO: fix
            //ObjectiveType t = ObjectiveType;
            /*foreach (var type in Assembly.GetExecutingAssembly().GetTypes())
            {
                if (existingTypesHashset.Contains(type))
                {
                    continue;
                }
                if (!type.IsSubclassOf(typeof(ObjectiveOption)))
                {
                    continue;
                }
                var attribute = type.GetCustomAttribute<ObjectiveTypesFilterAttribute>();
                // ---(Broken down for readability)
                // No filter specified
                if (attribute == null)
                {
                    options.Add(type);
                }
                // No allowed filter specified, but disallowed types are specified
                else if (attribute.AllowedTypes.Count == 0
                         && attribute.DisallowedTypes.All(disallowed => disallowed != t))
                {
                    options.Add(type);
                }
                // Allowed and disallowed filters are specified
                else if (attribute.AllowedTypes.Any(allowed => allowed == t)
                         && attribute.DisallowedTypes.All(disallowed => disallowed != t))
                {
                    options.Add(type);
                }
            }*/

            return options;
        }
        
        /// <summary>
        /// Tries to convert the objective processing type to
        /// another
        /// </summary>
        public bool EDITOR_TryConvertObjectiveType(ObjectiveType toType, out string error)
        {
            error = "";
            // TODO: fix
            /*if (toType == ObjectiveType.Single && ChildObjectives.Count > 0)
            {
                error = "Can't convert to single objective until all child objectives are removed";
                return false;
            }

            objectiveType = toType;*/
            return true;
        }
        
        /// <summary>
        /// Tries to convert the objective processing type to
        /// another
        /// </summary>
        public void EDITOR_DeleteEventData(ObjectiveEventData data)
        {
            if (data == null)
            {
                return;
            }
            
            eventDataContainer.Delete(data);
        }

        public void EDITOR_ChangeEventDataTrigger(ObjectiveEventData data, TriggerEventInfo newTriggerInfo)
        {
            if (!eventDataContainer.Contains(data))
            {
                return;
            }
            
            data.EDITOR_SetTriggerEventType(new TriggerEventInfo(newTriggerInfo));
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/BaseObjective.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/AnyObjectAnyWaistSocketPlacedCondition.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b2c58cb1f6374c7fae9ae43da7594630
# ASMDEF: ldx.framework.runtime.dll
# ---
/*using System;
using System.Collections.Generic;
using HurricaneVR.Framework.Core.Grabbers;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.Player.Waist;

namespace Ldx.Framework.Systems.Objectives.Conditions
{
    [Serializable]
    public class AnyObjectAnyWaistSocketPlacedCondition : ObjectiveCondition
    {
        private readonly HashSet<HVRSocket> occupiedSockets = new HashSet<HVRSocket>();

        public AnyObjectAnyWaistSocketPlacedCondition() { }
        
        public AnyObjectAnyWaistSocketPlacedCondition(AnyObjectAnyWaistSocketPlacedCondition copy) : base(copy)
        {
            occupiedSockets = new HashSet<HVRSocket>(copy.occupiedSockets);
        }
        
        public override bool IsConditionValid()
        {
            return occupiedSockets.Count > 0;
        }
        
        public override void BeginChecking()
        {
            base.BeginChecking();
            WaistController waistController = PlayerController.Instance.WaistController;
            waistController.OnAnyHolsterGrabbed += HandleAnyHolsterGrabbed;
            waistController.OnAnyHolsterReleased += HandleAnyHolsterReleased;
        }

        public override void EndChecking()
        {
            base.EndChecking();
            WaistController waistController = PlayerController.Instance.WaistController;
            waistController.OnAnyHolsterGrabbed -= HandleAnyHolsterGrabbed;
            waistController.OnAnyHolsterReleased -= HandleAnyHolsterReleased;
        }

        private void HandleAnyHolsterGrabbed(HVRSocket socket)
        {
            occupiedSockets.Add(socket);
        }
        
        private void HandleAnyHolsterReleased(HVRSocket socket)
        {
            occupiedSockets.Remove(socket);
        }

        public override void ResetCondition()
        {
            occupiedSockets.Clear();
        }
    }
}*/
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/AnyObjectAnyWaistSocketPlacedCondition.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/CheckCrouchingCondition.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8dd7ebb9382542718178991e902b78bd
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Player;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Conditions
{
    [Serializable]
    public class CheckCrouchingCondition : ObjectiveCondition
    {
        [Serializable]
        private enum CrouchingState
        {
            Crouching = 0,
            NotCrouching
        }
        
        [SerializeField]
        private CrouchingState targetCheck;
        
        public CheckCrouchingCondition() { }
        
        public CheckCrouchingCondition(CheckCrouchingCondition copy) : base(copy)
        {
            targetCheck = copy.targetCheck;
        }

        public override bool IsConditionValid()
        {
            bool crouching = PlayerController.Instance.IsCrouching;
            return targetCheck == CrouchingState.Crouching ? crouching : !crouching;
        }

        public override void ResetCondition() { }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/CheckCrouchingCondition.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/CheckKeyCondition.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2eff058beafa4dcdae231fe8dbd070b3
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Conditions
{
    /// <summary>
    /// Condition to check if a certain key is registered
    /// </summary>
    [Serializable]
    public class CheckKeyCondition : ObjectiveCondition
    {
        [Tooltip("Passes if the selected key matches the target value")]
        [IDSelection(LdxIdSettings.IdType.Key)] 
        [SerializeField]
        private string keyToCheck;

        [SerializeField]
        private bool isStatic;
        
        [SerializeField] 
        private bool targetValue = true;
        
        public CheckKeyCondition() { }
        
        public CheckKeyCondition(CheckKeyCondition copy) : base(copy)
        {
            keyToCheck = copy.keyToCheck;
            isStatic = copy.isStatic;
            targetValue = copy.targetValue;
        }

        public override bool IsConditionValid()
        {
            if (isStatic)
            {
                return TrackingKeyController.GetStaticKeyValue(keyToCheck) == targetValue;
            }
            
            return TrackingKeyController.Instance.GetKeyValue(keyToCheck) == targetValue;
        }

        public override void ResetCondition()
        {
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/CheckKeyCondition.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/DialogCompleteCondition.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3ca79a9e6a944cacaf2b03f30c9310d7
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using UnityEngine.InputSystem;

namespace Ldx.Framework.Systems.Objectives.Conditions
{
    /// <summary>
    /// Condition to check if a dialog was completed
    /// </summary>
    [Serializable]
    public class DialogCompleteCondition : ObjectiveCondition
    {
        [SerializeField] 
        private bool acceptAnyId;
        [IDSelection(LdxIdSettings.IdType.Dialog)]
        [SerializeField] 
        private string id;
        [SerializeField] 
        private bool requireRightAnswer;
        
        private bool didDialogComplete;
        
        public DialogCompleteCondition() { }
        
        public DialogCompleteCondition(DialogCompleteCondition copy) : base(copy)
        {
            acceptAnyId = copy.acceptAnyId;
            id = copy.id;
            requireRightAnswer = copy.requireRightAnswer;
            didDialogComplete = copy.didDialogComplete;
        }

        public override void BeginChecking()
        {
            base.BeginChecking();
            didDialogComplete = false;
            LdxTrackingManager.Instance.OnDialogCompleted += HandleDialogCompleted;
        }

        public override void EndChecking()
        {
            base.EndChecking();
            LdxTrackingManager.Instance.OnDialogCompleted -= HandleDialogCompleted;
        }

        public override void ResetCondition()
        {
            didDialogComplete = false;
        }

        private void HandleDialogCompleted(string dialogId, bool isRightAnswer)
        {
            if (!acceptAnyId && id != dialogId)
            {
                return;
            }

            if (requireRightAnswer && !isRightAnswer)
            {
                return;
            }

            didDialogComplete = true;
        }

        public override bool IsConditionValid()
        {
#if UNITY_EDITOR
            if (Keyboard.current != null && Keyboard.current.wKey.isPressed)
            {
                return true;
            }
#endif
            return didDialogComplete;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/DialogCompleteCondition.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/GrabbedAnyObjectCondition.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 02b8c0f6941842fa871056ebfe65aec5
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Autohand;
using Ldx.Framework.Systems.Player;

namespace Ldx.Framework.Systems.Objectives.Conditions
{
    [Serializable]
    public class GrabbedAnyObjectCondition : ObjectiveCondition
    {
        private bool grabbedAnyObject;
        
        public GrabbedAnyObjectCondition() { }
        
        public GrabbedAnyObjectCondition(GrabbedAnyObjectCondition copy) : base(copy) { }

        public override bool IsConditionValid()
        {
            return grabbedAnyObject;
        }

        public override void BeginChecking()
        {
            base.BeginChecking();
            PlayerController.Instance.HandsController.LeftHand.OnGrabbed += HandleHandGrabbed;
            PlayerController.Instance.HandsController.RightHand.OnGrabbed += HandleHandGrabbed;
        }

        public override void EndChecking()
        {
            base.EndChecking();
            if (PlayerController.IsValid)
            {
                PlayerController.Instance.HandsController.LeftHand.OnGrabbed -= HandleHandGrabbed;
                PlayerController.Instance.HandsController.RightHand.OnGrabbed -= HandleHandGrabbed;
            }
        }

        private void HandleHandGrabbed(Hand hand, Grabbable grabbable)
        {
            grabbedAnyObject = true;
        }

        public override void ResetCondition()
        {
            grabbedAnyObject = false;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/GrabbedAnyObjectCondition.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/KeyboardPressCondition.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 10509673238d4fd1b42854050b45f73a
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;
using UnityEngine.InputSystem;

namespace Ldx.Framework.Systems.Objectives.Conditions
{
    /// <summary>
    /// Condition to check if a keyboard key was pressed
    /// </summary>
    [Serializable]
    public class KeyboardPressCondition : ObjectiveCondition
    {
        [SerializeField] 
        private KeyCode key;
        
        public KeyboardPressCondition() { }
        
        public KeyboardPressCondition(KeyboardPressCondition copy) : base(copy)
        {
            key = copy.key;
        }
        
        public override bool IsConditionValid()
        {
            if (Keyboard.current != null)
            {
                if (Enum.TryParse(key.ToString(), out Key keyToPress))
                {
                    return Keyboard.current[keyToPress].wasPressedThisFrame;
                }
            }

            return false;
        }

        public override void ResetCondition()
        {
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/KeyboardPressCondition.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/SystemMenuOpenedOrClosedCondition.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 43a04aab6e5347a49342ff6e6b0969e2
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.UI;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Conditions
{
    [Serializable]
    public class SystemMenuOpenedOrClosedCondition : ObjectiveCondition
    {
        public enum WindowState
        {
            Opened = 0,
            Closed
        }

        [SerializeField]
        private WindowState targetState = WindowState.Opened;
        
        private bool conditionValid;
        
        public SystemMenuOpenedOrClosedCondition() { }
        
        public SystemMenuOpenedOrClosedCondition(SystemMenuOpenedOrClosedCondition copy) : base(copy)
        {
            targetState = copy.targetState;
        }
        
        public override bool IsConditionValid()
        {
            return conditionValid;
        }

        public override void BeginChecking()
        {
            ResetCondition();
            base.BeginChecking();
            UIController.OnMainMenuOpenClosed += HandleSystemMenuOpenedClosed;
        }

        public override void EndChecking()
        {
            base.EndChecking();
            UIController.OnMainMenuOpenClosed -= HandleSystemMenuOpenedClosed;
        }

        private void HandleSystemMenuOpenedClosed(UIController uiController, bool isOpen)
        {
            conditionValid = (isOpen && targetState == WindowState.Opened) || 
                             (!isOpen && targetState == WindowState.Closed);
        }
        
        public override void ResetCondition()
        {
            conditionValid = false;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/SystemMenuOpenedOrClosedCondition.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/TrackingEventCondition.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c5afa0ee69934e70905b5078e6edff02
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Conditions
{
    /// <summary>
    /// Condition to check if a tracking event was fired 
    /// </summary>
    [Serializable]
    public class TrackingEventCondition : ObjectiveCondition
    {
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] 
        private string targetEvent;

        public string TargetEvent => targetEvent;

        [SerializeField] 
        private bool checkHappenedBefore;

        private bool eventTriggered = false;

        public TrackingEventCondition() { }
        
        public TrackingEventCondition(TrackingEventCondition copy) : base(copy)
        {
            targetEvent = copy.targetEvent;
        }

        public override bool IsConditionValid()
        {
            if (checkHappenedBefore)
            {
                return LdxTrackingManager.Instance.CheckTrackingEventOccured(targetEvent);
            }
            return eventTriggered;
        }

        public override void BeginChecking()
        {
            base.BeginChecking();
            if (LdxTrackingManager.Instance != null)
            {
                LdxTrackingManager.Instance.OnTrackingEvent += HandleEvent;
            }
        }

        public override void EndChecking()
        {
            base.EndChecking();
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleEvent;
            } 
            eventTriggered = false;
        }

        public override void ResetCondition()
        {
            eventTriggered = false;
        }

        private void HandleEvent(string id)
        {
            if (id == targetEvent)
            {
                eventTriggered = true;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/TrackingEventCondition.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/VideoFinishedCondition.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9699f9cef1a54e37adbdbf0477898a03
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.UI.Video;

namespace Ldx.Framework.Systems.Objectives.Conditions
{
    /// <summary>
    /// Condition to check if a video is finished
    /// </summary>
    [Serializable]
    public class VideoFinishedCondition : ObjectiveCondition
    {
        private bool finished;
        
        public VideoFinishedCondition() { }
        
        public VideoFinishedCondition(VideoFinishedCondition copy) : base(copy) { }

        public override void BeginChecking()
        {
            base.BeginChecking();
            LdxVideoPlayer.Instance.OnVideoPlayerFinished += HandleVideoPlayerFinished;
        }

        private void HandleVideoPlayerFinished(LdxVideoPlayer videoPlayer)
        {
            finished = true;
            LdxVideoPlayer.Instance.OnVideoPlayerFinished -= HandleVideoPlayerFinished;
        }

        public override bool IsConditionValid()
        {
            return finished;
        }

        public override void ResetCondition()
        {
            finished = false;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Conditions/VideoFinishedCondition.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/AnimationEventDatas.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 50cba36753cd4fa3a678ca9635bb9476
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using UnityEngine.Serialization;

namespace Systems.Objectives.EventData
{
    public class AnimationEventDatas
    {
        [ObjectiveCategory(ObjectiveCategoryList.OBJECT_TRANSFORMS)]
        [Serializable]
        [RequireTracker(typeof(AnimationEventsTracker))]
        public class TriggerAnimationEventData : ObjectiveEventData
        {
            [FormerlySerializedAs("objectGroup")]
            [IDSelection(LdxIdSettings.IdType.Dialog)]
            [SerializeField] 
            private string animationDialogId;
            public string AnimationDialogId => animationDialogId;
            
            public TriggerAnimationEventData() { }
            
            public TriggerAnimationEventData(TriggerAnimationEventData copy) : base(copy)
            {
                animationDialogId = copy.animationDialogId;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/AnimationEventDatas.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/AudioEventDatas.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b676cbc469c94aeb90811d0c0f07a3e9
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using Systems.Sound;
using UnityEngine;
using UnityEngine.Audio;

namespace Ldx.Framework.Systems.Objectives
{
    public interface IAudioEventData
    {
    }
    
    public interface IPlayAudioEventData : IAudioEventData
    {
        public string SoundReference { get; }
        public List<LocalizedAudioClip> AudioClips { get; }
        public AudioMixerGroup AudioMixerGroup { get; }
        public bool CanBeInterrupted { get; }
    }
    
    [ObjectiveCategory(ObjectiveCategoryList.AUDIO)]
    [Serializable] [RequireTracker(typeof(AudioEventTracker))]
    public class PlayAudioEventData : ObjectiveEventData, IPlayAudioEventData
    {
        [SerializeField][SoundReference]
        private string soundReference;
        
        [SerializeField]
        [Tooltip("If canBeInterrupted is false, the sound will be played as one shot")]
        private bool canBeInterrupted = false;
        
        public string SoundReference => soundReference;
        public bool CanBeInterrupted => canBeInterrupted;
        
        public List<LocalizedAudioClip> AudioClips { get; }
        public AudioMixerGroup AudioMixerGroup { get; }
        
        public PlayAudioEventData() { }
        
        public PlayAudioEventData(PlayAudioEventData copy) : base(copy)
        {
            soundReference = copy.soundReference;
            canBeInterrupted = copy.canBeInterrupted;
        }
    }

    [ObjectiveCategory(ObjectiveCategoryList.AUDIO)]
    [Serializable] [RequireTracker(typeof(AudioEventTracker))]
    public class PlayDialogEventData : ObjectiveEventData, IPlayAudioEventData, IDialogEventData
    {
        private const string REACTIVE_TEXT_DISPLAY = "Dialogue audio only, no text is displayed";
        
        [SerializeField] 
        private List<LocalizedAudioClip> audioClips = new();
        public List<LocalizedAudioClip> AudioClips => audioClips;
        
        [SerializeField][HelpBox("If left unassigned, will use default mixing (Project Settings > LDX > Audio)")]
        private AudioMixerGroup customMixerGroup;
        public AudioMixerGroup AudioMixerGroup => customMixerGroup;
        
        public string SoundReference => null;
        public bool CanBeInterrupted => true;
        public string DialogID { get; }

        public AudioClip AudioClip => AudioClips.FirstOrDefault(c => c.Language == LocalizationModel.CurrentLanguage)
            ?.AudioClip;

        public PlayDialogEventData()
        {
            DialogID = StringUtilities.GenerateUniqueId();
        }
        
        public PlayDialogEventData(PlayDialogEventData copy) : base(copy)
        {
            DialogID = StringUtilities.GenerateUniqueId();
            audioClips.Clear();
            foreach (LocalizedAudioClip audioClip in copy.audioClips)
            {
                audioClips.Add(new LocalizedAudioClip(audioClip.Language, audioClip.AudioClips));
            }
            
            customMixerGroup = copy.AudioMixerGroup;
        }

        public List<ReactiveDialogData> GetReactiveDialogData()
        {
            List<ReactiveDialogData> dataList = new();
            ReactiveDialogData data = new ReactiveDialogData(() => REACTIVE_TEXT_DISPLAY, (t) => { }, audioClips)
            {
                NoTextSource = true
            };

            dataList.Add(data);
            return dataList;
        }
    }

    [ObjectiveCategory(ObjectiveCategoryList.AUDIO)]
    [Serializable] [RequireTracker(typeof(AudioEventTracker))]
    public class StopDialogEventData : ObjectiveEventData { }
    
    [ObjectiveCategory(ObjectiveCategoryList.AUDIO)]
    [Serializable] [RequireTracker(typeof(AudioEventTracker))]
    public class PlayRandomAudioFromListEventData : ObjectiveEventData, IPlayAudioEventData
    {
        [SerializeField][SoundReference]
        private string soundReference;

        [SerializeField]
        private List<LocalizedAudioClip> audioClips = new ();
        [SerializeField][Tooltip("If left unassigned, will use default mixing")] 
        private AudioMixerGroup audioMixerGroup;
        [SerializeField]
        [Tooltip("If canBeInterrupted is false, the sound will be played as one shot")]
        private bool canBeInterrupted = true;
        
        public string SoundReference => soundReference;
        public bool CanBeInterrupted => canBeInterrupted;
        
        public List<LocalizedAudioClip> AudioClips => audioClips;
        public AudioMixerGroup AudioMixerGroup => audioMixerGroup;
        
        public PlayRandomAudioFromListEventData() { }
        
        public PlayRandomAudioFromListEventData(PlayRandomAudioFromListEventData copy) : base(copy)
        {
            soundReference = copy.soundReference;
            audioMixerGroup = copy.audioMixerGroup;
            canBeInterrupted = copy.canBeInterrupted;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/AudioEventDatas.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/ControlsEventDatas.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5aa112368ff14e7281780da11e1e744a
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Systems.Player.Hands;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
    [ObjectiveCategory(ObjectiveCategoryList.CONTROLS)]
    [Serializable]
    public class SetTeleportationStateEventData : ObjectiveEventData
    {
        [SerializeField]
        private bool enabled;
        public bool Enabled => enabled;

        public SetTeleportationStateEventData() { }
        
        public SetTeleportationStateEventData(SetTeleportationStateEventData copy) : base(copy)
        {
            enabled = copy.enabled;
        }
    }

    [ObjectiveCategory(ObjectiveCategoryList.CONTROLS)]
    [Serializable]
    public class SetTurningStateEventData : ObjectiveEventData
    {
        [SerializeField]
        private bool enabled;
        public bool Enabled => enabled;

        public SetTurningStateEventData() { }
        
        public SetTurningStateEventData(SetTurningStateEventData copy) : base(copy)
        {
            enabled = copy.enabled;
        }
    }
    
    [Serializable]
    [ObjectiveCategory(ObjectiveCategoryList.CONTROLS)]
    public class ForceGrabEventData : ObjectiveEventData
    {
        [IDSelection(LdxIdSettings.IdType.Transform)]
        public string GrabbableTransform;
        [SoundReference]
        public string PlaySound;
        [SerializeField]
        private HandSide handSide = HandSide.Right;
        public HandSide HandSide => handSide;
        [SerializeField]
        private bool autoReleaseIfHolding = true;
        public bool AutoReleaseIfHolding => autoReleaseIfHolding;

        public ForceGrabEventData() { }
        
        public ForceGrabEventData(ForceGrabEventData copy) : base(copy)
        {
            GrabbableTransform = copy.GrabbableTransform;
            PlaySound = copy.PlaySound;
            handSide = copy.handSide;
            autoReleaseIfHolding = copy.autoReleaseIfHolding;
        }
    }
    
    [ObjectiveCategory(ObjectiveCategoryList.CONTROLS)]
    [Serializable]
    public class SetPlayerMovementStateEventData : ObjectiveEventData
    {
        [SerializeField]
        private bool enabled;
        public bool Enabled => enabled;

        public SetPlayerMovementStateEventData() { }
        
        public SetPlayerMovementStateEventData(SetPlayerMovementStateEventData copy) : base(copy)
        {
            enabled = copy.enabled;
        }
    }
    
    [ObjectiveCategory(ObjectiveCategoryList.CONTROLS)]
    [Serializable]
    public class SetJoystickMovementStateEventData : ObjectiveEventData
    {
        [SerializeField]
        private bool enabled;
        public bool Enabled => enabled;

        public SetJoystickMovementStateEventData() { }
        
        public SetJoystickMovementStateEventData(SetJoystickMovementStateEventData copy) : base(copy)
        {
            enabled = copy.enabled;
        }
    }

    [ObjectiveCategory(ObjectiveCategoryList.CONTROLS)]
    [Serializable]
    public class ApplyHolsterOffsetEventData : ObjectiveEventData
    {
        [IDSelection(LdxIdSettings.IdType.Socketable)]
        [SerializeField]
        private List<string> socketableIds;
        public List<string> SocketableIDs => socketableIds;
        
        [SerializeField]
        private Vector3 offset;
        public Vector3 Offset => offset;

        [SerializeField] 
        private bool returnSocketOnRelease = true;
        public bool ReturnSocketOnRelease => returnSocketOnRelease;
        
        [SerializeField]
        private bool clearsOnObjectiveEnd = true;
        public bool ClearsOnObjectiveEnd => clearsOnObjectiveEnd;

        public ApplyHolsterOffsetEventData() { }
        
        public ApplyHolsterOffsetEventData(ApplyHolsterOffsetEventData copy) : base(copy)
        {
            socketableIds = copy.socketableIds;
            offset = copy.offset;
            returnSocketOnRelease = copy.returnSocketOnRelease;
            clearsOnObjectiveEnd = copy.clearsOnObjectiveEnd;
        }
    }

    [ObjectiveCategory(ObjectiveCategoryList.CONTROLS)]
    [Serializable]
    public class SetHolsterVisibleEventData : ObjectiveEventData
    {
        [IDSelection(LdxIdSettings.IdType.Socketable)]
        [SerializeField]
        private List<string> socketableIds;
        public List<string> SocketableIDs => socketableIds;

        [SerializeField] 
        private bool visible;
        public bool Visible => visible;

        public SetHolsterVisibleEventData() { }
        
        public SetHolsterVisibleEventData(SetHolsterVisibleEventData copy) : base(copy)
        {
            socketableIds = copy.socketableIds;
            visible = copy.visible;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/ControlsEventDatas.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/FlowControlObjectiveEventDatas.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7c619fea78434edbb5944e80f49bd2fa
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Features.Timer;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
    [ObjectiveCategory(ObjectiveCategoryList.FLOW_CONTROL)]
    [Serializable][RequireTracker(typeof(TrackingKeyController))]
    public class SetKeyEventData : ObjectiveEventData
    {
        [IDSelection(LdxIdSettings.IdType.Key)]
        [SerializeField]
        private string keyToSet;

        public string KeyToSet => keyToSet;

        [SerializeField]
        private bool value;

        public bool Value => value;

        [SerializeField]
        private bool isStatic;
        public bool IsStatic => isStatic;

        [SerializeField]
        private bool saveToPlayerPrefs;

        public bool SaveToPlayerPrefs => saveToPlayerPrefs;
        
        public SetKeyEventData() { }
        
        public SetKeyEventData(SetKeyEventData copy) : base(copy)
        {
            keyToSet = copy.keyToSet;
            value = copy.value;
            isStatic = copy.isStatic;
            saveToPlayerPrefs = copy.saveToPlayerPrefs;
        }
    }
    
    [ObjectiveCategory(ObjectiveCategoryList.FLOW_CONTROL)]
    [Serializable][RequireTracker(typeof(TrackingKeyController))]
    public class TriggerEventBasedOnKeyEventData : ObjectiveEventData
    {
        [IDSelection(LdxIdSettings.IdType.Key)]
        [SerializeField]
        private string keyToCheck;
        public string KeyToCheck => keyToCheck;
        
        [SerializeField]
        private bool isStatic;
        public bool IsStatic => isStatic;
        
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)] 
        [SerializeField]
        private string eventToTriggerOnFalse;
        public string EventToTriggerOnFalse => eventToTriggerOnFalse;
        
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)] 
        [SerializeField]
        private string eventToTriggerOnTrue;
        public string EventToTriggerOnTrue => eventToTriggerOnTrue;
        
        public TriggerEventBasedOnKeyEventData() { }
        
        public TriggerEventBasedOnKeyEventData(TriggerEventBasedOnKeyEventData copy) : base(copy)
        {
            keyToCheck = copy.keyToCheck;
            isStatic = copy.isStatic;
            eventToTriggerOnFalse = copy.eventToTriggerOnFalse;
            eventToTriggerOnTrue = copy.eventToTriggerOnTrue;
        }
    }

    [ObjectiveCategory(ObjectiveCategoryList.FLOW_CONTROL)]
    [Serializable]
    public class SetObjectiveNameEventData : ObjectiveEventData, ILocalizable
    {
        [SerializeField]
        [LocalizationKey]
        private string newName;

        public string NewName => newName;
        
        public SetObjectiveNameEventData() { }
        
        public SetObjectiveNameEventData(SetObjectiveNameEventData copy) : base(copy)
        {
            newName = copy.newName;
        }
        
        public void ProcessLocalizationKeys(LocalizationTable table)
        {
            table.ProcessLocalizationKey(ref newName);
        }
    }

    [Serializable]
    [ObjectiveCategory(ObjectiveCategoryList.FLOW_CONTROL)]
    public class ConfigureDrawableSurfacesEventData : ObjectiveEventData
    {
        [IDSelection(LdxIdSettings.IdType.TrackingFeature)]
        [SerializeField]
        private List<string> drawableSurfaces = new();

        public List<string> DrawableSurfaces => drawableSurfaces;

        [IDSelection(LdxIdSettings.IdType.TrackingFeature)]
        [SerializeField]
        private List<string> erasableSurfaces = new();

        public List<string> ErasableSurfaces => erasableSurfaces;
        
        public ConfigureDrawableSurfacesEventData() { }
        
        public ConfigureDrawableSurfacesEventData(ConfigureDrawableSurfacesEventData copy) : base(copy)
        {
            drawableSurfaces = new List<string>(copy.drawableSurfaces);
            erasableSurfaces = new List<string>(copy.erasableSurfaces);
        }
    }

    [ObjectiveCategory(ObjectiveCategoryList.FLOW_CONTROL)]
    [Serializable]
    public class ActivateFallControllerEventData : ObjectiveEventData
    {
        [IDSelection(LdxIdSettings.IdType.Transform)]
        [SerializeField]
        private string targetTransform;

        public string TargetTransform => targetTransform;
        
        public ActivateFallControllerEventData() { }
        
        public ActivateFallControllerEventData(ActivateFallControllerEventData copy) : base(copy)
        {
            targetTransform = copy.targetTransform;
        }
    }

    [ObjectiveCategory(ObjectiveCategoryList.FLOW_CONTROL)]
    [Serializable]
    public class TimerActionEventData : ObjectiveEventData
    {
        [Serializable]
        public enum ActionType
        {
            Start,
            Pause,
            Resume,
            Finish
        }

        [SerializeField]
        private ActionType timerEvent;

        [Space]
        [SerializeField]
        private CountMode countMode;

        [SerializeField]
        private float startTime;

        [SerializeField]
        private float stopTime;

        [SerializeField]
        private bool showTimer;

        [SerializeField]
        [IDSelection(LdxIdSettings.IdType.Transform)]
        private string positionTransform;

        public ActionType TimerEvent => timerEvent;
        public CountMode CountMode => countMode;
        public float StartTime => startTime;
        public float StopTime => stopTime;
        public bool ShowTimer => showTimer;
        public string PositionTransform => positionTransform;
        
        public TimerActionEventData() { }
        
        public TimerActionEventData(TimerActionEventData copy) : base(copy)
        {
            timerEvent = copy.timerEvent;
            countMode = copy.countMode;
            startTime = copy.startTime;
            stopTime = copy.stopTime;
            showTimer = copy.showTimer;
            positionTransform = copy.positionTransform;
        }
    }

    [ObjectiveCategory(ObjectiveCategoryList.FLOW_CONTROL)]
    [Serializable]
    public class RestartObjectiveStepEventData : ObjectiveEventData
    {
        public RestartObjectiveStepEventData() { }
        public RestartObjectiveStepEventData(RestartObjectiveStepEventData copy) : base(copy) { }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/FlowControlObjectiveEventDatas.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/HighlighterObjectInfo.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4bc1a53e578d40afa825c701e1ffcacb
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Systems.Objectives.EventData
{
    [Serializable]
    public class HighlighterObjectInfo : ILocalizable
    {
        [IDSelection(LdxIdSettings.IdType.Dialog)]
        [SerializeField]
        private string highlighterID;
        public string HighlighterID => highlighterID;
            
        [SerializeField]
        private bool isCorrect;
        public bool IsCorrect => isCorrect;
        
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField]
        private string eventOnHighlight;
        public string EventOnHighlight => eventOnHighlight;
        
        [SerializeField]
        private bool overrideTooltip;
        public bool OverrideTooltip => overrideTooltip;
            
        [SerializeField][LocalizationKey]
        private string tooltipDescription;
        public string TooltipDescription => tooltipDescription;
            
        [SerializeField]
        private bool useQuestion = true;
        public bool UseQuestion => useQuestion;
        
        [SerializeField]
        private HighlightingQuestionData question;
        public HighlightingQuestionData Question => question;
        
        [SerializeField]
        private bool useExplanation = true;
        public bool UseExplanation => useExplanation;

        [SerializeField]
        private HighlightingExplanationData explanation;
        public HighlightingExplanationData Explanation => explanation;
        
        [SerializeField]
        private bool playSoundOnHighlight = false;
        public bool PlaySoundOnHighlight => playSoundOnHighlight;

        [SerializeField] [SoundReference] 
        private string soundReference;
        public string SoundReference => soundReference;
        
        public HighlighterObjectInfo() { }

        public HighlighterObjectInfo(HighlighterObjectInfo copy)
        {
            highlighterID = copy.highlighterID;
            isCorrect = copy.isCorrect;
            eventOnHighlight = copy.eventOnHighlight;
            overrideTooltip = copy.overrideTooltip;
            tooltipDescription = copy.tooltipDescription;
            useQuestion = copy.useQuestion;
            question = copy.question != null ? new HighlightingQuestionData(copy.question) : null;
            useExplanation = copy.useExplanation;
            explanation = copy.explanation != null ? new HighlightingExplanationData(copy.explanation) : null;
            playSoundOnHighlight = copy.playSoundOnHighlight;
            soundReference = copy.soundReference;
        }
        
        public void ProcessLocalizationKeys(LocalizationTable table)
        {
            table.ProcessLocalizationKey(ref tooltipDescription);
            question.ProcessLocalizationKeys(table);
            explanation.ProcessLocalizationKeys(table);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/HighlighterObjectInfo.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/HighlightingEventDatas.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c61792d5294242c5823fa26bac58f974
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Features.Highlighting;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.VFX;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Systems.Objectives.EventData
{
    [Serializable]
    public class HighlightingQuestionData : ILocalizable
    {
        [SerializeField] [LocalizationKey] private string questionTitle;
        public string QuestionTitle => questionTitle;

        [SerializeField] [LocalizationKey] private string questionDescription;
        public string QuestionDescription => questionDescription;

        [IDSelection(LdxIdSettings.IdType.TrackingEvent)] [SerializeField]
        private string correctAnswerEvent;

        public string CorrectAnswerEvent => correctAnswerEvent;

        [IDSelection(LdxIdSettings.IdType.TrackingEvent)] [SerializeField]
        private string wrongAnswerEvent;

        public string WrongAnswerEvent => wrongAnswerEvent;

        [SerializeField] [SoundReference] private string soundReference;
        public string SoundReference => soundReference;

        public HighlightingQuestionData() { }
        
        public HighlightingQuestionData(HighlightingQuestionData copy)
        {
            questionTitle = copy.questionTitle;
            questionDescription = copy.questionDescription;
            correctAnswerEvent = copy.correctAnswerEvent;
            wrongAnswerEvent = copy.wrongAnswerEvent;
            soundReference = copy.soundReference;
        }
        
        public void ProcessLocalizationKeys(LocalizationTable table)
        {
            table.ProcessLocalizationKey(ref questionTitle);
            table.ProcessLocalizationKey(ref questionDescription);
        }
    }

    [Serializable]
    public class HighlightingExplanationData : ILocalizable
    {
        [SerializeField] [LocalizationKey] private string explanationTitle;
        public string ExplanationTitle => explanationTitle;

        [SerializeField] [LocalizationKey] private string explanationDescription;
        public string ExplanationDescription => explanationDescription;

        [SerializeField] [LocalizationKey] private string continueText = "Continue";
        public string ContinueText => continueText;

        [IDSelection(LdxIdSettings.IdType.TrackingEvent)] [SerializeField]
        private string dialogCompletionEvent;

        public string DialogCompletionEvent => dialogCompletionEvent;

        [SerializeField] [SoundReference] private string soundReference;
        public string SoundReference => soundReference;
        
        public HighlightingExplanationData() { }
        
        public HighlightingExplanationData(HighlightingExplanationData copy)
        {
            explanationTitle = copy.explanationTitle;
            explanationDescription = copy.explanationDescription;
            continueText = copy.continueText;
            dialogCompletionEvent = copy.dialogCompletionEvent;
            soundReference = copy.soundReference;
        }
        
        public void ProcessLocalizationKeys(LocalizationTable table)
        {
            table.ProcessLocalizationKey(ref explanationTitle);
            table.ProcessLocalizationKey(ref explanationDescription);
            table.ProcessLocalizationKey(ref continueText);
        }
    }

    [Serializable]
    public class IdentificationData
    {
        [SerializeField] private List<HighlighterObjectInfo> highlighterObjects = new List<HighlighterObjectInfo>();
        public List<HighlighterObjectInfo> HighlighterObjects => highlighterObjects;

        [SerializeField] private bool limitTriesAmount;
        public bool LimitTriesAmount => limitTriesAmount;

        [SerializeField] private int maxTries = 3;
        public int MaxTries => maxTries;

        [IDSelection(LdxIdSettings.IdType.TrackingEvent)] [SerializeField]
        private string eventOnFail;

        public string EventOnFail => eventOnFail;

        [SerializeField] private bool playParticlesOnHighlight = true;
        public bool PlayParticlesOnHighlight => playParticlesOnHighlight;

        public enum ParticleType
        {
            CorrectIncorrect,
            Custom
        }

        [SerializeField] private ParticleType particleType = ParticleType.CorrectIncorrect;
        public ParticleType ParticleOnHighlightType => particleType;

        [SerializeField] private LdxFxController.FX customParticleType;
        public LdxFxController.FX CustomParticleType => customParticleType;

        [SerializeField] private bool highlightCorrectOnFail = true;
        public bool HighlightCorrectOnFail => highlightCorrectOnFail;

        [IDSelection(LdxIdSettings.IdType.TrackingEvent)] [SerializeField]
        private string eventOnCorrect;

        public string EventOnCorrectHighlight => eventOnCorrect;

        [IDSelection(LdxIdSettings.IdType.TrackingEvent)] [SerializeField]
        private string eventOnWrong;

        public string EventOnWrong => eventOnWrong;

        [IDSelection(LdxIdSettings.IdType.TrackingEvent)] [SerializeField]
        private string eventOnAllCorrectHighlight;
        
        public string EventOnAllCorrectHighlight => eventOnAllCorrectHighlight;
        
        public IdentificationData() { }
        
        public IdentificationData(IdentificationData copy)
        {
            highlighterObjects = new List<HighlighterObjectInfo>();
            foreach (HighlighterObjectInfo info in copy.highlighterObjects)
            {
                highlighterObjects.Add(new HighlighterObjectInfo(info));
            }

            limitTriesAmount = copy.limitTriesAmount;
            maxTries = copy.maxTries;
            eventOnFail = copy.eventOnFail;
            playParticlesOnHighlight = copy.playParticlesOnHighlight;
            particleType = copy.particleType;
            customParticleType = copy.customParticleType;
            highlightCorrectOnFail = copy.highlightCorrectOnFail;
            eventOnCorrect = copy.eventOnCorrect;
            eventOnWrong = copy.eventOnWrong;
            eventOnAllCorrectHighlight = copy.eventOnAllCorrectHighlight;
        }
    }

    [ObjectiveCategory(ObjectiveCategoryList.HIGHLIGHTING)]
    [RequireTracker(typeof(HighlighterEventsTracker))]
    [Serializable]
    public class ObjectIdentificationEventData : ObjectiveEventData, ILocalizable
    {
        [SerializeField] private IdentificationData highlightingData;
        public IdentificationData HighlightingData => highlightingData;

        public void ProcessLocalizationKeys(LocalizationTable table)
        {
            foreach (HighlighterObjectInfo highlighterObject in highlightingData.HighlighterObjects)
            {
                highlighterObject.ProcessLocalizationKeys(table);
            }
        }
        
        public ObjectIdentificationEventData(ObjectIdentificationEventData copy) : base(copy)
        {
            highlightingData = new IdentificationData(copy.highlightingData);
        }
    }

    [Serializable]
    public class HighlightObjectContainer
    {
        [IDSelection(LdxIdSettings.IdType.Dialog)] [SerializeField]
        private List<string> objects = new();

        public List<string> Objects => objects;
        
        public HighlightObjectContainer(HighlightObjectContainer copy)
        {
            objects = new List<string>(copy.objects);
        }
    }

    [ObjectiveCategory(ObjectiveCategoryList.HIGHLIGHTING)]
    [RequireTracker(typeof(HighlighterEventsTracker))]
    [Serializable]
    public class ToggleHighlightObjectsEventData : ObjectiveEventData
    {
        [SerializableContainer] [SerializeField]
        private HighlightObjectContainer objectContainer;

        public HighlightObjectContainer ObjectContainer => objectContainer;

        public enum ActionType
        {
            None = 0,
            Highlight = 1,
            Unhighlight = 2
        }

        [SerializeField] private ActionType action = ActionType.Highlight;
        public ActionType Action => action;
        
        public enum HighlightingObjectChange
        {
            None, 
            SetHighlightingEnabled,
            SetHighlightingDisabled,
        }

        [SerializeField] private HighlightingObjectChange setHighlightingChange = HighlightingObjectChange.None;
        public HighlightingObjectChange SetHighlightingChange => setHighlightingChange;

        [SerializeField] private bool playParticlesOnHighlight = true;
        public bool PlayParticlesOnHighlight => playParticlesOnHighlight;

        [SerializeField] private LdxFxController.FX fxToPlay;
        public LdxFxController.FX FXToPlay => fxToPlay;
        
        public ToggleHighlightObjectsEventData() { }
        
        public ToggleHighlightObjectsEventData(ToggleHighlightObjectsEventData copy) : base(copy)
        {
            objectContainer = copy.objectContainer != null ? new HighlightObjectContainer(copy.objectContainer) : null;
            action = copy.action;
            setHighlightingChange = copy.setHighlightingChange;
            playParticlesOnHighlight = copy.playParticlesOnHighlight;
            fxToPlay = copy.fxToPlay;
        }
    }

    [RequireTracker(typeof(HighlighterEventsTracker))]
    [ObjectiveCategory(ObjectiveCategoryList.HIGHLIGHTING)]
    [Serializable]
    public class ChangeHighlightingSourceEventData : ObjectiveEventData
    {
        [SerializeField] private HighlightingGlobalSettings.PointingSource pointingSource;

        public HighlightingGlobalSettings.PointingSource PointingSource => pointingSource;

        // Return to default setting (source from highlighting global settings) on end of Objective.
        [SerializeField] private bool restoreDefaultSourceOnObjectiveEnd = true;
        public bool RestoreDefaultSourceOnObjectiveEnd => restoreDefaultSourceOnObjectiveEnd;
        
        public ChangeHighlightingSourceEventData() { }
        
        public ChangeHighlightingSourceEventData(ChangeHighlightingSourceEventData copy) : base(copy)
        {
            pointingSource = copy.pointingSource;
            restoreDefaultSourceOnObjectiveEnd = copy.restoreDefaultSourceOnObjectiveEnd;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/HighlightingEventDatas.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/InstallObjectFeatureEventData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: fe1081ed5fe447fb9c7ae5abd01b6190
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Systems.Objectives.EventData
{
    [Serializable] [ObjectiveCategory(ObjectiveCategoryList.MISC)]
    public class InstallObjectFeatureEventData : ObjectiveEventData
    {
        [IDSelection(LdxIdSettings.IdType.TrackingFeature)]
        [SerializeField] 
        private string featureID = string.Empty;
        public string FeatureID => featureID;
        
        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string invokeEventOnCompletion;
        public string InvokeEventOnCompletion => invokeEventOnCompletion;
    }

    [Serializable] [ObjectiveCategory(ObjectiveCategoryList.MISC)]
    public class ToggleHighlightOfInstallAreaEventData : ObjectiveEventData
    {
        [IDSelection(LdxIdSettings.IdType.TrackingFeature)]
        [SerializeField] 
        private string featureID = string.Empty;
        public string FeatureID => featureID;
        
        [SerializeField] private bool highlight;
        public bool Highlight => highlight;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/InstallObjectFeatureEventData.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/MiscEventDatas.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 73b8f5444c20465fb17f14ff6bef60cf
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
    [Serializable]
    [ObjectiveCategory(ObjectiveCategoryList.MISC)]
    public class SwitchHolstersEventData : ObjectiveEventData
    {
        public SwitchHolstersEventData() { }
        public SwitchHolstersEventData(SwitchHolstersEventData copy) : base(copy) { }
    }

    [Serializable]
    [ObjectiveCategory(ObjectiveCategoryList.MISC)]
    public class SetActiveRopeEventData : ObjectiveEventData
    {
        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingFeature)]
        private string trackingFeatureId;
        public string TrackingFeatureID => trackingFeatureId;

        [SerializeField] private bool isReversed;
        public bool IsReversed => isReversed;
        
        public SetActiveRopeEventData() { }
        
        public SetActiveRopeEventData(SetActiveRopeEventData copy) : base(copy)
        {
            trackingFeatureId = copy.trackingFeatureId;
            isReversed = copy.isReversed;
        }
    }

    [Serializable]
    [ObjectiveCategory(ObjectiveCategoryList.MISC)]
    public class ClearActiveRopeEventData : ObjectiveEventData
    {
        public ClearActiveRopeEventData() { }
        public ClearActiveRopeEventData(ClearActiveRopeEventData copy) : base(copy) { }
    }

    [Serializable]
    [ObjectiveCategory(ObjectiveCategoryList.MISC)]
    public class SetLanyardForcedSocketsCountEventData : ObjectiveEventData
    {
        [SerializeField] private int forcedSocketsCount;
        public int ForcedSocketsCount => forcedSocketsCount;

        [IDSelection(LdxIdSettings.IdType.TrackingFeature)] [SerializeField]
        private string socketParentId;

        public string SocketParentID => socketParentId;

        [SerializeField] private bool resetForAllRopes;
        public bool ResetForAllRopes => resetForAllRopes;
        
        public SetLanyardForcedSocketsCountEventData() { }
        
        public SetLanyardForcedSocketsCountEventData(SetLanyardForcedSocketsCountEventData copy) : base(copy)
        {
            forcedSocketsCount = copy.forcedSocketsCount;
            socketParentId = copy.socketParentId;
            resetForAllRopes = copy.resetForAllRopes;
        }
    }

    [Serializable]
    [ObjectiveCategory(ObjectiveCategoryList.MISC)]
    public class StartRebarTieEventData : ObjectiveEventData
    {
        [IDSelection(LdxIdSettings.IdType.TrackingFeature)] [SerializeField]
        private string tieFeatureId;

        public string TieFeatureID => tieFeatureId;
        
        public StartRebarTieEventData() { }
        
        public StartRebarTieEventData(StartRebarTieEventData copy) : base(copy)
        {
            tieFeatureId = copy.tieFeatureId;
        }
    }

    [Serializable]
    [ObjectiveCategory(ObjectiveCategoryList.MISC)]
    public class ResetLanyardForcedSocketsCountEventData : ObjectiveEventData
    {
        public ResetLanyardForcedSocketsCountEventData() { }
        public ResetLanyardForcedSocketsCountEventData(ResetLanyardForcedSocketsCountEventData copy) : base(copy) { }
    }

    [Serializable]
    [ObjectiveCategory(ObjectiveCategoryList.MISC)]
    public class SetRopeTieableEventData : ObjectiveEventData
    {
        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingFeature)]
        private string trackingFeatureId;

        public string TrackingFeatureID => trackingFeatureId;

        [SerializeField] private bool tieable;
        public bool Tieable => tieable;
        
        public SetRopeTieableEventData() { }
        
        public SetRopeTieableEventData(SetRopeTieableEventData copy) : base(copy)
        {
            trackingFeatureId = copy.trackingFeatureId;
            tieable = copy.tieable;
        }
    }

    [Serializable]
    [ObjectiveCategory(ObjectiveCategoryList.MISC)]
    public class UntieAllCarabinersEventData : ObjectiveEventData
    {
        public UntieAllCarabinersEventData() { }
        public UntieAllCarabinersEventData(UntieAllCarabinersEventData copy) : base(copy) { }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/MiscEventDatas.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/ObjectivesEventDatas.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: eaaa155613e1498ea96b5127a380bfb2
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
    [Serializable][ObjectiveCategory(ObjectiveCategoryList.OBJECTIVES)]
    public class DisplayObjectiveListEventData : ObjectiveEventData
    {
        public enum ObjectiveDisplayType
        {
            Everything,
            SelfOnly,
            SubObjectivesOnly
        }

        [SerializeField]
        private ObjectiveDisplayType objectiveDisplayType = ObjectiveDisplayType.Everything;
        public ObjectiveDisplayType ObjectiveDisplay => objectiveDisplayType;

        [SerializeField]
        private Vector3 offset;
        public Vector3 Offset => offset;
        
        public DisplayObjectiveListEventData() { }
        
        public DisplayObjectiveListEventData(DisplayObjectiveListEventData copy) : base(copy)
        {
            objectiveDisplayType = copy.objectiveDisplayType;
            offset = copy.offset;
        }
    }

    [Serializable]
    [ObjectiveCategory(ObjectiveCategoryList.OBJECTIVES)]
    public class HideObjectiveListEventData : ObjectiveEventData
    {
        public HideObjectiveListEventData() { }
        public HideObjectiveListEventData(HideObjectiveListEventData copy) : base(copy) { }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/ObjectivesEventDatas.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/ObjectsAndTransformsEventDatas.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0e23d3a76875465b9634815b082c34b8
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
    [ObjectiveCategory(ObjectiveCategoryList.OBJECT_TRANSFORMS)]
    [Serializable]
    public class ObjectGroupActionEventData : ObjectiveEventData
    {
        public enum ActionType
        {
            GameObjectState = 0,
            CollidersState,
            LightState,
            RigidbodyKinematicState,
            GrabbableCanGrabState,
            HighlightEffect
        }

        [SerializeField]
        private ActionType actionType;
        [SerializeField] 
        private bool setActive;
        [IDSelection(LdxIdSettings.IdType.ObjectGroup)]
        [SerializeField] 
        private string group;

        public ActionType GroupActionType => actionType;
        public bool SetActive => setActive;
        public string Group => group;
        
        public ObjectGroupActionEventData() { }
        
        public ObjectGroupActionEventData(ObjectGroupActionEventData copy) : base(copy)
        {
            actionType = copy.actionType;
            setActive = copy.setActive;
            group = copy.group;
        }
    }
    
    [RequireTracker(typeof(TransformEventsTracker))]
    [ObjectiveCategory(ObjectiveCategoryList.OBJECT_TRANSFORMS)]
    [Serializable]
    public class MoveTargetToPositionEventData : ObjectiveEventData
    {
        [SerializeField]
        [IDSelection(LdxIdSettings.IdType.Transform)]
        private string transformToMove;
        public string TransformToMove => transformToMove;

        [SerializeField]
        [IDSelection(LdxIdSettings.IdType.Transform)]
        private string destinationTransform;
        public string DestinationTransform => destinationTransform;
        
        public MoveTargetToPositionEventData() { }
        
        public MoveTargetToPositionEventData(MoveTargetToPositionEventData copy) : base(copy)
        {
            transformToMove = copy.transformToMove;
            destinationTransform = copy.destinationTransform;
        }
    }

    [RequireTracker(typeof(TransformEventsTracker))]
    [ObjectiveCategory(ObjectiveCategoryList.OBJECT_TRANSFORMS)]
    [Serializable]
    public class PlaceTargetInFrontOfPlayerWaistEventData : ObjectiveEventData
    {
        [SerializeField]
        [IDSelection(LdxIdSettings.IdType.Transform)]
        private string target;
        public string Target => target;

        [SerializeField] 
        private Vector3 offset = new Vector3(0,0, 1);
        public Vector3 Offset => offset;
        
        public PlaceTargetInFrontOfPlayerWaistEventData() { }
        
        public PlaceTargetInFrontOfPlayerWaistEventData(PlaceTargetInFrontOfPlayerWaistEventData copy) : base(copy)
        {
            target = copy.target;
            offset = copy.offset;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/ObjectsAndTransformsEventDatas.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/PlayerEventDatas.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 012aa5377687424994b32d12ff9731a7
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.EventData
{
    /// <summary>
    /// Defines the data required to track a specific player action for an objective.
    /// This event data specifies which action to track, how many times it needs to occur,
    /// and what events to broadcast on each occurrence and upon completion.
    /// It requires a <see cref="PlayerActionTracker"/> to be present in the scene.
    /// </summary>
    [RequireTracker(typeof(PlayerActionTracker))]
    [Serializable][ObjectiveCategory(ObjectiveCategoryList.PLAYER)]
    public class TrackPlayerActionsEventData : ObjectiveEventData
    {
        [SerializeField] private PlayerActionTracker.PlayerActionType actionType;
        public PlayerActionTracker.PlayerActionType ActionType => actionType;
        
        [Tooltip("The number of times the specified action needs to occur to be considered complete.")]
        [SerializeField][Min(1)] private int amount = 1;
        public int Amount => amount;
        
        [Tooltip("The ID of the tracking event to broadcast each time the specified action occurs.")]
        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string eventOnEachAction;
        public string EventOnEachAction => eventOnEachAction;
        
        [Tooltip("The ID of the tracking event to broadcast when the specified action has occurred the required number of times.")]
        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string eventOnCompletion;
        public string EventOnCompletion => eventOnCompletion;
        
        public TrackPlayerActionsEventData() { }
        
        public TrackPlayerActionsEventData(TrackPlayerActionsEventData copy) : base(copy)
        {
            actionType = copy.actionType;
            amount = copy.amount;
            eventOnCompletion = copy.eventOnCompletion;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/PlayerEventDatas.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/PPEFeatureEventData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4ed460855d044bc28d06f1862e01bdf3
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Systems.Objectives.EventData
{
    [Serializable] [ObjectiveCategory(ObjectiveCategoryList.MISC)]
    public class PPEFeatureEventData : ObjectiveEventData
    {
        [SerializeField]
        private bool requiresAllObjectsPickup = true;
        public bool RequiresAllObjectsPickup => requiresAllObjectsPickup;
        
        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string invokeEventOnCompletion;
        public string InvokeEventOnCompletion => invokeEventOnCompletion;
        
        [Header("If requiresAllObjectsPickup = false")]
        [SerializeField]
        private bool disableRemainingOnCompletion = true;
        public bool DisableRemainingOnCompletion => disableRemainingOnCompletion;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/PPEFeatureEventData.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/ReactiveDialogData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c0a747f7aec348b6a278c84acac12864
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Utilities.Reactive;
using Systems.Sound;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
    /// <summary>
    /// This wrapper for dialogue data makes use of ReactiveProperty to obfuscate details
    /// about the source for a dialog event data, and allow manipulation of text and audio.
    /// Motivation being the ability to manipulate different types of dialog event data without
    /// caring about their unique structures for future efforts.
    /// </summary>
    public class ReactiveDialogData
    {
        public ReactiveProperty<string> Text { get; set; }
        public List<LocalizedAudioClip> AudioClips { get; }
        public bool NoTextSource { get; set; }

        public ReactiveDialogData(Func<string> textGetter, Action<string> textSetter,
            List<LocalizedAudioClip> audioClips)
        {
            Text = new(textGetter, textSetter);
            AudioClips = audioClips;
        }

        public string GetLocalizedText(Language language)
        {
            return LocalizationUtilities.GetAnyLocalizationEntry(Text, language);
        }

        public AudioClip GetAudioClip(Language? language = null)
        {
            if (AudioClips == null)
            {
                return null;
            }

            if (AudioClips.Count == 0)
            {
                return null;
            }

            if (language == null)
            {
                return AudioClips.First().AudioClip;
            }

            LocalizedAudioClip localizedAudioClip = AudioClips.FirstOrDefault(c => c.Language == language);
            if (localizedAudioClip == null)
            {
                return null;
            }

            return localizedAudioClip.AudioClip;
        }

        public void SetAudioClip(AudioClip clip, Language? language = null)
        {
            if (AudioClips == null)
            {
                return;
            }

            Language clipLanguage = language ?? Language.English;

            LocalizedAudioClip matchingLanguageClip = AudioClips.FirstOrDefault(c => c.Language == clipLanguage);

            if (AudioClips.Count == 0 || matchingLanguageClip == null)
            {
                AudioClips.Add(new LocalizedAudioClip(clipLanguage, clip));
                return;
            }

            matchingLanguageClip.SetAudioClips(new() { clip });
        }

#if UNITY_EDITOR
        public bool EDITOR_SetLocalizedText(string text, Language language)
        {
            return LocalizationUtilities.EDITOR_UpdateAnyLocalizationEntry(Text, text, language);
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/ReactiveDialogData.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/ScenarioEventDatas.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b549e32be5b94fb8988d51c8160e4246
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.Objectives
{
    [Serializable]
    [RequireTracker(typeof(ScenarioLoadEventTracker))]
    [ObjectiveCategory(ObjectiveCategoryList.SCENARIOS)]
    public class LoadScenarioEventData : ObjectiveEventData
    {
        public enum ScenarioLoadType
        {
            ReloadCurrent = 0,
            Next = 1,
            Previous = 2,
            LoadById = 3,
            Lobby = 4,
            Tutorial = 5,
            RestartApplication = 6
        }

        [SerializeField] private ScenarioLoadType loadType = ScenarioLoadType.ReloadCurrent;
        public ScenarioLoadType LoadType => loadType;
        
        [IDSelection(LdxIdSettings.IdType.Scenario)]
        [SerializeField] private string scenarioId = string.Empty;
        public string ScenarioId => scenarioId;

        public LoadScenarioEventData() { }

        public LoadScenarioEventData(LoadScenarioEventData copy) : base(copy)
        {
            loadType = copy.loadType;
            scenarioId = copy.scenarioId;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/ScenarioEventDatas.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/SetWorldObjectiveStepEventData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3f493e2b6c2843dc925f0cb9224fd58f
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.EventData
{
    [ObjectiveCategory(ObjectiveCategoryList.OBJECTIVES)]
    public class SetWorldObjectiveStepEventData : ObjectiveEventData
    {
        [IDSelection(LdxIdSettings.IdType.TrackingFeature)]
        [SerializeField] private string stepId;
        public string StepId => stepId;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/SetWorldObjectiveStepEventData.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/SeuratEventDatas.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3a6739dfd346435ebdb61eea86ef3a93
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
    [Serializable][RequireTracker(typeof(SeuratEventsTracker))]
    [ObjectiveCategory(ObjectiveCategoryList.SEURAT)]
    public class EnableDisableSeuratObjectEventData : ObjectiveEventData
    {
        [SerializeField]
        private string seuratId = String.Empty;
        public string SeuratId => seuratId;

        [SerializeField]
        private bool setActive = true;
        public bool SetActive => setActive;
        
        public EnableDisableSeuratObjectEventData() { }
        
        public EnableDisableSeuratObjectEventData(EnableDisableSeuratObjectEventData copy) : base(copy)
        {
            seuratId = copy.seuratId;
            setActive = copy.setActive;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/SeuratEventDatas.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/StepsFlowEventData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1e7ef0413a1e46e3ae74ab0aa5ea941d
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.UI.StepsFlow;
using Ldx.Framework.Utilities.Attributes;
using Systems.Sound;
using UnityEngine;
using UnityEngine.Audio;

namespace Systems.Objectives.EventData
{
    public enum ProgressTrackMethod
    {
        TrackingEvents = 0,
        Duration = 1,
    }
    
    [Serializable]
    public class StepInformation: IPlayAudioEventData, ILocalizable
    {
        [SerializeField][LocalizationKey]
        private string stepTitle;
        public string StepTitle
        {
            get => stepTitle;
            set => stepTitle = value;
        }

        [SerializeField][LocalizationKey]
        private string stepDescription;
        public string StepDescription
        {
            get => stepDescription;
            set => stepDescription = value;
        }
        
        [Header("VOs")]
        [SerializeField] private List<LocalizedAudioClip> audioClips = new();
        public List<LocalizedAudioClip> AudioClips => audioClips;
        
        [SerializeField] [IDSelection(LdxIdSettings.IdType.Dialog)]
        private string stepID;
        public string StepID => stepID;
        
        public string SoundReference => null;
        public bool CanBeInterrupted => true;
        public AudioMixerGroup AudioMixerGroup => null;
        
        public StepInformation(StepInformation copyFrom)
        {
            stepID = copyFrom.stepID;
            stepTitle = copyFrom.stepTitle;
            stepDescription = copyFrom.stepDescription;
        }
        
        public void ProcessLocalizationKeys(LocalizationTable table)
        {
            table.ProcessLocalizationKey(ref stepTitle);
            table.ProcessLocalizationKey(ref stepDescription);
        }
    }

    [Serializable]
    public class StepFlowInformation
    {
        public string StepID { get; private set; }
        public string AnimatedAttentionLineId { get; private set; }
        public ProgressTrackMethod ProgressMethod { get; private set; }
        public List<string> EventsToTrackProgress { get; private set; }
        public float ProgressDuration { get; private set; }
        public string CompleteFlowStepOnEvent { get; private set; }
        public string ShowAnimationCompletedEvent { get; private set; }
        public string MarkAsCompletedAnimationCompletedEvent { get; private set; }

        public StepFlowInformation(TransitionToStepFlow transitionToStepFlow)
        {
            StepID = transitionToStepFlow.StepID;
            AnimatedAttentionLineId = transitionToStepFlow.AnimatedAttentionLineId;
            ProgressMethod = transitionToStepFlow.ProgressMethod;
            EventsToTrackProgress = transitionToStepFlow.EventsToTrackProgress;
            ProgressDuration = transitionToStepFlow.ProgressDuration;
            CompleteFlowStepOnEvent = transitionToStepFlow.CompleteFlowStepOnEvent;
            ShowAnimationCompletedEvent = transitionToStepFlow.ShowAnimationCompletedEvent;
            MarkAsCompletedAnimationCompletedEvent = transitionToStepFlow.MarkAsCompletedAnimationCompletedEvent;
        }
    }
    
    [Serializable]
    [RequireTracker(typeof(StepsFlowEventsTracker))] [ObjectiveCategory(ObjectiveCategoryList.UI)]
    public class SetupStepsFlowDisplay : ObjectiveEventData, IDialogEventData, ILocalizable
    {
        [Serializable]
        public class StepInformationContainer : IEnumerable<StepInformation>
        {
            [SerializeField]
            private List<StepInformation> stepsInformation = new();
            
            public StepInformation this[int i] => stepsInformation[i];
            public int Count => stepsInformation.Count;

            public StepInformationContainer()
            {
                stepsInformation = new();
            }
            
            public StepInformationContainer(StepInformationContainer copy)
            {
                stepsInformation = new List<StepInformation>();
                foreach (StepInformation stepInformation in copy.stepsInformation)
                {
                    stepsInformation.Add(new StepInformation(stepInformation));
                }
            }

            public IEnumerator<StepInformation> GetEnumerator()
            {
                return stepsInformation.GetEnumerator();
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                return GetEnumerator();
            }
        }
        
        [SerializeField][IDSelection(LdxIdSettings.IdType.TrackingFeature)]
        private string displayID;
        public string DisplayID => displayID;
        public string DialogID => displayID;
        
        [SerializeField] [SerializableContainer]
        private StepInformationContainer stepsInformationContainer = new StepInformationContainer();
        public StepInformationContainer StepsInformationContainer => stepsInformationContainer;
        
        public override bool OnValidate()
        {
            base.OnValidate();
            foreach (StepInformation step in stepsInformationContainer)
            {
                if (step.AudioClips.Count == 0)
                {
                    step.AudioClips.Add(new LocalizedAudioClip(Language.English, (AudioClip)null));
                    return true;
                }
            }

            return false;
        }
        
        public List<ReactiveDialogData> GetReactiveDialogData()
        {
            List<ReactiveDialogData> result = new();
            foreach (StepInformation step in stepsInformationContainer)
            {
                result.Add(
                    new ReactiveDialogData(
                        textGetter: () => step.StepTitle,
                        textSetter: t => step.StepTitle = t,
                        step.AudioClips));
                
                result.Add(
                    new ReactiveDialogData(
                        textGetter: () => step.StepDescription,
                        textSetter: t => step.StepDescription = t,
                        step.AudioClips));
            }

            return result;
        }

        public void ProcessLocalizationKeys(LocalizationTable table)
        {
            foreach (StepInformation step in stepsInformationContainer)
            {
                step.ProcessLocalizationKeys(table);
            }
        }
    }

    [Serializable] 
    [RequireTracker(typeof(StepsFlowEventsTracker))] [ObjectiveCategory(ObjectiveCategoryList.UI)]
    public class TransitionToStepFlow : ObjectiveEventData
    {
        [SerializeField] [IDSelection(LdxIdSettings.IdType.Dialog)]
        private string stepID;
        public string StepID => stepID;
        
        [SerializeField] [IDSelection(LdxIdSettings.IdType.Transform)]
        private string animatedAttentionLineId;
        public string AnimatedAttentionLineId => animatedAttentionLineId;
        
        [Space]
        [Header("Progress track")]
        [SerializeField]
        private ProgressTrackMethod progressTrackMethod = ProgressTrackMethod.TrackingEvents;
        public ProgressTrackMethod ProgressMethod => progressTrackMethod;

        [Header("Progress: Tracking events")]
        [SerializeField][IDSelection(LdxIdSettings.IdType.TrackingEvent)] 
        private List<string> eventsToTrackProgress;
        public List<string> EventsToTrackProgress => eventsToTrackProgress;
        
        [Header("Progress: Duration")]
        [SerializeField]
        private float progressDuration = 0f;
        public float ProgressDuration => progressDuration;
        
        [Space]
        [Header("Events to listen:")]
        [SerializeField][IDSelection(LdxIdSettings.IdType.TrackingEvent)] 
        private string completeFlowStepOnEvent;
        public string CompleteFlowStepOnEvent => completeFlowStepOnEvent;
        
        [Space]
        [Header("Events to broadcast:")]
        [SerializeField][IDSelection(LdxIdSettings.IdType.TrackingEvent)] 
        private string showAnimationCompletedEvent;
        public string ShowAnimationCompletedEvent => showAnimationCompletedEvent;

        [SerializeField][IDSelection(LdxIdSettings.IdType.TrackingEvent)] 
        private string markAsCompletedAnimationCompletedEvent;
        public string MarkAsCompletedAnimationCompletedEvent => markAsCompletedAnimationCompletedEvent;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/StepsFlowEventData.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/TeleportationEventDatas.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f68bf98859204f98ab1ae55eec145fda
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
    /// <summary>
    /// Event data used to signal the enabling or disabling of a specific <see cref="Ldx.Framework.Systems.Teleportation.TeleportationZone"/>.
    /// This data is typically processed by a <see cref="Ldx.Framework.Systems.Teleportation.TeleportationZonesManager"/>
    /// or a similar system responsible for managing teleportation zone states.
    /// </summary>
    [Serializable] [ObjectiveCategory(ObjectiveCategoryList.TELEPORTATION)]
    public class EnableDisableTeleportationZoneEventData : ObjectiveEventData
    {
        [SerializeField] [IDSelection(LdxIdSettings.IdType.Transform)]
        private string zoneID;
        public string ZoneID => zoneID;

        [SerializeField] private bool setEnabled = true;
        public bool SetEnabled => setEnabled;

        public EnableDisableTeleportationZoneEventData() { }
        
        public EnableDisableTeleportationZoneEventData(EnableDisableTeleportationZoneEventData copy) : base(copy)
        {
            zoneID = copy.zoneID;
            setEnabled = copy.setEnabled;
        }
    }
    
    /// <summary>
    /// Event data used to signal that the preview for a specific <see cref="Ldx.Framework.Systems.Teleportation.TeleportationZone"/>
    /// should be forcibly enabled or shown. This typically overrides the normal visibility rules
    /// tied to teleportation system activation.
    /// </summary>
    [Serializable] [ObjectiveCategory(ObjectiveCategoryList.TELEPORTATION)]
    public class EnableTeleportationZonePreviewEventData : ObjectiveEventData
    {
        [SerializeField] [IDSelection(LdxIdSettings.IdType.Transform)]
        private string zoneID;
        public string ZoneID => zoneID;
        
        public EnableTeleportationZonePreviewEventData() { }
        
        public EnableTeleportationZonePreviewEventData(EnableTeleportationZonePreviewEventData copy) : base(copy)
        {
            zoneID = copy.zoneID;
        }
    }
    
    /// <summary>
    /// Event data used to signal that the forced preview for a specific <see cref="Ldx.Framework.Systems.Teleportation.TeleportationZone"/>
    /// should be disabled or hidden. This typically removes a previously applied force-show state,
    /// allowing the zone's visibility to be controlled by standard teleportation system activation.
    /// </summary>
    [Serializable] [ObjectiveCategory(ObjectiveCategoryList.TELEPORTATION)]
    public class DisableTeleportationZonePreviewEventData : ObjectiveEventData
    {
        [SerializeField] [IDSelection(LdxIdSettings.IdType.Transform)]
        private string zoneID;
        public string ZoneID => zoneID;
        
        public DisableTeleportationZonePreviewEventData() { }
        
        public DisableTeleportationZonePreviewEventData(DisableTeleportationZonePreviewEventData copy) : base(copy)
        {
            zoneID = copy.zoneID;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/TeleportationEventDatas.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/TetherActionEventDatas.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2b53ca45a7c74650a7c0b99e6d5d63d8
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.Tethers;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Systems.Objectives.EventData
{
    [RequireTracker(typeof(TetherEventsTracker))]
    [Serializable]
    [ObjectiveCategory(ObjectiveCategoryList.TETHER)]
    public class TetherActionEventData : ObjectiveEventData
    {
        [SerializeField]
        private TetherController.TetherEnum tether;
        public TetherController.TetherEnum Tether => tether;

        public enum Action
        {
            SetActive,
            Move,
            SummonToPlayer,
        }

        [SerializeField]
        private Action tetherAction;
        public Action TetherAction => tetherAction;
        
        [SerializeField]
        private bool setActive;
        public bool SetActive => setActive;
        
        [Header("Move or Summon")]
        [SerializeField][IDSelection(LdxIdSettings.IdType.Transform)]
        private string moveToTransform;
        public string MoveToTransform => moveToTransform;

        [SerializeField]
        private bool useOtherTetherPosition = false;
        public bool UseOtherTetherPosition => useOtherTetherPosition;
        
        [SerializeField]
        private TetherController.TetherEnum otherTetherToMoveTo;
        public TetherController.TetherEnum OtherTetherToMoveTo => otherTetherToMoveTo;
        
        [SerializeField]
        private bool keepLocalPositioning;
        public bool KeepLocalPositioning => keepLocalPositioning;
        
        [SerializeField]
        private bool useTween = true;
        public bool UseTween => useTween;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/TetherActionEventDatas.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/TimersEventDatas.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a0dd2d52dc4e4f6597cf08201e5523d9
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
    [Serializable][ObjectiveCategory(ObjectiveCategoryList.TIMERS)]
    public class TrackingFeatureEventData : ObjectiveEventData
    {
        [IDSelection(LdxIdSettings.IdType.TrackingFeature)]
        [SerializeField]
        private string feature;
        public string Feature => feature;
        
        public TrackingFeatureEventData() { }
        
        public TrackingFeatureEventData(TrackingFeatureEventData copy) : base(copy)
        {
            feature = copy.feature;
        }
    }
    
    [Serializable][ObjectiveCategory(ObjectiveCategoryList.TIMERS)]
    public class StartTrackingFeature : TrackingFeatureEventData
    {
        public StartTrackingFeature() { }
        public StartTrackingFeature(StartTrackingFeature copy) : base(copy) { }
    }

    [ObjectiveCategory(ObjectiveCategoryList.TIMERS)]
    [Serializable]
    public class StartCounterTrackingFeatureEventData : TrackingFeatureEventData
    {
        [SerializeField]
        private EventCounterTrackingFeature.CounterTrackingType trackingType;
        public EventCounterTrackingFeature.CounterTrackingType TrackingType => trackingType;

        [IDSelection(LdxIdSettings.IdType.TrackingEvent)] 
        [SerializeField]
        private List<string> eventsToTrack;
        public List<string> EventsToTrack => eventsToTrack;
        
        [Header("Only applies to 'Same Id Count'")]
        [Min(1)]
        [SerializeField] 
        private int targetCount = 1;
        public int TargetCount => targetCount;
        
        public StartCounterTrackingFeatureEventData() { }
        
        public StartCounterTrackingFeatureEventData(StartCounterTrackingFeatureEventData copy) : base(copy)
        {
            trackingType = copy.trackingType;
            eventsToTrack = new List<string>(copy.eventsToTrack);
            targetCount = copy.targetCount;
        }
    }

    [ObjectiveCategory(ObjectiveCategoryList.TIMERS)]
    [Serializable]
    public class StartDialogTrackingFeatureEventData : TrackingFeatureEventData, ILocalizable
    {
        [Serializable]
        public class NotesInfo: ILocalizable
        {
            [IDSelection(LdxIdSettings.IdType.Dialog)] 
            [SerializeField]
            private string dialogToTrack;

            public string DialogToTrack => dialogToTrack;

            [SerializeField][LocalizationKey]
            public string noteTitle;
            public string NoteTitle => noteTitle;

            public NotesInfo(NotesInfo copy)
            {
                dialogToTrack = copy.dialogToTrack;
                noteTitle = copy.noteTitle;
            }
            
            public void ProcessLocalizationKeys(LocalizationTable table)
            {
                table.ProcessLocalizationKey(ref noteTitle);
            }
        }
        
        [Serializable]
        public class NotesInfoContainer : IEnumerable<NotesInfo>
        {
            [SerializeField]
            private List<NotesInfo> info = new List<NotesInfo>();

            public NotesInfoContainer() { }
            
            public NotesInfoContainer(NotesInfoContainer copy)
            {
                info.Clear();
                foreach (NotesInfo notesInfo in copy.info)
                {
                    info.Add(new NotesInfo(notesInfo));
                }
            }
            
            public IEnumerator<NotesInfo> GetEnumerator()
            {
                return info.GetEnumerator();
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                return GetEnumerator();
            }
        }

        [SerializableContainer] 
        [SerializeField]
        private NotesInfoContainer dialogInfo = new();

        public NotesInfoContainer DialogInfo => dialogInfo;
        
        public StartDialogTrackingFeatureEventData() { }
        
        public StartDialogTrackingFeatureEventData(StartDialogTrackingFeatureEventData copy) : base(copy)
        {
            dialogInfo = new NotesInfoContainer(copy.dialogInfo);
        }
        
        public void ProcessLocalizationKeys(LocalizationTable table)
        {
            foreach (NotesInfo notesInfo in dialogInfo)
            {
                notesInfo.ProcessLocalizationKeys(table);
            }
        }
    }

    [ObjectiveCategory(ObjectiveCategoryList.TIMERS)]
    [Serializable]
    public class StopTrackingFeatureEventData : TrackingFeatureEventData
    {
        public StopTrackingFeatureEventData() { }
        public StopTrackingFeatureEventData(StopTrackingFeatureEventData copy) : base(copy) { }
    }

    [ObjectiveCategory(ObjectiveCategoryList.TIMERS)]
    [Serializable]
    public class TrackingEventTriggerEventData : ObjectiveEventData
    {
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)] 
        [SerializeField]
        private string eventToTrigger;

        public string EventToTrigger => eventToTrigger;
        
        public TrackingEventTriggerEventData() { }
        
        public TrackingEventTriggerEventData(TrackingEventTriggerEventData copy) : base(copy)
        {
            eventToTrigger = copy.eventToTrigger;
        }
    }

    [ObjectiveCategory(ObjectiveCategoryList.TIMERS)]
    [Serializable]
    public class TriggerEventAfterTimeEventData : TrackingEventTriggerEventData
    {
        [SerializeField] 
        private float time;

        public float Time => time;
        
        public TriggerEventAfterTimeEventData() { }
        
        public TriggerEventAfterTimeEventData(TriggerEventAfterTimeEventData copy) : base(copy)
        {
            time = copy.time;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/TimersEventDatas.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/TransitionEventDatas.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cb29a41590aa4bdfa9c56d32f002e5e2
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
    [Serializable][ObjectiveCategory(ObjectiveCategoryList.TRANSITIONS)]
    public class TransitionAndResetToSpawnPointEventData : ObjectiveEventData
    {
        [SerializeField]
        private bool revealWhenGrounded = true;
        public bool RevealWhenGrounded => revealWhenGrounded;
        
        [SerializeField]
        private bool keepCurrentOrientation;
        public bool KeepCurrentOrientation => keepCurrentOrientation;

        [SerializeField]
        private bool useYPosition = true;
        public bool UseYPosition => useYPosition;

        [SerializeField]
        private bool dontResetSockets;
        public bool DontResetSockets => dontResetSockets;

        [IDSelection(LdxIdSettings.IdType.Transform)]
        [SerializeField]
        private string spawnPoint;
        public string SpawnPoint => spawnPoint;
        
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField]
        private List<string> eventsOnFadeOut;
        public List<string> EventsOnFadeOut => eventsOnFadeOut;

        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField]
        private List<string> eventsOnFadeIn;
        public List<string> EventsOnFadeIn => eventsOnFadeIn;
        
        public TransitionAndResetToSpawnPointEventData() { }
        
        public TransitionAndResetToSpawnPointEventData(TransitionAndResetToSpawnPointEventData copy) : base(copy)
        {
            revealWhenGrounded = copy.revealWhenGrounded;
            keepCurrentOrientation = copy.keepCurrentOrientation;
            useYPosition = copy.useYPosition;
            dontResetSockets = copy.dontResetSockets;
            spawnPoint = copy.spawnPoint;
            eventsOnFadeOut = new List<string>(copy.eventsOnFadeOut);
            eventsOnFadeIn = new List<string>(copy.eventsOnFadeIn);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/TransitionEventDatas.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/UIEventDatas.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8fa5d0b747b646eb9d7bfed9fa585bd3
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.UI;
using Ldx.Framework.Systems.UI.Modules.Tooltip;
using Ldx.Framework.Utilities.Attributes;
using Systems.Sound;
using TMPro;
using UnityEngine;
using UnityEngine.Audio;

namespace Ldx.Framework.Systems.Objectives
{
    public interface IDialogEventData
    {
        public string DialogID { get; }
        public List<ReactiveDialogData> GetReactiveDialogData();
    }
    
    [ObjectiveCategory(ObjectiveCategoryList.UI)]
    [Serializable]
    public class DialogEventData : ObjectiveEventData, IDialogEventData, ILocalizable
    {
        [Serializable]
        public class DialogInfo : IPlayAudioEventData, ILocalizable
        {
            [SerializeField][LocalizationKey]
            private string dialogDescription;

            public string DialogDescription
            {
                get => dialogDescription;
                set => dialogDescription = value;
            }

            [SerializeField][IDSelection(LdxIdSettings.IdType.Transform)]
            private string speakerTransform;
            public string SpeakerTransform => speakerTransform;

            [SerializeField]private bool usePreviousSpeakerIfNeeded = true;
            public bool UsePreviousSpeakerIfNeeded => usePreviousSpeakerIfNeeded;
            
            [SerializeField]
            private DialogueWindow.AnchorSide anchorSide = DialogueWindow.AnchorSide.Top;
            public DialogueWindow.AnchorSide AnchorSide => anchorSide;
            
            [Serializable]
            public class AnswerInfo: ILocalizable
            {
                [SerializeField][LocalizationKey]
                private string answerText;
                public string AnswerText => answerText;

                [SerializeField] 
                private bool isCorrectAnswer;
                public bool IsCorrectAnswer => isCorrectAnswer;
            
                public AnswerInfo(){}

                public AnswerInfo(string text, bool isCorrectAnswer)
                {
                    answerText = text;
                    this.isCorrectAnswer = isCorrectAnswer;
                }
                
                public AnswerInfo(AnswerInfo copy)
                {
                    answerText = copy.answerText;
                    isCorrectAnswer = copy.isCorrectAnswer;
                }

                public void ProcessLocalizationKeys(LocalizationTable table)
                {
                    table.ProcessLocalizationKey(ref answerText);
                }
            }

            [Serializable]
            public class AnswersContainer : IEnumerable<AnswerInfo>
            {
                [SerializeField] private List<AnswerInfo> answers = new List<AnswerInfo>();

                public int Count => answers.Count;

                public AnswersContainer()
                {
                    answers = new List<AnswerInfo>();
                }
                
                public AnswersContainer(AnswersContainer copy)
                {
                    answers = new List<AnswerInfo>();
                    foreach (AnswerInfo answer in copy.answers)
                    {
                        answers.Add(new AnswerInfo(answer));
                    }
                }
            
                public void Add(AnswerInfo info)
                {
                    answers.Add(info);
                }

                public void AddRange(IEnumerable<AnswerInfo> list)
                {
                    answers.AddRange(list);
                }
            
                public IEnumerator<AnswerInfo> GetEnumerator()
                {
                    return answers.GetEnumerator();
                }

                IEnumerator IEnumerable.GetEnumerator()
                {
                    return GetEnumerator();
                }
            }
            
            [SerializableContainer]
            [SerializeField] 
            private AnswersContainer answers = new AnswersContainer();
            public AnswersContainer Answers => answers;
            
            [SerializeField]
            private DialogueWindow.AnswerButtonLayout answerButtonLayout = DialogueWindow.AnswerButtonLayout.Horizontal;
            public DialogueWindow.AnswerButtonLayout AnswerButtonLayout => answerButtonLayout;
            
            public enum EventType
            {
                OnCorrectAnswer,
                OnWrongAnswer,
                OnTimerRunOut, 
                OnDialogStart
            }

            [Serializable]
            public class EventCallGroup
            {
                [SerializeField]
                private EventType triggerEvent;
                public EventType TriggerEvent => triggerEvent;
                [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
                [SerializeField]
                private List<string> invokeEventsOnTrigger = new List<string>();
                public List<string> InvokeEventsOnTrigger => invokeEventsOnTrigger;
            }

            [SerializeField]
            private List<EventCallGroup> eventCallGroups = new List<EventCallGroup>();

            public List<string> GetEventsByTriggerEvent(EventType type)
            {
                List<string> result = eventCallGroups.FirstOrDefault(x => x.TriggerEvent == type)
                    ?.InvokeEventsOnTrigger;
                return result ?? new();
            }
            
            [Header("VOs")]
            [SerializeField] private List<LocalizedAudioClip> audioClips = new();
            public List<LocalizedAudioClip> AudioClips => audioClips;
            public string SoundReference => null;
            public string SoundSettingsID => string.Empty;
            public bool CanBeInterrupted => true;
            
            [SerializeField][HelpBox("If left unassigned, will use default mixing (Project Settings > LDX > Audio)")]
            private AudioMixerGroup customMixerGroup;
            public AudioMixerGroup AudioMixerGroup => customMixerGroup;

            [Serializable]
            public class UIEventOptions
            {
                [Header("Custom time")]
                [SerializeField] 
                private float customTime;
                public float CustomTime => customTime;

                [Header("Highlighting")]
                [SerializeField]
                private bool blockHighlightingUntilCompleted;
                public bool BlockHighlightingUntilCompleted => blockHighlightingUntilCompleted;
            }

            [Header("Options")]
            [SerializeField]
            private UIEventOptions eventOptions;
            public UIEventOptions EventOptions => eventOptions;
            
            public DialogInfo() { }
            
            public DialogInfo(DialogInfo copy)
            {
                dialogDescription = copy.dialogDescription;
                answers = new AnswersContainer(copy.answers);
                eventCallGroups = new List<EventCallGroup>(copy.eventCallGroups);
                audioClips = new List<LocalizedAudioClip>(copy.audioClips);
                customMixerGroup = copy.customMixerGroup;
                eventOptions = copy.eventOptions;
            }

            public void ProcessLocalizationKeys(LocalizationTable table)
            {
                table.ProcessLocalizationKey(ref dialogDescription);

                foreach (AnswerInfo answer in answers)
                {
                    answer.ProcessLocalizationKeys(table);
                }
            }

#if UNITY_EDITOR
            public void EDITOR_ClearAnswers()
            {
                answers = new AnswersContainer();
            }

            public void EDITOR_AddAnswer(string text, bool correct)
            {
                answers.Add(new AnswerInfo(text, correct));
            }
#endif
        }
        
        [Serializable]
        public class DialogContainer : IEnumerable<DialogInfo>
        {
            [SerializeField]
            private List<DialogInfo> dialogs = new List<DialogInfo>();

            public DialogInfo this[int i] => dialogs[i];
            public int Count => dialogs.Count;
            
            public DialogContainer(DialogContainer copy)
            {
                dialogs = new List<DialogInfo>();
                foreach (DialogInfo dialog in copy.dialogs)
                {
                    dialogs.Add(new DialogInfo(dialog));
                }
            }

            public IEnumerator<DialogInfo> GetEnumerator()
            {
                return dialogs.GetEnumerator();
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                return GetEnumerator();
            }
        }
        
        [IDSelection(LdxIdSettings.IdType.Dialog)]
        [SerializeField]
        private string dialogId;
        public string DialogID => dialogId;

        [SerializableContainer]
        [SerializeField]
        private DialogContainer dialogs;
        public DialogContainer Dialogs => dialogs;
        
        public DialogEventData() { }
        
        public DialogEventData(DialogEventData copy) : base(copy)
        {
            dialogId = copy.dialogId;
            dialogs = new DialogContainer(copy.dialogs);
        }

        public override bool OnValidate()
        {
            base.OnValidate();
            foreach (DialogInfo dialog in dialogs)
            {
                if (dialog.AudioClips.Count == 0)
                {
                    dialog.AudioClips.Add(new LocalizedAudioClip(Language.English, (AudioClip)null));
                    return true;
                }
            }

            return false;
        }

        public void ProcessLocalizationKeys(LocalizationTable table)
        {
            foreach (DialogInfo dialogInfo in dialogs)
            {
                dialogInfo.ProcessLocalizationKeys(table);
            }
        }

        public List<ReactiveDialogData> GetReactiveDialogData()
        {
            List<ReactiveDialogData> result = new();
            foreach (DialogInfo info in dialogs)
            {
                result.Add(
                    new ReactiveDialogData(
                        textGetter: ()=>info.DialogDescription,
                    textSetter:(t)=> info.DialogDescription = t,
                    info.AudioClips));
            }

            return result;
        }
    }
    
    [ObjectiveCategory(ObjectiveCategoryList.UI)]
    [Serializable]
    public class TutorialDialogEventData : DialogEventData
    {
        [SerializableContainer]
        [SerializeField]
        private OptionsContainer inputOptions;

        public OptionsContainer InputOptions => inputOptions;
        
        public TutorialDialogEventData() { }
        
        public TutorialDialogEventData(TutorialDialogEventData copy) : base(copy)
        {
            inputOptions = new OptionsContainer(copy.inputOptions);
        }
    }

    [Serializable]
    [ObjectiveCategory(ObjectiveCategoryList.UI)]
    public class CloseDialogEventData : ObjectiveEventData
    {
        public CloseDialogEventData() { }
        public CloseDialogEventData(CloseDialogEventData copy) : base(copy) { }
    }

    [Serializable]
    [ObjectiveCategory(ObjectiveCategoryList.UI)]
    public class ShowScenarioSelectionWindow : ObjectiveEventData
    {
        public ShowScenarioSelectionWindow() { }
        public ShowScenarioSelectionWindow(ShowScenarioSelectionWindow copy) : base(copy) { }
    }

    [Serializable]
    [ObjectiveCategory(ObjectiveCategoryList.UI)]
    public class CloseScenarioSelectionWindow : ObjectiveEventData
    {
        public CloseScenarioSelectionWindow() { }
        public CloseScenarioSelectionWindow(CloseScenarioSelectionWindow copy) : base(copy) { }
    }

    [Serializable]
    [ObjectiveCategory(ObjectiveCategoryList.UI)]
    public class OverlayActionEventData : ObjectiveEventData
    {
        public enum Action
        {
            FadeIn,
            FadeOut
        }
        
        [SerializeField]
        private Action overlayAction;
        public Action OverlayAction => overlayAction;
        
        public OverlayActionEventData() { }
        
        public OverlayActionEventData(OverlayActionEventData copy) : base(copy)
        {
            overlayAction = copy.overlayAction;
        }
    }
    
    [ObjectiveCategory(ObjectiveCategoryList.UI)]
    [Serializable][RequireTracker(typeof(UIEventsTracker))]
    public class ChangeWindowPositionModeEventData : ObjectiveEventData
    {
        [SerializeField]
        private UIController.WindowType windowType;
        public UIController.WindowType WindowType => windowType;

        [SerializeField]
        private UIElement.PositionMode positionModeToSet = UIElement.PositionMode.Static;
        public UIElement.PositionMode PositionModeToSet => positionModeToSet;

        public ChangeWindowPositionModeEventData() { }
        
        public ChangeWindowPositionModeEventData(ChangeWindowPositionModeEventData copy) : base(copy)
        {
            windowType = copy.windowType;
            positionModeToSet = copy.positionModeToSet;
        }
    }
    
    [Serializable] [ObjectiveCategory(ObjectiveCategoryList.UI)]
    public class ShowWorldTooltipEventData : ObjectiveEventData
    {
        [SerializeField]
        private List<TooltipParameters> tooltipsToShow = new();
        public List<TooltipParameters> TooltipsToShow => tooltipsToShow;

        public ShowWorldTooltipEventData() { }
        
        public ShowWorldTooltipEventData(ShowWorldTooltipEventData copy) : base(copy)
        {
            tooltipsToShow.Clear();
            foreach (TooltipParameters tooltipParameters in copy.tooltipsToShow)
            {
                tooltipsToShow.Add(new TooltipParameters(tooltipParameters));
            }
        }
    }
    
    [Serializable] [ObjectiveCategory(ObjectiveCategoryList.UI)]
    public class HideWorldTooltipEventData : ObjectiveEventData
    {
        [SerializeField]
        private bool hideAll = false;
        public bool HideAll => hideAll;
        
        [SerializeField] [IDSelection(LdxIdSettings.IdType.Transform)]
        private List<string> tooltipTargetsToHide = new();
        public List<string> TooltipTargetsToHide => tooltipTargetsToHide;

        public HideWorldTooltipEventData() { }
        
        public HideWorldTooltipEventData(HideWorldTooltipEventData copy) : base(copy)
        {
            hideAll = copy.hideAll;
            tooltipTargetsToHide = new List<string>();
            foreach (string target in copy.tooltipTargetsToHide)
            {
                tooltipTargetsToHide.Add(target);
            }
        }
    }

    [Serializable][ObjectiveCategory(ObjectiveCategoryList.UI)]
    public class TrackUIWindowOpenCloseEventData : ObjectiveEventData
    {
        public enum Action
        {
            Open,
            Close
        }

        [SerializeField] private Action actionToTrack = Action.Open;
        public Action ActionToTrack => actionToTrack;

        [SerializeField] private UIController.WindowType windowType = UIController.WindowType.MainMenu;
        public UIController.WindowType WindowType => windowType;
        
        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string invokeTrackingEventOnSuccess;
        public string InvokeTrackingEventOnSuccess => invokeTrackingEventOnSuccess;
        
        public TrackUIWindowOpenCloseEventData() { }
        
        public TrackUIWindowOpenCloseEventData(TrackUIWindowOpenCloseEventData copy) : base(copy)
        {
            actionToTrack = copy.actionToTrack;
            windowType = copy.windowType;
            invokeTrackingEventOnSuccess = copy.invokeTrackingEventOnSuccess;
        }
    }
  
    [Serializable]
    public class OptionInfo
    {
        [Serializable]
        public enum TutorialInputOptions
        {
            CanSkipWithInput = 0,
            CompletesOnTeleportation,
            CompletesOnAnythingGrabbed,
            CompletesOnAnythingHighlighted,
            EditorOnlyCanSkipWithInput
        }
        
        public TutorialInputOptions option;
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        public List<string> eventsOnSuccess;
        public bool closeOnSuccess;
        
        public OptionInfo(OptionInfo copy)
        {
            option = copy.option;
            eventsOnSuccess = new List<string>(copy.eventsOnSuccess);
            closeOnSuccess = copy.closeOnSuccess;
        }
    }

    [Serializable]
    public class OptionsContainer : IEnumerable<OptionInfo>
    {
        [SerializeField] private List<OptionInfo> options = new();

        public int Count => options.Count;
        
        public OptionsContainer(OptionsContainer copy)
        {
            options = new List<OptionInfo>();
            foreach (OptionInfo option in copy.options)
            {
                options.Add(new OptionInfo(option));
            }
        }
            
        public IEnumerator<OptionInfo> GetEnumerator()
        {
            return options.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/UIEventDatas.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/VisualFeedbackEventDatas.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c2fec614fade470599ba2256c0340a2a
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Features.GhostController;
using Ldx.Framework.Systems.Player.Hands;
using Ldx.Framework.Systems.UI;
using Ldx.Framework.Systems.VFX;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.Video;

namespace Ldx.Framework.Systems.Objectives
{
    [Serializable][ObjectiveCategory(ObjectiveCategoryList.VISUAL_FEEDBACK)]
    public class ClearFXEventData : ObjectiveEventData
    {
        [SerializeField] private float delay;
        public ClearFXEventData() { }
        public ClearFXEventData(ClearFXEventData copy) : base(copy) { }
        public float Delay => delay;
    }
    
    [Serializable][ObjectiveCategory(ObjectiveCategoryList.VISUAL_FEEDBACK)]
    public class PlayVideoEventData : ObjectiveEventData
    {
        [Serializable]
        public enum VideoFormat
        {
            m4v = 0,
            mp4
        }

        [SerializeField] 
        private VideoSource videoSource = VideoSource.VideoClip;
        public VideoSource VideoSource => videoSource;

        [SerializeField]
        [IDSelection(LdxIdSettings.IdType.Transform)]
        private string positionTransform;
        public string PositionTransform => positionTransform;

        [SerializeField]
        private bool relyOnNearestAnchorInstead = true;
        public bool RelyOnNearestAnchorInstead => relyOnNearestAnchorInstead;

        [SerializeField] 
        private VideoClip videoClip;
        public VideoClip VideoClip => videoClip;
        
        [SerializeField]
        private string videoName;
        public string VideoName => videoName;
        
        [SerializeField] 
        private VideoFormat videoFormat;
        public VideoFormat Format => videoFormat;

        [SerializeField]
        private Sprite preview;
        public Sprite Preview => preview;

        [SerializeField] 
        private bool playOnLoad;
        public bool PlayOnLoad => playOnLoad;
        
        [SerializeField]
        private bool enableSkip;
        public bool EnableSkip => enableSkip;

        [SerializeField]
        private float skipDelay;
        public float SkipDelay => skipDelay;
        
        public PlayVideoEventData() { }
        
        public PlayVideoEventData(PlayVideoEventData copy) : base(copy)
        {
            videoSource = copy.videoSource;
            positionTransform = copy.positionTransform;
            relyOnNearestAnchorInstead = copy.relyOnNearestAnchorInstead;
            videoClip = copy.videoClip;
            videoName = copy.videoName;
            videoFormat = copy.videoFormat;
            preview = copy.preview;
            playOnLoad = copy.playOnLoad;
            enableSkip = copy.enableSkip;
            skipDelay = copy.skipDelay;
        }
    }
    
    [Serializable][ObjectiveCategory(ObjectiveCategoryList.VISUAL_FEEDBACK)]
    public class PlayUIParticleEventData : ObjectiveEventData
    {
        [SerializeField]
        private bool isCorrectParticles = true;
        public bool IsCorrectParticles => isCorrectParticles;
        
        public PlayUIParticleEventData() { }
        
        public PlayUIParticleEventData(PlayUIParticleEventData copy) : base(copy)
        {
            isCorrectParticles = copy.isCorrectParticles;
        }
    }
    
    [Serializable][ObjectiveCategory(ObjectiveCategoryList.VISUAL_FEEDBACK)]
    public class PlayFxEventData : ObjectiveEventData
    {
        [SerializeField]
        private LdxFxController.FX fx;
        [SerializeField, IDSelection(LdxIdSettings.IdType.Transform)]
        private string position;
        [SerializeField]
        private Vector3 offset = Vector3.zero;
        [SerializeField]
        private float scale = 1;
        [SerializeField]
        private Vector3 direction = Vector3.zero;
        [SerializeField]
        private float destroyAfter = 0;
        [SerializeField]
        private bool clearsOnObjectiveEnd = true;
        [SerializeField]
        private bool matchReferencedTransform;
        public bool MatchReferencedTransform => matchReferencedTransform;
        
        public LdxFxController.FX FX => fx;
        public string Position => position;
        public Vector3 Offset => offset;
        public float Scale => scale;
        public Vector3 Direction => direction;
        public float DestroyAfter => destroyAfter;
        public bool ClearsOnObjectiveEnd => clearsOnObjectiveEnd;
        
        public PlayFxEventData() { }
        
        public PlayFxEventData(PlayFxEventData copy) : base(copy)
        {
            fx = copy.fx;
            position = copy.position;
            scale = copy.scale;
            destroyAfter = copy.destroyAfter;
            clearsOnObjectiveEnd = copy.clearsOnObjectiveEnd;
            matchReferencedTransform = copy.matchReferencedTransform;
        }
    }
    
    [Serializable][ObjectiveCategory(ObjectiveCategoryList.VISUAL_FEEDBACK)]
    public class SetHandMeshEnabled: ObjectiveEventData
    {
        [SerializeField]
        private bool enabled;
        public bool Enabled => enabled;
        
        public SetHandMeshEnabled() { }
        
        public SetHandMeshEnabled(SetHandMeshEnabled copy) : base(copy)
        {
            enabled = copy.enabled;
        }
    }
    
    [Serializable][ObjectiveCategory(ObjectiveCategoryList.VISUAL_FEEDBACK)]
    public class DisableHandMeshOnGrabEventData: ObjectiveEventData
    {
        [SerializeField]
        private bool enable;
        public bool Enable => enable;
        
        public DisableHandMeshOnGrabEventData() { }
        
        public DisableHandMeshOnGrabEventData(DisableHandMeshOnGrabEventData copy) : base(copy)
        {
            enable = copy.enable;
        }
    }

    [Serializable][ObjectiveCategory(ObjectiveCategoryList.VISUAL_FEEDBACK)]
    public class ActivateSocketToHolsterGuideEventData : ObjectiveEventData
    {
        [IDSelection(LdxIdSettings.IdType.Socketable)]
        [SerializeField]
        private List<string> socketableIDs = new List<string>();
        public List<string> SocketableIDs => socketableIDs;

        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField]
        private string completionEvent;
        public string CompletionEvent => completionEvent;
        
        public ActivateSocketToHolsterGuideEventData() { }
        
        public ActivateSocketToHolsterGuideEventData(ActivateSocketToHolsterGuideEventData copy) : base(copy)
        {
            completionEvent = copy.completionEvent;
        }
    }
    
    [Serializable][ObjectiveCategory(ObjectiveCategoryList.VISUAL_FEEDBACK)]
    public class DeactivateSocketToHolsterGuideEventData : ObjectiveEventData
    {
        public DeactivateSocketToHolsterGuideEventData() { }
        public DeactivateSocketToHolsterGuideEventData(DeactivateSocketToHolsterGuideEventData copy) : base(copy) { }
    }
    
    [Serializable][ObjectiveCategory(ObjectiveCategoryList.VISUAL_FEEDBACK)]
    public class HighlighterEffectStateEventData : ObjectiveEventData
    {
        [IDSelection(LdxIdSettings.IdType.TrackingFeature)]
        [SerializeField] 
        private string highlighterFeatureId;

        public string HighlighterFeatureId => highlighterFeatureId;
        
        [SerializeField]
        private bool highlighted;
        public bool Highlighted => highlighted;
        
        [SerializeField] 
        private bool resetOnObjectiveEnd;
        public bool ResetOnObjectiveEnd => resetOnObjectiveEnd;
        
        public HighlighterEffectStateEventData() { }
        
        public HighlighterEffectStateEventData(HighlighterEffectStateEventData copy) : base(copy)
        {
            highlighterFeatureId = copy.highlighterFeatureId;
            highlighted = copy.highlighted;
            resetOnObjectiveEnd = copy.resetOnObjectiveEnd;
        }
    }
    
    [Serializable][ObjectiveCategory(ObjectiveCategoryList.VISUAL_FEEDBACK)]
    public class DisplayDialogObjectEventData : ObjectiveEventData
    {
        [FormerlySerializedAs("id")]
        [IDSelection(LdxIdSettings.IdType.Transform)]
        [SerializeField]
        private string dialogueTransform;
        public string DialogueTransform => dialogueTransform;

        [SerializeField]
        private UIElement.PositionMode positionMode;
        public UIElement.PositionMode PositionMode => positionMode;

        [SerializeField]
        private Vector3 offset;
        public Vector3 Offset => offset;
        
        public DisplayDialogObjectEventData() { }
        
        public DisplayDialogObjectEventData(DisplayDialogObjectEventData copy) : base(copy)
        {
            dialogueTransform = copy.dialogueTransform;
            positionMode = copy.positionMode;
            offset = copy.offset;
        }
    }
    
    [Serializable][ObjectiveCategory(ObjectiveCategoryList.VISUAL_FEEDBACK)]
    public class AlignmentLineRendererEventData : ObjectiveEventData
    {
        [IDSelection(LdxIdSettings.IdType.Transform)]
        [SerializeField]
        private string startTransform;
        public string StartTransform => startTransform;
        
        [IDSelection(LdxIdSettings.IdType.Transform)]
        [SerializeField]
        private string endTransfrom;
        public string EndTransform => endTransfrom;

        public enum ActionType
        {
            Activate,
            Deactivate
        }
        
        [SerializeField] private ActionType actionType;
        public ActionType Action => actionType;
        
        public AlignmentLineRendererEventData() { }
        
        public AlignmentLineRendererEventData(AlignmentLineRendererEventData copy) : base(copy)
        {
            startTransform = copy.startTransform;
            endTransfrom = copy.endTransfrom;
            actionType = copy.actionType;
        }
    }
    
    [Serializable][ObjectiveCategory(ObjectiveCategoryList.VISUAL_FEEDBACK)]
    public class ShowDemonstrationControllerEventData : ObjectiveEventData
    {
        [SerializeField] private ControllerAction actionToDemonstrate;
        public ControllerAction ActionToDemonstrate => actionToDemonstrate;

        [SerializeField] private List<HandSide> handSides = new();
        public List<HandSide> HandSides => handSides;

        [SerializeField] private bool hideOnActionExecuted = true;
        public bool HideOnActionExecuted => hideOnActionExecuted;

        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string eventBroadcastOnHide;
        public string EventBroadcastOnHide => eventBroadcastOnHide;
        
        public ShowDemonstrationControllerEventData() { }
        
        public ShowDemonstrationControllerEventData(ShowDemonstrationControllerEventData copy) : base(copy)
        {
            actionToDemonstrate = copy.actionToDemonstrate;
            handSides.Clear();
            foreach (HandSide handSide in copy.handSides)
            {
                handSides.Add(handSide);
            }

            eventBroadcastOnHide = copy.eventBroadcastOnHide;
        }
    }
    
    [Serializable][ObjectiveCategory(ObjectiveCategoryList.VISUAL_FEEDBACK)]
    public class HideDemonstrationControllersEventData : ObjectiveEventData
    {
        [SerializeField] private bool anyControllers = true;
        public bool AnyControllers => anyControllers;

        [ShowIf(nameof(anyControllers), Op.Equals, false)]
        [SerializeField] private List<HandSide> handSides = new();
        public List<HandSide> HandSides => handSides;
        
        public HideDemonstrationControllersEventData() { }
        
        public HideDemonstrationControllersEventData(HideDemonstrationControllersEventData copy) : base(copy)
        {
            anyControllers = copy.anyControllers;
            handSides.Clear();
            foreach (HandSide handSide in copy.handSides)
            {
                handSides.Add(handSide);
            }
        }
    }
    
    [Serializable][ObjectiveCategory(ObjectiveCategoryList.VISUAL_FEEDBACK)]
    public class GhostHandGuideEventData : ObjectiveEventData
    {
        public enum StartPositionTypes
        {
            ViewportCentre = 1,
            StartTransform = 2
        }
        
        [SerializeField] private HandSide handSide = HandSide.Right;
        public HandSide HandSide => handSide;

        [Space]
        [SerializeField] private StartPositionTypes startPositionType = StartPositionTypes.ViewportCentre;
        public StartPositionTypes StartPositionType => startPositionType;
        
        [IDSelection(LdxIdSettings.IdType.Transform)]
        [ShowIf(nameof(startPositionType), Op.Equals, StartPositionTypes.StartTransform)]
        [SerializeField] private string startPosition;
        public string StartPosition => startPosition;
        
        [IDSelection(LdxIdSettings.IdType.Transform)]
        [SerializeField] private string targetPosition;
        public string TargetPosition => targetPosition;
        
        [Space]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)] 
        [SerializeField] private string resetTrackingEvent;
        public string ResetTrackingEvent => resetTrackingEvent;
        
        [SerializeField] private bool resetOnObjectiveEnd;
        public bool ResetOnObjectiveEnd => resetOnObjectiveEnd;
        
        [SerializeField] private float handMoveTime = 1;
        public float HandMoveTime => handMoveTime;
        
        [SerializeField] private float handDistanceFromEyes = .4572f;
        public float HandDistanceFromEyes => handDistanceFromEyes;
        
        [SerializeField] private float restartDelay = 1;
        public float RestartDelay => restartDelay;
        
        public GhostHandGuideEventData() { }
        
        public GhostHandGuideEventData(GhostHandGuideEventData copy) : base(copy)
        {
            handSide = copy.handSide;
            startPositionType = copy.startPositionType;
            startPosition = copy.startPosition;
            targetPosition = copy.targetPosition;
            resetTrackingEvent = copy.resetTrackingEvent;
            resetOnObjectiveEnd = copy.resetOnObjectiveEnd;
            handMoveTime = copy.handMoveTime;
            handDistanceFromEyes = copy.handDistanceFromEyes;
            restartDelay = copy.restartDelay;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/EventData/VisualFeedbackEventDatas.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Feedback/ObjectiveFeedbackData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e53f7d0e15e64583b5056b3ceca4a393
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Feedback
{
    [Serializable]
    public enum FeedbackType
    {
        Tooltip = 0,
        Warning
    }
        
    [Serializable]
    public enum ConditionEvaluationType
    {
        And = 0,
        Or
    }

    [Serializable]
    public enum PositioningType
    {
        ObjectiveTransform = 0,
        CircleFollow
    }

    [Serializable]
    public enum FeedbackDurationType
    {
        ReadingTime = 0,
        CustomTime,
        UntilObjectiveComplete
    }

    /// <summary>
    /// Data for defining feedback related to objectives
    /// </summary>
    [Serializable]
    public class ObjectiveFeedbackData : ILocalizable
    {
        [Header("Feedback")] 
        [SerializeField] 
        private FeedbackType feedbackType;
        public FeedbackType FeedbackType => feedbackType;
        
        [SerializeField] 
        private PositioningType positioningType = PositioningType.ObjectiveTransform;
        public PositioningType PositioningType => positioningType;

        [HelpBox("Applicable only if Positioning Type = Objective Transform")]
        [IDSelection(LdxIdSettings.IdType.Transform)]
        [SerializeField]
        private string positionTransformId;
        public string PositionTransformID => PositioningType == PositioningType.ObjectiveTransform? positionTransformId : null;
        
        [SerializeField][LocalizationKey]
        private string feedbackMessage;
        public string FeedbackMessage => feedbackMessage;
        public string LocalizedFeedbackMessage => LocalizationGlobalSettings.LocalizationEnabled ? LocalizationModel.GetTextString(feedbackMessage) : feedbackMessage;

        [Header("Target Event")]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] 
        private string trackingEvent;
        public string TrackingEvent => trackingEvent;

        [SerializableContainer("Condition")]
        [SerializeField] 
        private KeyConditionContainer keyConditions = new KeyConditionContainer();

        [SerializeField]
        private ConditionEvaluationType evaluationType = ConditionEvaluationType.And;

        [Header("Duration")] 
        [SerializeField]
        private FeedbackDurationType durationType = FeedbackDurationType.ReadingTime;
        public FeedbackDurationType DurationType => durationType;
        
        [HelpBox("Applicable only if Duration Type = Custom Time")]
        [SerializeField]
        private float customTime;
        public float CustomTime => customTime;

        [HelpBox("Applicable only if Duration Type = Until Objective End")]
        [SerializeField]
        private bool canFinishWithSubObjective;
        public bool CanFinishWithSubObjective => canFinishWithSubObjective;
        
        [Header("Settings")]
        [SerializeField] 
        private bool onlyBroadcastOnce = true;
        public bool OnlyBroadcastOnce => onlyBroadcastOnce;
        
        [SerializeField] 
        private bool finishCurrentObjectiveWhenFeedbackCompletes;
        public bool FinishCurrentObjectiveWhenFeedbackCompletes => finishCurrentObjectiveWhenFeedbackCompletes;
        
        public ObjectiveFeedbackData()
        {
        }

        public ObjectiveFeedbackData(FeedbackType feedbackType, PositioningType positioningType, string positionTransformId,
            string feedbackMessage, string trackingEvent, KeyConditionContainer keyConditions = null,
            ConditionEvaluationType evaluationType =  ConditionEvaluationType.And,
            FeedbackDurationType durationType = FeedbackDurationType.ReadingTime,
            float customTime = 0f, bool canFinishWithSubObjective = false,
            bool onlyBroadcastOnce = true, bool finishCurrentObjectiveWhenFeedbackCompletes = false)
        {
            this.feedbackType = feedbackType;
            this.positioningType = positioningType;
            this.positionTransformId = positionTransformId;
            this.feedbackMessage = feedbackMessage;
            this.trackingEvent = trackingEvent;
            this.keyConditions = keyConditions ?? new KeyConditionContainer();
            this.evaluationType = evaluationType;
            this.durationType = durationType;
            this.customTime = customTime;
            this.canFinishWithSubObjective = canFinishWithSubObjective;
            this.onlyBroadcastOnce = onlyBroadcastOnce;
            this.finishCurrentObjectiveWhenFeedbackCompletes = finishCurrentObjectiveWhenFeedbackCompletes;
        }
        
        public bool Evaluate()
        {
            if (evaluationType == ConditionEvaluationType.And)
            {
                return EvaluateAnd();
            }
            return EvaluateOr();
        }

        private bool EvaluateAnd()
        {
            foreach (KeyCondition condition in keyConditions)
            {
                if (!condition.Evaluate())
                {
                    return false;
                }
            }

            return true;
        }
        
        private bool EvaluateOr()
        {
            foreach (KeyCondition condition in keyConditions)
            {
                if (condition.Evaluate())
                {
                    return true;
                }
            }

            if (keyConditions.Count < 1)
            {
                return true;
            }

            return false;
        }

        public void ProcessLocalizationKeys(LocalizationTable table)
        {
            table.ProcessLocalizationKey(ref feedbackMessage);
        }
    }

    [Serializable]
    public class ObjectiveFeedbackDataContainer : IEnumerable<ObjectiveFeedbackData>
    {
        [SerializeField] 
        private List<ObjectiveFeedbackData> feedbackList = new List<ObjectiveFeedbackData>();

        public void Add(ObjectiveFeedbackData data)
        {
            feedbackList.Add(data);    
        }

        public void Add(List<ObjectiveFeedbackData> data)
        {
            feedbackList.AddRange(data);
        }
        
        public IEnumerator<ObjectiveFeedbackData> GetEnumerator()
        {
            return feedbackList.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }

    /// <summary>
    /// A condition check for a tracking key's value to be used with feedback
    /// </summary>
    [Serializable]
    public class KeyCondition
    {
        //[HelpBox("Feedback is displayed if the key value matches, not the other way around")]
        [IDSelection(LdxIdSettings.IdType.Key)]
        [SerializeField]
        private string key;

        [SerializeField]
        private bool value;

        public bool Evaluate()
        {
            bool? result = TrackingKeyController.Instance.GetKeyValue(key);
            return result == value;
        }
    }
    
    [Serializable]
    public class KeyConditionContainer : IEnumerable<KeyCondition>
    {
        [SerializeField] 
        private List<KeyCondition> conditions = new List<KeyCondition>();

        public int Count => conditions.Count;

        public KeyConditionContainer() { }

        public IEnumerator<KeyCondition> GetEnumerator()
        {
            return conditions.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Feedback/ObjectiveFeedbackData.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Feedback/ObjectiveFeedbackManager.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f346656b2e674e65a5910c01d9f799d2
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Feedback
{
    // TODO: Remove ObjectiveWarningManager once its usages been replaced with ObjectiveFeedbackManager
    /// <summary>
    /// Manages objective feedback data in the inspector, reports them in play mode
    /// </summary>
    public class ObjectiveFeedbackManager : MonoBehaviour, ILocalizable
    {
        private const int REPORT_DELAY_MS = 500;
        /// <summary>
        /// Feedback manager, feedback data, and a callback action when the feedback is finished displaying
        /// </summary>
        public static event Action<ObjectiveFeedbackManager, ObjectiveFeedbackData, Action> OnObjectiveFeedback;
        public static event Action<ObjectiveFeedbackManager, ObjectiveFeedbackData> OnObjectiveFeedbackFinished;
        
        private readonly HashSet<ObjectiveFeedbackData> blockedFeedbackSet = new HashSet<ObjectiveFeedbackData>();
        readonly private Dictionary<string, ObjectiveFeedbackData> idToFeedbackDataMap =
            new Dictionary<string, ObjectiveFeedbackData>();
        
        [SerializableContainer("Feedback")]
        [SerializeField] 
        private ObjectiveFeedbackDataContainer objectiveFeedbackDataContainer;
        
        private Scenario scenario;

        private void Awake()
        {
            InitDictionary();
            scenario = FindFirstObjectByType<Scenario>();
            if (scenario != null)
            {
                scenario.OnScenarioStarted += HandleScenarioStarted;
            }
        }
        
        private void InitDictionary()
        {
            idToFeedbackDataMap.Clear();
            foreach (ObjectiveFeedbackData feedback in objectiveFeedbackDataContainer)
            {
                idToFeedbackDataMap[feedback.TrackingEvent] = feedback;
            }
        }

        private IEnumerator Start()
        {
            yield return new WaitUntil(() => LdxTrackingManager.IsValid);
            LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
        }

        private void OnDestroy()
        {
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }
           
            if (scenario != null)
            {
                scenario.OnScenarioStarted -= HandleScenarioStarted;
            }
        }

        private void HandleScenarioStarted(BaseScenario _)
        {
            blockedFeedbackSet.Clear();
        }

        public void AddFeedbackData(ObjectiveFeedbackData feedbackData)
        {
            objectiveFeedbackDataContainer.Add(feedbackData);
            InitDictionary();
        }
        
        private void HandleTrackingEvent(string id)
        {
            if (!idToFeedbackDataMap.TryGetValue(id, out ObjectiveFeedbackData feedbackData))
            {
                return;
            }

            if (!feedbackData.Evaluate())
            {
                return;
            }
            
            BroadcastFeedback(feedbackData);
        }

        private void BroadcastFeedback(ObjectiveFeedbackData feedbackData)
        {
            if (blockedFeedbackSet.Contains(feedbackData))
            {
                return;
            }

            if (feedbackData.OnlyBroadcastOnce)
            {
                blockedFeedbackSet.Add(feedbackData);
            }

            // Delay for now to avoid feedback displaying before new window
#pragma warning disable CS4014
            broadcastFeedbackAsync();
#pragma warning restore CS4014
            
            async UniTaskVoid broadcastFeedbackAsync()
            {
                await UniTask.Delay(REPORT_DELAY_MS);
                OnObjectiveFeedback?.Invoke(this, feedbackData, handleFeedbackScreenFinished);
            }
            
            void handleFeedbackScreenFinished()
            {
                OnObjectiveFeedbackFinished?.Invoke(this, feedbackData);
                if (feedbackData.FinishCurrentObjectiveWhenFeedbackCompletes)
                {
                    ObjectiveSystem.Instance.ForceCompleteObjectiveStep();
                }
            }
        }

        public void ProcessLocalizationKeys(LocalizationTable table)
        {
            foreach (ObjectiveFeedbackData feedbackData in objectiveFeedbackDataContainer)
            {
                feedbackData.ProcessLocalizationKeys(table);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Feedback/ObjectiveFeedbackManager.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ID/ExtensionIDDefinition.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 46d2d2c8ccd1419ea07aab178b850353
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;

namespace Ldx.Framework.Systems.Objectives.ID
{
    /// <summary>
    /// Inherit from this class to define a new ID extension to be added as a category
    /// </summary>
    [Serializable]
    public abstract class ExtensionIDDefinition
    {
        public abstract string CustomID { get; }
        public abstract string DisplayName { get; }
        public IdTypeWrapper IdTypeWrapper => new(LdxIdSettings.IdType.Extension, DisplayName, CustomID);
    }

    [Serializable]
    public abstract class ExtensionIDDefinition<T> : ExtensionIDDefinition where T : ExtensionIDDefinition<T>, new()
    {
        private static T definition;

        public static T Definition
        {
            get
            {
                if (definition == null)
                {
                    definition = new T();
                }

                return definition;
            }
        }
        
        public override string CustomID => GetCustomID();
        
        public static string GetCustomID()
        {
            return typeof(T).Name;
        }

        public static IdTypeWrapper GetIdTypeWrapper()
        {
            return Definition.IdTypeWrapper;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ID/ExtensionIDDefinition.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ID/ExtensionIDInfoContainer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 701db16a68df4118b5f030c6c6969263
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.ID
{
    /// <summary>
    /// Specialized container for ID extensions
    /// </summary>
    [Serializable]
    public class ExtensionIDInfoContainer : IDInfoContainer
    {
        [SerializeField] private string customId;
        [SerializeField] private string displayName;
        public string CustomID => customId;
        public string DisplayName => displayName;
        public IdTypeWrapper IdTypeWrapper => new(LdxIdSettings.IdType.Extension, DisplayName, CustomID);

        public ExtensionIDInfoContainer(string customId, string displayName)
        {
            this.customId = customId;
            this.displayName = displayName;
        }

        public ExtensionIDInfoContainer(ExtensionIDDefinition definition)
        {
            customId = definition.CustomID;
            displayName = definition.DisplayName;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ID/ExtensionIDInfoContainer.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ID/IDHelpers.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 878c4b251862460986d2b612215b0fdc
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;

namespace Ldx.Framework.Systems.Objectives.ID
{
    public static class IDHelpers
    {
        /// <summary>
        /// Given a list of extension containers and a custom ID, returns the corresponding container
        /// </summary>
        public static bool TryGetExtensionContainerByID(List<ExtensionIDInfoContainer> container, string customID, out ExtensionIDInfoContainer result)
        {
            result = container.FirstOrDefault(c => c.CustomID == customID);
            return result != null;
        }
        
        public static bool TryGetExtensionContainerByType<T>(List<ExtensionIDInfoContainer> container, out ExtensionIDInfoContainer result)
        where T : ExtensionIDDefinition<T>, new()
        {
            result = container.FirstOrDefault(c => c.CustomID == typeof(T).Name);
            return result != null;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ID/IDHelpers.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ID/IdTypeWrapper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f789aeb7c5dd40c99624f3baa618b698
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities.Extensions;

namespace Ldx.Framework.Systems.Objectives.ID
{
    /// <summary>
    /// Wrapper struct for IdType to help emulate extending the enum
    /// Contains implicit casting to/from the enum
    /// </summary>
    public readonly struct IdTypeWrapper
    {
        public LdxIdSettings.IdType IDType { get; }
        public string DisplayName { get; }
        public string CustomID { get; }

        public IdTypeWrapper(LdxIdSettings.IdType idType, string displayName, string customID = null)
        {
            IDType = idType;
            DisplayName = displayName;
            CustomID = customID;
        }

        public static implicit operator IdTypeWrapper(LdxIdSettings.IdType value)
        {
            return new IdTypeWrapper(value, GetDisplayName(value));
        }

        public static implicit operator LdxIdSettings.IdType(IdTypeWrapper wrapper)
        {
            return wrapper.IDType;
        }

        public static string GetDisplayName(LdxIdSettings.IdType type)
        {
            return type.ToString().SeparateWords() + 's';
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ID/IdTypeWrapper.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/InteractableID.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b983eee7bd0a4b56a5a1b290abe147eb
# ASMDEF: ldx.framework.runtime.dll
# ---
using Autohand;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
    /// <summary>
    /// Marks a scene object with an InteractableID, to be used with InteractableEventsTracker
    /// </summary>
    [TrackedReference]
    public class InteractableID : MonoBehaviour, ISaveSceneListener
    {
        public enum InteractionSources
        {
            Grabbable = 0,
            Socket
        }
        
        [IDSelection(LdxIdSettings.IdType.Interactable)] [SerializeField]
        private string id;
        public string ID => id;

        [Hide]
        [SerializeField] private InteractionSources interactionSource;
        public InteractionSources InteractionSource => interactionSource;

        [Hide] 
        [SerializeField] private MonoBehaviour interactionSourceReference;
        public MonoBehaviour InteractionSourceReference => interactionSourceReference;
        
        public PlacePoint Socket => interactionSourceReference as PlacePoint;
        public Grabbable Grabbable => interactionSourceReference as Grabbable; 
        
        public void OnSceneSaving()
        {
            RefreshInteractionSource();
        }

        public void SetupRuntime(string id)
        {
            this.id = id;
            RefreshInteractionSource();
        }
        
        private void RefreshInteractionSource()
        {
            if (TryGetComponent(out Grabbable grabbable))
            {
                interactionSource = InteractionSources.Grabbable;
                interactionSourceReference = grabbable;
            }
            else if (TryGetComponent(out PlacePoint socket))
            {
                interactionSource = InteractionSources.Socket;
                interactionSourceReference = socket;
            }
        }

#if UNITY_EDITOR
        public void EDITOR_SetupNewID(string description, bool isGlobal)
        {
            id = StringUtilities.GenerateUniqueId();
            IDInfo idInfo = new IDInfo(id, description);
            LdxIdSettings settings =
                isGlobal ? LdxIdSettings.GlobalInstance : LdxIdSettings.GetScenarioIDSettings();
            settings.EDITOR_AddIdInfo(idInfo, LdxIdSettings.IdType.Interactable);
            RefreshInteractionSource();
            UnityEditor.EditorUtility.SetDirty(this);
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/InteractableID.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/InteractableIDEditorConfig.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 83fafe21ac20467f85ab1f77d7987269
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
    /// <summary>
    /// Added discretely to the scene (hidden in hierarchy) to cache already processed objects for use
    /// with the AddInteractionIDsOnSceneSaving script when opening the window through scene saving
    /// </summary>
    public class InteractableIDEditorConfig : MonoBehaviour
    {
        [Hide]
        [SerializeField] private List<MonoBehaviour> alreadyProcessed = new ();
        public List<MonoBehaviour> AlreadyProcessed => alreadyProcessed;

        public void Sanitize()
        {
            alreadyProcessed = new HashSet<MonoBehaviour>(alreadyProcessed.Where(a => a != null)).ToList();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/InteractableIDEditorConfig.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/IObjective.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 696733874ac9494b8a9240cd940fad66
# ASMDEF: ldx.framework.runtime.dll
# ---
namespace Ldx.Framework.Systems.Objectives
{
    /// <summary>
    /// Interface for objectives
    /// </summary>
    public interface IObjective
    {
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/IObjective.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/LdxIdSettings.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 85a529101c874852b4926c262b27c887
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Objectives.Attributes;
using Ldx.Framework.Systems.Objectives.ID;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Ldx.Framework.Systems.Objectives
{
    public class LdxIdSettings : ScriptableObject
    {
        public enum InstanceTypeResult
        {
            Global = 0,
            CurrentScenario = 1,
            NotInSceneMode = 2,
            Framework = 3,
            Other = 4,
        }

        // Enum values account for removed fields
        public enum IdType
        {
            TrackingEvent = 0,
            ObjectGroup = 2,
            TrackingFeature = 3,
            Key = 4,
            Transform = 5,
            Dialog = 6,
            Socketable = 7,
            Interactable = 11,
            Objective = 8,
            [GlobalOnly]
            Scenario = 9,
            Extension = 1000
        }

        private const string GLOBAL_ID_SETTINGS_FILENAME = "ID_Global";
        private const string FRAMEWORK_ID_SETTINGS_FILENAME = "ID_Framework";
        private const string FRAMEWORK_ID_SETTINGS_PATH = "Packages/com_ldx_framework/Runtime/Resources/";
        private const string FILE_EXTENSION = "asset";
        private const int DURATION_TO_SUPPRESS_ERRORS_MS = 50000;
		
        private static string LoadPath => $"Data/IDSettings";
        private static string SavePath => $"Assets{_}Resources{_}Data{_}IDSettings";
        private static bool CanShowError { get; set; } = true;
        private static char _ => Path.DirectorySeparatorChar;
        private static LdxIdSettings globalInstance;
        private static LdxIdSettings frameworkInstance;

        private List<IDInfoContainer> allInfoContainers;

        private List<IDInfoContainer> AllInfoContainers
        {
            get
            {
                if (allInfoContainers != null)
                {
                    return allInfoContainers;
                }

                allInfoContainers = new List<IDInfoContainer>();

                Type t = GetType();
                FieldInfo[] fields =
                    typeof(LdxIdSettings).GetFields(
                        BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);

                foreach (FieldInfo f in fields)
                {
                    if (f.FieldType == typeof(IDInfoContainer))
                    {
                        IDInfoContainer c = f.GetValue(this) as IDInfoContainer;
                        allInfoContainers.Add(c);
                    }
                }
				
                allInfoContainers.AddRange(extensionIdContainers);
                return allInfoContainers;
            }
        }

        [SerializeField] private bool isGlobal;
        public bool IsGlobal => isGlobal;

        [Hide]
        [SerializeField]
        private string associatedScenarioId;

        public string AssociatedScenarioID
        {
            get => associatedScenarioId;
            set => associatedScenarioId = value;
        }
			
        [SerializeField] private IDInfoContainer trackingEventsIds;
        [SerializeField] private IDInfoContainer objectGroupIds;
        [SerializeField] private IDInfoContainer trackingFeatureIds;
        [SerializeField] private IDInfoContainer keyIds;
        [SerializeField] private IDInfoContainer transformIds;
        [SerializeField] private IDInfoContainer dialogIds;
        [SerializeField] private IDInfoContainer socketableIds;
        [SerializeReference] private List<ExtensionIDInfoContainer> extensionIdContainers = new();
		
        [SerializeField] 
        private IDInfoContainer scenarioIds;
        [SerializeField] 
        private IDInfoContainer objectiveIds;
        [SerializeField] 
        private IDInfoContainer interactableIds;
		
        public IDInfoContainer TrackingEventsIDs => trackingEventsIds;
        public IDInfoContainer ObjectGroupIDs => objectGroupIds;
        public IDInfoContainer TrackingFeatureIDs => trackingFeatureIds;
        public IDInfoContainer KeyIDs => keyIds;
        public IDInfoContainer TransformIDs => transformIds;
        public IDInfoContainer DialogIDs => dialogIds;
        public IDInfoContainer SocketableIDs => socketableIds;
        public IDInfoContainer ScenarioIDs => scenarioIds;
        public IDInfoContainer ObjectiveIDs => objectiveIds;
        public IDInfoContainer InteractableIDs => interactableIds;
        public List<ExtensionIDInfoContainer> ExtensionIDContainers => extensionIdContainers;
        public static string FullGlobalPath => SavePath + "/" + GLOBAL_ID_SETTINGS_FILENAME + "." + FILE_EXTENSION;
        public static string FullFrameworkPath => FRAMEWORK_ID_SETTINGS_PATH + FRAMEWORK_ID_SETTINGS_FILENAME + "." + FILE_EXTENSION;

        public static LdxIdSettings FrameworkInstance
        {
            get
            {
                if (frameworkInstance == null)
                {
                    frameworkInstance = Resources.Load<LdxIdSettings>(FRAMEWORK_ID_SETTINGS_FILENAME);
                }
				
                return frameworkInstance;
            }
        }
		
        public static LdxIdSettings GlobalInstance
        {
            get
            {
                if (globalInstance == null)
                {
                    globalInstance = GetOrCreateNewIDSettings(GLOBAL_ID_SETTINGS_FILENAME);
                    globalInstance.isGlobal = true;
                    TryMigrateFromOldGlobalIDsFile();
                }

                return globalInstance;
            }
        }

#if UNITY_EDITOR
        public IdTypeWrapper? EDITOR_LaunchIdTab { get; set; }
#endif

        private void OnValidate()
        {
            extensionIdContainers.RemoveAll(x => x == null);
        }

        public static bool TryGetIDDescription(string id, IdTypeWrapper type, out string description, bool searchAllScenarios = false)
        {
            description = null;
            // TODO: Optimize when the ID settings refactor is in place in the future
            if (searchAllScenarios)
            {
                foreach (LdxIdSettings settings in GetAllIDSettings())
                {
                    foreach (IDInfoContainer container in settings.AllInfoContainers)
                    {
                        foreach (IDInfo info in container)
                        {
                            if (info.ID == id)
                            {
                                description = info.Description;
                                return true;
                            }
                        }
                    }
                }

                return false;
            }
			
            if (!GetCompoundIDList(type).TryGetIDDescription(id, out string outDescription))
            {
                return false;
            }

            description = outDescription;
            return true;
        }
		
        public static CompoundIDInfoContainer GetCompoundIDList(IdTypeWrapper type, LdxIdSettings scenarioSettings = null)
        {
            // In prefab mode, avoid local IDs
            if (PrefabHelper.IsInPrefabStaging())
            {
                return new CompoundIDInfoContainer(GetIDListForSettings(GlobalInstance, type), null, FrameworkInstance != null ? GetIDListForSettings(FrameworkInstance, type) : null);
            }

            LdxIdSettings sceneSettings = scenarioSettings == null? GetScenarioIDSettings() : scenarioSettings;
            IDInfoContainer sceneContainer = sceneSettings != null? GetIDListForSettings(sceneSettings, type) : null;
            IDInfoContainer globalContainer = GetIDListForSettings(GlobalInstance, type);
            IDInfoContainer frameworkContainer = FrameworkInstance != null ? GetIDListForSettings(FrameworkInstance, type) : null;
            CompoundIDInfoContainer result = new CompoundIDInfoContainer(globalContainer, sceneContainer, frameworkContainer);
            return result;
        }

        public static CompoundIDInfoContainer GetCompoundIDListAllScenarios(IdTypeWrapper type)
        {
            // In prefab mode, avoid local IDs
            if (PrefabHelper.IsInPrefabStaging())
            {
                return new CompoundIDInfoContainer(GetIDListForSettings(GlobalInstance, type));
            }

            IDInfoContainer[] allLocalContainers = GetAllIDSettings()
                .Where(s => !s.isGlobal)
                .Select(s => GetIDListForSettings(s, type)).ToArray();
            IDInfoContainer globalContainer = GetIDListForSettings(GlobalInstance, type);
            IDInfoContainer frameworkContainer = FrameworkInstance != null ? GetIDListForSettings(FrameworkInstance, type) : null;

            return new CompoundIDInfoContainer(globalContainer, frameworkContainer, allLocalContainers);
        }

        public static IDInfoContainer GetIDListForSettings(LdxIdSettings settings, IdTypeWrapper typeWrapper)
        {
            IdType type = typeWrapper;
			
            if (type == IdType.Extension)
            {
                if (!IDHelpers.TryGetExtensionContainerByID(settings.extensionIdContainers, typeWrapper.CustomID,
                        out ExtensionIDInfoContainer extensionContainer))
                {
                    Debug.LogError($"Can't find extension ID container for: {typeWrapper.CustomID} {(settings.isGlobal? "global":"local")}");
                    return null;
                }

                return extensionContainer;
            }
            switch (type)
            {
                case IdType.TrackingEvent:
                    return settings.TrackingEventsIDs;
                case IdType.ObjectGroup:
                    return settings.ObjectGroupIDs;
                case IdType.TrackingFeature:
                    return settings.TrackingFeatureIDs;
                case IdType.Key:
                    return settings.KeyIDs;
                case IdType.Transform:
                    return settings.TransformIDs;
                case IdType.Dialog:
                    return settings.DialogIDs;
                case IdType.Socketable:
                    return settings.SocketableIDs;
                case IdType.Scenario:
                    return settings.ScenarioIDs;
                case IdType.Objective:
                    return settings.ObjectiveIDs;
                case IdType.Interactable:
                    return settings.InteractableIDs;
                default:
                    throw new ArgumentOutOfRangeException(nameof(type), type, null);
            }
        }

        public static string GetLoadPath(string filename) => $"{LoadPath}{_}{filename}";
        public static string GetSavePath(string filename) => $"{SavePath}{_}{filename}.{FILE_EXTENSION}";

        public static LdxIdSettings GetScenarioIDSettings()
        {
            if (LdxScenarioConfig.Instance == null)
            {
                // Create new scenario config
                if (!LdxScenarioConfig.TryAddNewScenarioConfig(out string errorMessage))
                {
#if UNITY_EDITOR
                    if (CanShowError)
                    {
                        Debug.LogError(errorMessage);
                        CanShowError = false;
                        waitThenEnableShowingErrorsAsync().Forget();
                    }

                    return null;
#endif
                }
            }

            LdxScenarioConfig config = LdxScenarioConfig.Instance;

            if (config.AreIDSettingsEmpty())
            {
                config.FillIDSettingsFields();
            }

            if (config.ReferenceType == LdxScenarioConfig.FileReferenceType.InspectorReference)
            {
                return config.IDSettingsFile;
            }
			
            return GetOrCreateNewIDSettings(LdxScenarioConfig.Instance.IDSettingsFilename);

#if UNITY_EDITOR
            async UniTaskVoid waitThenEnableShowingErrorsAsync()
            {
                await UniTask.Delay(DURATION_TO_SUPPRESS_ERRORS_MS);
                CanShowError = true;
            }
#endif
        }

        public static List<LdxIdSettings> GetAllIDSettings()
        {
            return Resources.LoadAll<LdxIdSettings>(GetLoadPath("")).ToList();
        }
		
        private static LdxIdSettings GetOrCreateNewIDSettings(string filename)
        {
            string dir = $"{Application.dataPath}{_}{SavePath.Replace($"Assets{_}", "")}";
            if (!Application.isPlaying)
            {
                if (!Directory.Exists(dir))
                {
                    Directory.CreateDirectory(dir);
                }	
            }

            LdxIdSettings result = Resources.Load<LdxIdSettings>(GetLoadPath(filename));

            if (result == null)
            {
                if (!Application.isPlaying)
                {
                    result = CreateInstance<LdxIdSettings>();
#if UNITY_EDITOR
                    AssetDatabase.CreateAsset(result, GetSavePath(filename));
                    AssetDatabase.SaveAssets();
                    AssetDatabase.Refresh();
#endif
                    Debug.Log("Created new instance");
                }
                else
                {
                    Debug.LogError($"ID SETTINGS ERROR: Couldn't load ID settings at {GetLoadPath(filename)}");
                }
            }


            return result;
        }

        private static void TryMigrateFromOldGlobalIDsFile()
        {
#if UNITY_EDITOR
            if (Application.isPlaying)
            {
                return;
            }
            LdxIdSettings oldFile = Resources.Load<LdxIdSettings>($"Data{_}IdSettings");
            if (oldFile == null)
            {
                return;
            }

            LdxIdSettings newFile = GetOrCreateNewIDSettings(GLOBAL_ID_SETTINGS_FILENAME);
            newFile.Copy(oldFile);
            EditorUtility.SetDirty(newFile);
            File.Delete($"Assets{_}Resources{_}Data{_}IdSettings.asset");
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
#endif
        }

        public static InstanceTypeResult GetInstanceType(LdxIdSettings idSettings)
        {
            if (PrefabHelper.IsInPrefabStaging())
            {
                return InstanceTypeResult.NotInSceneMode;
            }

            if (idSettings == GlobalInstance)
            {
                return InstanceTypeResult.Global;
            }

            if (idSettings == FrameworkInstance)
            {
                return InstanceTypeResult.Framework;
            }

            if (idSettings == GetScenarioIDSettings())
            {
                return InstanceTypeResult.CurrentScenario;
            }

            return InstanceTypeResult.Other;

        }

#if UNITY_EDITOR
        [MenuItem("LogicalDox/ID Settings/Global IDs", false, priority: 0)]
        public static void HighlightGlobalIDsFileMenuItem()
        {
            HighlightGlobalIDsFile();
        }
		
        public static void HighlightGlobalIDsFile(IdTypeWrapper? idType = null)
        {
            LdxIdSettings idSettings = GlobalInstance;
            idSettings.EDITOR_LaunchIdTab = idType;
            Selection.activeObject = idSettings;
        }
        
        [MenuItem("LogicalDox/ID Settings/Framework IDs", false, priority: 0)]
        public static void HighlightFrameworkIDsFileMenuItem()
        {
            HighlightFrameworkIDsFile();
        }
        
        public static void HighlightFrameworkIDsFile(IdTypeWrapper? idType = null)
        {
            LdxIdSettings idSettings = FrameworkInstance;
            if (idSettings == null)
            {
                Debug.LogWarning("Framework ID Settings file (ID_Framework.asset) not found in the project.");
                return;
            }
            idSettings.EDITOR_LaunchIdTab = idType;
            Selection.activeObject = idSettings;
        }
        
        [MenuItem("LogicalDox/ID Settings/Scenario IDs", false, priority: 0)]
        public static void HighlightScenarioIDsFileMenuItem()
        {
            HighlightScenarioIDsFile();
        }
		
        public static void HighlightScenarioIDsFile(IdTypeWrapper? idType = null)
        {
            LdxIdSettings idSettings = GetScenarioIDSettings();
            idSettings.EDITOR_LaunchIdTab = idType;
            Selection.activeObject = idSettings;
        }
#endif
        
        private void Awake()
        {
            foreach (IDInfoContainer c in AllInfoContainers)
            {
                if (c == null)
                {
                    Debug.LogError($"We are returning null reference in LdxIdSettings index {allInfoContainers.IndexOf(c)}, and cannot initialize, please fix this and run scenario again.");
                    return;
                }

                c.Initialize();
            }
        }

        private void Reset()
        {
            extensionIdContainers.Clear();
        }

        private void Copy(LdxIdSettings other)
        {
            FieldInfo[] fields =
                typeof(LdxIdSettings).GetFields(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
            foreach (FieldInfo f in fields)
            {
                if (f.FieldType == typeof(IDInfoContainer))
                {
                    IDInfoContainer otherContainer = f.GetValue(other) as IDInfoContainer;
                    IDInfoContainer thisContainer = f.GetValue(this) as IDInfoContainer;
                    if (thisContainer == null)
                    {
                        continue;
                    }

                    thisContainer.UnionWith(otherContainer);
                }
            }
        }

#if UNITY_EDITOR
        public void EDITOR_AddIdInfo(IDInfo info, IdTypeWrapper type)
        {
            IDInfoContainer list = GetIDListForSettings(this, type);
            list.Add(info);
            EditorUtility.SetDirty(this);
            AssetDatabase.Refresh();
        }

        public void EDITOR_RemoveIdInfo(IDInfo info, IdTypeWrapper type)
        {
            IDInfoContainer list = GetIDListForSettings(this, type);
            list.Remove(info);
            EditorUtility.SetDirty(this);
            AssetDatabase.Refresh();
        }
#endif
    }

    [Serializable]
    public class IDInfo
    {
        [Hide]
        [SerializeField]
        private string id;
        [SerializeField]
        private string description;

        [SerializeField]
        private bool isSelected;
        public bool IsSelected
        {
            get => isSelected;
            set => isSelected = value;
        }

        public string ID
        {
            get => id;
            set
            {
                if (!Application.isPlaying)
                {
                    id = value;
                }
            }
        }
        public string Description
        {
            get => description;
            set
            {
                if (!Application.isPlaying)
                {
                    description = value;
                }
            } 
        }

        public IDInfo(string newId, string newDescription)
        {
            id = newId;
            description = newDescription;
        }
    }

    [Serializable]
    public class IDInfoContainer : IEnumerable<IDInfo>
    {
        [SerializeField]
        protected List<IDInfo> infoList = new List<IDInfo>();

        private Dictionary<string, string> idToDescriptionMap = new Dictionary<string, string>();

        public int Count => infoList.Count;

        public void Initialize()
        {
            UpdateMap();
        }

        private void UpdateMap()
        {
            if (idToDescriptionMap == null)
            {
                idToDescriptionMap = new();
            }
            idToDescriptionMap.Clear();
            foreach (IDInfo info in infoList)
            {
                if (idToDescriptionMap.ContainsKey(info.ID))
                {
                    continue;
                }
                idToDescriptionMap.Add(info.ID, info.Description);
            }
        }

        public void Add(IDInfo info)
        {
            if (infoList.FirstOrDefault(i => info.ID == i.ID || info == i) != null)
            {
                Debug.LogError($"ID \"{info.Description}\" already exists in target list");
                return;
            }
            infoList.Add(info);
        }

        public void Remove(IDInfo info)
        {
            infoList.Remove(info);
            UpdateMap();
        }

        public void UnionWith(IDInfoContainer other)
        {
            UpdateMap();
            foreach (IDInfo info in other)
            {
                if (idToDescriptionMap.ContainsKey(info.ID))
                {
                    continue;
                }

                infoList.Add(info);
            }

            UpdateMap();
        }

        public string GetDescription(string id)
        {
            if (!idToDescriptionMap.TryGetValue(id, out string result))
            {
                Debug.LogError($"Couldn't get description for id {id}");
                return null;
            }

            return result;
        }

        public virtual IEnumerator<IDInfo> GetEnumerator()
        {
            return infoList.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public void OnBeforeSerialize()
        {
        }

        public void OnAfterDeserialize()
        {
        }
    }

    public class CompoundIDInfoContainer : IDInfoContainer
    {
        public IDInfoContainer GlobalContainer { get; }
        public IDInfoContainer LocalContainer { get; }
        public IDInfoContainer FrameworkContainer { get; }
        public int GlobalIDStartIndex { get; }
        public int FrameworkIDStartIndex { get; }

        public CompoundIDInfoContainer(IDInfoContainer globalContainer, IDInfoContainer localContainer = null, IDInfoContainer frameworkContainer = null)
        {
            GlobalContainer = globalContainer;
            LocalContainer = localContainer;
            FrameworkContainer = frameworkContainer;
            
            if (localContainer != null)
            {
                foreach (IDInfo l in localContainer)
                {
                    infoList.Add(l);
                }
            }

            GlobalIDStartIndex = infoList.Count;
            foreach (IDInfo g in globalContainer)
            {
                infoList.Add(g);
            }
            
            FrameworkIDStartIndex = infoList.Count;
            if (frameworkContainer != null)
            {
                foreach (IDInfo f in frameworkContainer)
                {
                    infoList.Add(f);
                }
            }
            
            Initialize();
        }

        public CompoundIDInfoContainer(IDInfoContainer globalContainer, IDInfoContainer frameworkContainer, params IDInfoContainer[] localContainers)
        {
            GlobalContainer = globalContainer;
            LocalContainer = new IDInfoContainer();
            foreach (IDInfoContainer container in localContainers)
            {
                LocalContainer.UnionWith(container);
            }
			
            foreach (IDInfo l in LocalContainer)
            {
                infoList.Add(l);
            }
			
            GlobalIDStartIndex = infoList.Count;
            foreach (IDInfo g in globalContainer)
            {
                infoList.Add(g);
            }
            
            FrameworkIDStartIndex = infoList.Count;
            if (frameworkContainer != null)
            {
                foreach (IDInfo f in frameworkContainer)
                {
                    infoList.Add(f);
                }
            }
            
            Initialize();
        }

        public bool TryGetIDDescription(string id, out string description)
        {
            description = null;
            if (GlobalContainer != null)
            {
                foreach (IDInfo info in GlobalContainer)
                {
                    if (info.ID == id)
                    {
                        description = info.Description;
                        return true;
                    }
                }
            }

            if (LocalContainer != null)
            {
                foreach (IDInfo info in LocalContainer)
                {
                    if (info.ID == id)
                    {
                        description = info.Description;
                        return true;
                    }
                }
            }

            if (FrameworkContainer != null)
            {
                foreach (IDInfo info in FrameworkContainer)
                {
                    if (info.ID == id)
                    {
                        description = info.Description;
                        return true;
                    }
                }
            }

            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/LdxIdSettings.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveCondition.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1b457131166448aba750f26b86eb9570
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
    /// <summary>
    /// Base class for a data Objective's conditions
    /// </summary>
    [Serializable]
    public abstract class ObjectiveCondition
    {
        public enum ConditionalCheckType
        {
            Mandatory = 0,
            CompletesObjectiveIfValid,
            SkipsObjectiveIfValid
        }

        [SerializeField] 
        private ConditionalCheckType checkType = ConditionalCheckType.Mandatory;
        public ConditionalCheckType CheckType => checkType;
        
        public ObjectiveCondition() { }
        
        public ObjectiveCondition(ObjectiveCondition copy)
        {
            checkType = copy.checkType;
        }
    
        public virtual bool IsConditionValid()
        {
            return true;
        }

        public virtual void BeginChecking()
        {
            ResetCondition();
        }

        public virtual void EndChecking() { }

        public abstract void ResetCondition();
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveCondition.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveEventData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a2609253f2e24df9a300e33f6def20dd
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
    public static class ObjectiveCategoryList
    {
        public const string OBJECTIVES = "Objectives";
        public const string UI = "UI";
        public const string MISC = "Misc";
        public const string VISUAL_FEEDBACK = "Visual Feedback";
        public const string FLOW_CONTROL = "Flow Control";
        public const string AUDIO = "Audio";
        public const string OBJECT_TRANSFORMS = "Objects and Transforms";
        public const string CONTROLS = "Controls";
        public const string TIMERS = "Tracking Timers";
        public const string TRANSITIONS = "Transitions";
        public const string SCENARIOS = "Scenarios";
        public const string HIGHLIGHTING = "Highlighting";
        public const string ANIMATION = "Animation";
        public const string PROJECT = "Project";
        public const string SEURAT = "Seurat";
        public const string TETHER = "Tether";
        public const string PLAYER = "Player";
        public const string TELEPORTATION = "Teleportation";
    }
    
    [Serializable]
    public class TriggerEventInfo : IEquatable<TriggerEventInfo>
    {
        [Hide]
        [SerializeField]
        private string id = String.Empty;
        public string ID => id;
        
        [SerializeField] 
        private ObjectiveEventData.TriggerEventType eventType = ObjectiveEventData.TriggerEventType.Begin;
        public ObjectiveEventData.TriggerEventType EventType => eventType;

        [SerializeField] 
        private ObjectiveEventData.InteractionEventType interactionEventType;
        public ObjectiveEventData.InteractionEventType InteractionEventType => interactionEventType;
        
        [IDSelectionShowIfEventType(ObjectiveEventData.TriggerEventType.TrackingEvent, LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField]
        private string triggerTrackingEvent;
        public string TriggerTrackingEvent => triggerTrackingEvent;

        [IDSelectionShowIfEventType(ObjectiveEventData.TriggerEventType.DialogCompleted, LdxIdSettings.IdType.Dialog)]
        [SerializeField]
        private string triggerDialogId;
        public string TriggerDialogId => triggerDialogId;

        [SerializeField] private string triggerInteractableId;
        public string TriggerInteractableID => triggerInteractableId;

        public TriggerEventInfo(ObjectiveEventData.TriggerEventType eventType, 
            string trackingEvent = "", 
            string dialogId = "",
            string id = "",
            ObjectiveEventData.InteractionEventType interactionEventType = default,
            string interactableId = "")
        {
            InitializeEventInfo(eventType, trackingEvent, dialogId, id, interactionEventType, interactableId);
        }
        
        public TriggerEventInfo(TriggerEventInfo eventInfo)
        {
            InitializeEventInfo(eventInfo.EventType, eventInfo.TriggerTrackingEvent, eventInfo.TriggerDialogId, 
                interactionEventType: eventInfo.InteractionEventType, interactableId: eventInfo.TriggerInteractableID);
        }
        
        public TriggerEventInfo(ObjectiveEventData data)
        {
            eventType = data.EventType;
            triggerTrackingEvent = data.TriggerTrackingEvent;
            triggerDialogId = data.TriggerDialogId;
            interactionEventType = data.TriggerEventInfo.InteractionEventType;
            triggerInteractableId = data.TriggerEventInfo.TriggerInteractableID;
        }

        private void InitializeEventInfo(ObjectiveEventData.TriggerEventType eventType,
            string trackingEvent = "",
            string dialogId = "",
            string id = "",
            ObjectiveEventData.InteractionEventType interactionEventType = default,
            string interactableId = "")
        {
            this.eventType = eventType;
            triggerTrackingEvent = trackingEvent;
            triggerDialogId = dialogId;
            this.interactionEventType = interactionEventType;
            triggerInteractableId = interactableId;

            if (string.IsNullOrEmpty(id))
            {
                TryGenerateId();
            }
            else
            {
                this.id = id;
            }
        }

        public void TryGenerateId()
        {
            if (!String.IsNullOrEmpty(id))
            {
                return;
            }   
            id = StringUtilities.GenerateUniqueId(minLength: 5, maxLength: 8);
        }
    
        public string GetTriggerName()
        {
            string nodeName = eventType.ToString().SeparateWords();
            switch (eventType)
            {
                case ObjectiveEventData.TriggerEventType.TrackingEvent:
                    if (LdxIdSettings.TryGetIDDescription(triggerTrackingEvent, LdxIdSettings.IdType.TrackingEvent,
                            out string description))
                    {
                        return $"Event: {description}";
                    }
                    break;
                case ObjectiveEventData.TriggerEventType.DialogCompleted:
                    if (LdxIdSettings.TryGetIDDescription(triggerDialogId, LdxIdSettings.IdType.Dialog,
                            out string dialogDescription))
                    {
                        return $"Dialog: {dialogDescription}";
                    }
                    break;
                case ObjectiveEventData.TriggerEventType.Interaction:
                    if (LdxIdSettings.TryGetIDDescription(TriggerInteractableID, LdxIdSettings.IdType.Interactable,
                            out string interactableDescription))
                    {
                        return $"{interactionEventType} ({interactableDescription})";
                    }
                    break;
            }

            return nodeName;
        }
        
        public bool Equals(TriggerEventInfo other)
        {
            if (other == null) return false;

            // Check if eventType is the same
            if (eventType != other.eventType) return false;

            // Additional checks based on eventType
            switch (eventType)
            {
                case ObjectiveEventData.TriggerEventType.TrackingEvent:
                    return TriggerTrackingEvent == other.TriggerTrackingEvent;
                case ObjectiveEventData.TriggerEventType.DialogCompleted:
                    return TriggerDialogId == other.TriggerDialogId;
                case ObjectiveEventData.TriggerEventType.Begin:
                case ObjectiveEventData.TriggerEventType.Complete:
                    // For Begin and Complete, eventType match is enough
                    return true;
                case ObjectiveEventData.TriggerEventType.Interaction:
                    return InteractionEventType == other.InteractionEventType &&
                           TriggerInteractableID == other.TriggerInteractableID;
                default:
                    // Optionally handle other cases or assume equality based only on eventType
                    return true;
            }
        }
        
        public override int GetHashCode()
        {
            // Generate a hash code based on all properties that are part of equality comparison
            int hashCode = eventType.GetHashCode();
            
            if (eventType == ObjectiveEventData.TriggerEventType.TrackingEvent && !string.IsNullOrEmpty(TriggerTrackingEvent))
            {
                hashCode = (hashCode * 397) ^ TriggerTrackingEvent.GetHashCode();
            }
            else if (eventType == ObjectiveEventData.TriggerEventType.DialogCompleted && !string.IsNullOrEmpty(TriggerDialogId))
            {
                hashCode = (hashCode * 397) ^ TriggerDialogId.GetHashCode();
            }
            else if (eventType == ObjectiveEventData.TriggerEventType.Interaction && !string.IsNullOrEmpty(TriggerInteractableID))
            {
                hashCode = (hashCode * 397) ^ InteractionEventType.GetHashCode() ^ TriggerInteractableID.GetHashCode();
            }
            
            return hashCode;
        }
    }
    
    /// <summary>
    /// The EventData on the objective system
    /// </summary>
    [Serializable]
    public abstract class ObjectiveEventData
    {
        [Hide]
        [SerializeField]
        private string id = String.Empty;
        public string ID => id;
        
        [Serializable]
        public enum TriggerEventType
        {
            Begin = 0,
            Complete = 2,
            TrackingEvent = 4,
            DialogCompleted = 8,
            Interaction = 16
        }

        [Serializable]
        public enum InteractionEventType
        {
            Grabbed = 0,
            Ungrabbed = 2,
            Socketed = 4,
            Unsocketed = 8
        }
        
        [Hide]
        [SerializeField]
        private TriggerEventInfo triggerEventInfo;
        public TriggerEventInfo TriggerEventInfo => triggerEventInfo;
        
        public TriggerEventType EventType => triggerEventInfo.EventType;
        public string TriggerTrackingEvent => triggerEventInfo.TriggerTrackingEvent;
        public string TriggerDialogId => triggerEventInfo.TriggerDialogId;

        #region NodeEditor

        //Node view datas
        [Hide]
        public Rect eventNodePosition = Rect.zero;

        #endregion

        public ObjectiveEventData() { }
        
        public ObjectiveEventData(ObjectiveEventData copy)
        {
            TryGenerateId(true);
            triggerEventInfo = new TriggerEventInfo(copy.TriggerEventInfo);
            eventNodePosition = copy.eventNodePosition;
        }

        public virtual bool OnValidate()
        {
            return false;
        }
        
        public void TryGenerateId(bool force = false)
        {
            if (string.IsNullOrEmpty(id) || force)
            {
                id = StringUtilities.GenerateUniqueId(minLength: 5, maxLength: 8);
            }   
        }
        
#if UNITY_EDITOR
        public void EDITOR_SetTriggerEventType(TriggerEventInfo eventInfo)
        {
            triggerEventInfo = eventInfo;
            id = triggerEventInfo.ID;
        }
#endif
    }
    
    /// <summary>
    /// Container for the EventData, contained by each objective
    /// </summary>
    [Serializable]
    public class EventDataContainer : IEnumerable<ObjectiveEventData>, ISerializationCallbackReceiver
    {
        [Serializable]
        public class EventDataComment
        {
            [SerializeField] 
            private string comment;
            public string Comment => comment;

            [SerializeField] 
            private int index;
            public int Index => index;

            public EventDataComment(EventDataComment copy)
            {
                comment = copy.comment;
                index = copy.index;
            }
        }
        
        [SerializeReference]
        private List<ObjectiveEventData> objectiveEventData = new List<ObjectiveEventData>();

        [SerializeField] 
        private List<EventDataComment> comments = new List<EventDataComment>();
        
        private Dictionary<Type, List<ObjectiveEventData>> eventDataMap = new Dictionary<Type, List<ObjectiveEventData>>();
        public int Count => objectiveEventData.Count;

        public EventDataContainer(){}

        public EventDataContainer(EventDataContainer source)
        {
            this.CloneObject(source);
            objectiveEventData.Clear();
            
            foreach (ObjectiveEventData data in source.objectiveEventData)
            {
                Type dataType = data.GetType();
                ObjectiveEventData newData = (ObjectiveEventData)Activator.CreateInstance(dataType, data);
                Add(newData);
            }
            
            comments.Clear();
            foreach (EventDataComment comment in source.comments)
            {
                comments.Add(new EventDataComment(comment));
            }
        }

        public bool OnValidate()
        {
            bool shouldSetDirty = false;

            List<ObjectiveEventData> eventDatas = objectiveEventData.ToList();
            for (int i = 0; i < eventDatas.Count; i++)
            {
                ObjectiveEventData eventData = eventDatas[i];
                if (eventData == null)
                {
                    Debug.LogError("Alert: A null ObjectiveEventData was found!");
                    objectiveEventData.RemoveAt(i);
                    shouldSetDirty = true;
                    continue;
                }

                if (eventData.OnValidate())
                {
                    shouldSetDirty = true;
                }
            }

            return shouldSetDirty;
        }
        
        public void Add(ObjectiveEventData data)
        {
            objectiveEventData.Add(data);
        }
        
        public void Delete(ObjectiveEventData data)
        {
            objectiveEventData.Remove(data);
        }

        public void ClearNull()
        {
            for (int i = objectiveEventData.Count - 1; i >= 0; i--)
            {
                if (objectiveEventData[i] == null)
                {
                    objectiveEventData.RemoveAt(i);
                }
            }
        }
        
        public bool TryGet<T>(out List<T> list) where T : ObjectiveEventData
        {
            if (!Application.isPlaying)
            {
                bool tryGetUncached = TryGetUncached(out List<T> uncachedList);
                list = uncachedList;
                return tryGetUncached;
            }
            list = null;
            Type type = typeof(T);
            if (!eventDataMap.ContainsKey(type))
            {
                return false;
            }

            list = eventDataMap[type] as List<T>;
            return true;
        }

        private bool TryGetUncached<T>(out List<T> list) where T : ObjectiveEventData
        {
            list = new List<T>();
            foreach (ObjectiveEventData data in objectiveEventData)
            {
                if (data is T tData)
                {
                    list.Add(tData);
                }
            }

            if (list.Count == 0)
            {
                list = null;
                return false;
            }

            return true;
        }
        
        public bool TryGet(ObjectiveEventData.TriggerEventType eventType, out List<ObjectiveEventData> list)
        {
            list = objectiveEventData.Where(l => l.EventType == eventType).ToList();
            if (list.Count == 0)
            {
                return false;
            }
            return true;
        }

        public bool TryGet(ObjectiveEventData.TriggerEventType eventType, string id, out List<ObjectiveEventData> list)
        {
            list = objectiveEventData.Where(l =>
                {
                    if (l.EventType != eventType)
                    {
                        return false;
                    }

                    return (eventType == ObjectiveEventData.TriggerEventType.TrackingEvent &&
                            l.TriggerTrackingEvent == id)
                           || (eventType == ObjectiveEventData.TriggerEventType.DialogCompleted &&
                               l.TriggerDialogId == id)
                           || (eventType == ObjectiveEventData.TriggerEventType.Interaction &&
                               l.TriggerEventInfo.TriggerInteractableID == id);

                })
                .ToList();
            if (list.Count == 0)
            {
                return false;
            }

            return true;
        }

        public IEnumerator<ObjectiveEventData> GetEnumerator()
        {
            return objectiveEventData.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public void OnBeforeSerialize()
        {
        }

        public void OnAfterDeserialize()
        {
            eventDataMap.Clear();
            foreach (var data in objectiveEventData)
            {
                if (data == null)
                {
                    continue;
                }
                
                Type t = data.GetType();
                
                if (!eventDataMap.ContainsKey(t))
                {
                    eventDataMap[t] = new List<ObjectiveEventData>();
                }
                eventDataMap[t].Add(data);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveEventData.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveOption.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 595e279db7ee42ce844870494e553140
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Utilities.Extensions;

namespace Ldx.Framework.Systems.Objectives
{
    /// <summary>
    /// An objective option adds additional parameters based on the objective type
    /// </summary>
    [Serializable]
    public abstract class ObjectiveOption
    {
        public string DisplayName => GetType().Name.Replace("ObjectiveOption", "").SeparateWords();
        
        public ObjectiveOption() { }
        public ObjectiveOption(ObjectiveOption copy) { }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveOption.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveOptions/DisplayAsHierarchyParentObjectiveOption.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c42bcff476bb41ac91992c0e24b43689
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives.Attributes;

namespace Ldx.Framework.Systems.Objectives.ObjectiveOptions
{
    /// <summary>
    /// Displays the objective group in a hierarchy, with the objective as parent
    /// </summary>
    [ObjectiveTypesFilter(ObjectiveType.InSequenceGroup)]
    [Serializable]
    public class DisplayAsHierarchyParentObjectiveOption : ObjectiveOption
    {
        public DisplayAsHierarchyParentObjectiveOption() { }
        public DisplayAsHierarchyParentObjectiveOption(DisplayAsHierarchyParentObjectiveOption copy) : base(copy) { }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveOptions/DisplayAsHierarchyParentObjectiveOption.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveOptions/FinishesWithChildObjectivesObjectiveOption.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 76e4ab0ab65c4f59bfb0c5c9389b2567
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;

namespace Ldx.Framework.Systems.Objectives.ObjectiveOptions
{
    /// <summary>
    /// When added, the parent objective doesn't need conditions,
    /// but finishes when all the children are completed
    /// </summary>
    [Serializable]
    public class FinishesWithChildObjectivesObjectiveOption : ObjectiveOption
    {
        public FinishesWithChildObjectivesObjectiveOption() { }
        public FinishesWithChildObjectivesObjectiveOption(FinishesWithChildObjectivesObjectiveOption copy) : base(copy) { }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveOptions/FinishesWithChildObjectivesObjectiveOption.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveOptions/HideTickObjectiveOption.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c39ca589d7894e3e948f017687957a5d
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;

namespace Ldx.Framework.Systems.Objectives.ObjectiveOptions
{
    /// <summary>
    /// For marking when an objective shouldn't have a tick
    /// (Like parents that represent headers)
    /// </summary>
    [Serializable]
    public class HideTickObjectiveOption : ObjectiveOption
    {
        public HideTickObjectiveOption() { }
        public HideTickObjectiveOption(HideTickObjectiveOption copy) : base(copy) { }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveOptions/HideTickObjectiveOption.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveOptions/ShowInRequirementsObjectiveOption.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7a05520936f941ba9e02b5ff77600172
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;

namespace Ldx.Framework.Systems.Objectives.ObjectiveOptions
{
    /// <summary>
    /// When added, the objective will show in requirements
    /// </summary>
    [Serializable]
    public class ShowInRequirementsObjectiveOption : ObjectiveOption
    {
        public ShowInRequirementsObjectiveOption() { }
        public ShowInRequirementsObjectiveOption(ShowInRequirementsObjectiveOption copy) : base(copy) { }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveOptions/ShowInRequirementsObjectiveOption.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveOptions/ShowNotificationObjectiveOption.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6da56fa5fb714ea6ac3c45ac28621880
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.ObjectiveOptions
{
    /// <summary>
    /// Options for showing notifications regarding the objective
    /// </summary>
    [Serializable]
    public class ShowNotificationObjectiveOption : ObjectiveOption
    {
        [SerializeField] 
        private bool showStartNotification;
        public bool ShowStartNotification => showStartNotification;

        [SerializeField] 
        private bool showCompletedNotification;
        public bool ShowCompletedNotification => showCompletedNotification;
        
        public ShowNotificationObjectiveOption() { }
        
        public ShowNotificationObjectiveOption(ShowNotificationObjectiveOption copy) : base(copy)
        {
            showStartNotification = copy.showStartNotification;
            showCompletedNotification = copy.showCompletedNotification;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveOptions/ShowNotificationObjectiveOption.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveOptions/StartDelayObjectiveOption.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: fb3f4f407c364898a614250c1598c753
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.ObjectiveOptions
{
    /// <summary>
    /// For adding a start delay to the objective
    /// </summary>
    [Serializable]
    public class StartDelayObjectiveOption : ObjectiveOption
    {
        [SerializeField]
        private float duration;
        public float Duration => duration;
        
        public StartDelayObjectiveOption() { }
        
        public StartDelayObjectiveOption(StartDelayObjectiveOption copy) : base(copy)
        {
            duration = copy.duration;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveOptions/StartDelayObjectiveOption.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveProcessor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0bda1339f8db4ca4854cecc2702d315d
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Objectives.ObjectiveOptions;
using Ldx.Framework.Systems.Objectives.Tracking;

namespace Ldx.Framework.Systems.Objectives
{
    /// <summary>
    /// Class for processing current objective
    /// </summary>
    public class ObjectiveProcessor
    {
        public event Action<ObjectiveProcessor> OnProcessingComplete;
        public event Action<ObjectiveProcessor, BaseObjective> OnObjectiveBegin; 
        public event Action<ObjectiveProcessor, BaseObjective> OnObjectiveComplete;
        public event Action<ObjectiveProcessor, BaseObjective, ObjectiveEventData> OnObjectiveEvent;

        private List<BaseObjective> currentStep = new();
        private List<BaseObjective> currentStepRestartBackup = new();
        private Queue<List<BaseObjective>> stepsQueue = new();
        private List<BaseObjective> removedObjectives = new();
        private HashSet<ObjectiveEventData> broadcastedEventDataSet = new();
        private Dictionary<BaseObjective, List<ObjectiveCondition>> currentStepToConditionsMap = new();

        private Objective SourceBaseObjective { get;}

        private LdxTrackingManager TrackingManager => LdxTrackingManager.Instance;
        public bool IsCompleted { get; private set; }
        public bool DidStartProcessing { get; private set; }

        public ObjectiveProcessor(Objective sourceBaseObjective)
        {
            SourceBaseObjective = sourceBaseObjective;
            SourceBaseObjective.AcquireStepsToQueue(ref stepsQueue);
        }

        public void Begin()
        {
            beginAsync().Forget();

            async UniTaskVoid beginAsync()
            {
                if (SourceBaseObjective.ObjectiveOptions.FirstOrDefault(o => o is StartDelayObjectiveOption) is StartDelayObjectiveOption option)
                {
                    DidStartProcessing = false;
                    await UniTask.Delay((int)(option.Duration * 1000.0f));
                }
                MoveNext();
                DidStartProcessing = true;
                if (!LdxTrackingManager.IsValid)
                {
                    return;
                }
                TrackingManager.OnTrackingEvent += HandleTrackingEvent;
                TrackingManager.OnDialogCompleted += HandleDialogCompleted;
                TrackingManager.OnInteractionEvent += HandleInteractionEvent;
            }
        }

        public void Terminate()
        {
            if (!LdxTrackingManager.IsValid)
            {
                return;
            }

            TrackingManager.OnTrackingEvent -= HandleTrackingEvent;
            TrackingManager.OnDialogCompleted -= HandleDialogCompleted;
            TrackingManager.OnInteractionEvent -= HandleInteractionEvent;
        }

        private void MoveNext()
        {
            if (stepsQueue.Count == 0 && !IsCompleted)
            {
                IsCompleted = true;
                BroadcastProcessingCompleted();
                return;
            }

            currentStep = stepsQueue.Dequeue();
            
            broadcastedEventDataSet.Clear();

            currentStepToConditionsMap =
                currentStep.ToDictionary(o => o, c => new List<ObjectiveCondition>(c.Conditions));
            
            currentStepRestartBackup = new List<BaseObjective>(currentStep);
            foreach (BaseObjective objective in currentStep)
            {
                bool isSkipped = false;
                foreach (ObjectiveCondition condition in objective.Conditions)
                {
                    if (condition.CheckType == ObjectiveCondition.ConditionalCheckType.SkipsObjectiveIfValid
                        && condition.IsConditionValid())
                    {
                        condition.EndChecking();
                        removedObjectives.Add(objective);
                        isSkipped = true;
                        break;
                    }
                }

                if (isSkipped)
                {
                    continue;
                }
                
                foreach (ObjectiveCondition condition in objective.Conditions)
                {
                    condition.BeginChecking();
                }
                
                BroadcastObjectiveBegin(objective);
            }
        }

        public void ProcessObjectivesStep()
        {
            if (IsCompleted || !DidStartProcessing)
            {
                return;
            }
            
            if (removedObjectives.Count > 0)
            {
                foreach (BaseObjective objective in removedObjectives)
                {
                    currentStep.Remove(objective);
                }

                removedObjectives.Clear();
            }

            if (currentStep.Count == 0)
            {
                MoveNext();
                return;
            }

            foreach (BaseObjective objective in currentStep)
            {
                ProcessObjective(objective);
            }
        }

        private void ProcessObjective(BaseObjective objective)
        {
            bool completed = true;
            bool forceComplete = false;

            List<ObjectiveCondition> conditions = currentStepToConditionsMap[objective];

            for (int i = conditions.Count - 1; i >= 0; i--)
            {
                ObjectiveCondition condition = conditions[i];
                bool valid = condition.IsConditionValid();
                switch (condition.CheckType)
                {
                    case ObjectiveCondition.ConditionalCheckType.Mandatory:
                        if (!valid)
                        {
                            completed = false;
                        }
                        break;
                    
                    case ObjectiveCondition.ConditionalCheckType.CompletesObjectiveIfValid:
                        if (valid)
                        {
                            forceComplete = true;
                        }
                        break;
                    
                    case ObjectiveCondition.ConditionalCheckType.SkipsObjectiveIfValid:
                        continue;
                    default:
                        throw new ArgumentOutOfRangeException();
                }

                if (valid)
                {
                    condition.EndChecking();
                    conditions.RemoveAt(i);
                }

                if (forceComplete)
                {
                    completed = true;
                    break;
                }
            }

            if (completed)
            {
                CompleteObjective(objective);
            }
        }

        private void RestartObjectiveStep()
        {
            stepsQueue.Enqueue(currentStepRestartBackup);
            MoveNext();
        }

        public void ForceCompleteObjectiveStep()
        {
            foreach (BaseObjective objectiveStep in currentStep)
            {
                CompleteObjective(objectiveStep);
            }
        }
        
        public void CompleteObjective(BaseObjective baseObjective)
        {
            BroadcastObjectiveComplete(baseObjective);
            removedObjectives.Add(baseObjective);
        }

        private void BroadcastObjectiveBegin(BaseObjective baseObjective)
        {
            baseObjective.GetEvents(ObjectiveEventData.TriggerEventType.Begin).ForEach(e => BroadcastObjectiveEvent(baseObjective, e));
            OnObjectiveBegin?.Invoke(this, baseObjective);
        }

        private void BroadcastObjectiveComplete(BaseObjective baseObjective)
        {
            baseObjective.GetEvents(ObjectiveEventData.TriggerEventType.Complete).ForEach(e => BroadcastObjectiveEvent(baseObjective, e));
            OnObjectiveComplete?.Invoke(this, baseObjective);
        }
        
        private void BroadcastProcessingCompleted()
        {
            OnProcessingComplete?.Invoke(this);
        }
        
        private void BroadcastObjectiveEvent(BaseObjective baseObjective, ObjectiveEventData data)
        {
            if (data is RestartObjectiveStepEventData)
            {
                RestartObjectiveStep();
            }

            broadcastedEventDataSet.Add(data);
            OnObjectiveEvent?.Invoke(this, baseObjective, data);
        }
        
        private void HandleTrackingEvent(string id)
        {
            foreach (BaseObjective objective in currentStep)
            {
                objective.GetEvents(ObjectiveEventData.TriggerEventType.TrackingEvent, id).ForEach(e => BroadcastObjectiveEvent(objective, e));
            }
        }
        
        private void HandleInteractionEvent(ObjectiveEventData.InteractionEventType interactionEventType, string id)
        {
            foreach (BaseObjective objective in currentStep)
            {
                objective.GetInteractionEvents(interactionEventType, id)
                    .ForEach(e =>
                    {
                        if (broadcastedEventDataSet.Contains(e))
                        {
                            return;
                        }
                        BroadcastObjectiveEvent(objective, e);
                    });
            }
        }

        private void HandleDialogCompleted(string id, bool isRightAnswer)
        {
            foreach (BaseObjective objective in currentStep)
            {
                objective.GetEvents(ObjectiveEventData.TriggerEventType.DialogCompleted, id).ForEach(e => BroadcastObjectiveEvent(objective, e));
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveProcessor.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveSystem.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 74b70e5494794bc8ad01ca0c956d77c4
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Systems.UI;
using Ldx.Framework.Utilities;
using UnityEngine;
using UnityEngine.InputSystem;

namespace Ldx.Framework.Systems.Objectives
{
    /// <summary>
    /// The objective system processes the injected ObjectiveData
    /// and runs the necessary logic to make it work at runtime
    /// </summary>
    public class ObjectiveSystem : Singleton<ObjectiveSystem>
    {
        private enum ObjectiveState
        {
            Inactive = 0,
            Active,
            Completed
        }

        public event Action<ObjectiveSystem> OnObjectivesFinished;
        public event Action<ObjectiveSystem, BaseObjective> OnAnyObjectiveBegin;
        public event Action<ObjectiveSystem, BaseObjective> OnAnyObjectiveComplete; 

        public static bool IsBlocked { get; set; }
        
        public bool IsActive { get; private set; }
        private ObjectiveData ObjectiveData { get; set; }
        private int? CurrentStepIndex { get; set; } = null;
        
        private List<Objective> Objectives => ObjectiveData.Objectives;
        private Objective CurrentBaseObjective =>
            CurrentStepIndex == null
                ? null
                : Objectives[CurrentStepIndex.Value];
        private bool DidFinishAllObjectives => CurrentStepIndex != null
                                               && CurrentStepIndex.Value >= ObjectiveData.ObjectivesCount;
        private ObjectiveProcessor CurrentObjectiveProcessor { get; set; }
        
        public void InitializeSystem(ObjectiveData objectiveData)
        {
            ResetSystem();
            ObjectiveData = objectiveData;
        }

        public void ResetSystem()
        {
            ObjectiveData = null;
            CurrentStepIndex = null;
            IsActive = false;
        }

        public void StopSystem()
        {
            IsActive = false;
        }

        public void StartSystem()
        {
            if (IsBlocked)
            {
                waitUntilUnblockedThenStartSystemAsync().Forget();
                return;
            }
            
            IsActive = true;
            AdvanceObjectiveStep();

            async UniTaskVoid waitUntilUnblockedThenStartSystemAsync()
            {
                if (IsBlocked)
                {
                    await UniTask.WaitUntil(() => !IsBlocked);
                }
                StartSystem();
            }
        }

        public void ForceFinishSystem()
        {
            IsActive = false;
            BroadcastObjectivesFinished();
        }

        private void Update()
        {
            if (!IsActive)
            {
                return;
            }

            UpdateProcessing();

#if UNITY_EDITOR
            Keyboard keyboard = Keyboard.current;
            if (keyboard == null)
            {
                return;
            }

            if (keyboard.leftAltKey.wasPressedThisFrame && keyboard.oKey.wasPressedThisFrame)
            {
                ForceCompleteObjectiveStep();
            }
            
            if (keyboard.leftAltKey.wasPressedThisFrame && keyboard.iKey.wasPressedThisFrame)
            {
                ForceAnswerDialogue();
            }
#endif
        }

        private void UpdateProcessing()
        {
            CurrentObjectiveProcessor?.ProcessObjectivesStep();
        }

        public void ForceCompleteObjectiveStep()
        {
            CurrentObjectiveProcessor?.ForceCompleteObjectiveStep();
        }

        public void ForceAnswerDialogue()
        {
            UIController.Instance.GetUIElement<DialogueWindow>().TryForceAnswerDialogue();
        }
        
        private void AdvanceObjectiveStep()
        {
            if (!IsActive)
            {
                return;
            }
            CurrentStepIndex = CurrentStepIndex == null ? GetStartObjectiveStepIndex() : CurrentStepIndex.Value + 1;
            
            if (DidFinishAllObjectives)
            {
                IsActive = false;
                BroadcastObjectivesFinished();
                return;
            }
            
            CurrentObjectiveProcessor = new ObjectiveProcessor(CurrentBaseObjective);
            CurrentObjectiveProcessor.OnObjectiveEvent += HandleObjectiveEvent;
            CurrentObjectiveProcessor.OnProcessingComplete += HandleObjectiveProcessingComplete;
            CurrentObjectiveProcessor.OnObjectiveBegin += HandleObjectiveBegin; 
            CurrentObjectiveProcessor.OnObjectiveComplete += HandleObjectiveComplete; 
            CurrentObjectiveProcessor.Begin();
        }

        private int GetStartObjectiveStepIndex()
        {
            int? overrideStep = ObjectiveData.ObjectivesStepOverrideIndex;
            
            if (!Application.isEditor)
            {
                return 0;
            }

            if (overrideStep == null)
            {
                return 0;
            }

            if (overrideStep.Value > Objectives.Count - 1)
            {
                return 0;
            }

            return overrideStep.Value;
        }
        
        private void HandleObjectiveEvent(ObjectiveProcessor processor, BaseObjective baseObjective, ObjectiveEventData eventData)
        {
            if (LdxTrackingManager.Instance != null)
            {
                LdxTrackingManager.Instance.BroadcastObjectiveEvent(baseObjective, eventData);
            }
        }

        private void HandleObjectiveProcessingComplete(ObjectiveProcessor processor)
        {
            CurrentObjectiveProcessor.OnObjectiveEvent -= HandleObjectiveEvent;
            CurrentObjectiveProcessor.OnProcessingComplete -= HandleObjectiveProcessingComplete;
            CurrentObjectiveProcessor.OnObjectiveBegin -= HandleObjectiveBegin;
            CurrentObjectiveProcessor.OnObjectiveComplete -= HandleObjectiveComplete;
            CurrentObjectiveProcessor.Terminate();
            CurrentObjectiveProcessor = null;
            AdvanceObjectiveStep();
        }
        
        private void HandleObjectiveBegin(ObjectiveProcessor processor, BaseObjective baseObjective)
        {
            OnAnyObjectiveBegin?.Invoke(this, baseObjective);
        }
        
        private void HandleObjectiveComplete(ObjectiveProcessor processor, BaseObjective baseObjective)
        {
            OnAnyObjectiveComplete?.Invoke(this, baseObjective);            
        }

        private void BroadcastObjectivesFinished()
        {
            OnObjectivesFinished?.Invoke(this);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveSystem.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveTransform.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 667e43cfc6d2a264b9b01d42b1554a45
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
	[TrackedReference]
	public class ObjectiveTransform : MonoBehaviour
	{
#if UNITY_EDITOR
		
		private const float GIZMO_SPHERE_RADIUS = 0.05f;
		private readonly Color gizmoColor = Color.yellow.Opacity(0.5f);

		private static GUIStyle textStyle;
		private GUIStyle TextStyle
		{
			get
			{
				return textStyle ??= new GUIStyle
				{  
					fontSize = 16,
					normal =
					{
						textColor = gizmoColor
					}
				};
			}
		}
		
#endif
		
		[IDSelection(LdxIdSettings.IdType.Transform)]
		[SerializeField]
		private string transformPoint;
		public string TransformPoint => transformPoint;

#if UNITY_EDITOR
		private void OnDrawGizmos()
		{
			if (LdxIdSettings.TryGetIDDescription(TransformPoint, LdxIdSettings.IdType.Transform,
				    out string description))
			{
				Color color = Gizmos.color;
				Vector3 transformPosition = transform.position;
				Gizmos.color = gizmoColor;
			
				Gizmos.DrawSphere(transformPosition, GIZMO_SPHERE_RADIUS);
				Handles.Label(transformPosition, description, TextStyle);
            
				Gizmos.color = color;
			}
		}
#endif
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveTransform.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveType.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ac076bf6290047d7ab2116443f370b3b
# ASMDEF: ldx.framework.runtime.dll
# ---
namespace Ldx.Framework.Systems.Objectives
{

}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/ObjectiveType.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/SpawnPoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6b9f3c3c8d604680a7fda342873a146c
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Ldx.Framework.Systems.Objectives
{
    [TrackedReference]
    public class SpawnPoint : MonoBehaviour
    {
        [IDSelection(LdxIdSettings.IdType.Transform)]
        [SerializeField] 
        private string spawnPoint;
        public string SpawnPointID
        {
            get => spawnPoint;
            set => spawnPoint = value;
        }
        
#if UNITY_EDITOR
        private string lastSpawnPoint = null;
        private CustomCameraPreview customCameraPreview;
        
        private void OnDrawGizmos()
        {
            if (customCameraPreview == null)
            {
                customCameraPreview = gameObject.GetOrAddComponent<CustomCameraPreview>();
                customCameraPreview.hideFlags = HideFlags.DontSave | HideFlags.NotEditable;
                updateLabel();
            }

            if (lastSpawnPoint != spawnPoint)
            {
               updateLabel();
            }

            lastSpawnPoint = spawnPoint;

            void updateLabel()
            {
                string sPLabel = gameObject.name;
                if (LdxIdSettings.TryGetIDDescription(spawnPoint, LdxIdSettings.IdType.Transform, out string description))
                {
                    sPLabel = description;
                }
                customCameraPreview.SetLabel($"Spawn Point: {sPLabel}");
            }
        }
        
        [MenuItem("GameObject/LogicalDox/Spawn Point", false, 10)]
        public static void EDITOR_CreateCustomObject()
        {
            GameObject spawnPointObj = new GameObject("SpawnPoint:");
            spawnPointObj.AddComponent<SpawnPoint>();
            Undo.RegisterCreatedObjectUndo(spawnPointObj, "Create Spawn Point Object");
            Selection.activeGameObject = spawnPointObj;
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/SpawnPoint.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/AnimationEventsTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3a88ae1f50d34cf4a3152dcd35f4907d
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Features.Animation;
using Ldx.Framework.Utilities.Attributes;
using Systems.Objectives.EventData;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    [TrackedReference]
    public class AnimationEventsTracker : EventDataTracker
    {
        private LdxReferenceIDTracker ReferenceIDTracker => LdxReferenceIDTracker.Instance;
        
        protected override void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            switch (eventData)
            {
                case AnimationEventDatas.TriggerAnimationEventData data:
                    if (ReferenceIDTracker.TryGetAnimationObject(data.AnimationDialogId, out AnimationObject animationObject))
                    {
                        animationObject.TriggerAnimation();
                    }
                    break;
                default:
                    return;   
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/AnimationEventsTracker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/AudioEventTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 921b239ada9041fbb92f370c3df27119
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.AudioSystem;
using UnityEngine;
using UnityEngine.Audio;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    public class AudioEventTracker : EventDataTracker
    {
        protected override void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            switch (eventData)
            {
                case PlayDialogEventData data:
                    PlayDialogueAudio(data);
                    break;
                case StopDialogEventData _:
                    StopDialogueAudio();
                    break;
                case IPlayAudioEventData data:
                    if (data.CanBeInterrupted)
                    {
                        AudioRuntimeManager.Instance.InterruptAndPlayObjectiveSound(data.SoundReference);
                    }
                    else
                    {
                        AudioRuntimeManager.Instance.CreatePlayOneShotReleaseByReference(data.SoundReference, out SoundInstance _);
                    }
                    break;
                default:
                    return;
            }
        }

        #region Dialog Audio

        private void PlayDialogueAudio(PlayDialogEventData data)
        {
            StopDialogueAudio();
            
            AudioClip clip = data.AudioClip;
            if (clip != null)
            {
                AudioMixerGroup mixerGroup = null;
                if (data.AudioMixerGroup != null)
                {
                    mixerGroup = data.AudioMixerGroup;
                }

                Audio.PlayDialogue(clip, mixerGroup);
            }
        }

        private void StopDialogueAudio()
        {
            Audio.StopDialogue();
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/AudioEventTracker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/CollisionEnums.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1e7b992cad3942f48105e174729a4bca
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    [Serializable]
    public enum CollisionType
    {
        Hand = 0,
        Player,
        ObjectGroup
    }
    
    [Serializable]
    public enum CollisionDirection
    {
        Enter,
        Exit
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/CollisionEnums.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/CollisionTrackingKeySetter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 292684efac9dad143bedb51955cd2c66
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    /// <summary>
    /// Set a key to the value specified in the inspector on collision/trigger enter,
    /// and change to the opposite value on collision/trigger exit.
    /// </summary>
    public class CollisionTrackingKeySetter : TrackingKeySetter
    {
        [SerializeField]
        private CollisionType collisionType = CollisionType.Hand;
        
        [SerializeField]
        private CollisionDirection collisionDirection = CollisionDirection.Enter;
        
        [SerializeField]
        private bool ignoreTriggerEnterExit;
        
        [SerializeField]
        private bool ignoreCollisionEnterExit;

        [Header("Applies only if collision type is 'Object Group'")]
        [IDSelection(LdxIdSettings.IdType.ObjectGroup)]
        [SerializeField]
        private string targetObjectGroup;

        private void OnTriggerEnter(Collider other)
        {
            if (ignoreTriggerEnterExit || !CollisionUtilities.CheckCollision(other.gameObject, collisionType, targetObjectGroup))
            {
                return;
            }

            SetKey(collisionDirection is CollisionDirection.Enter ? value : !value);
        }

        private void OnCollisionEnter(Collision other)
        {
            if (ignoreCollisionEnterExit || !CollisionUtilities.CheckCollision(other.gameObject, collisionType, targetObjectGroup))
            {
                return;
            }

            SetKey(collisionDirection is CollisionDirection.Enter ? value : !value);
        }

        private void OnTriggerExit(Collider other)
        {
            if (ignoreTriggerEnterExit || !CollisionUtilities.CheckCollision(other.gameObject, collisionType, targetObjectGroup))
            {
                return;
            }

            SetKey(collisionDirection is CollisionDirection.Exit ? value : !value);
        }

        private void OnCollisionExit(Collision other)
        {
            if (ignoreCollisionEnterExit || !CollisionUtilities.CheckCollision(other.gameObject, collisionType, targetObjectGroup))
            {
                return;
            }
            
            SetKey(collisionDirection is CollisionDirection.Exit ? value : !value);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/CollisionTrackingKeySetter.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/CollisionTrackingKeySetterEverySecond.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: dcfbf01a3d364c50a63e4898e56f975f
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Player;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    [RequireComponent(typeof(Collider))]
    public class CollisionTrackingKeySetterEverySecond : TrackingKeySetter
    {
        private const float MAX_TIME_TO_WAIT_AT_START_SECONDS = 5f;
        private const int TIME_FREQUENCY_CHECK_MS = 1000;
        
        [SerializeField] 
        private Collider bounds;

        public bool InBounds { get; private set; }

        private void OnValidate()
        {
            if (bounds == null)
            {
                bounds = GetComponent<Collider>();
            }
        }

        private IEnumerator Start()
        {
            UpdatePlayerInBounds();
            yield return new WaitForSeconds(Random.Range(0, MAX_TIME_TO_WAIT_AT_START_SECONDS));
#pragma warning disable CS4014
            UpdateAsync();
#pragma warning restore CS4014
        } 

        private async UniTask UpdateAsync()
        {
            while (true)
            {
                UpdatePlayerInBounds();
                await UniTask.Delay(TIME_FREQUENCY_CHECK_MS);
            }
        }
        
        private void UpdatePlayerInBounds()
        {
            bool previous = InBounds;
            InBounds = CheckPlayerInBounds();
            if (InBounds != previous)
            {
                SetKey(InBounds);
            }
        }
        
        private bool CheckPlayerInBounds()
        {
            if (bounds == null)
            {
                return false;
            }
            
            Collider[] objectsInCollider = Physics.OverlapBox(bounds.bounds.center, bounds.bounds.extents / 2f);
            foreach (Collider col in objectsInCollider)
            {
                if (col.GetComponent<PlayerPositionMarker>())
                {
                    return true;
                }
            }

            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/CollisionTrackingKeySetterEverySecond.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/DialogAnswersTrackingFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: fe2f6549d8844312857cf9d112b7c8e3
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.UI;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    public class DialogAnswersTrackingFeature : TrackingFeature
    {
        public class ResultData
        {
            [LocalizationKey]
            public string Description;
            public bool IsCorrectAnswer { get; }
            
            public ResultData(string description, bool isCorrectAnswer)
            {
                Description = description;
                IsCorrectAnswer = isCorrectAnswer;
            }
        }
        
        private List<StartDialogTrackingFeatureEventData.NotesInfo> trackedDialogInfo = new List<StartDialogTrackingFeatureEventData.NotesInfo>();
        readonly private Dictionary<string, bool?> resultMap = new Dictionary<string, bool?>();

        public override void StartTracking(TrackingFeatureEventData eventData)
        {
            if (isTracking)
            {
                return;
            }

            if (!(eventData is StartDialogTrackingFeatureEventData data))
            {
                return;
            }

            isTracking = true;
            trackedDialogInfo = new List<StartDialogTrackingFeatureEventData.NotesInfo>(data.DialogInfo);
            foreach (StartDialogTrackingFeatureEventData.NotesInfo info in trackedDialogInfo)
            {
                resultMap.Add(info.DialogToTrack, null);
            }

            DialogueWindow.OnAnyQuestionAnswered += HandleAnyQuestionAnswered;
        }

        public override void StopTracking()
        {
            if (!isTracking)
            {
                return;
            }

            isTracking = false;
            DialogueWindow.OnAnyQuestionAnswered -= HandleAnyQuestionAnswered;
        }

        private void HandleAnyQuestionAnswered(DialogueWindow window, string dialogId, string answerText, bool isCorrect)
        {
            if (!isTracking)
            {
                return;
            }
            if (!resultMap.ContainsKey(dialogId))
            {
                return;
            }

            resultMap[dialogId] = isCorrect;
        }

        public List<ResultData> GetResults()
        {
            List<ResultData> results = new List<ResultData>();
            foreach (StartDialogTrackingFeatureEventData.NotesInfo info in trackedDialogInfo)
            {
                if (resultMap[info.DialogToTrack] == null)
                {
                    Debug.LogError($"Dialog \"{info.NoteTitle}\" was not tracked, can't find answer");
                    continue;
                }

                ResultData r = new ResultData(info.NoteTitle, resultMap[info.DialogToTrack].Value);
                results.Add(r);
            }

            return results;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/DialogAnswersTrackingFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/EventCounterTrackingFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7fc90eab40a64064bc77473a12e2895e
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    /// <summary>
    /// A tracking feature that tracks and keeps count of x events
    /// </summary>
    public class EventCounterTrackingFeature : TrackingFeature
    {
        public enum CounterTrackingType
        {
            UniqueIdTracking = 0,
            UniqueIdTrackingInOrder,
            SameIdCount
        }
        
        public event Action<EventCounterTrackingFeature> OnTrackingStarted; 
        public event Action<EventCounterTrackingFeature> OnTrackingUpdate;

        private List<string> targetIds;
        private HashSet<string> targetSet;
        
        private List<string> collectedIds = new List<string>();
        private HashSet<string> collectedSet = new HashSet<string>();

        private CounterTrackingType trackingType = CounterTrackingType.UniqueIdTracking;
        public CounterTrackingType TrackingType => trackingType;
        
        public int CompletedEventsCount => collectedIds.Count;
        public int TotalEventsCount => targetIds.Count;

        public override void StartTracking(TrackingFeatureEventData eventData)
        {
            if (isTracking)
            {
                return;
            }
            
            switch (eventData)
            {
                case StartCounterTrackingFeatureEventData e:
                    collectedIds.Clear();
                    collectedSet.Clear();
                    HashSet<string> checkSet = new HashSet<string>();
                    foreach (var id in e.EventsToTrack)
                    {
                        if (checkSet.Contains(id))
                        {
                            Debug.LogError($"Found duplicates in events passed to LdxTrackingEventCounter id:{id}");
                            continue;
                        }

                        checkSet.Add(id);
                    }
                    trackingType = e.TrackingType;
                    if (trackingType == CounterTrackingType.SameIdCount)
                    {
                        targetIds = new List<string>();
                        targetIds.AddRepeated(e.EventsToTrack[0], e.TargetCount);
                        targetSet.Add(e.EventsToTrack[0]);
                        break;
                    }

                    targetIds = e.EventsToTrack;
                    targetSet = new HashSet<string>(targetIds);
                    break;
            }

            isTracking = true;
            OnTrackingStarted?.Invoke(this);
        }

        public override void StopTracking()
        {
            if (LdxTrackingManager.Instance == null)
            {
                return;
            }

            if (!isTracking)
            {
                return;
            }
            isTracking = false;
        }

        public override void NotifyOfTrackingEvent(string id)
        {
            if (!isTracking || !targetSet.Contains(id) || collectedIds.Count >= targetIds.Count)
            {
                return;
            }

            if (trackingType != CounterTrackingType.SameIdCount)
            {
                if (collectedSet.Contains(id))
                {
                    return;
                }
            }

            if (trackingType == CounterTrackingType.UniqueIdTrackingInOrder)
            {
                int newIndex = collectedIds.Count;
                if (targetIds[newIndex] != id)
                {
                    BroadcastFailed();
                    OnTrackingUpdate?.Invoke(this);
                    return;
                }
            }
            collectedIds.Add(id);
            if (!collectedSet.Contains(id))
            {
                collectedSet.Add(id);
            }
            OnTrackingUpdate?.Invoke(this);
            if (CompletedEventsCount >= TotalEventsCount)
            {
                StopTracking();
                BroadcastCompleted();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/EventCounterTrackingFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/EventDataTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9e01c26b84834227ac03e0aad82a81c7
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    /// <summary>
    /// An abstract base class for MonoBehaviour components that track objective-related events.
    /// It handles the subscription and unsubscription to global objective events from the
    /// <see cref="LdxTrackingManager"/>. Derived classes must implement how specific
    /// objective events are handled and can optionally override handlers for tracking resets
    /// and general objective completions.
    /// </summary>
    public abstract class EventDataTracker : MonoBehaviour
    {
        protected virtual void Start()
        {
            LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
            LdxTrackingManager.Instance.OnTrackingReset += HandleTrackingReset;
            LdxTrackingManager.OnAnyObjectiveComplete += HandleAnyObjectiveComplete;
        }
        
        protected virtual void OnDestroy()
        {
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
                LdxTrackingManager.Instance.OnTrackingReset -= HandleTrackingReset;
            }
            
            LdxTrackingManager.OnAnyObjectiveComplete -= HandleAnyObjectiveComplete;
        }

        /// <summary>
        /// Abstract method to be implemented by derived classes.
        /// Handles incoming objective events dispatched by the <see cref="LdxTrackingManager"/>.
        /// </summary>
        /// <param name="objective">The <see cref="IObjective"/> that triggered the event.</param>
        /// <param name="eventData">The <see cref="ObjectiveEventData"/> associated with the event, providing details about what to track.</param>
        protected abstract void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData);
        
        /// <summary>
        /// Virtual method that can be overridden by derived classes.
        /// Called when the <see cref="LdxTrackingManager"/> signals a tracking reset.
        /// Derived classes can implement this to clear their specific tracking state.
        /// </summary>
        /// <param name="trackingManager">The instance of the <see cref="LdxTrackingManager"/> that initiated the reset.</param>
        protected virtual void HandleTrackingReset(LdxTrackingManager trackingManager) { }
        
        /// <summary>
        /// Virtual method that can be overridden by derived classes.
        /// Called when any objective is completed, as signaled by <see cref="LdxTrackingManager.OnAnyObjectiveComplete"/>.
        /// Derived classes can implement this to react to the completion of any objective in the system.
        /// </summary>
        /// <param name="objective">The <see cref="IObjective"/> that was completed.</param>
        protected virtual void HandleAnyObjectiveComplete(IObjective objective) { }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/EventDataTracker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/HighlighterEventsTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 52acfaa5e35e4b62bb79ef2321af367f
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Features.Highlighting;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.UI;
using Ldx.Framework.Systems.VFX;
using Systems.Objectives.EventData;
using UnityEngine;
using Debug = Ldx.Framework.Utilities.Logging.Debug;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    public class HighlighterEventsTracker : MonoBehaviour
    {
        private const float WAIT_BEFORE_PROCESS_FAIL = 1f;
        private const float FX_Y_OFFSET = 1f;

        private readonly List<HighlightableObject> highlightersList = new();
        private readonly Dictionary<string, IdentificationInfo> highlightIdToIdentificationInfoMap = new();
        private readonly Queue<DialogParameters> dialogParametersQueue = new();
        
        private class IdentificationInfo
        {
            public HighlightableObject Highlighter { get; }
            public bool IsCorrect { get; }
            public string EventOnHighlight { get; }
            public string SoundOnHighlight { get; }
            public bool BlockIdentificationDuringPrompts { get; }
            public DialogParameters QuestionParameters { get; }
            public DialogParameters ExplanationParameters { get; }
            public bool IsInQuestionPhase { get; set; }

            public IdentificationInfo(bool isCorrect, bool blockIdentification, DialogParameters questionParameters,
                DialogParameters explanationParameters, HighlightableObject highlighter, string eventOnHighlight = "",
                string soundOnHighlight = "")
            {
                IsCorrect = isCorrect;
                BlockIdentificationDuringPrompts = blockIdentification;
                QuestionParameters = questionParameters;
                ExplanationParameters = explanationParameters;
                Highlighter = highlighter;
                EventOnHighlight = eventOnHighlight;
                SoundOnHighlight = soundOnHighlight;
            }
        }
        
        private IdentificationInfo activeIdentificationInfo;
        private bool trackingRetries;
        private int highlightingRetriesLeft;
        private bool playParticlesOnHighlight;
        private IdentificationData.ParticleType particleType = IdentificationData.ParticleType.CorrectIncorrect;
        private LdxFxController.FX customParticleType;
        
        private bool clearOnObjectiveEnd = true;
        private bool highlightCorrectOnFail = true;
        private bool isHighlightingSourceChanged;
        private bool restoreDefaultSourceOnObjectiveComplete;
        private string eventOnCorrect;
        private string eventOnWrong;
        private string eventOnAllCorrectHighlight;
        private string eventOnFail;
        
        private LdxReferenceIDTracker ReferenceIDTracker => LdxReferenceIDTracker.Instance;
        public HighlightingGlobalSettings.PointingSource DefaultSource =>
            HighlightingGlobalSettings.HighlightingPointingSource;
        
        private void Start()
        {
            LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
            LdxTrackingManager.Instance.OnTrackingReset += HandleTrackingReset;
            LdxTrackingManager.OnAnyObjectiveComplete += HandleAnyObjectiveComplete;
            ObjectHighlighterController.OnAnyModalHighlighted += HandleAnyModalHighlighted;
            DialogueWindow.OnAnyQuestionAnswered += HandleAnyQuestionAnswered;
            ScenarioManager.Instance.OnUnloadingScenarioOrLobby += HandleScenarioExit;
        }
        
        private void OnDestroy()
        {
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
                LdxTrackingManager.Instance.OnTrackingReset -= HandleTrackingReset;
            }

            if (isHighlightingSourceChanged)
            {
                SetHighlightingSource(DefaultSource);
            }
            
            ObjectHighlighterController.OnAnyModalHighlighted -= HandleAnyModalHighlighted;
            DialogueWindow.OnAnyQuestionAnswered -= HandleAnyQuestionAnswered;
            LdxTrackingManager.OnAnyObjectiveComplete -= HandleAnyObjectiveComplete;
            
            if (ScenarioManager.IsValid)
            {
                ScenarioManager.Instance.OnUnloadingScenarioOrLobby -= HandleScenarioExit;
            }
        }

        private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            switch (eventData)
            {
                case ObjectIdentificationEventData data:
                    ProcessObjectIdentificationEventData(data);
                    break;
                case ToggleHighlightObjectsEventData data:
                    ProcessHighlightUnhighlightObjectsEventData(data);
                    break;
                case ChangeHighlightingSourceEventData changeHighlightingSourceEventData:
                    ProcessChangeHighlightingSource(changeHighlightingSourceEventData);
                    break;
                default:
                    return;   
            }
        }

        private void HandleScenarioExit(ScenarioManager scrMgr)
        {
            if (isHighlightingSourceChanged)
            {
                SetHighlightingSource(DefaultSource);
            }
        }
        
        private void HandleAnyModalHighlighted(ObjectHighlighterController controller, HighlightableObject modalHighlighter)
        {
            if (!highlightIdToIdentificationInfoMap.Remove(modalHighlighter.DialogID, out IdentificationInfo data))
            {
                return;
            }
            
            activeIdentificationInfo = data;
            bool correctHighlight = activeIdentificationInfo.IsCorrect;
            
            if (playParticlesOnHighlight)
            {
                LdxFxController.FX effect = particleType == IdentificationData.ParticleType.CorrectIncorrect
                    ? correctHighlight ? LdxFxController.FX.Checkmark : LdxFxController.FX.Incorrect
                    : customParticleType;
                PlayFX(effect, modalHighlighter.transform);
            }

            if (!string.IsNullOrEmpty(data.SoundOnHighlight))
            {
                Audio.PlayOneShot(data.SoundOnHighlight);
            }
            
            LdxTrackingManager.Instance.BroadcastTrackingEvent(activeIdentificationInfo.EventOnHighlight);
            
            if (correctHighlight)
            {
                EnableCorrectHighlighting(modalHighlighter);
                LdxTrackingManager.Instance.BroadcastTrackingEvent(eventOnCorrect);
                DisableIncorrectHighlights();

                if (!DoesActiveIdentificationHaveDialogs() && !highlightIdToIdentificationInfoMap.Any(x => x.Value.IsCorrect))
                {
                    LdxTrackingManager.Instance.BroadcastTrackingEvent(eventOnAllCorrectHighlight);
                }
            }
            else
            {
                highlightingRetriesLeft--;
                PlaySound(false);
                EnableIncorrectHighlighting(modalHighlighter);
                LdxTrackingManager.Instance.BroadcastTrackingEvent(eventOnWrong);
            }
            
            if (trackingRetries && highlightingRetriesLeft < 1)
            {
                ProcessFailRetriesHighlighting().Forget();
                return;
            }

            if (activeIdentificationInfo.QuestionParameters != null)
            {
                dialogParametersQueue.Enqueue(activeIdentificationInfo.QuestionParameters);
            }
            if (activeIdentificationInfo.ExplanationParameters != null)
            {
                dialogParametersQueue.Enqueue(activeIdentificationInfo.ExplanationParameters);
            }
            
            TryProcessDialogQueue();
        }
        
        private async UniTaskVoid ProcessFailRetriesHighlighting()
        {
            foreach (HighlightableObject highlighter in highlightersList)
            {
                highlighter.SetHighlightingEnabled(false);
            }

            await UniTask.Delay(TimeSpan.FromSeconds(WAIT_BEFORE_PROCESS_FAIL));
            
            DisableIncorrectHighlights();
            
            if (highlightCorrectOnFail)
            {
                List<IdentificationInfo> correctInfos =
                    highlightIdToIdentificationInfoMap.Values.Where(x => x.IsCorrect).ToList();
                foreach (IdentificationInfo correctInfo in correctInfos)
                {
                    EnableCorrectHighlighting(correctInfo.Highlighter);
                }
            }
            
            await UniTask.Delay(TimeSpan.FromSeconds(WAIT_BEFORE_PROCESS_FAIL));

            LdxTrackingManager.Instance.BroadcastTrackingEvent(eventOnFail);

            if (!clearOnObjectiveEnd)
            {
                ResetTracking();
            }
        }
        
        private void HandleAnyQuestionAnswered(DialogueWindow dialogueWindow, string dialogId, string answerText, bool isCorrect)
        {
            if (activeIdentificationInfo != null && activeIdentificationInfo.Highlighter != null)
            {
                if (!activeIdentificationInfo.IsInQuestionPhase)
                {
                    Audio.PlayOneShot(HighlightingGlobalSettings.SimpleHazardContinueAudio);
                    highlightersList.ForEach(h => h.SetHighlightingEnabled(true));
                }
                
                if (activeIdentificationInfo.IsCorrect && activeIdentificationInfo.IsInQuestionPhase)
                {
                    PlayFX(isCorrect ? LdxFxController.FX.Checkmark : LdxFxController.FX.Incorrect, activeIdentificationInfo.Highlighter.transform);
                    PlaySound(isCorrect);
                    
                    if (isCorrect)
                    {
                        activeIdentificationInfo.Highlighter.SetCorrectHighlighterProfile();    
                    }
                    else
                    {
                        activeIdentificationInfo.Highlighter.SetWrongHighlighterProfile();        
                    }
                    
                    activeIdentificationInfo.Highlighter.EnableHighlighter();
                }
            }
            
            TryProcessDialogQueue();
        }
        
        private void TryProcessDialogQueue()
        {
            if (dialogParametersQueue.Count < 1)
            {
                if (activeIdentificationInfo is { BlockIdentificationDuringPrompts: true })
                {
                    highlightersList.ForEach(h => h.SetHighlightingEnabled(true));
                }
                
                activeIdentificationInfo = null;
                if (highlightIdToIdentificationInfoMap.Count == 0)
                {
                    LdxTrackingManager.Instance.BroadcastTrackingEvent(eventOnAllCorrectHighlight);
                }
                return;
            }

            if (activeIdentificationInfo is { BlockIdentificationDuringPrompts: true })
            {
                highlightersList.ForEach(h => h.SetHighlightingEnabled(false));
            }
            
            DialogParameters parameters = dialogParametersQueue.Dequeue();
            UIController.Instance.ShowQuestionWindow(parameters);
            if (activeIdentificationInfo != null)
            {
                activeIdentificationInfo.IsInQuestionPhase = parameters == activeIdentificationInfo.QuestionParameters;
            }
        }
        
        private void HandleAnyObjectiveComplete(IObjective objective)
        {
            ResetTracking();

            if (isHighlightingSourceChanged && restoreDefaultSourceOnObjectiveComplete)
            {
                RestoreDefaultHighlightingSource(objective);
            }
        }
        
        private void HandleTrackingReset(LdxTrackingManager trackingManager)
        {
            ResetTracking();
        }

        private void ResetTracking()
        {
            DisableHighlightingAndBlock(highlightersList);
            highlightIdToIdentificationInfoMap.Clear();
            highlightersList.Clear();
            trackingRetries = false;

            ObjectHighlighterController.Instance.ClearHighlighters();
        }

        #region ObjectHighlightingEventData
        
        private void ProcessObjectIdentificationEventData(ObjectIdentificationEventData data)
        {
            highlightIdToIdentificationInfoMap.Clear();
            highlightersList.Clear();
            
            IdentificationData identificationData = data.HighlightingData;
            clearOnObjectiveEnd = true;
            trackingRetries = identificationData.LimitTriesAmount;
            highlightingRetriesLeft = identificationData.MaxTries;

            playParticlesOnHighlight = identificationData.PlayParticlesOnHighlight;
            particleType = identificationData.ParticleOnHighlightType;
            customParticleType = identificationData.CustomParticleType;

            highlightCorrectOnFail = identificationData.HighlightCorrectOnFail;
            eventOnCorrect = identificationData.EventOnCorrectHighlight;
            eventOnFail = identificationData.EventOnFail;
            eventOnWrong = identificationData.EventOnWrong;
            eventOnAllCorrectHighlight = identificationData.EventOnAllCorrectHighlight;
            
            foreach (HighlighterObjectInfo info in data.HighlightingData.HighlighterObjects)
            {
                if (ReferenceIDTracker.TryGetModalHighlighter(info.HighlighterID, out HighlightableObject highlighter))
                {
                    highlighter.ResetHighlighter(true, true);
                    ProcessHighlighterObjectInfo(info, highlighter);
                }
            }
        }

        private void ProcessHighlighterObjectInfo(HighlighterObjectInfo data, HighlightableObject highlighter)
        {
            DialogParameters questionParam = null;
            DialogParameters explanationParam = null;
            
            if (data.UseQuestion)
            {
                questionParam = new DialogParameters(data.Question);
            }

            if (data.UseExplanation)
            {
                explanationParam = new DialogParameters(data.Explanation);
            }

            IdentificationInfo info = new(data.IsCorrect, true, questionParam, explanationParam, highlighter, data.EventOnHighlight, soundOnHighlight: data.PlaySoundOnHighlight ? data.SoundReference : string.Empty);
            highlightIdToIdentificationInfoMap.Add(highlighter.DialogID, info);
            highlightersList.Add(highlighter);
        }
        
        private bool DoesActiveIdentificationHaveDialogs()
        {
            return activeIdentificationInfo.QuestionParameters != null
                   || activeIdentificationInfo.ExplanationParameters != null;
        }
        
        #endregion

        #region Highlight Unhighlight

        private void ProcessHighlightUnhighlightObjectsEventData(ToggleHighlightObjectsEventData data)
        {
            foreach (string highlighterID in data.ObjectContainer.Objects)
            {
                if (ReferenceIDTracker.TryGetModalHighlighter(highlighterID,
                        out HighlightableObject highlighter))
                {
                    switch (data.Action)
                    {
                        case ToggleHighlightObjectsEventData.ActionType.Highlight:
                            highlighter.EnableHighlighter();
                            
                            if (data.PlayParticlesOnHighlight)
                            {
                                PlayFX(data.FXToPlay, highlighter.transform);
                            }
                            
                            break;
                        case ToggleHighlightObjectsEventData.ActionType.Unhighlight:
                            highlighter.ResetHighlighter();
                            break;
                        case ToggleHighlightObjectsEventData.ActionType.None:
                            break;
                        default:
                            throw new ArgumentOutOfRangeException();
                    }

                    if (data.SetHighlightingChange is not ToggleHighlightObjectsEventData.HighlightingObjectChange.None)
                    {
                        highlighter.SetHighlightingEnabled(data.SetHighlightingChange is ToggleHighlightObjectsEventData.HighlightingObjectChange.SetHighlightingEnabled);
                    }
                }
            }
        }

        #endregion

        #region Helpers
        
        private void DisableIncorrectHighlights()
        {
            List<HighlightableObject> incorrect = highlightersList.Where(x =>
                !highlightIdToIdentificationInfoMap.TryGetValue(x.DialogID, out IdentificationInfo info)
                || !info.IsCorrect).ToList();
            DisableHighlightingAndBlock(incorrect);
        }
        
        private void PlaySound(bool correctSound)
        {
            string soundRef = correctSound ? AudioGlobalSettings.OnCorrectSound : AudioGlobalSettings.OnIncorrectSound;
            Audio.PlayOneShot(soundRef);
        }

        private void PlayFX(LdxFxController.FX fx, Transform refTransform)
        {
            if (LdxFxController.Instance == null)
            {
                Debug.LogError("There is currently no LdxFxController in bootstrapper or current scene. Review scene flow.");
                return;
            }
            
            LdxFxController.Instance.InstantiateFx(fx,
                refTransform, new Vector3(0, FX_Y_OFFSET,0), Vector3.up, true);
        }

        private void EnableCorrectHighlighting(HighlightableObject highlighter)
        {
            highlighter.SetCorrectHighlighterProfile();
            WaitThenEnableHighlighter(highlighter).Forget();
        }
        
        private void EnableIncorrectHighlighting(HighlightableObject highlighter)
        {
            highlighter.SetWrongHighlighterProfile();
            WaitThenEnableHighlighter(highlighter).Forget();
        }
        
        private async UniTaskVoid WaitThenEnableHighlighter(HighlightableObject highlighter)
        {
            await UniTask.WaitUntil(() => !highlighter.HighlightProcessor.IsHighlighted);
            highlighter.EnableHighlighter(true);
        }
        
        private void DisableHighlightingAndBlock(List<HighlightableObject> highlighters, bool resetDidBroadcast = true)
        {
            foreach (HighlightableObject highlighter in highlighters)
            {
                highlighter.ResetHighlighter(resetDidBroadcast);
            }
        }

        #endregion
        
        #region Change Highlighting Pointing Source

        private void ProcessChangeHighlightingSource(ChangeHighlightingSourceEventData data)
        {
            restoreDefaultSourceOnObjectiveComplete = data.RestoreDefaultSourceOnObjectiveEnd;
            isHighlightingSourceChanged = true;
            SetHighlightingSource(data.PointingSource);
        }
        
        public async void SetHighlightingSource(HighlightingGlobalSettings.PointingSource source)
        {
            await UniTask.WaitUntil(() => PlayerController.IsValid);
            //TODO: do something with it
            /*LdxPlayerInputHandler inputHandler = PlayerController.Instance.PlayerInputHandler;
            inputHandler.AssignReferences(source);*/
        }
        
        public void RestoreDefaultHighlightingSource(IObjective objective)
        {
            SetHighlightingSource(DefaultSource);
            isHighlightingSourceChanged = false;
        }
        
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/HighlighterEventsTracker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/HighlightStateSetter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 24cdc8fb4c7e49329f8d44aca8024927
# ASMDEF: ldx.framework.runtime.dll
# ---
using Cysharp.Threading.Tasks;
using HighlightPlus;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Tracking 
{
    /// <summary>
    /// Sets highlighting state by listening to appropriate objective event
    /// </summary>
    [RequireComponent(typeof(HighlightEffect))]
    public class HighlightStateSetter : MonoBehaviour
    {
        [IDSelection(LdxIdSettings.IdType.TrackingFeature)]
        [SerializeField]
        private string highlighterFeatureId;
        [SerializeField]
        private HighlightEffect highlightEffect;

        private bool? cachedHighlightResetValue = null;
        
        private void OnValidate()
        {
            if (highlightEffect == null)
            {
                highlightEffect = GetComponent<HighlightEffect>();
            }
        }

        private void Start()
        {
            StartAsync().Forget();
        }

        private async UniTask StartAsync()
        {
            await UniTask.WaitUntil(() => LdxTrackingManager.IsValid);
            LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
        }

        private void OnDestroy()
        {
            if (LdxTrackingManager.Instance != null)
            {
                LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
            }
        }

        private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData data)
        {
            if (data is HighlighterEffectStateEventData eventData)
            {
                if (eventData.HighlighterFeatureId != highlighterFeatureId)
                {
                    return;
                }

                if (eventData.ResetOnObjectiveEnd)
                {
                    cachedHighlightResetValue = highlightEffect.highlighted;
                    LdxTrackingManager.OnAnyObjectiveComplete += HandleObjectiveComplete;
                }
                highlightEffect.highlighted = eventData.Highlighted;
            }
        }

        private void HandleObjectiveComplete(IObjective obj)
        {
            LdxTrackingManager.OnAnyObjectiveComplete -= HandleObjectiveComplete;
            if (cachedHighlightResetValue == null)
            {
                return;
            }
            highlightEffect.highlighted = cachedHighlightResetValue.Value;
            cachedHighlightResetValue = null;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/HighlightStateSetter.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/InteractableEventsTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 05f318577f224e938cf8ba11eecfc86c
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using Autohand;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Logging;
using UnityEngine;
using Debug = Ldx.Framework.Utilities.Logging.Debug;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    /// <summary>
    /// Tracker for interaction events.
    /// Registers InteractableIDs and broadcasts their relevant events. 
    /// </summary>
    public class InteractableEventsTracker : Singleton<InteractableEventsTracker>
    {
        private List<InteractableID> interactableIDs = new();
        private Dictionary<MonoBehaviour, string> sourceToIdMap = new();

        protected override void Awake()
        {
            base.Awake();
            interactableIDs = ReferenceBank.Get<InteractableID>();
            if (interactableIDs == null)
            {
                Debug.Log(LogCategory.TrackingManager,
                    $"Disabling {nameof(InteractableEventsTracker)} - no interactable IDs found in reference bank");
                enabled = false;
            }

            InitMap();
            Subscribe(interactableIDs);
        }

        private void OnDestroy()
        {
            UnsubscribeAll();
        }

        public void Register(List<InteractableID> list)
        {
            if (!enabled && list.Count > 0)
            {
                enabled = true;
            }
            
            foreach (InteractableID entry in list)
            {
                if(sourceToIdMap.ContainsKey(entry.InteractionSourceReference))
                {
                    continue;
                }
                
                interactableIDs.Add(entry);
                sourceToIdMap.Add(entry.InteractionSourceReference, entry.ID);
            }
            
            Subscribe(list);
        }
        
        private void InitMap()
        {
            sourceToIdMap = interactableIDs
                .ToDictionary(i => i.InteractionSourceReference,
                i => i.ID);
        }

        private void Subscribe(List<InteractableID> list)
        {
            foreach (InteractableID id in list)
            {
                if (id.InteractionSource == InteractableID.InteractionSources.Socket)
                {
                    id.Socket.OnPlaceEvent += HandleSocketGrabbed;
                    id.Socket.OnRemoveEvent += HandleSocketReleased;
                }
                else if (id.InteractionSource == InteractableID.InteractionSources.Grabbable)
                {
                    id.Grabbable.OnGrabEvent += HandleGrabbableGrabbed;
                    id.Grabbable.OnReleaseEvent += HandleGrabbableReleased;
                    id.Grabbable.OnPlacePointAddEvent += HandleGrabbableSocketed;
                    id.Grabbable.OnPlacePointRemoveEvent += HandleGrabbableUnsocketed;
                }
            }
        }

        private void UnsubscribeAll()
        {
            foreach (InteractableID id in interactableIDs)
            {
                if (id == null || id.InteractionSourceReference == null)
                {
                    continue;
                }
                if (id.InteractionSource == InteractableID.InteractionSources.Socket)
                {
                    id.Socket.OnPlaceEvent -= HandleSocketGrabbed;
                    id.Socket.OnRemoveEvent -= HandleSocketReleased;
                }
                else if (id.InteractionSource == InteractableID.InteractionSources.Grabbable)
                {
                    id.Grabbable.OnGrabEvent -= HandleGrabbableGrabbed;
                    id.Grabbable.OnReleaseEvent -= HandleGrabbableReleased;
                    id.Grabbable.OnPlacePointAddEvent -= HandleGrabbableSocketed;
                    id.Grabbable.OnPlacePointRemoveEvent -= HandleGrabbableUnsocketed;
                }
            }
        }

        private void BroadcastEvent(MonoBehaviour source, ObjectiveEventData.InteractionEventType eventType)
        {
            if (!sourceToIdMap.TryGetValue(source, out string id))
            {
                return;
            }
            
            LdxTrackingManager.Instance.BroadcastInteractionEvent(eventType, id);
        }
        
        private void HandleGrabbableGrabbed(Hand hand, Grabbable grabbable)
        {
            BroadcastEvent(grabbable, ObjectiveEventData.InteractionEventType.Grabbed);
        }
        
        private void HandleGrabbableReleased(Hand hand, Grabbable grabbable)
        {
            BroadcastEvent(grabbable, ObjectiveEventData.InteractionEventType.Ungrabbed);
        }
        
        private void HandleGrabbableSocketed(PlacePoint point, Grabbable grabbable)
        {
            BroadcastEvent(grabbable, ObjectiveEventData.InteractionEventType.Socketed);
        }
        
        private void HandleGrabbableUnsocketed(PlacePoint point, Grabbable grabbable)
        {
            BroadcastEvent(grabbable, ObjectiveEventData.InteractionEventType.Unsocketed);
        }
        
        private void HandleSocketGrabbed(PlacePoint point, Grabbable grabbable)
        {
            BroadcastEvent(grabbable, ObjectiveEventData.InteractionEventType.Socketed);
            BroadcastEvent(grabbable, ObjectiveEventData.InteractionEventType.Grabbed);
        }
        
        private void HandleSocketReleased(PlacePoint point, Grabbable grabbable)
        {
            BroadcastEvent(grabbable, ObjectiveEventData.InteractionEventType.Unsocketed);
            BroadcastEvent(grabbable, ObjectiveEventData.InteractionEventType.Ungrabbed);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/InteractableEventsTracker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/IObjectGroupInitializer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c341bd45682d4c85bcf8bf91a33d6bf5
# ASMDEF: ldx.framework.runtime.dll
# ---
namespace Ldx.Framework.Systems.Objectives.Tracking
{
    /// <summary>
    /// Implement this interface on an LdxObjectGroup or a child of it so it can
    /// have custom initialization regardless of the object being active in hierarchy 
    /// </summary>
    public interface IObjectGroupInitializer
    {
        void Initialize();
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/IObjectGroupInitializer.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/KeySetterOnPlayerTrigger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 821fec5e76ea4c2eaea8d0714259782f
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.Player;
using Unity.Collections;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    public class KeySetterOnPlayerTrigger : TrackingKeySetter
    {
        [ReadOnly]
        [SerializeField]
        private bool keyValue;

        public bool KeyValue
        {
            get => keyValue;
            set
            {
                if (keyValue == value)
                {
                    return;
                }

                keyValue = value;
                SetKey(keyValue);
            }
        }
        
        private void OnTriggerEnter(Collider other)
        {
            if (!other.TryGetComponent(out PlayerPositionMarker marker))
            {
                return;
            }

            KeyValue = true;
        }

        private void OnTriggerExit(Collider other)
        {
            if (!other.TryGetComponent(out PlayerPositionMarker marker))
            {
                return;
            }

            KeyValue = false;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/KeySetterOnPlayerTrigger.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxEventNotifierOnCollision.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2cda8fafbd454150b0d1b14014b6dbfe
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    public class LdxEventNotifierOnCollision : TrackingEventNotifier
    {
        [SerializeField]
        private CollisionType collisionType = CollisionType.Hand;

        [SerializeField]
        private CollisionDirection collisionDirection = CollisionDirection.Enter;

        [Header("Applies only if collision type is 'Object Group'")]
        [IDSelection(LdxIdSettings.IdType.ObjectGroup)]
        [SerializeField]
        private string targetObjectGroup;

        private void OnTriggerEnter(Collider other)
        {
            if (collisionDirection != CollisionDirection.Enter ||
                !CollisionUtilities.CheckCollision(other.gameObject, collisionType, targetObjectGroup))
            {
                return;
            }

            BroadcastEvent();
        }

        private void OnCollisionEnter(Collision other)
        {
            if (collisionDirection != CollisionDirection.Enter ||
                !CollisionUtilities.CheckCollision(other.gameObject, collisionType, targetObjectGroup))
            {
                return;
            }

            BroadcastEvent();
        }

        private void OnTriggerExit(Collider other)
        {
            if (collisionDirection != CollisionDirection.Exit ||
                !CollisionUtilities.CheckCollision(other.gameObject, collisionType, targetObjectGroup))
            {
                return;
            }

            BroadcastEvent();
        }

        private void OnCollisionExit(Collision other)
        {
            if (collisionDirection != CollisionDirection.Exit ||
                !CollisionUtilities.CheckCollision(other.gameObject, collisionType, targetObjectGroup))
            {
                return;
            }

            BroadcastEvent();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxEventNotifierOnCollision.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxObjectGroup.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ed29417eb76f481e8798c40cc0a93e84
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    /// <summary>
    /// Marks an object group for tracking
    /// </summary>
    [TrackedReference]
    public class LdxObjectGroup : MonoBehaviour, ISerializationCallbackReceiver
    {
        public enum StateOnAwake
        {
            Active,
            Inactive
        }
        
        [IDSelection(LdxIdSettings.IdType.ObjectGroup)]
        [SerializeField] 
        private string objectGroup;
        public string ObjectGroup => objectGroup;
        
        [SerializeField] private StateOnAwake stateOnAwake = StateOnAwake.Active;

        [Hide]
        [SerializeField] 
        private List<MonoBehaviour> initializers = new List<MonoBehaviour>();

        public List<IObjectGroupInitializer> Initializers => initializers.Select(initializer => (IObjectGroupInitializer)initializer).ToList();

        public void OnBeforeSerialize()
        {
            if (this == null)
            {
                return;
            }
            
            initializers.Clear();

            foreach (var c in GetComponentsInChildren<IObjectGroupInitializer>(true))
            {
                if (c is IObjectGroupInitializer objectGroupInit)
                {
                    initializers.Add(objectGroupInit as MonoBehaviour);
                }            
            }
        }

        public void OnAfterDeserialize() { }

        private void Start()
        {
            gameObject.SetActive(stateOnAwake is StateOnAwake.Active);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxObjectGroup.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxObjectiveEventsTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7423adb265c746579f2ab1e7d7bf4da6
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    public class LdxObjectiveEventsTracker : MonoBehaviour
    {
        public static event Action<IObjective, DisplayObjectiveListEventData> OnAnyObjectiveListShowRequest; 
        public static event Action OnAnyObjectiveListHideRequest; 
        
        private void Start()
        {
            LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
            LdxTrackingManager.Instance.OnTrackingReset += HandleTrackingReset;
        }
        
        private void OnDestroy()
        {
            LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
            LdxTrackingManager.Instance.OnTrackingReset -= HandleTrackingReset;
        }
        
        private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            if (eventData is DisplayObjectiveListEventData displayObjectiveEventData)
            {
                OnAnyObjectiveListShowRequest?.Invoke(objective, displayObjectiveEventData);
                return;
            }

            if (eventData is HideObjectiveListEventData)
            {
                OnAnyObjectiveListHideRequest?.Invoke();
            }
        }

        private void HandleTrackingReset(LdxTrackingManager trackingManager)
        {
            OnAnyObjectiveListHideRequest?.Invoke();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxObjectiveEventsTracker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxReferenceIDTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 173e204326494fd48f34f11a1e68ccce
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Autohand;
using HighlightPlus;
using Ldx.Framework.Features.Animation;
using Ldx.Framework.Features.Highlighting;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
	public class LdxReferenceIDTracker : Singleton<LdxReferenceIDTracker>
	{
		private List<LdxObjectGroup> objectGroupObjects = new();
		private List<SpawnPoint> spawnPoints = new();
		private List<HighlightableObject> highlighters = new();
		private List<AnimationObject> animations = new();
		private List<ObjectiveTransform> objectiveTransforms = new();

		private readonly Dictionary<string, List<LdxObjectGroup>> groupIdToObjectsMap = new();
		private readonly Dictionary<string, SpawnPoint> idToSpawnPointMap = new();
		private readonly Dictionary<string, HighlightableObject> dialogIdToHighlighterMap = new();
		private readonly Dictionary<string, AnimationObject> dialogIdToAnimationMap = new();
		private readonly Dictionary<string, Transform> idToTransformMap = new();
		private readonly Dictionary<string, ObjectiveTransform> idToObjectiveTransformMap = new();
		private readonly Dictionary<string, ObjectiveTransform> idToSocketableMap = new();

		private void Start()
		{
			InitTrackedReferences();
			InitIDMaps();
			LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
			InitializeObjectGroups();
		}

		private void InitializeObjectGroups()
		{
			foreach (var o in objectGroupObjects)
			{
				foreach (var objectGroupInitializer in o.Initializers)
				{
					objectGroupInitializer.Initialize();
				}
			}
		}

		private void OnDestroy()
		{
			if (LdxTrackingManager.IsValid)
			{
				LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
			}
		}

		public SpawnPoint GetSpawnPoint(string id)
		{
			if (!idToSpawnPointMap.TryGetValue(id, out SpawnPoint point))
			{
				if (idToObjectiveTransformMap.TryGetValue(id, out var t))
				{
					var newSpawnPoint = t.gameObject.GetOrAddComponent<SpawnPoint>();
					newSpawnPoint.SpawnPointID = t.TransformPoint;
					idToSpawnPointMap.Add(t.TransformPoint, newSpawnPoint);
					return newSpawnPoint;
				}
				Debug.LogError($"Couldn't find spawn point with ID: {id}");
				return null;
			}

			return point;
		}

		public bool TryGetModalHighlighter(string id, out HighlightableObject highlighter)
		{
			highlighter = null;
			
			if (dialogIdToHighlighterMap.TryGetValue(id, out HighlightableObject h))
			{
				highlighter = h;
				return true;
			}

			return false;
		}

		public HighlightableObject GetModalHighlighter(string id)
		{
			if (!dialogIdToHighlighterMap.TryGetValue(id, out HighlightableObject highlighter))
			{
				Debug.LogError($"Couldn't find highlighter with ID: {id}");
				return null;
			}

			return highlighter;
		}
		
		public bool TryGetAnimationObject(string id, out AnimationObject animObject)
		{
			animObject = null;
			
			if (dialogIdToAnimationMap.TryGetValue(id, out AnimationObject obj))
			{
				animObject = obj;
				return true;
			}

			return false;
		}

		public Transform GetTransform(string id)
		{
			if (!idToTransformMap.TryGetValue(id, out Transform t))
			{
				Debug.LogWarning($"Couldn't find transform with ID: {id}");
				return null;
			}

			return t;
		}
		
		public bool TryGetTransform(string id, out Transform foundTransform)
		{
			return idToTransformMap.TryGetValue(id, out foundTransform);
		}
		
		public List<Transform> GetAllTransforms(string id)
		{
			return objectiveTransforms
				.Where(o => o != null && o.TransformPoint == id)
				.Select(o => o.transform)
				.ToList();
		}
		
		public List<ObjectiveTransform> GetAllObjectiveTransforms(string id)
		{
			List<ObjectiveTransform> transformList =
				GetAllTransforms(id)?
					.Select(transform => transform.GetComponent<ObjectiveTransform>())
					.Where(component => component != null)
					.ToList();
			return transformList;
		}
		
		private void InitTrackedReferences()
        {
			objectGroupObjects = ReferenceBank.Get<LdxObjectGroup>();
			objectGroupObjects ??= new List<LdxObjectGroup>();
			spawnPoints = ReferenceBank.Get<SpawnPoint>();
			spawnPoints ??= new List<SpawnPoint>();
			highlighters = ReferenceBank.Get<HighlightableObject>();
			highlighters ??= new List<HighlightableObject>();
			animations = ReferenceBank.Get<AnimationObject>();
			animations ??= new List<AnimationObject>();
			objectiveTransforms = ReferenceBank.Get<ObjectiveTransform>();
			objectiveTransforms ??= new List<ObjectiveTransform>();
        }

		private void InitIDMaps()
		{
			idToTransformMap.Clear();

			groupIdToObjectsMap.Clear();
			foreach (var o in objectGroupObjects)
			{
				if (o == null || String.IsNullOrEmpty(o.ObjectGroup))
				{
					continue;
				}

				if (!groupIdToObjectsMap.ContainsKey(o.ObjectGroup))
				{
					groupIdToObjectsMap[o.ObjectGroup] = new List<LdxObjectGroup>();
				}

				groupIdToObjectsMap[o.ObjectGroup].Add(o);
			}

			idToSpawnPointMap.Clear();
			foreach (var o in spawnPoints)
			{
				if (idToSpawnPointMap.ContainsKey(o.SpawnPointID))
				{
					Debug.LogError($"Found duplicate spawn points with ID {o.SpawnPointID}");
					continue;
				}

				idToSpawnPointMap.Add(o.SpawnPointID, o);
				idToTransformMap.Add(o.SpawnPointID, o.transform);
			}

			idToObjectiveTransformMap.Clear();
			foreach (var o in objectiveTransforms)
			{
				if (o == null)
				{
					continue;
				}
				
				if (idToObjectiveTransformMap.ContainsKey(o.TransformPoint))
				{
					Debug.LogError($"Found duplicate spawn points with ID {o.TransformPoint}");
					continue;
				}

				idToObjectiveTransformMap.Add(o.TransformPoint, o);
				idToTransformMap.Add(o.TransformPoint, o.transform);
			}

			dialogIdToHighlighterMap.Clear();
			foreach (var h in highlighters)
			{
				if (String.IsNullOrEmpty(h.DialogID))
				{
					continue;
				}

				if (dialogIdToHighlighterMap.ContainsKey(h.DialogID))
				{
					string description = h.DialogID;
					if (LdxIdSettings.TryGetIDDescription(h.DialogID, LdxIdSettings.IdType.Dialog,  out string desc))
					{
						description = desc;
					}
					Debug.LogError($"Found highlighter with duplicate dialog ID: {description}", h.gameObject);
					continue;
				}
				dialogIdToHighlighterMap.Add(h.DialogID, h);
				idToTransformMap.Add(h.DialogID, h.transform);
			}
			
			dialogIdToAnimationMap.Clear();
			foreach (var anim in animations)
			{
				if (String.IsNullOrEmpty(anim.DialogID))
				{
					continue;
				}

				if (dialogIdToAnimationMap.ContainsKey(anim.DialogID))
				{
					string description = anim.DialogID;
					if (LdxIdSettings.TryGetIDDescription(anim.DialogID, LdxIdSettings.IdType.Dialog,  out string desc))
					{
						description = desc;
					}
					Debug.LogError($"Found animation with duplicate dialog ID: {description}", anim.gameObject);
					continue;
				}
				dialogIdToAnimationMap.Add(anim.DialogID, anim);
				idToTransformMap.Add(anim.DialogID, anim.transform);
			}
		}

		private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
		{
			switch (eventData)
			{
				case ObjectGroupActionEventData data:
					ProcessObjectGroupAction(data);
					break;
			}
		}

		private void ProcessObjectGroupAction(ObjectGroupActionEventData data)
		{
			if (!groupIdToObjectsMap.TryGetValue(data.Group, out List<LdxObjectGroup> objects))
			{
				Debug.LogError($"### ID Count: {groupIdToObjectsMap.Count}");
				Debug.LogError($"Tried performing ObjectGroup action, but id {data.Group} not found");
				return;
			}

			var active = data.SetActive;

			foreach (var o in objects)
			{
				switch (data.GroupActionType)
				{
					case ObjectGroupActionEventData.ActionType.GameObjectState:
						o.gameObject.SetActive(active);
						break;
					case ObjectGroupActionEventData.ActionType.CollidersState:
						foreach (Collider c in o.GetComponents<Collider>())
						{
							c.enabled = active;
						}
						break;
					case ObjectGroupActionEventData.ActionType.LightState:
						Light l = o.GetComponent<Light>();
						if (l == null)
						{
							Debug.LogError($"Tried to set light state for object {o.name}, but no light found");
						}
						l.enabled = active;
						break;
					case ObjectGroupActionEventData.ActionType.RigidbodyKinematicState:
						foreach (Rigidbody r in o.GetComponentsInChildren<Rigidbody>())
						{
							r.isKinematic = active;
						}
						break;
					case ObjectGroupActionEventData.ActionType.GrabbableCanGrabState:
						if (o.TryGetComponent(out Grabbable grabbable))
						{
							grabbable.isGrabbable = active;
						}
						break;
					case ObjectGroupActionEventData.ActionType.HighlightEffect:
						if (o.TryGetComponent(out HighlightEffect effect))
						{
							effect.highlighted = active;
						}
						break;
					default:
						throw new ArgumentOutOfRangeException();
				}
			}
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxReferenceIDTracker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxSpawnResetEventTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5a37a63323d54116aa025a503858628c
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.UI;
using Ldx.Framework.Systems.UI.Fading;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    public class LdxSpawnResetEventTracker : Singleton<LdxSpawnResetEventTracker>
    {
        public static event Action<LdxSpawnResetEventTracker, string> OnTransitionAndMoveToPositionCompleted;
        
        [Serializable]
        public class SpawnResetData
        {
            [SerializeField]
            private bool revealWhenGrounded = true;

            public bool RevealWhenGrounded
            {
                get => revealWhenGrounded;
                set => revealWhenGrounded = value;
            }
        
            [SerializeField]
            private bool keepCurrentOrientation;

            public bool KeepCurrentOrientation
            {
                get => keepCurrentOrientation;
                set => keepCurrentOrientation = value;
            }

            [SerializeField]
            private bool useYPosition = true;

            public bool UseYPosition
            {
                get => useYPosition;
                set => useYPosition = value;
            }

            [SerializeField]
            private bool dontResetSockets;

            public bool DontResetSockets
            {
                get => dontResetSockets;
                set => dontResetSockets = value;
            }

            [IDSelection(LdxIdSettings.IdType.Transform)]
            [SerializeField]
            private string spawnPoint;

            public string SpawnPoint
            {
                get => spawnPoint;
                set => spawnPoint = value;
            }
        
            [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
            [SerializeField]
            private List<string> eventsOnFadeOut;

            public List<string> EventsOnFadeOut
            {
                get => eventsOnFadeOut;
                set => eventsOnFadeOut = value;
            }

            [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
            [SerializeField]
            private List<string> eventsOnFadeIn;
            public List<string> EventsOnFadeIn
            {
                get => eventsOnFadeIn;
                set => eventsOnFadeIn = value;
            }
            
            public SpawnResetData(){}

            public SpawnResetData(TransitionAndResetToSpawnPointEventData data)
            {
                revealWhenGrounded = data.RevealWhenGrounded;
                keepCurrentOrientation = data.KeepCurrentOrientation;
                useYPosition = data.UseYPosition;
                dontResetSockets = data.DontResetSockets;
                spawnPoint = data.SpawnPoint;
                eventsOnFadeOut = data.EventsOnFadeOut;
                eventsOnFadeIn = data.EventsOnFadeIn;
            }

            public SpawnResetData(string spawnPoint, bool revealWhenGrounded = true, bool keepCurrentOrientation = false, 
                bool useYPosition = true, bool dontResetSockets = false,  
                List<string> eventsOnFadeOut = null, List<string> eventsOnFadeIn = null)
            {
                this.spawnPoint = spawnPoint;
                this.revealWhenGrounded = revealWhenGrounded;
                this.keepCurrentOrientation = keepCurrentOrientation;
                this.useYPosition = useYPosition;
                this.dontResetSockets = dontResetSockets;
                this.eventsOnFadeOut = eventsOnFadeOut ?? new List<string>();
                this.eventsOnFadeIn = eventsOnFadeIn ?? new List<string>();
            }
        }

        protected override void Awake()
        {
            base.Awake();
            LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
        }

        private void Start()
        {
            InitMap();
        }

        private void OnDestroy()
        {
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
            }
        }

        private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            if (eventData is not TransitionAndResetToSpawnPointEventData data)
            {
                return;
            }

            TransitionAndMoveToPosition(new SpawnResetData(data)).Forget();
        }

        private void InitMap()
        {
            //TODO: init sockets map
            /*socketToGrabbableMap.Clear();
            foreach (HVRGrabbable target in FindObjectsByType<HVRGrabbable>(FindObjectsInactive.Include, FindObjectsSortMode.None))
            {
                HVRSocket socket = target.StartingSocket;
                if (socket == null)
                {
                    continue;
                }
                socketToGrabbableMap.Add(socket, target);
            }*/
        }

        private void ResetSockets()
        {
            //TODO: reset sockets
            /*foreach (HVRSocket socket in socketToGrabbableMap.Keys)
            {
                HVRGrabbable target = socketToGrabbableMap[socket];
                if (target == null || socket.GrabbedTarget == target || target.Socketable == null)
                {
                    continue;
                }
                
                target.transform.position = socket.transform.position;
                socket.TryGrab(target, force: true);
            }*/
        }

         // Do not change this to private, certain projects use it for project-specific scripts.
        public async UniTask TransitionAndMoveToPosition(SpawnResetData data, float? overrideDuration = null)
        {
            if (!PlayerController.IsValid)
            {
                return;
            }
            
            SpawnPoint spawnPoint = LdxReferenceIDTracker.Instance.GetSpawnPoint(data.SpawnPoint);
            if (spawnPoint == null)
            {
                Debug.LogError($"[LdxSpawnResetEventTracker] Could not find SpawnPoint with ID '{data.SpawnPoint}'. Aborting move.");
                return;
            }
            
            Transform pointTransform = spawnPoint.transform;
            PlayerMovementRequest request = new PlayerMovementRequest
            {
                TargetPosition = data.UseYPosition ? pointTransform.position : pointTransform.position.Modify(y: PlayerController.Instance.GetPlayerPosition.y),
                TargetRotation = data.KeepCurrentOrientation ? (Quaternion?)null : pointTransform.rotation,
                UseFade = true,
                FadeDurationOverride = overrideDuration,
                OnBeforeMove = () =>
                {
                    PlayerController.Instance.HandsController.ForceReleaseBothHands();
                    if (!data.DontResetSockets)
                    {
                        ResetSockets();
                    }
                    
                    foreach (string id in data.EventsOnFadeOut)
                    {
                        LdxTrackingManager.Instance.BroadcastTrackingEvent(id);
                    }
                },
                OnAfterMove = () =>
                {
                    foreach (string id in data.EventsOnFadeIn)
                    {
                        LdxTrackingManager.Instance.BroadcastTrackingEvent(id);
                    }
                }
            };
            
            await PlayerController.Instance.MovePlayerToAsync(request);
            OnTransitionAndMoveToPositionCompleted?.Invoke(this, data.SpawnPoint);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxSpawnResetEventTracker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxTimerEventNotifier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 49f11ec45b4246abb1848407d1e49e70
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections;
using System.Collections.Generic;
using Ldx.Framework.Utilities.Logging;
using UnityEngine;
using Debug = Ldx.Framework.Utilities.Logging.Debug;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    /// <summary>
    /// Starts a timer that invokes a tracking event after x seconds
    /// </summary>
    public class LdxTimerEventNotifier : TrackingEventNotifier
    {
        readonly private List<Coroutine> coroutines = new List<Coroutine>();
        
        protected override void Awake()
        {
            base.Awake();
            LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
            LdxTrackingManager.Instance.OnTrackingReset += HandleTrackingReset;
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
            LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
            LdxTrackingManager.Instance.OnTrackingReset -= HandleTrackingReset;
        }

        private void HandleTrackingReset(LdxTrackingManager trackingManager)
        {
            foreach (Coroutine c in coroutines)
            {
                if (c == null)
                {
                    continue;
                }
                
                StopCoroutine(c);
            }  
            
            coroutines.Clear();
        }
        
        private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            if (eventData is not TriggerEventAfterTimeEventData timeEventData)
            {
                return;
            }
            
            coroutines.Add(StartCoroutine(BroadcastEventAfterTimeAsync(timeEventData.Time, timeEventData.EventToTrigger)));
        }

        private IEnumerator BroadcastEventAfterTimeAsync(float time, string id)
        {
            yield return new WaitForSeconds(time);

            BroadcastEvent(id);
            Debug.LogVerbose(LogCategory.EventData, $"Broadcasting event: {id}");
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxTimerEventNotifier.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxTrackingEventArgument.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 14e856a9d5b448d4b4e471daf221a6df
# ASMDEF: ldx.framework.runtime.dll
# ---
namespace Ldx.Framework.Systems.Objectives.Tracking
{
    /// <summary>
    /// In case a tracking feature needs access to the original ObjectiveEventData
    /// </summary>
    public class LdxTrackingEventArgument
    {
        public static LdxTrackingEventArgument EmptyEventArgument { get; } = new LdxTrackingEventArgument();
        public ObjectiveEventData ObjectiveEventData { get; }
        public string ID { get; }
        
        private LdxTrackingEventArgument()
        {
        }
        
        public LdxTrackingEventArgument(ObjectiveEventData objectiveEventData, string id)
        {
            ObjectiveEventData = objectiveEventData;
            ID = id;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxTrackingEventArgument.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxTrackingManager.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 53b25b6a17294e249857ed9e71b9e434
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Logging;
using UnityEngine;
using System.Reflection;
using Debug = Ldx.Framework.Utilities.Logging.Debug;
using Object = UnityEngine.Object;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    /// <summary>
    /// Handles event tracking in the application's outer layer
    /// </summary>
    [SceneSetupLink(SceneSetupLinkGroup.Essential)]
    public class LdxTrackingManager : Singleton<LdxTrackingManager>, ISerializationCallbackReceiver, ISaveSceneListener
    {
        public static event Action<IObjective> OnAnyObjectiveComplete; 
        public static event Action<IObjective, ObjectiveEventData> OnAnyObjectiveEvent;

        public event Action<string> OnTrackingEvent;
        public event Action<string> OnDialogHighlighterActivated; 
        public event Action<string, bool> OnDialogCompleted;
        public event Action<IObjective, ObjectiveEventData> OnObjectiveEvent;
        public event Action<TrackingFeature> OnFeatureCompleted;
        public event Action<TrackingFeature> OnFeatureFailed;
        public event Action<LdxTrackingManager> OnTrackingReset;
        public event Action<ObjectiveEventData.InteractionEventType, string> OnInteractionEvent; 

        [SerializeField]
        private bool startWithoutWaitForScenario;

        private bool ShouldStartWithoutWaitForScenario =>
            startWithoutWaitForScenario;

        private List<TrackingFeature> trackingFeatures = new();
        
        private List<TrackingEventNotifier> notifiers = new();
        public List<TrackingEventNotifier> Notifiers => notifiers;

        private readonly List<string> trackingEventsHistory = new(); 
        private readonly HashSet<TrackingEventNotifier> notifiersSet = new();
        private readonly Dictionary<string, TrackingFeature> idToTrackingFeatureMap = new();
        private readonly Dictionary<string, Action<LdxTrackingEventArgument>> eventTrackingIdToEvent = new();
        private readonly Dictionary<Type, Delegate> objectiveEventDataSubscriptions = new();
        
        public bool IsReady { get; private set; }
        
        protected override void Awake()
        {
            base.Awake();

            if (ShouldStartWithoutWaitForScenario)
            {
                StartManager();
                return;
            }
            BaseScenario s = FindAnyObjectByType<BaseScenario>();
            s.OnScenarioStarted += handleScenarioStarted;
            Debug.LogVerbose(LogCategory.TrackingManager,"TrackingManager's Awake()");
                
            void handleScenarioStarted(BaseScenario scenario)
            {
                scenario.OnScenarioStarted -= handleScenarioStarted;
                StartManager();
            }
        }
        
        private void OnDestroy()
        {
            if (ObjectiveSystem.IsValid)
            {
                ObjectiveSystem.Instance.OnAnyObjectiveComplete -= HandleAnyObjectiveComplete;
            }

            foreach (TrackingFeature f in trackingFeatures)
            {
                if (f == null)
                {
                    continue;
                }

                f.OnCompleted -= HandleFeatureCompleted;
                f.OnFailed -= HandleFeatureFailed;
            }
        }


        private void StartManager()
        {
            Debug.LogVerbose(LogCategory.TrackingManager,"TrackingManager's Start()");
            GrabSceneReferences();
            InitDictionaries();
            SubscribeToEvents();
            IsReady = true;
        }

        private void GrabSceneReferences()
        {
            trackingFeatures = ReferenceBank.Get<TrackingFeature>()?? new List<TrackingFeature>();
            Debug.LogVerbose(LogCategory.TrackingManager,$"TrackingFeatures count: {trackingFeatures.Count}");
            notifiers = ReferenceBank.Get<TrackingEventNotifier>() ?? new List<TrackingEventNotifier>();
            Debug.LogVerbose(LogCategory.TrackingManager,$"Notifiers count: {notifiers.Count}");
        }

        private void SubscribeToEvents()
        {
            if (ObjectiveSystem.Instance != null)
            {
                ObjectiveSystem.Instance.OnAnyObjectiveComplete += HandleAnyObjectiveComplete;
            }

            foreach (TrackingFeature f in trackingFeatures)
            {
                if (f == null)
                {
                    continue;
                }
                f.OnCompleted += HandleFeatureCompleted;
                f.OnFailed += HandleFeatureFailed;
            }
        }

        public void BroadcastObjectiveEvent(BaseObjective baseObjective, ObjectiveEventData eventData)
        {
            handleTrackingFeature();
            handleTrackingEvent();
            OnObjectiveEvent?.Invoke(baseObjective, eventData);
            OnAnyObjectiveEvent?.Invoke(baseObjective, eventData);
            
            if (eventData != null)
            {
                Type eventDataType = eventData.GetType();
                if (objectiveEventDataSubscriptions.TryGetValue(eventDataType, out Delegate handler))
                {
                    // We use DynamicInvoke because the delegate's signature is generic and stored as a base Delegate.
                    // This has a small performance cost, but is acceptable for objective events.
                    handler.DynamicInvoke(baseObjective, eventData);
                }
            }
            

            void handleTrackingFeature()
            {
                if (eventData is not TrackingFeatureEventData e)
                {
                    return;
                }

                if (!idToTrackingFeatureMap.TryGetValue(e.Feature, out TrackingFeature feature))
                {
                    return;
                }

                if (e is StopTrackingFeatureEventData)
                {
                    feature.StopTracking();
                    return;
                }
                feature.StartTracking(e);
            }

            void handleTrackingEvent()
            {
                if (!(eventData is TrackingEventTriggerEventData e) || eventData is TriggerEventAfterTimeEventData)
                {
                    return;
                }
                if (!eventTrackingIdToEvent.TryGetValue(e.EventToTrigger, out Action<LdxTrackingEventArgument> eventAction))
                {
                    return;
                }
                
                eventAction?.Invoke(new LdxTrackingEventArgument(e, e.EventToTrigger));
                BroadcastTrackingEvent(e.EventToTrigger);
            }
        }

        private void HandleAnyObjectiveComplete(ObjectiveSystem objectiveSystem, BaseObjective baseObjective)
        {
            OnAnyObjectiveComplete?.Invoke(baseObjective);
        }
        
        private void NotifyActiveTrackingFeaturesOfEvent(string id)
        {
            foreach (TrackingFeature feature in trackingFeatures)
            {
                if (!feature.IsTracking)
                {
                    continue;
                }
                feature.NotifyOfTrackingEvent(id);
            }
        }

        public void BroadcastInteractionEvent(ObjectiveEventData.InteractionEventType interactionEventType, string id)
        {
            OnInteractionEvent?.Invoke(interactionEventType, id);
        }
        
        public void BroadcastTrackingEvent(string id)
        {
            if (string.IsNullOrEmpty(id))
            {
                return;
            }

            if (LdxIdSettings.TryGetIDDescription(id, LdxIdSettings.IdType.TrackingEvent, out string description))
            {
                Debug.LogVerbose($"Broadcasting tracking event: {description}");
            }
            
            OnTrackingEvent?.Invoke(id);
            
            NotifyActiveTrackingFeaturesOfEvent(id);
            trackingEventsHistory.Add(id);
            
            if (eventTrackingIdToEvent.TryGetValue(id, out Action<LdxTrackingEventArgument> specificEvent))
            {
                specificEvent?.Invoke(LdxTrackingEventArgument.EmptyEventArgument);
            }
        }

        /// <summary>
        /// Returns true if tracking event has happened in the past
        /// </summary>
        public bool CheckTrackingEventOccured(string id)
        {
            return trackingEventsHistory.Contains(id);
        }

        public void BroadcastDialogHighlighterActivated(string id)
        {
            OnDialogHighlighterActivated?.Invoke(id);
        }

        public void BroadcastDialogComplete(string id, bool rightAnswer = true)
        {
            OnDialogCompleted?.Invoke(id, rightAnswer);
        }

        private void HandleFeatureCompleted(TrackingFeature f)
        {
            OnFeatureCompleted?.Invoke(f);
        }
        
        private void HandleFeatureFailed(TrackingFeature f)
        {
            OnFeatureFailed?.Invoke(f);
        }

        public void AddTracker(TrackingEventNotifier notifier)
        {
            if (notifiersSet.Contains(notifier))
            {
                return;
            }

            notifiers.Add(notifier);
            notifiersSet.Add(notifier);
        }

        public bool Contains(TrackingEventNotifier notifier)
        {
            return notifiersSet.Contains(notifier);
        }

        public void OnBeforeSerialize()
        {
            trackingFeatures = FindObjectsByType<TrackingFeature>(FindObjectsInactive.Include, FindObjectsSortMode.None).ToList();
            notifiers = FindObjectsByType<TrackingEventNotifier>(FindObjectsInactive.Include, FindObjectsSortMode.None).ToList().ToList();
        }

        public void OnAfterDeserialize() { }

        private void InitDictionaries()
        {
            notifiersSet.Clear();
            idToTrackingFeatureMap.Clear();
            eventTrackingIdToEvent.Clear();
            objectiveEventDataSubscriptions.Clear();
                
            for (int i = notifiers.Count - 1; i >= 0; i--)
            {
                TrackingEventNotifier t = notifiers[i];
                if (!notifiersSet.Add(t))
                {
                    notifiers.RemoveAt(i);
                }
            }

            foreach (TrackingFeature f in trackingFeatures)
            {
                if (f == null)
                {
                    Debug.LogError(LogCategory.TrackingManager,"Issue while initializing dictionary: tracking feature is null");
                    continue;
                }

                if (string.IsNullOrEmpty(f.TrackingFeatureID))
                {
                    Debug.LogError(LogCategory.TrackingManager,$"{f.name} - Issue while initializing dictionary: tracking feature id is null or empty");
                }

                idToTrackingFeatureMap[f.TrackingFeatureID] = f;
            }
            
            CompoundIDInfoContainer idList = LdxIdSettings.GetCompoundIDList(LdxIdSettings.IdType.TrackingEvent);
            foreach (IDInfo info in idList)
            {
                eventTrackingIdToEvent.TryAdd(info.ID, null);
            }
        }
        
        public static TrackingFeature GetTrackingFeature(string id)
        {
            if (Instance == null)
            {
                Debug.LogError(LogCategory.TrackingManager,"No LdxTrackingManager instance available in the scene");
                return null;
            }

            if (!Instance.idToTrackingFeatureMap.TryGetValue(id, out TrackingFeature feature))
            {
                Debug.LogError(LogCategory.TrackingManager, $"No feature with id {id} found, id count: {Instance.idToTrackingFeatureMap.Count}");
                return null;
            }

            return feature;
        }

        public void BroadcastTrackingReset()
        {
            OnTrackingReset?.Invoke(this);
        }
        
        #region Subscription

        /// <summary>
        /// Subscribes a handler to a specific tracking event ID.
        /// The handler will only be called when an event with the matching ID is broadcast.
        /// </summary>
        /// <param name="eventId">The ID of the tracking event to listen for.</param>
        /// <param name="handler">The action to execute when the event occurs.</param>
        public void SubscribeToTrackingEvent(string eventId, Action<LdxTrackingEventArgument> handler)
        {
            if (string.IsNullOrEmpty(eventId) || handler == null) return;

            if (eventTrackingIdToEvent.TryGetValue(eventId, out var existingHandler))
            {
                eventTrackingIdToEvent[eventId] = existingHandler + handler;
            }
            else
            {
                // This event ID is not pre-registered in LdxIdSettings. We can add it dynamically or log a warning.
                // Let's add it, but also warn the user.
                Debug.LogWarning(LogCategory.TrackingManager, $"Subscribing to tracking event '{eventId}' which was not pre-registered. Consider adding it to LdxIdSettings.");
                eventTrackingIdToEvent[eventId] = handler;
            }
        }

        /// <summary>
        /// Unsubscribes a handler from a specific tracking event ID.
        /// </summary>
        /// <param name="eventId">The ID of the tracking event to stop listening to.</param>
        /// <param name="handler">The action to remove.</param>
        public void UnsubscribeFromTrackingEvent(string eventId, Action<LdxTrackingEventArgument> handler)
        {
            if (string.IsNullOrEmpty(eventId) || handler == null) return;

            if (eventTrackingIdToEvent.TryGetValue(eventId, out var existingHandler))
            {
                eventTrackingIdToEvent[eventId] = existingHandler - handler;
            }
        }

        /// <summary>
        /// Subscribes a handler to a specific type of ObjectiveEventData.
        /// The handler will only be called when an objective event with the matching data type occurs.
        /// </summary>
        /// <typeparam name="T">The type of ObjectiveEventData to listen for.</typeparam>
        /// <param name="handler">The action to execute. It will receive the objective and the strongly-typed event data.</param>
        public void SubscribeToObjectiveEvent<T>(Action<IObjective, T> handler) where T : ObjectiveEventData
        {
            Type eventType = typeof(T);
            if (!objectiveEventDataSubscriptions.TryGetValue(eventType, out Delegate existingDelegate))
            {
                objectiveEventDataSubscriptions[eventType] = handler;
            }
            else
            {
                objectiveEventDataSubscriptions[eventType] = (Action<IObjective, T>)existingDelegate + handler;
            }
        }

        /// <summary>
        /// Unsubscribes a handler from a specific type of ObjectiveEventData.
        /// </summary>
        /// <typeparam name="T">The type of ObjectiveEventData to stop listening to.</typeparam>
        /// <param name="handler">The action to remove.</param>
        public void UnsubscribeFromObjectiveEvent<T>(Action<IObjective, T> handler) where T : ObjectiveEventData
        {
            Type eventType = typeof(T);
            if (objectiveEventDataSubscriptions.TryGetValue(eventType, out Delegate existingDelegate))
            {
                Delegate newDelegate = (Action<IObjective, T>)existingDelegate - handler;
                if (newDelegate == null)
                {
                    // Remove the key if no listeners are left
                    objectiveEventDataSubscriptions.Remove(eventType);
                }
                else
                {
                    objectiveEventDataSubscriptions[eventType] = newDelegate;
                }
            }
        }

        #endregion

        public void OnSceneSaving()
        {
#if UNITY_EDITOR
            EDITOR_CheckForRequiredTrackers();
#endif
        }
        
#if UNITY_EDITOR
        public void EDITOR_OnEnable()
        {
            GrabSceneReferences();
            InitDictionaries();
        }

        public void EDITOR_CheckForRequiredTrackers()
        {
            GlobalData.Instance.Initialize();
            ScenarioData scenarioData = GlobalData.Instance.GetScenarioDataBySceneName(gameObject.scene.name);
            if (scenarioData == null)
            {
                return;
            }

            foreach (ObjectiveData objectiveData in scenarioData.ObjectiveDataList)
            {
                if (objectiveData.EDITOR_HasAnyInteractionEvents() && InteractableEventsTracker.Instance == null)
                {
                    string message = $"Found interaction events, but {nameof(InteractableEventsTracker)} is missing\n\n";
                    message += "Add now as child of the tracking manager?";
                    if (UnityEditor.EditorUtility.DisplayDialog("Message", message, "Ok", "Cancel"))
                    {
                        addTrackerByType(typeof(InteractableEventsTracker));
                    }
                }
            
                List<Type> types = objectiveData.EDITOR_GetAllRegisteredEventDataTypes();
                foreach (Type t in types)
                {
                    RequireTrackerAttribute customAttribute = t.GetCustomAttribute<RequireTrackerAttribute>();
                    if (customAttribute == null)
                    {
                        continue;
                    }

                    Type trackerType = customAttribute.Type;
                    Object trackerRef = FindAnyObjectByType(trackerType);
                    if (trackerRef != null)
                    {
                        continue;
                    }

                    string message = $"Found event data of type {t.Name} which has a missing tracker requirement of type {trackerType.Name}\n\n";
                    message += $"Add now as child of the tracking manager?";
                    if (!UnityEditor.EditorUtility.DisplayDialog("Message", message, "Ok", "Cancel"))
                    {
                        continue;
                    }

                    if (string.IsNullOrEmpty(customAttribute.PrefabPath))
                    {
                        addTrackerByType(trackerType);
                    }
                    else
                    {
                        addTrackerByPath(customAttribute.PrefabPath);
                    }
                }
            }

            void addTrackerByType(Type trackerType)
            {
                Component trackerObject = new GameObject(trackerType.Name).AddComponent(trackerType);
                trackerObject.transform.SetParent(transform);
            }

            void addTrackerByPath(string prefabPath)
            {
                prefabPath = prefabPath
                    .Replace('\\', System.IO.Path.DirectorySeparatorChar)
                    .Replace('/', System.IO.Path.DirectorySeparatorChar);
                
                if (prefabPath.Last() == System.IO.Path.DirectorySeparatorChar)
                {
                    prefabPath = prefabPath.Substring(0, prefabPath.Length - 1);
                }
                
                GameObject prefab = Resources.Load<GameObject>(prefabPath);
        
                if (prefab != null)
                {
                    GameObject trackerObject = (GameObject)UnityEditor.PrefabUtility.InstantiatePrefab(prefab, gameObject.scene);
                    trackerObject.transform.SetParent(transform);
                }
                else
                {
                    string error = $"Tracker at path '{prefabPath}' could not be found and wasn't added to the scene.\nPlease inform developers.";
                    UnityEditor.EditorUtility.DisplayDialog("Error", error, "Ok");
                    Debug.LogError(error);
                }
            }
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxTrackingManager.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxTrackingUnityEventListener.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0a0f0144e1c74e0293bc78d51be02f5e
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;
using UnityEngine.Events;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    /// <summary>
    /// Event listener that invokes a UnityEvent in response to a TrackingEvent
    /// </summary>
    public class LdxTrackingUnityEventListener : TrackingEventListener
    {
        [SerializeField] 
        private UnityEvent OnEvent;

        protected override void ProcessTrackingEvent()
        {
            base.ProcessTrackingEvent();
            OnEvent?.Invoke();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/LdxTrackingUnityEventListener.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/PlayerActionTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6077469b004645b085bc121dadcf8950
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Autohand;
using Ldx.Framework.Systems.Objectives.EventData;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.Teleportation;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    /// <summary>
    /// Tracks specific player actions like snap turns and teleportation events.
    /// It integrates with the objective system to monitor when these actions occur
    /// and for how many times, broadcasting events upon each occurrence and completion.
    /// </summary>
    public class PlayerActionTracker : EventDataTracker
    {
        public enum PlayerActionType
        {
            /// <summary>
            /// Represents a player snap turn action.
            /// </summary>
            SnapTurn = 0,
            /// <summary>
            /// Represents the action of pulling the joystick to initiate teleportation.
            /// </summary>
            TeleportationJoystickPull = 1,
            /// <summary>
            /// Represents the completion of a teleportation action.
            /// </summary>
            TeleportationComplete = 2,
        }

        /// <summary>
        /// A dictionary that stores the player actions currently being tracked.
        /// The key is the <see cref="PlayerActionType"/>, and the value is a tuple containing:
        /// - float: The remaining amount of actions required.
        /// - string: The event string to broadcast on each action.
        /// - string: The event string to broadcast upon completion.
        /// </summary>
        private readonly Dictionary<PlayerActionType, (float amount, string onAction, string onCompleted)>
            trackingActions = new();

        protected override void Start()
        {
            base.Start();
            PlayerController.Instance.AutoHandPlayer.OnSnapTurn += HandlePlayerSnapTurn;
            PlayerTeleporter.OnTeleportActivateDeactive += HandleTeleportActivatedDeactivated;
            PlayerTeleporter.OnTeleportationFinished += HandleTeleported;
        }
        
        protected override void OnDestroy()
        {
            base.OnDestroy();
            if (PlayerController.IsValid)
            {
                PlayerController.Instance.AutoHandPlayer.OnSnapTurn -= HandlePlayerSnapTurn;
                PlayerTeleporter.OnTeleportActivateDeactive -= HandleTeleportActivatedDeactivated;
                PlayerTeleporter.OnTeleportationFinished -= HandleTeleported;
            }
        }

        /// <summary>
        /// Handles incoming objective events. If the event is a <see cref="TrackPlayerActionsEventData"/>,
        /// it starts tracking the specified player action or updates an existing one.
        /// </summary>
        /// <param name="objective">The objective that triggered the event.</param>
        /// <param name="eventData">The data associated with the objective event.</param>
        protected override void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            switch (eventData)
            {
                case TrackPlayerActionsEventData data:
                {
                    if (trackingActions.ContainsKey(data.ActionType))
                    {
                        Debug.LogWarning("The tracking action has already been added. Completing the previous and starting the new one.");
                        CompleteAndRemoveAction(data.ActionType);
                    }
                
                    trackingActions.Add(data.ActionType, (data.Amount, data.EventOnEachAction, data.EventOnCompletion));
                    break;
                }
                default:
                    return;   
            }
        }

        /// <summary>
        /// Handles the reset signal from the <see cref="LdxTrackingManager"/> by clearing
        /// all currently tracked player actions.
        /// </summary>
        /// <param name="trackingManager">The instance of the tracking manager initiating the reset.</param>
        protected override void HandleTrackingReset(LdxTrackingManager trackingManager)
        {
            trackingActions.Clear();
        }

        /// <summary>
        /// Decreases the remaining count for a specific tracked player action.
        /// Broadcasts an 'onAction' event and, if the count reaches zero, completes and removes the action.
        /// </summary>
        /// <param name="actionType">The type of player action that occurred.</param>
        private void DecreaseRemainingAmount(PlayerActionType actionType)
        {
            if (trackingActions.TryGetValue(actionType, out (float amount, string onAction, string) trackingInfo))
            {
                trackingInfo.amount--;
                LdxTrackingManager.Instance.BroadcastTrackingEvent(trackingInfo.onAction);
                if (trackingInfo.amount < 1)
                {
                    CompleteAndRemoveAction(actionType);
                }
            }
        }

        /// <summary>
        /// Broadcasts the completion event for the specified player action and removes it
        /// from the tracking dictionary.
        /// </summary>
        /// <param name="actionType">The type of player action to complete and remove.</param>
        private void CompleteAndRemoveAction(PlayerActionType actionType)
        {
            if (trackingActions.TryGetValue(actionType, out (float, string, string onCompleted) trackingInfo))
            {
                LdxTrackingManager.Instance.BroadcastTrackingEvent(trackingInfo.onCompleted);
                trackingActions.Remove(actionType);
            }
        }
        
        /// <summary>
        /// Event handler for player snap rotation. Decreases the remaining amount for the <see cref="PlayerActionType.SnapTurn"/> action type.
        /// </summary>
        private void HandlePlayerSnapTurn(AutoHandPlayer _)
        {
            DecreaseRemainingAmount(PlayerActionType.SnapTurn);
        }

        /// <summary>
        /// Event handler for teleport activation. Decreases the remaining amount for the <see cref="PlayerActionType.TeleportationJoystickPull"/> action type.
        /// </summary>
        private void HandleTeleportActivatedDeactivated(PlayerTeleporter playerTeleporter, bool active)
        {
            if (active)
            {
                DecreaseRemainingAmount(PlayerActionType.TeleportationJoystickPull);
            }
        }
        
        /// <summary>
        /// Event handler for teleportation completion. Decreases the remaining amount
        /// for the <see cref="PlayerActionType.TeleportationComplete"/> action type.
        /// </summary>
        private void HandleTeleported(PlayerTeleporter playerTeleporter)
        {
            DecreaseRemainingAmount(PlayerActionType.TeleportationComplete);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/PlayerActionTracker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/ScenarioLoadEventTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 982a9e664eff464baf44b9ad6d3660e4
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.ScenarioManagement;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    public class ScenarioLoadEventTracker : MonoBehaviour
    {
        private void Awake()
        {
            LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
        }

        private void OnDestroy()
        {
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
            }
        }
        
        private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            if (eventData is LoadScenarioEventData data)
            {
                switch (data.LoadType)
                {
                    case LoadScenarioEventData.ScenarioLoadType.ReloadCurrent:
                        ScenarioManager.Instance.ReloadCurrentScenario();
                        break;
                    case LoadScenarioEventData.ScenarioLoadType.Next:
                        ScenarioManager.Instance.LoadNextScenario();
                        break;
                    case LoadScenarioEventData.ScenarioLoadType.Previous:
                        ScenarioManager.Instance.LoadPreviousScenario();
                        break;
                    case LoadScenarioEventData.ScenarioLoadType.LoadById:
                        ScenarioManager.Instance.LoadScenario(data.ScenarioId);
                        break;
                    case LoadScenarioEventData.ScenarioLoadType.Lobby:
                        ScenarioManager.Instance.LoadLobby();
                        break;
                    case LoadScenarioEventData.ScenarioLoadType.Tutorial:
                        ScenarioManager.Instance.LoadBasicsTutorial();
                        break;
                    case LoadScenarioEventData.ScenarioLoadType.RestartApplication:
                        ScenarioManager.Instance.LoadStartup();
                        break;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/ScenarioLoadEventTracker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/SetTrackingKeyBasedOnLocalRotation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c9f26f95c4a74a638008ed36f7fb9801
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using Range = Ldx.Framework.Utilities.Range;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    public class SetTrackingKeyBasedOnLocalRotation : MonoBehaviour
    {
        [Serializable]
        public enum Axis
        {
            X = 0, Y, Z
        }
        
        [IDSelection(LdxIdSettings.IdType.Key)]
        [SerializeField] 
        private string key;
        [SerializeField] 
        private Axis rotationAxis;
        [Tooltip("Key set to true if in this range, otherwise false")]
        [SerializeField] 
        private Range trueRange;

        private bool isOn;

        private bool IsOn
        {
            get => isOn;
            set
            {
                if (isOn == value)
                {
                    return;
                }
                SetKeyValue(value);
            }
        }

        private void Update()
        {
            UpdateValue();
        }

        private void UpdateValue()
        {
            float value = GetSelectedAxisValue();
            IsOn = trueRange.IsInRange(value);
        }

        private float GetSelectedAxisValue()
        {
            switch (rotationAxis)
            {
                case Axis.X:
                    return transform.localRotation.eulerAngles.x;
                case Axis.Y:
                    return transform.localRotation.eulerAngles.y;
                case Axis.Z:
                    return transform.localRotation.eulerAngles.z;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        private void SetKeyValue(bool newValue)
        {
            isOn = newValue;
            TrackingKeyController.Instance.SetKeyValue(key, IsOn);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/SetTrackingKeyBasedOnLocalRotation.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/SeuratEventsTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8ec4e9a0e53b4b54adab804b86844b13
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Utilities.Seurat;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    public class SeuratEventsTracker : MonoBehaviour
    {
        private List<SeuratEnvironment> seuratEnvironments = new();

        private readonly Dictionary<string, SeuratEnvironment> idSeuratEnvironmentsMap =
            new Dictionary<string, SeuratEnvironment>();
        
        private void Start()
        {
            LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
            InitializeEnvReference();
        }
        
        private void OnDestroy()
        {
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
            }
        }

        private void InitializeEnvReference()
        {
            seuratEnvironments = FindObjectsByType<SeuratEnvironment>(FindObjectsInactive.Include, FindObjectsSortMode.None).ToList();
            idSeuratEnvironmentsMap.Clear();

            foreach (SeuratEnvironment environment in seuratEnvironments)
            {
                if (string.IsNullOrEmpty(environment.SeuratID))
                {
                    continue;
                }

                idSeuratEnvironmentsMap[environment.SeuratID] = environment;
            }
        }

        private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            if (eventData is EnableDisableSeuratObjectEventData data)
            {
                if (idSeuratEnvironmentsMap.Count < 1)
                {
                    InitializeEnvReference();
                }
                
                if (string.IsNullOrEmpty(data.SeuratId) || !idSeuratEnvironmentsMap.TryGetValue(data.SeuratId, out SeuratEnvironment environment))
                {
                    return;
                }
                
                environment.gameObject.SetActive(data.SetActive);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/SeuratEventsTracker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/Socketing/SocketableArrowMarker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 89bb5fab8f2b4c788efb9e569eae0a82
# ASMDEF: ldx.framework.runtime.dll
# ---
using Autohand;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    /// <summary>
    /// Marks a socketable arrow location for an item with
    /// a Socketable ID
    /// </summary>
    [TrackedReference]
    public class SocketableArrowMarker : MonoBehaviour
    {
        [IDSelection(LdxIdSettings.IdType.Socketable)]
        [SerializeField] 
        private string socketableId;
        public string SocketableID => socketableId;
        [SerializeField] 
        private Grabbable grabbable;
        public Grabbable Grabbable => grabbable;
        
        public GameObject Arrow { get; set; }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/Socketing/SocketableArrowMarker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/Socketing/SocketToHolsterGuideTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c3cbafdad1934952ab586451775e1a0a
# ASMDEF: ldx.framework.runtime.dll
# ---
/*using System;
using System.Collections.Generic;
using System.Linq;
using Autohand;
using Cysharp.Threading.Tasks;
using FluffyUnderware.DevTools.Extensions;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Utilities;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    /// <summary>
    /// Tracker for the socket holster guide feature
    /// Activates arrows on target items, then points to available holsters when they're grabbed 
    /// </summary>
    public class SocketToHolsterGuideTracker : MonoBehaviour
    {
        private readonly List<GameObject> holsterArrows = new List<GameObject>();
        private readonly List<SocketableArrowMarker> trackedMarkers = new List<SocketableArrowMarker>();
        private readonly Dictionary<PlacePoint, GameObject> holsterToArrowMap = new Dictionary<PlacePoint, GameObject>();
        private readonly Dictionary<string, SocketableArrowMarker> idToMarkerMap =
            new Dictionary<string, SocketableArrowMarker>();
        
        [SerializeField] private GameObject arrowPrefab;
        [SerializeField] private float arrowHolsterOffset = 0.25f;

        private enum IndicatorState 
        {
            NoItemsGrabbed = 0,
            ItemsGrabbed,
            Completed
        }
        
        private IndicatorState? State { get; set; } = null;

        private bool IsActive { get; set; }
        private string CompletionTrackingEvent { get; set; } = null;

        private void Awake()
        {
            LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
#pragma warning disable CS4014
            awakeAsync();
#pragma warning restore CS4014

            async UniTaskVoid awakeAsync()
            {
                await UniTask.WaitUntil(() => ScenarioManager.Instance != null);
                ScenarioManager.Instance.OnScenarioStarted += HandleScenarioStarted;
            }
        }

        private void OnDestroy()
        {
            foreach (GameObject arrow in holsterArrows)
            {
                if (arrow == null)
                {
                    continue;
                }
                Destroy(arrow);
            }
            if (ScenarioManager.Instance != null)
            {
                ScenarioManager.Instance.OnScenarioStarted -= HandleScenarioStarted;
            }

            if (LdxTrackingManager.Instance != null)
            {
                LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
            }
        }

        private void Initialize()
        {
            List<Holster> holsters = PlayerController.Instance.WaistController.GetAllAvailableHolsters();
            foreach (Holster holster in holsters)
            {
                GameObject arrow = Instantiate(arrowPrefab, holster.transform, true);
                arrow.transform.localPosition = Vector3.zero;
                Vector3 forward = PlayerController.Instance.WaistController.GetWaistForward();
                arrow.transform.position += forward * arrowHolsterOffset;
                arrow.transform.LookAt(holster.transform, Vector3.up);
                holsterToArrowMap.Add(holster, arrow);
                holsterArrows.Add(arrow);
                arrow.gameObject.SetActive(false);
            }

            List<SocketableArrowMarker> markers = ReferenceBank.Get<SocketableArrowMarker>();
            if (markers == null)
            {
                return;
            }
            
            foreach (SocketableArrowMarker o in markers)
            {
                GameObject arrow = Instantiate(arrowPrefab, o.transform, true);
                arrow.transform.localPosition = Vector3.zero;
                arrow.transform.localRotation = Quaternion.identity;
                idToMarkerMap.Add(o.SocketableID, o);
                o.Arrow = arrow;
                arrow.SetActive(false);
            }
        }

        private void HandleScenarioStarted(ScenarioManager mgr, ScenarioDataType dataType)
        {
            Initialize();
        }

        private void Update()
        {
            if (!IsActive)
            {
                return;
            }

            IndicatorState? lastState = State;
            // Have to pool instead of using events because HVR events are unreliable and dumb
            DeduceState();
            if (lastState != State)
            {
                switch (State)
                {
                    case IndicatorState.NoItemsGrabbed:
                        ProcessNoItemsGrabbedState();
                        break;
                    case IndicatorState.ItemsGrabbed:
                        ProcessItemsGrabbedState();
                        break;
                    case IndicatorState.Completed:
                        ProcessCompletedState();
                        break;
                    case null:
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
        }

        private void ProcessNoItemsGrabbedState()
        {
            holsterArrows.ForEach(arrow => arrow.SetActive(false));
            trackedMarkers.ForEach(m => m.Arrow.SetActive(!(m.Grabbable.Socket is Holster)));
        }

        private void ProcessItemsGrabbedState()
        {
            string[] grabbedIds = trackedMarkers.Where(m => m.Grabbable.IsHandGrabbed)
                .Select(m => m.SocketableID).ToArray();
            trackedMarkers.ForEach(m => m.Arrow.SetActive(false));
            List<Holster> availableHolsters =
                PlayerController.Instance.WaistController.GetAvailableHolsters(grabbedIds);

            foreach (Holster holster in availableHolsters)
            {
                if (!holsterToArrowMap.TryGetValue(holster, out GameObject arrow))
                {
                    Debug.LogError($"Can't find arrow for holster: {holster.name}");
                    continue;
                }

                arrow.gameObject.SetActive(true);
            }
        }

        private void ProcessCompletedState()
        {
            SetActive(false);
            if (!string.IsNullOrEmpty(CompletionTrackingEvent))
            {
                LdxTrackingManager.Instance.BroadcastTrackingEvent(CompletionTrackingEvent);
            }

            CompletionTrackingEvent = null;
        }

        private void DeduceState()
        {
            bool handGrabbedFound = false;
            int itemsSocketedToHolsterCount = 0;

            foreach (SocketableArrowMarker marker in trackedMarkers)
            {
                if (marker.Grabbable.IsHandGrabbed)
                {
                    handGrabbedFound = true;
                }

                if (marker.Grabbable.Socket is Holster)
                {
                    itemsSocketedToHolsterCount++;
                }
            }

            if (itemsSocketedToHolsterCount == trackedMarkers.Count)
            {
                State = IndicatorState.Completed;
                return;
            }

            if (handGrabbedFound)
            {
                State = IndicatorState.ItemsGrabbed;
                return;
            }

            State = IndicatorState.NoItemsGrabbed;
        }

        private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            switch (eventData)
            {
                case ActivateSocketToHolsterGuideEventData data:
                    ProcessActivate(data);
                    break;
                case DeactivateSocketToHolsterGuideEventData data:
                    ProcessDeactivate(data);
                    break;
            }
        }

        private void ProcessActivate(ActivateSocketToHolsterGuideEventData data)
        {
            SetActive(true);
            CompletionTrackingEvent = data.CompletionEvent;
            foreach (string id in data.SocketableIDs)
            {
                if (!idToMarkerMap.TryGetValue(id, out SocketableArrowMarker marker))
                {
                    Debug.LogError($"Can't find marker for socketable id: {id}");
                    continue;
                }

                trackedMarkers.Add(marker);
                marker.Arrow.SetActive(true);
            }
        }

        private void ProcessDeactivate(DeactivateSocketToHolsterGuideEventData data)
        {
            SetActive(false);
        }

        private void SetActive(bool active)
        {
            if (IsActive == active)
            {
                return;
            }

            IsActive = active;

            if (IsActive)
            {
                SubscribeOnActive();
            }
            else if (!IsActive)
            {
                UnsubscribeOnInactive();
                holsterArrows.ForEach(a => a.SetActive(false));
                trackedMarkers.ForEach(m => m.Arrow.SetActive(false));
                trackedMarkers.Clear();
                State = null;
            }
        }

        private void SubscribeOnActive()
        {
            holsterToArrowMap.Keys.ForEach(h => h.Grabbed.AddListener(HandleHolsterGrabbed));
        }

        private void UnsubscribeOnInactive()
        {
            holsterToArrowMap.Keys.ForEach(h => h.Grabbed.RemoveListener(HandleHolsterGrabbed));
        }

        private void HandleHolsterGrabbed(HVRGrabberBase grabber, HVRGrabbable grabbable)
        {
            Holster holster = grabber as Holster;
            if (holster == null)
            {
                return;
            }

            holsterToArrowMap[holster].SetActive(false);
        }
    }
}*/
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/Socketing/SocketToHolsterGuideTracker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TetherEventsTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 34d1bf6e3bb2450eab7ca5639bfbc8b1
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Tethers;
using Systems.Objectives.EventData;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    public class TetherEventsTracker : EventDataTracker
    {
        protected override void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            switch (eventData)
            {
                case TetherActionEventData data:
                    ProcessTetherActionEventData(data);
                    break;
                default:
                    return;   
            }
        }
        
        #region Tethers

        private void ProcessTetherActionEventData(TetherActionEventData data)
        {
            switch (data.TetherAction)
            {
                case TetherActionEventData.Action.SetActive:
                    TetherController.Instance.SetTether(data.Tether, data.SetActive);
                    break;
                case TetherActionEventData.Action.Move:
                    if (data.UseOtherTetherPosition)
                    {
                        TetherController.Instance.MoveTether(data.Tether, data.OtherTetherToMoveTo, useTween: data.UseTween);
                    }
                    else
                    {
                        TetherController.Instance.MoveTether(data.Tether, data.MoveToTransform, useTween: data.UseTween);
                    }
                    break;
                case TetherActionEventData.Action.SummonToPlayer:
                    TetherController.Instance.SummonTetherToPlayer(data.Tether, data.KeepLocalPositioning, data.UseTween);
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TetherEventsTracker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TrackingEventBlocker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 629e56f41442b494d9dc0dc5ac9d70aa
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using Utilities.Blockers;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    public class TrackingEventBlocker : MonoBehaviour, IBlocker
    {
        public event Action<IBlocker, bool> OnBlockChanged;

        [Header("Listen to:")] [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string eventToBlock;

        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string eventToUnblock;

        [SerializeField] private bool blockedByDefault;

        public bool IsBlocked { get; private set; }

        private void Start()
        {
            IsBlocked = blockedByDefault;
            LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
        }

        private void OnDestroy()
        {
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }
        }

        private void HandleTrackingEvent(string eventID)
        {
            if (eventID == eventToBlock)
            {
                IsBlocked = true;
                OnBlockChanged?.Invoke(this, IsBlocked);
            }

            if (eventID == eventToUnblock)
            {
                IsBlocked = false;
                OnBlockChanged?.Invoke(this, IsBlocked);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TrackingEventBlocker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TrackingEventInteractableNotifier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cca48468b8d44efcbfa10783fc6f1c14
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Autohand;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    /// <summary>
    /// A shortcut class for reporting tracking events specifically tied to Auto-Hand
    /// (Like grabbing, releasing, socketing, etc)
    /// </summary>
    [TrackedReference]
    public class TrackingEventInteractableNotifier : TrackingEventNotifier
    {
        [Serializable]
        public enum EventType
        {
            None = 0,
            Grabbed,
            Released,
            SocketGrabbed,
            SocketReleased,
        }

        [HelpBox("Note: Grabbed/Released only work with grabbables")]
        [SerializeField] 
        private EventType eventType = EventType.None;

        private Grabbable grabbable;
        private PlacePoint socket;
        
        protected override void Awake()
        {
            base.Awake();
            grabbable = GetComponentInChildren<Grabbable>();
            socket = GetComponentInChildren<PlacePoint>();
            switch (eventType)
            {
                case EventType.None:
                    Debug.LogError("No HVR Tracking Event specified");
                    break;
                case EventType.Grabbed:
                    if (grabbable == null)
                    {
                        Debug.LogError("No attached Grabbable for the Grabbed event");
                        break;
                    }
                    grabbable.OnGrabEvent += HandleGrabbed;
                    break;
                case EventType.SocketGrabbed:
                    if (socket == null)
                    {
                        Debug.LogError("No attached Socket for the SocketGrabbed event");
                        break;
                    }
                    socket.OnPlaceEvent += HandleObjectPlaced;
                    break;
                case EventType.Released:
                    if (grabbable == null)
                    {
                        Debug.LogError("No attached Grabbable for the Released event");
                        break;
                    }
                    grabbable.OnReleaseEvent += HandleReleased;
                    break;
                case EventType.SocketReleased:
                    if (socket == null)
                    {
                        Debug.LogError("No attached Socket for the SocketReleased event");
                        break;
                    }
                    socket.OnRemoveEvent += HandleObjectRemoved;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }


        protected override void OnDestroy()
        {
            base.OnDestroy();
            switch (eventType)
            {
                case EventType.None:
                    break;
                case EventType.Grabbed:
                    if (grabbable == null)
                    {
                        break;
                    }
                    grabbable.OnGrabEvent -= HandleGrabbed;
                    break;
                case EventType.SocketGrabbed:
                    if (socket == null)
                    {
                        break;
                    }
                    socket.OnPlaceEvent -= HandleObjectPlaced;
                    break;
                case EventType.Released:
                    if (grabbable == null)
                    {
                        break;
                    }
                    grabbable.OnReleaseEvent -= HandleReleased;
                    break;
                case EventType.SocketReleased:
                    if (socket == null)
                    {
                        break;
                    }
                    socket.OnRemoveEvent -= HandleObjectRemoved;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        private void HandleReleased(Hand hand, Grabbable _)
        {
            BroadcastEvent();
        }

        private void HandleGrabbed(Hand hand, Grabbable _)
        {
            BroadcastEvent();
        }
        
        private void HandleObjectPlaced(PlacePoint point, Grabbable _)
        {
            BroadcastEvent();
        }
        
        private void HandleObjectRemoved(PlacePoint point, Grabbable _)
        {
            BroadcastEvent();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TrackingEventInteractableNotifier.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TrackingEventListener.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 496344f23fd493b4f82420372d26e521
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using UnityEngine.Serialization;

// Override this for scripts that require event tracking.
namespace Ldx.Framework.Systems.Objectives.Tracking
{
    public class TrackingEventListener : MonoBehaviour
    {
        [FormerlySerializedAs("listenForEvent")]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField]
        private string targetEvent;
        public string TargetEvent => targetEvent;

        private void Start()
        {
            LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
        }

        protected void OnDestroy()
        {
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }
        }
        
        private void HandleTrackingEvent(string id)
        {
            if (targetEvent == id)
            {
                ProcessTrackingEvent();
            }
        }

        protected virtual void ProcessTrackingEvent() { }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TrackingEventListener.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TrackingEventNotifier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 400610772d5349efa831b4cf02ee8979
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Logging;
using UnityEngine;
using Debug = Ldx.Framework.Utilities.Logging.Debug;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    /// <summary>
    /// Allows you to select an event, then broadcast it to the tracking manager when needed
    /// Inherit from this or reference it in your script
    /// Tracked by the tracking manager in editor
    /// </summary>
    [TrackedReference]
    public class TrackingEventNotifier : MonoBehaviour
    {
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] 
        private string eventToBroadcast;
        public string EventToBroadcastID => eventToBroadcast;

        [SerializeField]
        protected bool broadcastTrackingEventOnce;
        [SerializeField]
        protected bool broadcastOnEnable;

        protected bool didBroadcast;

        protected virtual void Awake()
        {
            ScenarioManager.OnLoadingFinished += HandleLoadingFinished;
        }

        private void OnEnable()
        {
            if (broadcastOnEnable)
            {
                BroadcastEvent();
            }
        }

        protected virtual void OnDestroy()
        {
            ScenarioManager.OnLoadingFinished -= HandleLoadingFinished;
        }
        
        /// <summary>
        /// Broadcasts the event
        /// </summary>
        public virtual void BroadcastEvent()
        {
            if (didBroadcast && broadcastTrackingEventOnce)
            {
                return;
            }
            if (string.IsNullOrEmpty(eventToBroadcast))
            {
                return;
            }
            
            LdxTrackingManager.Instance.BroadcastTrackingEvent(eventToBroadcast);
            didBroadcast = true;
        }

        public virtual void BroadcastEvent(string id)
        {
            if (didBroadcast && broadcastTrackingEventOnce)
            {
                return;
            }
            
            LdxTrackingManager.Instance.BroadcastTrackingEvent(id);
            didBroadcast = true;
        }
        
        private void HandleLoadingFinished(ScenarioManager scenarioManager)
        {
            ResetTracking();
        }

        private void ResetTracking()
        {
            didBroadcast = false;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TrackingEventNotifier.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TrackingFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9d0d74ac67cc4e92808cd764a7326994
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    /// <summary>
    /// Base class for tracking features that hook into the tracking manager
    /// </summary>
    [TrackedReference]
    public abstract class TrackingFeature : MonoBehaviour
    {
        public event Action<TrackingFeature> OnCompleted;
        public event Action<TrackingFeature> OnFailed;

        [IDSelection(LdxIdSettings.IdType.TrackingFeature)]
        [SerializeField] 
        private string trackingFeatureId;
        public string TrackingFeatureID => trackingFeatureId;
        
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] 
        private string completedTrackingEvent;
        public string CompletedTrackingEvent => completedTrackingEvent;
        
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] 
        private string failedTrackingEvent;
        public string FailedTrackingEvent => failedTrackingEvent;

        protected bool isTracking;
        public bool IsTracking => isTracking;
        
        protected virtual void OnDestroy()
        {
            StopTracking();
        }
        
        public virtual void StartTracking(TrackingFeatureEventData eventData)
        {
            isTracking = true;
        }

        public virtual void StopTracking()
        {
            isTracking = false;
        }

        public virtual void BroadcastCompleted()
        {
            if (!String.IsNullOrEmpty(CompletedTrackingEvent))
            {
                LdxTrackingManager.Instance.BroadcastTrackingEvent(CompletedTrackingEvent);
            }
            OnCompleted?.Invoke(this);
        }

        public virtual void BroadcastFailed()
        {
            if (!String.IsNullOrEmpty(FailedTrackingEvent))
            {
                LdxTrackingManager.Instance.BroadcastTrackingEvent(FailedTrackingEvent);
            }
            OnFailed?.Invoke(this);
        }

        public virtual void NotifyOfTrackingEvent(string id)
        {
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TrackingFeature.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TrackingKeyController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b3274c46e407467ab732bc6170539eee
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    [SingletonSpawnable(requiresScenario:true)]
    public class TrackingKeyController : Singleton<TrackingKeyController>
    {
        private const string TRACKER_KEY_PREFIX = "TRACKER_KEY_";
        
        private static Dictionary<string, bool> staticIdToValueMap = new Dictionary<string, bool>();
        
        private Dictionary<string, bool> idToValueMap = new Dictionary<string, bool>();
        
        protected override void Awake()
        {
            base.Awake();
            InitDictionary();
            LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
        }

        private void OnDestroy()
        {
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
            }
        }

        public void SetKeyValue(string id, bool value)
        {
            if (!idToValueMap.ContainsKey(id))
            {
                idToValueMap.Add(id, value);
                Debug.LogError($"The key ID {id} couldn't be found in the map, setting anyway");
                return;
            }

            idToValueMap[id] = value;
        }
        
        private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData objectiveEventData)
        {
            if (objectiveEventData is SetKeyEventData data)
            {
                if (data.IsStatic)
                {
                    SetStaticKeyValue(data.KeyToSet, data.Value);
                }
                else
                {
                    ProcessKeyEventData(data);
                }
            }
            else if (objectiveEventData is TriggerEventBasedOnKeyEventData eventData)
            {
                ProcessTriggerEventBasedOnKey(eventData);
            }
        }

        private void ProcessTriggerEventBasedOnKey(TriggerEventBasedOnKeyEventData data)
        {
            bool keyValue = data.IsStatic ? GetStaticKeyValue(data.KeyToCheck).GetValueOrDefault() : GetKeyValue(data.KeyToCheck).GetValueOrDefault();
            LdxTrackingManager.Instance.BroadcastTrackingEvent(keyValue
                ? data.EventToTriggerOnTrue
                : data.EventToTriggerOnFalse);
        }

        private void ProcessKeyEventData(SetKeyEventData eventData)
        {
            string id = eventData.KeyToSet;
            if (!idToValueMap.ContainsKey(id))
            {
                idToValueMap.Add(eventData.KeyToSet, GetPlayerPrefsKeyValueOrDefault(id));
                Debug.LogError($"The key ID {id} couldn't be found in the map, setting anyway");
            }

            idToValueMap[id] = eventData.Value;
            if (eventData.SaveToPlayerPrefs)
            {
                SetPlayerPrefsKeyValue(id, eventData.Value);
            }
        }

        private void InitDictionary()
        {
            foreach (IDInfo info in LdxIdSettings.GetCompoundIDList(LdxIdSettings.IdType.Key))
            {
                if (idToValueMap.ContainsKey(info.ID))
                {
                    Debug.LogError($"Found duplicate in key id settings: {info.ID} - {info.Description}");
                    continue;
                }

                bool value = GetPlayerPrefsKeyValueOrDefault(info.ID);
                idToValueMap.Add(info.ID, value);
                staticIdToValueMap.TryAdd(info.ID, false);
            }
        }

        public bool? GetKeyValue(string id)
        {
            if (!idToValueMap.ContainsKey(id))
            {
                Debug.LogError($"Can't find key with id {id}");
                return null;
            }

            return idToValueMap[id];
        }

        private static void SetPlayerPrefsKeyValue(string id, bool value)
        {
            PlayerPrefs.SetInt(GetPlayerPrefsKey(id), value? 1 : 0);
        }
        
        private static bool GetPlayerPrefsKeyValueOrDefault(string id)
        {
            return PlayerPrefs.GetInt(GetPlayerPrefsKey(id), 0) == 1;
        }
        
        public static string GetPlayerPrefsKey(string id)
        {
            return TRACKER_KEY_PREFIX + id;
        }

        #region Static
        
        public static void SetStaticKeyValue(string id, bool value)
        {
            if (staticIdToValueMap.TryAdd(id, value))
            {
                Debug.LogError($"The static key ID {id} couldn't be found in the static map, setting anyway");
                return;
            }

            staticIdToValueMap[id] = value;
        }

        public static bool? GetStaticKeyValue(string id)
        {
            if (!staticIdToValueMap.TryGetValue(id, out bool value))
            {
                Debug.LogError($"Can't find static key with id {id}");
                return null;
            }

            return value;
        }

        #endregion
        
#if UNITY_EDITOR
        [InitializeOnEnterPlayMode]
        private static void EDITOR_ClearStaticMapOnEnterPlayMode()
        {
            staticIdToValueMap?.Clear();
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TrackingKeyController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TrackingKeySetter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a9ad0e9264144067957766159c893ba8
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    public class TrackingKeySetter : MonoBehaviour
    {
        [IDSelection(LdxIdSettings.IdType.Key)] 
        [SerializeField]
        private string key;

        [SerializeField]
        protected bool value;

        public void SetKey(bool newValue)
        {
            TrackingKeyController.Instance.SetKeyValue(key, newValue);
        }
        
        public void SetKey(string keyValue, bool newValue)
        {
            TrackingKeyController.Instance.SetKeyValue(keyValue, newValue);
        }

        public void SetKey()
        {
            SetKey(value);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TrackingKeySetter.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TransformEventsTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7c258ea9eea848dabf659daf2bf76b4b
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.Player;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    /// <summary>
    /// Handles tracking for transform-related objective event data 
    /// </summary>
    public class TransformEventsTracker : EventDataTracker
    {
        protected override void HandleObjectiveEvent(IObjective objective, ObjectiveEventData objectiveEventData)
        {
            switch (objectiveEventData)
            {
                case MoveTargetToPositionEventData moveTargetToPositionEventData:
                    ProcessMoveTargetToPosition(moveTargetToPositionEventData);
                    break;
                case PlaceTargetInFrontOfPlayerWaistEventData placeTargetInFrontOfPlayerWaistEventData:
                    ProcessPlaceTargetInFrontOfPlayerWaist(placeTargetInFrontOfPlayerWaistEventData);
                    break;
            }
        }
        
        private void ProcessMoveTargetToPosition(MoveTargetToPositionEventData data)
        {
            Transform toMove = LdxReferenceIDTracker.Instance.GetTransform(data.TransformToMove);
            Transform destinationTransform = LdxReferenceIDTracker.Instance.GetTransform(data.DestinationTransform);
            
            if (toMove == null || destinationTransform == null)
            {
                Debug.LogError($"Couldn't move transform due to one of the ids missing ({data.TransformToMove}, {data.DestinationTransform})");
                return;
            }

            toMove.position = destinationTransform.position;
            toMove.rotation = destinationTransform.rotation;
        }

        private void ProcessPlaceTargetInFrontOfPlayerWaist(PlaceTargetInFrontOfPlayerWaistEventData data)
        {
            Transform target = LdxReferenceIDTracker.Instance.GetTransform(data.Target);
            if (target == null)
            {
                Debug.LogError($"Couldn't move transform due to the target id missing ({data.Target}))");
                return;
            }

            Vector3 offset = data.Offset;
            Vector3 playerPos = PlayerController.Instance.GetPlayerPosition;
            Vector3 waistDirection = PlayerController.Instance.GetPlayerForward();
            
           target.position = playerPos + waistDirection * offset.z + Vector3.right * offset.x + Vector3.up * offset.y;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/TransformEventsTracker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/UIEventsTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5ba07ef5445f47db9bb9a70f7b289c30
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Threading;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Features.Highlighting;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.UI;
using Ldx.Framework.Utilities.Extensions;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    public class UIEventsTracker : EventDataTracker
    {
        public static event Action<DialogParameters> OnAnyQuestionShowRequest;
        public static event Action OnAnyQuestionHideRequest;
        public event Action<ObjectiveEventData> OnReceivedTutorialEventData;
        
        private Dictionary<IDialogEventData, List<string>> dataToSuccessEventsMap =
            new Dictionary<IDialogEventData, List<string>>();
        private LdxTrackingManager TrackingManager => LdxTrackingManager.Instance;
        private LdxReferenceIDTracker ReferenceIDTracker => LdxReferenceIDTracker.Instance;
        private IDialogEventData CurrentDialogEventData { get; set; }
        
        private DialogEventData CurrentDialogData { get; set; }
        private int? dialogIndex;
        private DialogEventData.DialogInfo CurrentDialog => CurrentDialogData.Dialogs[dialogIndex.Value];
        private bool IsProcessingDialogList => CurrentDialogData != null;
        
        private SoundInstance soundInstance;

        private CancellationTokenSource sceneChangeCts;

        private Dictionary<UIController.WindowType, List<string>> windowTypeEventOnOpen = new();
        private Dictionary<UIController.WindowType, List<string>> windowTypeEventOnClose = new();

        protected override void Start()
        {
            base.Start();
            DialogueWindow.OnAnyQuestionAnswered += HandleAnyQuestionAnswered;
            UIController.OnAnyWindowTypeOpenClosed += HandleAnyWindowTypeOpenClosed;
            ScenarioManager.OnLoadingStarted += HandleStartLoading;
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
            DialogueWindow.OnAnyQuestionAnswered -= HandleAnyQuestionAnswered;
            
            if (ObjectiveSystem.IsValid)
            {
                ObjectiveSystem.Instance.OnAnyObjectiveComplete -= HandleAnyObjectiveComplete;
            }
            
            UIController.OnAnyWindowTypeOpenClosed -= HandleAnyWindowTypeOpenClosed;
            ScenarioManager.OnLoadingStarted -= HandleStartLoading;
        }

        private void HandleAnyQuestionAnswered(DialogueWindow dialogueWindow, string dialogId, string answerText, bool isCorrect)
        {
            HandleAnswer(dialogId, isCorrect,false);
        }
        
        private void HandleAnswer(string dialogId, bool isRightAnswer, bool forceSuccessEvents)
        {
            if (IsProcessingDialogList)
            {
                answerDialogList();
            }
            else
            {
                answerSingleDialog();
            }

            void answerDialogList()
            {
                soundInstance?.StopFadeOutAndRelease();
                
                if (isRightAnswer)
                {
                    if (dialogIndex.Value >= CurrentDialogData.Dialogs.Count - 1)
                    {
                        CompleteDialog(true);
                        return;
                    }
                    DisplayNextOrFirstDialog();
                }
                else
                {
                    CompleteDialog(false);
                }
            }

            void answerSingleDialog()
            {
                if (CurrentDialogEventData != null && dataToSuccessEventsMap.ContainsKey(CurrentDialogEventData))
                {
                    if (forceSuccessEvents)
                    {
                       List<string> list = dataToSuccessEventsMap[CurrentDialogEventData];
                       foreach (string e in list)
                       {
                           TrackingManager.BroadcastTrackingEvent(e);
                       }
                    }
                    dataToSuccessEventsMap.Remove(CurrentDialogEventData);
                }

                soundInstance?.StopFadeOutAndRelease();
                    
                //TODO: localization Changes
                /*if (CurrentDialogEventData is IPlayAudioEventData audioEventData)
                    {
                        foreach (LocalizedAudioClip audioClip in audioEventData.AudioClips)
                        {
                            foreach (AudioClip clip in audioClip.AudioClips)
                            {
                                soundInstance.StopAdditiveMonoClip(clip);
                            }
                        }
                    }*/

                CompleteDialog(isRightAnswer);
            }
        }
        
        protected override void HandleTrackingReset(LdxTrackingManager trackingManager)
        {
            base.HandleTrackingReset(trackingManager);
            dataToSuccessEventsMap.Clear();
        }

        private void CompleteDialog(bool isRightAnswer)
        {
            if (CurrentDialogEventData == null)
            {
                return;
            }
            string id = CurrentDialogEventData.DialogID ?? "";
            
            CurrentDialogEventData = null;
            ObjectHighlighterController.SetDialogBlocking(false);
            TrackingManager.BroadcastDialogComplete(id, isRightAnswer);
        }

        protected override void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            switch (eventData)
            {
                case DialogEventData data:
                    CurrentDialogEventData = data;
                    ProcessDialogData(data);

                    if (data is TutorialDialogEventData tutorialData)
                    {
                        OnReceivedTutorialEventData?.Invoke(tutorialData);
                    }
                    break;
                case CloseDialogEventData:
                    CloseCurrentDialog();
                    break;
                case ChangeWindowPositionModeEventData data:
                    ProcessChangeWindowPositionModeEventData(data);
                    break;
                case OverlayActionEventData data:
                    switch (data.OverlayAction)
                    {
                        case OverlayActionEventData.Action.FadeIn:
                            UIController.Instance.FadeInScreen();
                            break;
                        case OverlayActionEventData.Action.FadeOut:
                            UIController.Instance.FadeOutScreen();
                            break;
                        default:
                            throw new ArgumentOutOfRangeException();
                    }
                    break;
                case TrackUIWindowOpenCloseEventData data:
                    ProcessTrackUIWindowOpenCloseEventData(data);
                    break;
                default:
                    return;
            }
        }

        private void HandleAnyObjectiveComplete(ObjectiveSystem system, BaseObjective baseObjective)
        {
            BroadcastQuestionHideRequest();
        }
        
        protected override void HandleAnyObjectiveComplete(IObjective obj)
        {
            base.HandleAnyObjectiveComplete(obj);
            BroadcastQuestionHideRequest();
        }

        private void DisplaySingleDialog(DialogParameters parameters, bool broadcastQuestionHideRequest = false)
        {
            OnAnyQuestionShowRequest?.Invoke(parameters);
            
            if (parameters.CustomTime is > 0)
            {
                sceneChangeCts?.SafeCancelAndDispose();
                sceneChangeCts = new CancellationTokenSource();
                closeAfterTimeAsync(CurrentDialogEventData, broadcastQuestionHideRequest).Forget();
            }
            
            async UniTask closeAfterTimeAsync(IDialogEventData dialogEventData, bool broadcastHide)
            {
                await UniTask.Delay(parameters.CustomTime.Value.ToMilliseconds(), cancellationToken: sceneChangeCts.Token);
                if (sceneChangeCts.IsCancellationRequested)
                    return;
                if (CurrentDialogEventData == dialogEventData)
                {
                    HandleAnswer(dialogEventData.DialogID, true, true);
                    if (broadcastHide)
                    {
                        BroadcastQuestionHideRequest();
                    }
                }
            }
        }

        private void CloseCurrentDialog()
        {
            if (CurrentDialogEventData != null)
            {
                HandleAnswer(CurrentDialogEventData.DialogID, true, true);
                BroadcastQuestionHideRequest();
            }
        }

        private void BroadcastQuestionHideRequest()
        {
            OnAnyQuestionHideRequest?.Invoke();
        }

        private void ProcessTrackUIWindowOpenCloseEventData(TrackUIWindowOpenCloseEventData data)
        {
            if (data.ActionToTrack == TrackUIWindowOpenCloseEventData.Action.Open)
            {
                if (!windowTypeEventOnOpen.ContainsKey(data.WindowType))
                {
                    windowTypeEventOnOpen.Add(data.WindowType, new List<string>());
                }
                
                windowTypeEventOnOpen[data.WindowType].Add(data.InvokeTrackingEventOnSuccess);
            }
            else
            {
                if (!windowTypeEventOnClose.ContainsKey(data.WindowType))
                {
                    windowTypeEventOnClose.Add(data.WindowType, new List<string>());
                }
                
                windowTypeEventOnClose[data.WindowType].Add(data.InvokeTrackingEventOnSuccess);
            }
        }
        
        private void HandleAnyWindowTypeOpenClosed(UIController.WindowType windowType, bool isOpen)
        {
            if (isOpen)
            {
                if (windowTypeEventOnOpen.TryGetValue(windowType, out List<string> events))
                {
                    foreach (string e in events)
                    {
                        LdxTrackingManager.Instance.BroadcastTrackingEvent(e);
                    }
                    
                    windowTypeEventOnOpen.Remove(windowType);
                }
            }
            else
            {
                if (windowTypeEventOnClose.TryGetValue(windowType, out List<string> events))
                {
                    foreach (string e in events)
                    {
                        LdxTrackingManager.Instance.BroadcastTrackingEvent(e);
                    }
                    
                    windowTypeEventOnClose.Remove(windowType);
                }
            }
        }

        private void HandleStartLoading(ScenarioLoadingParameters parameters)
        {
            sceneChangeCts?.SafeCancelAndDispose();
        }

        #region Dialog Processing

        private void ProcessDialogData(DialogEventData data)
        {
            dialogIndex = null;
            CurrentDialogEventData = data;
            CurrentDialogData = data;
            DisplayNextOrFirstDialog();
        }

        private void DisplayNextOrFirstDialog()
        {
            dialogIndex = dialogIndex == null ? 0 : dialogIndex.Value + 1;
            bool hasNextDialog = dialogIndex.Value < CurrentDialogData.Dialogs.Count - 1;
            DialogParameters parameters = new(CurrentDialog, CurrentDialogData.DialogID);
            ObjectHighlighterController.SetDialogBlocking(CurrentDialog.EventOptions.BlockHighlightingUntilCompleted);
            DisplaySingleDialog(parameters, !hasNextDialog);

            if (soundInstance is { IsPlaying: true })
            {
                soundInstance.StopFadeOutAndRelease();
            }
            
            soundInstance = Audio.PlayEventDataAudio(CurrentDialog);
            soundInstance?.Release();
        }

        #endregion

        #region Repositioning

        private void ProcessChangeWindowPositionModeEventData(ChangeWindowPositionModeEventData eventData)
        {
            UIController.Instance.SetUIElementPositionMode(eventData.WindowType, eventData.PositionModeToSet);
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/Tracking/UIEventsTracker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/WorldObjective/IStepController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 833d12b890c942a9bc6e72da1d5ee358
# ASMDEF: ldx.framework.runtime.dll
# ---
namespace Ldx.Framework.Systems.Objectives.WorldObjective
{
    /// <summary>
    /// Implement this with a controller for your objective sequence and assign it
    /// to a WorldObjectiveStep to define what activating/deactivating the objective means
    /// for lifecycle control 
    /// </summary>
    public interface IStepController
    {
        void Activate();
        void Deactivate(bool isInitialization = false);
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/WorldObjective/IStepController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/WorldObjective/WorldObjectiveStep.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5c86de80322f4068b694f403772c65fa
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.WorldObjective
{
    public class WorldObjectiveStep : MonoBehaviour
    {
        [IDSelection(LdxIdSettings.IdType.TrackingFeature)] [SerializeField]
        private List<string> stepIds = new();

        [RequireInterface(typeof(IStepController))]
        [SerializeField] private MonoBehaviour stepController;

        [SerializeField][ShowIf(nameof(stepController), Op.Equals, null)]
        private bool toggleGameObjectIfNoController = true;

        private IStepController StepController => stepController as IStepController;

        private void Awake()
        {
            SetActive(false);
        }

        public bool Contains(string id)
        {
            return stepIds.Contains(id);
        }

        public void SetActive(bool active, bool initialization = false)
        {
            if (StepController == null)
            {
                if (toggleGameObjectIfNoController)
                {
                    gameObject.SetActive(active);
                }
              
                return;
            }
            
            if (active)
            {
                StepController?.Activate();
            }
            else
            {
                StepController?.Deactivate(isInitialization: initialization);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/WorldObjective/WorldObjectiveStep.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/WorldObjective/WorldObjectiveStepManager.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 02d75b43eee74decae757773f109e435
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.Objectives.EventData;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.WorldObjective
{
    public class WorldObjectiveStepManager : MonoBehaviour, ISaveSceneListener
    {
        [SerializeField] private List<WorldObjectiveStep> objectiveSteps = new();

        public void OnSceneSaving()
        {
            objectiveSteps = GetComponentsInChildren<WorldObjectiveStep>(true).ToList();
        }

        private IEnumerator Start()
        {
            yield return new WaitUntil(() => LdxTrackingManager.IsValid);
            
            LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
            ObjectiveSystem.Instance.OnAnyObjectiveBegin += HandleAnyObjectiveBegin;
            
            objectiveSteps.ForEach(s => s.SetActive(false, initialization: true));
        }

        private void OnDestroy()
        {
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
            }
            
            if (ObjectiveSystem.IsValid)
            {
                ObjectiveSystem.Instance.OnAnyObjectiveBegin -= HandleAnyObjectiveBegin;
            }
        }
        
        /// <summary>
        /// Handles the new, direct trigger from an objective starting.
        /// </summary>
        private void HandleAnyObjectiveBegin(ObjectiveSystem system, BaseObjective objective)
        {
            if (!string.IsNullOrEmpty(objective.WorldObjectiveStepId))
            {
                SetActiveStep(objective.WorldObjectiveStepId);
            }
        }

        private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            if (eventData is not SetWorldObjectiveStepEventData setWorldObjective)
            {
                return;
            }

            SetActiveStep(setWorldObjective.StepId);
        }
        
        /// <summary>
        /// Activates the target step and deactivates all others.
        /// </summary>
        private void SetActiveStep(string id)
        {
            if (string.IsNullOrEmpty(id)) return;
            
            foreach (WorldObjectiveStep step in objectiveSteps)
            {
                bool isTargetStep = step.Contains(id);
                step.SetActive(isTargetStep);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Objectives/WorldObjective/WorldObjectiveStepManager.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/Hands/ApplyHandPoseBehaviour.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cb43702c09014e7aa57e91f499c390e0
# ASMDEF: ldx.framework.runtime.dll
# ---
using Autohand;
using UnityEngine;

namespace Systems.Player.Hands
{
    public interface IHandPoseDriver
    {
        void SetLayerPose(int layerIndex, HandPoseScriptable poseAsset);
    }
    public class ApplyHandPoseBehaviour : StateMachineBehaviour
    {
        [Tooltip("The pose asset to apply when this state is active.")]
        public HandPoseScriptable poseAsset;

        private IHandPoseDriver driver;

        public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
        {
            driver ??= animator.GetComponent<IHandPoseDriver>();
        }
        
        public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
        {
            if (driver != null && poseAsset != null)
            {
                // Every frame, tell the driver which pose this layer wants to be in.
                // The driver will handle the blending and application.
                driver.SetLayerPose(layerIndex, poseAsset);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/Hands/ApplyHandPoseBehaviour.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/Hands/HandFeedback.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 85315dd5faec42598ea6604776258bc8
# ASMDEF: ldx.framework.runtime.dll
# ---
using Autohand;
using Ldx.Framework.Systems.AudioSystem;
using UnityEngine;

namespace Systems.Player.Hands
{
    [RequireComponent(typeof(Hand))]
    public class HandFeedback : MonoBehaviour
    {
        [SerializeField] private Hand hand;

        private void OnValidate()
        {
            if (hand == null)
            {
                hand = GetComponent<Hand>();
            }
        }

        private void Start()
        {
            hand.OnBeforeGrabbed += HandleBeforeGrabbed;
            hand.OnGrabbed += HandleGrabbed;
            hand.OnReleased += HandleReleased;
            hand.OnForcedRelease += HandleForceReleased;
            hand.OnSqueezed += HandleSqueezed;
            hand.OnUnsqueezed += HandleUnsqueezed;
            hand.highlighter.OnHighlight += HandleHighlight;
            hand.highlighter.OnStopHighlight += HandleStopHighlight;
        }

        private void OnDestroy() 
        {
            hand.OnBeforeGrabbed -= HandleBeforeGrabbed;
            hand.OnGrabbed -= HandleGrabbed;
            hand.OnReleased -= HandleReleased;
            hand.OnForcedRelease -= HandleForceReleased;
            hand.OnSqueezed -= HandleSqueezed;
            hand.OnUnsqueezed -= HandleUnsqueezed;
            hand.highlighter.OnHighlight -= HandleHighlight;
            hand.highlighter.OnStopHighlight -= HandleStopHighlight;
        }

        private void HandleBeforeGrabbed(Hand hand, Grabbable grab)
        {
            hand.PlayHapticVibration(0.1f);
        }

        private void HandleGrabbed(Hand hand, Grabbable grab)
        {
            if (!grab.TryGetComponent(out AudioEmitter _))
            {
                Audio.PlayOneShot(AudioGlobalSettings.HandGrabbedSound, grab.transform);
            }
        }

        private void HandleReleased(Hand hand, Grabbable grab)
        {
            if (!grab.TryGetComponent(out AudioEmitter _))
            {
                Audio.PlayOneShot(AudioGlobalSettings.HandReleasedSound, grab.transform);
            }
        }

        private void HandleSqueezed(Hand hand, Grabbable grab) { }

        private void HandleUnsqueezed(Hand hand, Grabbable grab) { }
        
        private void HandleHighlight(Hand hand, Grabbable grab) { }

        private void HandleStopHighlight(Hand hand, Grabbable grab) { }

        private void HandleForceReleased(Hand hand, Grabbable grab) { }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/Hands/HandFeedback.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/Hands/HandsController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c21c6c34cd7a1a4469a13c8303a54f7a
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Autohand;
using Ldx.Framework.Features.GhostController;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.Player.Input;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;
using Debug = Ldx.Framework.Utilities.Logging.Debug;

namespace Ldx.Framework.Systems.Player.Hands
{
	public enum HandSide
	{
		Left = 0,
		Right = 1,
	}
	
	public class HandsController : MonoBehaviour
	{
		[Serializable]
		public class HandReferences
		{
			public Hand hand;
			public Transform teleportAimer;
			public HandProjector handProjector;
			public GhostController ghostController;
			public List<SkinnedMeshRenderer> meshRenderers = new();
			[NonSerialized]
			public Material originalMaterial;
			[NonSerialized]
			public Collider[] colliders;

			public void OnValidate()
			{
				if (hand != null)
				{
					meshRenderers = hand.GetComponentsInChildren<SkinnedMeshRenderer>().ToList();
				}
			}
		}

		[SerializeField] private SerializableDictionary<HandSide, HandReferences> handReferencesMap = new();

		[Header("Input ")]
		[SerializeField] [RequireInterface(typeof(IInputModule))]
		private List<MonoBehaviour> modules = new();
		
		public Hand LeftHand { get; private set; }
		public Hand RightHand { get; private set; }
		
		private IInputModule currentInputModule;
		private readonly Dictionary<IInputModule, GameObject> inputModulesMap = new();
		private Dictionary<Hand, Transform> handAimerByHand = new();

		private void OnValidate()
		{
			foreach (HandReferences handReferences in handReferencesMap.Values)
			{
				handReferences.OnValidate();
			}
		}

		private void Awake()
		{
			InitHandReferences();
			InitInputModulesSet();
			if (currentInputModule == null)
			{
				SetActiveInputModule<ControllersInputModule>();
			}
		}

		private void Start()
		{
			ScenarioManager.Instance.OnUnloadingScenarioOrLobby += HandleUnloadingScenarioOrLobby;
			ScenarioManager.Instance.OnScenarioStarted += HandleScenarioStarted;
		}

		private void OnDestroy()
		{
			if (LdxTrackingManager.IsValid)
			{
				LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
			}

			if (ScenarioManager.IsValid)
			{
				ScenarioManager.Instance.OnUnloadingScenarioOrLobby += HandleUnloadingScenarioOrLobby;
				ScenarioManager.Instance.OnScenarioStarted -= HandleScenarioStarted;
			}
		}

		public T GetInputModule<T>() where T : class, IInputModule
		{
			if (inputModulesMap.Count < 1)
			{
				InitInputModulesSet();
			}
			
			return inputModulesMap.FirstOrDefault(p => p.Key is T) as T;
		}

		public void SetActiveInputModule<T>() where T : class, IInputModule
		{
			if (inputModulesMap.Count < 1)
			{
				InitInputModulesSet();
			}
			
			foreach ((IInputModule module, GameObject go) in inputModulesMap)
			{
				bool rightModule = module is T;
				go.SetActive(rightModule);
				if (rightModule)
				{
					currentInputModule = module;
				}
			}
			
			currentInputModule.Initialize(handReferencesMap);
		}

		private void InitHandReferences()
		{
			handAimerByHand.Clear();
			foreach (KeyValuePair<HandSide, HandReferences> pair in handReferencesMap)
			{
				if (pair.Key == HandSide.Left)
				{
					LeftHand = pair.Value.hand;
				}
				else
				{
					RightHand = pair.Value.hand;
				}
				
				handAimerByHand.Add(pair.Value.hand, pair.Value.teleportAimer);
				pair.Value.originalMaterial = PlayerController.Instance.HandsController.GetCurrentHandMaterial(pair.Key);
				pair.Value.colliders = pair.Value.hand.GetComponentsInChildren<Collider>();
			}	
		}
		
		private void InitInputModulesSet()
		{
			inputModulesMap.Clear();
			foreach (MonoBehaviour module in modules)
			{
				inputModulesMap.Add(module as IInputModule, module.gameObject);
			}
		}

		private void HandleUnloadingScenarioOrLobby(ScenarioManager scenarioManager)
		{
			ResetHandsMaterials();
			LeftHand?.ForceReleaseGrab();
			RightHand?.ForceReleaseGrab();
		}
		
		private void HandleScenarioStarted(ScenarioManager scrMgr, ScenarioDataType dType)
		{
			if (LdxTrackingManager.Instance != null)
			{
				LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
				LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
			}
		}
		
		public Hand GetHand(HandSide side)
		{
			if (handReferencesMap.TryGetValue(side, out HandReferences refs))
			{
				return refs.hand;
			}
			Debug.LogError($"No hand references configured for hand side: {side}");
			return null;
		}
		
		public Transform GetAimerForHand(Hand handInstance)
		{
			if (handAimerByHand.TryGetValue(handInstance, out Transform aimer))
			{
				return aimer;
			}
			
			Debug.LogWarning($"Could not find a matching aimer for the provided hand: {handInstance.name}");
			return null;
		}
		
		private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
		{
			switch (eventData)
			{
				case ForceGrabEventData data:
					ForceGrab(data);
					break;
				case SetHandMeshEnabled data:
					EnableHandsRenderers(data.Enabled);
					break;
			}
		}

		private void ForceGrab(ForceGrabEventData data)
		{
			Hand hand = GetHand(data.HandSide);
			Transform grabbableTransform = LdxReferenceIDTracker.Instance.GetTransform(data.GrabbableTransform);

			if (grabbableTransform == null)
				return;

			grabbableTransform.gameObject.SetActive(true);
			Grabbable grabbable = grabbableTransform.GetComponentInChildren<Grabbable>();

			if (grabbable != null)
			{
				if (grabbable.IsHeld())
				{
					grabbable.ForceHandsRelease();
					return;
				}

				if (data.AutoReleaseIfHolding)
					hand.ForceReleaseGrab();

				hand.ForceGrab(grabbable);

				if (!string.IsNullOrEmpty(data.PlaySound))
				{
					Audio.PlayOneShot(data.PlaySound);
				}
			}
			else
			{
				Debug.LogError($"Returning null on grabbable using ID {data.GrabbableTransform}");
			}
		}
		
		public void EnableHandsRenderers(bool setEnabled)
		{
			foreach (HandReferences refs in handReferencesMap.Values)
			{
				foreach (SkinnedMeshRenderer meshRenderer in refs.meshRenderers)
				{
					if(meshRenderer)
					{
						meshRenderer.enabled = setEnabled;
					}
				}
			}
		}

		public void EnableHandRenderer(HandSide side, bool setEnabled)
		{
			if (handReferencesMap.TryGetValue(side, out HandReferences refs))
			{
				foreach (SkinnedMeshRenderer meshRenderer in refs.meshRenderers)
				{
					if(meshRenderer) meshRenderer.enabled = setEnabled;
				}
			}
		}
		
		public void SetHandMaterial(HandSide handSide, Material material)
		{
			if (handReferencesMap.TryGetValue(handSide, out HandReferences refs))
			{
				foreach (SkinnedMeshRenderer meshRenderer in refs.meshRenderers)
				{
					if(meshRenderer)
					{
						meshRenderer.material = material;
					}
				}
			}
		}
		
		public void SetHandsMaterials(Material material)
		{
			foreach (HandReferences refs in handReferencesMap.Values)
			{
				foreach (SkinnedMeshRenderer meshRenderer in refs.meshRenderers)
				{
					if(meshRenderer)
					{
						meshRenderer.material = material;
					}
				}
			}
		}
		
		public Material GetCurrentHandMaterial(HandSide handSide)
		{
			if (handReferencesMap.TryGetValue(handSide, out HandReferences refs))
			{
				foreach (SkinnedMeshRenderer meshRenderer in refs.meshRenderers)
				{
					return meshRenderer.material;
				}
			}

			return null;
		}
		
		public Material GetOriginalHandMaterial(HandSide handSide)
		{
			if (handReferencesMap.TryGetValue(handSide, out HandReferences refs))
			{
				return refs.originalMaterial;
			}

			return null;
		}

		public void ResetHandsMaterials()
		{
			foreach (HandReferences refs in handReferencesMap.Values)
			{
				if (refs.originalMaterial == null)
				{
					continue;
				}
				
				foreach (SkinnedMeshRenderer meshRenderer in refs.meshRenderers)
				{
					if(meshRenderer)
					{
						meshRenderer.material = refs.originalMaterial;
					}
				}
			}
		}
		
		/// <summary>
		/// Enables or disables the physical colliders for both hands.
		/// This is used to prevent unwanted physics interactions during teleportation.
		/// </summary>
		/// <param name="setEnabled">True to enable colliders, false to disable.</param>
		public void ToggleHandColliders(bool setEnabled)
		{
			foreach (HandReferences handReferences in handReferencesMap.Values)
			{
				foreach (Collider col in handReferences.colliders)
				{
					if (col != null)
					{
						col.enabled = setEnabled;
					}
				}
			}
		}

		#region Projection

		public void DisableGripProjection()
		{
			EnableDisableGripProjection(false);
		}

		public void EnableGripProjection()
		{
			EnableDisableGripProjection(true);
		}

		private void EnableDisableGripProjection(bool enable)
		{
			foreach (HandReferences refs in handReferencesMap.Values)
			{
				if (refs.handProjector != null)
				{
					refs.handProjector.gameObject.SetActive(enable);
					if (refs.handProjector.useGrabTransition)
					{
						refs.handProjector.enabled = enable;
					}
				}
			}
		}
		
		#endregion

		#region Actions and Events

		public void VibrateHands(float amp = 1f, float duration = 1f)
		{
			foreach (HandReferences handReferences in handReferencesMap.Values)
			{
				if(handReferences.hand != null)
				{
					handReferences.hand.PlayHapticVibration(duration, amp);
				}
			}
		}
		
		public void VibrateHand(HandSide side, float amp = 1f, float duration = 1f)
		{
			VibrateHand(GetHand(side), amp, duration);
		}
		
		public void VibrateHand(Hand hand, float amp = 1f, float duration = 1f)
		{
			if(hand != null)
			{
				hand.PlayHapticVibration(duration, amp);
			}
		}
		
		#endregion

		#region Ghost controllers

		public GhostController GetGhostControllerByHandSide(HandSide handSide)
		{
			if (handReferencesMap.TryGetValue(handSide, out HandReferences refs))
			{
				return refs.ghostController;
			}

			return null;
		}

		#endregion

		public void ForceReleaseBothHands()
		{
			if(LeftHand) LeftHand.ForceReleaseGrab();
			if(RightHand) RightHand.ForceReleaseGrab();
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/Hands/HandsController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/Hands/HandVisualChangeZone.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 50968853aa89f8840bbf88e825a9abf4
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Autohand;
using DG.Tweening;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Systems.Player.Hands
{
    /// <summary>
    /// Creates a trigger zone that changes the visual material of the player's hands.
    /// It can be activated/deactivated by tracking events and supports two distinct modes for material swapping.
    /// </summary>
    [RequireComponent(typeof(HandTriggerAreaEvents))]
    public class HandVisualChangeZone : MonoBehaviour
    {
        [Space]
        [Header("Listen to:")]
        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string eventToActivate;
        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string eventToDeactivate;

        [Space]
        [SerializeField] private bool activateOnStart = true;
        
        [Header("References")]
        [SerializeField] private HandTriggerAreaEvents handTrigger;
        [SerializeField] private Collider triggerCollider;
        [SerializeField] private Renderer zoneRenderer;

        private enum MaterialChangeMode
        {
            [Tooltip("Default behavior: Hands change to a specified material upon entering the zone.")]
            ChangeOnEnter,
            [Tooltip("Inverted behavior: The zone sets a default material for hands when active. " +
                     "Entering the zone reverts them to their original material.")]
            RevertOnEnter
        }
        
        [Header("Material Change Settings")]
        [SerializeField] private MaterialChangeMode changeMode = MaterialChangeMode.ChangeOnEnter;
        [Tooltip("The material used for the visual effect. Its role depends on the selected 'Change Mode'.")]
        [SerializeField] private Material specifiedMaterial;

        [Space]
        [Header("Zone Visuals")]
        [Range(0f, 1f)]
        [SerializeField] private float opacityWhenHandInside;
        [SerializeField] private float tweenDuration;
        [SerializeField] private Ease tweenEase;
        
        [Space]
        [Header("Optimization")]
        [Tooltip("How many frames to wait between expensive polling checks in Update. Higher is more performant but less responsive to tracking glitches.")]
        [Range(1, 20)]
        [SerializeField] private int updateCheckInterval = 5;
        
        private Tween colorChangeTween;
        private float baseAlpha;
        private bool isCurrentlyActive;
        private readonly HashSet<Hand> handsInside = new();
        private readonly Dictionary<Hand, Material> originalHandMaterialsMap = new();
        private readonly List<Hand> allHandsInScene = new();
        
        private void OnValidate()
        {
            if (handTrigger == null)
            {
                handTrigger = GetComponent<HandTriggerAreaEvents>();
            }
            
            if (triggerCollider == null)
            {
                triggerCollider = GetComponent<Collider>();
            }

            if (zoneRenderer == null)
            {
                zoneRenderer = GetComponentInChildren<Renderer>();
            }
        }

        private void Start()
        {
            handTrigger.HandEnter.AddListener(HandleHandEntered);
            handTrigger.HandExit.AddListener(HandleHandExited);
            
            LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
            
            allHandsInScene.AddRange(PlayerController.IsValid
                ? new List<Hand>()
                {
                    PlayerController.Instance.HandsController.LeftHand,
                    PlayerController.Instance.HandsController.RightHand
                }
                : FindObjectsByType<Hand>(FindObjectsSortMode.None).ToList());
            
            if (activateOnStart)
            {
                Activate();
            }
            else
            {
                DoFade(0, () => gameObject.SetActive(false), 0);
            }
        }

        private void OnEnable()
        {
            Activate();
        }

        private void OnDisable()
        {
            Deactivate(false);
        }

        private void OnDestroy()
        {
            handTrigger.HandEnter.RemoveListener(HandleHandEntered);
            handTrigger.HandExit.RemoveListener(HandleHandExited);
            
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }
            
            if (isCurrentlyActive)
            {
                RevertAllHandMaterials();
            }
            
            colorChangeTween?.Kill();
        }

        private void Update()
        {
            if (!isCurrentlyActive || triggerCollider == null || !triggerCollider.enabled)
            {
                if (handsInside.Count > 0)
                {
                    foreach (Hand hand in handsInside.ToList())
                    {
                        ProcessHandExit(hand);
                    }
                }
                
                return;
            }
            
            // This polling check is a fallback for when trigger events might be missed (e.g., tracking loss).
            // We optimize it by only running it every N frames instead of every frame.
            if (Time.frameCount % updateCheckInterval != 0)
            {
                return;
            }
            
            foreach (Hand hand in allHandsInScene)
            {
                if (hand == null)
                {
                    continue;
                }

                bool isCurrentlyInZone = handsInside.Contains(hand);
                bool isPhysicallyInside = triggerCollider.bounds.Contains(hand.palmTransform.position);
                
                // Use hand.enabled as a generic check for tracking status.
                // This works for both controllers and hand tracking.
                bool handIsValid = hand.enabled;
                
                bool shouldBeInZone = handIsValid && isPhysicallyInside;

                if (shouldBeInZone && !isCurrentlyInZone)
                {
                    ProcessHandEnter(hand);
                }
                else if (!shouldBeInZone && isCurrentlyInZone)
                {
                    ProcessHandExit(hand);
                }
            }
        }

        /// <summary>
        /// Activates the visual change zone, making it visible and enabling its logic.
        /// </summary>
        private void Activate()
        {
            if (isCurrentlyActive)
            {
                return;
            }
            
            isCurrentlyActive = true;
            
            if (!gameObject.activeSelf)
            {
                gameObject.SetActive(true);
            }
            
            if(baseAlpha == 0)
                baseAlpha = zoneRenderer.material.color.a;
            DoFade(baseAlpha);
            
            if (changeMode == MaterialChangeMode.RevertOnEnter)
            {
                originalHandMaterialsMap.Clear();
                foreach (Hand hand in allHandsInScene)
                {
                    if (hand == null)
                    {
                        continue;
                    }
                    
                    HandSide handSide = hand.left ? HandSide.Left : HandSide.Right;
                    originalHandMaterialsMap[hand] = PlayerController.Instance.HandsController.GetOriginalHandMaterial(handSide);
                    SetHandMaterial(handSide, specifiedMaterial);
                }
            }
        }

        /// <summary>
        /// Deactivates the zone, hiding it and reverting all hands to their original state.
        /// </summary>
        /// <param name="disableObject">If true, the GameObject will be set to inactive after fading out.</param>
        private void Deactivate(bool disableObject = true)
        {
            if (!isCurrentlyActive)
            {
                return;
            }
            
            isCurrentlyActive = false;
            
            foreach (Hand hand in handsInside.ToList())
            {
                ProcessHandExit(hand);
            }
            
            RevertAllHandMaterials();
            handsInside.Clear();
            
            DoFade(0, disableObject ? () => gameObject.SetActive(false) : null);
        }
        
        /// <summary>
        /// Fades the zone's renderer to a target alpha value using DOTween.
        /// </summary>
        /// <param name="fadeValue">The target alpha value (0-1).</param>
        /// <param name="onComplete">An optional action to invoke when the tween completes.</param>
        /// <param name="durationOverride">An optional duration to use instead of the serialized tweenDuration.</param>
        private void DoFade(float fadeValue, Action onComplete = null, float? durationOverride = null)
        {
            colorChangeTween?.Kill();
            colorChangeTween = zoneRenderer.material.DOFade(fadeValue, durationOverride ?? tweenDuration)
                .SetEase(tweenEase).OnComplete(() => onComplete?.Invoke());
        }
        
        /// <summary>
        /// Handles incoming tracking events to activate or deactivate the zone.
        /// </summary>
        private void HandleTrackingEvent(string eventID)
        {
            if (eventID == eventToActivate)
            {
                Activate();
            }
            if (eventID == eventToDeactivate)
            {
                Deactivate();
            }
        }
        
        /// <summary>
        /// Callback for when a hand enters the trigger area.
        /// </summary>
        private void HandleHandEntered(Hand hand)
        {
            if (isCurrentlyActive)
            {
                ProcessHandEnter(hand);
            }
        }

        /// <summary>
        /// Callback for when a hand exits the trigger area.
        /// </summary>
        private void HandleHandExited(Hand hand)
        {
            if (isCurrentlyActive)
            {
                ProcessHandExit(hand);
            }
        }
        
        /// <summary>
        /// Processes the logic for a hand entering the zone, including material changes.
        /// </summary>
        private void ProcessHandEnter(Hand hand)
        {
            if (!handsInside.Add(hand))
            {
                return;
            }

            HandSide handSide = hand.left ? HandSide.Left : HandSide.Right;
            
            switch (changeMode)
            {
                case MaterialChangeMode.ChangeOnEnter:
                    if (!originalHandMaterialsMap.ContainsKey(hand) && PlayerController.IsValid)
                    {
                        originalHandMaterialsMap[hand] = PlayerController.Instance.HandsController.GetOriginalHandMaterial(handSide);
                    }
                    SetHandMaterial(handSide, specifiedMaterial);
                    break;
                
                case MaterialChangeMode.RevertOnEnter:
                    if (originalHandMaterialsMap.TryGetValue(hand, out Material originalMaterial))
                    {
                        SetHandMaterial(handSide, originalMaterial);
                    }
                    break;
            }
            
            if (handsInside.Count == 1)
            {
                DoFade(opacityWhenHandInside);
            }
        }

        /// <summary>
        /// Processes the logic for a hand exiting the zone, including material changes.
        /// </summary>
        private void ProcessHandExit(Hand hand)
        {
            if (!handsInside.Remove(hand))
            {
                return;
            }

            HandSide handSide = hand.left ? HandSide.Left : HandSide.Right;
            
            switch (changeMode)
            {
                case MaterialChangeMode.ChangeOnEnter:
                    if (originalHandMaterialsMap.TryGetValue(hand, out Material originalHandMaterial))
                    {
                        SetHandMaterial(handSide, originalHandMaterial);
                        originalHandMaterialsMap.Remove(hand);
                    }
                    break;
                
                case MaterialChangeMode.RevertOnEnter:
                    SetHandMaterial(handSide, specifiedMaterial);
                    break;
            }
            
            if (handsInside.Count < 1)
            {
                DoFade(baseAlpha);
            }
        }
        
        /// <summary>
        /// A wrapper to safely set the material on a hand via the PlayerController.
        /// </summary>
        private void SetHandMaterial(HandSide handSide, Material material)
        {
            if (!PlayerController.IsValid || material == null)
            {
                return;
            }

            PlayerController.Instance.HandsController.SetHandMaterial(handSide, material);
        }
        
        /// <summary>
        /// Forcefully restores the original, cached materials for all hands affected by this component.
        /// Clears the material cache afterward.
        /// </summary>
        private void RevertAllHandMaterials()
        {
            if (originalHandMaterialsMap.Count == 0) return;

            foreach ((Hand hand, Material originalMat) in originalHandMaterialsMap)
            {
                if (hand != null)
                {
                    SetHandMaterial(hand.left ? HandSide.Left : HandSide.Right, originalMat);
                }
            }
            
            originalHandMaterialsMap.Clear();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/Hands/HandVisualChangeZone.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/IdealogicalAutoHandPlayer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 93efb3e5306449c9b5adc3b05ff8edb5
# ASMDEF: ldx.framework.runtime.dll
# ---
using Autohand;
using UnityEngine;

namespace Ldx.Framework.Systems.Player
{
    public class IdealogicalAutoHandPlayer : AutoHandPlayer
    {
        private Collider headFollowerCollider;

        public override void Awake()
        {
            base.Awake();
            headFollowerCollider = headPhysicsFollower.GetComponent<Collider>();
        }

        /// <summary>
        /// Overrides the default SetPosition method to customize teleportation behavior.
        /// This version directly sets the tracking container's position to the player's new position
        /// and simplifies the target tracked position update. The head physics follower
        /// position calculation is also locally scoped.
        /// </summary>
        /// <remarks>
        /// This implementation requires access to protected members of the base AutoHandPlayer class
        /// and public members of the HeadPhysicsFollower, which required modifying the original asset's scripts.
        /// </remarks>
        /// <param name="position">The target world position to move the player to.</param>
        /// <param name="rotation">The target world rotation for the player.</param>
        public override void SetPosition(Vector3 position, Quaternion rotation)
        {
            Vector3 deltaPos = position - transform.position;
            transform.position += deltaPos;

            // --- MODIFIED ---
            // Directly set the tracking container's position to the new player position.
            // This differs from the original, which calculated an offset based on the head's position.
            trackingContainer.position = transform.position;
            
            // Update tracking positions.
            lastUpdatePosition = transform.position;
            
            // --- MODIFIED ---
            // Set the target tracked position directly to the new tracking container position.
            // The original implementation retained the y-value from the previous targetTrackedPos.
            // NOTE: This requires 'targetTrackedPos' to be 'protected' in the base class.
            targetTrackedPos = trackingContainer.position;
            
            // NOTE: This requires 'targetPosOffset' method to be 'protected' in the base class.
            targetPosOffset = Vector3.zero;
            body.position = transform.position;
            
            // Update head physics follower if it exists.
            if(headPhysicsFollower != null) 
            {
                // --- NEW ---
                // The targetPos calculation is now inside the if-block,
                // making it local to the headPhysicsFollower logic.
                Vector3 targetPos = transform.position - headCamera.transform.position;
                targetPos.y = deltaPos.y;
                headPhysicsFollower.transform.position += targetPos;
                // NOTE: This requires the 'body' Rigidbody in HeadPhysicsFollower to be 'public'.
                headPhysicsFollower.body.position = headPhysicsFollower.transform.position;
            }

            lastHeadPos = headCamera.transform.position;

            // NOTE: This requires 'SafeMoveHandToPosition' method to be 'protected' in the base class.
            SafeMoveHandToPosition(handRight, transform, handRight.transform.position);
            SafeMoveHandToPosition(handLeft, transform, handLeft.transform.position);

            AddRotation(rotation * Quaternion.Inverse(headCamera.transform.rotation));

            OnTeleported?.Invoke(this);
        }

        public void SetHeadFollowerCollisionEnabled(bool setEnabled)
        {
            headFollowerCollider.enabled = setEnabled;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/IdealogicalAutoHandPlayer.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/Input/ControllersInputModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 445663b5f8fa45d29d35a99a5d3b09e1
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Autohand;
using Autohand.Demo;
using Ldx.Framework.Systems.Player.Hands;
using Ldx.Framework.Systems.UI.Interaction;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;

namespace Ldx.Framework.Systems.Player.Input
{
    public class ControllersInputModule : MonoBehaviour, IInputModule
    {
        public static XRHandControllerLink LeftHand { get; private set; }
        public static XRHandControllerLink RightHand { get; private set; }
        
        [Serializable]
        public class HandData
        {
            public XRHandControllerLink openXRAutoHandTracking;
            public Common2DAxis turningAxis = Common2DAxis.primaryAxis;
            public Transform overrideFollowOffsetBuild;
            public Transform UIPointerOffsetControllers;
        }

        [SerializeField]
        private SerializableDictionary<HandSide, HandData> handSideToControllerLinkSet = new();
        
        private readonly List<(XRHandControllerLink, Common2DAxis)> turnControllers = new();
        private AutoHandPlayer autoHandPlayer;

        public void Initialize(SerializableDictionary<HandSide, HandsController.HandReferences> hands)
        {
            turnControllers.Clear();
            foreach (HandSide side in PlayerGlobalSettings.TurnHandSides)
            {
                HandData handData = handSideToControllerLinkSet[side];
                if (side is HandSide.Right)
                {
                    RightHand = handData.openXRAutoHandTracking;
                }
                else
                {
                    LeftHand = handData.openXRAutoHandTracking;   
                }
                
                turnControllers.Add((handData.openXRAutoHandTracking, 
                    handData.turningAxis));

                if (handData.UIPointerOffsetControllers)
                {
                    LdxHandCanvasPointer uiPointer = hands[side].hand.GetComponentInChildren<LdxHandCanvasPointer>();
                    if (uiPointer != null)
                    {
                        uiPointer.transform.localPosition = handData.UIPointerOffsetControllers.localPosition;
                        uiPointer.transform.localRotation = handData.UIPointerOffsetControllers.localRotation;
                    }
                }

#if !UNITY_EDITOR
                if (handSideToControllerLinkSet[side].overrideFollowOffsetBuild != null)
                {
                    hands[side].hand.follow = handSideToControllerLinkSet[side].overrideFollowOffsetBuild;
                }
#endif
            }

            autoHandPlayer = PlayerController.Instance.AutoHandPlayer;
        }

        private void Update()
        {
            float activeTurnValue = 0;
            foreach ((XRHandControllerLink controllerLink, Common2DAxis axis) in turnControllers)
            {
                float axisValue = controllerLink.GetAxis2D(axis).x;
                if (Mathf.Abs(axisValue) >= Mathf.Abs(activeTurnValue))
                {
                    activeTurnValue = axisValue;   
                }
            }

            autoHandPlayer.Turn(activeTurnValue);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/Input/ControllersInputModule.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/Input/IInputModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 61363818424349ed949bb31a575cb6a9
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.Player.Hands;
using Ldx.Framework.Utilities.Serializable;

namespace Ldx.Framework.Systems.Player.Input
{
    public interface IInputModule
    {
        void Initialize(SerializableDictionary<HandSide, HandsController.HandReferences> hands);
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/Input/IInputModule.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/PlayerController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 88666d4042274676b6c804a271073d53
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Threading;
using Autohand;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.Player.Hands;
using Ldx.Framework.Systems.Player.Waist;
using Ldx.Framework.Systems.Save;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Systems.Teleportation;
using Ldx.Framework.Systems.UI;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Systems.Player
{
    /// <summary>
    /// The player controller
    /// At the top of hierarchy for the player rig. Serves to provide
    /// information about the player, controls the setup, and provides
    /// references to the various components of the setup
    /// </summary>
    public class PlayerController : Singleton<PlayerController>
    {
        [SerializeField] private IdealogicalAutoHandPlayer autoHandPlayer;
        public IdealogicalAutoHandPlayer AutoHandPlayer => autoHandPlayer;

        [SerializeField] private PlayerTeleporter teleporter;
        public PlayerTeleporter Teleporter => teleporter;
        
        [SerializeField] private Camera mainCamera;
        public Camera MainCamera => mainCamera;
        
        [SerializeField] private HandsController handsController;
        public HandsController HandsController => handsController;
        
        [SerializeField] private WaistController waistController;
        public WaistController WaistController => waistController;

        [SerializeField] private PlayerFallController fallController;
        public PlayerFallController FallController => fallController;

        public Transform LeftHand => handsController.LeftHand.transform;
        public Transform RightHand => handsController.RightHand.transform;

        private PlayerRigCapture StartingRigCapture { get; set; }
        
        public Vector3 GetPlayerForward() => WaistController.GetWaistForward();
        public Vector3 GetPlayerPosition => autoHandPlayer.transform.position;
        public bool CurrentStateOfMovement { get; private set; }
        public bool IsGrounded => autoHandPlayer.IsGrounded();
        public bool IsCrouching => autoHandPlayer.crouching;
        public bool IsPlayerControllerEnabled => autoHandPlayer.enabled;
        public bool IsMovementEnabled => autoHandPlayer.maxMoveSpeed > 0;
        public CapsuleCollider PlayerBodyCollider => autoHandPlayer.bodyCollider;
        
        private float defaultMovementSpeed;
        private float defaultRunSpeed;
        private CancellationTokenSource cts;
        
        private void OnValidate()
        {
            if (autoHandPlayer == null)
            {
                autoHandPlayer = GetComponentInChildren<IdealogicalAutoHandPlayer>();
            }

            if (teleporter == null)
            {
                teleporter = GetComponentInChildren<PlayerTeleporter>();
            }

            if (mainCamera == null)
            {
                mainCamera = GetComponentInChildren<Camera>();
            }
        }

        protected override void Awake()
        {
            base.Awake();
            if (autoHandPlayer == null)
            {
                DestroyImmediate(gameObject);
                return;
            }
            StartingRigCapture = PlayerRigCapture.GetCapture(this);
            LdxSaveSystem.OnPlayerSettingsChanged += HandlePlayerSettingsChanged;
            ScenarioManager.OnLoadingFinished += HandleLoadingFinished;
            mainCamera.cullingMask = PlayerGlobalSettings.MainCameraCullingMask;
        }
        
        private void Start()
        {
            ScenarioManager.Instance.OnScenarioStarted += HandleScenarioStarted;
            ScenarioManager.Instance.OnUnloadingScenarioOrLobby += HandleScenarioExit;
            SetHeadCollisionEnabled(false);
            defaultMovementSpeed = autoHandPlayer.maxMoveSpeed;
        }

        private void OnDestroy()
        {
            cts.SafeCancelAndDispose();
            LdxSaveSystem.OnPlayerSettingsChanged -= HandlePlayerSettingsChanged;
            
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
            }

            if (ScenarioManager.IsValid)
            {
                ScenarioManager.Instance.OnScenarioStarted -= HandleScenarioStarted;
                ScenarioManager.Instance.OnUnloadingScenarioOrLobby -= HandleScenarioExit;
            }
            
            ScenarioManager.OnLoadingFinished -= HandleLoadingFinished;

            SetJoystickMovementEnabled(true);
        }
        
        private void HandleScenarioExit(ScenarioManager scrMgr)
        {
            SetPlayerMovementEnabled(true);
            SetJoystickMovementEnabled(true);
        }

        private async void HandleScenarioStarted(ScenarioManager scrMgr, ScenarioDataType dType)
        {
            CurrentStateOfMovement = teleporter.enabled;
            await UniTask.WaitUntil(() => LdxTrackingManager.IsValid);
            LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
            LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
        }

        private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            switch (eventData)
            {
                case SetPlayerMovementStateEventData setPlayerMovementStateEventData:
                    ProcessPlayerMovementState(setPlayerMovementStateEventData);
                    break;
                case SetTeleportationStateEventData setTeleportationStateEventData:
                    ProcessSetTeleportationState(setTeleportationStateEventData);
                    break;
                case SetTurningStateEventData setTurningStateEventData:
                    ProcessSetTurningState(setTurningStateEventData);
                    break;
                case SetJoystickMovementStateEventData setJoystickMovementStateEventData:
                    ProcessSetJoystickMovementState(setJoystickMovementStateEventData);
                    break;
            }
        }

        #region Movement

        /// <summary>
        /// The primary method for moving the player. Elegantly handles fading, component safety,
        /// and rig-aware positioning to ensure a smooth and correct transition.
        /// </summary>
        /// <param name="request">A struct containing all parameters for the move.</param>
        public async UniTask MovePlayerToAsync(PlayerMovementRequest request)
        {
            if (request.UseFade)
            {
                await UIController.Instance.FadeOutScreenAsync(false, request.FadeDurationOverride ?? -1f);
            }
            
            cts.SafeCancelAndDispose();
            SetPlayerControllerEnabled(false);
            SetPlayerHandCollisionEnabled(false);
            AutoHandPlayer.SetHeadFollowerCollisionEnabled(false);
            
            autoHandPlayer.autoAdjustColliderHeight = false;
            
            request.OnBeforeMove?.Invoke();
            MovePlayerRig(request.TargetPosition, request.TargetRotation);
            request.OnAfterMove?.Invoke();
            
            await UniTask.WaitForFixedUpdate();
            autoHandPlayer.autoAdjustColliderHeight = true;
            
            SetPlayerControllerEnabled(true);
            
            await UniTask.WaitForFixedUpdate();
            SetPlayerHandCollisionEnabled(true);
            
            cts = new CancellationTokenSource();
            EnableHeadCollisionAfterDelay(0.5f, cts.Token).Forget();
       
            if (request.UseFade)
            {
                await UIController.Instance.FadeInScreenAsync(false, request.FadeDurationOverride ?? -1f);
            }
        }

        private async UniTask EnableHeadCollisionAfterDelay(float delay, CancellationToken token)
        {
            await UniTask.Delay(delay.ToMilliseconds(), cancellationToken: token);

            if (token.IsCancellationRequested)
            {
                return;
            }
            
            AutoHandPlayer.SetHeadFollowerCollisionEnabled(true);
        }
        
        /// <summary>
        /// The core logic that physically repositions the player's rig. This ensures the player's
        /// real-world playspace is correctly offset to the new virtual position.
        /// </summary>
        private void MovePlayerRig(Vector3 targetPosition, Quaternion? targetRotation)
        {
            autoHandPlayer.body.linearVelocity = Vector3.zero;

            if (targetRotation.HasValue)
            {
                autoHandPlayer.SetPosition(targetPosition, targetRotation.Value);
            }
            else
            {
                autoHandPlayer.SetPosition(targetPosition);
            }

            Physics.SyncTransforms();
        }

        #endregion
        
        public void SetPlayerMovementEnabled(bool setEnabled)
        {
            if (CurrentStateOfMovement == setEnabled)
            {
                return;
            }

            SetPlayerControllerEnabled(setEnabled);
            SetTeleportEnabled(setEnabled);
            CurrentStateOfMovement = setEnabled;
        }
        
        public void InjectSetup(PlayerRigData data)
        {
            PlayerRigCapture captureWithOverrides = data.GetCaptureWithOverrides(StartingRigCapture);
            captureWithOverrides.Apply(this);
        }
        
        public void ResetSetupState()
        {
            StartingRigCapture.Apply(this);
        }
        
        public void SetGravityEnabled(bool enable)
        {
            //TODO: find gravity replacement
            /*HVRPlayerController.Gravity = enable ? StartingRigCapture.Gravity : 0;*/
        }
        
        public void SetTeleportEnabled(bool setEnabled)
        {
            teleporter.enabled = setEnabled;
        }
        
        public void SetPlayerControllerEnabled(bool setEnabled)
        {
            autoHandPlayer.enabled = setEnabled;
        }

        public void SetHeadCollisionEnabled(bool setEnabled)
        {
            autoHandPlayer.useHeadCollision = setEnabled;
        }
        
        public void SetPlayerHandCollisionEnabled(bool setEnabled)
        {
            HandsController.LeftHand.collisionTracker.enabled = setEnabled;
            HandsController.RightHand.collisionTracker.enabled = setEnabled;
            if (!setEnabled)
            {
                HandsController.LeftHand.collisionTracker.CleanUp();
                HandsController.RightHand.collisionTracker.CleanUp();
            }
            
            HandsController.ToggleHandColliders(setEnabled);
        }
        
        private void HandlePlayerSettingsChanged(LdxSaveSystem saveSystem)
        {
            autoHandPlayer.rotationType = saveSystem.SmoothTurnToggle ? RotationType.smooth : RotationType.snap;
            autoHandPlayer.smoothTurnSpeed = saveSystem.SmoothTurnSpeed;
            autoHandPlayer.snapTurnAngle = saveSystem.SnapTurnSpeed;
            //TODO: find the replacement
            /*hvrPlayerController.FadeFromLean = saveSystem.FadeFromLean;*/
            //TODO: manually change offset
            /*cameraRig.SetSitStandMode((HVRSitStand)saveSystem.SitStandIndex);*/
        }

        private void HandleLoadingFinished(ScenarioManager scenarioManager)
        {
            CalibrateHeight();
        }
        
        private void ProcessPlayerMovementState(SetPlayerMovementStateEventData data)
        {
            SetPlayerMovementEnabled(data.Enabled);
        }

        private void ProcessSetTeleportationState(SetTeleportationStateEventData data)
        {
            SetTeleportEnabled(data.Enabled);
        }
        
        private void ProcessSetTurningState(SetTurningStateEventData data)
        {
            SetPlayerControllerEnabled(data.Enabled);
        }
        
        private void ProcessSetJoystickMovementState(SetJoystickMovementStateEventData data)
        {
            SetJoystickMovementEnabled(data.Enabled);
        }
        
        public void SetJoystickMovementEnabled(bool dataEnabled)
        {
            autoHandPlayer.maxMoveSpeed = dataEnabled ? defaultMovementSpeed : 0;
        }

        public void CalibrateHeight() { }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/PlayerController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/PlayerFallController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ac6078470562b034d971d1bd483d8984
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Threading;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Systems.UI;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Systems.Player
{
    public enum FallState
    {
        Grounded,
        Falling
    }

    /// <summary>
    /// This class handles the player falling out of the world. It initiates an asynchronous check upon scenario start.
    /// It detects a fall by monitoring if the player remains ungrounded for a certain duration while simultaneously
    /// dropping a significant vertical distance, based on settings in PlayerGlobalSettings.
    /// </summary>
    public class PlayerFallController : MonoBehaviour
    {
        private const float DELAY = 1;
        private static FallState CurrentState { get; set; } = FallState.Grounded;
        public static event Action OnPlayerFall;
        public static event Action OnPlayerFallEnd;
        
        [Header("Configuration")]
        [SerializeField] private float fallTransitionDuration = 1f;
        [SerializeField] private bool debugMode;
        
        private CancellationTokenSource cts = new();
        private CancellationTokenSource scenarioLifetimeCts = new();

        private void Start()
        {
            if (!PlayerGlobalSettings.EnableFallController)
            {
                gameObject.SetActive(false);
                return;
            }
            
            if (ScenarioManager.IsValid)
            {
                ScenarioManager.Instance.OnScenarioStarted += HandleScenarioStarted;
                ScenarioManager.Instance.OnUnloadingScenarioOrLobby += HandleScenarioUnloading;
            }
            
            if (LdxTrackingManager.Instance != null)
            {
                LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
            }
        }

        private void OnDestroy()
        {
            cts.SafeCancelAndDispose();
            cts = null;
            
            if (ScenarioManager.IsValid)
            {
                ScenarioManager.Instance.OnScenarioStarted -= HandleScenarioStarted;
                ScenarioManager.Instance.OnUnloadingScenarioOrLobby -= HandleScenarioUnloading;
            }
            
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
            }
        }
        
        private void HandleScenarioStarted(ScenarioManager manager, ScenarioDataType dataType)
        {
            scenarioLifetimeCts.SafeCancelAndDispose();
            scenarioLifetimeCts = new CancellationTokenSource();
            FallCheckLoopAsync(scenarioLifetimeCts.Token).Forget();
        }

        private void HandleScenarioUnloading(ScenarioManager manager)
        {
            scenarioLifetimeCts.SafeCancelAndDispose();
            CurrentState = FallState.Grounded;
        }
        
        private async UniTaskVoid FallCheckLoopAsync(CancellationToken token)
        {
            while (!token.IsCancellationRequested)
            {
                try
                {
                    await UniTask.WaitUntil(() => PlayerController.IsValid && !PlayerController.Instance.IsGrounded, cancellationToken: token);
                    Log("Player is ungrounded, starting potential fall check...");
                    
                    bool isFalling = await MonitorPotentialFallAsync(token);
                    
                    if (isFalling)
                    {
                        Log("Fall confirmed. Activating fall sequence.");
                        await ActivateFallAsync(token);
                    }
                    else
                    {
                        Log("Potential fall was not confirmed (player landed or did not fall far enough).");
                    }
                }
                catch (OperationCanceledException)
                {
                    Log("Fall check loop was cancelled.");
                    break;
                }
                catch (Exception ex)
                {
                    Debug.LogError($"An error occurred in the fall check loop: {ex}. The loop will pause before retrying.");
                    await UniTask.Delay(DELAY.ToMilliseconds(), ignoreTimeScale: true, cancellationToken: token);
                }
            }
        }
        
        /// <summary>
        /// Monitors the player after they become ungrounded to determine if it's a real fall.
        /// </summary>
        /// <returns>True if the player is determined to be falling, false otherwise.</returns>
        private async UniTask<bool> MonitorPotentialFallAsync(CancellationToken token)
        {
            float initialY = PlayerController.Instance.GetPlayerPosition.y;
            
            try
            {
                await UniTask.Delay(PlayerGlobalSettings.TimeBeforeFallCheck.ToMilliseconds(), cancellationToken: token);
            }
            catch (OperationCanceledException)
            {
                return false;
            }
            
            if (!PlayerController.IsValid || PlayerController.Instance.IsGrounded)
            {
                return false;
            }

            float currentY = PlayerController.Instance.GetPlayerPosition.y;
            float verticalDistanceDropped = initialY - currentY;
            return verticalDistanceDropped > PlayerGlobalSettings.MinVerticalFallDistance;
        }
        
        private async UniTask ActivateFallAsync(CancellationToken token)
        {
            if (CurrentState == FallState.Falling)
            {
                return;
            }
            
            CurrentState = FallState.Falling;
            OnPlayerFall?.Invoke();

            try
            {
                await UIController.Instance.FadeOutScreenAsync(false, fallTransitionDuration);
                token.ThrowIfCancellationRequested();

                switch (PlayerGlobalSettings.FallMode)
                {
                    case PlayerGlobalSettings.FallControllerMode.TeleportToStart:
                        PlayerStartPoint point = ReferenceBank.GetFirstOrDefault<PlayerStartPoint>();
                        if (point != null)
                        {
                            PlayerMovementRequest request = new PlayerMovementRequest
                            {
                                TargetPosition = point.transform.position,
                                TargetRotation = point.transform.rotation,
                                UseFade = true,
                                FadeDurationOverride = fallTransitionDuration
                            };
                            await PlayerController.Instance.MovePlayerToAsync(request);
                        }
                        else
                        {
                            Log("TeleportToStart failed because no PlayerStartPoint was found.");
                        }
                        break;
                    case PlayerGlobalSettings.FallControllerMode.RestartModule:
                        if (ScenarioManager.IsValid)
                        {
                            ScenarioManager.Instance.ReloadCurrentScenario();
                        }
                        else
                        {
                            Debug.LogError(
                                "ScenarioManager not found, cannot restart module. Teleporting to start instead.");
                            PlayerController.Instance.ResetSetupState();
                        }

                        break;
                }

                await UniTask.Yield(PlayerLoopTiming.LastPostLateUpdate, cts.Token);

                await UIController.Instance.FadeInScreenAsync(false, fallTransitionDuration);
                token.ThrowIfCancellationRequested();

                CurrentState = FallState.Grounded;
                OnPlayerFallEnd?.Invoke();
            }
            catch (OperationCanceledException)
            {
                Log("Fall sequence was cancelled.");
            }
            catch (Exception ex)
            {
                Debug.LogError($"An error occurred during the fall sequence: {ex.Message}");

                if (PlayerController.IsValid)
                {
                    PlayerController.Instance.SetPlayerControllerEnabled(true);
                    PlayerController.Instance.SetGravityEnabled(true);
                }

                if (UIController.IsValid)
                {
                    UIController.Instance.FadeInScreenAsync(true).Forget();
                }
            }
            finally
            {
                CurrentState = FallState.Grounded;
                OnPlayerFallEnd?.Invoke();
            }
        }
         
        private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            if (eventData is not ActivateFallControllerEventData data)
            {
                return;
            }
            
            Log("Manual fall activated via objective event.");
            ActivateFallAsync(scenarioLifetimeCts?.Token ?? CancellationToken.None).Forget();
        }
        
        /// <summary>
        /// Logs a message to the console if debug mode is enabled.
        /// </summary>
        private void Log(string message)
        {
            if (!debugMode)
            {
                return;
            }
            
            Debug.Log($"[{nameof(PlayerFallController)}] {message}");
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/PlayerFallController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/PlayerGlobalSettings.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8ef31eff2f4f489e8b131aa7149bc079
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Player.Hands;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Player
{
    [HasFrameworkDefault]
    public class PlayerGlobalSettings : GlobalSettings<PlayerGlobalSettings>
    {
        [Header("Camera")] 
        [SerializeField] private LayerMask mainCameraCullingMask;
        public static LayerMask MainCameraCullingMask => Instance.mainCameraCullingMask;
        
        [Space]
        [Header("Turning")]
        [SerializeField] private List<HandSide> turnHandSides = new();
        public static List<HandSide> TurnHandSides => Instance.turnHandSides;

        [SerializeField] private float initialSmoothTurnSpeed = 250f;
        public float InitialSmoothTurnSpeed => initialSmoothTurnSpeed;
        
        [SerializeField] private Vector2 smoothTurnRange = new Vector2(100f, 300f);
        public Vector2 SmoothTurnRange => smoothTurnRange;

        [SerializeField] private float initialSnapAmount = 45f;
        public float InitialSnapAmount => initialSnapAmount;
        
        [SerializeField] private Vector2 snapAmountRange = new Vector2(10f, 90f);
        public Vector2 SnapAmountRange => snapAmountRange;
        
        [Space]
        [Header("Teleportation")]
        [SerializeField] private bool useFadeInOutForTeleportation = true;
        public static bool UseFadeInOutForTeleportation => Instance.useFadeInOutForTeleportation;
        
        [SerializeField] private float teleportationFadeInTime = 0.2f;
        public static float TeleportationFadeInTime => Instance.teleportationFadeInTime;
        
        [SerializeField] private float teleportationFadeOutTime = 0.2f;
        public static float TeleportationFadeOutTime => Instance.teleportationFadeOutTime;
        
        public enum JoystickDirection 
        { 
            /// <summary>Activates when pushing the joystick up.</summary>
            Up, 
            /// <summary>Activates when pulling the joystick down.</summary>
            Down, 
            /// <summary>Activates when pushing up OR pulling down.</summary>
            Vertical 
        }
        
        [Tooltip("The direction(s) on the vertical axis to activate teleport aiming.")]
        [SerializeField] private JoystickDirection teleportationJoystickDirection = JoystickDirection.Vertical;
        public static JoystickDirection TeleportationJoystickDirection => Instance.teleportationJoystickDirection;

        [Tooltip("How far the joystick must be moved to activate aiming. (0.1 to 1)")]
        [SerializeField, Range(0.1f, 1f)] private float teleportationJoystickActivationThreshold = 0.75f;
        public static float TeleportationJoystickActivationThreshold => Instance.teleportationJoystickActivationThreshold;

        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string eventOnTeleportAiming;
        public static string EventOnTeleportAiming => Instance.eventOnTeleportAiming;

        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string eventOnTeleported;
        public static string EventOnTeleported => Instance.eventOnTeleported;
        
        [Header("Fall Controller")]
        [SerializeField] private bool enableFallController = true;
        public static bool EnableFallController => Instance.enableFallController;
        
        public enum FallControllerMode
        {
            TeleportToStart,
            RestartModule
        }

        [SerializeField] private FallControllerMode fallMode = FallControllerMode.TeleportToStart;
        public static FallControllerMode FallMode => Instance.fallMode;
        
        [Tooltip("How long the player must be ungrounded before we check if it's a true fall.")]
        [SerializeField] private float timeBeforeFallCheck = 1.5f;
        public static float TimeBeforeFallCheck => Instance.timeBeforeFallCheck;

        [Tooltip("The minimum vertical distance the player must drop during the 'timeBeforeFallCheck' to be considered falling.")]
        [SerializeField] private float minVerticalFallDistance = 2.0f;
        public static float MinVerticalFallDistance => Instance.minVerticalFallDistance;


#if UNITY_EDITOR
        [UnityEditor.SettingsProvider]
        public static UnityEditor.SettingsProvider CreateSettingsProvider()
        {
            return CreateGlobalSettingsProvider("Project/LDX/Project/Player");
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/PlayerGlobalSettings.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/PlayerMovementRequest.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ec5f6470d58446e0b26bca09090a06e4
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Systems.Player
{
    /// <summary>
    /// A parameter object for making player movement requests to the PlayerController.
    /// </summary>
    public struct PlayerMovementRequest
    {
        public Vector3 TargetPosition;
        public Quaternion? TargetRotation;
        public bool UseFade;
        public float? FadeDurationOverride;
        
        /// <summary>
        /// An action to be invoked after the screen has faded out, but before the player is moved.
        /// Useful for triggering events or resetting state.
        /// </summary>
        public Action OnBeforeMove;
        
        /// <summary>
        /// An action to be invoked after the player has moved, but before the screen fades back in.
        /// Useful for triggering events that should occur at the new location.
        /// </summary>
        public Action OnAfterMove;

        public PlayerMovementRequest(Vector3 targetPosition)
        {
            TargetPosition = targetPosition;
            TargetRotation = null;
            UseFade = true;
            FadeDurationOverride = null;
            OnBeforeMove = null;
            OnAfterMove = null;
        }
        
        public PlayerMovementRequest(Vector3 targetPosition, Quaternion targetRotation)
        {
            TargetPosition = targetPosition;
            TargetRotation = targetRotation;
            UseFade = true;
            FadeDurationOverride = null;
            OnBeforeMove = null;
            OnAfterMove = null;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/PlayerMovementRequest.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/PlayerPositionMarker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 032cb9e09e5d490f975db98fdea079cd
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Systems.Player
{
    public class PlayerPositionMarker : MonoBehaviour
    {
        
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/PlayerPositionMarker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/PlayerRig/MaxDropData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: df6bf8ef5a794b85940299b3c0163b2d
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Systems.Player.PlayerRig
{
    [Serializable]
    public class MaxDropData
    {
        [SerializeField] 
        private bool checkDropDistance;
        public bool CheckDropDistance
        {
            get => checkDropDistance;
            set => checkDropDistance = value;
        }

        [SerializeField] 
        private float maxDropDistance;
        public float MaxDropDistance
        {
            get => maxDropDistance;
            set => maxDropDistance = value;
        }

        public MaxDropData()
        {
            
        }
        
        public MaxDropData(bool checkDropDistance, float maxDropDistance)
        {
            this.checkDropDistance = checkDropDistance;
            this.maxDropDistance = maxDropDistance;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/PlayerRig/MaxDropData.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/PlayerRig/PlayerRigOverrides.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 748fad02ae56406cb133d56f6b315675
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using Ldx.Framework.Features.SocketFilter;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Player.PlayerRig
{
    /// <summary>
    /// Defines a property to override in the player rig with a custom value
    /// </summary>
    [Serializable]
    public abstract class PlayerRigOverride
    {
        public abstract void ApplyToDataCapture(PlayerRigCapture capture);
    }

    [Serializable]
    public abstract class PlayerRigOverride<T> : PlayerRigOverride
    {
        [SerializeField] 
        private T value;
        public T Value => value;
    }

    [Serializable]
    public class PlayerRigOverridesContainer : IEnumerable<PlayerRigOverride>
    {
        [SerializeReference] private List<PlayerRigOverride> overrides = new List<PlayerRigOverride>();

        public void Add(PlayerRigOverride o)
        {
            overrides.Add(o);    
        }
        
        public IEnumerator<PlayerRigOverride> GetEnumerator()
        {
            return overrides.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }

    [Serializable]
    public class CanJumpRigOverride : PlayerRigOverride<bool>
    {
        public override void ApplyToDataCapture(PlayerRigCapture capture)
        {
            capture.CanJump = Value;
        }
    }

    [Serializable]
    public class CanSteerWhileJumpingRigOverride : PlayerRigOverride<bool>
    {
        public override void ApplyToDataCapture(PlayerRigCapture capture)
        {
            capture.CanSteerWhileJumping = Value;
        }
    }
    
    [Serializable]
    public class CanSprintRigOverride : PlayerRigOverride<bool>
    {
        public override void ApplyToDataCapture(PlayerRigCapture capture)
        {
            capture.CanSprint = Value;
        }
    }
    
    [Serializable]
    public class MinHeightRigOverride : PlayerRigOverride<float>
    {
        public override void ApplyToDataCapture(PlayerRigCapture capture)
        {
            capture.MinHeight = Value;
        }
    }
    
    [Serializable]
    public class CanCrouchRigOverride : PlayerRigOverride<bool>
    {
        public override void ApplyToDataCapture(PlayerRigCapture capture)
        {
            capture.CanCrouch = Value;
        }
    }
    
    [Serializable]
    public class TeleporterEnabledRigOverride : PlayerRigOverride<bool>
    {
        public override void ApplyToDataCapture(PlayerRigCapture capture)
        {
            capture.TeleporterEnabled = Value;
        }
    }

    [Serializable]
    public class CanMoveWithJoystickRigOverride : PlayerRigOverride<bool>
    {
        public override void ApplyToDataCapture(PlayerRigCapture capture)
        {
            capture.JoystickMovementEnabled = Value;
        }
    }
    
    [Serializable]
    public class HeadCollisionPushesBackEnabledRigOverride : PlayerRigOverride<bool>
    {
        public override void ApplyToDataCapture(PlayerRigCapture capture)
        {
            capture.HeadCollisionPushesBack = Value;
        }
    }

    [Serializable]
    public class CameraClearFlagsRigOverride : PlayerRigOverride<CameraClearFlags>
    {
        public override void ApplyToDataCapture(PlayerRigCapture capture)
        {
            capture.CameraClearFlags = Value;
        }
    }

    [Serializable]
    public class SetWaistChildPrefabsRigOverride : PlayerRigOverride<List<GameObject>>
    {
        public override void ApplyToDataCapture(PlayerRigCapture capture)
        {
            capture.WaistChildPrefabs.Clear();
            capture.WaistChildPrefabs.AddRange(Value);
        }
    }

    [Serializable]
    public class SetupHolstersAndItemsRigOverride : PlayerRigOverride
    {
        [SerializableContainer("Holster", maxItems: 6)]
        [SerializeField] 
        private HolsterSpawnDataContainer data;
        
        public override void ApplyToDataCapture(PlayerRigCapture capture)
        {
            capture.HolsterSpawnDataContainer = data;
        }
    }
    
    [Serializable]
    public class MaxDropRigOverride : PlayerRigOverride<MaxDropData>
    {
        public override void ApplyToDataCapture(PlayerRigCapture capture)
        {
            capture.MaxDropData = new MaxDropData(Value.CheckDropDistance, Value.MaxDropDistance);
        }
    }
    
    [Serializable]
    public class PlayerControllerEnabledRigOverride : PlayerRigOverride<bool>
    {
        public override void ApplyToDataCapture(PlayerRigCapture capture)
        {
            capture.HVRPlayerControllerEnabled = Value;
        }
    }

    [Serializable]
    public class SetEyeHeightRigOverride : PlayerRigOverride<float>
    {
        public override void ApplyToDataCapture(PlayerRigCapture capture)
        {
            capture.EyeHeight = Value;
        }
    }

    [Serializable]
    public class SetFarClipPlaneRigOverride : PlayerRigOverride<float>
    {
        public override void ApplyToDataCapture(PlayerRigCapture capture)
        {
            capture.FarClipPlane = Value;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/PlayerRig/PlayerRigOverrides.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/StartPoint/BaseStartPointMarker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9af8f66887d440fbbb5d94144430a47a
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.Player
{
    /// <summary>
    /// Used to visualize a start point in editor
    /// </summary>
    public abstract class BaseStartPointMarker : MonoBehaviour
    {
        protected const float FLOOR_OFFSET = 1.5f;

        [HideInInspector] [SerializeField] 
        private UnityEngine.Camera editorPreviewCamera; 
        
        private GUIStyle textStyle;
        protected GUIStyle TextStyle
        {
            get
            {
                if (textStyle == null)
                {
                    textStyle = new GUIStyle();
                    textStyle.fontSize = 20;
                    textStyle.normal.textColor = GetColour();
                }

                return textStyle;
            }
        }

        public virtual string DrawnOverMessage => null;
        protected virtual string LabelText { get; set; } = "Start Point";

        protected Color? color;
        
        public Vector3 GetCameraPosition()
        {
            return transform.position.Modify(y: transform.position.y + FLOOR_OFFSET);
        }

        protected abstract Color GetColour();

#if UNITY_EDITOR

   /// <summary>
        /// Creates the camera used for the SceneView preview
        /// Created when the object is selected, then destroyed after
        /// </summary>
        public UnityEngine.Camera EDITOR_GetPreviewCamera()
        {
            if (editorPreviewCamera == null)
            {
                var obj = new GameObject("EditorPreviewCamera_Hidden");
                obj.hideFlags = HideFlags.HideAndDontSave; 
                editorPreviewCamera = obj.AddComponent<UnityEngine.Camera>();
                obj.transform.SetParent(transform);
                obj.transform.localPosition = new Vector3(0.0f, FLOOR_OFFSET, 0.0f);
                obj.transform.localRotation = Quaternion.identity;
                obj.transform.localScale = Vector3.one;
                RenderTexture txt =  new RenderTexture(1280, 720, 16, RenderTextureFormat.ARGB32);
                txt.Create();
                editorPreviewCamera.targetTexture = txt;
            }
            return editorPreviewCamera;
        }
        
        // Why here? Because no build logic here yet, and so
        // just adding it outside of this block will cause Update()
        // to be added to Unity's PlayerLoop for no reason
        private void Update()
        {
            transform.rotation = Quaternion.Euler(0, transform.rotation.eulerAngles.y, 0);
        }

        private void OnDrawGizmos()
        {
            Color color = Gizmos.color;
            Matrix4x4 matrix = Gizmos.matrix;
            Vector3 cameraPos = transform.position.Modify(y: transform.position.y + FLOOR_OFFSET);
            Gizmos.color = GetColour();
            Gizmos.DrawLine(transform.position, cameraPos.Modify(y: cameraPos.y - 0.3f));
            Gizmos.matrix = Matrix4x4.TRS(cameraPos, transform.rotation, Vector3.one);
            Gizmos.DrawFrustum(Vector3.zero, 45, 1, 0, 800.0f / 600.0f);
            Handles.Label(transform.position, LabelText, TextStyle);
            
            Gizmos.color = color;
            Gizmos.matrix = matrix;
        }

#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/StartPoint/BaseStartPointMarker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/StartPoint/CustomCameraPreview.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: de8bdd232f9545228378135740eec79f
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Systems.Player
{
    public class CustomCameraPreview : BaseStartPointMarker
    {
        private string userSetLabel;

        protected override string LabelText => userSetLabel ?? " ";

        protected override Color GetColour()
        {
            if (color == null)
            {
                color = new Color(0.8f, 0.6f, 0.1f);
            }
            return color.Value;        
        }
        
        public void SetLabel(string label)
        {
            userSetLabel = label;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/StartPoint/CustomCameraPreview.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/StartPoint/CustomStartPoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ecaaef34037e4e208ca12faf28a06e87
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Systems.Player
{
    public class CustomStartPoint : BaseStartPointMarker
    {
        [SerializeField]
        protected bool active = true;

        public virtual bool Active
        {
            get => active;
            set => active = value;
        }
        
        protected override string LabelText => "Custom Start";

        protected override Color GetColour()
        {
            color ??= new Color(0.9f, 0.3f, 0.7f);
            return color.Value;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/StartPoint/CustomStartPoint.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/StartPoint/CustomStartPointKeyBased.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 931caebea19a4cfab45d5410ac375e95
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Player
{
    public class CustomStartPointKeyBased : CustomStartPoint
    {
        [SerializeField][IDSelection(LdxIdSettings.IdType.Key)]
        private string keyToCheck;
        
        [SerializeField]
        private bool value;
        
        [SerializeField]
        private bool isStatic;

        public override bool Active => active && IsValid();

        private bool IsValid()
        {
            if (string.IsNullOrEmpty(keyToCheck))
            {
                return true;
            }
            
            bool keyValue = isStatic ? TrackingKeyController.GetStaticKeyValue(keyToCheck).GetValueOrDefault() 
                : TrackingKeyController.Instance.GetKeyValue(keyToCheck).GetValueOrDefault();
            return keyValue == value;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/StartPoint/CustomStartPointKeyBased.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/StartPoint/PlayerStartPoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f33d6d630ea1473b9e09d07c43a4ad2c
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using Cysharp.Threading.Tasks;
#if UNITY_EDITOR
using UnityEditor.Callbacks;
#endif

namespace Ldx.Framework.Systems.Player
{
    /// <summary>
    /// Specifies the player's starting point in the scenario
    /// The player rig will be placed accordingly
    /// </summary>
    [ExecuteInEditMode]
    [TrackedReference]
    public class PlayerStartPoint : BaseStartPointMarker
    {
        private const string RANDOM_START_POINT_DRAWN_MESSAGE =
            "Transform not used since RandomizedStartPoint is active";
        protected override string LabelText => "Player Start";

        public override string DrawnOverMessage => RandomizedStartPointController.Instance != null
                                                   && RandomizedStartPointController.Instance.HasStartPoints
                                                    ? RANDOM_START_POINT_DRAWN_MESSAGE
                                                    : null;
            

        protected override Color GetColour()
        {
            return Color.cyan;
        }

#if UNITY_EDITOR

        // Sanitize by ensuring there's only one instance in the scene when reloading scripts
        [DidReloadScripts]
        private static void DidReloadScripts()
        {
            waitThenSanitizeScene();
            
            async void waitThenSanitizeScene()
            {
                // Can't get objects in the same cycle sometimes
                await UniTask.Delay(100); 
                var startPoints = FindObjectsByType<PlayerStartPoint>(FindObjectsSortMode.None);

                for (int i = 1; i < startPoints.Length; i++)
                {
                    DestroyImmediate(startPoints[i].gameObject);
                }
            }
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/StartPoint/PlayerStartPoint.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/StartPoint/RandomizedStartPointController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 704fd62c717242f2a7e4568a5f2c4757
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Utilities;
using UnityEngine;

namespace Ldx.Framework.Systems.Player
{
    /// <summary>
    /// Randomizes the player start point
    /// </summary>
    public class RandomizedStartPointController : Singleton<RandomizedStartPointController>, ISaveSceneListener
    {
        [SerializeField] private PlayerStartPoint playerStartPoint;
        [SerializeField] private List<CustomStartPoint> startPoints;

        public bool HasStartPoints => startPoints.Count(s=>s.Active) > 0;

        public void OnSceneSaving()
        {
            if (playerStartPoint == null)
            {
                playerStartPoint = FindAnyObjectByType<PlayerStartPoint>();
            }

            startPoints = GetComponentsInChildren<CustomStartPoint>().ToList();
        }

        private void Start()
        {
            if (playerStartPoint == null || !HasStartPoints)
            {
                return;
            }

            List<CustomStartPoint> activePoints = startPoints.Where(p => p.Active).ToList();
            if (activePoints.Count < 1)
            {
                return;
            }

            // Have to use this since Unity's Random was returning the same number everywhere
            // Is there a seed somewhere in our code?
            System.Random random = new System.Random();
            int i = random.Next(0, activePoints.Count);
            CustomStartPoint point = activePoints[i];
            playerStartPoint.transform.position = point.transform.position;
            playerStartPoint.transform.rotation = point.transform.rotation;
        }

#if UNITY_EDITOR
        public void EDITOR_AddPoint()
        {
            GameObject obj = new GameObject("Random Start Point");
            UnityEditor.Undo.RegisterCreatedObjectUndo(obj, "Created random point");
            startPoints.Add(obj.AddComponent<CustomStartPoint>());
            obj.transform.SetParent(transform);
            obj.transform.localPosition = Vector3.zero;
            obj.transform.localRotation = Quaternion.identity;
            obj.transform.localScale = Vector3.one;
            UnityEditor.Selection.activeObject = obj;
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/StartPoint/RandomizedStartPointController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/StartPoint/SegmentCustomStartPoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e20eb7bb17f14361a4921062b570d0b8
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Systems.Player
{
    public class SegmentCustomStartPoint : BaseStartPointMarker
    {
        protected override string LabelText => "Segment Custom Start";

        protected override Color GetColour()
        {
            color ??= new Color(1f, 0.8f, 0.4f);
            return color.Value;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/StartPoint/SegmentCustomStartPoint.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/TeleportMarkerHolder.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ee65b92bde0743538c6addc711866097
# ASMDEF: ldx.framework.runtime.dll
# ---
/*using HurricaneVR.Framework.Core.Player;
using UnityEngine;

namespace Ldx.Framework.Systems.Player
{
    public class TeleportMarkerHolder : MonoBehaviour
    {
        [SerializeField] private HVRTeleportMarker teleportMarker;
        public HVRTeleportMarker TeleportMarker => teleportMarker;

        [SerializeField] private LineRenderer teleportLR;
        public LineRenderer TeleportLR => teleportLR;
    }
}*/
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/TeleportMarkerHolder.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/Waist/WaistController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6e4a2b18192b4e21b83edb55280953b0
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Autohand;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Features.SocketFilter;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Tools;
using UnityEngine;

namespace Ldx.Framework.Systems.Player.Waist
{
    /// <summary>
    /// Controls the waist setup
    /// </summary>
    public class WaistController : MonoBehaviour
    {
        public event Action<PlacePoint> OnAnyHolsterGrabbed;
        public event Action<PlacePoint> OnAnyHolsterReleased;
        
        /*[SerializeField] 
        private HVRPlayerWaist hvrPlayerWaist;
        public HVRPlayerWaist HVRPlayerWaist => hvrPlayerWaist;*/
        
        [SerializeField] 
        private PlacePoint holsterPrefab;
        [SerializeField] 
        private List<Transform> holsterPositions = new List<Transform>();

        private List<PlacePoint> activeHolsters = new List<PlacePoint>();

        private Transform holstersParentTransform = null;

        private Transform HolstersParentTransform
        {
            get
            {
                if (holstersParentTransform == null)
                {
                    holstersParentTransform = new GameObject("HolstersParent").transform;
                    holstersParentTransform.SetParent(transform);
                    holstersParentTransform.SetLocalPositionAndRotation(Vector3.zero, Quaternion.identity);
                }
                return holstersParentTransform;
            }
        }
        
        private void Awake()
        {
            holsterPositions = holsterPositions.OrderBy(t => (t.position - transform.position).sqrMagnitude).ToList();
            ScenarioManager.Instance.OnUnloadingScenarioOrLobby += HandleUnloadingScenarioOrLobby;
        }

        private void OnDestroy()
        {
            if (ScenarioManager.IsValid)
            {
                ScenarioManager.Instance.OnUnloadingScenarioOrLobby -= HandleUnloadingScenarioOrLobby;
            }
        }

        private void HandleUnloadingScenarioOrLobby(ScenarioManager manager)
        {
            activeHolsters.Clear();
        }

        public Vector3 GetWaistForward()
        {
            Vector3 dir = holsterPositions[0].position - holsterPositions[1].position;
            Vector3 left = Vector3.Cross(dir, Vector3.up).normalized;
            return left;
        }
        
        public List<PlacePoint> GetAllAvailableHolsters()
        {
            List<PlacePoint> result = new List<PlacePoint>();
            foreach (PlacePoint holster in activeHolsters)
            {
                if (!holster.HasGrabbable(out Grabbable _))
                {
                    result.Add(holster);
                }
            }

            return result;
        }
        
        public List<PlacePoint> GetAvailableHolsters(Grabbable grabbable)
        {
            List<PlacePoint> result = new List<PlacePoint>();
            foreach (PlacePoint holster in activeHolsters)
            {
                if (!holster.HasGrabbable(out Grabbable _) && holster.CanPlace(grabbable))
                {
                    result.Add(holster);
                }
            }

            return result;
        }
        
        public PlacePoint GetAvailableSocket(Grabbable grabbable)
        {
            foreach (PlacePoint holster in activeHolsters)
            {
                if (holster.CanPlace(grabbable))
                    return holster;
            }
            
            Debug.LogWarning($"Pocket not found, or all pockets are full!");
            return null;
        }

        /// <summary>
        /// Given a container of holster spawn data, spawns the holster setup
        /// </summary>
        public async UniTaskVoid SpawnHolsterSetupAsync(HolsterSpawnDataContainer holsterData)
        {
            Queue<Transform> positionTransformQueue = new Queue<Transform>(holsterPositions);
            Quaternion waistLookRotation = Quaternion.LookRotation(GetWaistForward(), Vector3.up);
            List<InteractableID> interactableIds = new();
            
            foreach (HolsterSpawnData data in holsterData)
            {
                Vector3 position = positionTransformQueue.Dequeue().position;
                if (data.SkipHolsterSlot)
                {
                    continue;
                }
                
                Vector3? globalOffset = GlobalData.Instance.GlobalHolsterOffset;
                if (globalOffset != null)
                {
                    position += waistLookRotation * globalOffset.Value;
                }

                if (data.Offset.sqrMagnitude > 0.0f)
                {
                    position += waistLookRotation * data.Offset;
                }

                PlacePoint holster = Instantiate(holsterPrefab, HolstersParentTransform);
                holster.transform.position = position;
                holster.transform.localRotation = Quaternion.identity;
    
                //TODO: here
                /*if (data.UseSocketedOffset)
                {
                    holster.EnabledHolsterOffset(data.SocketedOffset);
                }
           
                holster.ScaleGrabbable = data.ScaleGrabbable;*/
                holster.OnRemoveEvent += HandleAnyHolsterGrabbed;
                holster.OnPlaceEvent += HandleAnyHolsterReleased;
                switch (data.ColliderSettings)
                {
                    case HolsterSpawnData.ColliderSettingsType.None:
                        break;
                    case HolsterSpawnData.ColliderSettingsType.ScaleSphere:
                        holster.GetComponent<SphereCollider>().radius = data.ColliderRadius;
                        break;
                    case HolsterSpawnData.ColliderSettingsType.BoxCollider:
                        if (holster.TryGetComponent(out SphereCollider sphereCollider))
                        {
                            Destroy(sphereCollider);
                        }
                        BoxCollider boxCollider = holster.GetOrAddComponent<BoxCollider>();
                        boxCollider.isTrigger = true;
                        data.BoxColliderSettings.Apply(boxCollider);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
                
                activeHolsters.Add(holster);
                holster.gameObject.AddComponent<DestroyObjectOnUnloading>();
                if (data.HolsterFilterIDs.Count > 0 
                    && data.HolsterFilterIDs.Count(id => String.IsNullOrEmpty(id)) < data.HolsterFilterIDs.Count)
                {
                    /*IDSocketFilter filter = holster.gameObject.AddComponent<IDSocketFilter>();
                    filter.SetIDFilters(data.HolsterFilterIDs);*/
                    /*holster.SocketFilters = new[] { filter };*/
                }

                if (data.SocketedItemPrefab == null)
                {
                    continue;
                }

                // To prevent Awake() from being called before we're ready
                data.SocketedItemPrefab.SetActive(false);
                GameObject item = Instantiate(data.SocketedItemPrefab);
                Grabbable grabbable = item.GetComponentInChildren<Grabbable>();
                item.AddComponent<DestroyObjectOnUnloading>();
                /*
                if (!String.IsNullOrEmpty(data.SocketedItemFilterID))
                {
                    IDSocketable idSocketable = item.GetComponentInChildren<IDSocketable>();
                    if (idSocketable == null)
                    {
                        // We want to add it on the same object as the grabbable
                        idSocketable = grabbable.gameObject.AddComponent<IDSocketable>();
                    }
                    idSocketable.ID = data.SocketedItemFilterID;
                }
                */

                data.SocketedItemPrefab.SetActive(true);
                item.gameObject.SetActive(true);
                await UniTask.Yield();
                List<MeshRenderer> meshRenderers = new();
                meshRenderers.AddRange(item.GetComponentsInChildren<MeshRenderer>().Where(m => m.enabled));
                meshRenderers.AddRange(holster.GetComponentsInChildren<MeshRenderer>().Where(m => m.enabled));
                item.transform.position = holster.transform.position;
                /*holster.Initialize(grabbable, meshRenderers);*/
                holster.TryPlace(grabbable);
                await UniTask.Yield();

                if (!String.IsNullOrEmpty(data.InteractableID))
                {
                   InteractableID interactableId = item.GetOrAddComponent<InteractableID>();
                   interactableId.SetupRuntime(data.InteractableID);
                   interactableIds.Add(interactableId);
                }
                
                /*if (data.StartInvisible)
                {
                    holster.SetHolsterAndItemVisible(false);
                }*/
            }

            if (InteractableEventsTracker.IsValid && interactableIds.Count > 0)
            {
                InteractableEventsTracker.Instance.Register(interactableIds);
            }
        }

        private void HandleAnyHolsterGrabbed(PlacePoint point, Grabbable grabbableHand)
        {
            OnAnyHolsterGrabbed?.Invoke(point);
        }
        
        private void HandleAnyHolsterReleased(PlacePoint point, Grabbable grabbableHand)
        {
            OnAnyHolsterReleased?.Invoke(point);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Player/Waist/WaistController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Save/LdxSaveSystem.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 08566812749e33240b2c07b1f23e0ee4
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.IO;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Systems.Save
{
    public static class SaveStorageKeys
    {
        public const string FADE_FROM_LEAN = "fadeFromLean";
        public const string SMOOTH_TURN = "smoothTurnToggle";
        public const string LANGUAGE = "Language";
        public const string SMOOTH_TURN_SPEED = "smoothTurnSpeed";
        public const string SNAP_TURN_SPEED = "snapTurnSpeed";
        public const string POSITIONING_MODE = "SitStand";
    }
    
    public class LdxSaveSystem : Singleton<LdxSaveSystem>
    {
        private const int MS_TO_WAIT_BEFORE_LOADING_AT_START = 2000;
        public static event Action<LdxSaveSystem> OnSaveSystemFirstLoad;
        public static event Action<LdxSaveSystem> OnPlayerSettingsChanged;
        
        [SerializeField][ReadOnly]
        private bool fadeFromLean = true;
        public bool FadeFromLean => fadeFromLean;
        
        [SerializeField][ReadOnly]
        private bool fingerPointToId = true;
        public bool FingerPointToId => fingerPointToId;
        
        [SerializeField][ReadOnly]
        private bool smoothTurnToggle = true;
        public bool SmoothTurnToggle => smoothTurnToggle;
        
        [SerializeField][ReadOnly]
        private float smoothTurnSpeed = 100;
        public float SmoothTurnSpeed => smoothTurnSpeed;
        
        [SerializeField][ReadOnly]
        private float snapTurnSpeed = 15;
        public float SnapTurnSpeed => snapTurnSpeed;
        
        [SerializeField][ReadOnly]
        private int sitStandIndex = 0;
        public int SitStandIndex => sitStandIndex;
        
        [SerializeField][ReadOnly]
        private int currentLanguageIndex = 0;
        public int CurrentLanguageIndex => currentLanguageIndex;
        
        [SerializeField][ReadOnly]
        private bool multiLanguageSupport = true;
        public bool MultiLanguageSupport => multiLanguageSupport;
        
		private void Start()
        {
            LoadSettingsAfterDurationAsync().Forget();
            OnSaveSystemFirstLoad?.Invoke(this);
        }

        private async UniTaskVoid LoadSettingsAfterDurationAsync()
        {
            await UniTask.Delay(MS_TO_WAIT_BEFORE_LOADING_AT_START);
            LoadSettings();
        }

        [ContextMenu("Load")]
        public void LoadSettings()
        {
            fadeFromLean = IntToBool(PlayerPrefs.GetInt(SaveStorageKeys.FADE_FROM_LEAN));
            smoothTurnToggle = IntToBool(PlayerPrefs.GetInt(SaveStorageKeys.SMOOTH_TURN));
            smoothTurnSpeed = PlayerPrefs.GetFloat(SaveStorageKeys.SMOOTH_TURN_SPEED, PlayerGlobalSettings.Instance.InitialSmoothTurnSpeed);
            snapTurnSpeed = PlayerPrefs.GetFloat(SaveStorageKeys.SNAP_TURN_SPEED, PlayerGlobalSettings.Instance.InitialSnapAmount);
            sitStandIndex = PlayerPrefs.GetInt(SaveStorageKeys.POSITIONING_MODE);
            SetCurrentLanguageIndex(PlayerPrefs.GetInt(SaveStorageKeys.LANGUAGE));
            OnPlayerSettingsChanged?.Invoke(this);
        }

        private void SaveSettings()
        {
            PlayerPrefs.SetInt(SaveStorageKeys.FADE_FROM_LEAN, BoolToInt(fadeFromLean));
            PlayerPrefs.SetInt(SaveStorageKeys.SMOOTH_TURN, BoolToInt(smoothTurnToggle));
            PlayerPrefs.SetFloat(SaveStorageKeys.SMOOTH_TURN_SPEED, smoothTurnSpeed);
            PlayerPrefs.SetFloat(SaveStorageKeys.SNAP_TURN_SPEED, snapTurnSpeed);
            PlayerPrefs.SetInt(SaveStorageKeys.POSITIONING_MODE, sitStandIndex);
            PlayerPrefs.SetInt(SaveStorageKeys.LANGUAGE, currentLanguageIndex);
        }
        
        public void ResetSceneData()
        {
            string dir = Application.persistentDataPath + LdxFileHandler.Directory;

            if (Directory.Exists(dir))
            {
                Directory.Delete(dir);
            }
        }

        #region Parameters Setters
        
        public void SetFadeFromLean(bool fade)
        {
            fadeFromLean = fade;
            SaveAndBroadcastChanges();
        }
        
        public void SetSmoothTurn(bool isOn)
        {
            smoothTurnToggle = isOn;
            SaveAndBroadcastChanges();
        }

        public void SetSmoothTurnSpeed(float value)
        {
            smoothTurnSpeed = value;
            SaveAndBroadcastChanges();
        }
        
        public void SetSnapRateSpeed(float value)
        {
            snapTurnSpeed = value;
            SaveAndBroadcastChanges();
        }
        
        public void SetPositioningMode(int index)
        {
            sitStandIndex = index;
            SaveAndBroadcastChanges();
        }

        public void SetCurrentLanguageIndex(int index)
        {
            currentLanguageIndex = index;
            LocalizationModel.SetLanguage((Language)index);
            SaveAndBroadcastChanges();
        }
        
        private void SaveAndBroadcastChanges()
        {
            SaveSettings();
            OnPlayerSettingsChanged?.Invoke(this);
        }
        
        #endregion
        
        #region Helpers

        private int BoolToInt(bool value)
        {
            return value ? 1 : 0;
        }

        private bool IntToBool(int value)
        {
            return value != 0;
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Save/LdxSaveSystem.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/ActiveMainMenuBlocker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a58782f8f7b707a419acce29d7710e50
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using FluffyUnderware.DevTools;
using Ldx.Framework.Systems.UI;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using UnityEngine.UIElements;
using Utilities.Blockers;

namespace Ldx.Framework.Systems.ScenarioManagement
{
    /// <summary>
    /// Blocker set to block if there is no main menu.
    /// </summary>
    public class ActiveMainMenuBlocker : MonoBehaviour, IBlocker
    {
        public event Action<IBlocker, bool> OnBlockChanged;
        public bool IsBlocked { get; private set;}
        
        
        [SerializeField, Note(
             "This item will be blocked if there is no main menu prefab set in UIGlobalSettings.", 
             NoteAttribute.NoteType.Info)]
        private int _; //Not Drawn, attaches to Note

        
        private void Awake()
        {
            if (!UIGlobalSettings.MainMenuWindowPrefab)
                IsBlocked = true;
        }

        private void OnDestroy()
        {
            IsBlocked = false;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/ActiveMainMenuBlocker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/BaseScenario.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5e55965f941549d1a37ab9ff1f66f3aa
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.ScenarioManagement
{
    [TrackedReference]
    public abstract class BaseScenario : MonoBehaviour, ISaveSceneListener
    {
        public static event Action<BaseScenario> OnAnyScenarioStarted;
        public static event Action<BaseScenario> OnAnyScenarioCompleted;
        
        public event Action<BaseScenario> OnScenarioStarted;
        public event Action<BaseScenario, IScenarioCompletionResult> OnScenarioCompletionReported;

        protected ScenarioData ScenarioData => Parameters.Data;
        protected ScenarioDataInfoContainer ScenarioInfoContainer => Parameters.InfoContainer;
        
        public ScenarioParameters Parameters { get; private set; }

        public void OnSceneSaving()
        {
#if UNITY_EDITOR
            /*if (!LdxScenarioConfig.IsValid)
            {
                return;
            }*/

            LdxIdSettings idSettings = LdxIdSettings.GetScenarioIDSettings();
            if (idSettings == null)
            {
                return;
            }
            var scenarioData = EDITOR_GetAssociatedScenarioData();
            if (scenarioData == null)
            {
                return;
            }

            idSettings.AssociatedScenarioID = scenarioData.ScenarioID;
#endif
        }

        public virtual void StartScenario(ScenarioParameters parameters)
        {
            Parameters = parameters;
            BroadcastScenarioStarted();
            BroadcastAnyScenarioStarted();
        }
        
        protected void BroadcastAnyScenarioStarted()
        {
            OnAnyScenarioStarted?.Invoke(this);
        }
        
        protected void BroadcastScenarioStarted()
        {
            OnScenarioStarted?.Invoke(this);
        }

        protected void BroadcastAnyScenarioCompleted()
        {
            OnAnyScenarioCompleted?.Invoke(this);
        }

        protected void BroadcastScenarioCompletionReported(IScenarioCompletionResult result)
        {
            OnScenarioCompletionReported?.Invoke(this, result);
        }
#if UNITY_EDITOR
        public ScenarioData EDITOR_GetAssociatedScenarioData()
        {
            GlobalData.Instance.Initialize();
            return GlobalData.Instance.GetScenarioDataBySceneName(gameObject.scene.name);
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/BaseScenario.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/Global/BootstrapperProvider.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cecf9d3f9fe0437cae40722a51aa34dd
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.SceneManagement;
using UnityEngine;

namespace Ldx.Framework.Systems.ScenarioManagement.Data.Global
{
    public abstract class BootstrapperProvider : ScriptableObject
    {
        public abstract SceneReference GetBootstrapperScene();
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/Global/BootstrapperProvider.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/Global/BootstrapperType.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7989fa97f76b4817be511302fece83b8
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;

namespace Ldx.Framework.Systems.ScenarioManagement.Data.Global
{
    [Serializable]
    public enum BootstrapperType
    {
        Scene = 0,
        Provider
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/Global/BootstrapperType.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/GlobalData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 35977cab79b34e3084117af28144b990
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.AddOns;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.ScenarioManagement.Data.Global;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Systems.SceneManagement;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
#if UNITY_EDITOR
using UnityEditor;
#endif
using UnityEngine;

namespace Ldx.Framework.Systems.ScenarioManagement.Data
{
    /// <summary>
    /// The global scriptable object, ScenarioManager should only care about
    /// having access to this in order to process everything related to the project
    /// </summary>
    [SavePath("Assets/Resources/Data")]
    public class GlobalData : GlobalSettings<GlobalData>, ILocalizable
    {
        [SerializeField][LocalizationKey]
        private string projectTitle;
        public string ProjectTitle => projectTitle;

        [SerializeField] private Sprite projectLogo;
        public static Sprite ProjectLogo => Instance.projectLogo;
        
        [Header("Scenarios")]
        [SerializeField] 
        private List<ScenarioData> scenarioDataList = new List<ScenarioData>();

        [Header("Bootstrapper")] 
        [SerializeField]
        private BootstrapperType bootstrapperType;
        [SerializeField] 
        private SceneReference bootstrapperScene;
        [SerializeField] 
        private BootstrapperProvider bootstrapperProvider;
        public SceneReference BootstrapperScene => GetBootstrapperScene();

        [Header("Add-On Configs")]
        [SerializeField]
        [InheritedClassContainer(typeof(AddOnConfig), suffixToRemove: "AddOnConfig", uniqueItemsOnly: true, drawAddRemoveButtons: false)]
        private AddOnConfigsContainer addOnsConfigs = new();
        public AddOnConfigsContainer AddOnsConfigs => addOnsConfigs;
        
        [Header("Lobby")]
        [SerializeField]
        private SceneReference lobbyScene;
        public SceneReference LobbyScene => lobbyScene;

        [Header("Tutorial")]
        [SerializeField]
        private ScenarioData basicsTutorialData;
        public ScenarioData BasicsTutorialData => basicsTutorialData;
        
        [Header("Startup Loading")]
        [SerializeField] 
        private StartupLoadingMode startupLoadingMode = StartupLoadingMode.LoadLobby;
        public StartupLoadingMode StartupLoadingMode => startupLoadingMode;

        [SerializeField] 
        [ShowIf("startupLoadingMode", Op.Equals, Data.StartupLoadingMode.LoadLobby)]
        private Sprite lobbyLogo;
        public Sprite LobbyLogo => lobbyLogo;
        
        [Header("Global Scenario Options")] 
        [SerializeField]
        [InheritedClassContainer(typeof(GlobalScenarioOption), suffixToRemove: "Option")]
        private GlobalScenarioOptionsContainer globalScenarioOptions = new();

        [Header("Global Rig Settings")]
        [SerializeField]
        private bool addGlobalHolsterOffset;

        [ShowIf("addGlobalHolsterOffset", Op.Equals, true)]
        [SerializeField] 
        private Vector3 globalHolsterOffset;
        public Vector3? GlobalHolsterOffset => addGlobalHolsterOffset ? globalHolsterOffset : null;
        
        private readonly Dictionary<string, ScenarioData> sceneNameToScenarioMap = new Dictionary<string, ScenarioData>();
        private readonly Dictionary<string, ScenarioData> idToScenarioMap = new Dictionary<string, ScenarioData>();
        private readonly Dictionary<string, ScenarioData> scenarioIdToScenarioMap = new Dictionary<string, ScenarioData>();

        public void Initialize()
        {
            Instance.InitializeMaps();
        }

        private void InitializeMaps()
        {
            sceneNameToScenarioMap.Clear();
            idToScenarioMap.Clear();
            scenarioIdToScenarioMap.Clear();
            
            foreach (ScenarioData data in scenarioDataList)
            {
                if (data.SceneReference?.ScenePath == null)
                {
                    Debug.LogError($"Scene name to scenario map error: scenario {data.ID} has no scene assigned");
                }
                else
                {
                    string sceneName = data.SceneReference.GetSceneName();
                    if (!sceneNameToScenarioMap.TryAdd(sceneName, data))
                    {
                        Debug.LogError("Scene name to scenario map error: scene already assigned to another scenario");
                    }
                }
                
                if (string.IsNullOrEmpty(data.ID))
                {
                    Debug.LogError($"Scenario {data.name} has no ID assigned");
                }
                else
                {
                    if (!idToScenarioMap.TryAdd(data.ID, data))
                    {
                        Debug.LogError("Scene id to scenario map error: id already assigned to another scenario");
                    }
                }

                if (string.IsNullOrEmpty(data.ScenarioID))
                {
                    IDInfo info = new IDInfo(StringUtilities.GenerateUniqueId(), data.ID);
                    data.ScenarioID = info.ID;
                    LdxIdSettings.GlobalInstance.ScenarioIDs.Add(info);
#if UNITY_EDITOR
                    EditorUtility.SetDirty(LdxIdSettings.GlobalInstance);
                    EditorUtility.SetDirty(data);
#endif
                }

                if (!scenarioIdToScenarioMap.TryAdd(data.ScenarioID, data))
                {
                    Debug.LogError(
                        "Scenario id to scenario map error: Scenario id already assigned to another scenario");
                }
            }
        }

        public int GetScenarioDataIndex(ScenarioData data)
        {
            return scenarioDataList.IndexOf(data);
        }
        
        public ScenarioData GetScenarioData(int index)
        {
            return scenarioDataList[index];
        }

        public ScenarioData GetScenarioData(string id)
        {
            if(!idToScenarioMap.TryGetValue(id, out ScenarioData data))
            {
                Debug.LogWarning($"Can't find scenario with ID {id} in GlobalData");
            }
            else
            {
                return data;
            }
            
            if(!scenarioIdToScenarioMap.TryGetValue(id, out data))
            {
                Debug.LogError($"Can't find scenario with Scenario ID {id} in GlobalData");
                return null;
            }
            
            return data;
        }

        public GlobalScenarioOptionsContainer GetGlobalScenarioOptions()
        {
            return new GlobalScenarioOptionsContainer(globalScenarioOptions);
        }

        public List<ScenarioData> GetScenarioDataList(int startIndex = 0)
        {
            List<ScenarioData> list = new List<ScenarioData>();
            for (int i = startIndex; i < scenarioDataList.Count; i++)
            {
                list.Add(scenarioDataList[i]);
            }

            return list;
        }

        public ScenarioDataInfoContainer GetScenarioDataInfo()
        {
            ScenarioDataInfoContainer container = new ScenarioDataInfoContainer();
            container.LobbyLogo = lobbyLogo;
            container.ProjectTitle = projectTitle;

            bool showBasicsTutorialFirst = globalScenarioOptions.Any(o => o is ShowBasicsTutorialFirst);
            
            container.Add(scenarioDataList
                .Select(d => new ScenarioDataInfo(d)).ToList());
            
            if (basicsTutorialData != null)
            {
                ScenarioDataInfo tutorialInfo = new ScenarioDataInfo(basicsTutorialData);
                if (showBasicsTutorialFirst)
                {
                    container.Insert(0, tutorialInfo);
                }
                else
                {
                    container.Add(tutorialInfo);
                }
            }
            
            return container;
        }

        public ScenarioData GetScenarioDataBySceneName(string sceneName)
        {
            if (!sceneNameToScenarioMap.TryGetValue(sceneName, out ScenarioData data))
            {
                return null;
            }

            return data;
        }

        public bool HasScenarioAtIndex(int index)
        {
            return index > 0 && index < scenarioDataList.Count;
        }

        private SceneReference GetBootstrapperScene()
        {
            if (bootstrapperType == BootstrapperType.Provider)
            {
                return bootstrapperProvider.GetBootstrapperScene();
            }
            
            return bootstrapperScene;
        }

        public void ProcessLocalizationKeys(LocalizationTable table)
        {
            table.ProcessLocalizationKey(ref projectTitle);
        }
#if UNITY_EDITOR
        [UnityEditor.SettingsProvider]
        public static UnityEditor.SettingsProvider CreateSettingsProvider()
        {
            return CreateGlobalSettingsProvider("Project/LDX/Project/Global");
        }

        public void EDITOR_AddScenarioToGlobalData(ScenarioData scenarioData)
        {
            if (scenarioDataList.Contains(scenarioData))
            {
                return;
            }
            
            scenarioDataList.Add(scenarioData);
            EditorUtility.SetDirty(this);
        }
        
        public void EDITOR_RemoveScenarioFromGlobalData(ScenarioData scenarioData)
        {
            if (!scenarioDataList.Contains(scenarioData))
            {
                return;
            }
            
            scenarioDataList.Remove(scenarioData);
            EditorUtility.SetDirty(this);
        }

        public void EDITOR_ChangeScenarioIndex(ScenarioData scenarioData, int index)
        {
            if (index < 0 || index >= scenarioDataList.Count)
            {
                return;
            }

            scenarioDataList.Remove(scenarioData);
            scenarioDataList.Insert(index, scenarioData);
            EditorUtility.SetDirty(this);
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/GlobalData.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/ObjectiveData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b98422180aeb4b08a3f6bb53ab132e3c
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Ldx.Framework.Systems.ScenarioManagement.Data
{
    /// <summary>
    /// Contains all objective related data to be created with the scenario data
    /// </summary>
    [CreateAssetMenu(fileName = "ObjectiveData", menuName = "LogicalDox/Scenario/ObjectiveData")]
    public class ObjectiveData : ScriptableObject
    {
        [SerializeField]
        private List<Objective> objectives = new List<Objective>();

        public List<Objective> Objectives => objectives;
        public int ObjectivesCount => Objectives.Count;


        public bool EditorOverrideStartObjectiveStep
        {
            get => this.TryGetObjectivesStepOverrideIndex(out int index);
            set
            {
                if (value == EditorOverrideStartObjectiveStep)
                {
                    return;
                }

                int i = value ? 0 : -1;
                this.SetObjectivesStepOverrideIndex(i);
            }
        }


        /// <summary>
        /// At runtime: if this is null, no desired override is set
        /// </summary>
        public int? ObjectivesStepOverrideIndex
        {
            get
            {
                if (!this.TryGetObjectivesStepOverrideIndex(out int index))
                {
                    return null;
                }
                return index;
            }
            set
            {
                if (value == null)
                {
                    return;
                }
                this.SetObjectivesStepOverrideIndex(value.Value);
            }
        }

        [Hide]
        [SerializeField] 
        private string displayName;
        
        public string DisplayName
        {
            get => displayName;
            set => displayName = value;
        }

        private void OnValidate()
        {
            bool shouldSetDirty = false;
            
            foreach (Objective objective in objectives)
            {
                shouldSetDirty = objective.OnValidate() || shouldSetDirty;

                objective.TryGenerateId();

                foreach (ObjectiveEventData eventData in objective.EventDataContainer)
                {
                    eventData?.TryGenerateId();
                }

                foreach (SubObjective childObjective in objective.ChildObjectives.Where(childObjective => childObjective != null))
                {
                    childObjective.TryGenerateId();
                    
                    foreach (ObjectiveEventData eventData in childObjective.EventDataContainer)
                    {
                        eventData?.TryGenerateId();
                    }
                }
            }

            if (shouldSetDirty)
            {
#if UNITY_EDITOR
                EditorUtility.SetDirty(this);
#endif
            }
        }

#if UNITY_EDITOR
        
        [ContextMenu("Regenerate duplicate IDs")]
        public void EDITOR_RegenerateDuplicateIDs()
        {
            List<string> ids = new List<string>();
            foreach (Objective objective in objectives)
            {
                foreach (ObjectiveEventData objectiveEventData in objective.EventDataContainer)
                {
                    while (ids.Contains(objectiveEventData.ID))
                    {
                        objectiveEventData.TryGenerateId(true);
                    }
                    
                    ids.Add(objectiveEventData.ID);
                }
                
                foreach (SubObjective subObjective in objective.ChildObjectives)
                {
                    foreach (ObjectiveEventData objectiveEventData in subObjective.EventDataContainer)
                    {
                        while (ids.Contains(objectiveEventData.ID))
                        {
                            objectiveEventData.TryGenerateId(true);
                        }
                    
                        ids.Add(objectiveEventData.ID);
                    }
                }
            }
                        
            EDITOR_SetDirtyAndSave();
        }
        public List<BaseObjective> EDITOR_GetAllRegisteredObjectives()
        {
            var allObjectives = new List<BaseObjective>();
            foreach (Objective objective in objectives)
            {
                allObjectives.Add(objective);
                foreach (SubObjective subObjective in objective.ChildObjectives)
                {
                    allObjectives.Add(subObjective);
                }
            }
            
            return allObjectives;
        }

        public List<ObjectiveEventData> EDITOR_GetAllRegisteredEventData()
        {
            List<BaseObjective> objectives = EDITOR_GetAllRegisteredObjectives();
            List<ObjectiveEventData> eventDataList = new();
            foreach (BaseObjective o in objectives)
            {
                foreach (ObjectiveEventData eventData in o.EventDataContainer)
                {
                    if (eventData == null)
                    {
                        Debug.LogError($"Alert: A null ObjectiveEventData was found in objective {o.Name}!");
                        continue;
                    }
                    
                    eventDataList.Add(eventData);
                }
            }

            return eventDataList;
        }

        public List<Type> EDITOR_GetAllRegisteredEventDataTypes()
        {
            List<ObjectiveEventData> eventDataList = EDITOR_GetAllRegisteredEventData();
            HashSet<Type> types = new();
            foreach (ObjectiveEventData eventData in eventDataList)
            {
                Type t = eventData.GetType();
                if (types.Contains(t))
                {
                    continue;
                }

                types.Add(t);
            }

            return new List<Type>(types);
        }

        public bool EDITOR_HasAnyInteractionEvents()
        {
            return EDITOR_GetAllRegisteredEventData().Any(e =>
                e != null && e.TriggerEventInfo.EventType == ObjectiveEventData.TriggerEventType.Interaction);
        }
        
        public void EDITOR_DeleteObjective(BaseObjective delete)
        {
            if (delete is Objective objective)
            {
                objectives.Remove(objective);
                return;
            }

            if (delete is SubObjective subObjective)
            {
                foreach (Objective parent in objectives)
                {
                    if (parent.ChildObjectives.Contains(subObjective))
                    {
                        parent.ChildObjectives.Remove(subObjective);
                        break;
                    }
                }
            }
            
            EDITOR_SetDirtyAndSave();
        }
        
        public int EDITOR_GetObjectiveIndex(Objective objective)
        {
            for (int i = 0; i < objectives.Count; i++)
            {
                if (objectives[i] == objective)
                {
                    return i;
                }
            }

            return 0;
        }

        public void EDITOR_DuplicateObjective(Objective duplicate)
        {
            Objective newObjective = new(duplicate);
            objectives.Add(newObjective);
            EDITOR_SetDirtyAndSave();
        }
        
        public void EDITOR_DuplicateObjective(Objective parent, SubObjective duplicate)
        {
            SubObjective newObjective = new SubObjective(duplicate);
            parent.EDITOR_AddSubObjective(newObjective);
            EDITOR_SetDirtyAndSave();
        }
        
        public Objective EDITOR_CreateNewObjective(int atIndex = -1)
        {
            Objective newObjective = Objective.EDITOR_CreateNewObjective(ObjectiveType.ParallelGroup);
            newObjective.Name = $"New Objective {objectives.Count}";
            newObjective.TryGenerateId();
            if (atIndex >= 0 && atIndex < objectives.Count)
            {
                objectives.Insert(atIndex, newObjective);
            }
            else
            {
                objectives.Add(newObjective);
            }
            
            EDITOR_SetDirtyAndSave();
            return newObjective;
        }

        public Objective EDITOR_FindParentOfSubObjective(SubObjective subObjective, out int index)
        {
            foreach (Objective objective in objectives)
            {
                for (int i = 0; i < objective.ChildObjectives.Count; i++)
                {
                    if (objective.ChildObjectives[i] == subObjective)
                    {
                        index = i;
                        return objective;
                    }
                }
            }

            index = -1;
            return null;
        }
        
        public SubObjective EDITOR_CreateNewSubObjective(Objective parent, int atIndex = -1)
        {
            if (parent == null || !objectives.Contains(parent))
            {
                return null;
            }
            
            SubObjective newSubObjective = SubObjective.EDITOR_CreateNewChildObjective();
            newSubObjective.Name = $"New Child Objective {parent.ChildObjectives.Count}";
            newSubObjective.TryGenerateId();
            if (atIndex >= 0 && atIndex < parent.ChildObjectives.Count)
            {
                parent.ChildObjectives.Insert(atIndex, newSubObjective);
            }
            else
            {
                parent.ChildObjectives.Add(newSubObjective);
            }

            EDITOR_SetDirtyAndSave();
            return newSubObjective;
        }

        public void EDITOR_MoveObjective(BaseObjective baseObjective, int newIndex)
        {
            if (baseObjective == null)
            {
                return;
            }

            if (baseObjective is Objective objective)
            {
                objectives.Remove(objective);
                objectives.Insert(newIndex, objective);
            }
            else if(baseObjective is SubObjective subObjective)
            {
                Objective parent = objectives.FirstOrDefault(x => x.ChildObjectives.Contains(subObjective));
                if (parent != null)
                {
                    parent.ChildObjectives.Remove(subObjective);
                    parent.ChildObjectives.Insert(newIndex, subObjective);
                }
            }
            
            EDITOR_SetDirtyAndSave();
        }
        
        public void EDITOR_DeleteObjectiveEventDataByTrigger(BaseObjective objective, TriggerEventInfo triggerEventInfo)
        {
            if (objective == null || triggerEventInfo == null)
            {
                return;
            }

            List<ObjectiveEventData> eventDataToDelete = objective.EventDataContainer
                .Where(eventData => eventData.TriggerEventInfo.Equals(triggerEventInfo)).ToList();

            foreach (ObjectiveEventData eventData in eventDataToDelete)
            {
                EDITOR_DeleteObjectiveEvent(objective, eventData);
            }
        }

        public void EDITOR_DeleteObjectiveEvent(BaseObjective objective, ObjectiveEventData eventData)
        {
            objective.EDITOR_DeleteEventData(eventData); 
            EDITOR_SetDirtyAndSave();
        }
        
        public void EDITOR_SetDirtyAndSave()
        {
            EditorUtility.SetDirty(this);
            AssetDatabase.SaveAssets(); 
            AssetDatabase.Refresh();
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/ObjectiveData.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/ObjectiveDataSessionHelper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 94e01d786d03445ca737495c8919f26e
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Ldx.Framework.Systems.ScenarioManagement.Data
{
    /// <summary>
    /// Helper for objective data session operations
    /// </summary>
    public static class ObjectiveDataSessionHelper
    {
        private const string SESSION_KEY_PREFIX = "OBJECTIVE_DATA_SESSION";
        private const string OVERRIDE_INDEX_KEY_SUFFIX = "OVERRIDE_INDEX";
        
        public static bool TryGetObjectivesStepOverrideIndex(this ObjectiveData objectiveData, out int index)
        {
            index = 0;
#if !UNITY_EDITOR
            return false;
#else
            string key = GetOverrideIndexSessionKey(objectiveData);
            int overrideIndex = SessionState.GetInt(key, -1);
            if (overrideIndex < 0)
            {
                return false;
            }

            index = overrideIndex;
            return true;
#endif
        }

        public static void SetObjectivesStepOverrideIndex(this ObjectiveData objectiveData, int index)
        {
#if !UNITY_EDITOR
            return;
#else
            string key = GetOverrideIndexSessionKey(objectiveData);
            SessionState.SetInt(key, index);
#endif   
        }

        public static string GetOverrideIndexSessionKey(ObjectiveData objectiveData)
        {
            return $"{GetObjectiveDataSessionKey(objectiveData)}_{OVERRIDE_INDEX_KEY_SUFFIX}";
        }
        
        public static string GetObjectiveDataSessionKey(ObjectiveData objectiveData)
        {
            return $"{SESSION_KEY_PREFIX}_{GetDataID(objectiveData)}";
        }
        
        public static string GetDataID(ObjectiveData objectiveData)
        {
#if !UNITY_EDITOR
            return string.Empty;
#else
            if (objectiveData == null)
            {
                return string.Empty;
            }

            string assetPath = AssetDatabase.GetAssetPath(objectiveData);

            if (string.IsNullOrEmpty(assetPath))
            {
                Debug.LogError("The provided ObjectiveData is not a valid asset in the project.");
                return string.Empty;
            }

            string directoryPath = System.IO.Path.GetDirectoryName(assetPath);
            string directoryName = System.IO.Path.GetFileName(directoryPath);
            return directoryName;
#endif
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/ObjectiveDataSessionHelper.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/PlayerRigData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 50214f90d7a44e2bb85bb5998002cd7f
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Features.SocketFilter;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.Player.PlayerRig;
using Ldx.Framework.Utilities.Tools;
using UnityEngine;

namespace Ldx.Framework.Systems.ScenarioManagement.Data
{
    /// <summary>
    /// Data file for defining data related to the player rig in the scenario
    /// </summary>
    [CreateAssetMenu(fileName ="PlayerRigData", menuName ="LogicalDox/Scenario/PlayerRigData")]
    public class PlayerRigData : ScriptableObject
    {
        [SerializeField] 
        private PlayerRigOverridesContainer overrides = new PlayerRigOverridesContainer();

        public PlayerRigCapture GetCaptureWithOverrides(PlayerRigCapture capture)
        {
            return capture.GetCaptureWithOverrides(overrides);
        }
    }

    /// <summary>
    /// Class that represents a capture of the player rig that can be used to apply
    /// to the rig later or after modification
    /// </summary>
    public class PlayerRigCapture
    {
        // HVRPlayerController
        public bool CanJump { get; set; }
        public bool CanCrouch { get; set; }
        public bool CanSteerWhileJumping { get; set; }
        public bool CanSprint { get; set; }
        public float MinHeight { get; set; }
        public float Gravity { get; set; }
        public CameraClearFlags CameraClearFlags { get; set; }
        public List<GameObject> WaistChildPrefabs { get; set; } = new List<GameObject>();
        public HolsterSpawnDataContainer HolsterSpawnDataContainer { get; set; }
        public MaxDropData MaxDropData { get; set; } = new MaxDropData();

        // HVR
        public bool TeleporterEnabled { get; set; } = true;
        public bool JoystickMovementEnabled { get; set; } = true;
        public bool HVRPlayerControllerEnabled { get; set; } = true;
        public bool HeadCollisionPushesBack { get; set; }
        
        /*// Hands material
        public Material LeftHandMaterial { get; set; }
        public Material RightHandMaterial { get; set; }*/

        // CameraRig
        public float EyeHeight { get; set; } = 1.66f;
        private float InitialEyeHeight { get; set; }
        public bool ChangedEyeHeight => EyeHeight != InitialEyeHeight;
        public float FarClipPlane { get; set; } = 2500;

        /// <summary>
        /// Returns a recorded capture from the player controller 
        /// </summary>
        public static PlayerRigCapture GetCapture(PlayerController controller)
        {
            return new PlayerRigCapture()
            {
                /*CanJump = controller.CanJump,
                /*CanCrouch = controller.HVRPlayerController.CanCrouch,
                CanSteerWhileJumping = controller.CanSteerWhileJumping,
                CanSprint = controller.CanSprint,
                DirectionStyle = controller.DirectionStyle,
                MinHeight = controller.MinHeight,
                Gravity = controller.Gravity,*/
                TeleporterEnabled = controller.Teleporter.enabled,
                /*HeadCollisionPushesBack = controller.HVRPlayerController.HeadCollisionPushesBack,*/
                CameraClearFlags = controller.MainCamera.clearFlags,
                HVRPlayerControllerEnabled = controller.IsPlayerControllerEnabled,
                JoystickMovementEnabled = controller.IsMovementEnabled,
                /*MaxDropData = new MaxDropData(controller.HVRTeleporter.CheckDropDistance, controller.HVRTeleporter.MaxDropDistance),*/
                /*LeftHandMaterial = controller.HandsController.HandSideToSkin[HandSide.Left].Select(r => r.sharedMaterial).FirstOrDefault(),
                RightHandMaterial = controller.HandsController.HandSideToSkin[HandSide.Left].Select(r => r.sharedMaterial).FirstOrDefault(),*/
                /*EyeHeight = controller.CameraRig.EyeHeight,*/
                FarClipPlane = controller.MainCamera.farClipPlane
            };
        }

        /// <summary>
        /// Given a set of overrides, returns a version of
        /// this capture with the applied overrides
        /// </summary>
        public PlayerRigCapture GetCaptureWithOverrides(PlayerRigOverridesContainer overrides)
        {
            PlayerRigCapture result = Clone();
            foreach (PlayerRigOverride rigOverride in overrides)
            {
                rigOverride.ApplyToDataCapture(result);
            }

            return result;
        }

        /// <summary>
        /// Applies this capture's state to a player controller
        /// </summary>
        public void Apply(PlayerController controller)
        {
            /*controller.HVRPlayerController.CanCrouch = CanCrouch;*/
            controller.Teleporter.enabled = TeleporterEnabled;
            controller.SetJoystickMovementEnabled(JoystickMovementEnabled);
            /*controller.HVRPlayerController.HeadCollisionPushesBack = HeadCollisionPushesBack;*/
            controller.MainCamera.clearFlags = CameraClearFlags;
            //---Unity oddity block start
            // Changing the clear flags doesn't work for some reason through script unless
            // I disable then reenable the camera
            controller.MainCamera.enabled = false;
            controller.MainCamera.enabled = true;
            //---Unity oddity block end
            
            // Waist Child Prefabs
            foreach (GameObject prefab in WaistChildPrefabs)
            {
                //TODO: check that spawning is correct
                GameObject obj = Object.Instantiate(prefab, controller.WaistController.transform);
                obj.AddComponent<DestroyObjectOnUnloading>();
            }
            
            // Holster spawn data
            if (HolsterSpawnDataContainer != null)
            {
                controller.WaistController.SpawnHolsterSetupAsync(HolsterSpawnDataContainer).Forget();
            }

            controller.SetPlayerControllerEnabled(HVRPlayerControllerEnabled);
            
            /*// Max drop distance data
            if (MaxDropData != null)
            {
                controller.HVRTeleporter.CheckDropDistance = MaxDropData.CheckDropDistance;
                controller.HVRTeleporter.MaxDropDistance = MaxDropData.MaxDropDistance;
            }*/
            
            /*controller.HandsController.SetHandsMaterials(LeftHandMaterial, RightHandMaterial);*/

            /*controller.CameraRig.EyeHeight = EyeHeight;*/
            controller.MainCamera.farClipPlane = FarClipPlane;
        }

        /// <summary>
        /// Clones this capture and returns one with identical data
        /// </summary>
        public PlayerRigCapture Clone()
        {
            return new PlayerRigCapture
            {
                CanJump = CanJump,
                CanCrouch = CanCrouch,
                CanSteerWhileJumping = CanSteerWhileJumping,
                CanSprint = CanSprint,
                MinHeight = MinHeight,
                Gravity = Gravity,
                TeleporterEnabled = TeleporterEnabled,
                JoystickMovementEnabled = JoystickMovementEnabled,
                HeadCollisionPushesBack = HeadCollisionPushesBack,
                CameraClearFlags = CameraClearFlags,
                WaistChildPrefabs = new List<GameObject>(WaistChildPrefabs),
                HolsterSpawnDataContainer = HolsterSpawnDataContainer,
                MaxDropData = MaxDropData,
                HVRPlayerControllerEnabled = HVRPlayerControllerEnabled,
                /*LeftHandMaterial = LeftHandMaterial,
                RightHandMaterial = RightHandMaterial,*/
                EyeHeight = EyeHeight,
                FarClipPlane = FarClipPlane
            };
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/PlayerRigData.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/Scenario/GlobalScenarioOption.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 38d9ca0b5da64a62b5507aa5607171b5
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.Localization;
using UnityEngine;

namespace Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios
{
    [Serializable]
    public abstract class GlobalScenarioOption
    {
    }
    
    [Serializable]
    public class GlobalScenarioOptionsContainer : IEnumerable<GlobalScenarioOption>
    {
        [SerializeReference] private List<GlobalScenarioOption> options = new();

        public GlobalScenarioOptionsContainer(){}

        public GlobalScenarioOptionsContainer(GlobalScenarioOptionsContainer container)
        {
            options = new(container);
        }
        
        public bool TryGet<T>(out T foundOption) where T : GlobalScenarioOption
        {
            foundOption = options.FirstOrDefault(o => o is T) as T;
            return foundOption != null;
        }
        
        public IEnumerator<GlobalScenarioOption> GetEnumerator()
        {
            return options.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }

    [Serializable]
    public class ShowBasicsTutorialFirst : GlobalScenarioOption
    {
    }

    [Serializable]
    public class DisableScenariosPage : GlobalScenarioOption
    {
    }

    [Serializable]
    public class EndScenarioPageOverrideSettings : GlobalScenarioOption
    {
        [SerializeField] private bool showRestartTrainingButtonAtTheEnd;
        public bool ShowRestartTrainingButtonAtTheEnd => showRestartTrainingButtonAtTheEnd;

        [SerializeField] private bool overrideRestartTrainingText;
        public bool OverrideRestartTrainingText => overrideRestartTrainingText;

        [LocalizationKey]
        [SerializeField] private string restartTrainingTextOverride;
        public string RestartTrainingTextOverride => restartTrainingTextOverride;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/Scenario/GlobalScenarioOption.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/Scenario/ScenarioDataInfo.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4a30c51c350e4b33a5a12d31ad0a3d41
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using Ldx.Framework.Systems.SceneManagement;
using UnityEngine;

namespace Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios
{
    /// <summary>
    /// Class that captures display data from a scenario
    /// without revealing the reference 
    /// </summary>
    [Serializable]
    public class ScenarioDataInfo
    {
        public string ID { get; }
        public string ScenarioName { get; }
        public string Description { get; }
        public Sprite PreviewImage { get; }
        public bool IncludeInMenuSelectionList { get; }
        public ScenarioDataType Type { get; }
        public SceneReference SceneReference { get; }
        public List<SceneReference> AdditionalScenes { get; }
        public bool CopyRenderSettingsFromAdditionalScene { get; }
        
        public ScenarioDataInfo(ScenarioData data)
        {
            ID = data.ID;
            ScenarioName = data.ScenarioName;
            Description = data.Description;
            PreviewImage = data.PreviewImage;
            IncludeInMenuSelectionList = data.IncludeInMenuSelectionList;
            Type = data.Type;
            SceneReference = data.SceneReference;
            AdditionalScenes = data.AdditionalScenes;
            CopyRenderSettingsFromAdditionalScene = data.CopyRenderSettingsFromAdditionalScene;
        }
    }
    
    [Serializable]
    public class ScenarioDataInfoContainer : IEnumerable<ScenarioDataInfo>
    {
        [SerializeField] 
        private List<ScenarioDataInfo> infoList = new List<ScenarioDataInfo>();

        public int Count => infoList.Count;
        public ScenarioDataInfo this[int i] => infoList[i];
        public Sprite LobbyLogo { get; set; }
        public string ProjectTitle { get; set; }
        public bool HasLobbyLogo => LobbyLogo != null;
        
        public void Add(ScenarioDataInfo info)
        {
            if (infoList.Contains(info))
            {
                return;
            }
            infoList.Add(info);
        }

        public void Add(List<ScenarioDataInfo> dataInfo)
        {
            foreach (ScenarioDataInfo info in dataInfo)
            {
                Add(info);
            }
        }

        public void Insert(int index, ScenarioDataInfo info)
        {
            infoList.Insert(index, info);
        }
        
        public IEnumerator<ScenarioDataInfo> GetEnumerator()
        {
            return infoList.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/Scenario/ScenarioDataInfo.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/Scenario/ScenarioDataType.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c134220a351549739f7e97cdd31e9143
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;

namespace Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios
{
    /// <summary>
    /// Type of the scenario data
    /// </summary>
    [Serializable]
    public enum ScenarioDataType
    {
        Scenario = 0,
        Cutscene,
        Lobby,
        Tutorial
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/Scenario/ScenarioDataType.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/Scenario/ScenarioEndTypes.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ae4f99df04be4c13a155c18c8bda0684
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;

namespace Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios
{
    /// <summary>
    /// Specifies the options for the way a scenario should end
    /// </summary>
    [Serializable]
    public enum ScenarioEndTypes
    {
        AllObjectivesCompleted = 0,
        ManualScenarioCompletion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/Scenario/ScenarioEndTypes.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/ScenarioData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 144b6b54eca94aa9999ad09252bf997c
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.IO;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Scripts.Systems.Scoring;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Systems.SceneManagement;
using Ldx.Framework.Utilities.Async;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Systems.ScenarioManagement.Data
{
    /// <summary>
    /// Data for a specific scenario
    /// </summary>
    public class ScenarioData : ScriptableObject, ILocalizable
    {
        public static event Action<ScenarioData> OnDataCreated;
        
        private static char Separator => Path.DirectorySeparatorChar;
        private static string ScenariosPath => $"Assets{Separator}Resources{Separator}Data{Separator}Scenarios";

        [Header("Scenario Info")]
        [IDSelection(LdxIdSettings.IdType.Scenario)]
        [SerializeField]
        private string scenarioId;
        public string ScenarioID
        {
            get => scenarioId;
            set => scenarioId = value;
        }

        [ReadOnly]
        [SerializeField] 
        private string id;
        public string ID => id;
        
        [SerializeField][LocalizationKey]
        private string scenarioName;
        public string ScenarioName => scenarioName;
        public string ScenarioNameLocalized => LocalizationModel.UseLocalization ? LocalizationModel.GetTextString(ScenarioName, Language.English) : ScenarioName;

        [SerializeField][LocalizationKey]
        private string description;
        public string Description => description;
        
        [SerializeField] 
        private Sprite previewImage;
        public Sprite PreviewImage => previewImage;
        
        [SerializeField] 
        private ScenarioDataType type = ScenarioDataType.Scenario;

        public ScenarioDataType Type
        {
            get => type;
#if UNITY_EDITOR
            set => type = value;
#endif
        }
        
        [SerializeField]
        private List<ObjectiveData> objectiveDataList = new();
        public List<ObjectiveData> ObjectiveDataList => objectiveDataList;

        [SerializeField]
        private bool includeInMenuSelectionList = true; 
        public bool IncludeInMenuSelectionList => includeInMenuSelectionList;
        
        [SerializeField] 
        private bool copyRenderSettingsFromAdditionalScene = true;
        public bool CopyRenderSettingsFromAdditionalScene => copyRenderSettingsFromAdditionalScene;
        
        [SerializeField]
        private bool displayLoadingIcon = true; 
        public bool DisplayLoadingIcon => displayLoadingIcon;

        [Header("Scoring")]
        [SerializeField] private ScoringData scoringData;
        public ScoringData ScoringData => scoringData;
        
        [Header("Scenario End")]
        [SerializeField] 
        private ScenarioEndTypes scenarioEndType;
        public ScenarioEndTypes ScenarioEndType => scenarioEndType;

        public enum ScenarioEndBehaviourType
        {
            ShowEndScreen = 0,
            LoadNextScenarioOrLobby = 1,
            LoadLobby = 2,
            LoadFirstScenario = 3,
        }
        
        [SerializeField] private ScenarioEndBehaviourType scenarioEndBehaviour = ScenarioEndBehaviourType.LoadNextScenarioOrLobby;
        public ScenarioEndBehaviourType ScenarioEndBehaviour => scenarioEndBehaviour;
        
        [Header("Scenes")]
        [SerializeField]
        private SceneReference sceneReference;

        public SceneReference SceneReference
        {
            get => sceneReference;
            set => sceneReference = value;
        }
        
        [SerializeField] 
        private List<SceneReference> additionalScenes = new List<SceneReference>();

        public List<SceneReference> AdditionalScenes
        {
            get => additionalScenes;
            set => additionalScenes = value;
        }
        
        private PlayerRigData playerRigData;
        public PlayerRigData PlayerRigData => playerRigData;
        
        public AsyncOperationGroup LoadDataAsync()
        {
            AsyncOperationGroup operations = new AsyncOperationGroup();
            operations.AddAssetRequestAsync<PlayerRigData>(GetDataFileRequest<PlayerRigData>(),
                data => playerRigData = data).Forget();
            return operations;
        }

        public void UnloadData()
        {
            if (objectiveDataList != null)
            {
                foreach (ObjectiveData data in objectiveDataList)
                {
                    Resources.UnloadAsset(data);
                }
            }
            if (playerRigData != null)
            {
                Resources.UnloadAsset(playerRigData);
            }
        }

        private ResourceRequest GetDataFileRequest<T>() where T : ScriptableObject
        {
            return Resources.LoadAsync(GetLoadDataFilePath<T>(id));
        }

        private static string GetSaveDataFilePath<T>(string id)
        {
            string fileName = $"{typeof(T).Name}_{id}";
            return $"{ScenariosPath}{Separator}{id}{Separator}{fileName}.asset";
        }
        
        public static string GetLoadDataFilePath<T>(string id) where T : UnityEngine.Object
        {
            string resourcesBasePath = Path.Combine(
                ScenariosPath.Replace($"Assets{Path.DirectorySeparatorChar}Resources{Path.DirectorySeparatorChar}", ""), 
                id);
            
            string newFileName = $"{typeof(T).Name}_{id}";
            string newResourcesPath = Path.Combine(resourcesBasePath, newFileName);

            T assetCheck = Resources.Load<T>(newResourcesPath);
            if (assetCheck != null)
            {
                // SUCCESS: The asset with the new name was found.
                Resources.UnloadAsset(assetCheck);
                return newResourcesPath;
            }

            // FAIL: The new asset was not found. Fall back to the old name.
            string oldFileName = typeof(T).Name;
            string oldResourcesPath = Path.Combine(resourcesBasePath, oldFileName);
            return oldResourcesPath;
        }
        
#if UNITY_EDITOR
        [ContextMenu("AssignData")]
        private void EDITOR_AssignData()
        {
            EDITOR_LoadObjectiveData();
            
            if (playerRigData == null)
            {
                playerRigData = Resources.Load<PlayerRigData>(GetLoadDataFilePath<PlayerRigData>(id));
            }
        }

        private void EDITOR_LoadObjectiveData()
        {
            if (objectiveDataList.Count < 1)
            {
                objectiveDataList.Add(Resources.Load<ObjectiveData>(GetLoadDataFilePath<ObjectiveData>(id)));
            }
        }

        public T EDITOR_FindDataFileByType<T>() where T : ScriptableObject
        {
           return Resources.Load<T>(GetLoadDataFilePath<T>(id));
        }
        
        public ObjectiveData EDITOR_GetObjectiveData(int index)
        {
            EDITOR_LoadObjectiveData();

            index = Mathf.Clamp(index, 0, objectiveDataList.Count - 1);
            return objectiveDataList[index];
        }

        public string EDITOR_GetDisplayObjectiveDataName()
        {
            // Ensure objective data exists and is loaded
            EDITOR_GetObjectiveData(0);

            if (objectiveDataList.Count < 1)
            {
                return null;
            }

            // Plan 1: Scenario ID to description
            if (scenarioId != null)
            {
                if (LdxIdSettings.TryGetIDDescription(scenarioId, LdxIdSettings.IdType.Scenario,
                        out string foundDescription, searchAllScenarios: true))
                {
                    if (!string.IsNullOrEmpty(foundDescription))
                    {
                        return foundDescription;
                    }
                }
            }

            // Plan 2: Use the scenario name if it's there
            if (!string.IsNullOrEmpty(scenarioName))
            {
                return scenarioName;
            }
            
            // Plan 3: Infer from scene name
            if (sceneReference != null && !string.IsNullOrEmpty(sceneReference.GetSceneName()))
            {
                return sceneReference.GetSceneName().Replace("Scene", "").Replace("_", "").SeparateWords();
            }
            // Nothing worked - just return null
            return null;
        }
        
        public static bool EDITOR_TryCreateNewScenario(string id, string name, 
            string description, out ScenarioData scenarioData, out string errorMessage)
        {
            errorMessage = "";
            scenarioData = null;

            if (String.IsNullOrEmpty(id) || String.IsNullOrEmpty(name))
            {
                errorMessage = "Can't create ScenarioData, name or id aren't specified";
                return false;
            }
            
            if (Directory.Exists(GetSaveDataFilePath<ScenarioData>(id)))
            {
                errorMessage = "Can't create ScenarioData, file already exists";
                return false;
            }
            scenarioData = CreateDataFile<ScenarioData>(id, $"ScenarioData_{id}");
            scenarioData.EDITOR_SetInitialData(id, name, description);
            scenarioData.objectiveDataList.Clear();
            scenarioData.objectiveDataList.Add(CreateDataFile<ObjectiveData>(id, $"ObjectiveData_{id}"));
            scenarioData.playerRigData = CreateDataFile<PlayerRigData>(id, $"PlayerRigData_{id}");
            OnDataCreated?.Invoke(scenarioData);
            return true;
        }

        private void EDITOR_SetInitialData(string id, string scenarioName, string description)
        {
            this.id = id;
            this.scenarioName = scenarioName;
            this.description = description;
            EDITOR_SetDirtyAndSave();
        }
        
        private static T CreateDataFile<T>(string id, string overrideName = null) where T : ScriptableObject
        {
            string fileName = overrideName ?? typeof(T).Name;
            string filePath = $"{ScenariosPath}{Separator}{id}{Separator}{fileName}.asset";
            return ScriptableObjectUtilities.CreateInstanceAndFile<T>(filePath);
        }

        public void EDITOR_SetDirtyAndSave()
        {
            UnityEditor.EditorUtility.SetDirty(this);
            UnityEditor.AssetDatabase.Refresh();
        }
#endif
        public void ProcessLocalizationKeys(LocalizationTable table)
        {
            table.ProcessLocalizationKey(ref scenarioName);
            table.ProcessLocalizationKey(ref description);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/ScenarioData.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/StartupLoadingMode.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 76d4e4938217462083f21a72cb7a1c6f
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;

namespace Ldx.Framework.Systems.ScenarioManagement.Data
{
    [Serializable]
    public enum StartupLoadingMode
    {
        LoadLobby = 0,
        LoadFirstScenario,
        LoadBasicsTutorial
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Data/StartupLoadingMode.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/IScenarioResult.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: fb81a066190346a7a839e082b0aad8c4
# ASMDEF: ldx.framework.runtime.dll
# ---
namespace Ldx.Framework.Systems.ScenarioManagement
{
    public interface IScenarioCompletionResult
    {
        
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/IScenarioResult.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/LdxScenarioConfig.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4f0ae72fc1ae49b4bcffcc9b800813ce
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Ldx.Framework.Systems.ScenarioManagement
{
    public class LdxScenarioConfig : Singleton<LdxScenarioConfig>
    {
        public enum FileReferenceType
        {
            Filename = 0,
            InspectorReference
        }
        
        private const string SCENARIO_CONFIG_GAMEOBJECT_NAME = ".scenario-config";

        [SerializeField]
        private FileReferenceType referenceType = FileReferenceType.Filename;
        public FileReferenceType ReferenceType => referenceType;
        
        [SerializeField]
        private string scenarioName;
        public string ScenarioName => scenarioName;

        [ShowIf("referenceType", Op.Equals, FileReferenceType.Filename)]
        [SerializeField] 
        private string idSettingsFilename;
        public string IDSettingsFilename => idSettingsFilename;

        [ShowIf("referenceType", Op.Equals, FileReferenceType.InspectorReference)]
        [SerializeField]
        private LdxIdSettings idSettingsFile;
        public LdxIdSettings IDSettingsFile => idSettingsFile;

        public bool AreIDSettingsEmpty()
        {
            return String.IsNullOrEmpty(scenarioName) || String.IsNullOrEmpty(idSettingsFilename);
        }
        
        public void FillIDSettingsFields()
        {
            if (!String.IsNullOrEmpty(scenarioName) && !String.IsNullOrEmpty(idSettingsFilename))
            {
                return;
            }

            scenarioName = SceneManager.GetActiveScene().name;
            idSettingsFilename = $"ID_{StringUtilities.GenerateUniqueId(6, 8)}";
        }

        public static bool TryAddNewScenarioConfig(out string errorMessage)
        {
            errorMessage = "";
            if(!SceneUtilities.TryGetLoadedScenarioSceneName(out string scenarioSceneName, out bool isStandIn))
            {
                errorMessage = "Can't create ID settings because no scenario setup exists";
                return false;
            }

            SceneManager.SetActiveScene(SceneManager.GetSceneByName(scenarioSceneName));
            var o = new GameObject(SCENARIO_CONFIG_GAMEOBJECT_NAME);
            o.GetOrAddComponent<LdxScenarioConfig>().FillIDSettingsFields();
            return true;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/LdxScenarioConfig.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/LobbyScenario.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: da29800ffe6a491f8bf8750f5ede659a
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Utilities.Attributes;

namespace Ldx.Framework.Systems.ScenarioManagement
{
    /// <summary>
    /// Lobby instance in the scene for the lobby setup
    /// </summary>
    [TrackedReference]
    public class LobbyScenario : BaseScenario
    {
        public static event Action<LobbyScenario, ScenarioDataInfoContainer> OnAnyLobbyStarted;
        
        public override void StartScenario(ScenarioParameters parameters)
        {
            base.StartScenario(parameters);
            BroadcastAnyLobbyStarted();
        }
        
        private void BroadcastAnyLobbyStarted()
        {
            OnAnyLobbyStarted?.Invoke(this, ScenarioInfoContainer);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/LobbyScenario.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Scenario.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d02de8a58a674ab49f20e181dcd85ce4
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.ScenarioManagement
{
    /// <summary>
    /// Scenario instance in the scene
    /// To be later hooked into metric collection, but also for
    /// manually reporting scene completion
    /// </summary>
    [TrackedReference]
    public class Scenario : BaseScenario
    {
        public string ID => Parameters.Data.ID;
        public string NameKey => Parameters.Data.ScenarioName;
        public string DescriptionKey => Parameters.Data.Description;
        public bool CanFinishScenario => Parameters.Data.ScenarioEndType == ScenarioEndTypes.ManualScenarioCompletion;

        /// <summary>
        /// Call this to manually report when the scenario is finished
        /// Need to correspond with the expected ScenarioData.ScenarioEndType
        /// </summary>
        public void FinishScenario(IScenarioCompletionResult result = null)
        {
            if (!CanFinishScenario)
            {
                string error = $"Error: Invalid Scenario.FinishScenario() call." +
                               $"\nThe expected scenario end event specified in ScenarioData is different.";
                Debug.LogError(error);
#if UNITY_EDITOR
                // Just feels important to really note
                UnityEditor.EditorUtility.DisplayDialog("Error", error, "Ok");
#endif
                return;
            }

            BroadcastScenarioCompletionReported(result);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/Scenario.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/ScenarioLoadingBlocker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ec86ac7c00cf5944a9c902dedd0e022f
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;
using Utilities.Blockers;

namespace Ldx.Framework.Systems.ScenarioManagement
{
    public class ScenarioLoadingBlocker : MonoBehaviour, IBlocker
    {
        public event Action<IBlocker, bool> OnBlockChanged;
        public bool IsBlocked { get; private set;}

        private void Awake()
        {
            ScenarioManager.OnLoadingStarted += HandleLoadingStarted;
            ScenarioManager.OnLoadingFinished += HandleLoadingFinished;
        }

        private void OnDestroy()
        {
            ScenarioManager.OnLoadingStarted -= HandleLoadingStarted;
            ScenarioManager.OnLoadingFinished -= HandleLoadingFinished;
        }

        private void HandleLoadingStarted(ScenarioLoadingParameters parameters)
        {
            IsBlocked = true;
            OnBlockChanged?.Invoke(this, IsBlocked);
        }

        private void HandleLoadingFinished(ScenarioManager scenarioManager)
        {
            IsBlocked = false;
            OnBlockChanged?.Invoke(this, IsBlocked);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/ScenarioLoadingBlocker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/ScenarioLoadingParameters.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 77a302b822d74a2ab561c7f6c9fac183
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Utilities.Async;

namespace Ldx.Framework.Systems.ScenarioManagement
{
    /// <summary>
    /// Parameters passed by the scenario manager to the UI overlay when loading
    /// </summary>
    public class ScenarioLoadingParameters
    {
        public ScenarioManager ScenarioManager { get; }
        public AsyncOperationGroup AsyncOperationGroup { get; }
        public ScenarioData ScenarioData { get; }
        public Func<bool> IsSceneHiddenGetter { get; private set; }
        
        public ScenarioLoadingParameters(ScenarioManager scenarioManager, AsyncOperationGroup asyncOperationGroup, ScenarioData scenarioData)
        {
            ScenarioManager = scenarioManager;
            AsyncOperationGroup = asyncOperationGroup;
            ScenarioData = scenarioData;
        }

        public void SetSceneHiddenGetter(Func<bool> getter)
        {
            IsSceneHiddenGetter = getter;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/ScenarioLoadingParameters.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/ScenarioManager.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 748ecb5f1d5f413eade16fe2b4be84d4
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Scripts.Systems.Scoring;
using Ldx.Framework.Systems.AddOns;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Systems.ScenarioManagement.ScenarioUtilities;
using Ldx.Framework.Systems.SceneManagement;
using Ldx.Framework.Systems.UI.Fading;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Async;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;
using UnityEngine.SceneManagement;
using Debug = Ldx.Framework.Utilities.Logging.Debug;
using Ldx.Framework.Utilities.Logging;
using UnityEngine.InputSystem;

namespace Ldx.Framework.Systems.ScenarioManagement
{
    /// <summary>
    /// Loads, unloads, and processes the different scenarios in the project
    /// </summary>
    public class ScenarioManager : Singleton<ScenarioManager>
    {
        public enum ProcessingType
        {
            MultipleScenarios = 0,
            SingleScenario
        }

        private const float ENABLE_HEAD_COLLISION_DURATION = 5f;
        private const float TIME_TO_WAIT_BEFORE_TRANSITION_TO_NEXT = 2.0f;
        
        public static event Action<ScenarioLoadingParameters> OnLoadingStarted;
        public static event Action<ScenarioManager> OnLoadingFinished;
        public static event Action OnApplicationQuitting;
        
        public event Action<ScenarioManager> OnLobbyCompleted;
        public event Action<ScenarioManager, ScenarioDataType> OnScenarioStarted; 
        public event Action<ScenarioManager, ScenarioData.ScenarioEndBehaviourType, IScenarioCompletionResult> OnScenarioCompleted;
        public event Action<ScenarioManager> OnUnloadingScenarioOrLobby;

        [SerializeField] 
        private bool loadAtStart = true;

        [Header("Systems")] 
        [SerializeField] private ObjectiveSystem objectiveSystem;
        [SerializeField] private ScoringSystem scoringSystem;

        private Coroutine enableHeadCollisionCoroutine;
        private bool debugSkipBlocked;
        private Queue<ObjectiveData> objectiveDataQueue;
        
        public static bool IsCustomLoadingMode { get; set; }
        
        public ScenarioData LoadedScenarioData { get; private set; }
        public bool HasPreviousScenario => GlobalData != null 
                                           && CurrentScenarioIndex != null 
                                           && GlobalData.HasScenarioAtIndex(CurrentScenarioIndex.Value - 1);
        public bool HasNextScenario => GlobalData != null 
                                       && CurrentScenarioIndex != null 
                                       && GlobalData.HasScenarioAtIndex(CurrentScenarioIndex.Value + 1);
        
        public ScenarioData NextScenarioData
        {
            get
            {
                IList<ScenarioData> list = GlobalData.GetScenarioDataList();
                if (list == null 
                    || list.Count == 0
                    || !CurrentScenarioIndex.HasValue)
                    return null;

                int next = CurrentScenarioIndex.Value + 1;
                return next >= list.Count ? null : GlobalData.GetScenarioData(next);
            }
        }
        
        public bool HasLobby => GlobalData != null
                                && GlobalData.LobbyScene.IsValid();

        public bool IsInCutscene => LoadedScenarioData != null && LoadedScenarioData.Type is ScenarioDataType.Cutscene;
        private GlobalData GlobalData => GlobalData.Instance;
        private int? CurrentScenarioIndex { get; set; } = null;
        public BaseScenario LoadedScenario { get; private set; }
        private ProcessingType SelectedProcessingType { get; set; } = ProcessingType.MultipleScenarios;
        private bool ShouldLoadAtStart => loadAtStart && !IsCustomLoadingMode;
        public bool IsLoadingAndUnloadingBlocked { get; set; }
        public bool IsLoading { get; private set; }

        public bool IsInLastScenario => CurrentScenarioIndex != null
                                        && !GlobalData.HasScenarioAtIndex(CurrentScenarioIndex.Value + 1);
        
        private PlayerController playerController;
        public PlayerController PlayerController =>
            playerController == null ? playerController = PlayerController.Instance : playerController;

        protected override void Awake()
        {
            base.Awake();
            SubscribeToEvent();
            GlobalData.Instance.Initialize();
            SetupAddOnModules();
        }

        private void OnDestroy()
        {
            UnsubscribeFromEvents();
        }

        private void Start()
        {
            if (!ShouldLoadAtStart)
            {
                return;
            }
            LoadStartup();
        }

#if UNITY_EDITOR
        private void Update()
        {
            if (debugSkipBlocked)
            {
                return;
            }
            
            if (Keyboard.current != null 
                && Keyboard.current.zKey.isPressed 
                && Keyboard.current.xKey.isPressed)
            {
                debugSkipBlocked = true;
#pragma warning disable CS4014
                waitThenReEnableDebugSkip();
#pragma warning restore CS4014
                LoadNextSceneOrMainMenu();
            }

            async UniTaskVoid waitThenReEnableDebugSkip()
            {
                await UniTask.Delay(4000);
                debugSkipBlocked = false;
            }
        }
#endif
        public ScenarioDataInfoContainer GetScenarioDataInfo() => GlobalData.GetScenarioDataInfo();
        public GlobalScenarioOptionsContainer GetGlobalScenarioOptions() => GlobalData.GetGlobalScenarioOptions();
        
        private void OnApplicationQuit()
        {
            OnApplicationQuitting?.Invoke();
        }
        
        private void SubscribeToEvent()
        {
            objectiveSystem.OnObjectivesFinished += HandleObjectivesFinished;
        }
        
        private void UnsubscribeFromEvents()
        {
            if (objectiveSystem != null)
            {
                objectiveSystem.OnObjectivesFinished -= HandleObjectivesFinished;
            }
        }

        public void LoadStartup()
        {
            switch (GlobalData.StartupLoadingMode)
            {
                case StartupLoadingMode.LoadLobby:
                    LoadLobby();
                    break;
                case StartupLoadingMode.LoadFirstScenario:
                    LoadFirstScenario();
                    break;
                case StartupLoadingMode.LoadBasicsTutorial:
                    LoadBasicsTutorial();
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        public void LoadBasicsTutorial()
        {
            if (GlobalData.BasicsTutorialData == null)
            {
                string error = $"Basics tutorial data not assigned in GlobalData";
                Debug.LogError(error);
#if UNITY_EDITOR
                UnityEditor.EditorUtility.DisplayDialog("Error", error + "\n\nExecution will be interrupted", "Ok");
                return;
#endif
            }
            LoadScenario(GlobalData.BasicsTutorialData).Forget();    
        }
        
        public async void LoadLobby()
        {
            if (Instance.HasLobby)
            {
                string error = $"Lobby scene not assigned in GlobalData";
                Debug.LogError(error);
#if UNITY_EDITOR
                UnityEditor.EditorUtility.DisplayDialog("Error", error + "\n\nExecution will be interrupted", "Ok");
                return;
#endif
            }
            DisableHeadAndHandCollision();
            string sceneName = GlobalData.LobbyScene.GetSceneName();
            CurrentScenarioIndex = null;
            // Prepare data loading operation
            AsyncOperationGroup operations = new AsyncOperationGroup();
            //--Screen starts to cover
            ScenarioLoadingParameters parameters = new ScenarioLoadingParameters(this, operations, null);
            OnLoadingStarted?.Invoke(parameters);
            ScreenFadeTimer loadTimer = ScreenFadeTimer.StartNew();
            await UniTask.WaitUntil(() => parameters.IsSceneHiddenGetter());
            if (LoadedScenarioData != null)
            {
                if (LoadedScenarioData.ScenarioEndType == ScenarioEndTypes.ManualScenarioCompletion
                    && LoadedScenario != null)
                {
                    LoadedScenario.OnScenarioCompletionReported -= HandleScenarioCompletionReported;
                }
                LoadedScenarioData.UnloadData();
                OnUnloadingScenarioOrLobby?.Invoke(this);
                foreach (SceneReference s in LoadedScenarioData.AdditionalScenes)
                {
                    await SceneManager.UnloadSceneAsync(s.GetSceneName());
                }
                await SceneManager.UnloadSceneAsync(LoadedScenarioData.SceneReference.GetSceneName());
                await UniTask.Yield();
            }
            LoadedScenario = null;
            LoadedScenarioData = null;
            if (PlayerController != null)
            {
                PlayerController.SetGravityEnabled(false);           
            }
            
            // Unload current scenario data and scene 
            objectiveSystem.ResetSystem();
            scoringSystem.ResetSystem();
            
            Debug.LogVerbose(LogCategory.ScenarioManager,  "Started Loading");
            if (!SceneManager.GetSceneByName(sceneName).isLoaded)
            {
                operations.AddOperation(SceneManager.LoadSceneAsync(sceneName, LoadSceneMode.Additive));
            }
            else
            {
                operations.ForceFinish();
            }
            
            await operations.Wait();
            await UniTask.Yield();
            SceneManager.SetActiveScene(SceneManager.GetSceneByName(sceneName));
            Debug.LogVerbose(LogCategory.ScenarioManager, "Finished Loading");
            LoadedScenario = ReferenceBank.GetFirstOrDefault<LobbyScenario>();
            if (LoadedScenario == null)
            {
                string error =
                    $"Lobby setup not found in the scene, can't find object of type {nameof(LobbyScenario)} in the ReferenceBank";
                Debug.LogError(error);
#if UNITY_EDITOR
                UnityEditor.EditorUtility.DisplayDialog("Error", error + "\n\nExecution will be interrupted", "Ok");
                return;
#endif
            }

            // -- Player Controller
            // Reset player setup
            // Inject new setup
            if (PlayerController != null)
            {
                PlayerController.ResetSetupState();
            }

            // Get starting point
            PlayerStartPoint point = ReferenceBank.GetFirstOrDefault<PlayerStartPoint>();
            if (point == null)
            {
                Debug.LogError(LogCategory.ScenarioManager, $"Lobby scene {sceneName} doesn't have a PlayerStartPoint setup" +
                                                            $"Load the scene in the editor then apply LogicalDox/Scene Setup/Setup Lobby Scene");
            }

            if (PlayerController != null)
            {
                PlayerMovementRequest moveRequest = new PlayerMovementRequest(point.transform.position)
                {
                    TargetRotation = point.transform.rotation,
                    UseFade = false // ScenarioManager handles the master fade
                };
                await PlayerController.MovePlayerToAsync(moveRequest);
            }

            if (loadTimer.EndCheck())
            {
                await loadTimer.AwaitRemaining();
            }
            OnLoadingFinished?.Invoke(this);
            OnScenarioStarted?.Invoke(this, ScenarioDataType.Lobby);
            await UniTask.WaitUntil(() => !parameters.IsSceneHiddenGetter());
            // TODO: When we load lobby through a scenario data, this won't be null (and will be
            // unified with the LoadScenario method)
            LoadedScenario.StartScenario(GetScenarioParameters(null));
            StartEnableHeadCollisionCoroutine();
        }
        
        public void LoadScenario(string id, ProcessingType processingType = ProcessingType.MultipleScenarios)
        {
            ScenarioData data = GlobalData.GetScenarioData(id);

            if (data == null)
            {
                Debug.LogError($"LoadScenario: No scenario data was found with the {id} id");
                return;
            }
            
            SelectedProcessingType = processingType;
            LoadScenario(data).Forget();
        }
        
        public async UniTaskVoid LoadScenario(ScenarioData data)
        {
            IsLoading = true;
            DisableHeadAndHandCollision();
            switch (data.Type)
            {
                case ScenarioDataType.Scenario:
                    CurrentScenarioIndex = GlobalData.GetScenarioDataIndex(data);
                    break;
                case ScenarioDataType.Cutscene:
                    // If cutscene keep the existing CurrentScenarioIndex
                    CurrentScenarioIndex = CurrentScenarioIndex;
                    break;
                default:
                    CurrentScenarioIndex = null;
                    break;
            }
            
            string sceneName = data.SceneReference.GetSceneName();
            // Prepare data loading operation
            AsyncOperationGroup operations = new AsyncOperationGroup();
            //--Screen starts to cover
            ScenarioLoadingParameters parameters = new ScenarioLoadingParameters(this, operations, data);
            OnLoadingStarted?.Invoke(parameters);
            await UniTask.WaitUntil(() => parameters.IsSceneHiddenGetter());
            if (IsLoadingAndUnloadingBlocked)
            {
                await UniTask.WaitUntil(() => !IsLoadingAndUnloadingBlocked);
            }
            ScreenFadeTimer loadTimer = ScreenFadeTimer.StartNew();
            HashSet<string> nextDataScenesSet = new HashSet<string>(data.AdditionalScenes.Select(s => s.GetSceneName()).ToList());
            nextDataScenesSet.Add(sceneName);
            HashSet<string> preservedScenesSet = new HashSet<string>();

            Debug.LogVerbose(LogCategory.ScenarioManager,"Scene Hidden");

            if (GlobalData.LobbyScene != null)
            {
                string lobbySceneName = GlobalData.LobbyScene.GetSceneName();
                if (SceneManager.GetSceneByName(lobbySceneName).isLoaded)
                {
                    await SceneManager.UnloadSceneAsync(lobbySceneName);
                    // TODO: future refactor to make lobby use ScenarioData
                    OnLobbyCompleted?.Invoke(this);
                }
            }
            
            // Wait until data and scene are unloaded
            if (LoadedScenarioData != null)
            {
                if (LoadedScenarioData.Type == ScenarioDataType.Lobby)
                {
                    // OnLobbyCompleted?.Invoke(this);
                }
                if (LoadedScenarioData.Type == ScenarioDataType.Scenario
                    && LoadedScenarioData.ScenarioEndType == ScenarioEndTypes.ManualScenarioCompletion
                    && LoadedScenario != null)
                {
                    LoadedScenario.OnScenarioCompletionReported -= HandleScenarioCompletionReported;
                }
                LoadedScenarioData.UnloadData();
                OnUnloadingScenarioOrLobby?.Invoke(this);
                // Unload additional scenes (except the ones that are shared between
                // this scenario and the one being loaded)
                foreach (SceneReference s in LoadedScenarioData.AdditionalScenes)
                {
                    string sName = s.GetSceneName();
                    // Does this scene exist in the loading scenario? Preserve
                    if (nextDataScenesSet.Contains(sName))
                    {
                        preservedScenesSet.Add(sName);
                        continue;
                    }
                    await SceneManager.UnloadSceneAsync(sName);
                }

                if (LoadedScenarioData.SceneReference != null)
                {
                    await SceneManager.UnloadSceneAsync(LoadedScenarioData.SceneReference.GetSceneName());
                }
             
                LoadedScenario = null;
                LoadedScenarioData = null;
                await UniTask.Yield();
            }
            
            HashSet<string> loadedScenesSet = new HashSet<string>(SceneUtilities.GetAllLoadedScenes().Select(s => s.name));
            
            operations.UnionWith(data.LoadDataAsync());
            if (!loadedScenesSet.Contains(sceneName))
            {
                operations.AddOperation(SceneManager.LoadSceneAsync(sceneName, LoadSceneMode.Additive));
            }
            foreach (SceneReference s in data.AdditionalScenes)
            {
                string sName = s.GetSceneName();
                // Scene is preserved? (Wasn't unloaded because it's shared?) Then skip, already loaded
                if (preservedScenesSet.Contains(sName) || loadedScenesSet.Contains(sName))
                {
                    continue;
                }
                operations.AddOperation(SceneManager.LoadSceneAsync(sName, LoadSceneMode.Additive));
            }

            if (PlayerController != null)
            {
                PlayerController.SetGravityEnabled(false);
            }

            // Unload current scenario data and scene 
            objectiveSystem.ResetSystem();
            scoringSystem.ResetSystem();
            
            Debug.LogVerbose(LogCategory.ScenarioManager, "Started Loading");
            // Wait until all loading is finished
            await operations.Wait();
            Debug.LogVerbose(LogCategory.ScenarioManager, "Finished Loading");
            LoadedScenarioData = data;
            switch (LoadedScenarioData.Type)
            {
                case ScenarioDataType.Scenario:
                    LoadedScenario = ReferenceBank.GetFirstOrDefault<Scenario>();
                    break;
                case ScenarioDataType.Cutscene:
                    LoadedScenario = ReferenceBank.GetFirstOrDefault<Scenario>();
                    break;
                case ScenarioDataType.Lobby:
                    LoadedScenario = ReferenceBank.GetFirstOrDefault<LobbyScenario>();
                    break;
                case ScenarioDataType.Tutorial:
                    LoadedScenario = ReferenceBank.GetFirstOrDefault<TutorialScenario>();
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
            if (LoadedScenario == null)
            {
                string error = $"Scenario setup not found in the scene, can't find object of type {nameof(Scenario)} in the RefereneBank";
                Debug.LogError(error);
#if UNITY_EDITOR
                UnityEditor.EditorUtility.DisplayDialog("Error", error + "\n\nExecution will be interrupted", "Ok");
                return;
#endif
            }

            if (LoadedScenarioData.Type == ScenarioDataType.Scenario 
                && LoadedScenarioData.ScenarioEndType == ScenarioEndTypes.ManualScenarioCompletion)
            {
                LoadedScenario.OnScenarioCompletionReported += HandleScenarioCompletionReported;
            }
            
            await UniTask.Yield();

            if (LoadedScenarioData.CopyRenderSettingsFromAdditionalScene)
            {
                await ScenarioHelper.ApplyLightingSettingsFromFirstAdditionalSceneAsync(LoadedScenarioData.SceneReference,
                    LoadedScenarioData.AdditionalScenes);
            }
            // Set active scene to the new scene
            SceneManager.SetActiveScene(SceneManager.GetSceneByName(sceneName));
            PlayerStartPoint point = ReferenceBank.GetFirstOrDefault<PlayerStartPoint>();

            // Get starting point
            if (point == null)
            {
                Debug.LogError($"Scenario {data.ScenarioNameLocalized} doesn't have a PlayerStartPoint setup" +
                               $"Load the scene in the editor then apply LogicalDox/Scene Setup/Setup Scenario Scene");
            }
            
            if (PlayerController != null)
            {
                PlayerController.ResetSetupState();
                PlayerMovementRequest moveRequest = new PlayerMovementRequest(point.transform.position)
                {
                    TargetRotation = point.transform.rotation,
                    UseFade = false, // ScenarioManager handles the master fade
                    OnAfterMove = () => PlayerController.InjectSetup(data.PlayerRigData)
                };
                await PlayerController.MovePlayerToAsync(moveRequest);
            }

            // -- Objective System
            scoringSystem.InitializeSystem(data.ScoringData, data.ScenarioID);
            objectiveDataQueue = new Queue<ObjectiveData>(data.ObjectiveDataList);
            
            if (IsLoadingAndUnloadingBlocked)
            {
                await UniTask.WaitUntil(() => !IsLoadingAndUnloadingBlocked);
            }

            IsLoading = false;
            
            if (loadTimer.EndCheck())
            {
                await loadTimer.AwaitRemaining();
            }

            OnLoadingFinished?.Invoke(this);
            await UniTask.WaitUntil(() => !parameters.IsSceneHiddenGetter());
            LoadedScenario.StartScenario(GetScenarioParameters(LoadedScenarioData));
            OnScenarioStarted?.Invoke(this, LoadedScenarioData.Type);
            scoringSystem.StartSystem();
            StartNextObjectiveData();
            StartEnableHeadCollisionCoroutine();
        }
        
        public void ReloadCurrentScenario()
        {
            LoadScenario(LoadedScenarioData).Forget();
        }

        public void LoadNextScenario()
        {
            if (!HasNextScenario)
            {
                Debug.LogError("No next scenario found");
                return;
            }
            LoadScenario(GlobalData.GetScenarioData(CurrentScenarioIndex.Value + 1)).Forget();
        }

        public void LoadPreviousScenario()
        {
            if (!HasPreviousScenario)
            {
                Debug.LogError("No previous scenario found");
                return;   
            }
            LoadScenario(GlobalData.GetScenarioData(CurrentScenarioIndex.Value - 1)).Forget();
        }
        
        public void LoadNextSceneOrMainMenu()
        {
            if (IsInCutscene && CurrentScenarioIndex == null)
            {
                LoadFirstScenario(true);
                return;
            }
            
            if (HasNextScenario)
            {
                LoadNextScenario();
                return;
            }

            switch (GlobalData.StartupLoadingMode)
            {
                case StartupLoadingMode.LoadLobby:
                    LoadLobby();
                    break;
                case StartupLoadingMode.LoadFirstScenario:
                    LoadFirstScenario();
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        public void LoadFirstScenario(bool onlyScenarioType = false)
        {
            ScenarioDataInfoContainer scenarioDataInfo = GlobalData.GetScenarioDataInfo();
            if (scenarioDataInfo.Count == 0)
            {
                Debug.LogError("Can't load first scenario, no scenarios listed");
                return;
            }

            ScenarioDataInfo firstScenario = onlyScenarioType
                ? scenarioDataInfo.FirstOrDefault(x => x.Type == ScenarioDataType.Scenario)
                : scenarioDataInfo[0];

            if (firstScenario != null)
            {
                LoadScenario(firstScenario.ID);
            }
        }

        public void SetObjectiveSystemBlocked(bool isBlocked)
        {
            ObjectiveSystem.IsBlocked = isBlocked;
            ScoringSystem.IsBlocked = isBlocked;
        }

        private void SetupAddOnModules()
        {
            foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                foreach (Type type in assembly.GetTypes())
                {
                    if (type.IsAbstract)
                    {
                        continue;
                    }

                    if (!type.IsSubclassOf(typeof(AddOnModule)))
                    {
                        continue;
                    }
                    AddOnModule instance = Activator.CreateInstance(type) as AddOnModule;
                    if (instance == null)
                    {
                        continue;
                    }
                    instance.Setup();
                }
            }
        }
        
        private void StartEnableHeadCollisionCoroutine()
        {
            if (enableHeadCollisionCoroutine != null)
            {
                StopCoroutine(enableHeadCollisionCoroutine);
                enableHeadCollisionCoroutine = null;
            }
            enableHeadCollisionCoroutine = StartCoroutine(EnableHeadCollisionAfterDurationRoutine());
        }

        private void DisableHeadAndHandCollision()
        {
            if (enableHeadCollisionCoroutine != null)
            {
                StopCoroutine(enableHeadCollisionCoroutine);
                enableHeadCollisionCoroutine = null;
            }
            
            if (PlayerController != null)
            {
                PlayerController.SetHeadCollisionEnabled(false);
                PlayerController.SetPlayerHandCollisionEnabled(false);
            }
        }

        private IEnumerator EnableHeadCollisionAfterDurationRoutine()
        {
            yield return new WaitForSeconds(ENABLE_HEAD_COLLISION_DURATION);
            if (PlayerController != null)
            {
                PlayerController.SetHeadCollisionEnabled(true);
            }

            enableHeadCollisionCoroutine = null;
        }
        
        private ScenarioParameters GetScenarioParameters(ScenarioData data)
        {
            return new ScenarioParameters(data, GetScenarioDataInfo());
        }
        
        private void StartNextObjectiveData()
        {
            if (objectiveDataQueue is { Count: > 0 })
            {
                ObjectiveData nextObjectiveData = objectiveDataQueue.Dequeue();
                objectiveSystem.InitializeSystem(nextObjectiveData);
                objectiveSystem.StartSystem();
            }
            else
            {
                if (LoadedScenarioData.ScenarioEndType == ScenarioEndTypes.AllObjectivesCompleted)
                {
                    ReportScenarioCompletion(null);
                }
            }
        }
        
        private void HandleScenarioCompletionReported(BaseScenario scenario, IScenarioCompletionResult result)
        {
            scenario.OnScenarioCompletionReported -= HandleScenarioCompletionReported;
            if (LoadedScenarioData.ScenarioEndType == ScenarioEndTypes.ManualScenarioCompletion)
            {
                objectiveSystem.StopSystem();
                scoringSystem.StopSystem();
                ReportScenarioCompletion(result);
            }
        }
        
        private void HandleObjectivesFinished(ObjectiveSystem obj)
        {
            if (LoadedScenarioData == null)
            {
                return;
            }

            if (LoadedScenarioData.ScenarioEndType == ScenarioEndTypes.AllObjectivesCompleted)
            {
                StartNextObjectiveData();
            }
        }
        
        private void ReportScenarioCompletion(IScenarioCompletionResult result)
        {
            OnScenarioCompleted?.Invoke(this, LoadedScenarioData.ScenarioEndBehaviour, result);

            switch (LoadedScenarioData.ScenarioEndBehaviour)
            {
                case ScenarioData.ScenarioEndBehaviourType.LoadNextScenarioOrLobby:
                    waitThenTransitionToNextAsync().Forget();
                    break;
                case ScenarioData.ScenarioEndBehaviourType.LoadLobby:
                    waitThenTransitionToLobby().Forget();
                    break;
                case ScenarioData.ScenarioEndBehaviourType.LoadFirstScenario:
                    waitThenTransitionToFirstScenario().Forget();
                    break;
            }

            async UniTaskVoid waitThenTransitionToNextAsync()
            {
                await UniTask.Delay((int)(TIME_TO_WAIT_BEFORE_TRANSITION_TO_NEXT * 1000));
                LoadNextSceneOrMainMenu();
            }

            async UniTaskVoid waitThenTransitionToLobby()
            {
                await UniTask.Delay((int)(TIME_TO_WAIT_BEFORE_TRANSITION_TO_NEXT * 1000)); 
                LoadLobby();
            }
            
            async UniTaskVoid waitThenTransitionToFirstScenario()
            {
                await UniTask.Delay((int)(TIME_TO_WAIT_BEFORE_TRANSITION_TO_NEXT * 1000));
                LoadFirstScenario();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/ScenarioManager.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/ScenarioParameters.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1410190646a64834ac5ade21d7783f6c
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;

namespace Ldx.Framework.Systems.ScenarioManagement
{
    public class ScenarioParameters
    {
        public ScenarioData Data { get;}
        public ScenarioDataInfoContainer InfoContainer { get; }
        
        public ScenarioParameters(ScenarioData data, ScenarioDataInfoContainer infoContainer)
        {
            Data = data;
            InfoContainer = infoContainer;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/ScenarioParameters.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/ScenarioUtiltites/RenderSettingsCache.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5ec9efd0ec5342058af44b71dad52f26
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;
#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.SceneManagement;
#endif

namespace Ldx.Framework.Systems.ScenarioManagement.ScenarioUtilities
{
    /// <summary>
    /// Records the current RenderSettings properties (from the active scene)
    /// </summary>
    public class RenderSettingsCache
    {
        public Color AmbientEquatorColor { get; }
        public Color AmbientGroundColor { get; }
        public float AmbientIntensity { get; }
        public Color AmbientLight { get; }
        public AmbientMode AmbientMode { get; }
        public SphericalHarmonicsL2 AmbientProbe { get; }
        public Color AmbientSkyColor { get; }
        public DefaultReflectionMode DefaultReflectionMode { get; }
        public int DefaultReflectionResolution { get; }
        public float FlareFadeSpeed { get; }
        public float FlareStrength { get; }
        public bool Fog { get; }
        public Color FogColor { get; }
        public float FogDensity { get; }
        public float FogEndDistance { get; }
        public FogMode FogMode { get; }
        public float FogStartDistance { get; }
        public float HaloStrength { get; }
        public int ReflectionBounces { get; }
        public float ReflectionIntensity { get; }
        public Material Skybox { get; }
        public Color SubtractiveShadowColor { get; }
        public Light Sun { get; }

        public LightmapData[] Lightmaps { get; }
        public LightProbes LightProbes { get; }
        public LightingSettings LightingSettings { get; }

#if UNITY_EDITOR
        public LightingDataAsset LightingDataAsset { get; }
#endif

        public RenderSettingsCache()
        {
            AmbientEquatorColor = RenderSettings.ambientEquatorColor;
            AmbientGroundColor = RenderSettings.ambientGroundColor;
            AmbientIntensity = RenderSettings.ambientIntensity;
            AmbientLight = RenderSettings.ambientLight;
            AmbientMode = RenderSettings.ambientMode;
            AmbientProbe = RenderSettings.ambientProbe;
            AmbientSkyColor = RenderSettings.ambientSkyColor;
            DefaultReflectionMode = RenderSettings.defaultReflectionMode;
            DefaultReflectionResolution = RenderSettings.defaultReflectionResolution;
            FlareFadeSpeed = RenderSettings.flareFadeSpeed;
            FlareStrength = RenderSettings.flareStrength;
            Fog = RenderSettings.fog;
            FogColor = RenderSettings.fogColor;
            FogDensity = RenderSettings.fogDensity;
            FogEndDistance = RenderSettings.fogEndDistance;
            FogMode = RenderSettings.fogMode;
            FogStartDistance = RenderSettings.fogStartDistance;
            HaloStrength = RenderSettings.haloStrength;
            ReflectionBounces = RenderSettings.reflectionBounces;
            ReflectionIntensity = RenderSettings.reflectionIntensity;
            Skybox = RenderSettings.skybox;
            SubtractiveShadowColor = RenderSettings.subtractiveShadowColor;
            Sun = RenderSettings.sun;

            Lightmaps = LightmapSettings.lightmaps;
            LightProbes = LightmapSettings.lightProbes;

            if (!Application.isPlaying)
            {
#if UNITY_EDITOR
                LightingSettings = Lightmapping.lightingSettings;
                LightingDataAsset = Lightmapping.lightingDataAsset;
#endif
            }
        }

        public void Apply()
        {
            RenderSettings.ambientEquatorColor = AmbientEquatorColor;
            RenderSettings.ambientGroundColor = AmbientGroundColor;
            RenderSettings.ambientIntensity = AmbientIntensity;
            RenderSettings.ambientLight = AmbientLight;
            RenderSettings.ambientMode = AmbientMode;
            RenderSettings.ambientProbe = AmbientProbe;
            RenderSettings.ambientSkyColor = AmbientSkyColor;
            RenderSettings.defaultReflectionMode = DefaultReflectionMode;
            RenderSettings.defaultReflectionResolution = DefaultReflectionResolution;
            RenderSettings.flareFadeSpeed = FlareFadeSpeed;
            RenderSettings.flareStrength = FlareStrength;
            RenderSettings.fog = Fog;
            RenderSettings.fogColor = FogColor;
            RenderSettings.fogDensity = FogDensity;
            RenderSettings.fogEndDistance = FogEndDistance;
            RenderSettings.fogMode = FogMode;
            RenderSettings.fogStartDistance = FogStartDistance;
            RenderSettings.haloStrength = HaloStrength;
            RenderSettings.reflectionBounces = ReflectionBounces;
            RenderSettings.reflectionIntensity = ReflectionIntensity;
            RenderSettings.skybox = Skybox;
            RenderSettings.subtractiveShadowColor = SubtractiveShadowColor;
            RenderSettings.sun = Sun;

            if (!Application.isPlaying)
            {
#if UNITY_EDITOR
                Lightmapping.lightingSettings = LightingSettings;
                //TODO: Investigate the Bakery issue
                //Lightmapping.lightingDataAsset = LightingDataAsset;
                EditorSceneManager.MarkSceneDirty(SceneManager.GetActiveScene());
#endif
            }

            LightmapSettings.lightmaps = Lightmaps;
            LightmapSettings.lightProbes = LightProbes;
        }

        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType())
            {
                return false;
            }

            RenderSettingsCache other = (RenderSettingsCache)obj;

            return GetHashCode() == other.GetHashCode();
        }

        public override int GetHashCode()
        {
            unchecked
            {
                int hash = 17;
                hash = hash * 23 + AmbientEquatorColor.GetHashCode();
                hash = hash * 23 + AmbientGroundColor.GetHashCode();
                hash = hash * 23 + AmbientIntensity.GetHashCode();
                hash = hash * 23 + AmbientLight.GetHashCode();
                hash = hash * 23 + AmbientMode.GetHashCode();
                hash = hash * 23 + AmbientProbe.GetHashCode();
                hash = hash * 23 + AmbientSkyColor.GetHashCode();
                hash = hash * 23 + DefaultReflectionMode.GetHashCode();
                hash = hash * 23 + DefaultReflectionResolution.GetHashCode();
                hash = hash * 23 + FlareFadeSpeed.GetHashCode();
                hash = hash * 23 + FlareStrength.GetHashCode();
                hash = hash * 23 + Fog.GetHashCode();
                hash = hash * 23 + FogColor.GetHashCode();
                hash = hash * 23 + FogDensity.GetHashCode();
                hash = hash * 23 + FogEndDistance.GetHashCode();
                hash = hash * 23 + FogMode.GetHashCode();
                hash = hash * 23 + FogStartDistance.GetHashCode();
                hash = hash * 23 + HaloStrength.GetHashCode();
                hash = hash * 23 + ReflectionBounces.GetHashCode();
                hash = hash * 23 + ReflectionIntensity.GetHashCode();
                hash = hash * 23 + (Skybox != null ? Skybox.GetHashCode() : 0);
                hash = hash * 23 + SubtractiveShadowColor.GetHashCode();
                // Not needed - the sun reference will be in the environment scene
                // So it'll be set as an object reference only when both scenes are loaded
                // (In realtime or edit mode)

                //hash = hash * 23 + (Sun != null ? Sun.GetHashCode() : 0);

                return hash;
            }
        }

        public static bool operator ==(RenderSettingsCache lhs, RenderSettingsCache rhs)
        {
            if (ReferenceEquals(lhs, null))
            {
                return ReferenceEquals(rhs, null);
            }

            return lhs.Equals(rhs);
        }

        public static bool operator !=(RenderSettingsCache lhs, RenderSettingsCache rhs)
        {
            return !(lhs == rhs);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/ScenarioUtiltites/RenderSettingsCache.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/ScenarioUtiltites/ScenarioHelper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 034d88e06294498fb645458714525c3e
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.SceneManagement;
using Ldx.Framework.Utilities.Logging;
using UnityEngine.SceneManagement;
using Debug = Ldx.Framework.Utilities.Logging.Debug;

namespace Ldx.Framework.Systems.ScenarioManagement.ScenarioUtilities
{
    public static class ScenarioHelper
    {
        /// <summary>
        /// Applies lighting settings from first additional scene to scenario scene
        /// </summary>
        public static async UniTask<bool> ApplyLightingSettingsFromFirstAdditionalSceneAsync(SceneReference scenarioScene,
            List<SceneReference> additionalScenes)
        {
            if (additionalScenes == null || additionalScenes.Count < 1)
            {
                return false;
            }
            
            /*
             * 1. Set additional scene as active scene
             * 2. Copy RenderSettings properties through a custom cache class
             * 3. Switch back to scenario scene as active scene, then apply cache
             */

            string scenarioSceneName = scenarioScene.GetSceneName();
            string additionalSceneName = additionalScenes[0].GetSceneName();

            await UniTask.WaitUntil(() =>
                SceneManager.GetSceneByName(scenarioSceneName).isLoaded &&
                SceneManager.GetSceneByName(additionalSceneName).isLoaded);

            Scene additionalScene = SceneManager.GetSceneByName(additionalSceneName);
            
            SceneManager.SetActiveScene(additionalScene);

            await UniTask.Yield();
            
            RenderSettingsCache cache = new RenderSettingsCache();

            Scene scenarioSceneInstance = SceneManager.GetSceneByName(scenarioSceneName);
            
            SceneManager.SetActiveScene(scenarioSceneInstance);
            
            await UniTask.Yield();
            
            cache.Apply();

            Debug.Log(LogCategory.ScenarioManager, "Lighting settings applied from the first additional scene to scenario scene.");
            return true;
        }
        
        /// <summary>
        /// Compares two scenes render settings and returns true if they (loosely) match
        /// </summary>
        public static async UniTask<bool> CompareSceneRenderSettingsAsync(SceneReference sceneRef1, SceneReference sceneRef2)
        {
            Scene originalActiveScene = SceneManager.GetActiveScene();

            string sceneName1 = sceneRef1.GetSceneName();
            await UniTask.WaitUntil(() => SceneManager.GetSceneByName(sceneName1).isLoaded);
            Scene scene1 = SceneManager.GetSceneByName(sceneName1);
            SceneManager.SetActiveScene(scene1);

            RenderSettingsCache cache1 = new RenderSettingsCache();

            string sceneName2 = sceneRef2.GetSceneName();
            await UniTask.WaitUntil(() => SceneManager.GetSceneByName(sceneName2).isLoaded);
            Scene scene2 = SceneManager.GetSceneByName(sceneName2);
            SceneManager.SetActiveScene(scene2);

            RenderSettingsCache cache2 = new RenderSettingsCache();

            SceneManager.SetActiveScene(originalActiveScene);

            return cache1 == cache2;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/ScenarioUtiltites/ScenarioHelper.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/TutorialScenario.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 30ab83767d6b4dc98e75ba0090c88abc
# ASMDEF: ldx.framework.runtime.dll
# ---
namespace Ldx.Framework.Systems.ScenarioManagement
{
    public class TutorialScenario : BaseScenario
    {
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/ScenarioManagement/TutorialScenario.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/SceneManagement/SceneReference.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 81caca5dff2f308489dea597aa7a1b1f
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEngine;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Ldx.Framework.Systems.SceneManagement
{

// Author: JohannesMP (2018-08-12)
//
// A wrapper that provides the means to safely serialize Scene Asset References.
// 
// Internally we serialize an Object to the SceneAsset which only exists at editor time.
// Any time the object is serialized, we store the path provided by this Asset (assuming it was valid).
// 
// This means that, come build time, the string path of the scene asset is always already stored, which if 
// the scene was added to the build settings means it can be loaded.
// 
// It is up to the user to ensure the scene exists in the build settings so it is loadable at runtime.
// To help with this, a custom PropertyDrawer displays the scene build settings state.
// 
// Known issues:
//     -   When reverting back to a prefab which has the asset stored as null, Unity will show the property 
//         as modified despite having just reverted. This only happens the fist time, and reverting again 
//         fixes it. Under the hood the state is still always valid, and serialized correctly regardless.


    /// <summary>
    /// A wrapper that provides the means to safely serialize Scene Asset References.
    /// </summary>
    [System.Serializable]
    public class SceneReference : ISerializationCallbackReceiver
    {
#if UNITY_EDITOR
        // What we use in editor to select the scene
        [SerializeField] private Object sceneAsset = null;
        bool IsValidSceneAsset
        {
            get
            {
                if (sceneAsset == null)
                    return false;
                return sceneAsset.GetType().Equals(typeof(SceneAsset));
            }
        }
#endif

        // This should only ever be set during serialization/deserialization!
        [SerializeField]
        private string scenePath = string.Empty;

        // Use this when you want to actually have the scene path
        public string ScenePath
        {
            get
            {
#if UNITY_EDITOR
                // In editor we always use the asset's path
                return GetScenePathFromAsset();
#else
            // At runtime we rely on the stored path value which we assume was serialized correctly at build time.
            // See OnBeforeSerialize and OnAfterDeserialize
            return scenePath;
#endif
            }
            set
            {
                scenePath = value;
#if UNITY_EDITOR
                sceneAsset = GetSceneAssetFromPath();
#endif
            }
        }
        
        public bool IsValid()
        {
#if UNITY_EDITOR
            return sceneAsset != null && IsValidSceneAsset && !string.IsNullOrEmpty(scenePath);
#else
            return !string.IsNullOrEmpty(scenePath);
#endif
        }

        public static implicit operator string(SceneReference sceneReference)
        {
            return sceneReference.ScenePath;
        }

        public string GetSceneName()
        {
            Regex regex = new Regex(@"([^/]+)\.unity$");
            Match match = regex.Match(ScenePath);

            if (match.Success)
            {
                return match.Groups[1].Value;
            }
            else
            {
                return null;
            }
        }

        // Called to prepare this data for serialization. Stubbed out when not in editor.
        public void OnBeforeSerialize()
        {
#if UNITY_EDITOR
            HandleBeforeSerialize();
#endif
        }

        // Called to set up data for deserialization. Stubbed out when not in editor.
        public void OnAfterDeserialize()
        {
#if UNITY_EDITOR
            // We sadly cannot touch assetdatabase during serialization, so defer by a bit.
            EditorApplication.update += HandleAfterDeserialize;
#endif
        }



#if UNITY_EDITOR
        private SceneAsset GetSceneAssetFromPath()
        {
            if (string.IsNullOrEmpty(scenePath))
                return null;
            return AssetDatabase.LoadAssetAtPath<SceneAsset>(scenePath);
        }

        private string GetScenePathFromAsset()
        {
            if (sceneAsset == null)
                return string.Empty;
            return AssetDatabase.GetAssetPath(sceneAsset);
        }

        private void HandleBeforeSerialize()
        {
            // Asset is invalid but have Path to try and recover from
            if (IsValidSceneAsset == false && string.IsNullOrEmpty(scenePath) == false)
            {
                sceneAsset = GetSceneAssetFromPath();
                if (sceneAsset == null)
                    scenePath = string.Empty;

                UnityEditor.SceneManagement.EditorSceneManager.MarkAllScenesDirty();
            }
            // Asset takes precendence and overwrites Path
            else
            {
                scenePath = GetScenePathFromAsset();
            }
        }

        private void HandleAfterDeserialize()
        {
            EditorApplication.update -= HandleAfterDeserialize;
            // Asset is valid, don't do anything - Path will always be set based on it when it matters
            if (IsValidSceneAsset)
                return;

            // Asset is invalid but have path to try and recover from
            if (string.IsNullOrEmpty(scenePath) == false)
            {
                sceneAsset = GetSceneAssetFromPath();
                // No asset found, path was invalid. Make sure we don't carry over the old invalid path
                if (sceneAsset == null)
                    scenePath = string.Empty;

                if (Application.isPlaying == false)
                    UnityEditor.SceneManagement.EditorSceneManager.MarkAllScenesDirty();
            }
        }
#endif
    }


#if UNITY_EDITOR
    /// <summary>
    /// Display a Scene Reference object in the editor.
    /// If scene is valid, provides basic buttons to interact with the scene's role in Build Settings.
    /// </summary>
    [CustomPropertyDrawer(typeof(SceneReference))]
    public class SceneReferencePropertyDrawer : PropertyDrawer
    {
        // The exact name of the asset Object variable in the SceneReference object
        const string sceneAssetPropertyString = "sceneAsset";
        // The exact name of  the scene Path variable in the SceneReference object
        const string scenePathPropertyString = "scenePath";

        static readonly RectOffset boxPadding = EditorStyles.helpBox.padding;
        static readonly float padSize = 2f;
        static readonly float lineHeight = EditorGUIUtility.singleLineHeight;
        static readonly float paddedLine = lineHeight + padSize;
        static readonly float footerHeight = 10f;

        /// <summary>
        /// Drawing the 'SceneReference' property
        /// </summary>
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            var sceneAssetProperty = GetSceneAssetProperty(property);

            // Draw the Box Background
            position.height -= footerHeight;
            GUI.Box(EditorGUI.IndentedRect(position), GUIContent.none, EditorStyles.helpBox);
            position = boxPadding.Remove(position);
            position.height = lineHeight;

            // Draw the main Object field
            label.tooltip = "The actual Scene Asset reference.\nOn serialize this is also stored as the asset's path.";

            EditorGUI.BeginProperty(position, GUIContent.none, property);
            EditorGUI.BeginChangeCheck();
            int sceneControlID = GUIUtility.GetControlID(FocusType.Passive);
            var selectedObject = EditorGUI.ObjectField(position, label, sceneAssetProperty.objectReferenceValue, typeof(SceneAsset), false);
            BuildUtils.BuildScene buildScene = BuildUtils.GetBuildScene(selectedObject);

            if (EditorGUI.EndChangeCheck())
            {
                sceneAssetProperty.objectReferenceValue = selectedObject;

                // If no valid scene asset was selected, reset the stored path accordingly
                if (buildScene.scene == null)
                    GetScenePathProperty(property).stringValue = string.Empty;
            }
            position.y += paddedLine;

            if (buildScene.assetGUID.Empty() == false)
            {
                // Draw the Build Settings Info of the selected Scene
                DrawSceneInfoGUI(position, buildScene, sceneControlID + 1);
            }

            EditorGUI.EndProperty();
        }

        /// <summary>
        /// Ensure that what we draw in OnGUI always has the room it needs
        /// </summary>
        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            int lines = 2;
            SerializedProperty sceneAssetProperty = GetSceneAssetProperty(property);
            if (sceneAssetProperty.objectReferenceValue == null)
                lines = 1;

            return boxPadding.vertical + lineHeight * lines + padSize * (lines - 1) + footerHeight;
        }

        /// <summary>
        /// Draws info box of the provided scene
        /// </summary>
        private void DrawSceneInfoGUI(Rect position, BuildUtils.BuildScene buildScene, int sceneControlID)
        {
            bool readOnly = BuildUtils.IsReadOnly();
            string readOnlyWarning = readOnly ? "\n\nWARNING: Build Settings is not checked out and so cannot be modified." : "";

            // Label Prefix
            GUIContent iconContent = new();
            GUIContent labelContent = new();

            // Missing from build scenes
            if (buildScene.buildIndex == -1)
            {
                iconContent = GetLightIcon("redLight", "This scene is NOT in build settings.\nIt will be NOT included in builds.");
                labelContent.text = "NOT In Build";
            }
            // In build scenes and enabled
            else if (buildScene.scene.enabled)
            {
                iconContent = GetLightIcon("greenLight", $"This scene is in build settings and ENABLED.\nIt will be included in builds. {readOnlyWarning}");
                labelContent.text = $"BuildIndex: {buildScene.buildIndex}";
            }
            // In build scenes and disabled
            else
            {
                iconContent = GetLightIcon("yellowLight", "This scene is in build settings and DISABLED.\nIt will be NOT included in builds.");
                labelContent.text = $"BuildIndex: {buildScene.buildIndex}";
            }

            // Left status label
            using (new EditorGUI.DisabledScope(readOnly))
            {
                Rect labelRect = DrawUtils.GetLabelRect(position);
                Rect iconRect = labelRect;
                iconRect.width = iconContent.image.width + padSize;
                labelRect.width -= iconRect.width;
                labelRect.x += iconRect.width;
                EditorGUI.PrefixLabel(iconRect, sceneControlID, iconContent);
                EditorGUI.PrefixLabel(labelRect, sceneControlID, labelContent);
            }

            // Right context buttons
            Rect buttonRect = DrawUtils.GetFieldRect(position);
            buttonRect.width = (buttonRect.width) / 3;

            string tooltipMsg = "";
            using (new EditorGUI.DisabledScope(readOnly))
            {
                // NOT in build settings
                if (buildScene.buildIndex == -1)
                {
                    buttonRect.width *= 2;
                    int addIndex = EditorBuildSettings.scenes.Length;
                    tooltipMsg = "Add this scene to build settings. It will be appended to the end of the build scenes as buildIndex: " + addIndex + "." + readOnlyWarning;
                    if (DrawUtils.ButtonHelper(buttonRect, "Add...", "Add (buildIndex " + addIndex + ")", EditorStyles.miniButtonLeft, tooltipMsg))
                        BuildUtils.AddBuildScene(buildScene);
                    buttonRect.width /= 2;
                    buttonRect.x += buttonRect.width;
                }
                // In build settings
                else
                {
                    bool isEnabled = buildScene.scene.enabled;
                    string stateString = isEnabled ? "Disable" : "Enable";
                    tooltipMsg = stateString + " this scene in build settings.\n" + (isEnabled ? "It will no longer be included in builds" : "It will be included in builds") + "." + readOnlyWarning;

                    if (DrawUtils.ButtonHelper(buttonRect, stateString, stateString + " In Build", EditorStyles.miniButtonLeft, tooltipMsg))
                        BuildUtils.SetBuildSceneState(buildScene, !isEnabled);
                    buttonRect.x += buttonRect.width;

                    tooltipMsg = "Completely remove this scene from build settings.\nYou will need to add it again for it to be included in builds!" + readOnlyWarning;
                    if (DrawUtils.ButtonHelper(buttonRect, "Remove...", "Remove from Build", EditorStyles.miniButtonMid, tooltipMsg))
                        BuildUtils.RemoveBuildScene(buildScene);
                }
            }

            buttonRect.x += buttonRect.width;

            tooltipMsg = "Open the 'Build Settings' Window for managing scenes." + readOnlyWarning;
            if (DrawUtils.ButtonHelper(buttonRect, "Settings", "Build Settings", EditorStyles.miniButtonRight, tooltipMsg))
            {
                BuildUtils.OpenBuildSettings();
            }

        }
        
        static GUIContent GetLightIcon(string baseName, string tooltip)
        {
            string iconName = EditorGUIUtility.isProSkin ? $"d_{baseName}" : baseName;
            return EditorGUIUtility.IconContent(iconName, tooltip);
        }

        static SerializedProperty GetSceneAssetProperty(SerializedProperty property)
        {
            return property.FindPropertyRelative(sceneAssetPropertyString);
        }

        static SerializedProperty GetScenePathProperty(SerializedProperty property)
        {
            return property.FindPropertyRelative(scenePathPropertyString);
        }

        private static class DrawUtils
        {
            /// <summary>
            /// Draw a GUI button, choosing between a short and a long button text based on if it fits
            /// </summary>
            static public bool ButtonHelper(Rect position, string msgShort, string msgLong, GUIStyle style, string tooltip = null)
            {
                GUIContent content = new GUIContent(msgLong);
                content.tooltip = tooltip;

                float longWidth = style.CalcSize(content).x;
                if (longWidth > position.width)
                    content.text = msgShort;

                return GUI.Button(position, content, style);
            }

            /// <summary>
            /// Given a position rect, get its field portion
            /// </summary>
            static public Rect GetFieldRect(Rect position)
            {
                position.width -= EditorGUIUtility.labelWidth;
                position.x += EditorGUIUtility.labelWidth;
                return position;
            }
            /// <summary>
            /// Given a position rect, get its label portion
            /// </summary>
            static public Rect GetLabelRect(Rect position)
            {
                position.width = EditorGUIUtility.labelWidth - padSize;
                return position;
            }
        }

        /// <summary>
        /// Various BuildSettings interactions
        /// </summary>
        static private class BuildUtils
        {
            // time in seconds that we have to wait before we query again when IsReadOnly() is called.
            public static float minCheckWait = 3;

            static float lastTimeChecked = 0;
            static bool cachedReadonlyVal = true;

            /// <summary>
            /// A small container for tracking scene data BuildSettings
            /// </summary>
            public struct BuildScene
            {
                public int buildIndex;
                public GUID assetGUID;
                public string assetPath;
                public EditorBuildSettingsScene scene;
            }

            /// <summary>
            /// Check if the build settings asset is readonly.
            /// Caches value and only queries state a max of every 'minCheckWait' seconds.
            /// </summary>
            static public bool IsReadOnly()
            {
                float curTime = Time.realtimeSinceStartup;
                float timeSinceLastCheck = curTime - lastTimeChecked;

                if (timeSinceLastCheck > minCheckWait)
                {
                    lastTimeChecked = curTime;
                    cachedReadonlyVal = QueryBuildSettingsStatus();
                }

                return cachedReadonlyVal;
            }

            /// <summary>
            /// A blocking call to the Version Control system to see if the build settings asset is readonly.
            /// Use BuildSettingsIsReadOnly for version that caches the value for better responsivenes.
            /// </summary>
            static private bool QueryBuildSettingsStatus()
            {
                // If no version control provider, assume not readonly
                if (UnityEditor.VersionControl.Provider.enabled == false)
                    return false;

                // If we cannot checkout, then assume we are not readonly
                if (UnityEditor.VersionControl.Provider.hasCheckoutSupport == false)
                    return false;

                //// If offline (and are using a version control provider that requires checkout) we cannot edit.
                //if (UnityEditor.VersionControl.Provider.onlineState == UnityEditor.VersionControl.OnlineState.Offline)
                //    return true;

                // Try to get status for file
                var status = UnityEditor.VersionControl.Provider.Status("ProjectSettings/EditorBuildSettings.asset", false);
                status.Wait();

                // If no status listed we can edit
                if (status.assetList == null || status.assetList.Count != 1)
                    return true;

                // If is checked out, we can edit
                if (status.assetList[0].IsState(UnityEditor.VersionControl.Asset.States.CheckedOutLocal))
                    return false;

                return true;
            }

            /// <summary>
            /// For a given Scene Asset object reference, extract its build settings data, including buildIndex.
            /// </summary>
            static public BuildScene GetBuildScene(Object sceneObject)
            {
                BuildScene entry = new BuildScene()
                {
                    buildIndex = -1,
                    assetGUID = new GUID(string.Empty)
                };

                if (sceneObject as SceneAsset == null)
                    return entry;

                entry.assetPath = AssetDatabase.GetAssetPath(sceneObject);
                entry.assetGUID = new GUID(AssetDatabase.AssetPathToGUID(entry.assetPath));

                for (int index = 0; index < EditorBuildSettings.scenes.Length; ++index)
                {
                    if (entry.assetGUID.Equals(EditorBuildSettings.scenes[index].guid))
                    {
                        entry.scene = EditorBuildSettings.scenes[index];
                        entry.buildIndex = index;
                        return entry;
                    }
                }

                return entry;
            }

            /// <summary>
            /// Enable/Disable a given scene in the buildSettings
            /// </summary>
            static public void SetBuildSceneState(BuildScene buildScene, bool enabled)
            {
                bool modified = false;
                EditorBuildSettingsScene[] scenesToModify = EditorBuildSettings.scenes;
                foreach (var curScene in scenesToModify)
                {
                    if (curScene.guid.Equals(buildScene.assetGUID))
                    {
                        curScene.enabled = enabled;
                        modified = true;
                        break;
                    }
                }
                if (modified)
                    EditorBuildSettings.scenes = scenesToModify;
            }

            /// <summary>
            /// Display Dialog to add a scene to build settings
            /// </summary>
            static public void AddBuildScene(BuildScene buildScene, bool force = false, bool enabled = true)
            {
                if (force == false)
                {
                    int selection = EditorUtility.DisplayDialogComplex(
                        "Add Scene To Build",
                        "You are about to add scene at " + buildScene.assetPath + " To the Build Settings.",
                        "Add as Enabled",       // option 0
                        "Add as Disabled",      // option 1
                        "Cancel (do nothing)"); // option 2

                    switch (selection)
                    {
                        case 0: // enabled
                            enabled = true;
                            break;
                        case 1: // disabled
                            enabled = false;
                            break;
                        default:
                        case 2: // cancel
                            return;
                    }
                }

                EditorBuildSettingsScene newScene = new EditorBuildSettingsScene(buildScene.assetGUID, enabled);
                List<EditorBuildSettingsScene> tempScenes = EditorBuildSettings.scenes.ToList();
                tempScenes.Add(newScene);
                EditorBuildSettings.scenes = tempScenes.ToArray();
            }

            /// <summary>
            /// Display Dialog to remove a scene from build settings (or just disable it)
            /// </summary>
            static public void RemoveBuildScene(BuildScene buildScene, bool force = false)
            {
                bool onlyDisable = false;
                if (force == false)
                {
                    int selection = -1;

                    string title = "Remove Scene From Build";
                    string details = string.Format("You are about to remove the following scene from build settings:\n    {0}\n    buildIndex: {1}\n\n{2}",
                        buildScene.assetPath, buildScene.buildIndex,
                        "This will modify build settings, but the scene asset will remain untouched.");
                    string confirm = "Remove From Build";
                    string alt = "Just Disable";
                    string cancel = "Cancel (do nothing)";

                    if (buildScene.scene.enabled)
                    {
                        details += "\n\nIf you want, you can also just disable it instead.";
                        selection = EditorUtility.DisplayDialogComplex(title, details, confirm, alt, cancel);
                    }
                    else
                    {
                        selection = EditorUtility.DisplayDialog(title, details, confirm, cancel) ? 0 : 2;
                    }

                    switch (selection)
                    {
                        case 0: // remove
                            break;
                        case 1: // disable
                            onlyDisable = true;
                            break;
                        default:
                        case 2: // cancel
                            return;
                    }
                }

                // User chose to not remove, only disable the scene
                if (onlyDisable)
                {
                    SetBuildSceneState(buildScene, false);
                }
                // User chose to fully remove the scene from build settings
                else
                {
                    List<EditorBuildSettingsScene> tempScenes = EditorBuildSettings.scenes.ToList();
                    tempScenes.RemoveAll(scene => scene.guid.Equals(buildScene.assetGUID));
                    EditorBuildSettings.scenes = tempScenes.ToArray();
                }
            }

            /// <summary>
            /// Open the default Unity Build Settings window
            /// </summary>
            static public void OpenBuildSettings()
            {
                EditorWindow.GetWindow(typeof(BuildPlayerWindow));
            }
        }
    }

#endif
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/SceneManagement/SceneReference.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Scoring/ScoringData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 13e47a4f765a420d850cede94c977daf
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Scripts.Systems.Scoring
{
    [HelpURL("https://logicaldox.atlassian.net/wiki/spaces/LBVF/pages/3062267909/Scenario+Scoring+System")]
    [CreateAssetMenu(menuName = "Idealogical/ScoringData", fileName = "ScoringData_{ScenarioName}")]
    public class ScoringData : ScriptableObject
    { 
        [Serializable]
        public class ScoreRule
        {
            [SerializeField] private string eventName;
            public string EventName => eventName;

            [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
            [SerializeField] private string trackingEvent;
            public string TrackingEvent => trackingEvent;

            public enum EventType
            {
                ScorableTask = 0,
                Mistake = 1,
                CriticalMistake = 2,
            }
            
            [SerializeField] private EventType eventType;
            public EventType RuleEventType => eventType;
            
            [Tooltip("For 'ScorableTask': How many 'opportunity points' this task represents for 100% accuracy. " +
                     "For 'Error': How many 'opportunity points' are lost if this non-critical error occurs.")]
            [SerializeField] private float pointsValue;
            public float PointsValue => pointsValue;

            [Tooltip("Can this event be triggered multiple times? If false, it's only processed once.")]
            [SerializeField] private bool allowMultipleTriggers = true;
            public bool AllowMultipleTriggers => allowMultipleTriggers; 
        }
        
        public enum ScoringSystemMode
        {
            Percentage = 0, // Value is a ratio (0.0 to 1.0) of maxScore (for Accuracy) or of a defined total (for Accumulative if desired)
            AbsolutePoints = 1 // Value is a direct point score
        }
        
        [SerializeField] private ScoringSystemMode scoringSystemMode = ScoringSystemMode.AbsolutePoints;
        public ScoringSystemMode ScoringMode => scoringSystemMode;
        
        [Tooltip("Initial score when the scenario begins. " +
                 "AccuracyDeductive: Often the 'maxScore' representing 100%. " +
                 "PointsAccumulative: Usually 0.")]
        [SerializeField] private float startScore = 0f;
        public float StartScore => startScore;

        [Tooltip("Minimum score the trainee can reach. Score will not drop below this value.")]
        [SerializeField] private float minScore = 0f;
        public float MinScore => minScore;

        [Tooltip("Maximum score the trainee can achieve. Score will not exceed this value. " +
                 "AccuracyDeductive: This would be the 100% mark. " +
                 "PointsAccumulative: Could be a target maximum or just an upper cap.")]
        [SerializeField] private float maxScore = 100f;
        public float MaxScore => maxScore;
        
        [Tooltip("Defines how the 'Passing Threshold Value' is interpreted.")]
        [SerializeField] private ScoringSystemMode passingScoringSystemMode = ScoringSystemMode.Percentage;
        public ScoringSystemMode PassingScoringSystemMode => passingScoringSystemMode;
        
        [Tooltip("For AccuracyDeductive: Target accuracy (fraction, e.g., 0.8 for 80%) derived from (currentScore / maxScore)." +
                 "For PointsAccumulative: Minimum points value required to pass.")]
        [SerializeField] private float passingThreshold = 0.8f;
        public float PassingThreshold => passingThreshold;

        [SerializeField] private bool immediateFailOnMinScore = true;
        public bool ImmediateFailOnMinScore => immediateFailOnMinScore;

        [SerializeField] private List<ScoreRule> scoreRules = new();
        public List<ScoreRule> ScoreRules => scoreRules;

        public void OnValidate()
        {
            if (minScore > startScore) startScore = minScore;
            if (startScore > maxScore) maxScore = startScore;
            if (minScore > maxScore) minScore = maxScore;

            if (passingScoringSystemMode == ScoringSystemMode.Percentage)
            {
                if (passingThreshold > 1.0f) passingThreshold = 1.0f;
                if (passingThreshold < 0.0f) passingThreshold = 0.0f;
            }
            else
            {
                passingThreshold = Mathf.Clamp(passingThreshold, minScore, maxScore);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Scoring/ScoringData.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Scoring/ScoringSystem.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 42e71ade7a4b4460a747d6943ead2ac4
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities;
using UnityEngine;

namespace Ldx.Framework.Scripts.Systems.Scoring
{
    public class ScoringSystem : Singleton<ScoringSystem>
    {
        public static event Action<ScoringSystem> OnCriticalScoreReached;

        /// <summary>
        /// Passes this scoring system, the triggered rule (nullable), change in score (default to 0), & currentScore
        /// </summary>
        public static event Action<ScoringSystem, ScoringData.ScoreRule, float, float> OnReportScoringAction;

        public static event Action<ScoringSystem, EvaluationResult> OnEvaluationResultsCreated;

        private float currentScore;
        private readonly HashSet<string> triggeredCriticalEventIDs = new();
        private readonly Dictionary<string, int> eventTriggerCounts = new();
        private readonly HashSet<string> completedScorableTaskIDs = new();

        private readonly Dictionary<string, ScoringData.ScoreRule> scoreRulesCache = new();

        public class EvaluationResult
        {
            public enum Result
            {
                Pass = 0,
                Fail = 1
            }

            public string ScenarioID { get; set; }
            public Result ScenarioResult { get; set; }
            public float FinalDisplayScore { get; set; }
            public string ScoreInterpretation { get; set; }
            public List<string> FailureReasons { get; set; } = new();
            public HashSet<string> CriticalErrorsTriggered { get; set; } = new();
            public int ScorableTasksTotal { get; set; }
            public int ScorableTasksCompleted { get; set; }
        }

        //string = scenario ID
        private readonly Dictionary<string, EvaluationResult> scenarioEvaluationHistory = new();

        private ScoringData ScoringData { get; set; }
        private string ScenarioID { get; set; }
        public bool IsActive { get; private set; }
        public static bool IsBlocked { get; set; }

        private float thresholdToMeet;
        private bool reachedCritical;

        public bool IsPassing
        {
            get
            {
                if (ScoringData == null) return false;

                if (triggeredCriticalEventIDs.Count > 0)
                {
                    return false;
                }

                float threshold = ScoringData.ScoringMode == ScoringData.ScoringSystemMode.Percentage
                    ? ScoringData.PassingThreshold * ScoringData.MaxScore
                    : ScoringData.PassingThreshold;

                return currentScore >= threshold;
            }
        }

        public void InitializeSystem(ScoringData scoringData, string scenarioID)
        {
            if (scoringData == null)
            {
                return;
            }

            ResetSystem();
            ScoringData = scoringData;
            InitializeScoreRulesCache();
            ResetEvaluation(scenarioID);
            ScenarioID = scenarioID;
        }

        private void InitializeScoreRulesCache()
        {
            scoreRulesCache.Clear();
            if (ScoringData == null || ScoringData.ScoreRules == null)
            {
                return;
            }

            foreach (ScoringData.ScoreRule rule in ScoringData.ScoreRules)
            {
                if (string.IsNullOrEmpty(rule.TrackingEvent))
                {
                    Debug.LogWarning(
                        $"ScoreRule '{rule.EventName}' has an empty or null TrackingEvent ID. It will be ignored by the scoring system.");
                    continue;
                }

                scoreRulesCache[rule.TrackingEvent] = rule;
            }
        }

        public void ResetSystem()
        {
            UnsubscribeFromEvents();

            ScoringData = null;
            IsActive = false;

            currentScore = 0f;
            reachedCritical = false;
            triggeredCriticalEventIDs.Clear();
            eventTriggerCounts.Clear();
            completedScorableTaskIDs.Clear();
            scoreRulesCache.Clear();
        }

        public void StartSystem()
        {
            if (ScoringData == null)
            {
                return;
            }

            if (IsActive)
            {
                return;
            }

            if (IsBlocked)
            {
                waitUntilUnblockedThenStartSystemAsync().Forget();
                return;
            }

            currentScore = ScoringData.StartScore;
            triggeredCriticalEventIDs.Clear();
            eventTriggerCounts.Clear();
            completedScorableTaskIDs.Clear();

            IsActive = true;
            SubscribeToEvents();

            async UniTaskVoid waitUntilUnblockedThenStartSystemAsync()
            {
                if (IsBlocked)
                {
                    await UniTask.WaitUntil(() => !IsBlocked);
                }

                StartSystem();
            }
        }

        public void StopSystem()
        {
            if (!IsActive)
            {
                return;
            }

            IsActive = false;
            UnsubscribeFromEvents();
        }

        private void SubscribeToEvents()
        {
            LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
        }

        private void UnsubscribeFromEvents()
        {
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }
        }

        private void HandleTrackingEvent(string trackingEventID)
        {
            if (!IsActive || ScoringData == null)
            {
                return;
            }

            if (scoreRulesCache.TryGetValue(trackingEventID, out ScoringData.ScoreRule rule))
            {
                if (rule.RuleEventType != ScoringData.ScoreRule.EventType.CriticalMistake)
                {
                    if (eventTriggerCounts.TryGetValue(trackingEventID, out int timesTriggered) &&
                        !rule.AllowMultipleTriggers && timesTriggered > 0)
                    {
                        return;
                    }
                }

                eventTriggerCounts.TryGetValue(trackingEventID, out int currentCount);
                eventTriggerCounts[trackingEventID] = currentCount + 1;

                float points = CalculateEffectivePoints(rule);

                switch (rule.RuleEventType)
                {
                    case ScoringData.ScoreRule.EventType.ScorableTask:
                        completedScorableTaskIDs.Add(trackingEventID);
                        ApplyScoreChange(Mathf.Abs(points), rule);
                        break;
                    case ScoringData.ScoreRule.EventType.Mistake:
                        ApplyScoreChange(-Mathf.Abs(points), rule);
                        break;
                    case ScoringData.ScoreRule.EventType.CriticalMistake:
                        ProcessCriticalEvent(trackingEventID, rule);
                        break;
                }
            }
        }
        
        public void ApplyRuleById(string trackingEventID, float? overridePoints = null)
        {
            if (!IsActive || ScoringData == null)
            {
                return;
            }

            if (string.IsNullOrEmpty(trackingEventID))
            {
                return;
            }

            if (!scoreRulesCache.TryGetValue(trackingEventID, out ScoringData.ScoreRule rule))
            {
                return;
            }

            if (rule.RuleEventType != ScoringData.ScoreRule.EventType.CriticalMistake)
            {
                if (eventTriggerCounts.TryGetValue(trackingEventID, out int timesTriggered) &&
                    !rule.AllowMultipleTriggers && timesTriggered > 0)
                {
                    return;
                }
            }

            eventTriggerCounts.TryGetValue(trackingEventID, out int currentCount);
            eventTriggerCounts[trackingEventID] = currentCount + 1;

            if (rule.RuleEventType == ScoringData.ScoreRule.EventType.CriticalMistake)
            {
                ProcessCriticalEvent(trackingEventID, rule);
                return;
            }

            float points;

            if (overridePoints.HasValue)
            {
                float basePoints = overridePoints.Value;

                switch (ScoringData.ScoringMode)
                {
                    case ScoringData.ScoringSystemMode.Percentage:
                        if (ScoringData.MaxScore == 0f && basePoints != 0f)
                        {
                            Debug.LogWarning(
                                $"Rule '{rule.EventName}' uses Percentage, but MaxScore in ScoringData is 0. Points will be 0.");
                            points = 0f;
                        }
                        else
                        {
                            points = basePoints * ScoringData.MaxScore;
                        }

                        break;

                    case ScoringData.ScoringSystemMode.AbsolutePoints:
                        points = basePoints;
                        break;

                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
            else
            {
                points = CalculateEffectivePoints(rule);
            }

            switch (rule.RuleEventType)
            {
                case ScoringData.ScoreRule.EventType.ScorableTask:
                    completedScorableTaskIDs.Add(trackingEventID);
                    OnReportScoringAction?.Invoke(this, rule, points, currentScore);
                    ApplyScoreChange(Mathf.Abs(points), rule);
                    break;

                case ScoringData.ScoreRule.EventType.Mistake:
                    OnReportScoringAction?.Invoke(this, rule, points, currentScore);
                    ApplyScoreChange(-Mathf.Abs(points), rule);
                    break;
            }
        }

        private float CalculateEffectivePoints(ScoringData.ScoreRule rule)
        {
            switch (ScoringData.ScoringMode)
            {
                case ScoringData.ScoringSystemMode.Percentage:
                    if (ScoringData.MaxScore == 0f && rule.PointsValue != 0)
                    {
                        Debug.LogWarning(
                            $"Rule '{rule.EventName}' uses Percentage, but MaxScore in ScoringData is 0. Points will be 0.");
                        return 0f;
                    }

                    return rule.PointsValue * ScoringData.MaxScore;
                case ScoringData.ScoringSystemMode.AbsolutePoints:
                    return rule.PointsValue;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        private void ApplyScoreChange(float scoreChange, ScoringData.ScoreRule rule)
        {
            if (scoreChange == 0)
            {
                return;
            }

            currentScore += scoreChange;
            currentScore = Mathf.Clamp(currentScore, ScoringData.MinScore, ScoringData.MaxScore);
            ReportScoringAction(rule, scoreChange);

            PlayScoringSound(scoreChange > 0
                ? AudioGlobalSettings.ScoringSystemOnScorableTaskSound
                : AudioGlobalSettings.ScoringSystemMistakeSound);

            if (ScoringData.ImmediateFailOnMinScore && currentScore <= ScoringData.MinScore)
            {
                CriticalScoreReached();
            }
        }

        private void ProcessCriticalEvent(string trackingEventID, ScoringData.ScoreRule rule)
        {
            if (!triggeredCriticalEventIDs.Add(trackingEventID))
            {
                return;
            }

            ReportScoringAction(rule);
            CriticalScoreReached();
        }

        private void CriticalScoreReached()
        {
            if (reachedCritical)
            {
                return;
            }

            reachedCritical = true;
            PlayScoringSound(AudioGlobalSettings.ScoringSystemCriticalMistakeSound);
            OnCriticalScoreReached?.Invoke(this);
        }

        #region Evaluation

        private void ResetEvaluation(string scenarioID)
        {
            scenarioEvaluationHistory.Remove(scenarioID);
        }

        public void ResetAllEvaluations()
        {
            scenarioEvaluationHistory.Clear();
        }

        #endregion

        public EvaluationResult EvaluateScenario()
        {
            EvaluationResult result = new()
            {
                ScenarioID = ScenarioID,
            };
            
            if (ScoringData == null)
            {
                result.FailureReasons.Add("Scoring data not loaded.");
                result.ScenarioResult = EvaluationResult.Result.Fail;
            }

            result.ScenarioResult = triggeredCriticalEventIDs.Count > 0
                ? EvaluationResult.Result.Fail
                : EvaluationResult.Result.Pass;

            result.CriticalErrorsTriggered = new HashSet<string>(triggeredCriticalEventIDs);
            foreach (string critical in result.CriticalErrorsTriggered)
            {
                ScoringData.ScoreRule rule = ScoringData.ScoreRules.FirstOrDefault(r => r.TrackingEvent == critical);
                result.FailureReasons.Add($"Critical Error: {(rule != null ? rule.EventName : critical)}");
            }

            List<ScoringData.ScoreRule> allScorableTaskRules = ScoringData.ScoreRules
                .Where(r => r.RuleEventType == ScoringData.ScoreRule.EventType.ScorableTask).ToList();
            result.ScorableTasksTotal = allScorableTaskRules.Count;
            result.ScorableTasksCompleted = completedScorableTaskIDs.Count;

            if (result.ScenarioResult == EvaluationResult.Result.Pass)
            {
                float thresholdToMeet;
                string scoreComparisonString;

                if (ScoringData.PassingScoringSystemMode == ScoringData.ScoringSystemMode.Percentage)
                {
                    if (ScoringData.MaxScore == 0f)
                    {
                        thresholdToMeet = float.MaxValue;
                    }
                    else
                    {
                        thresholdToMeet = ScoringData.PassingThreshold * ScoringData.MaxScore;
                    }

                    result.FinalDisplayScore =
                        (ScoringData.MaxScore > 0) ? (currentScore / ScoringData.MaxScore) * 100f : 0f;
                    result.ScoreInterpretation = "Accuracy %";
                    scoreComparisonString =
                        $"{result.FinalDisplayScore:F1}% vs required {(ScoringData.PassingThreshold * 100f):F1}% (equivalent to {currentScore:F1} / {thresholdToMeet:F1} points)";
                }
                else
                {
                    thresholdToMeet = ScoringData.PassingThreshold;
                    result.FinalDisplayScore = currentScore;
                    result.ScoreInterpretation = "Points";
                    scoreComparisonString = $"{currentScore:F1} vs required {thresholdToMeet:F1} points";
                }

                if (currentScore < thresholdToMeet)
                {
                    result.ScenarioResult = EvaluationResult.Result.Fail;
                    result.FailureReasons.Add($"Score below threshold: {scoreComparisonString}");
                }
            }
            else
            {
                if (ScoringData.PassingScoringSystemMode == ScoringData.ScoringSystemMode.Percentage)
                {
                    result.FinalDisplayScore =
                        (ScoringData.MaxScore > 0) ? (currentScore / ScoringData.MaxScore) * 100f : 0f;
                    result.ScoreInterpretation = "Accuracy %";
                }
                else
                {
                    result.FinalDisplayScore = currentScore;
                    result.ScoreInterpretation = "Points";
                }
            }

            scenarioEvaluationHistory[ScenarioID] = result;
            OnEvaluationResultsCreated?.Invoke(this, result);
            return result;
        }

        private void ReportScoringAction(ScoringData.ScoreRule rule = null, float scoreChange = 0f)
        {
            OnReportScoringAction?.Invoke(this, rule, scoreChange, currentScore);
        }

        public (EvaluationResult.Result, List<EvaluationResult>) EvaluateAllScenarios()
        {
            if (!scenarioEvaluationHistory.ContainsKey(ScenarioID))
            {
                EvaluateScenario();
            }

            EvaluationResult.Result overallResult =
                scenarioEvaluationHistory.Values.All(x => x.ScenarioResult == EvaluationResult.Result.Pass)
                    ? EvaluationResult.Result.Pass
                    : EvaluationResult.Result.Fail;

            return (overallResult, scenarioEvaluationHistory.Values.ToList());
        }

        private void PlayScoringSound(string sound)
        {
            Audio.PlayOneShot(sound);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Scoring/ScoringSystem.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Settings/EditorGlobalSettings.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: be6e165faebb452db1170e880ab812f7
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities;
using UnityEngine;
using UnityEngine.UIElements;

namespace Systems.Settings
{
    public class EditorGlobalSettings : GlobalSettings<EditorGlobalSettings>
    {
        [Header("Localization window")]
        [SerializeField] 
        private VisualTreeAsset localizationWindowXml;
        public static VisualTreeAsset LocalizationWindowXml => Instance.localizationWindowXml;

        [SerializeField] 
        private StyleSheet localizationWindowStyle;
        public static StyleSheet LocalizationWindowStyle => Instance.localizationWindowStyle;
        
        [SerializeField] 
        private VisualTreeAsset localizationTableButton;
        public static VisualTreeAsset LocalizationTableButton => Instance.localizationTableButton;
        
        [SerializeField] 
        private VisualTreeAsset textDataEntryXml;
        public static VisualTreeAsset TextDataEntryXml => Instance.textDataEntryXml;

        [SerializeField]
        private VisualTreeAsset tableHeaderLabelXml;
        public static VisualTreeAsset TableHeaderLabelXml => Instance.tableHeaderLabelXml;

        [SerializeField]
        private VisualTreeAsset localizationValueTextXml;
        public static VisualTreeAsset LocalizationValueTextXml => Instance.localizationValueTextXml;
        
        [SerializeField] 
        private VisualTreeAsset addNewEntryButtonXml;
        public static VisualTreeAsset AddNewEntryButtonXml => Instance.addNewEntryButtonXml;
        
        [SerializeField]
        private Texture localizationEntryNotSavedTexture;
        public static Texture LocalizationEntryNotSavedTexture => Instance.localizationEntryNotSavedTexture;

        [SerializeField]
        private Texture localizationEntrySavedTexture;
        public static Texture LocalizationEntrySavedTexture => Instance.localizationEntrySavedTexture;

        [SerializeField]
        private Color localizationHeaderColor;
        public static Color LocalizationHeaderColor => Instance.localizationHeaderColor;
        
        [SerializeField]
        private Color localizationHeaderBorderColor;
        public static Color LocalizationHeaderBorderColor => Instance.localizationHeaderBorderColor;
        
        [SerializeField]
        private Texture localizationKeyLockedTexture;
        public static Texture LocalizationKeyLockedTexture => Instance.localizationKeyLockedTexture;

        [SerializeField]
        private Texture localizationKeyUnlockedTexture;
        public static Texture LocalizationKeyUnlockedTexture => Instance.localizationKeyUnlockedTexture;

        [Header("Objective window")]
        [SerializeField] 
        private VisualTreeAsset objectiveWindowXml;
        public static VisualTreeAsset ObjectiveWindowXml => Instance.objectiveWindowXml;
        
        [SerializeField] 
        private StyleSheet objectiveWindowStyle;
        public static StyleSheet ObjectiveWindowStyle => Instance.objectiveWindowStyle;
        
        [SerializeField] 
        private StyleSheet baseNodeStyle;
        public static StyleSheet BaseNodeStyle => Instance.baseNodeStyle;
        
        [SerializeField] 
        private StyleSheet objectiveNodeStyle;
        public static StyleSheet ObjectiveNodeStyle => Instance.objectiveNodeStyle;


        [SerializeField]
        private Sprite overrideObjectiveStartIcon;
        public static Sprite OverrideObjectiveStartIcon => Instance.overrideObjectiveStartIcon;

        [SerializeField] 
        private StyleSheet groupViewStyle;
        public static StyleSheet GroupViewStyle => Instance.groupViewStyle;
        
        [SerializeField] 
        private StyleSheet portViewStyle;
        public static StyleSheet PortViewStyle => Instance.portViewStyle;
        
        [SerializeField] 
        private StyleSheet portViewTypesStyle;
        public static StyleSheet PortViewTypesStyle => Instance.portViewTypesStyle;

        [SerializeField]
        private VisualTreeAsset objectiveConditionXml;
        public static VisualTreeAsset ObjectiveConditionXml => Instance.objectiveConditionXml;
        
        [SerializeField]
        private VisualTreeAsset optionElementXml;
        public static VisualTreeAsset OptionElementXml => Instance.optionElementXml;
        
        [Header("Objective Data Path")]
        [SerializeField] 
        private string objectiveDataPath = "Assets/Resources/Data";
        public static string ObjectiveDataPath => Instance.objectiveDataPath;

        [SerializeField]
        private string markdownConfigDataPath = "";
        public static string MarkdownConfigDataPath => Instance.markdownConfigDataPath;
        
        [Header("Dotween animation")]
        [SerializeField]
        private VisualTreeAsset dotweenAnimationXml;
        public static VisualTreeAsset DotweenAnimationXml => Instance.dotweenAnimationXml;

        [SerializeField]
        private StyleSheet dotweenAnimationStyle;
        public static StyleSheet DotweenAnimationStyle => Instance.dotweenAnimationStyle;
        
        [SerializeField]
        private VisualTreeAsset dotweenTweenElementXml;
        public static VisualTreeAsset DotweenTweenElementXml => Instance.dotweenTweenElementXml;
        
        [SerializeField]
        private StyleSheet dotweenTweenElementStyle;
        public static StyleSheet DotweenTweenElementStyle => Instance.dotweenTweenElementStyle;

        [Header("Grabbable gizmos")]
        [SerializeField]
        private Mesh rightHandGizmoMesh;
        public static Mesh RightHandGizmoMesh => Instance.rightHandGizmoMesh;
        
        [SerializeField]
        private Mesh leftHandGizmoMesh;
        public static Mesh LeftHandGizmoMesh => Instance.leftHandGizmoMesh;
        
        [SerializeField]
        private Color handGizmoColor = new Color(0, .5f, 0, 0.3f);
        public static Color HandGizmoColor => Instance.handGizmoColor;
        
#if UNITY_EDITOR
        [UnityEditor.SettingsProvider]
        public static UnityEditor.SettingsProvider CreateSettingsProvider()
        {
            return CreateGlobalSettingsProvider("Project/LDX/Systems/Editor");
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Settings/EditorGlobalSettings.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/PlayerTeleporter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ded8e68c719c499e9dec233dfba54480
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Autohand;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using Utilities.Blockers;

namespace Ldx.Framework.Systems.Teleportation
{
    [DefaultExecutionOrder(10000)]
    public class PlayerTeleporter : MonoBehaviour
    {
        private const float RADIUS_MODIFIER = 0.6f;
        
        public static event Action<PlayerTeleporter> OnTeleportationStarted;
        public static event Action<PlayerTeleporter> OnTeleportationFinished;
        public static event Action<PlayerTeleporter, bool> OnTeleportActivateDeactive;
        public static event Action<PlayerTeleporter, TeleportationZone, bool> OnTeleportationZoneHitChange;
        public static event Action<PlayerTeleporter, TeleportationZone> OnStartTeleportToTeleportationZone;
        public static event Action<PlayerTeleporter, TeleportationZone> OnTeleportToTeleportationZone;
        
        [Header("Visuals")]
        [SerializeField] private TeleporterVisuals teleportVisuals;
        
        [Header("Aim Settings")]
        [SerializeField] private LayerMask layerMask = ~0;
        [SerializeField] private LayerMask noTeleportationMask = ~0;
        [SerializeField] private float maxSurfaceAngle = 45f;
        [SerializeField][Min(0)] private float distanceMultiplier = 1f;
        [SerializeField][Min(0)] private float curveStrength = 1f;
        
        [Header("Line Settings")]
        [SerializeField] private int lineSegments = 75;
        
        [Space]
        [Header("Debug")]
        [SerializeField] private bool enableDebugLogs;
        
        [Header("Blockers")] 
        [SerializeField]
        [ReadOnly]
        private List<MonoBehaviour> blockers = new List<MonoBehaviour>();
        private bool isBlocked = false;
        
        public bool IsAiming { get; private set; }
        public bool IsTeleportValid { get; private set; }
        public Vector3 HitPosition { get; private set; }
        public Collider HitCollider { get; private set; }

        private Vector3[] linePoints;
        private int validLinePointsCount;
        private float[] totalDistancePoints;
        private TeleportationZone lastHitZone;
        private Vector3 visualTeleportDestination;
        private bool isTeleportingAsync;
        private bool isTeleportPreviouslyValid;
        private Hand aimingHand;
        private AutoHandPlayer playerBody;
        private Transform currentAimer;
        private bool sceneHasZones;
        
        private void OnValidate()
        {
            blockers = GetComponents<IBlocker>()
                .Cast<MonoBehaviour>() // must cast back to MonoBehaviour for serialization
                .ToList();
        }
        
        protected void Awake()
        {
            linePoints = new Vector3[lineSegments];
            totalDistancePoints = new float[lineSegments];
        }

        private void Start()
        {
            playerBody = PlayerController.Instance.AutoHandPlayer;
            foreach (IBlocker blocker in blockers)
            {
                blocker.OnBlockChanged += HandleBlockerChanged;
            }
            ScenarioManager.OnLoadingFinished += HandleLoadingFinished;
            OnValidTeleportChanged(false);
        }

        private void OnDestroy()
        {
            foreach (IBlocker blocker in blockers)
            {
                blocker.OnBlockChanged -= HandleBlockerChanged;
            }
            if (ScenarioManager.IsValid)
            {
                ScenarioManager.OnLoadingFinished -= HandleLoadingFinished;
            }
        }
        
        private void HandleLoadingFinished(ScenarioManager scenarioManager)
        {
            TeleportationZonesManager teleportationZonesManager =
                FindAnyObjectByType<TeleportationZonesManager>(FindObjectsInactive.Exclude);

            sceneHasZones = teleportationZonesManager != null && teleportationZonesManager.HasZones;
        }

        private void Update()
        {
            if (!IsAiming || isTeleportingAsync)
            {
                return;
            }
            
            isTeleportPreviouslyValid = IsTeleportValid;
            CalculateAim();

            // Check if the state of validity changed
            if (isTeleportPreviouslyValid != IsTeleportValid)
            {
                OnValidTeleportChanged(IsTeleportValid);
            }

            UpdateVisuals();
        }

        /// <summary>
        /// Call this to begin the aiming process.
        /// </summary>
        public void StartAiming(Hand hand)
        {
            if (IsAiming || isTeleportingAsync || isBlocked) return;

            currentAimer = PlayerController.Instance.HandsController.GetAimerForHand(hand);
            
            if (currentAimer == null)
            {
                Debug.LogError($"Cannot start aiming. No aimer transform is configured for hand '{hand.name}' in the HandsController.");
                return;
            }
            
            IsAiming = true;
            aimingHand = hand;
            
            // Calculate initial aim immediately
            CalculateAim();
            OnValidTeleportChanged(IsTeleportValid);
            UpdateVisuals();
            teleportVisuals.RevealHideTeleportLine(true);
            
            OnTeleportActivateDeactive?.Invoke(this, true);
            LdxTrackingManager.Instance.BroadcastTrackingEvent(PlayerGlobalSettings.EventOnTeleportAiming);
            Audio.PlayOneShot(AudioGlobalSettings.PlayerTeleportPullBackSound);
        }

        /// <summary>
        /// Call this to end the aiming process and either teleport or cancel.
        /// </summary>
        public void StopAiming(Hand hand, bool ignoreValid = false)
        {
            if (!IsAiming || hand != aimingHand) return;

            if (IsTeleportValid && !ignoreValid)
            {
                Teleport();
            }

            CancelAiming();
            OnTeleportActivateDeactive?.Invoke(this, false);
        }
     
        private void CalculateAim()
        {
            Vector3 startPoint = currentAimer.position;
            Vector3 forward = currentAimer.forward;

            float currentTotalDistance = 0f;
            linePoints[0] = startPoint;
            totalDistancePoints[0] = 0f;

            bool foundHit = false;
            validLinePointsCount = lineSegments;

            for (int i = 1; i < lineSegments; i++)
            {
                float time = i / 60f; 
                Vector3 currentPoint = startPoint + (forward * time * distanceMultiplier * 15f) +
                                       Vector3.up * (curveStrength * (time - Mathf.Pow(9.8f * 0.5f * time, 2)));
                linePoints[i] = currentPoint;

                Vector3 segmentStart = linePoints[i - 1];
                Vector3 segmentDir = currentPoint - segmentStart;
                float segmentDist = segmentDir.magnitude;
                currentTotalDistance += segmentDist;
                totalDistancePoints[i] = currentTotalDistance;

                if (Physics.Raycast(segmentStart, segmentDir.normalized, out RaycastHit hit, segmentDist, layerMask, QueryTriggerInteraction.Collide))
                {
                    HitPosition = hit.point;
                    HitCollider = hit.collider;
                    linePoints[i] = HitPosition; 
                    validLinePointsCount = i + 1;
                    
                    foundHit = true;
                    break;
                }
            }

            if (!foundHit)
            {
                visualTeleportDestination = linePoints[validLinePointsCount - 1];
            }
            
            LogIfEnabled(foundHit
                ? $"<color=#7CFC00>[AIM] Raycast HIT:</color> <color=yellow>{HitCollider.name}</color> at {HitPosition.ToString("F2")}"
                : "<color=orange>[AIM] Raycast MISSED.</color>");
            IsTeleportValid = foundHit && CheckValidHit(HitCollider, HitPosition, HitCollider.transform.forward);
            if(IsTeleportValid && HitCollider.TryGetComponentInParent(out TeleportationZone zone) && zone.OverrideHitPosition)
            {
                startPoint = linePoints[0];
                Vector3 endPoint = zone.HitPositionOverride;
                
                // Create a Bezier curve from start point to override position
                float distance = Vector3.Distance(startPoint, endPoint);
                Vector3 controlPoint = startPoint + (currentAimer.forward * distance * 0.5f);
                
                // Redistribute points along the Bezier curve
                for (int i = 0; i < validLinePointsCount; i++)
                {
                    float t = i / (float)(validLinePointsCount - 1);
                    linePoints[i] = Vector3.Lerp(
                        Vector3.Lerp(startPoint, controlPoint, t),
                        Vector3.Lerp(controlPoint, endPoint, t),
                        t
                    );
                }
            }
            OnValidTeleportChanged(IsTeleportValid);
        }
        
        private bool CheckValidHit(Collider hitCollider, Vector3 hitPoint, Vector3 surfaceNormal)
        {
            LogIfEnabled($"--- Checking Validity for hit on {hitCollider.name} ---");
            visualTeleportDestination = hitPoint;
            
            if (((1 << hitCollider.gameObject.layer) & noTeleportationMask) != 0)
            {
                LogIfEnabled($"<color=red>[VALIDITY] FAIL: Hit collider '{hitCollider.name}' is on the NonTeleportable layer.</color>");
                return false;
            }
            
            if (sceneHasZones)
            {
                if (hitCollider.TryGetComponentInParent(out TeleportationZone zone))
                {
                    visualTeleportDestination = zone.OverrideHitPosition ? zone.HitPositionOverride : hitPoint;
                
                    if (!zone.IsMarkerBaseInsideZoneXZ(teleportVisuals.MarkerTransform.position, teleportVisuals.MarkerRadiusWorld * RADIUS_MODIFIER))
                    {
                        LogIfEnabled("<color=red>[VALIDITY] FAIL: Marker would be outside the TeleportationZone.</color>");
                        return false;
                    }
                
                    LogIfEnabled($"<color=#7CFC00>[VALIDITY] PASS: Hit valid TeleportationZone '{zone.name}'.</color>");
                    return true;
                }
            }
            
            if (Vector3.Angle(Vector3.up, surfaceNormal) > maxSurfaceAngle)
            {
                LogIfEnabled($"<color=red>[VALIDITY] FAIL: Surface angle is {Vector3.Angle(Vector3.up, surfaceNormal):F1}, which is too steep (Max: {maxSurfaceAngle}).</color>");
                return false;
            }
            
            if (playerBody.bodyCollider != null)
            {
                CapsuleCollider playerCapsule = playerBody.bodyCollider;
                Vector3 capsuleBottom = hitPoint + Vector3.up * playerCapsule.radius + Vector3.up * 0.15f;
                Vector3 capsuleTop = hitPoint + Vector3.up * (playerCapsule.height - playerCapsule.radius);
                
                Collider[] overlaps = Physics.OverlapCapsule(
                    capsuleBottom,
                    capsuleTop,
                    playerCapsule.radius,
                    playerBody.handPlayerMask,
                    QueryTriggerInteraction.Ignore
                );
                
                foreach(Collider col in overlaps) 
                {
                    if(col.gameObject == playerBody.gameObject)
                        continue;

                    LogIfEnabled("<color=red>[VALIDITY] FAIL: Player capsule would collide with geometry at the destination.</color>");
                    return false;
                }
            }
            
            LogIfEnabled("<color=#7CFC00>[VALIDITY] PASS: All checks passed.</color>");
            if(lastHitZone != null)
                OnValidTeleportChanged(true);
            return true;
        }

        private void OnValidTeleportChanged(bool isValid)
        {
            teleportVisuals.SetValid(isValid);
            
            TeleportationZone previousZone = lastHitZone;
            lastHitZone = null;

            if (isValid && HitCollider != null && HitCollider.TryGetComponentInParent(out TeleportationZone currentZone))
            {
                lastHitZone = currentZone;
            }

            if (previousZone != lastHitZone)
            {
                if(previousZone != null)
                {
                    OnTeleportationZoneHitChange?.Invoke(this, previousZone, false);
                }
                if(lastHitZone != null)
                {
                    OnTeleportationZoneHitChange?.Invoke(this, lastHitZone, true);
                }
            }
        }

        private void UpdateVisuals()
        {
            LogIfEnabled($"[Teleporter] Trying to move marker to: {visualTeleportDestination.ToString("F3")}");
            teleportVisuals.UpdateLineRenderer(linePoints, validLinePointsCount - 1, totalDistancePoints);
            teleportVisuals.UpdateMarkerPositionRotation(visualTeleportDestination, currentAimer.position);
        }

        private void Teleport()
        {
            if (isTeleportingAsync) return;
            
            OnBeforeTeleport();
            TeleportPlayerAsync().Forget();
        }

        private void CancelAiming()
        {
            if (!IsAiming) return;
            
            if (lastHitZone != null && !IsTeleportValid)
            {
                OnTeleportationZoneHitChange?.Invoke(this, lastHitZone, false);
                lastHitZone = null;
            }
            
            IsAiming = false;
            IsTeleportValid = false;
            aimingHand = null;
            
            currentAimer = null;
            teleportVisuals.RevealHideTeleportLine(false);
        }
        
        private async UniTask TeleportPlayerAsync()
        {
            isTeleportingAsync = true;

            if (lastHitZone is TeleportationSnapZone { TeleportationType: not TeleportationSnapZone.TeleportType.Teleport } snapZone)
            {
                switch (snapZone.TeleportationType)
                {
                    case TeleportationSnapZone.TeleportType.LoadNextScenario:
                        ScenarioManager.Instance.LoadNextScenario();
                        break;
                    case TeleportationSnapZone.TeleportType.LoadScenarioById:
                        ScenarioManager.Instance.LoadScenario(snapZone.ScenarioToLoad);
                        break;
                }
                return; 
            }

            Vector3 finalPosition = lastHitZone != null && lastHitZone.OverrideDestinationPosition ? lastHitZone.DestinationOverride : visualTeleportDestination;
            Quaternion finalRotation = GetFinalRotation();

            var request = new PlayerMovementRequest
            {
                TargetPosition = finalPosition,
                TargetRotation = finalRotation,
                UseFade = PlayerGlobalSettings.UseFadeInOutForTeleportation,
                FadeDurationOverride = PlayerGlobalSettings.TeleportationFadeInTime 
            };
                
            await PlayerController.Instance.MovePlayerToAsync(request);

            isTeleportingAsync = false;
            OnAfterTeleport();
        }
         
        private Quaternion GetFinalRotation()
        {
            if (lastHitZone != null && lastHitZone.OverridePlayerRotation)
            {
                return Quaternion.Euler(0, lastHitZone.PlayerRotationYOverride, 0);
            }
            
            Vector3 lookDirection = visualTeleportDestination - playerBody.headCamera.transform.position;
            lookDirection.y = 0;
            return lookDirection.sqrMagnitude > 0.001f ? Quaternion.LookRotation(lookDirection.normalized) : playerBody.transform.rotation;
        }
        
        private void OnBeforeTeleport()
        {
            Audio.PlayOneShot(AudioGlobalSettings.PlayerTeleportFinishedSound);
            OnTeleportationStarted?.Invoke(this);
            if (lastHitZone != null)
            {
                OnStartTeleportToTeleportationZone?.Invoke(this, lastHitZone);
            }
        }

        private void OnAfterTeleport()
        {
            OnTeleportationFinished?.Invoke(this);
            if (lastHitZone != null)
            {
                OnTeleportToTeleportationZone?.Invoke(this, lastHitZone);
            }
            
            LdxTrackingManager.Instance.BroadcastTrackingEvent(PlayerGlobalSettings.EventOnTeleported);
        }
        
        private void HandleBlockerChanged(IBlocker blocker, bool state)
        {
            if (blockers.Any(x => (x as IBlocker).IsBlocked))
            {
                if(IsAiming)
                    StopAiming(aimingHand, true);
                isBlocked = true;
            }
            else
            {
                isBlocked = false;
            }
        }
        
        /// <summary>
        /// A helper method to log messages only when debugging is enabled.
        /// This avoids cluttering the main logic with 'if' checks.
        /// </summary>
        /// <param name="message">The message object to log.</param>
        private void LogIfEnabled(object message)
        {
            if (!enableDebugLogs)
            {
                return;
            }
            
            Debug.Log(message);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/PlayerTeleporter.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/TeleportationModeBlocker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5bd9057675550634e9dbd309a2735e3f
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Threading;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;
using Utilities.Blockers;

namespace Ldx.Framework.Systems.Teleportation
{
    public class TeleportationModeBlocker : MonoBehaviour, IBlocker
    {
        public event Action<IBlocker, bool> OnBlockChanged;

        [SerializeField, Tooltip("Delay after a teleport before unblocked (in seconds).")]
        private float delayAfterTeleportation = 1f;

        public bool IsBlocked { get; private set; }
        private CancellationTokenSource cts;

        private void Start()
        {
            PlayerTeleporter.OnTeleportActivateDeactive += HandleTeleportActivateDeactivate;
            PlayerTeleporter.OnTeleportationFinished += HandleTeleportFinished;
        }

        private void OnDestroy()
        {
            cts.SafeCancelAndDispose();
            PlayerTeleporter.OnTeleportActivateDeactive -= HandleTeleportActivateDeactivate;
            PlayerTeleporter.OnTeleportationFinished -= HandleTeleportFinished;
        }

        private void HandleTeleportActivateDeactivate(PlayerTeleporter teleporter, bool isActive)
        {
            cts.SafeCancelAndDispose();

            if (isActive)
            {
                IsBlocked = true;
                OnBlockChanged?.Invoke(this, IsBlocked);
            }
            else
            {
                cts = new CancellationTokenSource();
                EnableGestureTrackingAfterDelayAsync(cts.Token).Forget();
            }
        }

        private void HandleTeleportFinished(PlayerTeleporter teleporter)
        {
            cts.SafeCancelAndDispose();
            cts = new CancellationTokenSource();
            EnableGestureTrackingAfterDelayAsync(cts.Token).Forget();
        }

        /// <summary>
        /// Waits for the configured cooldown before re-enabling gesture tracking after teleport or other disruptions.
        /// </summary>
        /// <param name="token">Cancellation token to abort the wait if a new teleport starts or the object disables.</param>
        private async UniTask EnableGestureTrackingAfterDelayAsync(CancellationToken token)
        {
            await UniTask.Delay(delayAfterTeleportation.ToMilliseconds(), cancellationToken: token);
            if (token.IsCancellationRequested)
            {
                return;
            }

            IsBlocked = false;
            OnBlockChanged?.Invoke(this, IsBlocked);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/TeleportationModeBlocker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/TeleportationSnapZone.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3a2b10eb6243e104eb03e1fd200f1429
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.UI;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Teleportation
{
    public class TeleportationSnapZone : TeleportationZone
    {
        [Header("Snap zone")]
        [Tooltip("The location that the player's tp indicator will go to and where they will teleport to if no override is set.")]
        [SerializeField] private Transform snapLocation = null;
        [Tooltip("If not null, will send the player to the override location instead of the Snap Location. Set this to an object with a TeleportationSnapZone component for linking between two doorways.")]
        [SerializeField] private Transform destinationOverrideLocation = null;
        [SerializeField] private bool overrideRotation;
        [SerializeField] private UITweenedStates icon;
        [SerializeField] private bool loadScenarioOnTeleport;

        public enum TeleportType
        {
            Teleport,
            LoadNextScenario,
            LoadScenarioById
        }
        
        [Space]
        [SerializeField] private TeleportType teleportType = TeleportType.Teleport;
        public TeleportType TeleportationType => teleportType;
        
        [SerializeField][IDSelection(LdxIdSettings.IdType.Scenario)]
        private string scenarioToLoad;
        public string ScenarioToLoad => scenarioToLoad;

        public override bool OverrideHitPosition => true;
        public override Vector3 HitPositionOverride => snapLocation.position;
        
        public override bool OverrideDestinationPosition => destinationOverrideLocation != null;
        public override Vector3 DestinationOverride => destinationOverrideLocation.position;

        public override bool OverridePlayerRotation => overrideRotation;
        public override float PlayerRotationYOverride =>
            destinationOverrideLocation ? destinationOverrideLocation.transform.eulerAngles.y : transform.eulerAngles.y;

        public override bool OverrideCurrentTeleportationZone => destinationOverrideTeleportationZone != null;
        public override TeleportationZone TeleportationZoneOverride => destinationOverrideTeleportationZone;

        private TeleportationSnapZone destinationOverrideTeleportationZone;

        protected override void Start()
        {
            base.Start();
            if (destinationOverrideLocation != null)
            {
                destinationOverrideTeleportationZone = destinationOverrideLocation.GetComponentInParent<TeleportationSnapZone>();
            }
        }

        public override void ToggleActiveZone(bool isActive)
        {
            base.ToggleActiveZone(isActive);
            if (icon != null)
            {
                icon.SetState(isActive);
            }
        }

        public override void ShowHideZone(bool show)
        {
            base.ShowHideZone(show);
        }

        public override void SetAsCurrent(bool isCurrent)
        {
            base.SetAsCurrent(isCurrent);
            gameObject.SetActive(!isCurrent);
            if (icon != null)
            {
                icon.gameObject.SetActive(!isCurrent);
            }
        }

        public override void DoStartTeleportToZoneActions()
        {
            if(icon != null)
                icon.gameObject.SetActive(false);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/TeleportationSnapZone.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/TeleportationZone.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 85b45c8aabf546bf814b1e9337bfa415
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Dreamteck.Splines;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using UnityEngine.ProBuilder;

namespace Ldx.Framework.Systems.Teleportation
{
    [RequireComponent(typeof(SplineComputer))]
    public class TeleportationZone : MonoBehaviour
    {
        private static readonly int Color = Shader.PropertyToID("_Color");
        
        [SerializeField] [IDSelection(LdxIdSettings.IdType.Transform)]
        private string zoneID;
        public string ZoneID => zoneID;
        
        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string eventOnTeleportedToThisZone;
        public string EventOnTeleportedToThisZone => eventOnTeleportedToThisZone;

        [Space]
        [SerializeField] private MeshRenderer meshRenderer;
        [SerializeField] private MeshRenderer insideMeshRenderer;
        [SerializeField] private Color defaultColor;
        [SerializeField] private Color activeColor;

        [SerializeField] private SplineComputer splineComputer;
        
        [SerializeField] private bool usePolyShape;
        [SerializeField] private PolyShape polyShape;
        [SerializeField] private float polyShapeResolution = 5f;

        [SerializeField] private Collider colliderForBounds;
        [SerializeField] [SoundReference] private string onActivateSound;

        public virtual bool OverrideHitPosition => false;
        public virtual Vector3 HitPositionOverride => Vector3.zero;
        
        public virtual bool OverrideDestinationPosition => false;
        public virtual Vector3 DestinationOverride => Vector3.zero; 
        
        public virtual bool OverridePlayerRotation => false;
        public virtual float PlayerRotationYOverride => 0f;

        public virtual bool OverrideCurrentTeleportationZone => false;
        public virtual TeleportationZone TeleportationZoneOverride => null;
        
        public bool IsEnabled { get; set; } = true;
        
        private List<Vector3> splinePositions = new List<Vector3>();
        private Material material;
        private Bounds zoneBounds;

        private void OnValidate()
        {
            if (splineComputer == null)
            {
                splineComputer = GetComponent<SplineComputer>();
            }

            if (colliderForBounds == null)
            {
                colliderForBounds = GetComponentInChildren<Collider>();
            }

            if (usePolyShape)
            {
                if (polyShape == null)
                {
                    polyShape = GetComponentInChildren<PolyShape>();
                    if (polyShape == null)
                    {
                        GameObject go = new GameObject("PolyShape");
                        go.transform.SetParent(transform);
                        polyShape = go.AddComponent<PolyShape>(); 
                        MeshRenderer meshRenderer = go.AddComponent<MeshRenderer>();
                        meshRenderer.material = null;
                        go.AddComponent<ProBuilderMesh>();
                        go.AddComponent<MeshCollider>();
                        go.layer = LayerMask.NameToLayer("TeleportPoint");
                    }
                }
            }
            else
            {
                if (polyShape)
                {
#if UNITY_EDITOR
                    UnityEditor.EditorApplication.delayCall -= handleDelayCall;
                    UnityEditor.EditorApplication.delayCall += handleDelayCall;

                    void handleDelayCall()
                    {
                        DestroyImmediate(polyShape.gameObject);
                        polyShape = null;
                    }
#endif
                }
            }

            if (polyShape)
            {
                splinePositions.Clear();
                int resolution = Mathf.FloorToInt(splineComputer.CalculateLength() * polyShapeResolution);
                for (int i = 0; i < resolution; i++)
                {
                    splinePositions.Add(splineComputer.Evaluate(i / (float)resolution).position - transform.localPosition);
                }
                polyShape.SetControlPoints(splinePositions);
                polyShape.transform.localPosition = Vector3.zero;
            }
        }

        protected virtual void Awake()
        {
            material = Instantiate(meshRenderer.sharedMaterial);
            meshRenderer.material = material;
            zoneBounds = colliderForBounds.bounds;
            
            ShowHideZone(false);
            ToggleActiveZone(false);
        }
        
        protected virtual void Start()
        {
            if (insideMeshRenderer)
            {
                insideMeshRenderer.transform.localPosition = Vector3.zero;
            }
        }

        protected virtual void OnDestroy()
        {
            if (material)
            {
                DestroyImmediate(material);
            }
        }
        
        public bool IsMarkerBaseInsideZoneXZ(Vector3 markerPos, float modifiedRadius)
        {
            if (colliderForBounds == null)
            {
                return false;
            }

            float minX = markerPos.x - modifiedRadius;
            float maxX = markerPos.x + modifiedRadius;
            float minZ = markerPos.z - modifiedRadius;
            float maxZ = markerPos.z + modifiedRadius;
            
            return minX >= zoneBounds.min.x &&
                   maxX <= zoneBounds.max.x &&
                   minZ >= zoneBounds.min.z &&
                   maxZ <= zoneBounds.max.z;
        }

        public void EnableDisableZone(bool enable)
        {
            gameObject.SetActive(enable);
        }
        
        public virtual void ShowHideZone(bool show)
        {
            if (meshRenderer != null)
                meshRenderer.enabled = show;
            if(insideMeshRenderer != null)
                insideMeshRenderer.enabled = show;
        }
        
        public virtual void ToggleActiveZone(bool isActive)
        {
            if (isActive)
            {
                Audio.PlayOneShot(onActivateSound, transform);
            }
            material.SetColor(Color, isActive? activeColor : defaultColor);
        }

        public virtual void SetAsCurrent(bool isCurrent) { }

        public virtual void DoStartTeleportToZoneActions() { }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/TeleportationZone.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/TeleportationZonesManager.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2e4aa56aaddd42a998f9b9f491d2665b
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using UnityEngine;

namespace Ldx.Framework.Systems.Teleportation
{
    /// <summary>
    /// Manages a collection of <see cref="TeleportationZone"/> instances within the scene.
    /// It handles their visibility, activation, and interaction with the objective system
    /// by responding to objective events related to teleportation zones.
    /// This manager also listens to teleportation system events to update zone states.
    /// </summary>
    public class TeleportationZonesManager : EventDataTracker
    {
        [SerializeField] private List<TeleportationZone> zones = new();

        public bool HasZones => zones.Count > 0;
        
        private readonly Dictionary<string, TeleportationZone> zonesByName = new();
        private readonly HashSet<string> forcePreviewZone = new();
        private TeleportationZone currentTeleportationZone;
        private bool teleportActivated;

        private void OnValidate()
        {
            zones = GetComponentsInChildren<TeleportationZone>().ToList();
        }
        
        private void Awake()
        {
            PlayerTeleporter.OnTeleportActivateDeactive += HandleTeleportActivateDeactivate;
            PlayerTeleporter.OnTeleportationZoneHitChange += HandleTeleportationZoneHitChange;
            PlayerTeleporter.OnTeleportationFinished += HandlePlayerTeleport;
            PlayerTeleporter.OnStartTeleportToTeleportationZone += HandleStartTeleportToZone;
            PlayerTeleporter.OnTeleportToTeleportationZone += HandleTeleportToZone;
        }

        protected override void Start()
        {
            base.Start();
            foreach (TeleportationZone zone in zones)
            {
                if (string.IsNullOrEmpty(zone.ZoneID))
                {
                    continue;
                }

                if (!zonesByName.TryAdd(zone.ZoneID, zone))
                {
                    Debug.LogWarning($"Duplicate Teleportation Zone ID: {zone.ZoneID}");
                }
            }
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
            PlayerTeleporter.OnTeleportActivateDeactive -= HandleTeleportActivateDeactivate;
            PlayerTeleporter.OnTeleportationZoneHitChange -= HandleTeleportationZoneHitChange;
            PlayerTeleporter.OnTeleportationFinished -= HandlePlayerTeleport;
            PlayerTeleporter.OnStartTeleportToTeleportationZone -= HandleStartTeleportToZone;
            PlayerTeleporter.OnTeleportToTeleportationZone -= HandleTeleportToZone;
        }

        /// <summary>
        /// Handles objective events relevant to teleportation zones.
        /// This method processes events like enabling/disabling zone previews or entire zones.
        /// </summary>
        /// <param name="objective">The <see cref="IObjective"/> that triggered the event.</param>
        /// <param name="eventData">The <see cref="ObjectiveEventData"/> associated with the event.</param>
        protected override void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            switch (eventData)
            {
                case EnableTeleportationZonePreviewEventData data:
                    ToggleZonePreviewForced(data.ZoneID, true);
                    break;
                case DisableTeleportationZonePreviewEventData data:
                    ToggleZonePreviewForced(data.ZoneID, false);
                    break;
                case EnableDisableTeleportationZoneEventData data:
                    EnableDisableTeleportationZone(data.ZoneID, data.SetEnabled);
                    break;
                default:
                    break;
            }
        }

        /// <summary>
        /// Toggles the forced preview state for a teleportation zone.
        /// If <paramref name="show"/> is true, the zone's preview is displayed and added to the <see cref="forcePreviewZone"/> set.
        /// If false, it's removed from the set (its visibility will then be controlled by normal teleport activation).
        /// </summary>
        /// <param name="zoneID">The ID of the zone to affect.</param>
        /// <param name="show">True to force show the preview, false to remove the force.</param>
        private void ToggleZonePreviewForced(string zoneID, bool show)
        {
            if (!zonesByName.TryGetValue(zoneID, out TeleportationZone zone))
            {
                return;
            }
            
            if (show)
            {
                forcePreviewZone.Add(zoneID);
                zone.ShowHideZone(true);
            }
            else
            {
                forcePreviewZone.Remove(zoneID);
                if (!teleportActivated)
                {
                    zone.ShowHideZone(false);
                }
            }
        }

        /// <summary>
        /// Enables or disables a specific teleportation zone, affecting its interactability.
        /// </summary>
        /// <param name="zoneID">The ID of the zone to enable or disable.</param>
        /// <param name="enable">True to enable the zone, false to disable it.</param>
        private void EnableDisableTeleportationZone(string zoneID, bool enable)
        {
            if (!zonesByName.TryGetValue(zoneID, out TeleportationZone zone))
            {
                Debug.LogWarning($"Teleportation zone with ID '{zoneID}' not found for EnableDisableTeleportationZone.", gameObject);
                return;
            }
            
            zone.EnableDisableZone(enable);
        }

        /// <summary>
        /// Handles the activation or deactivation of the teleportation system.
        /// Shows or hides teleportation zones accordingly, respecting any forced previews.
        /// </summary>
        /// <param name="playerTeleporter">The <see cref="PlayerTeleporter"/> instance that triggered the event.</param>
        /// <param name="active">True if the teleport system was activated, false otherwise.</param>
        private void HandleTeleportActivateDeactivate(PlayerTeleporter playerTeleporter, bool active)
        {
            foreach (TeleportationZone zone in zones)
            {
                if (!active)
                {
                    // Keep enabled if it's forced to preview
                    if (!string.IsNullOrEmpty(zone.ZoneID) && forcePreviewZone.Contains(zone.ZoneID))
                    {
                        continue;
                    }
                }
                
                zone.ShowHideZone(active);
            }
        }

        /// <summary>
        /// Handles changes in which teleportation zone the teleport targeting system is currently hitting.
        /// Toggles the "active" visual state of the zone.
        /// </summary>
        /// <param name="playerTeleporter">The <see cref="PlayerTeleporter"/> instance that triggered the event.</param>
        /// <param name="zone">The <see cref="TeleportationZone"/> that is now being hit or no longer hit.</param>
        /// <param name="active">True if the zone is currently being hit by the teleporter, false otherwise.</param>
        private void HandleTeleportationZoneHitChange(PlayerTeleporter playerTeleporter, TeleportationZone zone, bool active)
        {
            if (zone == null)
            {
                return;
            }
            
            zone.ToggleActiveZone(active);
        }

        private void HandlePlayerTeleport(PlayerTeleporter playerTeleporter)
        {
            if (currentTeleportationZone != null)
            {
                currentTeleportationZone.SetAsCurrent(false);
                currentTeleportationZone.ToggleActiveZone(false);
            }
        }

        private void HandleStartTeleportToZone(PlayerTeleporter playerTeleporter, TeleportationZone zone)
        {
            zone.DoStartTeleportToZoneActions();
        }

        /// <summary>
        /// Handles the event when the player teleports to a specific zone.
        /// Updates the current teleportation zone, broadcasts a tracking event,
        /// and manages the visual states of the involved zones.
        /// </summary>
        /// <param name="playerTeleporter">The <see cref="PlayerTeleporter"/> instance that triggered the event.</param>
        /// <param name="zone">The <see cref="TeleportationZone"/> the player teleported to.</param>
        private void HandleTeleportToZone(PlayerTeleporter playerTeleporter, TeleportationZone zone)
        {
            if (!string.IsNullOrEmpty(zone.ZoneID))
            {
                ToggleZonePreviewForced(zone.ZoneID, false);
            }

            currentTeleportationZone = zone.OverrideCurrentTeleportationZone ? zone.TeleportationZoneOverride : zone;
            currentTeleportationZone.ToggleActiveZone(true);
            currentTeleportationZone.SetAsCurrent(true);
            LdxTrackingManager.Instance.BroadcastTrackingEvent(zone.EventOnTeleportedToThisZone);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/TeleportationZonesManager.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/TeleporterVisuals.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 87c7805a04e34d21b81ad61d5ff7025c
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using DG.Tweening;
using UnityEngine;

namespace Ldx.Framework.Systems.Teleportation
{
    public class TeleporterVisuals : MonoBehaviour
    {
        private readonly static int Reveal = Shader.PropertyToID("_Reveal");
        private readonly static int TotalLineLengthID = Shader.PropertyToID("_TotalLineLength");
        private readonly static int ColorID = Shader.PropertyToID("_Color");

        [Header("Component References")]
        [SerializeField] private TeleportMarker teleportMarker;
        [SerializeField] private LineRenderer lineRenderer;
        
        [Space]
        [SerializeField][Min(0)] private float revealDuration = 0.5f;
        [SerializeField][Min(0)] private float hideDuration = 0.25f;
        [SerializeField] private Ease ease = Ease.InOutQuad;
        
        [Space]
        [SerializeField] private Color validEndColor = Color.blue;
        [SerializeField] private Color invalidEndColor = Color.red;        
        [SerializeField] private float colorChangeDuration = 0.1f;
        [SerializeField] private Ease colorChangeEase = Ease.InExpo;

        public Transform MarkerTransform => teleportMarker.transform;
        public float MarkerRadiusWorld => teleportMarker.MarkerRadiusWorld;

        private Material lineRendererMat;
        private Tween lineFadeTween;
        private Tween colorTween;

       private void Start()
        {
            if (lineRenderer == null)
            {
                Debug.LogError("TeleporterVisuals requires a LineRenderer", this);
                enabled = false;
                return;
            }
            
            if (teleportMarker == null)
            {
                Debug.LogError("TeleporterVisuals requires a TeleportMarker", this);
                enabled = false;
                return;
            }

            lineRendererMat = lineRenderer.material;
            lineRendererMat.SetFloat(Reveal, 0);
        }

        private void OnDestroy()
        {
            lineFadeTween?.Kill();
            colorTween?.Kill();
        }
        
        /// <summary>
        /// Passes position and rotation data to the marker.
        /// </summary>
        public void UpdateMarkerPositionRotation(Vector3 position, Vector3 origin, bool smoothPosition = true)
        {
            teleportMarker.UpdatePositionRotation(position, origin, smoothPosition);
        }

        /// <summary>
        /// Updates the line renderer's points and length.
        /// </summary>
        public void UpdateLineRenderer(Vector3[] hitPoint, int lastValidIndex, float[] totalDistances)
        {
            lineRenderer.positionCount = lastValidIndex + 1;
            lineRenderer.SetPositions(hitPoint);
            lineRendererMat.SetFloat(TotalLineLengthID, totalDistances[lastValidIndex]);
        }

        /// <summary>
        /// Sets the visual state for both the line and the marker.
        /// </summary>
        public void SetValid(bool isTeleportValid)
        {
            teleportMarker.SetValid(isTeleportValid);
            TransitionLineColor(isTeleportValid ? validEndColor : invalidEndColor);
        }
        
        /// <summary>
        /// Animates the teleport line appearing or disappearing. Also toggles the marker.
        /// </summary>
        public void RevealHideTeleportLine(bool reveal, Action callback = null)
        {
            if (!reveal)
            {
                teleportMarker.Toggle(false);
            }

            if (reveal)
            {
                lineRenderer.enabled = true;
            }
            
            lineFadeTween?.Kill();
            lineFadeTween = lineRendererMat.DOFloat(reveal ? 1 : 0, Reveal, reveal ? revealDuration : hideDuration)
                .SetEase(ease)
                .OnComplete(() =>
                {
                    if (!reveal)
                    {
                        lineRenderer.enabled = false;
                    }
                    
                    lineFadeTween = null;
                    callback?.Invoke();
                    
                    if (reveal)
                        teleportMarker.Toggle(true);
                });
        }

        /// <summary>
        /// Smoothly transitions the line renderer's color.
        /// </summary>
        private void TransitionLineColor(Color color)
        {
            colorTween?.Kill();
            colorTween = lineRendererMat.DOColor(color, ColorID, colorChangeDuration).SetEase(colorChangeEase);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/TeleporterVisuals.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/TeleportMarker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 12efa306b4704f128493082207d49b55
# ASMDEF: ldx.framework.runtime.dll
# ---
using DG.Tweening;
using UnityEngine;

namespace Ldx.Framework.Systems.Teleportation
{
    public class TeleportMarker : MonoBehaviour
    {
        [Header("Component References")]
        [SerializeField] private Renderer arrowRenderer;
        [SerializeField] private Renderer ringRenderer;
        [SerializeField] private GameObject gradient;
        [SerializeField] private GameObject xShape;

        [Header("Materials")]
        [SerializeField] private Material validMarkerBodyMaterial;
        [SerializeField] private Material invalidMarkerBodyMaterial;

        [Header("Animations")]
        [SerializeField][Min(0)] private float scaleTweenStartScale = 0.25f;
        [SerializeField][Min(0)] private float scaleTweenShowDuration = 0.15f;
        [SerializeField] private Ease scaleTweenShowEase = Ease.OutBack;
        [SerializeField][Min(0)] private float scaleTweenHideDuration = 0.07f;
        [SerializeField] private Ease scaleTweenHideEase = Ease.InBack;
        [SerializeField][Min(0)] private float positionTweenDuration = 0.25f;
        [SerializeField] private Ease positionTweenEase = Ease.InOutQuad;

        public float MarkerRadiusWorld => ringRenderer != null ? ringRenderer.bounds.extents.x : 0.25f;

        private Tween scaleTween;
        private Tween positionTween;
        private bool hasBeenPositionedOnce;

        private void Awake()
        {
            transform.localScale = Vector3.zero;
            gameObject.SetActive(false);
        }

        private void OnDestroy()
        {
            scaleTween?.Kill();
            positionTween?.Kill();
        }

        /// <summary>
        /// Shows or hides the marker with a scaling animation.
        /// </summary>
        /// <param name="show">True to show, false to hide.</param>
        public void Toggle(bool show)
        {
            scaleTween?.Kill(true);

            if (show)
            {
                gameObject.SetActive(true);
                transform.localScale = Vector3.one * scaleTweenStartScale;
                scaleTween = transform.DOScale(Vector3.one, scaleTweenShowDuration).SetEase(scaleTweenShowEase);
            }
            else
            {
                hasBeenPositionedOnce = false; // Reset for the next time it's shown
                scaleTween = transform.DOScale(Vector3.one * scaleTweenStartScale, scaleTweenHideDuration)
                    .SetEase(scaleTweenHideEase)
                    .OnComplete(() => gameObject.SetActive(false));
            }
        }
        
        /// <summary>
        /// Updates the marker's position and rotation.
        /// </summary>
        /// <param name="position">The target world position.</param>
        /// <param name="origin">The point the marker should look towards (e.g., the player's head).</param>
        /// <param name="smoothPosition">If true, tweens the position smoothly.</param>
        public void UpdatePositionRotation(Vector3 position, Vector3 origin, bool smoothPosition = true)
        {
            positionTween?.Kill(false);

            if (hasBeenPositionedOnce && smoothPosition)
            {
                positionTween = transform.DOMove(position, positionTweenDuration).SetEase(positionTweenEase);
            }
            else
            {
                transform.position = position;
                hasBeenPositionedOnce = true;
            }
            
            // Make the marker look towards the origin on the Y plane.
            Vector3 lookAtPosition = origin;
            lookAtPosition.y = transform.position.y;
            transform.LookAt(lookAtPosition);
        }

        /// <summary>
        /// Sets the visual state of the marker to be valid or invalid.
        /// </summary>
        /// <param name="isValid">True for the valid state, false for the invalid state.</param>
        public void SetValid(bool isValid)
        {
            xShape.SetActive(!isValid);
            gradient.SetActive(isValid);

            if (ringRenderer)
            {
                ringRenderer.material = isValid ? validMarkerBodyMaterial : invalidMarkerBodyMaterial;
            }
            if (arrowRenderer)
            {
                arrowRenderer.material = isValid ? validMarkerBodyMaterial : invalidMarkerBodyMaterial;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/TeleportMarker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/XRTeleporterInput.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c25a867bb1594a0192eabe97a3a60900
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Autohand.Demo;
using Ldx.Framework.Systems.Player;
using UnityEngine;
using UnityEngine.XR;
using Hand = Autohand.Hand;

namespace Ldx.Framework.Systems.Teleportation
{
    public class XRTeleporterInput : MonoBehaviour
    {
        [SerializeField] private Hand hand;
        [SerializeField] private XRNode role;
        
        private bool teleporting;
        private InputDevice device;
        private readonly List<InputDevice> devices = new();
        private PlayerGlobalSettings.JoystickDirection activationDirection;

        private void Start()
        {
            activationDirection = PlayerGlobalSettings.TeleportationJoystickDirection;
        }

        private void FixedUpdate()
        {
            InputDevices.GetDevicesAtXRNode(role, devices);
            if(devices.Count > 0)
            {
                device = devices[0];
            }

            if(device is { isValid: true })
            {
                if(device.TryGetFeatureValue(XRHandControllerLink.GetCommon2DAxis(Common2DAxis.primaryAxis), out Vector2 joystickValue)) 
                {
                    float verticalAxis = joystickValue.y;
                    bool isJoystickActivated = false;
                    
                    switch (activationDirection)
                    {
                        case PlayerGlobalSettings.JoystickDirection.Up:
                            isJoystickActivated = verticalAxis > PlayerGlobalSettings.TeleportationJoystickActivationThreshold;
                            break;
                        case PlayerGlobalSettings.JoystickDirection.Down:
                            isJoystickActivated = verticalAxis < -PlayerGlobalSettings.TeleportationJoystickActivationThreshold;
                            break;
                        case PlayerGlobalSettings.JoystickDirection.Vertical:
                            isJoystickActivated = Mathf.Abs(verticalAxis) > PlayerGlobalSettings.TeleportationJoystickActivationThreshold;
                            break;
                    }
                    
                    if (teleporting && !isJoystickActivated)
                    {
                        PlayerController.Instance.Teleporter.StopAiming(hand);
                        teleporting = false;
                    }
                    else if (!teleporting && isJoystickActivated)
                    {
                        PlayerController.Instance.Teleporter.StartAiming(hand);
                        teleporting = true;
                    }
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Teleportation/XRTeleporterInput.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Tethers/InteractableTetherOrb.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d76011c6dcb447faa8116982deb25ce4
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Autohand;
using DG.Tweening;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.Tethers
{
    /// <summary>
    /// Represents an interactable tether orb that can be grabbed and reacts to player interactions.
    /// The orb will rotate to face the player camera and change its scale and color upon interaction.
    /// </summary>
    [RequireComponent(typeof(SphereCollider))]
    public class InteractableTetherOrb : MonoBehaviour
    {
        [SerializeField]
        private TransformTether transformTether;
        [SerializeField]
        private Grabbable grabbable;
        [SerializeField]
        private float lookAtCameraSpeed = 5f;
        [SerializeField][Tooltip("This tag will be used for filtering `OnTriggerEnter` and `OnTriggerExit`, " +
                                 "if no tag is defined then no filtering will be performed")]
        private string triggerTag = "FingerTip";
        
        [Header("Scale")]
        [SerializeField]
        private float handEnteredScale = 1.2f;
        [SerializeField]
        private float scaleDuration = 0.5f;
        [SerializeField]
        private Ease scaleEase = Ease.Linear;

        [Space]
        [Header("Grabbed")]
        [SerializeField]
        private float grabbedDuration = 0.5f;
        [SerializeField]
        private Ease grabbedEase = Ease.Linear;
        
        [Space]
        [SerializeField]
        private SpriteRenderer icon;

        [Serializable]
        public class MaterialColorSet
        {
            public Color originalColor;
            public Color grabbedColor;
        }
        
        [SerializeField]
        private MaterialColorSet iconColorSet;
        
        [Space]
        [HelpBox("Make sure that the amount of `materialColorSets` is equal to `orbRenderer` materials")]
        [SerializeField]
        private MeshRenderer orbRenderer;
        [SerializeField]
        private List<MaterialColorSet> materialColorSets = new();
        
        private readonly Dictionary<Material, MaterialColorSet> materialColorSetMap = new();

        private Transform playerCamera;
        public Transform PlayerCamera => playerCamera ??= PlayerController.Instance.MainCamera.transform;
        
        private float originalScale;
        private Tween scaleTween;
        private Sequence grabSequence;

        private void OnValidate()
        {
            if (transformTether == null)
            {
                transformTether = GetComponentInParent<TransformTether>();
            }
        }

        private void Awake()
        {
            originalScale = transform.localScale.x;
            if (grabbable == null)
            {
                gameObject.SetActive(false);
                return;
            }
            grabbable.OnGrabEvent += HandleSphereGrabbed;
            grabbable.OnReleaseEvent += HandleSphereReleased;
            AssignMaterials();
        }

        private void OnEnable()
        {
            UpdateRotationImmediately();
            ChangeGrabbedVisuals(false, true);
        }

        private void OnDisable()
        {
            if (grabbable != null)
            {
                grabbable.ForceHandsRelease();
            }
        }
        
        private void OnDestroy()
        {
            foreach (Material material in materialColorSetMap.Keys)
            {
                Destroy(material);
            }
            
            materialColorSetMap.Clear();

            if (grabbable != null)
            {
                grabbable.OnGrabEvent -= HandleSphereGrabbed;
                grabbable.OnReleaseEvent -= HandleSphereReleased;
            }
            
            scaleTween?.Kill();
            grabSequence?.Kill();
        }
        
        /// <summary>
        /// Assigns new instances of materials to the orb renderer and sets up the material color mapping.
        /// </summary>
        private void AssignMaterials()
        {
            if (orbRenderer == null)
            {
                return;
            }

            List<Material> sharedMaterials = orbRenderer.sharedMaterials.ToList();
            for (int i = 0; i < sharedMaterials.Count; i++)
            {
                Material newMaterial = Instantiate(sharedMaterials[i]);
                sharedMaterials[i] = newMaterial;
                materialColorSetMap.Add(newMaterial, materialColorSets[i]);
            }
            
            orbRenderer.SetMaterials(sharedMaterials);
        }

        private void LateUpdate()
        {
            Quaternion desiredRotation = GetDesiredRotation();
            transform.rotation = Quaternion.Slerp(transform.rotation, desiredRotation,
                Time.smoothDeltaTime * lookAtCameraSpeed);
        }
        
        /// <summary>
        /// Immediately updates the orb's rotation to face the player's camera without smoothing.
        /// </summary>
        private void UpdateRotationImmediately()
        {
            transform.rotation = GetDesiredRotation();
        }

        /// <summary>
        /// Calculates the desired rotation for the orb to face the player's camera.
        /// </summary>
        /// <returns>The calculated rotation that faces the player's camera.</returns>
        private Quaternion GetDesiredRotation()
        {
            if (!PlayerCamera)
            {
                return Quaternion.identity;
            }
            
            Vector3 directionToCamera = transform.position - PlayerCamera.position;
            directionToCamera.y = 0;

            Quaternion desiredRotation = Quaternion.LookRotation(directionToCamera);
            return Quaternion.Euler(0, desiredRotation.eulerAngles.y, 0);
        }
        
        private void OnTriggerEnter(Collider other)
        {
            if (string.IsNullOrEmpty(triggerTag) || other.CompareTag(triggerTag))
            {
                ChangeScale(handEnteredScale);
            }
        }
        
        private void OnTriggerExit(Collider other)
        {
            if (string.IsNullOrEmpty(triggerTag) || other.CompareTag(triggerTag))
            {
                ChangeScale(originalScale);
            }
        }

        /// <summary>
        /// Changes the scale of the orb with an animation.
        /// </summary>
        /// <param name="scale">The target scale to animate to.</param>
        private void ChangeScale(float scale)
        {
            scaleTween?.Kill();
            scaleTween = transform.DOScale(scale, scaleDuration).SetEase(scaleEase);
        }
        
        /// <summary>
        /// Handles the event when the orb is grabbed. Changes the visual state to indicate it's grabbed.
        /// </summary>
        /// <param name="hand">The hand that grabbed the orb.</param>
        /// <param name="grabbableHand">The grabbable component.</param>
        private void HandleSphereGrabbed(Hand hand, Grabbable grabbableHand)
        {
            ChangeGrabbedVisuals(true);
        }

        /// <summary>
        /// Handles the event when the orb is released. Changes the visual state to indicate it's released.
        /// </summary>
        /// <param name="hand">The hand that released the orb.</param>
        /// <param name="grabbableHand">The grabbable component.</param>
        private void HandleSphereReleased(Hand hand, Grabbable grabbableHand)
        {
            ChangeGrabbedVisuals(false);
            if (transformTether != null)
            {
                transformTether.UpdateLocalOffsetFromWaist();
            }
        }
        
        /// <summary>
        /// Changes the visual appearance of the orb and its icon based on whether it is grabbed.
        /// </summary>
        /// <param name="isGrabbed">Whether the orb is currently grabbed.</param>
        /// <param name="instant">If true the duration of animation will be 0</param>
        private void ChangeGrabbedVisuals(bool isGrabbed, bool instant = false)
        {
            grabSequence?.Kill();
            grabSequence = DOTween.Sequence();

            float duration = instant ? 0 : grabbedDuration;
            
            if (icon != null)
            {
                grabSequence
                    .Join(icon.DOColor(isGrabbed ? iconColorSet.grabbedColor : iconColorSet.originalColor,
                        duration));
            }

            foreach ((Material material, MaterialColorSet materialColorSet) in materialColorSetMap)
            {
                grabSequence
                    .Join(material.DOColor(isGrabbed ? materialColorSet.grabbedColor : materialColorSet.originalColor,
                        duration));
            }

            grabSequence.SetEase(grabbedEase);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Tethers/InteractableTetherOrb.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Tethers/TetherController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6d825e17b5cdb90499c0093260f33d75
# ASMDEF: ldx.framework.runtime.dll
# ---
using BrewedInk.MarkdownSupport.Markdown;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;

namespace Ldx.Framework.Systems.Tethers
{
    /// <summary>
    /// This controls the tethers in the scene. Similar to anchors, but more modular, you can tether any object to another
    /// object, and choose whether you want it to be relative to the local object or worldspace. Access tethers via enums,
    /// and please feel free to add to the enum as required.
    /// </summary>
    public class TetherController : Singleton<TetherController>
    {
        private const float SUMMON_FLOOR_OFFSET = 1.2f;
        
        public enum TetherEnum
        {
            Tablet = 0,
            Response = 1,
            ActiveWindow = 2,
            Wrist = 3,
            MainMenu = 4
            // Add more enums as needed
        }

        [MarkdownSnippet(InlineMarkdown =
            "If required, please open the script and add additional options as required. Do not remove any enums")]
        [SerializeField]
        private SerializableDictionary<TetherEnum, TransformTether> tetherMappings = new();

        private void Start()
        {
            ScenarioManager.Instance.OnScenarioStarted += HandleScenarioStarted;
            
            foreach (TetherEnum tetherEnum in tetherMappings.Keys)
            {
                SetTether(tetherEnum, false);
            }
        }

        private void OnDestroy()
        {
            if (ScenarioManager.IsValid)
            {
                ScenarioManager.Instance.OnScenarioStarted -= HandleScenarioStarted;
            }
        }

        /// <summary>
        /// Enables the specified tether by the enum type.
        /// </summary>
        /// <param name="tetherType">The type of tether to enable.</param>
        /// <param name="state">Set tether game object active</param>
        public void SetTether(TetherEnum tetherType, bool state)
        {
            if (TryGetTether(tetherType, out TransformTether tether))
            {
                tether.SetTetherActive(state);
            }
        }

        /// <summary>
        /// Move the main tether's object to a chosen position.
        /// </summary>
        /// <param name="tetherType">The enum of the tether associated with the two objects.</param>
        /// <param name="target">Target transform ID where to move to</param>
        /// <param name="useFloorOffset">If true, will set fixed Y floor offset</param>
        /// <param name="useTween">Indicates whether to animate (tween) the movement or move instantly. Default is true.</param>
        public void MoveTether(TetherEnum tetherType, string target, bool useFloorOffset = true, bool useTween = true)
        {
            Transform moveTo = LdxReferenceIDTracker.Instance.GetTransform(target);
            if (moveTo)
            {
                MoveTether(tetherType, moveTo.position, useFloorOffset, useTween);
            }
        }
        
        /// <summary>
        /// Move the main tether's object to a chosen position.
        /// </summary>
        /// <param name="tetherType">The enum of the tether associated with the two objects.</param>
        /// <param name="targetTether">Target tether type where to move to</param>
        /// <param name="useFloorOffset">If true, will set fixed Y floor offset</param>
        /// <param name="useTween">Indicates whether to animate (tween) the movement or move instantly. Default is true.</param>
        public void MoveTether(TetherEnum tetherType, TetherEnum targetTether, bool useFloorOffset = true, bool useTween = true)
        {
            if (TryGetTether(targetTether, out TransformTether tether))
            {
                MoveTether(tetherType, tether.Position, useFloorOffset, useTween);
            }
        }
        
        /// <summary>
        /// Move the main tether's object to a chosen position.
        /// </summary>
        /// <param name="tetherType">The enum of the tether associated with the two objects.</param>
        /// <param name="position">The new position to move the object tether to.</param>
        /// <param name="useFloorOffset">If true, will set fixed Y floor offset</param>
        /// <param name="useTween">Indicates whether to animate (tween) the movement or move instantly. Default is true.</param>
        public void MoveTether(TetherEnum tetherType, Vector3 position, bool useFloorOffset = true, bool useTween = true)
        {
            if (TryGetTether(tetherType, out TransformTether tether))
            {
                if (useFloorOffset)
                {
                    position.Modify(y: SUMMON_FLOOR_OFFSET);
                }
                tether.MoveTether(position, useTween);
            }
        }

        /// <summary>
        /// Summons the specified tether to the player's position, placing it half a meter in front of the camera.
        /// </summary>
        /// <param name="tetherType">The type of tether to summon.</param>
        /// <param name="keepLocalOffset">If true, maintains the tether's local offset relative to the player. Default is false.</param>
        /// <param name="useTween">Indicates whether to animate (tween) the movement or move instantly. Default is true.</param>
        public void SummonTetherToPlayer(TetherEnum tetherType, bool keepLocalOffset = false, bool useTween = true)
        {
            Vector3 position;

            bool useFloorOffset = true;
            if (keepLocalOffset && TryGetTether(tetherType, out TransformTether tether) && tether.LocalOffset != Vector3.zero)
            {
                position = PlayerController.Instance.WaistController.transform.TransformPoint(tether.LocalOffset);
                useFloorOffset = false;
            }
            else
            {
                position = PlayerController.Instance.MainCamera.transform.position +
                           PlayerController.Instance.MainCamera.transform.forward * .5f
                           + Vector3.down * 0.2f;
            }
            
            MoveTether(tetherType, position, useFloorOffset, useTween);
        }
        
        /// <summary>
        /// Tries to get the tether associated with the specified enum type.
        /// </summary>
        /// <param name="tetherType">The type of tether to retrieve.</param>
        /// <param name="tether">The retrieved tether if found; otherwise, null.</param>
        /// <returns>True if the tether object is found, false otherwise.</returns>
        public bool TryGetTether(TetherEnum tetherType, out TransformTether tether)
        {
            if (tetherMappings.TryGetValue(tetherType, out tether))
            {
                return true;
            }

            Debug.LogError($"Tether of type {tetherType} not found in TetherController.");
            return false;
        }
        
        private void HandleScenarioStarted(ScenarioManager scenarioManager, ScenarioDataType scenarioData)
        {
            foreach (TransformTether tether in tetherMappings.Values)
            {
                tether.ResetLocalOffset();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Tethers/TetherController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Tethers/TransformTarget.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c7b093d2cfb048c6a9e321742d3a40c0
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Systems.Tethers
{
    /// <summary>
    /// Represents a transform target object with position and rotation properties.
    /// Fires events when the target state (enabled or disabled) changes.
    /// </summary>
    public class TransformTarget : MonoBehaviour
    {
        public event Action<TransformTarget, bool> OnTargetStateChanged;

        public Vector3 Position
        {
            get => transform.position;
            set => transform.position = value;
        }
		
        public Quaternion Rotation
        {
            get => transform.rotation;
            set => transform.rotation = value;
        }

        private void OnEnable()
        {
            OnTargetStateChanged?.Invoke(this, true);
        }

        private void OnDisable()
        {
            OnTargetStateChanged?.Invoke(this, false);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Tethers/TransformTarget.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/Tethers/TransformTether.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 61d74ca4a0605e34ca42c82712cdd4b3
# ASMDEF: ldx.framework.runtime.dll
# ---
using DG.Tweening;
using Ldx.Framework.Systems.Player;
using TMPro;
using UnityEngine;

namespace Ldx.Framework.Systems.Tethers
{
	/// <summary>
	/// A modular approach to anchoring objects, allowing a tether to attach one object to another in local or world space.
	/// Provides options for positioning, rotation, and offset control.
	/// </summary>
	public class TransformTether : MonoBehaviour
	{
		[Tooltip("This is the object which will be the target of being attached to. Example, a wrist")] 
		[SerializeField] private Transform tetherTarget;
		[Tooltip("This is the object that we will attach to the tetherTarget. Example, a sticker")] 
		[SerializeField] private TransformTarget transformToTether;
		[Tooltip("The transform that represents the player's forward direction (e.g., camera or head transform)")]
		[SerializeField] private Vector3 offset;
		[SerializeField] private bool useWorldOffset;
		[SerializeField] private bool lookAtCamera;
		[SerializeField] private Vector3 lookAtOffset;
		[SerializeField] private bool alignVertically;
		[Tooltip("How quickly the object follows the wrist movement")] 
		[SerializeField] private float followSpeed = 5f;

		[Space] 
		[SerializeField] private TextMeshProUGUI debugUiReadout;
		
		private Tween moveTween;

		public Vector3 LocalOffset { get; private set; } = Vector3.zero;
		public Vector3 Position => tetherTarget.transform.position;

		private void OnEnable()
		{
			UpdatePosition(true);
			UpdateRotation(true);
		}

		private void Awake()
		{
			if (offset != Vector3.zero && debugUiReadout != null)
			{
				debugUiReadout.text = offset.ToString();
			}

			transformToTether.OnTargetStateChanged += HandleTargetStateChanged;
		}

		private void OnDestroy()
		{
			moveTween.Kill();
			transformToTether.OnTargetStateChanged -= HandleTargetStateChanged;
		}
		
		private void LateUpdate()
		{
			UpdatePosition();
			UpdateRotation();
		}

		/// <summary>
		/// Updates the position of the tethered object, optionally moving it instantly.
		/// </summary>
		/// <param name="instantly">If true, the object moves instantly to the target position.</param>
		private void UpdatePosition(bool instantly = false)
		{
			Vector3 desiredPosition = tetherTarget.position;
			if (useWorldOffset)
			{
				desiredPosition += offset;
			}
			else
			{
				desiredPosition += tetherTarget.TransformDirection(offset);
			}

			transformToTether.Position = Vector3.Lerp(transformToTether.Position, desiredPosition,
				instantly ? 1 : Time.smoothDeltaTime * followSpeed);
		}

		/// <summary>
		/// Updates the rotation of the tethered object, optionally rotating it instantly.
		/// </summary>
		/// <param name="instantly">If true, the object rotates instantly to the desired rotation.</param>
		private void UpdateRotation(bool instantly = false)
		{
			Quaternion desiredRotation;

			if (lookAtCamera)
			{
				Vector3 directionToCamera =
					transformToTether.Position - PlayerController.Instance.MainCamera.transform.position;
				directionToCamera.y = 0;
				
				desiredRotation = Quaternion.LookRotation(directionToCamera);
				desiredRotation *= Quaternion.Euler(lookAtOffset);
			}
			else
			{
				desiredRotation = alignVertically
					? Quaternion.Euler(0, tetherTarget.eulerAngles.y, 0)
					: tetherTarget.rotation;
			}
			
			transformToTether.Rotation = Quaternion.Slerp(transformToTether.Rotation, desiredRotation,
				instantly ? 1 : Time.smoothDeltaTime * followSpeed);
		}
		
		/// <summary>
		/// Handles the state change of the tether target.
		/// </summary>
		/// <param name="transformTarget">The transform target that changed state.</param>
		/// <param name="isActive">The new state of the target.</param>
		private void HandleTargetStateChanged(TransformTarget transformTarget, bool isActive)
		{
			SetTetherActive(isActive);
		}
		
		/// <summary>
		/// Updates the local offset of the tether relative to the player's waist.
		/// </summary>
		public void UpdateLocalOffsetFromWaist()
		{
			LocalOffset = PlayerController.Instance.WaistController.transform.InverseTransformPoint(tetherTarget.transform.position);
		}

		/// <summary>
		/// Resets the local offset of the tether to zero.
		/// </summary>
		public void ResetLocalOffset()
		{
			LocalOffset = Vector3.zero;
		}
		
		/// <summary>
		/// Activates or deactivates the tether, respecting the blocked state.
		/// </summary>
		/// <param name="state">True to activate, false to deactivate.</param>
		public void SetTetherActive(bool state)
		{
			gameObject.SetActive(state);
		}

		/// <summary>
		/// Moves the tether target to the specified position, optionally using a tween animation.
		/// </summary>
		/// <param name="position">The target position to move the tether to.</param>
		/// <param name="useTween">If true, moves the tether with an animation.</param>
		public void MoveTether(Vector3 position, bool useTween = false)
		{
			if (!tetherTarget)
			{
				return;
			}
			
			moveTween?.Kill();

			if (useTween)
			{
				moveTween = tetherTarget.transform.DOMove(position, 0.5f).OnComplete(UpdateLocalOffsetFromWaist);
			}
			else
			{
				tetherTarget.transform.position = position;
				UpdateLocalOffsetFromWaist();
			}
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/Tethers/TransformTether.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/AddInputCanvas.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c7344024b1a740f9ad5b8532bd7326eb
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Systems.UI
{
    [RequireComponent(typeof(Canvas))]
    public class AddInputCanvas : MonoBehaviour
    {
        [SerializeField]
        private Canvas canvas;

        private void OnValidate()
        {
            if (canvas == null)
            {
                canvas = GetComponent<Canvas>();
            }
        }

        //TODO: add input canvas
        /*private void Start()
        {
            HVRInputModule.Instance.AddCanvas(canvas);
        }

        private void OnDestroy()
        {
            if (HVRInputModule.Instance != null)
            {
                HVRInputModule.Instance.RemoveCanvas(canvas);
            }
        }*/
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/AddInputCanvas.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Appearance/ButtonStyleProfile.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9a5510118c9a40c39b6f84ff1cf0028c
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using DG.Tweening;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;

namespace Ldx.Framework.Systems.UI.Appearance
{
    /// <summary>
    /// Represents the visual style of a button, including colors, font style, and scale.
    /// </summary>
    [Serializable]
    public class ButtonStyle
    {
        public Color primaryColor = Color.white;
        public Color accentColor = Color.white;
        public Color additionalColor = Color.white;
        public FontStyle font = FontStyle.Normal;
        public Color primaryTextColor = Color.white;
        public Color accentTextColor = Color.white;
        public Vector3 scale = Vector3.one;
    }

    /// <summary>
    /// Represents a transition between two button states, including the duration and easing of the transition.
    /// </summary>
    [Serializable]
    public class ButtonStateTransition
    {
        public ButtonState startState;
        public ButtonState endState;
        public float tweenDuration = 0.1f;
        public Ease ease = Ease.Linear;

        /// <summary>
        /// Returns a default transition with a linear ease and 0.1 seconds duration.
        /// </summary>
        /// <returns>A default ButtonStateTransition object.</returns>
        public static ButtonStateTransition Default()
        {
            return new ButtonStateTransition();
        }
    }
    
    /// <summary>
    /// A ScriptableObject that defines a profile for button styles and transitions between button states.
    /// </summary>
    [CreateAssetMenu(menuName = "UI/Style/Button Style", fileName = "Button Style Profile", order = 100)]
    public class ButtonStyleProfile : ScriptableObject
    {
        public SerializableDictionary<ButtonState, ButtonStyle> stateButtonStyleMap = new();
        public List<ButtonStateTransition> buttonStateTransitions = new();

        /// <summary>
        /// Gets a transition between two button states, or returns a default transition if no match is found.
        /// </summary>
        /// <param name="startState">The starting button state.</param>
        /// <param name="endState">The ending button state.</param>
        /// <returns>A ButtonStateTransition object representing the transition between the states.</returns>
        public ButtonStateTransition GetTransitionOrDefault(ButtonState startState, ButtonState endState)
        {
            ButtonStateTransition found =
                buttonStateTransitions.FirstOrDefault(x => x.startState == startState && x.endState == endState);
            
            return found ?? ButtonStateTransition.Default();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Appearance/ButtonStyleProfile.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Appearance/IAppearanceUpdateableUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f025b8429b2e4ad448da5b1a9844c702
# ASMDEF: ldx.framework.runtime.dll
# ---
namespace Ldx.Framework.Systems.UI.Appearance
{
    /// <summary>
    /// Any UI element that should update its appearance when UI themes/appearance is changed
    /// should implement this interface and apply the appropriate changes (fonts, colors, sounds etc)
    /// </summary>
    public interface IAppearanceUpdateableUI
    {
        /// <summary>
        /// Update the appearance of the UI element when UI theme or appearance is changed globally.
        /// </summary>
        public void UpdateAppearanceUI();
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Appearance/IAppearanceUpdateableUI.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/AutoRestartWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: fed5397d5bb33104baa2fc03e481a0a2
# ASMDEF: ldx.framework.runtime.dll
# ---
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.UI;
using TMPro;
using UnityEngine;

namespace Ldx.Framework.Systems.UI
{
    /// <summary>
    /// Detects if the headset has gone into sleep mode. If that occurs, triggers a restart when coming back.
    /// </summary>
    public class AutoRestartWindow : UIElement
    {
        [Header("Countdown")]
        [SerializeField] private TextMeshProUGUI countdownText;
        [SerializeField] private uint countdownTime;
        
        [Header("Abort Button")]
        [SerializeField] private UIButton abortButton;
        
        private bool abort;
        
        protected override void Awake()
        {
            base.Awake();
            if(abortButton)
                abortButton.OnButtonPressed += HandleAbortButtonPressed;
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
            if(abortButton)
                abortButton.OnButtonPressed -= HandleAbortButtonPressed;
            abort = true;
        }

        protected override void ShowElementBeginActions(bool instant)
        {
            base.ShowElementBeginActions(instant);
            abort = false;
            countdownText.text = countdownTime.ToString();
        }

        protected override  void ShowElementCompleted()
        {
            base.ShowElementCompleted();
            StartCountdownAsync().Forget();
        }

        protected override void HideElementBeginActions(bool instant)
        {
            base.HideElementBeginActions(instant);;
            abort = true;
        }

        private async UniTaskVoid StartCountdownAsync()
        {
            uint timeRemaining = countdownTime;
            
            float nextUpdateTime;
            while (timeRemaining > 0)
            {
                nextUpdateTime = Time.time + 1; // 1 update per second
                await UniTask.WaitUntil(() => Time.time >= nextUpdateTime);
                if (!this || abort)
                {
                    if (this)
                    {
                        abort = false;
                    }

                    return;
                }
                
                timeRemaining--;
                countdownText.text = timeRemaining.ToString();
            }
            
            ScenarioManager.Instance.LoadScenario(GlobalData.Instance.GetScenarioData(0)).Forget();
        }

        private void AbortRestart()
        {
            abort = true;
            UIController.Instance.HideModuleAutoRestartWindow();
        }
        
        private void HandleAbortButtonPressed(UIButton button)
        {
            AbortRestart();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/AutoRestartWindow.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Buttons/ActionButton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c126afcbb4e5414a947e38db67ae2795
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.UI
{
    /// <summary>
    /// Represents a button within the quick actions window that performs different actions based on its type.
    /// </summary>
    public class ActionButton : UIButton
    {
        [Space]
        [SerializeReference][InheritedClassDropdown(typeof(ButtonBehaviour), "Behaviour")]
        private ButtonBehaviour behaviour = new ExitBehaviour();
        
        [Space]
        [SerializeReference][InheritedClassDropdown(typeof(ButtonBehaviour), "Behaviour")]
        private ButtonBehaviour[] additionalBehaviours = Array.Empty<ButtonBehaviour>();

        protected override void OnEnable()
        {
            base.OnEnable();
            behaviour?.OnButtonEnabled();
        }

        public override void ReleaseActions()
        {
            DoButtonAction();
            base.ReleaseActions();
        }

        /// <summary>
        /// Executes the action corresponding to the button's action behaviour.
        /// </summary>
        private void DoButtonAction()
        {
            behaviour?.ProcessAction();
            foreach (ButtonBehaviour behaviour in additionalBehaviours)
            {
                behaviour?.ProcessAction();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Buttons/ActionButton.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Buttons/ButtonBehaviour.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c726d095547c4e699e4ef0b484c91d5f
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Utilities.Attributes;
using Systems.UI;
using TMPro;
using UnityEngine;

namespace Ldx.Framework.Systems.UI
{
    /// <summary>
    /// Base class for defining the behavior of a button. 
    /// Derived classes should implement logic to determine whether the button should be shown 
    /// and what action should be performed when the button is pressed.
    /// </summary>
    [Serializable]
    public abstract class ButtonBehaviour
    {
        public virtual bool HideWindowAfterPress => true;

        /// <summary>
        /// Called OnEnable for the button
        /// Derived classes can implement this method to define specific behaviour when enabled.
        /// </summary>
        public virtual void OnButtonEnabled() { }
        
        /// <summary>
        /// Determines if the button should be visible based on the current scenario or game state.
        /// This method must be overridden by derived classes to define the specific conditions.
        /// </summary>
        /// <returns>True if the button should be shown, otherwise false.</returns>
        public abstract bool ShouldShowButton();
        
        /// <summary>
        /// Executes the action associated with the button.
        /// Derived classes must implement this method to define the specific action when the button is pressed.
        /// </summary>
        public abstract void ProcessAction();
    }
    
    /// <summary>
    /// Represents the behavior of a button that takes the player to the lobby.
    /// </summary>
    [Serializable]
    public class LobbyBehaviour : ButtonBehaviour
    {
        public override bool ShouldShowButton()
        {
            return ScenarioManager.Instance.HasLobby;
        }

        public override void ProcessAction()
        {
            ScenarioManager.Instance.LoadLobby();
        }
    }

    /// <summary>
    /// Represents the behavior of a button that restarts the current scenario.
    /// </summary>
    [Serializable]
    public class RestartBehaviour : ButtonBehaviour
    {
        public override bool ShouldShowButton()
        {
            ScenarioData loadedScenario = ScenarioManager.Instance.LoadedScenarioData;
            return loadedScenario != null && loadedScenario.IncludeInMenuSelectionList;
        }

        public override void ProcessAction()
        {
            ScenarioManager.Instance.ReloadCurrentScenario();
        }
    }
    
    /// <summary>
    /// Represents the behavior of a button that loads a specific scenario.
    /// </summary>
    [Serializable]
    public class SpecificScenarioBehaviour : ButtonBehaviour
    {
        [SerializeField][IDSelection(LdxIdSettings.IdType.Scenario)]
        private string scenarioId;

        [SerializeField] private LocalizedTextUGUI scenarioNameText;
        [SerializeField] private LocalizedTextUGUI scenarioDescriptionText;

        public override void OnButtonEnabled()
        {
            base.OnButtonEnabled();
            OnButtonEnabledAsync().Forget();
        }

        private async UniTaskVoid OnButtonEnabledAsync()
        {
            await UniTask.WaitUntil(() => ScenarioManager.IsValid);
            if(scenarioNameText)
                scenarioNameText.SetString(GlobalData.Instance.GetScenarioData(scenarioId)?.ScenarioName);
            if(scenarioDescriptionText)
                scenarioDescriptionText.SetString(GlobalData.Instance.GetScenarioData(scenarioId)?.Description);
        }

        public override bool ShouldShowButton()
        {
            return true;
        }
        
        public override void ProcessAction()
        {
            ScenarioManager.Instance.LoadScenario(scenarioId);
        }
    }

    /// <summary>
    /// Represents the behavior of a button that proceeds to the next scenario.
    /// </summary>
    [Serializable]
    public class NextScenarioBehaviour : ButtonBehaviour
    {
        [SerializeField] private LocalizedTextUGUI scenarioNameText;
        
        public override void OnButtonEnabled()
        {
            base.OnButtonEnabled();
            OnButtonEnabledAsync().Forget();
        }

        private async UniTaskVoid OnButtonEnabledAsync()
        {
            await UniTask.WaitUntil(() => ScenarioManager.IsValid);
            if(scenarioNameText && ScenarioManager.Instance.HasNextScenario)
                scenarioNameText.SetString(ScenarioManager.Instance.NextScenarioData?.ScenarioName);
        }
        
        public override bool ShouldShowButton()
        {
            return ScenarioManager.Instance.HasNextScenario;
        }

        public override void ProcessAction()
        {
            ScenarioManager.Instance.LoadNextScenario();
        }
    }
    
    /// <summary>
    /// Represents the behavior of a button that goes back to the first scenario in the list.
    /// </summary>
    [Serializable]
    public class FirstScenarioBehaviour : ButtonBehaviour
    {
        public override bool ShouldShowButton()
        {
            return true;
        }

        public override void ProcessAction()
        {
            ScenarioManager.Instance.LoadFirstScenario();
        }
    }

    /// <summary>
    /// Represents the behavior of a button that toggles the settings window.
    /// </summary>
    [Serializable]
    public class MainMenuBehaviour : ButtonBehaviour
    {
        public override bool HideWindowAfterPress => false;

        public override bool ShouldShowButton()
        {
            return true;
        }

        public override void ProcessAction()
        {
            UIController.Instance.ToggleMainWindow();
        }
    }

    /// <summary>
    /// Represents the behavior of a button that exits the application.
    /// </summary>
    [Serializable]
    public class ExitBehaviour : ButtonBehaviour
    {
        public override bool ShouldShowButton()
        {
            return true;
        }

        public override void ProcessAction()
        {
            Application.Quit();
        }
    }
    
    /// <summary>
    /// Represents the behavior of a button that changes the language
    /// </summary>
    [Serializable]
    public class LanguageBehaviour : ButtonBehaviour
    {
        [SerializeField]
        private TextMeshProUGUI languageText;
        
        public override bool ShouldShowButton()
        {
            return true;
        }

        public override void ProcessAction()
        {
            LocalizationModel.MoveToNextLanguage();
            if(languageText)
                languageText.text = LocalizationModel.CurrentLanguage.ToString();
        }
    }

    /// <summary>
    /// Represents the behavior of a button that toggles a game object
    /// </summary>
    [Serializable]
    public class ToggleGameObjectBehaviour : ButtonBehaviour
    {
        [SerializeField]
        private GameObject gameObjectToToggle;
        
        public override bool ShouldShowButton()
        {
            return true;
        }

        public override void ProcessAction()
        {
            if(gameObjectToToggle != null)
                gameObjectToToggle.SetActive(!gameObjectToToggle.activeSelf);
        }
    }

    /// <summary>
    /// Represents the behavior of a button that can Toggle, Show, or Hide UI elements
    /// </summary>
    public class UIShowHideBehaviour : ButtonBehaviour
    {
        public enum UIActionTypes
        {
            Toggle,
            Show,
            Hide
        }
        
        [SerializeField]
        private UIElement uiElementTarget;
        [SerializeField]
        private UIActionTypes uiActionType;

        public override bool ShouldShowButton()
        {
            return true;
        }

        public override void ProcessAction()
        {
            if (uiElementTarget == null)
                return;
            
            switch (uiActionType)
            {
                case UIActionTypes.Hide:
                    uiElementTarget.HideElement();
                    break;
                case UIActionTypes.Show:
                    uiElementTarget.ShowElement();
                    break;
                case UIActionTypes.Toggle:
                    if(uiElementTarget.IsShown)
                        uiElementTarget.HideElement();
                    else
                        uiElementTarget.ShowElement();
                    break;
            }
        }
    }
    
    /// <summary>
    /// Represents the behavior of a button that can Toggle, Show, or Hide the inventory
    /// </summary>
    public class InventoryBehaviour : ButtonBehaviour
    {
        public enum InventoryActionTypes
        {
            Toggle,
            Open,
            Close
        }
        
        [SerializeField]
        private InventoryActionTypes inventoryActionType = InventoryActionTypes.Toggle;
        
        public override bool ShouldShowButton()
        {
            return true;
        }

        public override void ProcessAction()
        {
            if (InventoryHandler.Instance == null)
                return;
            
            switch (inventoryActionType)
            {
                case InventoryActionTypes.Toggle:
                    InventoryHandler.Instance.ToggleInventory();
                    break;
                case InventoryActionTypes.Open:
                    InventoryHandler.Instance.OpenInventory();
                    break;
                case InventoryActionTypes.Close:
                    InventoryHandler.Instance.CloseInventory();
                    break;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Buttons/ButtonBehaviour.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Buttons/ButtonStateVisualBehaviour.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 538dfc6403544d1a87b971899a7807a6
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;
using UnityEngine.UI;

namespace Ldx.Framework.Systems.UI
{
    [Serializable]
    public abstract class ButtonStateVisualBehaviour
    {
        // Called by UIButtonBase when it initializes
        public virtual void Initialize(UIButton ownerButton) { }

        // Called by UIButtonBase when its state changes
        // 'ownerButton' provides access to the GameObject, transform, etc.
        // 'targetElement' could be a specific Graphic/Transform this behaviour acts upon
        public abstract UniTask ApplyState(UIButton ownerButton, ButtonState newState);

        // Optional: For cleaning up (e.g., killing tweens)
        public virtual void OnDisableOrDestroy(UIButton ownerButton) { }
    }

    public class TweenedStatesBehaviour : ButtonStateVisualBehaviour
    {
        [SerializeField] private UITweenedStates tweenSetup;
        
        public override async UniTask ApplyState(UIButton ownerButton, ButtonState newState)
        {
            if (tweenSetup == null) 
                return;

            tweenSetup.SetState(newState);
            
            await UniTask.CompletedTask;
        }
    }

    public class AnimatorBehaviour : ButtonStateVisualBehaviour
    {
        [SerializeField] private Animator animator;
        
        public override async UniTask ApplyState(UIButton ownerButton, ButtonState newState)
        {
            if (animator == null)
            {
                return;
            }
            
            ButtonState buttonState = ownerButton.ButtonState;
            
            animator.SetBool("Disabled", buttonState == ButtonState.Disabled);
            if (buttonState == ButtonState.Pressed)
            {
                animator.SetTrigger("Pressed");
            }
            
            animator.SetBool("Hovered", buttonState == ButtonState.Hover);
            animator.SetBool("Selected", buttonState == ButtonState.Selected);
            
            await UniTask.CompletedTask;
        }
    }
    
    public class SpriteSwapBehaviour : ButtonStateVisualBehaviour
    {
        [SerializeField] private Image targetImage;
        [SerializeField] private SerializableDictionary<ButtonState, Sprite> buttonStateSpriteSet = new();

        public override async UniTask ApplyState(UIButton ownerButton, ButtonState newState)
        {
            if (targetImage == null) 
                return;

            if (buttonStateSpriteSet.TryGetValue(newState, out Sprite newIcon))
            {
                targetImage.sprite = newIcon;
            }
            
            await UniTask.CompletedTask;
        }
    }
    
    public class SpriteColorChangeBehaviour : ButtonStateVisualBehaviour
    {
        [SerializeField] private Image targetImage;
        [SerializeField] private SerializableDictionary<ButtonState, Color> buttonStateColorSet = new();
        [SerializeField] private float duration = 0.25f;

        private Tween colorChangeTween;

        public override async UniTask ApplyState(UIButton ownerButton, ButtonState newState)
        {
            if (targetImage == null) 
                return;

            if (buttonStateColorSet.TryGetValue(newState, out Color newColor))
            {
                colorChangeTween?.Kill();
                colorChangeTween = targetImage.DOColor(newColor, duration);
                await colorChangeTween;
            }
            
            await UniTask.CompletedTask;
        }

        public override void OnDisableOrDestroy(UIButton ownerButton)
        {
            base.OnDisableOrDestroy(ownerButton);
            colorChangeTween?.Kill();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Buttons/ButtonStateVisualBehaviour.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Buttons/UIButton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 445f7a0a77034e58939a3003e009111a
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Utilities.Attributes;
using Systems.UI;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

namespace Ldx.Framework.Systems.UI
{
    public enum ButtonState
    {
        Idle = 0,
        Hover = 1,
        Pressed = 2,
        Selected = 3,
        Disabled = 4
    }
    
    public class UIButton : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerDownHandler,
        IPointerUpHandler
    {
        public static event Action<UIButton> OnAnyUIButtonStart;
        public static event Action<UIButton> OnAnyUIButtonHover;
        
        public event Action<UIButton> OnButtonPressed; 
        public event Action<UIButton> OnButtonHover; 
        public event Action<UIButton> OnButtonUnhover; 
        
        [SerializeField][ReadOnly]
        private ButtonState buttonState = ButtonState.Idle;
        public ButtonState ButtonState => buttonState;

        [Serializable]
        public class ButtonStateVisualBehaviourContainer
        {
            [SerializeReference][InheritedClassDropdown(typeof(ButtonStateVisualBehaviour))]
            private ButtonStateVisualBehaviour behaviour;
            public ButtonStateVisualBehaviour Behaviour => behaviour;
        }

        [SerializeField] private ButtonStateVisualBehaviourContainer behaviourContainer;
        
        [SerializeField] private LocalizedTextUGUI text;
        public LocalizedTextUGUI Text => text;
        [SerializeField] private Image icon;
        public Image Icon => icon;
        
        protected bool IsPointerDown { get; set; }
        protected bool Hovering { get; set; }
        public bool IsSelected { get; set; }
        protected virtual string HoverSound => null;
        protected virtual string ClickedSound => null;

        public bool IsInteractable { get; private set; } = true;
        
        protected ButtonState CurrentButtonState
        {
            get
            {
                if (!IsInteractable)
                    return ButtonState.Disabled;
                if (IsPointerDown)
                    return ButtonState.Pressed;
                if (IsSelected)
                    return ButtonState.Selected;
                if (Hovering)
                    return ButtonState.Hover;
                return ButtonState.Idle;
            }
        }

        private void Awake()
        {
            if(behaviourContainer.Behaviour != null)
                behaviourContainer.Behaviour.Initialize(this);
        }

        protected virtual void OnEnable()
        {
            ResetActions();
        }

        private void Start()
        {
            OnAnyUIButtonStart?.Invoke(this);
        }

        private void OnDestroy()
        {
            if(behaviourContainer.Behaviour != null)
                behaviourContainer.Behaviour.OnDisableOrDestroy(this);
        }

        #region Handlers
        
        public void OnPointerEnter(PointerEventData eventData)
        {
            HoverActions();
        }

        public void OnPointerExit(PointerEventData eventData)
        {
            UnHoverActions();
        }
        
        public void OnPointerUp(PointerEventData eventData)
        {
            if (!Hovering || eventData.button != PointerEventData.InputButton.Left)
                return;

            ReleaseActions();
        }
        
        public void OnPointerDown(PointerEventData eventData) 
        {
            if (eventData.button != PointerEventData.InputButton.Left || !IsInteractable)
                return;

            PressActions();
        }

        #endregion

        #region Main

        protected virtual void HoverActions()
        {
            Hovering = true;
            OnButtonHover?.Invoke(this);
            OnAnyUIButtonHover?.Invoke(this);
            DoStateTransition(CurrentButtonState);
        }
        
        protected virtual void UnHoverActions()
        {
            Hovering = false;
            IsPointerDown = false;
            OnButtonUnhover?.Invoke(this);
            DoStateTransition(CurrentButtonState);
        }

        public virtual void PressActions()
        {
            IsPointerDown = true;
            DoStateTransition(CurrentButtonState);
        }

        public virtual void ReleaseActions()
        {
            IsPointerDown = false;
            OnButtonPressed?.Invoke(this);
            DoStateTransition(CurrentButtonState);
        }

        public virtual void ResetActions()
        {
            IsPointerDown = false;
            Hovering = false;
            buttonState = ButtonState.Idle;
            DoStateTransition(CurrentButtonState);
        }

        #endregion
        
        #region Public Methods
        
        public void SetInteractable(bool interactable)
        {
            IsInteractable = interactable;
            DoStateTransition(CurrentButtonState);
        }
        
        public void SetButtonIcon(Sprite sprite)
        {
            if(icon != null)
                icon.sprite = sprite;
        }
        
        /// <summary>
        /// Transition the ButtonState to the entered state.
        /// </summary>
        /// <param name="state">State to transition to</param>
        /// <param name="instant">Should the transition occur instantly.</param>
        protected virtual void DoStateTransition(ButtonState state, bool instant = false)
        {
            if (!gameObject.activeInHierarchy)
                return;
            
            ButtonState previousButtonState = buttonState;
            buttonState = state;

            if (previousButtonState == state)
                return;
            
            if(behaviourContainer.Behaviour != null)
                behaviourContainer.Behaviour.ApplyState(this, buttonState);
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Buttons/UIButton.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Components/CustomHorizontalScrollRect.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9f4e2f4e6d32430799d2cab7c0d6828b
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using DG.Tweening;
using Ldx.Framework.Utilities;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

namespace Ldx.Framework.Systems.UI.Components
{
    /// <summary>
    /// Custom horizontal scroll rect
    /// Has IsDragging and scroll begin, end events
    /// Has optional limits for min and max normalized position
    /// Includes snapping behaviour that will gradually set scroll rect normalized position to damped value
    /// </summary>
    public class CustomHorizontalScrollRect : ScrollRect
    {
        public event Action<CustomHorizontalScrollRect> OnScrollRectBeginDrag;
        public event Action<CustomHorizontalScrollRect> OnScrollRectEndDrag;
        public event Action<CustomHorizontalScrollRect> OnScrollRectSnapCompleted;

        public bool IsDragging { get; private set; }
        public bool IsSnapping { get; private set; }

        private bool ignoreLimits = false;
        private float scrollRectLimitMin = float.MinValue;
        private float scrollRectLimitMax = float.MaxValue;
        private float snapDurationPerUnit;
        private float snapVelocity;
        private Coroutine snapRoutine;
        private Tween normalizedPositionTween;

        protected override void OnDisable()
        {
            base.OnDisable();
            StopSnapping();
            normalizedPositionTween?.Kill();
        }

        /// <summary>
        /// Sets the normalized position limits
        /// To reset it, set values to float.MinValue and float.MaxValue
        /// </summary>
        /// <param name="minLimit">Limit of min normalized position</param>
        /// <param name="maxLimit">Limit of max normalized position</param>
        public void SetLimits(float minLimit, float maxLimit)
        {
            scrollRectLimitMin = minLimit;
            scrollRectLimitMax = maxLimit;
        }

        public override void OnBeginDrag(PointerEventData eventData)
        {
            base.OnBeginDrag(eventData);
            IsDragging = true;
            OnScrollRectBeginDrag?.Invoke(this);
        }

        public override void OnEndDrag(PointerEventData eventData)
        {
            base.OnEndDrag(eventData);
            IsDragging = false;
            OnScrollRectEndDrag?.Invoke(this);
        }

        /// <summary>
        /// Starts snapping routine to the given value
        /// </summary>
        /// <param name="normalizedPositionToSnap">Normalized position to snap</param>
        public void SnapToNormalizedHorizontalPosition(float normalizedPositionToSnap)
        {
            IsSnapping = true;
            CoroutineUtilities.ReplaceAndStartCoroutine(ref snapRoutine, SnapRoutine(normalizedPositionToSnap), this);
        }

        protected override void SetContentAnchoredPosition(Vector2 position)
        {
            base.SetContentAnchoredPosition(position);

            // Updates normalized position to be within the limits
            if (horizontalNormalizedPosition > scrollRectLimitMax)
            {
                SetNormalizedPosition(scrollRectLimitMax, 0);
            }
            else if (horizontalNormalizedPosition < scrollRectLimitMin)
            {
                SetNormalizedPosition(scrollRectLimitMin, 0);
            }
        }

        protected override void SetNormalizedPosition(float value, int axis)
        {
            if (!ignoreLimits)
            {
                // Correct normalized position value with the scroll rect limits
                if (value > scrollRectLimitMax)
                {
                    value = scrollRectLimitMax;
                }
                else if (value < scrollRectLimitMin)
                {
                    value = scrollRectLimitMin;
                }
            }

            base.SetNormalizedPosition(value, axis);

            Bounds bounds = new Bounds(viewRect.rect.center, viewRect.rect.size);
            // How much the content is larger than the view.
            float hiddenLength = m_ContentBounds.size[axis] - bounds.size[axis];
            // Where the position of the lower left corner of the content bounds should be, in the space of the view.
            float contentBoundsMinPosition = bounds.min[axis] - value * hiddenLength;
            // The new content localPosition, in the space of the view.
            float newAnchoredPosition =
                content.anchoredPosition[axis] + contentBoundsMinPosition - m_ContentBounds.min[axis];

            Vector3 anchoredPosition = content.anchoredPosition;

            float delta = Mathf.Abs(anchoredPosition[axis] - newAnchoredPosition);
            if (delta <= 0.01f && delta > 0.0001f)
            {
                anchoredPosition[axis] = newAnchoredPosition;
                content.anchoredPosition = anchoredPosition;
                velocity = new Vector2(axis == 0 ? 0 : velocity[0], axis == 1 ? 0 : velocity[1]);
                UpdateBounds();
            }
        }

        private IEnumerator SnapRoutine(float normalizedPositionToSnap)
        {
            normalizedPositionTween?.Kill();
            StopMovement();

            float percentage = 0;
            float startedNormalizedPosition = horizontalNormalizedPosition;
            float duration = Mathf.Abs(startedNormalizedPosition - normalizedPositionToSnap) * snapDurationPerUnit;

            // Creates the tween to increase rotation time percentage until it reaches 1 by transition time to blend
            normalizedPositionTween = DOTween.To(x => percentage = x,
                    0,
                    1,
                    duration)
                .SetUpdate(true)
                .SetEase(Ease.Linear)
                .OnComplete(HandleTweenCompleted);

            void HandleTweenCompleted()
            {
                normalizedPositionTween = null;
                SetNormalizedPosition(normalizedPositionToSnap, 0);
            }

            while (normalizedPositionTween != null && !IsDragging)
            {
                float dampPosition = startedNormalizedPosition <= normalizedPositionToSnap
                    ? Mathf.Lerp(startedNormalizedPosition, normalizedPositionToSnap, percentage)
                    : Mathf.Lerp(normalizedPositionToSnap, startedNormalizedPosition, 1f - percentage);
                SetNormalizedPosition(dampPosition, 0);
                yield return null;
            }

            StopSnapping();
            snapRoutine = null;
        }

        public void StopSnapping()
        {
            if (CoroutineUtilities.TryStopAndNullCoroutine(ref snapRoutine, this))
            {
                IsSnapping = false;
                OnScrollRectSnapCompleted?.Invoke(this);
            }
        }

        public void SetIgnoreLimits(bool ignore)
        {
            ignoreLimits = ignore;
        }

        public void SetSnapDurationPerUnit(float duration)
        {
            snapDurationPerUnit = duration;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Components/CustomHorizontalScrollRect.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/ConfirmationWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4dbf66d2939c4e3d80086264cac46b41
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Localization;
using Systems.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace Ldx.Framework.Systems.UI
{
    /// <summary>
    /// Holds all the necessary parameters to configure and display a UIConfirmationWindow.
    /// </summary>
    [Serializable]
    public class ConfirmationArgs
    {
        public event Action<bool> OnProceedConfirmation;
        
        [Tooltip("The specific action name that will be inserted into the header's format string in UIConfirmationWindow " +
                 "(e.g., where {0} is in 'You are about to {0}'). Example: 'delete the item'.")]
        [LocalizationKey] public string headerActionName;
        [Tooltip("The descriptive part of the body message that will be inserted into the body's format string in UIConfirmationWindow" +
                 " (e.g., where {0} is in '{0}. Are you sure about that?'). Example: 'This will quit the game'.")]
        [LocalizationKey] public string body;
        [Tooltip("The specific action name that will be inserted into the proceed button's text format string in UIConfirmationWindow" +
                 " (e.g., where {0} is in 'Yes, {0}'). Example: 'Delete'.")]
        [LocalizationKey] public string proceedActionName;
        [Tooltip("The text to display on the cancel button. If null or empty, UIConfirmationWindow will use its 'defaultCancelText' (e.g. 'Cancel').")]
        [LocalizationKey] public string cancelActionName;
        [Tooltip("An optional custom sprite to display as the alert icon in the confirmation window. " +
                 "If null, UIConfirmationWindow may use a default triangle icon.")]
        public Sprite customAlertIconSprite;

        /// <summary>
        /// Default constructor for Inspector serialization.
        /// Fields should be set directly or via the Inspector.
        /// </summary>
        public ConfirmationArgs() { }
        
        /// <summary>
        /// Initializes a new instance of the <see cref="ConfirmationArgs"/> class.
        /// </summary>
        /// <param name="headerActionName">The specific action name for the header (e.g., "restart the level").</param>
        /// <param name="body">The detailed message for the confirmation.</param>
        /// <param name="proceedActionName">The specific action name for the proceed button (e.g., "Restart").</param>
        /// <param name="callback">The action to call with the user's boolean choice (true for proceed, false for cancel).</param>
        /// <param name="cancelActionName">Optional: The text for the cancel button. Uses default if null or empty.</param>
        /// <param name="customAlertIconSprite">Optional: A specific sprite to use for the alert icon. If null, the window might use a default or hide the icon.</param>
        public ConfirmationArgs(
            string headerActionName,
            string body,
            string proceedActionName,
            string cancelActionName = null,
            Sprite customAlertIconSprite = null)
        {
            this.headerActionName = headerActionName;
            this.body = body;
            this.proceedActionName = proceedActionName;
            this.cancelActionName = cancelActionName;
            this.customAlertIconSprite = customAlertIconSprite;
        }

        public void BroadcastProceedEvent(bool proceed)
        {
            OnProceedConfirmation?.Invoke(proceed);
        }
    }
    
    public class ConfirmationWindow : UIElement
    {
        public static ConfirmationWindow Instance { get; private set; }
        
        [Header("Confirmation Elements")]
        [SerializeField] private LocalizedTextUGUI headerText;
        [SerializeField] private LocalizedTextUGUI mainBodyText;
        [SerializeField] private UIButton proceedButton;
        [SerializeField] private UIButton cancelButton;
        [SerializeField] private Image alertImage;
        
        [Header("Text Formatting")]
        [SerializeField][LocalizationKey] private string headerFormat = "You are about to {0}";
        [SerializeField][LocalizationKey] private string bodyFormat = "{0}. Are you sure about that?";
        [SerializeField][LocalizationKey] private string proceedButtonFormat = "Yes, {0}";
        [SerializeField][LocalizationKey] private string defaultCancelText = "Cancel";

        private ConfirmationArgs currentArgs;
        private Sprite defaultAlertIcon;

        protected override void Awake()
        {
            base.Awake();

            if (proceedButton != null)
            {
                proceedButton.OnButtonPressed += HandleProceedButtonPressed;
            }

            if (cancelButton != null)
            {
                cancelButton.OnButtonPressed += HandleCancelButtonPressed;
            }
            
            defaultAlertIcon = alertImage.sprite;
            if (Instance != null)
            {
                Destroy(gameObject);
                return;
            }

            Instance = this;
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
            Instance = null;
            if (proceedButton != null)
            {
                proceedButton.OnButtonPressed -= HandleProceedButtonPressed;
            }

            if (cancelButton != null)
            {
                cancelButton.OnButtonPressed -= HandleCancelButtonPressed;
            }
        }
        
        private void HandleProceedButtonPressed(UIButton _)
        {
            CompleteConfirmation(true);
        }
        
        private void HandleCancelButtonPressed(UIButton _)
        {
            CompleteConfirmation(false);
        }
        
        /// <summary>
        /// Finalizes the confirmation process by unsubscribing button events,
        /// invoking the stored callback with the user's choice, and then hiding the confirmation window.
        /// </summary>
        /// <param name="proceeded">True if the user chose to proceed; false if they canceled.</param>
        private void CompleteConfirmation(bool proceeded)
        {
            currentArgs.BroadcastProceedEvent(proceeded);
            HideElement(false);
        }
        
        /// <summary>
        /// Initializes and then shows the confirmation window using a <see cref="ConfirmationArgs"/> object.
        /// </summary>
        /// <param name="args">The <see cref="ConfirmationArgs"/> object containing parameters for the dialog.</param>
        public static void ShowConfirmation(ConfirmationArgs args)
        {
            if (Instance == null)
            {
                return;
            }
            
            Instance.Initialize(args);
            Instance.ShowElement(false);
        }
        
        /// <summary>
        /// Initializes the confirmation window with content and a callback using <see cref="ConfirmationArgs"/>.
        /// </summary>
        /// <param name="args">The <see cref="ConfirmationArgs"/> object containing parameters for the dialog.</param>
        private void Initialize(ConfirmationArgs args)
        {
            currentArgs = args ?? throw new ArgumentNullException(nameof(args));
            headerText.SetStringValue(headerFormat, args.headerActionName);
            mainBodyText.SetStringValue(bodyFormat, args.body);
            proceedButton.Text.SetStringValue(proceedButtonFormat, args.proceedActionName);
            cancelButton.Text.SetString(string.IsNullOrEmpty(args.cancelActionName) ? defaultCancelText : args.cancelActionName);

            alertImage.sprite = args.customAlertIconSprite == null ? defaultAlertIcon : args.customAlertIconSprite;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/ConfirmationWindow.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/ControllerButtonChangeUIElementVisibility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 288188f258ed90c4e95b558b45cdcece
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.InputUtilities;
using UnityEngine;

namespace Ldx.Framework.Systems.UI
{
    public class ControllerButtonChangeUIElementVisibility : MonoBehaviour
    {
        public enum UIElementBehaviours
        {
            Toggle,
            Show,
            Hide
        }

        [Serializable]
        public struct UIElementBehaviourOnButtonPress
        {
            public UIElement UiElement;
            public UIElementBehaviours Behaviour;
        }

        [SerializeField][IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string showElementEvent;
        [SerializeField][IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string hideElementEvent;
        [SerializeField] private UIElementBehaviourOnButtonPress[] uiElementBehaviours;
        [SerializeField] private ControllerButtonInput controllerButtonInput;

        private void Awake()
        {
            controllerButtonInput.OnButtonStateChange += HandleControllerButtonInputChanged;
        }

        private void OnDestroy()
        {
            controllerButtonInput.OnButtonStateChange -= HandleControllerButtonInputChanged;
        }

        private void HandleControllerButtonInputChanged(bool isPressed)
        {
            if (!isPressed)
                return;

            foreach (UIElementBehaviourOnButtonPress uiBehaviour in uiElementBehaviours)
            {
                switch (uiBehaviour.Behaviour)
                {
                    case UIElementBehaviours.Toggle:
                    {
                        if (uiBehaviour.UiElement.IsShown)
                        {
                            uiBehaviour.UiElement.HideElement();
                            LdxTrackingManager.Instance.BroadcastTrackingEvent(hideElementEvent);
                        }
                        else
                        {
                            uiBehaviour.UiElement.ShowElement();
                            LdxTrackingManager.Instance.BroadcastTrackingEvent(showElementEvent);
                        }
                        break;
                    }
                    case UIElementBehaviours.Show:
                        uiBehaviour.UiElement.ShowElement();
                        break;
                    case UIElementBehaviours.Hide:
                        uiBehaviour.UiElement.HideElement();
                        break;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/ControllerButtonChangeUIElementVisibility.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/DialogParameters.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e2edb93d02d0404b853858500de17258
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Objectives;
using Systems.Objectives.EventData;
using TMPro;
using UnityEngine;
using UnityEngine.Audio;

namespace Ldx.Framework.Systems.UI
{
    public class DialogParameters
    {
        public string Title { get; set; }
        public string Description { get; set; }
        public string SpeakerTransform { get; set; }
        public bool CanUsePreviousSpeaker{ get; set; }
        public UIElement.AnchorSide AnchorSide { get; set; } = UIElement.AnchorSide.Top;
        public float? CustomTime { get; }
        public DialogEventData.DialogInfo.AnswersContainer Answers { get; set; }
        public DialogueWindow.AnswerButtonLayout AnswerButtonLayout { get; set; } = DialogueWindow.AnswerButtonLayout.Horizontal;
        public bool CloseOnCorrect { get; } = true;
        public bool CloseOnWrong { get; } = false;
        public List<string> EventsOnStart { get; } = new();
        public List<string> EventsOnSuccess { get; } = new();
        public List<string> EventsOnFail { get; } = new();
        public List<string> EventsOnTimerRunOut { get; } = new();
        public bool RandomizeAnswers { get; }
        public string DialogID { get; }
        public string SoundReference { get; }
        public AudioClip AudioClip { get; }
        private float? TextCustomDuration { get; }
        public AudioMixerGroup CustomMixerGroup { get; }
        public DialogueWindow.UIQuestionPrefix QuestionPrefix { get; set; } = DialogueWindow.UIQuestionPrefix.NoPrefix;

        public DialogParameters(HighlightingQuestionData data)
        {
            Title = data.QuestionTitle;
            Description = data.QuestionDescription;
            SoundReference = data.SoundReference;
            List<string> correctEvents = new();
            List<string> wrongEvents = new();

            if (!String.IsNullOrEmpty(data.CorrectAnswerEvent))
            {
                correctEvents.Add(data.CorrectAnswerEvent);
            }
            
            if (!String.IsNullOrEmpty(data.WrongAnswerEvent))
            {
                wrongEvents.Add(data.WrongAnswerEvent);
            }

            EventsOnSuccess = correctEvents;
            EventsOnFail = wrongEvents;
        }

        public DialogParameters(HighlightingExplanationData data)
        {
            Title = data.ExplanationTitle;
            Description = data.ExplanationDescription;
            SoundReference = data.SoundReference;
            Answers = new DialogEventData.DialogInfo.AnswersContainer
            {
                new(data.ContinueText, true)
            };

            if (!String.IsNullOrEmpty(data.DialogCompletionEvent))
            {
                EventsOnSuccess.Add(data.DialogCompletionEvent);
            }
        }

        public DialogParameters(DialogEventData.DialogInfo data, string dialogID)
        {
            Description = data.DialogDescription;
            SpeakerTransform = data.SpeakerTransform;
            CanUsePreviousSpeaker = data.UsePreviousSpeakerIfNeeded;
            AnchorSide = data.AnchorSide;
            DialogID = dialogID;
            SoundReference = data.SoundReference;
            
            CustomMixerGroup = data.AudioMixerGroup;
            if (data.AudioClips != null && data.AudioClips.Count > 0)
            {
                AudioClip = data.AudioClips.FirstOrDefault(c => c.Language == LocalizationModel.CurrentLanguage)
                    ?.AudioClip;
            }
            
            CustomTime = data.EventOptions.CustomTime;
            TextCustomDuration = data.EventOptions.CustomTime;
            Answers = data.Answers;
            AnswerButtonLayout = data.AnswerButtonLayout;
            RandomizeAnswers = false;
            CloseOnCorrect = true;
            CloseOnWrong = true;
            EventsOnStart = data.GetEventsByTriggerEvent(DialogEventData.DialogInfo.EventType.OnDialogStart);
            EventsOnSuccess = data.GetEventsByTriggerEvent(DialogEventData.DialogInfo.EventType.OnCorrectAnswer);
            EventsOnFail = data.GetEventsByTriggerEvent(DialogEventData.DialogInfo.EventType.OnWrongAnswer);
            EventsOnTimerRunOut = data.GetEventsByTriggerEvent(DialogEventData.DialogInfo.EventType.OnTimerRunOut);
        }
        
        public string GetAnswerPrefixByIndex(int currentIndex)
        {
            if (QuestionPrefix == DialogueWindow.UIQuestionPrefix.NoPrefix)
                return "";

            if (QuestionPrefix == DialogueWindow.UIQuestionPrefix.LetteredList)
            {
                return $"{(char)('A' + currentIndex)}. ";
            }

            return $"{currentIndex + 1}. ";
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/DialogParameters.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/DialogueWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a241af75c5354c8ab6d7e0aba6eb1065
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Cysharp.Threading.Tasks;
using FluffyUnderware.DevTools.Extensions;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Systems.VFX;
using Ldx.Framework.UI;
using Ldx.Framework.UI.Dialog;
using Ldx.Framework.Utilities.Serializable;
using Systems.UI;
using UnityEngine;
using UnityEngine.Audio;
using UnityEngine.UI;

namespace Ldx.Framework.Systems.UI
{
    /// <summary>
    /// A window that pops up over a specific position in the world and has question with answer buttons
    /// </summary>
    public class DialogueWindow : UIElement
    {
        public enum UIQuestionPrefix
        {
            NoPrefix,
            LetteredList,
            NumberedList
        }

        public enum AnswerButtonLayout
        {
            Horizontal,
            Vertical
        }
        
        /// <summary>
        /// string - dialog ID
        /// string - answer text
        /// bool - is correct answer
        /// </summary>
        public static event Action<DialogueWindow, string, string, bool> OnAnyQuestionAnswered;
        public static event Action<DialogueWindow> OnQuestionWindowShown;
        public static event Action<DialogueWindow> OnQuestionWindowHidden;

        private readonly Dictionary<UIButton, DialogEventData.DialogInfo.AnswerInfo> buttonsAnswerInfoSet = new();

        [Header("Question Window")] [SerializeField]
        private RectTransform windowCanvasRect;
        [SerializeField]
        private LocalizedTextUGUI dialogueText;
        [SerializeField] 
        private UIArrowPointToTarget arrowPositioner;
        
        [Header("Questions")]
        [SerializeField] private AnswerButtonLayout answerButtonLayout = AnswerButtonLayout.Horizontal;
        [SerializeField] private RectTransform verticalButtonLayoutParent;
        [SerializeField] private RectTransform horizontalButtonLayoutParent;
        [SerializeField] private UIButton buttonPrefab;
        
        private DialogEventData.DialogInfo.AnswerInfo currentCorrectAnswerInfo;
        private DialogParameters parameters;
        private Transform speakerTransform;

        protected override void OnValidate()
        {
            base.OnValidate();
            if (windowCanvasRect == null && canvasGroup != null)
            {
                windowCanvasRect = canvasGroup.GetComponent<RectTransform>();
            }
        }

        protected override void Awake()
        {
            LdxTrackingManager.OnAnyObjectiveComplete += HandleAnyObjectiveCompleted;
        }

        protected override void OnDestroy()
        {
            LdxTrackingManager.OnAnyObjectiveComplete -= HandleAnyObjectiveCompleted;
        }

        protected override void ShowElementCompleted()
        {
            base.ShowElementCompleted();
            OnQuestionWindowShown?.Invoke(this);
        }

        protected override void HideElementCompleted(bool wasActiveBefore)
        {
            base.HideElementCompleted(wasActiveBefore);
            Audio.StopDialogue();
            SetStaticAnchor(null);
            if (wasActiveBefore)
            {
                OnQuestionWindowHidden?.Invoke(this);
            }
        }
        
        public void SetupQuestion(DialogParameters param)
        {
            currentCorrectAnswerInfo = null;
            parameters = param;
            dialogueText.SetString(param.Description);
            
            if (param.Answers != null && param.Answers.Count > 0)
            {
                currentCorrectAnswerInfo = param.Answers.FirstOrDefault(a => a.IsCorrectAnswer);
                if (currentCorrectAnswerInfo == null)
                {
                    currentCorrectAnswerInfo = param.Answers.FirstOrDefault();
                }
                canvasGroup.blocksRaycasts = true;
            }
            else
            {
                canvasGroup.blocksRaycasts = false;
            }

            Transform newSpeakerTransform = LdxReferenceIDTracker.Instance.GetTransform(param.SpeakerTransform);
            if (newSpeakerTransform != null)
                SetAnchor(newSpeakerTransform);
            else if(!param.CanUsePreviousSpeaker)
                SetAnchor(null);
            
            anchorSide = param.AnchorSide;
            
            ClearButtons();
            PopulateAnswers(param);
            RebuildLayouts();
            if(param.AudioClip != null)
                Audio.PlayDialogue(param.AudioClip);
            
            foreach (string id in param.EventsOnStart)
            {
                LdxTrackingManager.Instance.BroadcastTrackingEvent(id);
            }
        }
        
        protected override void SetAnchor(Transform anchor)
        {
            base.SetAnchor(anchor);
            if (arrowPositioner != null)
                arrowPositioner.SetTarget(anchor);
            if (speakerTransform == anchor)
                hasPositioned = true;
            else
                speakerTransform = anchor;
        }

        private void HandleAnyObjectiveCompleted(IObjective objective)
        {
            currentCorrectAnswerInfo = null;
        }

        public void TryForceAnswerDialogue()
        {
            if (currentCorrectAnswerInfo == null)
            {
                return;
            }
            
            ProcessAnswer(currentCorrectAnswerInfo);
        }

        private void ClearButtons()
        {
            foreach (UIButton btn in buttonsAnswerInfoSet.Keys.Where(btn => btn != null))
            {
                btn.OnButtonPressed -= HandleAnswerButtonPressed;
                Destroy(btn.gameObject);
            }

            buttonsAnswerInfoSet.Clear();
        }

        private void PopulateAnswers(DialogParameters parameters)
        {
            DialogEventData.DialogInfo.AnswersContainer answers = parameters.Answers;
            int currentIndex = 0;

            if (answers == null)
            {
                //Deactivate button layout parents so they don't affect the rest of the menu's layout group
                verticalButtonLayoutParent.gameObject.SetActive(false);
                horizontalButtonLayoutParent.gameObject.SetActive(false);
                return;
            }
            
            verticalButtonLayoutParent.gameObject.SetActive(parameters.AnswerButtonLayout == AnswerButtonLayout.Vertical);
            horizontalButtonLayoutParent.gameObject.SetActive(parameters.AnswerButtonLayout == AnswerButtonLayout.Horizontal);

            foreach (DialogEventData.DialogInfo.AnswerInfo answerInfo in answers)
            {
                CreateButton(answerInfo);
                currentIndex++;
            }

            LayoutRebuilder.ForceRebuildLayoutImmediate(verticalButtonLayoutParent);
        }

        private void CreateButton(DialogEventData.DialogInfo.AnswerInfo answerInfo)
        {
            UIButton btn = Instantiate(buttonPrefab, answerButtonLayout == AnswerButtonLayout.Horizontal ? horizontalButtonLayoutParent : verticalButtonLayoutParent);
            btn.Text.SetString(answerInfo.AnswerText);
            btn.OnButtonPressed += HandleAnswerButtonPressed;
            buttonsAnswerInfoSet.Add(btn, answerInfo);
            btn.gameObject.SetActive(true);
        }
        
        private void HandleAnswerButtonPressed(UIButton button)
        {
            ProcessAnswer(buttonsAnswerInfoSet[button]);
        }

        public void ProcessAnswerExternal(DialogEventData.DialogInfo.AnswerInfo answerInfo)
        {
            ProcessAnswer(answerInfo);
        }

        private void ProcessAnswer(DialogEventData.DialogInfo.AnswerInfo answerInfo)
        {
            if (answerInfo.IsCorrectAnswer)
            {
                if (parameters.CloseOnCorrect)
                {
                    UIController.Instance.HideWindow(this);
                }

                foreach (string id in parameters.EventsOnSuccess)
                {
                    LdxTrackingManager.Instance.BroadcastTrackingEvent(id);
                }
            }
            else
            {
                if (parameters.CloseOnWrong)
                {
                    UIController.Instance.HideWindow(this);
                }

                foreach (string id in parameters.EventsOnFail)
                {
                    LdxTrackingManager.Instance.BroadcastTrackingEvent(id);
                }
            }
            OnAnyQuestionAnswered?.Invoke(this, parameters.DialogID, answerInfo.AnswerText, answerInfo.IsCorrectAnswer);
        }

        public async UniTaskVoid DisableDialogButtonsAsync(int duration, int delayMS = 0,
            CancellationTokenSource cts = null)
        {
            if (cts == null)
            {
                await UniTask.Delay(delayMS);
            }
            else
            {
                await UniTask.Delay(delayMS, cancellationToken: cts.Token);
            }

            foreach (UIButton uiButtonBase in buttonsAnswerInfoSet.Keys)
            {
                uiButtonBase.SetInteractable(false);
            }

            if (cts == null)
            {
                await UniTask.Delay(duration);
            }
            else
            {
                await UniTask.Delay(duration, cancellationToken: cts.Token);
            }

            foreach (UIButton uiButtonBase in buttonsAnswerInfoSet.Keys)
            {
                uiButtonBase.SetInteractable(true);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/DialogueWindow.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/EndScreenBlocker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 037f9a52a76e2b34ab95aaa3121c17ea
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.UI;
using UnityEngine;
using Utilities.Blockers;

namespace Ldx.Framework.Systems.UI.NewUISystem
{
    public class EndScreenBlocker : MonoBehaviour, IBlocker
    {
        public event Action<IBlocker, bool> OnBlockChanged;
        public bool IsBlocked { get; private set; }

        private void Start()
        {
            ScenarioEndWindow.OnScenarioEndWindowShowHide += HandleScenarioEndWindowShown;
        }

        private void OnDestroy()
        {
            ScenarioEndWindow.OnScenarioEndWindowShowHide -= HandleScenarioEndWindowShown;
        }

        private void HandleScenarioEndWindowShown(ScenarioEndWindow window, bool state)
        {
            IsBlocked = state;
            OnBlockChanged?.Invoke(this, IsBlocked);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/EndScreenBlocker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/FadeOverrideConfig.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 66033b21fb20454a9cdf72f2fd81aea7
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.UI.Fading;
using UnityEngine;

namespace Ldx.Framework.Systems.UI
{
    [Serializable]
    public class FadeOverrideConfig
    {
        [SerializeField] private float fadeOutTime = ScreenFadeConsts.FADE_OUT_TIME;
        public float FadeOutTime => fadeOutTime;
        
        [SerializeField] private float minInBetweenTime = ScreenFadeConsts.MIN_IN_BETWEEN_TIME;
        public float MinInBetweenTime => minInBetweenTime;
        
        [SerializeField] private float fadeInTime = ScreenFadeConsts.FADE_IN_TIME;
        public float FadeInTime => fadeInTime;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/FadeOverrideConfig.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Fading/ScreenFadeConsts.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4b034a8f012d44e0a5dc8ae51e906f75
# ASMDEF: ldx.framework.runtime.dll
# ---
namespace Ldx.Framework.Systems.UI.Fading
{
    /// <summary>
    /// Consts used in screen fading operations
    /// </summary>
    public static class ScreenFadeConsts
    {
        public const float FADE_OUT_TIME = 1.5f; // Fade out duration
        public const float MIN_IN_BETWEEN_TIME = 2.5f; // Minimum in-between duration
        public const float FADE_IN_TIME = 2.0f; // Fade in duration
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Fading/ScreenFadeConsts.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Fading/ScreenFadeTimer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 68b4b58a2c43447c9f998ee8feb0f268
# ASMDEF: ldx.framework.runtime.dll
# ---
using Cysharp.Threading.Tasks;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Systems.UI.Fading
{
    /// <summary>
    /// Timer used to easily ensure that the in-between while fading the screen
    /// remains for the defined min duration
    /// </summary>
    public class ScreenFadeTimer
    {
        private static float MinInBetweenDuration => UIGlobalSettings.MinInBetweenTime;

        private float TimeAtStart { get; set; }
        private float TimeAtEnd { get; set; }

        private float Duration => Mathf.Max(TimeAtEnd - TimeAtStart, 0);

        private ScreenFadeTimer(){}

        public static ScreenFadeTimer StartNew()
        {
            ScreenFadeTimer timer = new();
            timer.TimeAtStart = Time.unscaledTime;
            return timer;
        }

        public bool EndCheck()
        {
            TimeAtEnd = Time.unscaledTime;
            return Duration < MinInBetweenDuration;
        }

        public async UniTask AwaitRemaining()
        {
            float remaining = Mathf.Max(MinInBetweenDuration - Duration, 0);
            if (remaining <= 0)
            {
                return;
            }
            await UniTask.Delay(remaining.ToMilliseconds());
        }
        
        public static async UniTask AwaitInBetweenDuration(float? durationOverride = null)
        {
            float delay = durationOverride ?? MinInBetweenDuration;
            await UniTask.Delay(delay.ToMilliseconds());
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Fading/ScreenFadeTimer.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Feedback/ProgressCircle.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6ace9a2dad514dc6b4c42aaa2063a330
# ASMDEF: ldx.framework.runtime.dll
# ---
using Cysharp.Threading.Tasks;
using DG.Tweening;
using UnityEngine;
using UnityEngine.UI;

namespace Ldx.Framework.Systems.UI.Feedback
{
    /// <summary>
    /// A progress circle is a feedback UI that can be used to communicate progress
    /// to the user by filling in a circle
    /// </summary>
    public class ProgressCircle : MonoBehaviour
    {
        [SerializeField] private Image fillImage;
        [SerializeField] private CanvasGroup canvasGroup;
        [SerializeField] private float hideDuration;

        private bool isHidingAndDestroying;
        
        /// <summary>
        /// Sets the circle progress
        /// </summary>
        /// <param name="t">A value between 0 (no fill) and 1 (filled)</param>
        public void SetProgress(float t)
        {
            t = Mathf.Clamp01(t);
            fillImage.fillAmount = t;
        }

        /// <summary>
        /// Hides then destroys the progress circle object
        /// </summary>
        public void HideAndDestroy(float? durationOverride = null)
        {
            if (isHidingAndDestroying)
            {
                return;
            }

            isHidingAndDestroying = true;
            hideAndDestroyAsync().Forget();
            
            async UniTaskVoid hideAndDestroyAsync()
            {
                float usedDuration = durationOverride ?? hideDuration;
                await canvasGroup.DOFade(0.0f, usedDuration);
                Destroy(gameObject);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Feedback/ProgressCircle.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Feedback/ProgressCirclesController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0dfd17e5ae4c4e8eae1216b1837de75e
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.UI.Feedback
{
    /// <summary>
    /// A singleton that allows you to place progress circles
    /// </summary>
    [SingletonSpawnable(SingletonSpawnOptions.PlayModeOnly)]
    public class ProgressCirclesController : Singleton<ProgressCirclesController>
    {
        private const string CIRCLE_PREFAB_PATH = "UI/ProgressCircle";

        private ProgressCircle progressCirclePrefab;
        
        protected override void Awake()
        {
            base.Awake();
            if (progressCirclePrefab == null)
            {
                LoadPrefab();
            }
        }

        private void LoadPrefab()
        {
            progressCirclePrefab = Resources.Load<ProgressCircle>(CIRCLE_PREFAB_PATH);
        }

        public ProgressCircle GetNewCircle(Vector3 position, float scaleFactor = 1.0f)
        {
            if (progressCirclePrefab == null)
            {
                LoadPrefab();
            }
            
            ProgressCircle instance = Instantiate(progressCirclePrefab, transform);
            instance.transform.localScale *= scaleFactor;
            instance.transform.position = position;
            return instance;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Feedback/ProgressCirclesController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Font/FontStyleData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b41714d255a6410c8ddd05e91b38a33d
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Linq;
using Ldx.Framework.Utilities.Serializable;
using TMPro;
using UnityEngine;

namespace Ldx.Systems.UI.Font
{
    public enum FontMaterialType
    {
        Standard = 0,
    }
    
    [Serializable]
    public class FontStyleData
    {
        public TMP_FontAsset font;
        public SerializableDictionary<FontMaterialType, Material> fontMaterialTypeMap = new();

        public Material GetMaterial(FontMaterialType type)
        {
            if (!fontMaterialTypeMap.TryGetValue(type, out Material material))
            {
                Debug.LogError($"No material for material type {type} exist. First available will be used");
                material = fontMaterialTypeMap.First().Value;
            }

            return material;
        }

        public bool ContainsMaterial(Material material, out FontMaterialType mat)
        {
            mat = FontMaterialType.Standard;
            
            if (fontMaterialTypeMap.Any(x => x.Value == material))
            {
                mat = fontMaterialTypeMap.First(x => x.Value).Key;
                return true;
            }

            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Font/FontStyleData.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Font/LanguageFonts.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ba01c059603640f9a51fa44a7b424de9
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Linq;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;

namespace Ldx.Systems.UI.Font
{
    public enum FontStyle
    {
        Nohemi = 0,
    }
    
    [Serializable]
    public class LanguageFonts
    {
        public SerializableDictionary<FontStyle, FontStyleData> fontStyleDataMap = new();

        public FontStyleData GetFont(FontStyle style)
        {
            if (fontStyleDataMap.TryGetValue(style, out FontStyleData data))
            {
                return data;
            }

            Debug.LogError($"No FontStyleData exist for font style {style}.");
            return fontStyleDataMap.First().Value;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Font/LanguageFonts.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/HideUIElementWhenOutsideView.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: be94bc01c5676eb449a057940e9492ad
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Player;
using UnityEngine;

namespace Ldx.Framework.Systems.UI
{
    public class HideUIElementWhenOutsideView : MonoBehaviour
    {
        [SerializeField] private Vector2 viewFrustumLimits;
        private UIElement uiElement;

        private void Awake()
        {
            uiElement = GetComponent<UIElement>();
        }

        private void Update()
        {
            if(uiElement == null)
                return;
            
            // Calculate the anchor's position in viewport space
            Vector3 viewportPos =
                PlayerController.Instance.MainCamera.WorldToViewportPoint(uiElement.transform.position);

            // Check if the anchor is outside the frustum threshold
            if (viewportPos.x < viewFrustumLimits.x ||
                viewportPos.x > 1 - viewFrustumLimits.x ||
                viewportPos.y < viewFrustumLimits.y ||
                viewportPos.y > 1 - viewFrustumLimits.y)
            {
                uiElement.HideElement();
            }

        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/HideUIElementWhenOutsideView.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/HighlightProcessors/HighlightOutlineProcessor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b5a4cbf5229f4c41a573e01a40af99da
# ASMDEF: ldx.framework.runtime.dll
# ---
using DG.Tweening;
using HighlightPlus;
using Ldx.Framework.Features.Highlighting;
using Ldx.Framework.Utilities.Misc;
using UnityEngine;

namespace Ldx.Framework.Systems.UI.HighlightProcessors
{
    /// <summary>
    /// Processor for managing the highlighting effects using the Outline class.
    /// This class provides functionality to control the outline width, color, and other properties related to highlighting.
    /// </summary>
    public class HighlightOutlineProcessor : HighlightProcessor<HighlightOutlineProcessorParam>
    {
        private const float WIDTH_MULTIPLIER = 10f;
        
        private Tween widthTween;
        private bool isHighlighterEnabled;
        private HighlightProfile usedHighlightingProfile;

        public override bool IsHighlighted => isHighlighterEnabled;
        private Outline Outline => Parameters.Outline;
        private HighlightProfile HoverProfile => Parameters.HoverProfile;

        public HighlightOutlineProcessor(HighlightOutlineProcessorParam parameters) : base(parameters)
        {
        }

        public override void Initialize()
        {
            Outline.OutlineColor = HoverProfile.outlineColor;
            Outline.OutlineWidth = 0.0f;
        }

        public override void Terminate()
        {
            widthTween?.Kill();
        }

        ///<summary>
        /// Sets the highlighting profile, updating the outline color.
        ///</summary>
        public override void SetHighlightingProfile(HighlightProfile profile)
        {
            usedHighlightingProfile = profile;
            Outline.OutlineColor = profile.outlineColor;
        }

        ///<summary>
        /// Updates the hover state of the highlighter, adjusting the outline width accordingly.
        ///</summary>
        public override void SetHoverHighlightState(bool hovered)
        {
            if (hovered == IsHovered || isHighlighterEnabled)
            {
                return;
            }

            IsHovered = hovered;
            if (IsHovered)
            {
                Outline.OutlineColor = HoverProfile.outlineColor;
            }
            TweenWidth(IsHovered? GetAdjustedWidth(HoverProfile.outlineWidth) : 0.0f);
        }

        ///<summary>
        /// Enables the highlighter, adjusting the outline color and width based on the used highlighting profile.
        ///</summary>
        public override void EnableHighlighter()
        {
            isHighlighterEnabled = true;
            Outline.OutlineColor = usedHighlightingProfile != null ? usedHighlightingProfile.outlineColor : Color.white;
            TweenWidth(GetAdjustedWidth(HighlightingGlobalSettings.CorrectHighlightingProfile.outlineWidth));
        }

        ///<summary>
        /// Resets the highlighter, setting the outline width to zero.
        ///</summary>
        public override void ResetHighlighter()
        {
            IsHovered = false;
            isHighlighterEnabled = false;
            Outline.OutlineWidth = 0.0f;
        }

        ///<summary>
        /// Applies a tween animation to adjust the width of the outline.
        ///</summary>
        private void TweenWidth(float endValue)
        {
            widthTween?.Kill();
            widthTween = DOTween.To(() => Outline.OutlineWidth, (w) => Outline.OutlineWidth = w, endValue,
                HighlightingGlobalSettings.HighlightingFadeDuration);
        }

        ///<summary>
        /// Adjusts the width by multiplying it with a predefined multiplier.
        ///</summary>
        private float GetAdjustedWidth(float width)
        {
            return width * WIDTH_MULTIPLIER;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/HighlightProcessors/HighlightOutlineProcessor.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/HighlightProcessors/HighlightPlusProcessor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b54088c6e9804f9db7fe14335f6395e8
# ASMDEF: ldx.framework.runtime.dll
# ---
using HighlightPlus;
using Ldx.Framework.Features.Highlighting;

namespace Ldx.Framework.Systems.UI.HighlightProcessors
{
    /// <summary>
    /// Processor for highlight plus highlighting
    /// </summary>
    public class HighlightPlusProcessor : HighlightProcessor<HighlightPlusProcessorParam>
    {
        public override bool IsHighlighted => DefaultHighlight.highlighted;
        private HighlightEffect DefaultHighlight => Parameters.DefaultHighlight;
        private HighlightEffect HoverHighlight => Parameters.HoverHighlight;

        public HighlightPlusProcessor(HighlightPlusProcessorParam parameters) : base(parameters)
        {
        }

        public override void Initialize()
        {
        }

        public override void Terminate()
        {
        }

        public override void SetHighlightingProfile(HighlightProfile profile)
        {
            DefaultHighlight.ProfileLoad(profile);
        }

        public override void SetHoverHighlightState(bool hovered)
        {
            HoverHighlight.highlighted = hovered;
        }

        public override void EnableHighlighter()
        {
            DefaultHighlight.fadeInDuration = HighlightingGlobalSettings.HighlightingFadeDuration;
            DefaultHighlight.highlighted = true;
        }

        public override void ResetHighlighter()
        {
            DefaultHighlight.fadeOutDuration = HighlightingGlobalSettings.TimeToHold;
            DefaultHighlight.highlighted = false;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/HighlightProcessors/HighlightPlusProcessor.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/HighlightProcessors/HighlightProcessor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 50b4b80e80a24768834214a2555500ce
# ASMDEF: ldx.framework.runtime.dll
# ---
using HighlightPlus;

namespace Ldx.Framework.Systems.UI.HighlightProcessors
{
    /// <summary>
    /// Base class for highlight operations
    /// </summary>
    public abstract class HighlightProcessor
    {
        public virtual bool IsHighlighted { get; set; }
        public bool IsHovered { get; protected set; }

        public abstract void Initialize();
        public abstract void Terminate();
        public abstract void SetHighlightingProfile(HighlightProfile profile);
        public abstract void SetHoverHighlightState(bool hovered);
        public abstract void EnableHighlighter();
        public abstract void ResetHighlighter();
    }

    public abstract class HighlightProcessor<T> : HighlightProcessor where T : HighlightProcessorParam
    {
        protected T Parameters { get; }
        
        protected HighlightProcessor(T parameters)
        {
            Parameters = parameters;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/HighlightProcessors/HighlightProcessor.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/HighlightProcessors/HighlightProcessorParam.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 344f048d887f4662ac718b6267bfa853
# ASMDEF: ldx.framework.runtime.dll
# ---
using HighlightPlus;
using Ldx.Framework.Utilities.Misc;

namespace Ldx.Framework.Systems.UI.HighlightProcessors
{
    /// <summary>
    /// Parameter class for the highlighting processor 
    /// </summary>
    public abstract class HighlightProcessorParam
    {
    }

    public class HighlightPlusProcessorParam : HighlightProcessorParam
    {
        public HighlightEffect DefaultHighlight { get; }
        public HighlightEffect HoverHighlight { get; }
        
        public HighlightPlusProcessorParam(HighlightEffect defaultHighlight, HighlightEffect hoverHighlight)
        {
            DefaultHighlight = defaultHighlight;
            HoverHighlight = hoverHighlight;
        }
    }

    public class HighlightOutlineProcessorParam : HighlightProcessorParam
    {
        public Outline Outline { get; }
        public HighlightProfile HoverProfile { get; }

        public HighlightOutlineProcessorParam(Outline outline, HighlightProfile hoverProfile)
        {
            Outline = outline;
            HoverProfile = hoverProfile;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/HighlightProcessors/HighlightProcessorParam.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/IAnchorParent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6a578b0da64644499c75287db7bfdf06
# ASMDEF: ldx.framework.runtime.dll
# ---
namespace Ldx.Framework.UI
{
    public interface IAnchorParent
    {
#if UNITY_EDITOR
        void EDITOR_AddAnchor();
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/IAnchorParent.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Input/InputValidators.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7d745fd131c34504b88b8ded7f6da14d
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using UnityEngine;

namespace Systems.UI.NewUISystem.Input
{
    [Serializable]
    public abstract class InputValidator
    {
        public abstract bool Validate(string text);
    }
    
    [Serializable]
    public class InputValidatorsContainer : IEnumerable<InputValidator>
    { 
        [SerializeReference] private List<InputValidator> inputValidators = new();
        
        public IEnumerator<InputValidator> GetEnumerator()
        {
            return inputValidators.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
    
    [Serializable]
    public class EmailInputValidator : InputValidator
    {
        private const string EMAIL_REGEX = @"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$";
        
        public override bool Validate(string text)
        {
            Regex regex = new Regex(EMAIL_REGEX);
            return regex.IsMatch(text);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Input/InputValidators.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Interaction/CanvasHitPointMarker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6fb655d24bd44bae8375f3722d3adb7b
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Systems.UI.Interaction
{
    public class CanvasHitPointMarker : MonoBehaviour
    {
        [SerializeField]
        private SpriteRenderer objectRenderer;

        private void OnValidate()
        {
            if (objectRenderer == null)
            {
                objectRenderer = GetComponent<SpriteRenderer>();
            }
        }

        private void Awake()
        {
            ShowHide(false);
            SetSelected(false);
        }

        /// <summary>
        /// Controls the visibility of the hit marker by enabling or disabling its root GameObject.
        /// </summary>
        /// <param name="show">If true, the GameObject will be set to active. If false, it will be deactivated.</param>
        public void ShowHide(bool show)
        {
            gameObject.SetActive(show);
        }
        
        /// <summary>
        /// Sets the visual state of the hit marker.
        /// </summary>
        /// <param name="isSelected">True for the pressed/selected state, false for the default/released state.</param>
        public void SetSelected(bool isSelected)
        {
            if (objectRenderer == null) return;
            
            Material targetMaterial = isSelected
                ? UIGlobalSettings.OnSelectMarkerMaterial
                : UIGlobalSettings.OnDeselectMarkerMaterial;
            
            if (targetMaterial != null)
            {
                objectRenderer.material = targetMaterial;
            }
        }
        
        /// <summary>
        /// Updates the position and rotation of the hit marker based on a raycast hit.
        /// </summary>
        /// <param name="position">The world position where the ray hit.</param>
        /// <param name="normal">The world normal of the surface that was hit.</param>
        public void UpdatePose(Vector3 position, Vector3 normal)
        {
            transform.position = position;

            // Ensure the normal is not a zero vector to avoid LookRotation errors.
            if (normal != Vector3.zero)
            {
                transform.rotation = Quaternion.LookRotation(normal);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Interaction/CanvasHitPointMarker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Interaction/CanvasPointerLineRenderer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 490a3652973a4cc084406f9733b25ce8
# ASMDEF: ldx.framework.runtime.dll
# ---
using DG.Tweening;
using UnityEngine;

namespace Ldx.Framework.Systems.UI.Interaction
{
    /// <summary>
    /// A self-contained component that manages all visual aspects of the UI pointer's line,
    /// including its material, position, and animated appearance/disappearance using DOTween.
    /// </summary>
    [RequireComponent(typeof(LineRenderer))]
    public class CanvasPointerLineRenderer : MonoBehaviour
    {
        [Header("Animation Settings")]
        [SerializeField] private float animationDuration = 0.2f;
        [SerializeField] private Ease widthEase = Ease.OutQuad;
        [SerializeField] private Ease alphaEase = Ease.OutQuad;
        [SerializeField] private LineRenderer lineRenderer;
        
        private float initialWidth;
        private GradientAlphaKey[] initialAlphaKeys;
        
        private Tweener widthTween;
        private Tweener alphaTween;
        
        private void OnValidate()
        {
            if (lineRenderer == null)
            {
                lineRenderer = GetComponent<LineRenderer>();
            }
        }
        
        private void Awake()
        {
            if (lineRenderer == null)
            {
                lineRenderer = GetComponent<LineRenderer>();
            }
            
            initialWidth = lineRenderer.widthMultiplier;
            if (lineRenderer.colorGradient.alphaKeys.Length > 0)
            {
                initialAlphaKeys = lineRenderer.colorGradient.alphaKeys;
            }
            
            lineRenderer.widthMultiplier = 0f;
            lineRenderer.enabled = false;
            lineRenderer.positionCount = 2;
        }

        private void OnDestroy()
        {
            widthTween?.Kill();
            alphaTween?.Kill();
        }

        /// <summary>
        /// Updates the start and end positions of the line.
        /// </summary>
        public void SetPositions(Vector3 start, Vector3 end)
        {
            lineRenderer.SetPosition(0, start);
            lineRenderer.SetPosition(1, end);
        }
        
        /// <summary>
        /// Sets the selection state of the line by updating its material from UIGlobalSettings.
        /// </summary>
        public void SetSelected(bool isSelected)
        {
            Material targetMaterial = isSelected
                ? UIGlobalSettings.OnSelectLineMaterial
                : UIGlobalSettings.OnDeselectLineMaterial;

            if (targetMaterial != null)
            {
                lineRenderer.material = targetMaterial;
            }
        }
        
        public void ShowHide(bool show)
        {
            if (show)
            {
                Show();
            }
            else
            {
                Hide();
            }
        }

        /// <summary>
        /// Animates the line into view.
        /// </summary>
        private void Show()
        {
            widthTween?.Kill();
            alphaTween?.Kill();
        
            lineRenderer.enabled = true;
            widthTween = DOTween.To(() => lineRenderer.widthMultiplier, x => lineRenderer.widthMultiplier = x, initialWidth, animationDuration)
                .SetEase(widthEase);
            alphaTween = DOTween.To(GetMasterAlpha, SetGradientAlpha, 1f, animationDuration)
                .SetEase(alphaEase);
        }
        
        /// <summary>
        /// Animates the line out of view using DOTween.
        /// </summary>
        private void Hide()
        {
            widthTween?.Kill();
            alphaTween?.Kill();
            
            widthTween = DOTween.To(() => lineRenderer.widthMultiplier, x => lineRenderer.widthMultiplier = x, 0f, animationDuration)
                .SetEase(widthEase)
                .OnComplete(() =>
                {
                    lineRenderer.enabled = false;
                });
            
            alphaTween = DOTween.To(GetMasterAlpha, SetGradientAlpha, 0f, animationDuration)
                .SetEase(alphaEase);
        }

        
        /// <summary>
        /// Gets the current master alpha value from the gradient.
        /// Used as the starting point for a new tween.
        /// </summary>
        private float GetMasterAlpha()
        {
            if (initialAlphaKeys == null || initialAlphaKeys.Length == 0 || initialAlphaKeys[0].alpha == 0) return 0;
            return lineRenderer.colorGradient.alphaKeys[0].alpha / initialAlphaKeys[0].alpha;
        }
        
        /// <summary>
        /// Helper method to apply a master alpha multiplier to the line's color gradient.
        /// </summary>
        private void SetGradientAlpha(float masterAlpha)
        {
            if (initialAlphaKeys == null || initialAlphaKeys.Length == 0) return;
        
            Gradient newGradient = lineRenderer.colorGradient;
            GradientAlphaKey[] newAlphaKeys = new GradientAlphaKey[initialAlphaKeys.Length];

            for (int i = 0; i < initialAlphaKeys.Length; i++)
            {
                newAlphaKeys[i] = new GradientAlphaKey(initialAlphaKeys[i].alpha * masterAlpha, initialAlphaKeys[i].time);
            }
        
            newGradient.alphaKeys = newAlphaKeys;
            lineRenderer.colorGradient = newGradient;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Interaction/CanvasPointerLineRenderer.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Interaction/IUIPointer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9120c530a6934150bf82dd190e18b12e
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Systems.UI.Interaction
{
    /// <summary>
    /// Defines the contract for any object that can act as a UI pointer.
    /// The LdxInputModule interacts with pointers solely through this interface.
    /// </summary>
    public interface IUIPointer
    {
        /// <summary>
        /// Gets a value indicating whether the pointer is currently active and should be processed.
        /// </summary>
        bool IsEnabled { get; }

        /// <summary>
        /// Gets the pointer's root GameObject.
        /// </summary>
        GameObject GetGameObject { get; }
    
        /// <summary>
        /// Called by the input module before raycasting each frame.
        /// This is where the pointer should prepare itself (e.g., position the UI camera).
        /// </summary>
        void Preprocess();

        /// <summary>
        /// Called by the input module to inform the pointer of its index in the module's list.
        /// </summary>
        void SetIndex(int index);
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Interaction/IUIPointer.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Interaction/LdxHandCanvasPointer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ae760cfdac844d55848bd0d3ae97fe8c
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;
using UnityEngine.EventSystems;

namespace Ldx.Framework.Systems.UI.Interaction
{
    /// <summary>
    /// Extends the base Autohand.HandCanvasPointer to provide direct, code-driven control
    /// over visual and audio feedback, bypassing UnityEvents for a cleaner workflow.
    /// <br/><br/>
    /// <b>Note:</b> This component uses a custom editor (LdxHandCanvasPointerEditor) which
    /// cleans up the inspector by hiding inherited fields like the base events and
    /// redundant references.
    /// </summary>
    public class LdxHandCanvasPointer : MonoBehaviour, IUIPointer
    {
        public static event Action<LdxHandCanvasPointer, Vector3, GameObject> OnStartSelect;
        public static event Action<LdxHandCanvasPointer, Vector3, GameObject> OnStopSelect;
        public static event Action<LdxHandCanvasPointer, Vector3, GameObject> OnStartPoint;
        public static event Action<LdxHandCanvasPointer, Vector3, GameObject> OnStopPoint;
        
        private static Camera eventProcessingCamera;
        public static Camera EventProcessingCamera
        {
            get
            {
                if (eventProcessingCamera == null)
                {
                    GameObject camObj = new("Ldx UI Pointer Camera (RUNTIME CREATED)")
                    {
                        transform =
                        {
                            parent = UIController.Instance.transform
                        }
                    }; 
                
                    eventProcessingCamera = camObj.AddComponent<Camera>();
                    eventProcessingCamera.clearFlags = CameraClearFlags.Nothing;
                    eventProcessingCamera.stereoTargetEye = StereoTargetEyeMask.None;
                    eventProcessingCamera.orthographic = true;
                    eventProcessingCamera.orthographicSize = 0.001f;
                    eventProcessingCamera.cullingMask = 0;
                    eventProcessingCamera.nearClipPlane = 0.001f;
                    eventProcessingCamera.farClipPlane = 1;
                    eventProcessingCamera.useOcclusionCulling = false;
                    eventProcessingCamera.enabled = false; // It never renders!
                    
                    Canvas[] canvases = FindObjectsByType<Canvas>(FindObjectsInactive.Include, FindObjectsSortMode.None);
                    foreach (Canvas canvas in canvases)
                    {
                        if (canvas.renderMode == RenderMode.WorldSpace)
                        {
                            canvas.worldCamera = eventProcessingCamera;
                        }
                    }
                }
                return eventProcessingCamera;
            }
        }
        
        [Header("References")]
        [SerializeField] private CanvasHitPointMarker hitPointMarker;
        [SerializeField] private CanvasPointerLineRenderer pointerLine;
        
        [Header("Ray Settings")]
        [SerializeField] private bool useSmoothing = true;
        [SerializeField] private float forwardPointerSmoothing = 25f;
        [Tooltip("Approximately the time it will take for the pointer to reach the target direction. A smaller value is faster and snappier.")]
        [SerializeField] private float smoothTime = 0.05f;
        [SerializeField] private float raycastLength = 8.0f;
        [SerializeField] private bool autoShowTarget = true;
        [SerializeField] private LayerMask UILayer;
  
        public GameObject CurrentTarget { get; private set; }
        public float CurrentDistance { get; private set; }
        public LdxInputModule InputModule => LdxInputModule.Instance;
        public bool IsEnabled => enabled;
        public GameObject GetGameObject => gameObject;
        
        protected int pointerIndex = -1;
        protected Vector3 currentSmoothForward;
        protected bool isHovering;
        private RaycastResult lastRaycastResult;
        private Vector3 currentVelocity = Vector3.zero;

        private void OnValidate()
        {
            if (hitPointMarker == null)
            {
                hitPointMarker = GetComponentInChildren<CanvasHitPointMarker>();
            }

            if (pointerLine == null)
            {
                pointerLine = GetComponentInChildren<CanvasPointerLineRenderer>();
            }
        }
        
        protected virtual void OnEnable()
        {
            if (InputModule == null)
            {
                return;
            }
            
            currentSmoothForward = transform.forward;
            pointerIndex = InputModule.AddPointer(this);
            ShowRay(false);
        }
        
        protected virtual void OnDisable()
        {
            if (InputModule !=null)
            {
                InputModule.RemovePointer(this);
            }
        }
        
        private void OnDestroy()
        {
            if (EventProcessingCamera != null)
            {
                Destroy(EventProcessingCamera.gameObject);
                eventProcessingCamera = null;
            }
        }
        
        /// <summary>
        /// Prepares the pointer for raycasting by positioning the shared UI camera.
        /// Called by LdxInputModule before processing events.
        /// </summary>
        public void Preprocess()
        {
            EventProcessingCamera.transform.position = transform.position;
            EventProcessingCamera.transform.forward = currentSmoothForward;
            EventProcessingCamera.farClipPlane = raycastLength;
        }
        
        private void LateUpdate()
        {
            UpdateSmoothing();
            UpdatePointerVisuals();
        }
        
        /// <summary>
        /// Calculates the adaptive smoothing for the pointer's direction.
        /// Should be called from LateUpdate.
        /// </summary>
        protected virtual void UpdateSmoothing()
        {
            if (useSmoothing)
            {
                currentSmoothForward = Vector3.SmoothDamp(
                    currentSmoothForward,
                    transform.forward,
                    ref currentVelocity,
                    smoothTime
                ).normalized;
            }
            else
            {
                currentSmoothForward = transform.forward;
            }
        }
        
        /// <summary>
        /// Handles all visual updates for the pointer (line, hit marker, hover state).
        /// </summary>
        protected virtual void UpdatePointerVisuals()
        {
            PointerEventData data = InputModule.GetData(pointerIndex);
            if (data == null)
            {
                return;
            }
        
            RaycastResult currentRaycast = data.pointerCurrentRaycast;
            CurrentTarget = data.pointerCurrentRaycast.gameObject;
            CurrentDistance = data.pointerCurrentRaycast.distance;
        
            bool lastHoverState = isHovering;
            isHovering = CurrentTarget != null;
            
            if (isHovering && !lastHoverState)
            {
                OnStartPoint?.Invoke(this, currentRaycast.worldPosition, CurrentTarget);
            }
            else if (!isHovering && lastHoverState)
            {
                OnStopPoint?.Invoke(this, lastRaycastResult.worldPosition, lastRaycastResult.gameObject);
            }

            if (isHovering)
            {
                if (!lastHoverState && autoShowTarget)
                {
                    ShowRay(true);
                }

                Vector3 endPosition = transform.position + currentSmoothForward * CurrentDistance;
                pointerLine?.SetPositions(transform.position, endPosition);
                hitPointMarker?.UpdatePose(endPosition, currentRaycast.worldNormal);
                lastRaycastResult = currentRaycast;
            }
            else if(lastHoverState)
            {
                ShowRay(false);
            }
        }

        public void SetIndex(int index) => pointerIndex = index;

        public virtual void Press()
        {
            if (InputModule == null)
            {
                return;
            }
            
            if (!autoShowTarget && isHovering)
            {
                ShowRay(true);
            }
        
            InputModule.ProcessPress(pointerIndex);
            
            PointerEventData eventData = InputModule.GetData(pointerIndex);
            if (eventData != null && eventData.selectedObject != null)
            {
                pointerLine?.SetSelected(true); 
                hitPointMarker?.SetSelected(true);
                OnStartSelect?.Invoke(this, eventData.pointerCurrentRaycast.worldPosition, eventData.selectedObject);
            }
        }
        
        public virtual void Release()
        {
            PointerEventData data = InputModule.GetData(pointerIndex);
            GameObject pressedObject = data?.selectedObject; 
            
            InputModule.ProcessRelease(pointerIndex);
            
            pointerLine?.SetSelected(false); 
            hitPointMarker?.SetSelected(false);
            
            if (pressedObject != null)
            {
                OnStopSelect?.Invoke(this, data.pointerCurrentRaycast.worldPosition, pressedObject);
            }
        }
        
        protected virtual void ShowRay(bool show)
        {
            hitPointMarker?.ShowHide(show);
            pointerLine?.ShowHide(show);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Interaction/LdxHandCanvasPointer.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Interaction/LdxInputModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7ef9aaaa1c6d47f881fdb320b487efee
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;

namespace Ldx.Framework.Systems.UI.Interaction
{
    /// <summary>
    /// A self-contained, extensible UI input module for VR pointers.
    /// It manages all registered LdxHandCanvasPointers and processes their interactions
    /// with the Unity Event System.
    /// This is a clean rewrite of Autohand.AutoInputModule.
    /// </summary>
    [DefaultExecutionOrder(-100)]
    public class LdxInputModule : BaseInputModule
    {
        private static LdxInputModule instance;

        public static LdxInputModule Instance
        {
            get
            {
                if (instance == null)
                {
                    instance = FindFirstObjectByType<LdxInputModule>();

                    if (instance == null)
                    {
                        instance = new GameObject().AddComponent<LdxInputModule>();
                        instance.transform.parent = UIController.Instance.transform;
                    }
                }
                
                BaseInputModule[] inputModule = FindObjectsByType<BaseInputModule>(FindObjectsSortMode.None);
                if (inputModule.Length > 1)
                {
                    for (int i = inputModule.Length - 1; i >= 0; i--)
                    {
                        if (!inputModule[i].gameObject.GetComponent<LdxInputModule>())
                        {
                            Destroy(inputModule[i]);
                        }
                    }
                }

                EventSystem[] system = FindObjectsByType<EventSystem>(FindObjectsSortMode.None);
                if (system.Length > 1)
                {
                    for (int i = system.Length - 1; i >= 0; i--)
                    {
                        if (!system[i].gameObject.GetComponent<LdxInputModule>())
                        {
                            Destroy(system[i]);
                        }
                    }
                }

                return instance;
            }
        }

        protected List<IUIPointer> pointers = new List<IUIPointer>();
        protected PointerEventData[] eventDatas;
        
        public int AddPointer(IUIPointer pointer)
        {
            if (!pointers.Contains(pointer))
            {
                pointers.Add(pointer);
                eventDatas = new PointerEventData[pointers.Count];
                for (int i = 0; i < eventDatas.Length; i++)
                {
                    eventDatas[i] = new PointerEventData(eventSystem)
                    {
                        delta = Vector2.zero,
                        position = new Vector2(Screen.width / 2f, Screen.height / 2f)
                    };
                }
            }
            
            return pointers.IndexOf(pointer);
        }
        
        public void RemovePointer(IUIPointer pointer)
        {
            int pIndex = pointers.IndexOf(pointer);
            if (pIndex < 0) return;

            ProcessRelease(pIndex);
            ProcessExit(pIndex);

            if (pointers.Contains(pointer))
            {
                pointers.Remove(pointer);
            }
        
            foreach (IUIPointer p in pointers)
            {
                p.SetIndex(pointers.IndexOf(p));
            }

            eventDatas = new PointerEventData[pointers.Count];
            for (int i = 0; i < eventDatas.Length; i++)
            {
                eventDatas[i] = new PointerEventData(eventSystem);
            }
        }
        
        public override void Process()
        {
            for (int i = 0; i < pointers.Count; i++)
            {
                IUIPointer pointer = pointers[i];
                if (pointer == null || !pointer.GetGameObject.activeInHierarchy || !pointer.IsEnabled)
                {
                    continue;
                }

                pointer.Preprocess();
                eventSystem.RaycastAll(eventDatas[i], m_RaycastResultCache);
                eventDatas[i].pointerCurrentRaycast = FindFirstRaycast(m_RaycastResultCache);
                HandlePointerExitAndEnter(eventDatas[i], eventDatas[i].pointerCurrentRaycast.gameObject);
                ExecuteEvents.Execute(eventDatas[i].pointerDrag, eventDatas[i], ExecuteEvents.dragHandler);
            }
        }
        
        public void ProcessPress(int index)
        {
            PointerEventData data = eventDatas[index];
            data.pointerPressRaycast = data.pointerCurrentRaycast;
            data.pointerPress = ExecuteEvents.GetEventHandler<IPointerClickHandler>(data.pointerPressRaycast.gameObject);
            data.pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(data.pointerPressRaycast.gameObject);
            ExecuteEvents.Execute(data.pointerPress, data, ExecuteEvents.pointerDownHandler);
            ExecuteEvents.Execute(data.pointerDrag, data, ExecuteEvents.beginDragHandler);
        }
        
        public void ProcessRelease(int index)
        {
            PointerEventData data = eventDatas[index];
            GameObject currentGameObject = data.pointerCurrentRaycast.gameObject;
            GameObject pointerReleaseHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(currentGameObject);
            if (data.pointerPress == pointerReleaseHandler)
            {
                ExecuteEvents.Execute(data.pointerPress, data, ExecuteEvents.pointerClickHandler);
            }
            ExecuteEvents.Execute(data.pointerPress, data, ExecuteEvents.pointerUpHandler);
            ExecuteEvents.Execute(data.pointerDrag, data, ExecuteEvents.endDragHandler);
            data.pointerPress = null;
            data.pointerDrag = null;
        }
        
        public void ProcessExit(int index)
        {
            PointerEventData data = eventDatas[index];
            GameObject currentGameObject = data.pointerCurrentRaycast.gameObject;
            ExecuteEvents.Execute(currentGameObject, data, ExecuteEvents.pointerExitHandler);
        }
        
        public PointerEventData GetData(int index)
        {
            if (index < 0 || eventDatas == null || index >= eventDatas.Length) return null;
            return eventDatas[index];
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Interaction/LdxInputModule.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/InventoryHandler.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1482a44b3c2321549be3a2d3fbb88a8e
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Autohand;
using Ldx.Framework.Features.Visual.Tweening;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.AutoHand;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.Teleportation;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Animation;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.InputUtilities;
using UnityEngine;

namespace Ldx.Framework.Systems.UI
{
    public class InventoryHandler : Singleton<InventoryHandler>
    {
        [SerializeField] private Vector3 offsetFromPlayerHead;
        [SerializeField] private float wallHitOffset = 0.125f;
        [SerializeField] private LayerMask wallRaycastLayerMask;
        [SerializeField] private DoTweenAnimation openAnimation;
        [SerializeField] private DoTweenAnimation closeAnimation;
        
        [SerializeField] private ParentingDispenserPoint[] dispenserPoints;
        [SerializeField] private PlacePoint[] placePoints;

        [SerializeField] private ControllerButtonInput buttonInputForToggle;
        
        [SerializeField] [SoundReference] private string inventoryOpenSound;
        [SerializeField] [SoundReference] private string inventoryCloseSound;
        
        [SerializeField][IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string onShowEvent;
        [SerializeField][IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string onHideEvent;
        [SerializeField][IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string onItemGrabEvent;
        [SerializeField][IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private string onItemReleaseEvent;
        
        private Vector3 originalPos;
        private Transform playerCamera;

        private readonly HashSet<Grabbable> grabbedUnreleasedObjects = new();
        
        public bool IsOpen { get; private set; }

        protected override void Awake()
        {
            originalPos = transform.position;
            PlayerTeleporter.OnTeleportationStarted += HandleTeleportStarted;
            if (buttonInputForToggle != null)
                buttonInputForToggle.OnButtonStateChange += HandleControllerButtonInputChanged;
            ParentingDispenserPoint.OnAnyItemGrabbed += HandleAnyItemGrabbed;
        }

        private void OnDestroy()
        {
            PlayerTeleporter.OnTeleportationStarted -= HandleTeleportStarted;
            if (buttonInputForToggle != null)
                buttonInputForToggle.OnButtonStateChange += HandleControllerButtonInputChanged;
            ParentingDispenserPoint.OnAnyItemGrabbed -= HandleAnyItemGrabbed;

            foreach (Grabbable grabbable in grabbedUnreleasedObjects)
            {
                grabbable.OnReleaseEvent -= HandleGrabbedItemReleased;
            }
        }

        public void ToggleInventory()
        {
            if (!IsOpen)
            {
                OpenInventory();
            }
            else
            {
                CloseInventory();
            }
        }

        public void OpenInventory()
        {
            if(IsOpen)
                return;
            IsOpen = true;
            
            PositionInventory();

            if (closeAnimation)
            {
                closeAnimation.OnFinishedPlaying -= HandleCloseAnimationFinished;
                closeAnimation.Stop();
            }

            if (openAnimation)
            {
                openAnimation.OnFinishedPlaying += HandleOpenAnimationFinished;
                openAnimation.Play(true);
            }
            
            Audio.PlayOneShot(inventoryOpenSound, transform);
            LdxTrackingManager.Instance.BroadcastTrackingEvent(onShowEvent);
        }

        public void CloseInventory()
        {
            if (!IsOpen)
                return;
            IsOpen = false;
            if (openAnimation)
            {
                openAnimation.Stop();
                openAnimation.OnFinishedPlaying -= HandleOpenAnimationFinished;
            }

            if (closeAnimation)
            {
                closeAnimation.OnFinishedPlaying += HandleCloseAnimationFinished;
                closeAnimation.Play(true);
            }
                
            foreach (ParentingDispenserPoint dispenserPoint in dispenserPoints)
            {
                dispenserPoint.SetCurrentDispensedGrabbableState(false);
            }

            foreach (PlacePoint placePoint in placePoints)
            {
                placePoint.enabled = false;
                Grabbable placedObject = placePoint.GetPlacedObject();
                if(placedObject != null) 
                    placedObject.enabled = false;
            }
            
            Audio.PlayOneShot(inventoryCloseSound, transform);
            LdxTrackingManager.Instance.BroadcastTrackingEvent(onHideEvent);
        }

        private void HandleCloseAnimationFinished(IAnimationPlayble animation)
        {
            transform.position = originalPos;
        }

        private void HandleOpenAnimationFinished(IAnimationPlayble animation)
        {
            foreach (ParentingDispenserPoint dispenserPoint in dispenserPoints)
            {
                dispenserPoint.TryDispense();
                dispenserPoint.SetCurrentDispensedGrabbableState(true);
            }
            foreach (PlacePoint placePoint in placePoints)
            {
                placePoint.enabled = true;
                Grabbable placedObject = placePoint.GetPlacedObject();
                if(placedObject != null) 
                    placedObject.enabled = true;
            }
        }

        private void HandleControllerButtonInputChanged(bool state)
        {
            if(state)
                ToggleInventory();
        }

        private void PositionInventory()
        {
            if (playerCamera == null)
                playerCamera = PlayerController.Instance.MainCamera.transform;

            Quaternion basis = CalulcateRotationBasis(playerCamera.forward);
            // Apply the offset in that reference frame
            Vector3 desiredPosition = playerCamera.position + basis * offsetFromPlayerHead;
            
            //If hit a wall before reaching the desired location
            Vector3 camToPositionNormalized = (desiredPosition - playerCamera.position).normalized;
            Vector3 linecastEndPosition = desiredPosition + camToPositionNormalized * wallHitOffset;
            Debug.DrawLine(playerCamera.position, linecastEndPosition, Color.red, 3f);
            if (Physics.Linecast(playerCamera.position, linecastEndPosition, out RaycastHit hit, wallRaycastLayerMask))
            {
                desiredPosition = hit.point + hit.normal * wallHitOffset;
                transform.rotation = CalulcateRotationBasis(camToPositionNormalized);
            }
            else
            {
                transform.rotation = basis;
            }
            
            transform.position = desiredPosition;

            Quaternion CalulcateRotationBasis(Vector3 forwardVector)
            {
                // Negate the Y component
                Vector3 yNegated = new Vector3(forwardVector.x, 0, forwardVector.z);

                // Fallback if the vector is too small
                if (yNegated.sqrMagnitude < 1e-6f)
                    yNegated = forwardVector;

                // Build a rotation looking along the y-negated vector
                Vector3 forward = yNegated.normalized;
                Vector3 up = Vector3.up;
                if (Mathf.Abs(Vector3.Dot(forward, up)) > 0.99f)
                    up = Vector3.right;

                return Quaternion.LookRotation(forward, up);
            }
        }

        private void HandleTeleportStarted(PlayerTeleporter teleporter)
        {
            CloseInventory();
        }
        
        private void HandleAnyItemGrabbed(ParentingDispenserPoint point, Grabbable grabbable)
        {
            AddGrabbedItem(grabbable);
        }

        private void AddGrabbedItem(Grabbable grabbable)
        {
            grabbedUnreleasedObjects.Add(grabbable);
            grabbable.OnReleaseEvent += HandleGrabbedItemReleased;
            LdxTrackingManager.Instance.BroadcastTrackingEvent(onItemGrabEvent);
        }

        private void HandleGrabbedItemReleased(Hand hand, Grabbable grabbable)
        {
            grabbedUnreleasedObjects.Remove(grabbable);
            grabbable.OnReleaseEvent -= HandleGrabbedItemReleased;
            LdxTrackingManager.Instance.BroadcastTrackingEvent(onItemReleaseEvent);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/InventoryHandler.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/KeyboardWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 29ae09e31e9b40e8b6eba3fbbe48a685
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using Microsoft.MixedReality.Toolkit.Experimental.UI;
using Systems.UI.NewUISystem.Input;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

namespace Ldx.Framework.Systems.UI
{
    public class KeyboardWindow : UIElement
    {
        public event Action<KeyboardWindow, string> OnSubmitted; 
        
        [Space]
        [SerializeField]
        private NonNativeKeyboard nonNativeKeyboard;
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] 
        private string eventToBroadcastOnSubmit;

        [SerializeField]
        private Button enterButton; 
        [SerializeField]
        private Image enterButtonImage;
        [SerializeField] 
        private Color invalidButtonColor;
        [InheritedClassContainer(typeof(InputValidator), suffixToRemove:"Validator")]
        [SerializeField] private InputValidatorsContainer validators = new();

        [SerializeField] 
        private bool useSkipButton;

        [ShowIf("useSkipButton", Op.Equals, true)]
        [SerializeField]
        private Button skipButton;
        
        private Color? validButtonColor;
        
        public bool CanSubmit { get; private set; }
        
        private void OnEnable()
        {
            if (validButtonColor == null)
            {
                validButtonColor = enterButtonImage.color;
            }
            nonNativeKeyboard.OnTextUpdated += HandleTextUpdated;
            nonNativeKeyboard.OnTextSubmitted += HandleTextSubmitted;
            nonNativeKeyboard.OnKeyboardFunctionKeyPressed += HandleKeyboardFunctionKeyPressed;

            if (useSkipButton)
            {
                skipButton.onClick.AddListener(HandleSkipButtonClicked);
            }
            
            SetCanSubmit(IsInputValid(nonNativeKeyboard.InputField.text));
        }

        protected override void OnDisable()
        {
            base.OnDisable();
            nonNativeKeyboard.OnTextUpdated -= HandleTextUpdated;
            nonNativeKeyboard.OnTextSubmitted -= HandleTextSubmitted;
            nonNativeKeyboard.OnKeyboardFunctionKeyPressed -= HandleKeyboardFunctionKeyPressed;
            if (useSkipButton)
            {
                skipButton.onClick.RemoveListener(HandleSkipButtonClicked);
            }
        }
        
        private void HandleTextUpdated(string input)
        {
            bool valid = IsInputValid(input);
            SetCanSubmit(valid);
            // For the caret (cursor)
            EventSystem.current.SetSelectedGameObject(nonNativeKeyboard.InputField.gameObject, null);
        }

        private void HandleTextSubmitted(object sender, EventArgs e)
        {
            if (!CanSubmit)
            {
                return;
            }
            string text = nonNativeKeyboard.InputField.text;
            OnSubmitted?.Invoke(this, text);
            BroadcastCompletion();
        }

        public void BroadcastCompletion()
        {
            LdxTrackingManager.Instance.BroadcastTrackingEvent(eventToBroadcastOnSubmit);
        }
        
        private void HandleKeyboardFunctionKeyPressed(KeyboardKeyFunc keyboardKey)
        {
            // For the caret (cursor)
            EventSystem.current.SetSelectedGameObject(nonNativeKeyboard.InputField.gameObject, null);
        }

        private void SetCanSubmit(bool canSubmit)
        {
            CanSubmit = canSubmit;
            enterButtonImage.color = canSubmit ? validButtonColor.Value : invalidButtonColor;
            enterButton.interactable = canSubmit;
        }
        
        private void HandleSkipButtonClicked()
        {
            BroadcastCompletion();
        }
        
        private bool IsInputValid(string text)
        {
            foreach (InputValidator validator in validators)
            {
                if (!validator.Validate(text))
                {
                    return false;
                }
            }
            return true;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/KeyboardWindow.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/LdxObjectInfoController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 81a38e9b6e1817d468dfdec07bac27f6
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

namespace Ldx.Framework.Systems.UI
{
    public class LdxObjectInfoController : MonoBehaviour
    {
        public static LdxObjectInfoController instance;

        public GameObject windowUI;
        public Text titleUI;
        public Text descriptionUI;
        public GameObject optionPrefab;
        [HideInInspector] public List<GameObject> currentAnswers = new List<GameObject>();


        private void Awake()
        {
            DestroyClones();

            instance = this;
        }

        private void DestroyClones()
        {
            LdxObjectInfoController[] otherInstances = FindObjectsByType<LdxObjectInfoController>(FindObjectsSortMode.None);

            foreach (LdxObjectInfoController ins in otherInstances)
            {
                if (ins != this)
                    Destroy(this);
            }
        }

        public void CreateAnswers(List<string> incorrect, string correct)
        {
            //Create incorrect answers and add them
            foreach (string answer in incorrect)
            {
                currentAnswers.Add(optionPrefab);
            }

            //Create and set options for correct
            currentAnswers.Add(optionPrefab);
        }

        public void ClearAnswers()
        {
            currentAnswers.Clear();
        }

    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/LdxObjectInfoController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/LocalizedElement.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 145336926b634209b0a7eddafd84c500
# ASMDEF: ldx.framework.runtime.dll
# ---
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Localization;
using UnityEngine;

namespace Systems.LdxLocalization
{
    /// <summary>
    /// Abstract base class for any UI element that requires localization.
    /// It subscribes to language changes and updates accordingly.
    /// </summary>
    public abstract class LocalizedElement : MonoBehaviour
    {
        protected virtual void OnEnable()
        {
            RefreshLocalizationElement().Forget();
            if (LocalizationModel.UseLocalization)
            {
                LocalizationModel.OnLanguageChanged += HandleLanguageChanged;
            }
        }

        protected virtual void OnDisable()
        {
            if (LocalizationModel.UseLocalization)
            {
                LocalizationModel.OnLanguageChanged -= HandleLanguageChanged;
            }
        }

        /// <summary>
        /// Handles the language change event and refreshes the localization of the element.
        /// </summary>
        /// <param name="language">The new language that has been set.</param>
        private void HandleLanguageChanged(Language language)
        {
            RefreshLocalizationElement().Forget();
        }
        
        /// <summary>
        /// Forces a refresh of the localization element if specified, or refreshes if the object is active and enabled.
        /// </summary>
        /// <param name="forceToUpdate">Forces the update of localization regardless of the object's state.</param>
        protected void RefreshAfterUpdate(bool forceToUpdate = false)
        {
            if (forceToUpdate || (gameObject.activeInHierarchy && enabled))
            {
                RefreshLocalizationElement().Forget();
            }
        }

#pragma warning disable CS1998
        /// <summary>
        /// Abstract method to refresh the element's localized content.
        /// Implementations should update the element to reflect the current language.
        /// </summary>
        protected virtual async UniTask RefreshLocalizationElement() { }
#pragma warning restore CS1998
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/LocalizedElement.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/LocalizedTextUGUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d7cef68bc4d34b40be0814e2c0b98016
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.UI;
using Ldx.Framework.Utilities.Logging;
using Systems.LdxLocalization;
using TMPro;
using UnityEngine;
using Debug = Ldx.Framework.Utilities.Logging.Debug;
using FontStyle = Ldx.Systems.UI.Font.FontStyle;

namespace Systems.UI
{
    /// <summary>
    /// Component for localizing TextMeshProUGUI elements. Supports formatting and highlighting.
    /// </summary>
    public class LocalizedTextUGUI : LocalizedElement, ILocalizable
    {
        [SerializeField]
        private FontStyle font = FontStyle.Nohemi;
        
        [SerializeField] 
        protected TMP_Text tmpText;
        public TMP_Text TMPText => tmpText;

        [Header("Localization")]
        [SerializeField][LocalizationKey]
        private string localizedText;
        public string LocalizedText => localizedText;

        [SerializeField]
        private bool useFormatting;
        [SerializeField]
        private bool localizeFormattingValues;
        [SerializeField]
        private bool useHighlighting;
        [SerializeField]
        private string[] formattingValues;
        
        public enum AnimationType
        {
            None,
            TypewrittenEffect
        }

        [Space]
        [Header("Animation")]
        [SerializeField]
        private AnimationType animationType = AnimationType.None;
        [SerializeField]
        private float typewritingDelay = 0.1f;
        
        protected virtual void OnValidate()
        {
            if (tmpText == null)
            {
                tmpText = GetComponent<TMP_Text>();
            }
        }

        public void SetFontStyle(FontStyle fontStyle)
        {
            if (font == fontStyle)
            {
                return;
            }
            
            font = fontStyle;
            RefreshFontAppearance();
        }

        #region Key Values
        
        /// <summary>
        /// Sets the LocalizationString for this element.
        /// </summary>
        /// <param name="newString">The new LocalizationString to set.</param>
        /// <param name="refreshImmediately">Whether to refresh the text immediately.</param>
        /// <param name="forceToUpdate">Whether to force the update regardless of the object's state.</param>
        public void SetString(string newString, bool refreshImmediately = true, bool forceToUpdate = false)
        {
            if (newString == null)
            {
                return;
            }
            localizedText = newString;

            if (refreshImmediately)
            {
                RefreshAfterUpdate(forceToUpdate);
            }
        }

        /// <summary>
        /// Sets a single formatting value for the localized text.
        /// </summary>
        /// <param name="newString">The LocalizationString to use.</param>
        /// <param name="value">The formatting value.</param>
        /// <param name="forceToUpdate">Whether to force the update regardless of the object's state.</param>
        public void SetStringValue(string newString, string value, bool forceToUpdate = false)
        {
            SetStringValues(newString, new List<string>(){value}, forceToUpdate);
        }

        /// <summary>
        /// Sets multiple formatting values for the localized text.
        /// </summary>
        /// <param name="newString">The LocalizationString to use.</param>
        /// <param name="values">The list of formatting values.</param>
        /// <param name="forceToUpdate">Whether to force the update regardless of the object's state.</param>
        public void SetStringValues(string newString, List<string> values, bool forceToUpdate = false)
        {
            SetString(newString, false);
            SetValues(values, forceToUpdate);
        }
        
        /// <summary>
        /// Sets a single formatting value for the localized text.
        /// </summary>
        /// <param name="value">The formatting value.</param>
        /// <param name="forceToUpdate">Whether to force the update regardless of the object's state.</param>
        public void SetValue(string value, bool forceToUpdate = false)
        {
            SetValues(new List<string>(){value}, forceToUpdate);
        }

        /// <summary>
        /// Sets multiple formatting values for the localized text.
        /// </summary>
        /// <param name="values">The list of formatting values.</param>
        /// <param name="forceToUpdate">Whether to force the update regardless of the object's state.</param>
        public void SetValues(List<string> values, bool forceToUpdate = false)
        {
            formattingValues = values.ToArray();
            RefreshAfterUpdate(forceToUpdate);
        }

        /// <summary>
        /// Clears all formatting values for the localized text.
        /// </summary>
        public void ClearValues()
        {
            formattingValues = null;
            RefreshAfterUpdate();
        }

        public void SetTextColor(Color color)
        {
            tmpText.color = color;
        }

        #endregion

        /// <summary>
        /// Refreshes the element with the current localization settings.
        /// </summary>
        protected override async UniTask RefreshLocalizationElement()
        {
            await base.RefreshLocalizationElement();
            string localizedString = LocalizationModel.UseLocalization ? LocalizationModel.GetTextString(localizedText) : NoLocalizationFrameworkTable.GetValueOrDefault(localizedText);
            
            // If localized string is null or empty, exit function
            // (Note that if the string was formatted, it needs to be checked
            // again in case formatting turned it into an empty string).
            if (string.IsNullOrEmpty(localizedString))
            {
                Debug.Log($"RefreshLocalizationElement empty {gameObject.name}", gameObject);
                if (LocalizationModel.UseLocalization)
                {
                    Debug.Log(LogCategory.Localization, LogVerbosity.Verbose, () => $"No localized string found for key: {localizedText}", this);
                }
               
                localizedString = localizedText;
            }

            // Apply formatting if enabled.
            if (useFormatting && formattingValues != null)
            {
                string[] localizedFormattingValues = new string[formattingValues.Length];

                for (int i = 0; i < formattingValues.Length; i++)
                {
                    localizedFormattingValues[i] = formattingValues[i];
                    if (localizeFormattingValues)
                    {
                        localizedFormattingValues[i] = LocalizationModel.UseLocalization ? 
                            LocalizationModel.GetTextString(localizedFormattingValues[i]) : 
                            NoLocalizationFrameworkTable.GetValueOrDefault(localizedFormattingValues[i]);
                    }
                }

                try
                {
                    localizedString = string.Format(localizedString, localizedFormattingValues);
                }
                catch (Exception e)
                {
                    Debug.LogWarning($"Localization exception: {e}");
                }
            }

            // Apply highlighting if enabled.
            if (useHighlighting)
            {
                localizedString = UIGlobalSettings.GetHighlightedWordString(localizedString);
            }

            localizedString = AutoSanitizeString(localizedString);
            
            // Set the TextMeshProUGUI object's text to the localized string
            await ShowText(localizedString);
        }

        private async Task ShowText(string localizedString)
        {
            switch (animationType)
            {
                case AnimationType.None:
                    tmpText.text = localizedString;
                    break;
                case AnimationType.TypewrittenEffect:
                    tmpText.text = string.Empty;
                    foreach (char c in localizedString)
                    {
                        tmpText.text += c;
                        await UniTask.Delay(TimeSpan.FromSeconds(typewritingDelay));
                    }
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        private string AutoSanitizeString(string localizedString)
        {
            return localizedString.Replace("\r", "");
        }

        protected void RefreshFontAppearance()
        {
            tmpText.font = UIGlobalSettings.GetFont(font);
            Debug.Log("setting font to: " + tmpText.font.name);
            tmpText.material = UIGlobalSettings.GetFontMaterial(font);
        }
        
        public void ProcessLocalizationKeys(LocalizationTable table)
        {
            table.ProcessLocalizationKey(ref localizedText);
        }

        public async UniTask FadeText(float alpha, float duration = 0.5f)
        {
            await tmpText.DOFade(alpha, duration);
        }
        
        public Tween FadeTextTween(float alpha, float duration = 0.5f)
        {
            return tmpText.DOFade(alpha, duration);
        }
        
        public async UniTask SetColor(Color color, float duration = 0.5f)
        {
            await tmpText.DOColor(color, duration);
        }
        
        public Tween GetColorTween(Color color, float duration = 0.5f)
        {
            return tmpText.DOColor(color, duration);
        }
        
#if UNITY_EDITOR
        [ContextMenu("Generate localization text ID")]
        public void EDITOR_GenerateID()
        {
            LocalizationTable table = LocalizationUtilities.EDITOR_GetCurrentScenarioTable();
            ProcessLocalizationKeys(table);
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/LocalizedTextUGUI.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/MainMenu/HandCameraController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 41bbd1fe62ae7b145a6ece9dff1c0410
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Systems.UI.MainMenu
{
    /// <summary>
    /// Controller for showing/hiding the camera that only renders the Hands. Used when in menu to render hands over UI.
    /// </summary>
    public class HandCameraController : MonoBehaviour
    {
        private void Awake()
        {
            UIController.OnTransparentOverlayOpenClosed += HandleMainMenuStateChange;
            gameObject.SetActive(false);
        }

        private void OnDestroy()
        {
            UIController.OnTransparentOverlayOpenClosed -= HandleMainMenuStateChange;
        }

        private void HandleMainMenuStateChange(UIController uiController, bool state)
        {
            gameObject.SetActive(state);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/MainMenu/HandCameraController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/MainMenu/MainMenuBlocker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 874a6e19457c2484086e4d2f033e57cb
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;
using Utilities.Blockers;

namespace Ldx.Framework.Systems.UI.MainMenu
{
    public class MainMenuBlocker : MonoBehaviour, IBlocker
    {
        public event Action<IBlocker, bool> OnBlockChanged;
        public bool IsBlocked { get; private set;}

        private void Awake()
        {
            UIController.OnMainMenuOpenClosed += HandleMainMenuShownHidden;
        }

        private void OnDestroy()
        {
            UIController.OnMainMenuOpenClosed -= HandleMainMenuShownHidden;
        }

        private void HandleMainMenuShownHidden(UIController uiController, bool state)
        {
            IsBlocked = state;
            OnBlockChanged?.Invoke(this, IsBlocked);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/MainMenu/MainMenuBlocker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/AutoRestart/AutoRestartModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a68d636f1f7581a498c788ac6d74092d
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Systems.UI;
using Ldx.Framework.Systems.UI.Modules;
using UnityEngine;

namespace Ldx.Framework.UI.Modules.AutoRestart
{
    /// <summary>
    /// Detects if the headset has gone into sleep mode. If that occurs, triggers a restart when coming back.
    /// </summary>
    public class AutoRestartModule : MonoBehaviour, IUIModule
    {
        private bool canPause;

        private void OnApplicationPause(bool pausingStarted)
        {
            if (!UIGlobalSettings.EnableAutoRestartModule || pausingStarted || !canPause)
            {
                return;
            }
            
            UIController.Instance.ShowModuleAutoRestartWindow();
        }

        public void ScenarioStarted(ScenarioManager scenarioManager, ScenarioDataType scenarioDataType)
        {
            canPause = true;
        }

        public void UnloadingScenarioOrLobby(ScenarioManager scenarioManager)
        {
            canPause = false;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/AutoRestart/AutoRestartModule.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Inspection/InspectionProgressUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 47661c3ca41c4de38bc2d0317b69173b
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Features.Inspection;
using Ldx.Framework.Systems.Player;
using UnityEngine;
using UnityEngine.UI;

namespace Ldx.Framework.Systems.UI.Modules.Inspection
{
    /// <summary>
    /// Progress UI used by InspectionFeature. Inherits UIElement for unified show/hide & positioning.
    /// Provides a linear bar and a radial ring; the ring can follow a world point.
    /// </summary>
    public class InspectionProgressUI : UIElement
    {
         private const float DEFAULT_PADDING_PX = 16f;

        [Header("Progress Visuals")]
        [SerializeField] private Image lineFill;        
        [SerializeField] private Image ringFill;   

        [Header("Behavior")]
        [SerializeField] private float screenClampPadding = DEFAULT_PADDING_PX;

        private Camera uiCamera;
        private RectTransform canvasRect;
        private InspectableObject target;

        protected override bool ShouldScaleOnFade => false;
        protected override Vector3 OriginalScale => Vector3.one;

        protected override void OnValidate()
        {
            base.OnValidate();
            if (canvasRect == null && Canvas != null)
            {
                canvasRect = Canvas.transform as RectTransform;
            }
        }

        override protected void Start()
        {
            base.Start();
            uiCamera = PlayerController.Instance.MainCamera;
        }

        private void LateUpdate()
        {
            UpdatePositioning(uiCamera.transform);
        }

        public void SetProgress(float t)
        {
            float clamped = Mathf.Clamp01(t);
            if (lineFill != null) lineFill.fillAmount = clamped;
            if (ringFill != null) ringFill.fillAmount = clamped;
        }
        
        public void SetTarget(InspectableObject inspectableObject)
        {
            target = inspectableObject;
            if (target == null)
            {
                return;
            }
            
            transform.position = target.transform.position + target.ProgressUIOffset;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Inspection/InspectionProgressUI.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Inspection/InspectionUIModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6241329a844f44659d38d28c434c0eb6
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Threading;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Features.Inspection;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Systems.UI.Modules.Inspection
{
    public class InspectionUIModule : MonoBehaviour, IUIModule
    {
        private const float HIDE_DELAY = 0.5f;
        
        [SerializeField] private InspectionProgressUI progressIU;

        private InspectableObject current;
        private CancellationTokenSource cts;
    
        private void Awake()
        {
            InspectionFeature.OnInspectionStarted += HandleInspectionStarted;
            InspectionFeature.OnInspectionProgressUpdated += HandleInspectionProgressUpdated;
            InspectionFeature.OnInspectionCompleted += HandleInspectionCompleted;
            HideProgressUI();
        }
        
        private void OnDestroy()
        {
            InspectionFeature.OnInspectionStarted -= HandleInspectionStarted;
            InspectionFeature.OnInspectionProgressUpdated -= HandleInspectionProgressUpdated;
            InspectionFeature.OnInspectionCompleted -= HandleInspectionCompleted;
        }
        
        public void ScenarioStarted(ScenarioManager scenarioManager, ScenarioDataType scenarioDataType)
        {
            HideProgressUI();
        }

        public void UnloadingScenarioOrLobby(ScenarioManager scenarioManager)
        {
            HideProgressUI();
        }
        
        private void HandleInspectionStarted(InspectionFeature feature, InspectableObject inspectableObject)
        {
            if (inspectableObject == null)
            {
                return;
            }

            BeginInspection(inspectableObject);
        }

        private void BeginInspection(InspectableObject inspectableObject)
        {
            current = inspectableObject;
            ShowProgressUI(current);
        }
        
        private void HandleInspectionProgressUpdated(InspectionFeature feature, InspectableObject inspectableObject, float progress)
        {
            if (current != inspectableObject)
            {
                BeginInspection(inspectableObject);
            }
            
            progressIU.SetProgress(progress);
        }

        private void HandleInspectionCompleted(InspectionFeature feature, InspectableObject inspectableObject, bool isSuccessful)
        {
            if (current != inspectableObject)
            {
                BeginInspection(inspectableObject);
            }
            
            cts?.SafeCancelAndDispose();

            if (isSuccessful)
            {
                progressIU.SetProgress(1);
                cts = new CancellationTokenSource();
                HideAfterDelay(cts.Token).Forget();
            }
            else
            {
                HideProgressUI();
            }
        }

        private async UniTaskVoid HideAfterDelay(CancellationToken token)
        {
            await UniTask.Delay(HIDE_DELAY.ToMilliseconds(), cancellationToken: token);

            if (token.IsCancellationRequested)
            {
                return;
            }
            
            HideProgressUI();
        }

        private void ShowProgressUI(InspectableObject inspectableObject)
        {
            cts?.SafeCancelAndDispose();
            progressIU.SetTarget(inspectableObject);
            progressIU.SetProgress(0);
            progressIU.ShowElement();
        }

        private void HideProgressUI()
        {
            progressIU.HideElement();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Inspection/InspectionUIModule.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/IUIModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ed910b8025614f1c980767dc2d4dadd8
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;

namespace Ldx.Framework.Systems.UI.Modules
{
    /// <summary>
    /// Classes that implement this interface can register as a player module
    /// </summary>
    public interface IUIModule
    {
        /// <summary>
        /// Called when a scenario starts.
        /// </summary>
        /// <param name="scenarioManager">The scenario manager.</param>
        /// <param name="scenarioDataType">Scenario data type.</param>
        void ScenarioStarted(ScenarioManager scenarioManager, ScenarioDataType scenarioDataType);
        
        /// <summary>
        /// Called when unloading a scenario or lobby.
        /// </summary>
        /// <param name="scenarioManager">The scenario manager.</param>
        void UnloadingScenarioOrLobby(ScenarioManager scenarioManager);
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/IUIModule.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Tooltip/DisplayTooltips.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e4a31e877f451ca46942a1ddb558dc7c
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Systems.UI.Modules.Tooltip 
{
    /// <summary>
    /// This can be attached to an object and given a list of child objects and will display a tooltip for those
    /// objects when they are in the centre of the screen.
    /// </summary>
    public class DisplayTooltips : MonoBehaviour
    {
        private enum Method
        {
            Centermost,
            All
        }
        
        [Header("Events:")]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string activateTooltips;
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string deactivateTooltips;
        
        [Space]
        [SerializeField] private ObjectTooltip[] tooltipsToDisplay;
        [SerializeField] private Method displayMethod = Method.Centermost;
        [SerializeField] private float updateInterval = 0.1f;
        [SerializeField] private bool activateTooltipsOnEnable;
        [SerializeField] private float maxDisplayDistance = 2; // User sets distance, square is automatically calculated
        
        private float maxDisplaySqrDistance;

        private bool tooltipsActive;
        private readonly List<ObjectTooltip> currentTooltipsDisplayed = new();

        private void OnEnable()
        {
            maxDisplaySqrDistance = maxDisplayDistance * maxDisplayDistance;
            OnEnableAsync().Forget();
        }

        private async UniTaskVoid OnEnableAsync()
        {
            await UniTask.WaitUntil(()=> LdxTrackingManager.IsValid);
            LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
            if (activateTooltipsOnEnable)
            {
                ActivateTooltipChecks();
            }
        }

        private void OnDisable()
        {
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }

            HideCurrentTooltipsIfAny(true);
        }

        private void HandleTrackingEvent(string eventId)
        {
            if (eventId == activateTooltips)
            {
                ActivateTooltipChecks();
            }

            if (eventId == deactivateTooltips)
            {
                Deactivate();
            }
        }

        public void Activate()
        {
            ActivateTooltipChecks();
        }

        public void Deactivate()
        {
            HideCurrentTooltipsIfAny(true);
        }

        /// <summary>
        /// Sets the tooltips to active and begins checking which tooltip is nearest to the centre.
        /// </summary>
        private void ActivateTooltipChecks()
        {
            foreach (ObjectTooltip tooltip in tooltipsToDisplay)
            {
                tooltip.AssignReferences();
            }
            tooltipsActive = true;
            CheckTooltipToDisplay().Forget();
        }
        
        /// <summary>
        /// Checks which tooltip object is approximately closest to the centre of the player's view and displays
        /// that object's tooltip.
        /// </summary>
        private async UniTaskVoid CheckTooltipToDisplay()
        {
            while (tooltipsActive)
            {
                await UniTask.Delay(updateInterval.ToMilliseconds());

                if (!tooltipsActive)
                {
                    break;
                }
                
                switch (displayMethod)
                {
                    case Method.Centermost:
                        ObjectTooltip centremostTooltipObject =
                            PlayerController.Instance.MainCamera.GetCentremostObject(
                                tooltipsToDisplay,
                                tooltip => tooltip.IsVisible &&
                                           IsDistanceWithinSqrMax(tooltip.Transform.position));

                        if (centremostTooltipObject != null && !currentTooltipsDisplayed.Contains(centremostTooltipObject))
                        {
                            HideCurrentTooltipsIfAny(false);
                            currentTooltipsDisplayed.Add(centremostTooltipObject);
                            centremostTooltipObject.ShowTooltip();
                        }
                        break;
                    case Method.All:
                        foreach (ObjectTooltip tooltip in tooltipsToDisplay)
                        {
                            bool isVisible = tooltip.IsVisible && IsDistanceWithinSqrMax(tooltip.Transform.position);

                            if (isVisible && !currentTooltipsDisplayed.Contains(tooltip))
                            {
                                currentTooltipsDisplayed.Add(tooltip);
                                tooltip.ShowTooltip();
                            }
                            else if (!isVisible && currentTooltipsDisplayed.Contains(tooltip))
                            {
                                tooltip.HideTooltip();
                                currentTooltipsDisplayed.Remove(tooltip);
                            }
                        }
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }

            HideCurrentTooltipsIfAny(true);
        }

        /// <summary>
        /// Hides the currently displayed tooltip if any is active, and optionally deactivated checking to display
        /// a tooltip.
        /// </summary>
        /// <param name="deactivateOnHide">Deactivates checks for tooltips if true.</param>
        private void HideCurrentTooltipsIfAny(bool deactivateOnHide)
        {
            if (deactivateOnHide)
            {
                tooltipsActive = false;
                foreach (ObjectTooltip tooltip in tooltipsToDisplay)
                {
                    tooltip.HideTooltip();
                }
            }

            foreach (ObjectTooltip tooltip in currentTooltipsDisplayed)
            {
                tooltip.HideTooltip();
            }

            currentTooltipsDisplayed.Clear();
        }

        /// <summary>
        /// Checks that the object to display the tooltip for is within the maximum distance set by the user, using the
        /// square magnitude.
        /// </summary>
        /// <param name="objectPosition">The position of the tooltip object to display.</param>
        /// <returns>True if the object is within the max sqr distance, false if further from camera.</returns>
        private bool IsDistanceWithinSqrMax(Vector3 objectPosition)
        {
            return PlayerController.Instance.MainCamera.transform.position.GetSqrDistance(objectPosition) <=
                maxDisplaySqrDistance;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Tooltip/DisplayTooltips.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Tooltip/ObjectTooltip.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d3caf8ae00a46c44b96a26aa18b8d115
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.UI.Modules.Tooltip 
{
    /// <summary>
    /// Tooltip that's attachable to an object and can be shown/hidden programatically.
    /// </summary>
    public class ObjectTooltip : MonoBehaviour, ILocalizable
    {
        private enum Target
        {
            Self,
            ObjectiveTransform
        }

        [SerializeField] private Target target = Target.Self;
        
        [ShowIf(nameof(target), Op.Equals, Target.ObjectiveTransform)]
        [SerializeField]  [IDSelection(LdxIdSettings.IdType.Transform)]
        private string transformTarget;
        
        [SerializeField] private TooltipAnchorStyle anchorStyle = TooltipAnchorStyle.Right;
        private enum OffsetType
        {
            Transform,
            Manual,
            Default
        }

        [Space]
        [SerializeField] private OffsetType offsetType = OffsetType.Transform;
        
        [Tooltip("Works as an offset, not an exact position.")]
        [ShowIf(nameof(offsetType), Op.Equals, OffsetType.Transform)]
        [SerializeField] private Transform tooltipDisplayPoint;
        public Transform TooltipDisplayPoint => tooltipDisplayPoint;

        [Tooltip("Not an exact position, but an offset relative to the object in relation to the player's orientation.")]
        [SerializeField] 
        [ShowIf(nameof(offsetType), Op.Equals, OffsetType.Manual)]
        private Vector3 manualCustomOffset = new(0, 0.5f, 0);
        public Vector3 ManualCustomOffset => manualCustomOffset;
        
        [SerializeField] 
        private Vector3 overrideTooltipScale = new(1, 1, 1);
        
        [SerializeField] 
        private bool alignTooltipVertically = false;
        
        [Header("Text to be displayed when tooltip is shown:")]
        [LocalizationKey]
        [SerializeField] private string tooltipText;
        public string TooltipText => tooltipText;
        
        [SerializeField] [LocalizationKey]
        private string tooltipDescription;
        public string TooltipDescription => tooltipDescription;
        
        // Accessed by other scripts to detect if tooltip is rendered by the camera.
        [HideInInspector]
        [SerializeField] private Renderer tooltipObjectRenderer;
        public Renderer TooltipObjectRenderer => tooltipObjectRenderer;
        
        private Vector3? tooltipOffset;
        private bool isShowingTooltip;
        public bool IsShowingTooltip => isShowingTooltip;
        
        private Transform targetTransform;

        private Transform cachedTransform;
        public Transform Transform => cachedTransform ? cachedTransform : cachedTransform = GetTransform();

        public bool IsVisible =>
            tooltipObjectRenderer ? tooltipObjectRenderer.isVisible : Transform.gameObject.activeInHierarchy;

        public void ProcessLocalizationKeys(LocalizationTable table)
        {
            table.ProcessLocalizationKey(ref tooltipText);
            table.ProcessLocalizationKey(ref tooltipDescription);
        }
        
        private void OnValidate()
        {
            AssignReferences();
        }

        public void AssignReferences()
        {
            if (tooltipObjectRenderer == null)
            {
                Transform currentTransform = GetTransform();
                tooltipObjectRenderer = currentTransform.GetComponentInChildren<Renderer>();

                if (Application.isPlaying)
                {
                    transform.position = currentTransform.position;
                }
            }
        }

        private void Start()
        {
            AssignReferences();
        }

        private void OnEnable()
        {
            tooltipOffset = GetTooltipOffset();
        }

        /// <summary>
        /// Displays the attached tooltip.
        /// </summary>
        public void ShowTooltip(float? autoDisableTime = null)
        {
            if (isShowingTooltip)
            {
                return;
            }
            
            isShowingTooltip = true;
            TooltipService.ShowTooltip(Transform, tooltipText, autoDisableTime, tooltipOffset, overrideTooltipScale, alignTooltipVertically, tooltipDescription, anchorStyle);
        }
        
        /// <summary>
        /// Hides the attached tooltip.
        /// </summary>
        public void HideTooltip()
        {
            if (!isShowingTooltip)
            {
                return;
            }

            isShowingTooltip = false;
            TooltipService.HideTooltip(Transform);
        }

        /// <summary>
        /// Gets the offset to set when displaying the tooltip or return null to keep the system default offset
        /// as set in the tooltip's default parameters by the tooltip system.
        /// </summary>
        /// <returns>Returns the offset value based on the current configuration of the properties.</returns>
        private Vector3? GetTooltipOffset()
        {
            switch (offsetType)
            {
                case OffsetType.Default:
                    return null;
                case OffsetType.Manual:
                    return manualCustomOffset;
                case OffsetType.Transform:
                    return getPointFromTransform();
            }

            return null;
            
            Vector3 getPointFromTransform()
            {
                Vector3 inversePoint = GetTransform().InverseTransformPoint(tooltipDisplayPoint.position);
                return new Vector3(
                    -inversePoint.x, // Invert x to mirror position relative to player.
                    inversePoint.y,
                    -inversePoint.z); // Invert z to bring closer to player rather than further
            }    
        }

        private Transform GetTransform()
        {
            if (target == Target.Self || string.IsNullOrEmpty(transformTarget))
            {
                return transform;
            }

            if (targetTransform == null && LdxReferenceIDTracker.IsValid)
            {
                targetTransform = LdxReferenceIDTracker.Instance.GetTransform(transformTarget);
            }

            return targetTransform != null ? targetTransform : transform;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Tooltip/ObjectTooltip.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Tooltip/TooltipController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: fa18472dbc4549d58a78eb8316a915c3
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;

namespace Ldx.Framework.Systems.UI.Modules.Tooltip
{
    /// <summary>
    /// Manages the display and behavior of world tooltips.
    /// </summary>
    public class TooltipController : MonoBehaviour, IUIModule
    {
        [SerializeField] private SerializableDictionary<TooltipAnchorStyle, WorldTooltip> anchorStyleWorldTooltipSet = new();
        [SerializeField] private int initialPoolSize = 2;

        private readonly Dictionary<TooltipAnchorStyle, Queue<WorldTooltip>> tooltipPools = new();
        private readonly Dictionary<Transform, WorldTooltip> activeTooltipsByTargetMap = new();

        private void Awake()
        {
            WorldTooltip.OnAnyTooltipShowAnimationCompleted += HandleAnyTooltipShowAnimationCompleted;
            WorldTooltip.OnAnyTooltipHideAnimationCompleted += HandleAnyTooltipHideAnimationCompleted;
            TooltipService.OnShowTooltip += HandleShowTooltip;
            TooltipService.OnHideTooltip += HandleHideTooltip;
            TooltipService.OnHideAllTooltips += HandleHideAllTooltip;
        }

        private void Start()
        {
            InitializePool();
        }

        private void OnDestroy()
        {
            WorldTooltip.OnAnyTooltipShowAnimationCompleted -= HandleAnyTooltipShowAnimationCompleted;
            WorldTooltip.OnAnyTooltipHideAnimationCompleted -= HandleAnyTooltipHideAnimationCompleted;
            TooltipService.OnShowTooltip -= HandleShowTooltip;
            TooltipService.OnHideTooltip -= HandleHideTooltip;
            TooltipService.OnHideAllTooltips -= HandleHideAllTooltip;

            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
            }
        }

        #region IUIModule Implementation

        /// <summary>
        /// Called when a scenario starts.
        /// </summary>
        /// <param name="scenarioManager">The scenario manager.</param>
        /// <param name="_">Scenario data type.</param>
        public void ScenarioStarted(ScenarioManager scenarioManager, ScenarioDataType _)
        {
            LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
        }

        /// <summary>
        /// Called when unloading a scenario or lobby.
        /// </summary>
        /// <param name="scenarioManager">The scenario manager.</param>
        public void UnloadingScenarioOrLobby(ScenarioManager scenarioManager)
        {
            HideAllTooltips();
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
            }
        }

        #endregion

        #region Initialization

        /// <summary>
        /// Initializes the tooltip pool.
        /// </summary>
        private void InitializePool()
        {
            foreach ((TooltipAnchorStyle anchorStyle, WorldTooltip prefab) in anchorStyleWorldTooltipSet)
            {
                Queue<WorldTooltip> pool = new();
                for (int i = 0; i < initialPoolSize; i++)
                {
                    WorldTooltip tooltip = Instantiate(prefab, transform);
                    tooltip.gameObject.SetActive(false);
                    pool.Enqueue(tooltip);
                }
                tooltipPools.Add(anchorStyle, pool);
            }
        }

        #endregion

        #region Event Handlers

        /// <summary>
        /// Handles objective events related to tooltips.
        /// </summary>
        /// <param name="objective">The objective.</param>
        /// <param name="eventData">The event data.</param>
        private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            if (eventData is ShowWorldTooltipEventData showData)
            {
                foreach (TooltipParameters tooltipParameters in showData.TooltipsToShow)
                {
                    ShowTooltip(tooltipParameters);
                }
            }
            else if (eventData is HideWorldTooltipEventData hideData)
            {
                if (hideData.HideAll)
                {
                    HideAllTooltips();
                }
                else
                {
                    foreach (string tooltipTarget in hideData.TooltipTargetsToHide)
                    {
                        HideTooltipByTarget(tooltipTarget);
                    }
                }
            }
        }

        /// <summary>
        /// Handles the event to show a tooltip.
        /// </summary>
        /// <param name="parameters">The tooltip parameters.</param>
        private void HandleShowTooltip(TooltipParameters parameters)
        {
            ShowTooltip(parameters);
        }

        /// <summary>
        /// Handles the event to hide a tooltip.
        /// </summary>
        /// <param name="target">The target identifier.</param>
        /// <param name="targetTransform">The target transform.</param>
        private void HandleHideTooltip(string target, Transform targetTransform)
        {
            if (targetTransform)
            {
                HideTooltipByTarget(targetTransform);
            }
            else
            {
                HideTooltipByTarget(target);
            }
        }

        /// <summary>
        /// Handles the event to hide all tooltips.
        /// </summary>
        private void HandleHideAllTooltip()
        {
            HideAllTooltips();
        }

        /// <summary>
        /// Handles the completion of any tooltip show animation.
        /// </summary>
        /// <param name="tooltip">The tooltip.</param>
        private void HandleAnyTooltipShowAnimationCompleted(WorldTooltip tooltip) { }

        /// <summary>
        /// Handles the completion of any tooltip hide animation.
        /// </summary>
        /// <param name="tooltip">The tooltip.</param>
        private void HandleAnyTooltipHideAnimationCompleted(WorldTooltip tooltip)
        {
            if (tooltip.TargetTransform != null)
            {
                activeTooltipsByTargetMap.Remove(tooltip.TargetTransform);
            }
            
            TooltipAnchorStyle anchorStyle = tooltip.AnchorStyle;
            if (tooltipPools.TryGetValue(anchorStyle, out Queue<WorldTooltip> pool))
            {
                pool.Enqueue(tooltip);
            }
        }

        #endregion

        #region Tooltip Management

        /// <summary>
        /// Shows a tooltip based on the provided parameters.
        /// </summary>
        /// <param name="parameters">The tooltip parameters.</param>
        /// <returns>The displayed tooltip.</returns>
        private WorldTooltip ShowTooltip(TooltipParameters parameters)
        {
            Transform target = parameters.TargetTransform;
            if (!target)
            {
                target = LdxReferenceIDTracker.Instance.GetTransform(parameters.TooltipTarget);
            }
          
            if (activeTooltipsByTargetMap.TryGetValue(target, out WorldTooltip showTooltip))
            {
                return showTooltip;
            }
            
            // Get tooltip from pool and show it using the parameters
            WorldTooltip tooltip = GetTooltipFromPool(parameters.AnchorStyle);
            tooltip.ShowTooltip(parameters);
            
            activeTooltipsByTargetMap.Add(target, tooltip);
            return tooltip;
        }
        
        /// <summary>
        /// Shows a tooltip at the specified target with the given text by passing the parameters directly.
        /// </summary>
        /// <param name="target">The target transform.</param>
        /// <param name="text">The tooltip text.</param>
        /// <param name="autoDisableTime">Optional auto-disable time.</param>
        /// <returns>The displayed tooltip.</returns>
        private WorldTooltip ShowTooltip(Transform target, string text, float? autoDisableTime = null)
        {
            TooltipParameters parameters = new(target, text, autoDisableTime);
            return ShowTooltip(parameters);
        }

        /// <summary>
        /// Retrieves a tooltip from the pool or creates a new one based on the given anchor style.
        /// </summary>
        /// <param name="anchorStyle">The tooltip anchor style.</param>
        /// <returns>A world tooltip instance.</returns>
        private WorldTooltip GetTooltipFromPool(TooltipAnchorStyle anchorStyle)
        {
            if (tooltipPools.TryGetValue(anchorStyle, out Queue<WorldTooltip> pool))
            {
                if (pool.Count > 0)
                {
                    WorldTooltip tooltip = pool.Dequeue();
                    tooltip.gameObject.SetActive(true);
                    return tooltip;
                }

                // No pooled tooltip available, so instantiate a new one.
                WorldTooltip newTooltip = Instantiate(anchorStyleWorldTooltipSet[anchorStyle], transform);
                return newTooltip;
            }

            Debug.LogError("No tooltip pool found for anchor style: " + anchorStyle);
            return null;
        }

        /// <summary>
        /// Hides the specified tooltip.
        /// </summary>
        /// <param name="tooltip">The tooltip to hide.</param>
        private void HideTooltip(WorldTooltip tooltip)
        {
            tooltip.HideTooltip();
        }

        /// <summary>
        /// Hides the tooltip associated with the given target identifier.
        /// </summary>
        /// <param name="target">The target identifier.</param>
        private void HideTooltipByTarget(string target)
        {
            if (LdxReferenceIDTracker.Instance.TryGetTransform(target, out Transform targetTransform))
            {
                HideTooltipByTarget(targetTransform);
            }
        }

        /// <summary>
        /// Hides the tooltip associated with the given target transform.
        /// </summary>
        /// <param name="targetTransform">The target transform.</param>
        private void HideTooltipByTarget(Transform targetTransform)
        {
            if (activeTooltipsByTargetMap.TryGetValue(targetTransform, out WorldTooltip tooltip))
            {
                HideTooltip(tooltip);
            }
        }

        /// <summary>
        /// Hides all active tooltips.
        /// </summary>
        private void HideAllTooltips()
        {
            foreach (WorldTooltip tooltip in activeTooltipsByTargetMap.Values)
            {
                HideTooltip(tooltip);
            }
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Tooltip/TooltipController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Tooltip/TooltipService.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2fc3794879f04684ae3b6212c840856b
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Systems.UI.Modules.Tooltip
{
    /// <summary>
    /// Provides static events and methods to show and hide tooltips globally.
    /// </summary>
    public static class TooltipService
    {
        /// Note: Only the TooltipController should subscribe to these events.
        /// Do not subscribe to these events from outside the tooltip system.
        public static event Action<TooltipParameters> OnShowTooltip;
        public static event Action<string, Transform> OnHideTooltip;
        public static event Action OnHideAllTooltips;

        /// <summary>
        /// Triggers the event to show a tooltip for a target identified by a string.
        /// </summary>
        /// <param name="target">The identifier of the target.</param>
        /// <param name="text">The text to display in the tooltip.</param>
        /// <param name="autoDisableTime">Optional time after which the tooltip should auto-hide.</param>
        /// <param name="customOffset">Optional offset from the target to display the tooltip.</param>
        /// <param name="customScale">Optional scale of the tooltip. Default is Vector3.One</param>
        /// <param name="alignVertically">If true Y rotation will always be 0</param>
        /// <param name="description">Optional tooltip description</param>
        /// <param name="style">The tooltip anchor style.</param>
        public static void ShowTooltip(string target, string text, float? autoDisableTime = null, 
            Vector3? customOffset = null, Vector3? customScale = null, bool alignVertically = false, 
            string description = "", TooltipAnchorStyle style = TooltipAnchorStyle.Right)
        {
            OnShowTooltip?.Invoke(new TooltipParameters(target, text, autoDisableTime, customOffset, customScale, alignVertically, description, style));
        }

        /// <summary>
        /// Triggers the event to show a tooltip for a target transform.
        /// </summary>
        /// <param name="target">The transform of the target object.</param>
        /// <param name="text">The text to display in the tooltip.</param>
        /// <param name="autoDisableTime">Optional time after which the tooltip should auto-hide.</param>
        /// <param name="customOffset">Optional offset from the target to display the tooltip.</param>
        /// <param name="customScale">Optional scale of the tooltip. Default is Vector3.One</param>
        /// <param name="alignVertically">If true Y rotation will always be 0</param>
        /// <param name="description">Optional tooltip description</param>
        /// <param name="style">The tooltip anchor style.</param>
        public static void ShowTooltip(Transform target, string text, float? autoDisableTime = null, 
            Vector3? customOffset = null, Vector3? customScale = null, bool alignVertically = false, 
            string description = "", TooltipAnchorStyle style = TooltipAnchorStyle.Right)
        {
            OnShowTooltip?.Invoke(new TooltipParameters(target, text, autoDisableTime, customOffset, customScale, alignVertically, description, style));
        }

        /// <summary>
        /// Triggers the event to hide a tooltip for a target identified by a string.
        /// </summary>
        /// <param name="target">The identifier of the target.</param>
        public static void HideTooltip(string target)
        {
            OnHideTooltip?.Invoke(target, null);
        }
        
        /// <summary>
        /// Triggers the event to hide a tooltip for a target transform.
        /// </summary>
        /// <param name="target">The transform of the target object.</param>
        public static void HideTooltip(Transform target)
        {
            OnHideTooltip?.Invoke(string.Empty, target);
        }

        /// <summary>
        /// Triggers the event to hide all active tooltips.
        /// </summary>
        public static void HideAllTooltips()
        {
            OnHideAllTooltips?.Invoke();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Tooltip/TooltipService.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Tooltip/WorldTooltip.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9a6ff1f3d44d43df96d7f62c40f75534
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using Systems.UI;
using UnityEngine;
#if UNITY_EDITOR
#endif

namespace Ldx.Framework.Systems.UI.Modules.Tooltip
{
    /// <summary>
    /// Represents the parameters required to display a tooltip.
    /// </summary>
    [Serializable]
    public class TooltipParameters
    {
        [SerializeField] [IDSelection(LdxIdSettings.IdType.Transform)]
        private string tooltipTarget;
        public string TooltipTarget => tooltipTarget;
        
        [SerializeField] [LocalizationKey]
        private string tooltipText;
        public string TooltipText => tooltipText;
        
        [SerializeField] [LocalizationKey]
        private string tooltipDescription;
        public string TooltipDescription => tooltipDescription;
        
        [SerializeField] 
        private TooltipAnchorStyle anchorStyle = TooltipAnchorStyle.Right;
        public TooltipAnchorStyle AnchorStyle => anchorStyle;

        [SerializeField] 
        private bool autoDisable;
        public bool AutoDisable => autoDisable;

        [SerializeField] 
        private float autoDisableTime;
        public float AutoDisableTime => autoDisableTime;

        [SerializeField] 
        private bool overrideOffset;
        public bool OverrideOffset => overrideOffset;

        [SerializeField] 
        private Vector3 offsetToOverride;
        public Vector3 OffsetToOverride => offsetToOverride;
        
        [SerializeField]
        private Vector3 scaleToOverride;
        public Vector3 ScaleToOverride => scaleToOverride;

        [SerializeField]
        private bool alignVertically;
        public bool AlignVertically => alignVertically;
        
        [SerializeField] [HideInInspector]
        private Transform targetTransform;
        public Transform TargetTransform => targetTransform;

        public TooltipParameters(TooltipParameters copy)
        {
            tooltipTarget = copy.tooltipTarget;
            tooltipText = copy.tooltipText;
            tooltipDescription = copy.tooltipDescription;
            anchorStyle = copy.anchorStyle;
            autoDisable = copy.autoDisable;
            autoDisableTime = copy.autoDisableTime;
            overrideOffset = copy.overrideOffset;
            offsetToOverride = copy.offsetToOverride;
            scaleToOverride = copy.scaleToOverride;
            targetTransform = copy.targetTransform;
            alignVertically = copy.alignVertically;
        }

        public TooltipParameters(string target, string text, float? disableTime,
            Vector3? customOffset = null, Vector3? customScale = null, bool align = false, string description = "", 
            TooltipAnchorStyle style = TooltipAnchorStyle.Right)
        {
            tooltipTarget = target;
            tooltipText = text;
            tooltipDescription = description;
            anchorStyle = style;
            autoDisable = disableTime.HasValue;
            autoDisableTime = autoDisable ? disableTime.Value : 0;
            overrideOffset = customOffset.HasValue;
            offsetToOverride = customOffset ?? Vector3.zero;
            scaleToOverride = customScale ?? Vector3.one;
            alignVertically = align;
        }

        public TooltipParameters(Transform target, string text, float? disableTime,
            Vector3? customOffset = null, Vector3? customScale = null, bool align = false, string description = "",
            TooltipAnchorStyle style = TooltipAnchorStyle.Right)
        {
            tooltipTarget = string.Empty;
            targetTransform = target;
            tooltipText = text;
            tooltipDescription = description;
            anchorStyle = style;
            autoDisable = disableTime.HasValue;
            autoDisableTime = autoDisable ? disableTime.Value : 0;
            overrideOffset = customOffset.HasValue;
            offsetToOverride = customOffset ?? Vector3.zero;
            scaleToOverride = customScale ?? Vector3.one;
            alignVertically = align;
        }
    }

    public enum TooltipAnchorStyle
    {
        Right,
        Left
    }

    /// <summary>
    /// Represents a tooltip displayed in the world space.
    /// </summary>
    public class WorldTooltip : MonoBehaviour
    {
        private readonly static int Hide = Animator.StringToHash("Hide");
        
        private const float MINIMUM_DISPLAY_TIME = 2f;
        
        public static event Action<WorldTooltip> OnAnyTooltipShowAnimationCompleted; 
        public static event Action<WorldTooltip> OnAnyTooltipHideAnimationCompleted;

        [SerializeField] private TooltipAnchorStyle anchorStyle;
        public TooltipAnchorStyle AnchorStyle => anchorStyle;
        
        [SerializeField] private Transform tooltipCanvasesParent;
        
        [Space]
        [Header("Tooltip line")]
        [SerializeField] private LineRenderer tooltipLine;
        [SerializeField] private Transform lineStartPoint;
        [SerializeField] private Transform lineEndPoint;
        
        [Space]
        [Header("Main section")]
        [SerializeField] private RectTransform titleCanvas;
        [SerializeField] private LocalizedTextUGUI tooltipText;
        
        [Space]
        [Header("Info section")]
        [SerializeField] private Transform infoCanvas;
        [SerializeField] private LocalizedTextUGUI tooltipDescription;
        
        [Space]
        [Header("Positioning")]
        [SerializeField] private float followSpeed = 5f;
        [SerializeField] private Vector3 offset;
        [SerializeField] private bool alignVertically;
        
        [Space]
        [Header("SFX")]
        [SerializeField] private float soundEffectDelay = 0.25f;

        [Space]
        [Header("Appearance")]
        [SerializeField] private Animator animator;
        
        public Transform TargetTransform { get; private set; }
        private Transform mainCamera;
        private Transform MainCamera => mainCamera ??= PlayerController.Instance.MainCamera.transform;
        private Vector3 currentOffset;
        private float? displayedTimeStart;

        private void Awake()
        {
            tooltipLine.positionCount = 2;
            currentOffset = offset;
        }
        
        private void LateUpdate()
        {
            if (!TargetTransform)
            {
                return;
            }

            UpdatePositions();
        }

        #region Display and Control
        
        /// <summary>
        /// Initializes the tooltip with the target transform and text.
        /// </summary>
        /// <param name="parameters">The tooltip parameters object containing the current tooltip's data.</param>
        public void ShowTooltip(TooltipParameters parameters)
        {
            TargetTransform = GetTargetTransform(parameters);
            transform.position = TargetTransform.position;
            currentOffset = parameters.OverrideOffset ? parameters.OffsetToOverride : offset;
            alignVertically = parameters.AlignVertically;
            transform.localScale = parameters.ScaleToOverride;
            
            AssignTooltipTexts(parameters);
            UpdatePositions(true);
            ToggleGameObject(true);
            PlayAudioAsync(AudioGlobalSettings.SfxWorldTooltipShow, soundEffectDelay).Forget();

            if (parameters.AutoDisable)
            {
                HideAfterDelay(parameters.AutoDisableTime).Forget();
            }
        }

        /// <summary>
        /// Assigns the text values for the tooltip's title and description based on the provided parameters.
        /// </summary>
        /// <param name="parameters">The tooltip parameters containing the text and description.</param>
        private void AssignTooltipTexts(TooltipParameters parameters)
        {
            tooltipText.SetString(parameters.TooltipText);
            tooltipDescription.SetString(parameters.TooltipDescription);
            infoCanvas.gameObject.SetActive(!string.IsNullOrEmpty(parameters.TooltipDescription));
        }
        
        /// <summary>
        /// Hides the tooltip.
        /// </summary>
        public void HideTooltip()
        {
            HideTooltipAsync().Forget();
        }

        /// <summary>
        /// Hides the tooltip after it's been displayed for the minimum amount of time.
        /// </summary>
        private async UniTaskVoid HideTooltipAsync()
        {
            await checkMinimumDisplayTime();

            PlayAudioAsync(AudioGlobalSettings.SfxWorldTooltipHide, soundEffectDelay).Forget();
            
            animator.SetTrigger(Hide);
            return;

            async UniTask checkMinimumDisplayTime()
            {
                await UniTask.WaitUntil(() => displayedTimeStart.HasValue);
                float currentTimeDifference = Time.time - displayedTimeStart.Value;
                await UniTask.Delay(Mathf.Max(0,(MINIMUM_DISPLAY_TIME - currentTimeDifference).ToMilliseconds()));
            }
        }
        
        /// <summary>
        /// Hides the tooltip after a specified delay.
        /// </summary>
        /// <param name="delay">The delay in seconds.</param>
        private async UniTask HideAfterDelay(float delay)
        {
            await UniTask.Delay(delay.ToMilliseconds());
            HideTooltip();
        }
        
        #endregion
    
        #region Positioning and Movement

        /// <summary>
        /// Updates the positions of the tooltip elements.
        /// </summary>
        /// <param name="instant">If true, positions are updated instantly.</param>
        private void UpdatePositions(bool instant = false)
        {
            transform.position = TargetTransform.position;
            UpdateLineRenderer();
            UpdateCanvasTransform(instant);
        }
        
        /// <summary>
        /// Updates the positions of the LineRenderer.
        /// </summary>
        private void UpdateLineRenderer()
        {
            tooltipLine.SetPosition(0, lineStartPoint.position);
            tooltipLine.SetPosition(1, lineEndPoint.position);
        }
        
        /// <summary>
        /// Updates the position and orientation of the tooltip's canvas elements, ensuring they align with the target transform.
        /// </summary>
        /// <param name="instant">If true, updates the position instantly instead of interpolating.</param>
        private void UpdateCanvasTransform(bool instant = false)
        {
            Transform waistController = PlayerController.Instance.WaistController.transform;
            Vector3 waistForwardOffset = 
                waistController.forward * currentOffset.z + 
                waistController.right * currentOffset.x + 
                waistController.up * currentOffset.y;
            Vector3 targetPosition = transform.position + waistForwardOffset;
            tooltipCanvasesParent.position = Vector3.Lerp(tooltipCanvasesParent.position, targetPosition, instant ? 1 : followSpeed * Time.deltaTime);

            if (MainCamera != null)
            {
                Vector3 tooltipPointLookAtPosition = MainCamera.position;
                Vector3 canvasLookAtPosition = tooltipPointLookAtPosition;

                if (alignVertically)
                {
                    tooltipPointLookAtPosition.Modify(y: lineStartPoint.position.y);
                    canvasLookAtPosition.Modify(y: tooltipCanvasesParent.position.y);
                }
                
                lineStartPoint.LookAt(tooltipPointLookAtPosition);
                tooltipCanvasesParent.LookAt(canvasLookAtPosition);
            }
        }
        
        #endregion
        
        #region Event Handlers

        /// <summary>
        /// Handles the completion of the show animation by marking the tooltip as displayed and triggering a global event.
        /// </summary>
        public void HandleShowAnimationFinishedPlaying()
        {
            displayedTimeStart = Time.time;
            OnAnyTooltipShowAnimationCompleted?.Invoke(this);
        }

        /// <summary>
        /// Handles the completion of the hide animation by disabling the tooltip and triggering a global event.
        /// </summary>
        public void HandleHideAnimationFinishedPlaying()
        {
            ToggleGameObject(false);
            OnAnyTooltipHideAnimationCompleted?.Invoke(this);
        }

        #endregion

        #region Helpers

        /// <summary>
        /// Returns the target transform of the tooltip, prioritizing a transform ID over a direct transform reference.
        /// </summary>
        /// <param name="parameters">The tooltip parameters containing the target information.</param>
        /// <returns>The resolved target transform.</returns>
        private Transform GetTargetTransform(TooltipParameters parameters)
        {
            return parameters.TargetTransform == null && !string.IsNullOrEmpty(parameters.TooltipTarget)
                ? LdxReferenceIDTracker.Instance.GetTransform(parameters.TooltipTarget)
                : parameters.TargetTransform;
        }
        
        /// <summary>
        /// Toggles the active state of the tooltip GameObject.
        /// </summary>
        /// <param name="setActive">If true, enables the GameObject; otherwise, disables it.</param>
        private void ToggleGameObject(bool setActive)
        {
            gameObject.SetActive(setActive);
        }

        #endregion

        #region Audio
        
        /// <summary>
        /// Plays an audio clip with an optional delay.
        /// </summary>
        /// <param name="soundReference">The audio clip sound reference string to play.</param>
        /// <param name="delay">The delay before playing the clip, in seconds.</param>
        private async UniTask PlayAudioAsync(string soundReference, float delay)
        {
            await UniTask.Delay(delay.ToMilliseconds());
            Audio.PlayOneShot(soundReference);
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Tooltip/WorldTooltip.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Wrist/WristUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bfbdfd724c2a2cc4ea72dad6075bea59
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.Player.Hands;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using UnityEngine;
using Autohand;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using Utilities.Blockers;

//Some functionality is taken from the WristLookEvent script from AutoHand
//It was brought into this script to move away from inspector UnityEvents
namespace Ldx.Framework.Systems.UI.Modules.Wrist
{
    /// <summary>
    /// Manages a wrist-mounted user interface anchored to a specific hand, handling validation,
    /// initialization, per-frame alignment/visibility, and reacting to blockers appropriately.
    /// </summary>
    public class WristUI : MonoBehaviour, IUIModule
    {
        private const float CAMERA_FRUSTUM_THRESHOLD = 0.25f;
        
        /// <summary>
        /// The WristUI is the WristUI shown
        /// The int is the number of WristUIs currently shown
        /// </summary>
        public static event Action<WristUI, int> OnAnyWristUIShown;
        /// <summary>
        /// The WristUI is the WristUI hidden
        /// The int is the number of WristUIs currently shown
        /// </summary>
        public static event Action<WristUI, int> OnAnyWristUIHidden;
        public static int NumberOfWristUIsShown { get; private set; }
        
        [SerializeField]
        private HandSide handSide;
        public HandSide HandSide => handSide;
        [Tooltip("The GameObject that will be activated and deactivated when looking at your wrist")]
        [SerializeField] private GameObject objectToShowHide;
        [Tooltip("A collider that should have collisions disabled between itself and the hand. Usually the back collider for the button")]
        [SerializeField] private Collider colliderToIgnoreHand;
        [Tooltip("The minimum head->wrist distance required to activate")]
        [SerializeField]
        private float maxDistance = 0.75f;
        [Tooltip("The angle precisness required to activate; 0 is any angle, 1 is exactly pointed at the face")]
        [SerializeField]
        [Range(0, 1)]
        private float anglePreciseness = 0.75f;
        [SerializeField]
        private bool disableWhileHolding = true;

        [SerializeField] private Vector3 handOffset;

        [Header("Events")]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField]
        private string eventOnShow;
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField]
        private string eventOnHide;

        [Header("Blockers")] 
        [SerializeField]
        [ReadOnly]
        private List<MonoBehaviour> blockers = new List<MonoBehaviour>();
        private List<IBlocker> blockersList = new List<IBlocker>();

        private float maxDistanceSqr;
        private Hand targetHand;
        private Camera targetCamera;
        private Quaternion rotationOffset;
        private bool showing = false;

        private void OnValidate()
        {
            blockers = GetComponents<IBlocker>()
                .Cast<MonoBehaviour>() // must cast back to MonoBehaviour for serialization
                .ToList();
        }

        private void Awake()
        {
            maxDistanceSqr = maxDistance * maxDistance;
            foreach (IBlocker blocker in blockers)
            {
                blockersList.Add(blocker);
            }
        }

        private void Start()
        {
            targetHand = PlayerController.Instance.HandsController.GetHand(handSide);
            if(targetHand != null)
                targetHand.HandIgnoreCollider(colliderToIgnoreHand, true);
            rotationOffset = transform.rotation;
            
            targetCamera = PlayerController.Instance.MainCamera;
            
            objectToShowHide.SetActive(false);
        }
        
        private void Update()
        {
            bool isBlocked() => blockersList.Any(x => x.IsBlocked);
            if (isBlocked() || 
                targetHand == null || 
                targetCamera == null || 
                (disableWhileHolding && targetHand.holdingObj != null))
            {
                UpdateVisibility(false);
                return;
            }
            
            Vector3 handPos = targetHand.transform.position;
            Vector3 headPos = targetCamera.transform.position;

            bool found = false;
            // Calculate the hands's position in viewport space
            Vector3 viewportPos =
                PlayerController.Instance.MainCamera.WorldToViewportPoint(handPos);
            // Check if the hand is outside the frustum threshold
            if (viewportPos.x >= CAMERA_FRUSTUM_THRESHOLD && viewportPos.x <= 1 - CAMERA_FRUSTUM_THRESHOLD &&
                viewportPos.y >= CAMERA_FRUSTUM_THRESHOLD && viewportPos.y <= 1 - CAMERA_FRUSTUM_THRESHOLD)
            {
                //Inverse for different hands to accomodate for backwards palm forwards
                float lookness = Vector3.Dot((headPos - handPos).normalized,  -targetHand.palmTransform.forward);
                float distanceSqr = headPos.GetSqrDistance(targetHand.palmTransform.position);
                found = lookness >= anglePreciseness && distanceSqr < maxDistanceSqr && targetHand.holdingObj == null;
            }

            UpdateVisibility(found);
        }

        private void LateUpdate()
        {
            Vector3 targetPos = transform.position = targetHand.transform.TransformPoint(handOffset);
            Quaternion targetRotation = targetHand.transform.rotation * rotationOffset;
            
            transform.SetPositionAndRotation(targetPos,targetRotation);
        }

        private void UpdateVisibility(bool shouldSee)
        {
            if (!showing && shouldSee)
            {
                NumberOfWristUIsShown++;
                OnAnyWristUIShown?.Invoke(this, NumberOfWristUIsShown);
                LdxTrackingManager.Instance.BroadcastTrackingEvent(eventOnShow);
                objectToShowHide.SetActive(true);
                showing = true;
            }
            else if(showing && !shouldSee)
            {
                NumberOfWristUIsShown--;
                OnAnyWristUIHidden?.Invoke(this, NumberOfWristUIsShown);
                LdxTrackingManager.Instance.BroadcastTrackingEvent(eventOnHide);
                objectToShowHide.SetActive(false);
                showing = false;
            }
        }

        public void ScenarioStarted(ScenarioManager scenarioManager, ScenarioDataType scenarioDataType) { }

        public void UnloadingScenarioOrLobby(ScenarioManager scenarioManager){ }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Wrist/WristUI.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Wrist/WristUIShownBlocker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0018f9a5b2e77a14b854866b468679e7
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;
using Utilities.Blockers;
using System;

namespace Ldx.Framework.Systems.UI.Modules.Wrist
{
    public class WristUIShownBlocker : MonoBehaviour, IBlocker
    {
        public event Action<IBlocker, bool> OnBlockChanged;
        public bool IsBlocked { get; private set;}

        private void Start()
        {
            WristUI.OnAnyWristUIShown += HandleWristUIShown;
            WristUI.OnAnyWristUIHidden += HandleWristUIHidden;
        }

        private void OnDestroy()
        {
            WristUI.OnAnyWristUIShown -= HandleWristUIShown;
            WristUI.OnAnyWristUIHidden -= HandleWristUIHidden;
        }

        private void HandleWristUIShown(WristUI incomingWristUI, int numberOfWristUIsShown)
        {
            IsBlocked = true;
            OnBlockChanged?.Invoke(this, IsBlocked);
        }
        
        private void HandleWristUIHidden(WristUI incomingWristUI, int numberOfWristUIsShown)
        {
            if (numberOfWristUIsShown > 0)
                return;
            
            IsBlocked = false;
            OnBlockChanged?.Invoke(this, IsBlocked);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Modules/Wrist/WristUIShownBlocker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Notifier/UINotify.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1f28c9c1917dc2b4db19eb6272197b12
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Utilities;
using UnityEngine;

namespace Ldx.Framework.Systems.UI.Notifier
{
    public class UINotify : Singleton<UINotify>
    {
        public enum NotifyType
        {
            None = 0,
            Warning = 1,
            Error = 2,
            Success = 3
        }
        
        readonly private Queue<UINotifyMessage> pooledMessages = new Queue<UINotifyMessage>();
        readonly private HashSet<UINotifyMessage> activeMessages = new HashSet<UINotifyMessage>();
        
        [SerializeField] private UINotifyMessage template;
        [SerializeField] private Transform msgParent;
        
        private float CascadingTime => UIGlobalSettings.NotifyCascadingTime;
        
        private float lastMessageTime = -1;

        private void Start()
        {
            UINotifyMessage.OnAnyNotifyMessageHidden += HandleAnyNotifyMessageHidden;
        }

        private void OnDestroy()
        {
            UINotifyMessage.OnAnyNotifyMessageHidden -= HandleAnyNotifyMessageHidden;
        }

        public static void ShowMessage(string msg, NotifyType type = NotifyType.None, float time = 3f)
        {
            ShowMessage(msg, UIGlobalSettings.GetNotifyColorByType(type), time);
        }

        public static void ShowMessage(string msg, Color color, float time = 3f)
        {
            Instance.DisplayMessageCascading(msg, time, color);
        }

        private void DisplayMessageCascading(string msg, float time, Color color)
        {
            float timeSinceLastMessage = Time.time - lastMessageTime;
            float showDelay = timeSinceLastMessage < CascadingTime ? (CascadingTime - timeSinceLastMessage) : 0;
            DisplayMessageToList(msg, color, time, showDelay);
            lastMessageTime = Time.time + showDelay;
        }

        private void DisplayMessageToList(string msg, Color color, float time, float showDelay)
        {
            if (pooledMessages.Count < 1)
            {
                pooledMessages.Enqueue(Instantiate(template, msgParent));
            }
            
            UINotifyMessage message = pooledMessages.Dequeue();
            message.DisplayMessage(msg, color, showDelay,time);
        }

        public static void HideText(UINotifyMessage uiMessage, float time)
        {
            if (Instance.activeMessages.Contains(uiMessage))
            {
                uiMessage.HideMessage(time);
            }
        }
        
        private void HandleAnyNotifyMessageHidden(UINotifyMessage msg)
        {
            activeMessages.Remove(msg);
            pooledMessages.Enqueue(msg);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Notifier/UINotify.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Notifier/UINotifyMessage.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1ff99fe89466944448888e13b7272b73
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using DG.Tweening;
using Systems.UI;
using UnityEngine;

namespace Ldx.Framework.Systems.UI.Notifier
{
    public class UINotifyMessage : MonoBehaviour
    {
        public static event Action<UINotifyMessage> OnAnyNotifyMessageHidden;
        
        [SerializeField] private LocalizedTextUGUI windowText;
        [HideInInspector] public Vector3 startPosition = Vector3.zero;
        [HideInInspector] public Coroutine coroutine = null;

        private float SpeedShown => UIGlobalSettings.NotifySpeedShown;
        private float SpeedHidden => UIGlobalSettings.NotifySpeedHidden;
        private Vector3 UpperPosition => UIGlobalSettings.NotifyUpperPosition;
        private Ease LowerEase => UIGlobalSettings.NotifyLowerEase;
        private Ease HideEase => UIGlobalSettings.NotifyHideEase;

        private Tween tween;

        private void OnDisable()
        {
            tween?.Kill();
        }

        public void DisplayMessage(string msg, Color color, float showDelay, float displayDuration)
        {
            windowText.SetString(msg);
            windowText.TMPText.color = color;
      
            transform.localScale = Vector3.one;
            startPosition = transform.localPosition;
            
            tween = transform.DOLocalMove(startPosition, SpeedShown + showDelay)
                .From(UpperPosition)
                .SetEase(LowerEase)
                .OnComplete(() =>
            {
                if (displayDuration > -1)
                {
                    HideMessage(displayDuration);
                }
            });
        }

        public void HideMessage(float displayDuration)
        {
            tween?.Kill();
            tween = transform.DOScale(Vector3.zero, SpeedHidden)
                .SetDelay(displayDuration)
                .SetEase(HideEase)
                .OnComplete(() =>
                {
                    gameObject.SetActive(false);
                    OnAnyNotifyMessageHidden?.Invoke(this);
                });
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Notifier/UINotifyMessage.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/RadialButtonActionBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e77e3c336e0a4f1195273a062a13a3b3
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.Save;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using UnityEngine;
using Debug = Ldx.Framework.Utilities.Logging.Debug;

namespace Ldx.Framework.Systems.UI
{
    [Serializable]
    public abstract class RadialButtonActionBase
    {
        /// <summary>
        /// Called when the menu is being set up. Useful for one-time initialization or caching.
        /// </summary>
        public virtual void Initialize(RadialSystemMenu systemMenu, RadialButtonInfo buttonInfo) { }
        
        public virtual void OnDestroy(RadialSystemMenu systemMenu, RadialButtonInfo buttonInfo) { }
        
        /// <summary>
        /// Executes the action associated with this button.
        /// </summary>
        public abstract void Execute(RadialSystemMenu systemMenu);
        
        /// <summary>
        /// Determines if this button should be visible and interactable in the current context.
        /// </summary>
        public virtual bool CanShow(RadialSystemMenu systemMenu)
        {
            return true;
        }
    }
    
    public class ExitApplicationAction : RadialButtonActionBase
    {
        public ConfirmationArgs exitConfirmationArgs;

        public override void Initialize(RadialSystemMenu systemMenu, RadialButtonInfo buttonInfo)
        {
            base.Initialize(systemMenu, buttonInfo);
            exitConfirmationArgs.OnProceedConfirmation += HandleCallbackInvoked;
        }

        public override void OnDestroy(RadialSystemMenu systemMenu, RadialButtonInfo buttonInfo)
        {
            base.OnDestroy(systemMenu, buttonInfo);
            exitConfirmationArgs.OnProceedConfirmation -= HandleCallbackInvoked;
        }

        public override void Execute(RadialSystemMenu systemMenu)
        {
            Debug.Log($"Executing Exit Application Action");
            ConfirmationWindow.ShowConfirmation(exitConfirmationArgs);
        }

        private void HandleCallbackInvoked(bool proceed)
        {
            if (proceed)
            {
                Application.Quit();
            }
        }
    }
    
    public class RestartScenarioAction : RadialButtonActionBase
    {
        public ConfirmationArgs restartConfirmationArgs;

        public override void Initialize(RadialSystemMenu systemMenu, RadialButtonInfo buttonInfo)
        {
            base.Initialize(systemMenu, buttonInfo);
            restartConfirmationArgs.OnProceedConfirmation += HandleCallbackInvoked;
        }
        
        public override void OnDestroy(RadialSystemMenu systemMenu, RadialButtonInfo buttonInfo)
        {
            base.OnDestroy(systemMenu, buttonInfo);
            restartConfirmationArgs.OnProceedConfirmation -= HandleCallbackInvoked;
        }
        
        public override void Execute(RadialSystemMenu systemMenu)
        {
            Debug.Log("Executing: Restart Scenario Action");
            ConfirmationWindow.ShowConfirmation(restartConfirmationArgs);
        }
        
        public override bool CanShow(RadialSystemMenu systemMenu)
        {
            ScenarioData loadedScenario = ScenarioManager.Instance.LoadedScenarioData;
            bool hasScenario = loadedScenario != null;
            return hasScenario &&
                   loadedScenario.IncludeInMenuSelectionList;
        }
        
        private void HandleCallbackInvoked(bool proceed)
        {
            if (proceed)
            {
                ScenarioManager.Instance.ReloadCurrentScenario();
            }
        }
    }
    
    public class LoadNextScenarioAction : RadialButtonActionBase
    {
        public override void Execute(RadialSystemMenu systemMenu)
        {
            Debug.Log("Executing: Loading Next Scenario Action");
            ScenarioManager.Instance.LoadNextScenario();
        }
        
        public override bool CanShow(RadialSystemMenu systemMenu)
        {
            return ScenarioManager.Instance.HasNextScenario;
        }
    }

    public class ShowScenarioSelectionButtonsAction : RadialButtonActionBase
    {
        public override void Initialize(RadialSystemMenu systemMenu, RadialButtonInfo buttonInfo)
        {
            buttonInfo.subMenuButtons.Clear();
            List<ScenarioDataInfo> scenarioDataInfos = ScenarioManager.Instance.GetScenarioDataInfo()
                .Where(s => s.IncludeInMenuSelectionList).ToList();
            foreach (ScenarioDataInfo dataInfo in scenarioDataInfos)
            {
                buttonInfo.subMenuButtons.Add(new RadialButtonInfo()
                {
                    buttonName = dataInfo.ScenarioName,
                    icon = dataInfo.PreviewImage,
                    action = new LoadSpecificScenarioAction()
                    {
                        scenarioId = dataInfo.ID,
                    }
                });
            }
        }
        
        public override void Execute(RadialSystemMenu systemMenu) { }
    }
        
    public class LoadSpecificScenarioAction : RadialButtonActionBase
    {
        public string scenarioId;
        
        public override void Execute(RadialSystemMenu systemMenu)
        {
            Debug.Log($"Executing: Loading Specific Scenario Action: {scenarioId}");
            ScenarioManager.Instance.LoadScenario(scenarioId);
        }
    }
    
    public class RecalibratePlayerHeightAction : RadialButtonActionBase
    {
        public override void Execute(RadialSystemMenu systemMenu)
        {
            Debug.Log("Executing: Recalibrate Player Height Action");
            PlayerController.Instance.CalibrateHeight();
        }
    }
    
    public class ChangePlayerPositioningModeAction : RadialButtonActionBase
    {
        public enum PositioningMode
        {
            Sit = 0,
            Stand = 1,
        }

        public PositioningMode mode = PositioningMode.Sit;
        
        public override void Execute(RadialSystemMenu systemMenu)
        {
            Debug.Log($"Executing: Change Player Positioning Mode to {mode}");
            LdxSaveSystem.Instance.SetPositioningMode((int) mode);
        }
    }
    
    public class ChangePlayerSnapRateAction : RadialButtonActionBase
    {
        public int snapRate = 90;
        
        public override void Execute(RadialSystemMenu systemMenu)
        {
            Debug.Log($"Executing: Change Player Snap Rate to {snapRate}");
            LdxSaveSystem.Instance.SetSnapRateSpeed(snapRate);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/RadialButtonActionBase.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/RadialSystemMenu.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 14fb9c337e3242aa82fcfa9e880cd90a
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Utilities.Attributes;
using TMPro;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.UI
{
    [Serializable]
    public class RadialButtonInfo 
    {
        [LocalizationKey]
        public string buttonName;
        public Sprite icon;
        public Sprite hoveredIcon;
        public List<RadialButtonInfo> subMenuButtons = new();
        [SerializeReference][InheritedClassDropdown(typeof(RadialButtonActionBase), "Base")]
        public RadialButtonActionBase action;
    }
    
    public class RadialSystemMenu : UIElement
    {
        public static event Action<RadialSystemMenu, bool> OnSystemMenuOpenedClosed;
        
        public static bool IsSystemMenuOpened { get; private set; }
        
        [Space]
        [Header("References")]
        [SerializeField] private UIButton buttonPrefab;
        [SerializeField] private Transform buttonsParent; 
        [SerializeField] private UIButton centerButton;

        [SerializeField]
        [LocalizationKey]
        private string centerButtonBack = "Back";
    
        private enum MenuDirection
        {
            Clockwise,
            CounterClockwise
        }
        
        [Space]
        [Header("Menu Settings")]
        [SerializeField] private float radius = 150f;
        [SerializeField] private MenuDirection menuDirection = MenuDirection.Clockwise;
        [Tooltip("Number of fixed button slots. Must be >= number of root menu buttons.")]
        [SerializeField] private int buttonsAmount = 8;
        [Tooltip("Offset in degrees for the first button's position. 0 is top, 90 is right, etc.")]
        [SerializeField] private float startAngleOffsetDeg = 0f;
        [SerializeField] private List<RadialButtonInfo> rootMenuButtons;
        
        [Space]
        [Header("Other")]
        [SerializeField] private TextMeshProUGUI buildVersion;

        private List<RadialButtonInfo> currentButtonInfos;
        private readonly Stack<List<RadialButtonInfo>> menuHistory = new();
        private readonly List<UIButton> buttonSlotInstances = new();
        private readonly Dictionary<UIButton, RadialButtonInfo> assignedButtons = new();

        protected override void OnValidate()
        {
            base.OnValidate();
            buttonsAmount = Mathf.Max(buttonsAmount, rootMenuButtons.Count);
        }

        /// <summary>
        /// Sets up the window, initializes the button pool, and initializes button actions.
        /// </summary>
        public void SetUpWindow()
        {
            currentButtonInfos = rootMenuButtons;

            foreach (RadialButtonInfo buttonInfo in rootMenuButtons)
            {
                InitializeButtonInfoRecursive(buttonInfo);
            }
            
            InitializeButtonSlots();

            centerButton.OnButtonPressed += HandleCenterButtonPressed;
            buildVersion.text = Application.version;
        }

        /// <summary>
        /// Recursively calls the Initialize method on actions for a button and its sub-buttons.
        /// </summary>
        private void InitializeButtonInfoRecursive(RadialButtonInfo buttonInfo)
        {
            buttonInfo.action?.Initialize(this, buttonInfo);

            foreach (RadialButtonInfo button in buttonInfo.subMenuButtons)
            {
                InitializeButtonInfoRecursive(button);
            }
        }
        
        /// <summary>
        /// Instantiates and positions a fixed number of button UI elements (slots).
        /// </summary>
        private void InitializeButtonSlots()
        {
            if (buttonPrefab == null || buttonsParent == null)
            {
                Debug.LogError("ButtonPrefab or ButtonsParent not set for pool initialization!", gameObject);
                return;
            }

            int numberOfButtonSlots = Mathf.Max(buttonsAmount, rootMenuButtons.Count);
            if (numberOfButtonSlots <= 0)
            {
                Debug.LogWarning("NumberOfButtonSlots is 0 or less. No buttons will be created.", gameObject);
                return;
            }
            
            for (int i = 0; i < Mathf.Max(buttonsAmount, rootMenuButtons.Count); i++)
            {
                UIButton newButtonInstance = Instantiate(buttonPrefab, buttonsParent);
                newButtonInstance.gameObject.name = $"RadialSlot_{i}";
                Vector3 position = CalculateButtonPosition(i, numberOfButtonSlots, radius, menuDirection, startAngleOffsetDeg);
                newButtonInstance.transform.localPosition = position;

                newButtonInstance.OnButtonHover += HandleButtonHovered;
                newButtonInstance.OnButtonUnhover += HandleButtonUnhovered;
                newButtonInstance.OnButtonPressed += HandleButtonPressed;
                
                buttonSlotInstances.Add(newButtonInstance);
            }
        }
        
        private static Vector3 CalculateButtonPosition(int index, int totalButtonsInRing, float ringRadius, MenuDirection direction, float overallStartAngleDeg)
        {
            if (totalButtonsInRing == 0) return Vector3.zero;
            float angleStep = 360f / totalButtonsInRing;
            float currentAngleDeg = overallStartAngleDeg + (index * angleStep * (direction == MenuDirection.Clockwise ? 1 : -1));
            float currentAngleRad = currentAngleDeg * Mathf.Deg2Rad;
            return new Vector3(Mathf.Sin(currentAngleRad) * ringRadius, Mathf.Cos(currentAngleRad) * ringRadius, 0);
        }
        
        protected override void OnDestroy()
        {
            base.OnDestroy();
            ClearButtons();
        }
        
        private void ClearButtons()
        {
            foreach (UIButton button in buttonSlotInstances)
            {  
                button.OnButtonHover -= HandleButtonHovered;
                button.OnButtonUnhover -= HandleButtonUnhovered;
                button.OnButtonPressed -= HandleButtonPressed;
                DestroyImmediate(button.gameObject);
            }
            
            assignedButtons.Clear();
            buttonSlotInstances.Clear();
            
            centerButton.OnButtonPressed -= HandleCenterButtonPressed;
        }
        
        /// <summary>
        /// Actions performed when the menu finishes hiding. Deactivates buttons.
        /// </summary>
        protected override void ShowElementBeginActions(bool instant)
        {
            base.ShowElementBeginActions(instant);
            currentButtonInfos = rootMenuButtons;
            menuHistory.Clear();
            DisplayMenuLevel(currentButtonInfos);
        }

        protected override void ShowElementCompleted()
        {
            base.ShowElementCompleted();
            OnSystemMenuOpenedClosed?.Invoke(this, true);
            IsSystemMenuOpened = true;
        }

        protected override void HideElementCompleted(bool wasActiveBefore)
        {
            base.HideElementCompleted(wasActiveBefore);
            OnSystemMenuOpenedClosed?.Invoke(this, false);
            IsSystemMenuOpened = false;
        }

        /// <summary>
        /// Displays a given level of the radial menu, using pooled buttons.
        /// </summary>
        private void DisplayMenuLevel(List<RadialButtonInfo> buttonsToDisplay)
        {
            if (buttonsToDisplay == null || buttonsToDisplay.Count == 0 || buttonPrefab == null || buttonsParent == null || buttonSlotInstances.Count == 0)
            {
                Debug.LogWarning("No buttons to display or menu not configured properly!", gameObject);
                return;
            }
            currentButtonInfos = buttonsToDisplay;
            assignedButtons.Clear();

            for (int i = 0; i < buttonSlotInstances.Count; i++)
            {
                UIButton buttonInstance = buttonSlotInstances[i];
                bool isPlaceholder = i >= buttonsToDisplay.Count;
                RadialButtonInfo buttonDefinition = isPlaceholder ? null : buttonsToDisplay[i];
                
                if (!isPlaceholder)
                {
                    isPlaceholder = buttonDefinition.action != null && !buttonDefinition.action.CanShow(this);
                }

                buttonInstance.SetButtonIcon(isPlaceholder ? null : buttonDefinition.icon);
                
                if (!isPlaceholder)
                {
                    assignedButtons.Add(buttonInstance, buttonDefinition);
                }
            }
            
            ResetCenterDescription();
        }

        /// <summary>
        /// Handles a radial button press event.
        /// </summary>
        private void HandleButtonPressed(UIButton button)
        {
            if (assignedButtons.TryGetValue(button, out RadialButtonInfo buttonInfo))
            {
                if (buttonInfo.subMenuButtons.Count > 0)
                {
                    NavigateToSubMenu(buttonInfo.subMenuButtons);
                }
                else
                {
                    buttonInfo.action.Execute(this);
                }
            }
        }

        /// <summary>
        /// Handles a radial button hover event, updating the center description.
        /// </summary>
        private void HandleButtonHovered(UIButton button)
        {
            if (assignedButtons.TryGetValue(button, out RadialButtonInfo buttonInfo))
            {
                button.SetButtonIcon(buttonInfo.hoveredIcon);
                SetCenterDescription(buttonInfo.buttonName);
            }
        }
        
        /// <summary>
        /// Handles a radial button unhover event, clearing the center description or reverting it.
        /// </summary>
        private void HandleButtonUnhovered(UIButton button)
        {
            if (assignedButtons.TryGetValue(button, out RadialButtonInfo buttonInfo))
            {
                button.SetButtonIcon(buttonInfo.icon);
                SetCenterDescription(buttonInfo.buttonName);
            }
            
            ResetCenterDescription();
        }
        
        /// <summary>
        /// Handles center radial button press event.
        /// </summary>
        private void HandleCenterButtonPressed(UIButton button)
        {
            NavigateBack();
        }

        /// <summary>
        /// Navigates to a specified sub-menu level.
        /// </summary>
        public void NavigateToSubMenu(List<RadialButtonInfo> subMenuButtonInfos)
        {
            if (currentButtonInfos != null) // Push the current menu onto the history stack
            {
                menuHistory.Push(currentButtonInfos);
            }
            
            DisplayMenuLevel(subMenuButtonInfos);
        }

        /// <summary>
        /// Navigates back to the previous menu level or hides the menu if at root.
        /// </summary>
        private void NavigateBack()
        {
            if (menuHistory.Count > 0)
            {
                List<RadialButtonInfo> previousMenu = menuHistory.Pop();
                DisplayMenuLevel(previousMenu);
            }
            else
            {
                Debug.Log("Already at the root menu. Cannot go back further.");
                // Optionally, hide the menu if at root and back is pressed
                // HideMenu();
            }
        }

        /// <summary>
        /// Sets the description text in the center of the radial menu.
        /// </summary>
        public void SetCenterDescription(string description)
        {
            centerButton.Text.SetString(description);
        }

        /// <summary>
        /// Updates the center button's text and action based on the current menu depth.
        /// </summary>
        private void ResetCenterDescription()
        {
            centerButton.SetInteractable(menuHistory.Count > 0);
            centerButton.Text.SetString(menuHistory.Count > 0 ? centerButtonBack : "");
        }

        #region Editor
        
        private void OnDrawGizmosSelected()
        {
            if (buttonsParent == null && buttonsAmount == 0) return;

            Transform referenceTransform = buttonsParent != null ? buttonsParent : transform;
            Matrix4x4 originalGizmosMatrix = Gizmos.matrix;
            Gizmos.matrix = referenceTransform.localToWorldMatrix;

#if UNITY_EDITOR
            Matrix4x4 originalHandlesMatrix = Handles.matrix;
            Handles.matrix = referenceTransform.localToWorldMatrix;
#endif

            int slotsToDraw = buttonsAmount; 
            if (slotsToDraw <= 0 && rootMenuButtons != null) 
            {
                slotsToDraw = rootMenuButtons.Count;
            }
            if (slotsToDraw == 0) 
            {
                Gizmos.matrix = originalGizmosMatrix;
#if UNITY_EDITOR
                Handles.matrix = originalHandlesMatrix;
#endif
                return;
            }
        
            Gizmos.color = Color.yellow;
            DrawGizmoWireCircle(Vector3.zero, Vector3.forward, radius, 32);

            for (int i = 0; i < slotsToDraw; i++)
            {
                Vector3 slotCenterPos = CalculateButtonPosition(i, slotsToDraw, radius, menuDirection, startAngleOffsetDeg);
                RadialButtonInfo buttonInfoForThisSlot = (rootMenuButtons != null && i < rootMenuButtons.Count) ? rootMenuButtons[i] : null;

                if (buttonInfoForThisSlot != null) // This slot is filled by a defined root button
                {
                    Gizmos.color = Color.green; // Or check if it's a submenu for gizmoSubMenuColor
                    if(buttonInfoForThisSlot.subMenuButtons is { Count: > 0 })
                    {
                        Gizmos.color = Color.blue;
                    }
                    DrawGizmoWireCircle(slotCenterPos, Vector3.forward, 50f, 20);

#if UNITY_EDITOR
                    string buttonText = string.IsNullOrEmpty(buttonInfoForThisSlot.buttonName) ? "Btn" : buttonInfoForThisSlot.buttonName;
                    if (buttonText.Length > 6) buttonText = buttonText.Substring(0, 5) + ".";
                    Handles.Label(slotCenterPos, buttonText, new GUIStyle(GUI.skin.label) { alignment = TextAnchor.MiddleCenter, normal = { textColor = Color.white }, fontSize = 9 });
#endif
                }
                else // This is an empty slot at the root level
                {
                    Gizmos.color = Color.gray;
                    DrawGizmoWireCircle(slotCenterPos, Vector3.forward, 50f * 0.8f, 16);
                }
            }

            Gizmos.matrix = originalGizmosMatrix;
#if UNITY_EDITOR
            Handles.matrix = originalHandlesMatrix;
#endif
        }
         
        private void DrawGizmoWireCircle(Vector3 position, Vector3 normal, float circleRadius, int segments)
        {
            if (segments <= 0 || circleRadius <= 0) return;
            Quaternion rotation = Quaternion.LookRotation(normal, Vector3.up);
            if (normal == Vector3.up || normal == Vector3.down) rotation = Quaternion.LookRotation(normal, Vector3.forward);

            Vector3 prevPoint = position + rotation * (Quaternion.Euler(0, 0, 0) * Vector3.right * circleRadius);
            for (int i = 1; i <= segments; i++)
            {
                float angle = (360f * i / segments);
                Vector3 nextPoint = position + rotation * (Quaternion.Euler(0, 0, angle) * Vector3.right * circleRadius);
                Gizmos.DrawLine(prevPoint, nextPoint);
                prevPoint = nextPoint;
            }
        }
        
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/RadialSystemMenu.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/ScenarioEndWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 548875459f004a6e8d44903de3a5a3b2
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Scripts.Systems.Scoring;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Utilities;
using Systems.UI;
using UnityEngine;
using UnityEngine.UI;

namespace Ldx.Framework.Systems.UI
{
    public class ScenarioEndWindow : UIElement
    {
        private const float AUDIO_DELAY_SEC = 1f;
        
        public static event Action<ScenarioEndWindow, bool> OnScenarioEndWindowShowHide;
        
        [SerializeField] private LocalizedTextUGUI headerText;
        [SerializeField] private LocalizedTextUGUI scenarioNameText;
        [SerializeField] private LocalizedTextUGUI scoreText;
        [SerializeField] private float scoreSmallTextSize = 50f;
        [SerializeField] private UIButton tryAgainButton;
        [SerializeField] private LocalizedTextUGUI tryAgainButtonScenarioNameText;
        [SerializeField] private UIButton nextScenarioButton;
        [SerializeField] private LocalizedTextUGUI nextScenarioButtonScenarioNameText;
        [SerializeField] private UIButton restartButton;
        [SerializeField] private UIButton continueButton;

        [SerializeField]
        [LocalizationKey] private string passedKey;
        [SerializeField]
        [LocalizationKey] private string failedKey;
        [SerializeField]
        [LocalizationKey] private string criticalErrorKey;

        private Coroutine audioDelayCoroutine;

        private bool scenarioIsComplete;
        
        protected override void OnDisable()
        {
            base.OnDisable();
            CoroutineUtilities.StopAndNullCoroutine(ref audioDelayCoroutine, this);
        }

        protected override void ShowElementBeginActions(bool instant)
        {
            scenarioNameText.SetString(ScenarioManager.Instance.LoadedScenarioData.ScenarioName);
            
            if (ScoringSystem.Instance.IsActive)
            {
                ScoringSystem.EvaluationResult result = ScoringSystem.Instance.EvaluateScenario();
                
                headerText.SetString(result.CriticalErrorsTriggered.Count > 0 ? criticalErrorKey :
                    result.ScenarioResult == ScoringSystem.EvaluationResult.Result.Pass ? passedKey : failedKey);
                
                bool isPassWithoutCompletion = !scenarioIsComplete && result.ScenarioResult == ScoringSystem.EvaluationResult.Result.Pass;
                
                if (!isPassWithoutCompletion)
                {
                    tryAgainButtonScenarioNameText.SetString(ScenarioManager.Instance.LoadedScenarioData.ScenarioName);
                    if (ScenarioManager.Instance.HasNextScenario)
                        nextScenarioButtonScenarioNameText.SetString(ScenarioManager.Instance.NextScenarioData.ScenarioName);
                }

                scoreText.gameObject.SetActive(true);
                if (result.CriticalErrorsTriggered.Count > 0)
                {
                    scoreText.SetString("");
                }
                else
                {
                    scoreText.SetString(result.FinalDisplayScore + "<size=" + scoreSmallTextSize + ">/ 100");
                }
                
                tryAgainButton.gameObject.SetActive(!isPassWithoutCompletion);
                nextScenarioButton.gameObject.SetActive(!isPassWithoutCompletion && ScenarioManager.Instance.HasNextScenario);
                restartButton.gameObject.SetActive(false); 
                continueButton.gameObject.SetActive(isPassWithoutCompletion);
            }
            else
            {
                scoreText.gameObject.SetActive(false);
                headerText.SetString(UIGlobalSettings.DefaultScenarioEndLabel);
                
                tryAgainButton.gameObject.SetActive(false);
                nextScenarioButton.gameObject.SetActive(false);
                restartButton.gameObject.SetActive(true);
                continueButton.gameObject.SetActive(false);
            }
            
            CoroutineUtilities.ReplaceAndStartCoroutine(ref audioDelayCoroutine, AudioDelay(), UIController.Instance);
            rebuildVerticalLayoutsAsync().Forget();
            
            base.ShowElementBeginActions(instant);
            OnScenarioEndWindowShowHide?.Invoke(this, true);

            async UniTaskVoid rebuildVerticalLayoutsAsync()
            {
                List<VerticalLayoutGroup> layouts = new List<VerticalLayoutGroup>();
                foreach (VerticalLayoutGroup layout in GetComponentsInChildren<VerticalLayoutGroup>())
                {
                    layouts.Add(layout);
                    layout.enabled = false;
                    await UniTask.Yield();
                }

                await UniTask.Yield();
                for (int i = layouts.Count - 1; i >= 0; i--)
                {
                    VerticalLayoutGroup layout = layouts[i];
                    layout.enabled = true;
                    await UniTask.Yield();
                }
                
                RebuildLayouts();
            }
        }

        protected override void HideElementBeginActions(bool instant)
        {
            base.HideElementBeginActions(instant);
            OnScenarioEndWindowShowHide?.Invoke(this, false);
        }

        private IEnumerator AudioDelay()
        {
            yield return new WaitForSeconds(AUDIO_DELAY_SEC);
            Audio.PlayOneShot(AudioGlobalSettings.EndOfScenarioSound);
        }

        public void SetScenarioCompleteStatus(bool state)
        {
            scenarioIsComplete = state;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/ScenarioEndWindow.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/ScenarioTransitionUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0bd98ec498f94e0992e38a52fbce5e0d
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Async;
using UnityEngine;

namespace Ldx.Framework.Systems.UI
{
    /// <summary>
    /// The presentation layer for the ScenarioManager
    /// Responds to loading events and displays progress through the loading operations
    /// </summary>
    [RequireComponent(typeof(CanvasGroup))]
    public class ScenarioTransitionUI : MonoBehaviour
    {
        [SerializeField] 
        private CanvasGroup canvasGroup;
        
        private float displayedProgress;
        private bool finishedLoading;
        private Coroutine updateRoutine;

        private void OnValidate()
        {
            if (canvasGroup == null)
            {
                canvasGroup = GetComponent<CanvasGroup>();
            }
        }

        private void Awake()
        {
            canvasGroup.alpha = 0f;
            ScenarioManager.OnLoadingStarted += HandleLoadingStarted;
            ScenarioManager.OnLoadingFinished += HandleLoadingFinished;
        }

        private void OnDestroy()
        {
            ScenarioManager.OnLoadingStarted -= HandleLoadingStarted;
            ScenarioManager.OnLoadingFinished -= HandleLoadingFinished;
            UIOverlayFade.OnScreenFadeInComplete -= HandleScreenFadeInComplete;
            CoroutineUtilities.StopAndNullCoroutine(ref updateRoutine, this);
        }

        #region Loading

        /// <summary>
        /// Handles the start of the loading process. Fades out the screen and begins updating the loading status
        /// </summary>

        private void HandleLoadingStarted(ScenarioLoadingParameters parameters)
        {
            finishedLoading = false;
            parameters.SetSceneHiddenGetter(UIController.Instance.FadeOutScreen());
            ScenarioData scenarioData = parameters.ScenarioData;
            AsyncOperationGroup operations = parameters.AsyncOperationGroup;
            
            if (scenarioData == null || scenarioData.DisplayLoadingIcon)
            {
                canvasGroup.alpha = 1;
                CoroutineUtilities.ReplaceAndStartCoroutine(ref updateRoutine, LoadingStatusUpdateRoutine(operations), this);
            }
        }

        /// <summary>
        /// Continuously checks the status of the loading process, ensuring the display remains in the correct orientation
        /// </summary>
        /// <param name="operation">Group of asynchronous operations that define the loading process</param>
        /// <returns>Yield instruction for the coroutine</returns>
        private IEnumerator LoadingStatusUpdateRoutine(AsyncOperationGroup operation)
        {
            while (!finishedLoading)
            {
                // Pathetic attempt to keep the loading window straight 
                ResetZRotation();
                yield return null;
            }
        }

        /// <summary>
        /// Ensures the orientation of the loading display remains consistent by resetting any Z-axis rotation
        /// </summary>
        private void ResetZRotation()
        {
            Vector3 eulerRotation = transform.rotation.eulerAngles;
            eulerRotation.z = 0;
            transform.rotation = Quaternion.Euler(eulerRotation);
        }
        
        /// <summary>
        /// Handles the completion of the loading process. Fades in the screen and prepares to hide the loading UI
        /// </summary>
        /// <param name="m">Reference to the ScenarioManager that finished the load</param>
        private void HandleLoadingFinished(ScenarioManager m)
        {
            finishedLoading = true;
            UIOverlayFade.OnScreenFadeInComplete -= HandleScreenFadeInComplete;
            UIOverlayFade.OnScreenFadeInComplete += HandleScreenFadeInComplete;
            UIController.Instance.FadeInScreen();
        }
        
        /// <summary>
        /// Logic executed after the screen fade-in is completed, hiding the loading UI
        /// </summary>
        private void HandleScreenFadeInComplete()
        {
            UIOverlayFade.OnScreenFadeInComplete -= HandleScreenFadeInComplete;
            canvasGroup.alpha = 0;
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/ScenarioTransitionUI.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/ScreenTextureChanger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ee5e1f6c7f024da7b313553753e37d30
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Systems.UI
{
    [RequireComponent(typeof(MeshRenderer))]
    public class ScreenTextureChanger : MonoBehaviour
    {
        readonly static private int Texture1 = Shader.PropertyToID("_Texture");
        [SerializeField] private MeshRenderer screenMeshRenderer;
        
        [Space]
        [SerializeField] private Texture2D idleScreenTexture;
        [SerializeField] private Texture2D okScreenTexture;
        [SerializeField] private Texture2D stopScreenTexture;

        [SerializeField] private float okScreenDuration = 0.5f;
        
        [SerializeField][SoundReference]
        private string onClickSound;
        
        [Header("Events to listen to:")]
        [SerializeField][IDSelection(LdxIdSettings.IdType.TrackingEvent)] 
        private string startButtonPressedEvent;
        [SerializeField][IDSelection(LdxIdSettings.IdType.TrackingEvent)] 
        private string returnToIdleEvent;
        
        private Material screenMaterial;

        private void OnValidate()
        {
            if (screenMeshRenderer == null)
            {
                screenMeshRenderer = GetComponent<MeshRenderer>();
            }
        }

        private void Start()
        {
            screenMaterial = Instantiate(screenMeshRenderer.sharedMaterial);
            screenMeshRenderer.SetMaterials(new List<Material>{screenMaterial});
            SetTexture(idleScreenTexture);
            LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
        }

        private void OnDestroy()
        {
            if (screenMaterial != null)
            {
                Destroy(screenMaterial);
            }

            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }
        }
        
        private void HandleTrackingEvent(string id)
        {
            if (id == startButtonPressedEvent)
            {
                Audio.PlayOneShot(onClickSound);
                ProcessStartPressedAsync().Forget();
            }

            if (id == returnToIdleEvent)
            {
                SetTexture(idleScreenTexture);
            }
        }

        private async UniTask ProcessStartPressedAsync()
        {
            SetTexture(okScreenTexture);
            await UniTask.Delay(okScreenDuration.ToMilliseconds());
            SetTexture(stopScreenTexture);
        }

        private void SetTexture(Texture2D texture)
        {
            screenMaterial.SetTexture(Texture1, texture);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/ScreenTextureChanger.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/SegmentAnchorController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7c7da258c5544f3cac6e7c5f3c58b4bc
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.UI;
using Ldx.Framework.UI.Dialog;
using UnityEngine;

namespace Ldx.Framework.Systems.UI
{
    public class SegmentAnchorController : MonoBehaviour, IAnchorParent
    {
        [SerializeField] 
        private List<UIAnchor> anchors = new List<UIAnchor>();
        
        public void InjectAnchors(bool refreshListAfter = true, bool instantiateAnchors = false)
        {
            if (refreshListAfter)
            {
                UIAnchorController.Instance.Anchors.Clear();
            }
            foreach (UIAnchor anchor in anchors)
            {
                if (anchor == null)
                {
                    continue;
                }

                UIAnchor usedAnchor = anchor;
                if (instantiateAnchors)
                {
                    usedAnchor = Instantiate(anchor);
                }
                usedAnchor.transform.SetParent(UIAnchorController.Instance.transform);
                UIAnchorController.Instance.Anchors.Add(usedAnchor);
            }

            
        }
        
#if UNITY_EDITOR
        public void EDITOR_AddAnchor()
        {
            for (int i = anchors.Count - 1; i >= 0; i--)
            {
                if (anchors[i] == null)
                {
                    anchors.RemoveAt(i);
                }
            }
            GameObject o = new GameObject();
            o.transform.SetParent(transform);
            UIAnchor anchor = o.AddComponent<UIAnchor>();
            if (anchors.Count > 0)
            {
                o.transform.position = anchors.Last().transform.position;
            }

            UnityEditor.Selection.activeObject = o;
            anchors.Add(anchor);
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/SegmentAnchorController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/SpriteAnimation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0bd1f89f48f24748aa41250bad03433f
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Utilities.Extensions;
using Systems.LdxLocalization;
using UnityEngine;
using UnityEngine.UI;

namespace Ldx.Framework.Systems.UI
{
    [RequireComponent(typeof(Image))]
    public class SpriteAnimation : LocalizedElement
    {
        [Serializable]
        public class SpriteAnimationSettings
        {
            [SerializeField] private Sprite[] frames;
            public Sprite[] Frames => frames;

            [Serializable]
            public class LocalizedAnimationFrames
            {
                public Language language;
                public Sprite[] frames;
            }

            [SerializeField]
            private List<LocalizedAnimationFrames> localizedFrames = new();
            public List<LocalizedAnimationFrames> LocalizedFrames => localizedFrames;

            [SerializeField] private bool loop = true;
            public bool Loop => loop;
            [SerializeField] private bool playOnEnable = true;
            public bool PlayOnEnable => playOnEnable;
            [SerializeField] private float frameDuration = 0.13f;
            public float FrameDuration => frameDuration;

            public static SpriteAnimationSettings Default()
            {
                return new SpriteAnimationSettings()
                {
                    frames = new Sprite[] { }
                };
            }
        }
        
        [SerializeField] private Image image;
        public Image Image => image;
        [SerializeField] private SpriteAnimationSettings settings;

        private Sprite[] frames;
        private int currentFrame;
        private bool playing;
        private CancellationTokenSource cts = new();
        private readonly TimeSpan precautionTimeout = TimeSpan.FromSeconds(5);

        private void OnValidate()
        {
            if (image == null)
            {
                image = GetComponent<Image>();
            }
        }

        protected override void OnEnable()
        {
            base.OnEnable();
            if (settings.PlayOnEnable)
            {
                Play();
            }
        }

        protected override void OnDisable()
        {
            base.OnDisable();
            cts.SafeCancelAndDispose();
        }

        public void SetupAnimation(SpriteAnimationSettings newSettings)
        {
            SetupAnimationAsync(newSettings).Forget();
        }

        private async UniTaskVoid SetupAnimationAsync(SpriteAnimationSettings newSettings)
        {
            // Wait to ensure cancellation
            cts.SafeCancelAndDispose();
            await UniTask.WaitUntil(() => !playing).TimeoutWithoutException(precautionTimeout);
            
            settings = newSettings;
            AssignFrames();
            Play();
        }

        private void Play()
        {
            if (!gameObject.activeInHierarchy)
            {
                return;
            }
            
            FrameRoutineAsync().Forget();
        }

        private async UniTask FrameRoutineAsync()
        {
            if (playing)
            {
                return;
            }
            
            playing = true;
            cts.SafeCancelAndDispose();
            await UniTask.Yield();
            cts = new CancellationTokenSource();
            SetFrame(0);
            
            float timeOfNextFrame;
            while (!cts.IsCancellationRequested && frames.Length > 1)
            {
                timeOfNextFrame = Time.time + settings.FrameDuration;
                await UniTask.WaitUntil(() => Time.time > timeOfNextFrame);
                SetFrame(currentFrame + 1);
            }
            
            playing = false;
        }

        private void SetFrame(int index)
        {
            if (index >= frames.Length)
            {
                // TODO: figure out why settings.Loop is false
                // if (!settings.Loop)
                // {
                //     return;
                // }
                //
                index = 0;
            }
            currentFrame = index;
            if (settings != null && currentFrame < frames.Length)
            {
                image.sprite = frames[currentFrame];
            }
        }

        protected override async UniTask RefreshLocalizationElement()
        {
            await base.RefreshLocalizationElement();
            AssignFrames();
            Play();
        }

        private void AssignFrames()
        {
            if (LocalizationModel.UseLocalization && settings.LocalizedFrames.Count > 0)
            {
                Language current = LocalizationModel.CurrentLanguage;
                foreach (SpriteAnimationSettings.LocalizedAnimationFrames localizedFrame in settings.LocalizedFrames)
                {
                    if (localizedFrame.language == current)
                    {
                        frames = localizedFrame.frames;
                        return;
                    }
                }
                
                frames = settings.LocalizedFrames.FirstOrDefault()!.frames;
            }
            else
            {
                frames = settings.Frames;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/SpriteAnimation.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/AnimatedLineRenderer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 525e40ec00c34d28ad073c3cf314715a
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.UI.StepsFlow
{
    /// <summary>
    /// Handles animated line rendering using Unity's LineRenderer component.
    /// Supports animations for adding and removing points dynamically.
    /// </summary>
    [ExecuteAlways]
    [RequireComponent(typeof(LineRenderer))]
    public class AnimatedLineRenderer : MonoBehaviour
    {
        [SerializeField] private List<Transform> initialPoints = new List<Transform>();
        [SerializeField] private LineRenderer lineRenderer;
        [SerializeField] private float animationSpeed = 1f;
        [SerializeField] private bool updateEachFrame;
        [SerializeField] private bool delayOnEachNode;
        [SerializeField][ShowIf(nameof(delayOnEachNode), Op.Equals, true)][Min(0)]
        private float delayDurationOnEachNode = 0.1f;
        
        private readonly List<Transform> lineRendererPoints = new List<Transform>();
        private readonly List<Vector3> positions = new List<Vector3>();
        private bool isAnimating;
        private Transform animatingTransform;
        private int currentIndex = 0;
        private Tween animationTween;

        private void OnValidate()
        {
            initialPoints.Clear();
            foreach (Transform child in transform)
            {
                initialPoints.Add(child);
            }
        }

        private void Awake()
        {
            lineRenderer.positionCount = 0;
        }

        private void Start()
        {
#if UNITY_EDITOR
            if (!Application.isPlaying)
            {
                return;
            }
#endif
            if (animatingTransform == null)
            {
                animatingTransform = new GameObject("AnimatedLineRenderer: AnimatingTransform").transform;
            }
        }

        private void OnDestroy()
        {
            animationTween?.Kill();
            if (animatingTransform != null)
            {
                Destroy(animatingTransform.gameObject);
                animatingTransform = null;
            }
        }
        
        private void Update()
        {
#if UNITY_EDITOR
            if (!Application.isPlaying && lineRenderer != null)
            {
                lineRenderer.positionCount = initialPoints.Count;
                lineRenderer.SetPositions(initialPoints.Select(p => p.position).ToArray());
                return;
            }
#endif
            if (updateEachFrame && lineRendererPoints.Count > 0)
            {
                UpdatePositions();
            }
        }

        private void UpdatePositions()
        {
            positions.Clear();
            for (int i = 0; i < currentIndex + 1; i++)
            {
                positions.Add(lineRendererPoints[i].position);
            }

            if (isAnimating)
            {
                positions.Add(animatingTransform.position);
            }
            
            lineRenderer.positionCount = positions.Count;
            lineRenderer.SetPositions(positions.ToArray());
        }

        /// <summary>
        /// Animates the addition of line points to the LineRenderer, connecting the initial points and any additional targets.
        /// </summary>
        /// <param name="additionalTargets">Additional points to include in the animation.</param>
        public async UniTask AnimateAllLinePointsAsync(List<Transform> additionalTargets = null)
        {
            lineRendererPoints.AddRange(initialPoints);

            if (additionalTargets != null)
            {
                foreach (Transform target in additionalTargets)
                {
                    Transform point = new GameObject($"LinePoint: {lineRendererPoints.Count}").transform;
                    point.parent = transform;
                    point.position = target.position;
                    lineRendererPoints.Add(point);
                }
            }
            
            animationTween?.Kill();
            currentIndex = 0;
            UpdatePositions();
            
            for (int i = 1; i < lineRendererPoints.Count; i++)
            {
                if (!updateEachFrame)
                {
                    lineRenderer.positionCount += 1;
                }
                
                Vector3 startPosition = lineRendererPoints[i - 1].position;
                Vector3 endPosition = lineRendererPoints[i].position;
                await DoLineRendererPointMove(i, startPosition, endPosition);
                positions.Add(endPosition);
                currentIndex++;
            }
        }

        /// <summary>
        /// Animates the movement of a single line point between two positions.
        /// </summary>
        /// <param name="index">The index of the point in the LineRenderer.</param>
        /// <param name="startPosition">The starting position of the point.</param>
        /// <param name="endPosition">The target position of the point.</param>
        /// <returns>The animation Tween controlling the movement.</returns>
        private Tween DoLineRendererPointMove(int index, Vector3 startPosition, Vector3 endPosition)
        {
            isAnimating = true;
            int i = index;
            animatingTransform.position = startPosition;
            
            float distance = Vector3.Distance(startPosition, endPosition);
            float duration = distance / animationSpeed; 
            
            UpdatePositions();
            animationTween = animatingTransform.DOMove(endPosition, duration)
                .SetDelay(delayOnEachNode ? delayDurationOnEachNode : 0)
                .OnUpdate(() =>
                {
                    if (updateEachFrame)
                    {
                        UpdatePositions();
                    }
                    else
                    {
                        UpdateSpecificPosition(i, animatingTransform.position);
                    }
                })
                .OnComplete(() => isAnimating = false);
            return animationTween;
        }
        
        /// <summary>
        /// Updates the position of a specific point in the LineRenderer.
        /// </summary>
        /// <param name="index">The index of the point to update.</param>
        /// <param name="position">The new position of the point.</param>
        private void UpdateSpecificPosition(int index, Vector3 position)
        {
            lineRenderer.SetPosition(index, position);
        }

        /// <summary>
        /// Removes the last point from the LineRenderer with animation.
        /// </summary>
        public async UniTask RemoveLastLinePointAsync()
        {
            await RemoveLinePointsAsync(1);
        }

        /// <summary>
        /// Removes all points from the LineRenderer with animation.
        /// </summary>
        public async UniTask RemoveAllLinePointsAsync()
        {
            await RemoveLinePointsAsync(lineRendererPoints.Count);
        }

        /// <summary>
        /// Removes a specified number of points from the LineRenderer with animation.
        /// </summary>
        /// <param name="count">The number of points to remove.</param>
        private async UniTask RemoveLinePointsAsync(float count = 1)
        {
            float repeats = count;
            while (repeats > 0)
            {
                Transform pointToRemove = lineRendererPoints.LastOrDefault();
                lineRendererPoints.Remove(pointToRemove);
                Transform previous = lineRendererPoints.LastOrDefault();

                if (pointToRemove == null || previous == null)
                {
                    return;
                }

                int index = lineRendererPoints.Count;
                currentIndex--;
                await DoLineRendererPointMove(index, pointToRemove.position, previous.position);
                
                if (!initialPoints.Contains(pointToRemove))
                {
                    Destroy(pointToRemove.gameObject);
                }
                
                UpdatePositions();
                repeats--;
                
                if (lineRendererPoints.Count <= initialPoints.Count)
                {
                    repeats++;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/AnimatedLineRenderer.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/BaseStepElement.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d76c510ce60b4a72ac8e0071fc1acd5c
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Utilities.Serializable;
using Systems.UI;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Ldx.Framework.Systems.UI.StepsFlow
{
    /// <summary>
    /// Represents the base functionality for a step element in the Steps Flow UI.
    /// Handles alignment, animations, and title assignment.
    /// </summary>
    public class BaseStepElement : MonoBehaviour
    {
        private static readonly int FadeOutTriggerHash = Animator.StringToHash("FadeOut");
        
        [SerializeField] private RectTransform elementRect;
        public RectTransform ElementRect => elementRect;
        
        [SerializeField] private Canvas canvas;
        public Canvas Canvas => canvas;
        
        [SerializeField] protected Animator animator;
        
        [Space]
        [SerializeField] protected LocalizedTextUGUI titleText;
        
        [Serializable]
        public class ElementSetup
        {
            [Serializable]
            public class RectTransformValues
            {
                public bool useAnchoredOffset;
                public Vector2 anchoredOffsetMin;
                public Vector2 anchoredOffsetMax;
                
                public Vector3 localPosition;
                public Vector2 pivotPoint;
                public Vector2 anchorsMin;
                public Vector2 anchorsMax;
            }
            
            public SerializableDictionary<RectTransform, RectTransformValues> rectTransformValuesMap = new();
        }
        
        [Space]
        [Header("Editor")]
        [SerializeField]
        private SerializableDictionary<ElementAlignment, ElementSetup> elementAlignmentSetup = new();

        protected virtual void OnValidate()
        {
            if (animator == null)
            {
                animator = GetComponent<Animator>();
            }
        }

        protected virtual void OnDestroy() { }

        /// <summary>
        /// Assigns a title to the element using the provided text.
        /// </summary>
        /// <param name="title">The title to display on the element.</param>
        public void AssignTitle(string title)
        {
            titleText.SetString(title);
        }
        
        /// <summary>
        /// Hides the element
        /// </summary>
        /// <param name="instant"> If true, hides the element immediately without animation. </param>
        public async UniTask HideAsync(bool instant = false)
        {
            if (instant)
            {
                DisableGameObject();
            }
            else
            {
                // Will animate it out and then call DisableGameObject
                animator.SetTrigger(FadeOutTriggerHash);
                await UniTask.WaitUntil(() => gameObject != null && !gameObject.activeSelf);
            }
        }

        /// <summary>
        /// Disables the GameObject
        /// This method is also called from the animator when the FadeOut animation finishes.
        /// </summary>
        public void DisableGameObject()
        {
            gameObject.SetActive(false);
        }

        /// <summary>
        /// Shows the element by activating its GameObject.
        /// </summary>
        public void Show()
        {
            if (!gameObject.activeInHierarchy)
            {
                gameObject.SetActive(true);
            }
        }

#if UNITY_EDITOR
        
        /// <summary>
        /// Applies alignment settings in the Unity Editor based on the specified alignment.
        /// </summary>
        /// <param name="alignment">The alignment to apply to the element.</param>
        public void EDITOR_ApplyAlignment(ElementAlignment alignment)
        {
            if (elementAlignmentSetup.TryGetValue(alignment,
                    out ElementSetup elementSetup))
            {
                Undo.RecordObject(gameObject, $"Set {gameObject.name} alignment");
                foreach ((RectTransform target, ElementSetup.RectTransformValues values) in elementSetup.rectTransformValuesMap)
                {
                    target.pivot = values.pivotPoint;
                    target.anchorMin = values.anchorsMin;
                    target.anchorMax = values.anchorsMax;
                    
                    if (values.useAnchoredOffset)
                    {
                        target.offsetMin = values.anchoredOffsetMin;
                        target.offsetMax = values.anchoredOffsetMax;
                    }
                    else
                    {
                        target.localPosition = values.localPosition;
                    }
                }
                
                EditorUtility.SetDirty(gameObject);
            }
        }
        
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/BaseStepElement.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/CompletedStepElement.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5b20225b87f249a09e9d914c618ab336
# ASMDEF: ldx.framework.runtime.dll
# ---
namespace Ldx.Framework.Systems.UI.StepsFlow
{
    /// <summary>
    /// Represents a step element displayed as a completed step in the Steps Flow UI.
    /// Inherits functionality from the BaseStepElement class.
    /// </summary>
    public class CompletedStepElement : BaseStepElement
    {
        
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/CompletedStepElement.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/CurrentStepElement.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b687a8defbc5452c901f8199463918dc
# ASMDEF: ldx.framework.runtime.dll
# ---
using Cysharp.Threading.Tasks;
using DG.Tweening;
using Systems.Objectives.EventData;
using Systems.UI;
using UnityEngine;

namespace Ldx.Framework.Systems.UI.StepsFlow
{
    /// <summary>
    /// Represents the current step in the Steps Flow UI.
    /// Handles displaying, updating, and marking the current step as completed, along with progress management.
    /// </summary>
    public class CurrentStepElement : BaseStepElement
    {
        private static readonly int CompletedTriggerHash = Animator.StringToHash("Completed");
        private static readonly int HideElementsTriggerHash = Animator.StringToHash("Hide");

        [Space]
        [SerializeField]
        private LocalizedTextUGUI stepNumberText;

        [SerializeField]
        private LocalizedTextUGUI descriptionText;

        [SerializeField]
        private ProgressBar progressBar;

        [SerializeField]
        private Color originalColor;

        private StepInformation currentAssignedStepInfo;
        private bool completeAnimationFinished;
        private int currentOrder;
        private Tween progressTween;

        /// <summary>
        /// Indicates whether the variables for the current step have been updated.
        /// </summary>
        public bool IsVariablesUpdated { get; private set; }

        protected override void OnDestroy()
        {
            base.OnDestroy();
            progressTween?.Kill();
        }

        /// <summary>
        /// Displays the current step, initializing its data and resetting progress.
        /// </summary>
        /// <param name="stepInfo">The step information containing title, description, and progress method.</param>
        /// <param name="order">The order of the step in the sequence.</param>
        public async UniTask DisplayStepAsync(StepInformation stepInfo, int order)
        {
            IsVariablesUpdated = false;
            progressTween?.Kill();

            if (currentAssignedStepInfo != null)
            {
                animator.SetTrigger(HideElementsTriggerHash);
            }

            currentAssignedStepInfo = stepInfo;
            currentOrder = order;

            if (!gameObject.activeSelf)
            {
                gameObject.SetActive(true);
            }

            await UniTask.WaitUntil(() => IsVariablesUpdated);
        }

        /// <summary>
        /// Updates the variables for the current step, including colors, title, description, and progress tracking.
        /// </summary>
        private void UpdateVariables()
        {
            ResetColors();
            SetProgress(0, true).Forget();
            AssignTitle(currentAssignedStepInfo.StepTitle);
            descriptionText.SetString(currentAssignedStepInfo.StepDescription);
            stepNumberText.SetString(currentOrder.ToString());
            IsVariablesUpdated = true;
        }

        /// <summary>
        /// Marks the current step as completed, setting progress to 100% and playing the completion animation.
        /// </summary>
        /// <returns>A UniTask that completes when the completion animation finishes.</returns>
        public async UniTask MarkAsCompletedAsync()
        {
            SetProgress(1).Forget();
            animator.SetTrigger(CompletedTriggerHash);
            await UniTask.WaitUntil(() => completeAnimationFinished);
            completeAnimationFinished = false;
        }

        #region Animator Handlers

        /// <summary>
        /// Called by the animator when the completed animation finishes.
        /// </summary>
        private void HandleCompletedAnimationFinished()
        {
            completeAnimationFinished = true;
        }

        /// <summary>
        /// Called by the animator when the show animation starts, triggering variable updates.
        /// </summary>
        private void HandleShowAnimationStarted()
        {
            UpdateVariables();
        }

        /// <summary>
        /// Called by the animator when the hide animation finishes.
        /// Placeholder for future logic.
        /// </summary>
        private void HandleHideAnimationFinished() { }

        #endregion

        #region Progress Management

        /// <summary>
        /// Resets the color of the title text to its original color.
        /// </summary>
        private void ResetColors()
        {
            titleText.SetTextColor(originalColor);
        }

        /// <summary>
        /// Starts a progress timer that updates the progress bar over the specified duration.
        /// </summary>
        /// <param name="duration">The duration of the progress in seconds.</param>
        public void StartProgressTimer(float duration)
        {
            float progress = 0;
            progressTween?.Kill();
            progressTween = DOTween.To(x => progress = x, 0, 1, duration)
                .SetEase(Ease.Linear)
                .OnUpdate(() => SetProgress(progress, true).Forget());
        }

        /// <summary>
        /// Updates the progress bar to the specified progress value.
        /// </summary>
        /// <param name="progress">The progress value (0 to 1).</param>
        /// <param name="instant">If true, updates the progress bar immediately without animation.</param>
        public async UniTask SetProgress(float progress, bool instant = false)
        {
            await progressBar.SetProgress(progress, instant);
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/CurrentStepElement.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/FutureStepElement.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e249da74e6d448b08be67e9630d23c7e
# ASMDEF: ldx.framework.runtime.dll
# ---
using Systems.Objectives.EventData;
using Systems.UI;
using UnityEngine;

namespace Ldx.Framework.Systems.UI.StepsFlow
{
    /// <summary>
    /// Represents a step element displayed as a future step in the Steps Flow UI.
    /// </summary>
    public class FutureStepElement : BaseStepElement
    {
        [SerializeField] private RectTransform circleRectTransform;
        public RectTransform CircleRectTransform => circleRectTransform;
        
        [Space]
        [SerializeField] private LocalizedTextUGUI stepNumberText;

        /// <summary>
        /// Assigns data to the future step element, including step title and order number.
        /// </summary>
        /// <param name="stepInfo">The step information containing the title and other data.</param>
        /// <param name="order">The order of the step in the sequence.</param>
        public void AssignStepData(StepInformation stepInfo, int order)
        {
            stepNumberText.SetString(order.ToString());
            AssignTitle(stepInfo.StepTitle);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/FutureStepElement.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/ProgressBar.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1af5809148bb4328a40ea3f12a66f1c9
# ASMDEF: ldx.framework.runtime.dll
# ---
using Cysharp.Threading.Tasks;
using DG.Tweening;
using UnityEngine;

namespace Ldx.Framework.Systems.UI.StepsFlow
{
    public class ProgressBar : MonoBehaviour
    {
        [SerializeField] private RectTransform progressBarImage;
        [SerializeField] private CanvasGroup canvasGroup;
        
        public async UniTask SetProgress(float progress, bool instant = false)
        {
            await progressBarImage.DOScaleX(progress, instant ? 0 : .5f);
        }
        
        public Tween Fade(float alpha, float duration = 0.5f)
        {
            return canvasGroup.DOFade(alpha, duration);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/ProgressBar.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/StepsFlowDisplay.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 76b14d5a7e9049a2916876a955ddd1d0
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using Systems.Objectives.EventData;
using UnityEngine;

namespace Ldx.Framework.Systems.UI.StepsFlow
{
    public enum ElementAlignment
    {
        Left,
        Right
    }

    /// <summary>
    /// Manages the Steps Flow UI, including current, future, and completed steps.
    /// Handles animations and transitions between steps.
    /// </summary>
    [HelpURL(Constants.WIKI_ROOT + "2694217750/Steps+Flow+Display")]
    public class StepsFlowDisplay : MonoBehaviour
    {
        private const float WAIT_TIME_BEFORE_HIDE = 1f;
        private const float WIDTH_PERCENTAGE_DECREASE = 0.06f;
        private const float INITIAL_ANIMATION_DELAY = 0.6f;
        private const float STEP_REVEAL_DELAY = 0.3f;
        private const float FUTURE_ELEMENTS_MOVE_DELAY = 0.1f;
        private const float FUTURE_ELEMENTS_MOVE_DURATION = 0.3f;

        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingFeature)]
        private string displayID;
        public string DisplayID => displayID;

        [Space]
        [Header("Current")]
        [SerializeField] private ElementAlignment currentStepElementAlignment = ElementAlignment.Right;
        [HideInInspector]
        [SerializeField] private ElementAlignment previousCurrentStepElementAlignment = ElementAlignment.Right;
        [SerializeField] private CurrentStepElement currentStepElement;

        [Space]
        [Header("Next steps")]
        [SerializeField] private Transform futureStepsParent;
        [SerializeField] private FutureStepElement futureStepElementTemplate;
        [SerializeField] private ElementAlignment futureStepElementAlignment = ElementAlignment.Left;
        [HideInInspector]
        [SerializeField] private ElementAlignment previousFutureStepElementAlignment = ElementAlignment.Left;
        [Range(0.0001f, 1f)]
        [SerializeField] private float verticalOffsetBetweenFutureSteps = 0.2f;
        [Range(0, 180f)]
        [SerializeField] private float futureStepsRotationAngle = 40f;

        [Space]
        [Header("Completed steps")]
        [SerializeField] private Transform completedStepsParent;
        [SerializeField] private CompletedStepElement completedStepElementTemplate; 
        [Range(0.0001f, 1f)]
        [SerializeField] private float verticalOffsetBetweenCompletedSteps = 0.2f;

        [Space]
        [Header("Line")]
        [SerializeField] private AnimatedLineRenderer animatedLineRenderer;

        [Serializable]
        public class TransformIDAnimationLineSet
        {
            [IDSelection(LdxIdSettings.IdType.Transform)]
            public string animatedAttentionLineId;
            public AnimatedLineRenderer animatedLineRenderer;
        }
        
        [SerializeField]
        private List<TransformIDAnimationLineSet> transformIDAnimationLineSets = new List<TransformIDAnimationLineSet>();
        
        private readonly List<string> stepsIds = new();
        private readonly List<FutureStepElement> futureStepElements = new();
        private readonly List<CompletedStepElement> completedStepElements = new();
        
        private StepInformation currentStepInfo;
        private StepFlowInformation currentFlowInformation;
        private List<StepInformation> steps = new();

        private int initialTrackingEventsCount;
        private string completeStepFlowEvent;
        private List<string> progressTrackingEvents = new();
        
        private int currentIndex;
        private Tween progressTween;
        private readonly Dictionary<string, AnimatedLineRenderer> transformIDAnimationLineRenderersMap = new();
        private AnimatedLineRenderer currentAttentionLine;
        private AudioClip currentStepVO;

        private Vector3 completedElementStartPosition;
        private Quaternion completedElementStartRotation;
        private float completedElementOriginalWidth;

        private void OnValidate()
        {
#if UNITY_EDITOR
            if (previousCurrentStepElementAlignment != currentStepElementAlignment)
            {
                previousCurrentStepElementAlignment = currentStepElementAlignment;
                currentStepElement.EDITOR_ApplyAlignment(currentStepElementAlignment);
            }

            if (previousFutureStepElementAlignment != futureStepElementAlignment)
            {
                previousFutureStepElementAlignment = futureStepElementAlignment;
                futureStepElementTemplate.EDITOR_ApplyAlignment(futureStepElementAlignment);
            }
            
            futureStepsParent.transform.localRotation = Quaternion.Euler(futureStepsParent.transform.localRotation.eulerAngles.Modify(x: -futureStepsRotationAngle));
#endif
        }

        private void Start()
        {
            LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;

            transformIDAnimationLineRenderersMap.Clear();
            foreach (TransformIDAnimationLineSet lineSet in transformIDAnimationLineSets)
            {
                transformIDAnimationLineRenderersMap.Add(lineSet.animatedAttentionLineId, lineSet.animatedLineRenderer);
            }

            HideAsync(true).Forget();

            completedElementStartPosition = completedStepElementTemplate.transform.localPosition;
            completedElementStartRotation = completedStepElementTemplate.transform.localRotation;
            completedElementOriginalWidth = completedStepElementTemplate.ElementRect.rect.width;
        }

        private void OnDestroy()
        {
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }

            progressTween?.Kill();
        }
        
        #region Event Handlers

        /// <summary>
        /// Handles tracking events and updates the progress of the current step.
        /// </summary>
        /// <param name="id">The ID of the tracking event.</param>
        private void HandleTrackingEvent(string id)
        {
            if (currentStepInfo != null)
            {
                if (progressTrackingEvents.Contains(id))
                {
                    progressTrackingEvents.Remove(id);
                    ProcessCurrentStepProgress();
                    
                    if (progressTrackingEvents.Count < 1)
                    {
                        CompleteStepAsync().Forget();
                    }
                }
                else if (completeStepFlowEvent == id)
                {
                    CompleteStepAsync().Forget();
                }
            }
        }
        
        #endregion

        #region Setup

        /// <summary>
        /// Initializes the steps flow with a list of steps to display and tracks their IDs.
        /// Sets up the internal state to manage the progression through the steps.
        /// </summary>
        /// <param name="stepsInformation">A list of step information objects containing step data.</param>
        public void SetupStepsFlow(List<StepInformation> stepsInformation)
        {
            currentIndex = 0;
            steps = stepsInformation;
            stepsIds.Clear();
            foreach (StepInformation stepInformation in steps)
            {
                stepsIds.Add(stepInformation.StepID);
            }
        }

        #endregion
        
        #region Step Management
        
        /// <summary>
        /// Transitions to a specific step flow by matching the provided step ID.
        /// If the flow is starting, it initializes the steps. If already in progress, it moves to the next step.
        /// </summary>
        /// <param name="stepFlowInformation">The information about the step flow to transition to.</param>
        public void TransitionToStepFlow(StepFlowInformation stepFlowInformation)
        {
            if (!stepsIds.Contains(stepFlowInformation.StepID))
            {
                return;
            }
            
            if (stepsIds[0] == stepFlowInformation.StepID)
            {
                PopulateNextSteps();
                PopulateCompletedSteps();
                StartFirstShowAnimationAsync(stepFlowInformation).Forget();
            }
            else
            {
                //Then it should be already in progress, so do the next step
                ProcessNextStep(stepFlowInformation).Forget();
            }
        }
        
        /// <summary>
        /// Sets up the UI elements for future steps in the flow, creating and positioning elements
        /// for all steps after the current one.
        /// </summary>
        private void PopulateNextSteps()
        {
            if (steps.Count > 1)
            {
                for (int i = 1; i < steps.Count; i++)
                {
                    FutureStepElement nextBaseStepElement =
                        i == 1 ? futureStepElementTemplate : InstantiateNextStepElement(futureStepElements[i - 2]);
                    futureStepElements.Add(nextBaseStepElement);
                    nextBaseStepElement.AssignStepData(steps[i], i + 1);
                }
            }
        }
        
        /// <summary>
        /// Populates the list of completed steps based on the provided steps data.
        /// </summary>
        private void PopulateCompletedSteps()
        {
            if (steps.Count > 1)
            {
                for (int i = 0; i < steps.Count - 1; i++)
                {
                    CompletedStepElement completedBaseStepElement = i == 0
                        ? completedStepElementTemplate
                        : InstantiateCompletedStepElement(completedStepElementTemplate);
                    completedStepElements.Add(completedBaseStepElement);
                    completedBaseStepElement.AssignTitle(steps[i].StepTitle);
                    completedBaseStepElement.Canvas.sortingOrder =
                        currentStepElement.Canvas.sortingOrder - (steps.Count - 1 - i);
                }
            }
        }
        
        #endregion
        
        #region Step Instantiation
        
        /// <summary>
        /// Instantiates a new future step element relative to the position of the previous step element.
        /// </summary>
        /// <param name="prevElement">The previous future step element.</param>
        /// <returns>The newly instantiated future step element.</returns>
        private FutureStepElement InstantiateNextStepElement(FutureStepElement prevElement)
        {
            FutureStepElement element = Instantiate(futureStepElementTemplate, futureStepsParent);
            element.transform.position = prevElement.transform.position + prevElement.transform.rotation *
                (Vector3.down * verticalOffsetBetweenFutureSteps);
            return element;
        }

        /// <summary>
        /// Instantiates a new completed step element relative to the position of the previous completed step element.
        /// </summary>
        /// <param name="prevElement">The previous completed step element.</param>
        /// <returns>The newly instantiated completed step element.</returns>
        private CompletedStepElement InstantiateCompletedStepElement(CompletedStepElement prevElement)
        {
            CompletedStepElement element = Instantiate(completedStepElementTemplate, completedStepsParent);
            element.transform.position = prevElement.transform.position;
            return element;
        }
        
        #endregion
        
        #region Animation Handling
        
        /// <summary>
        /// Starts the initial animation sequence for displaying the steps and animating the connecting line.
        /// </summary>
        /// <returns>A UniTask that represents the asynchronous operation.</returns>
        private async UniTask StartFirstShowAnimationAsync(StepFlowInformation current)
        {
            SetupCurrentStepElementAsync(current).Forget();
            await UniTask.Delay(INITIAL_ANIMATION_DELAY.ToMilliseconds());

            await animatedLineRenderer.AnimateAllLinePointsAsync(futureStepElements
                .Select(x => x.CircleRectTransform.transform).ToList());

            foreach (FutureStepElement nextStepElement in futureStepElements)
            {
                nextStepElement.Show();
                await UniTask.Delay(STEP_REVEAL_DELAY.ToMilliseconds());
            }

            await AnimateAttentionLineAsync();
            BroadcastShowAnimationCompletedEvent();
        }
        
        /// <summary>
        /// Animates the transition of future steps as the current step progresses.
        /// </summary>
        /// <returns>A UniTask that represents the asynchronous operation.</returns>
        private async UniTask AnimateFutureStepsAsync()
        {
            if (currentIndex < 1)
            {
                return;
            }
            
            FutureStepElement elementToHide = futureStepElements[currentIndex - 1];
            await elementToHide.HideAsync();

            Sequence moveSequence = DOTween.Sequence();

            float delay = 0;
            for (int i = currentIndex; i < futureStepElements.Count; i++)
            {
                moveSequence.Join(futureStepElements[i].transform.DOMove(futureStepElements[i - 1].transform.position, FUTURE_ELEMENTS_MOVE_DURATION).SetDelay(delay));
                delay += FUTURE_ELEMENTS_MOVE_DELAY;
            }

            animatedLineRenderer.RemoveLastLinePointAsync().Forget();

            await moveSequence;
        }
        
        /// <summary>
        /// Animates the transition of completed steps when a new step is completed.
        /// </summary>
        private async UniTask AnimateCompletedStepsAsync()
        {
            if (currentIndex < 1)
            {
                return;
            }

            Sequence moveSequence = DOTween.Sequence();
            for (int i = 0; i < currentIndex; i++)
            {
                completedStepElements[i].Show();
                Vector3 offset = Vector2.up * verticalOffsetBetweenCompletedSteps * (currentIndex - 1 - i);
                Vector3 newPosition = completedElementStartPosition + completedElementStartRotation * offset;
                moveSequence.Join(completedStepElements[i].transform.DOLocalMove(newPosition, 0.5f));

                Vector2 newSize = new Vector2(
                    completedElementOriginalWidth - (completedElementOriginalWidth *
                                                     (WIDTH_PERCENTAGE_DECREASE * (currentIndex - 1 - i))),
                    completedStepElements[i].ElementRect.rect.height);
                moveSequence.Join(completedStepElements[i].ElementRect.DOSizeDelta(newSize, 0.3f));
            }

            await moveSequence;
        }
        
        #endregion

        #region Step Processing
        
        /// <summary>
        /// Sets up the current step element with its data and initializes animations.
        /// </summary>
        private async UniTask SetupCurrentStepElementAsync(StepFlowInformation current)
        {
            StepFlowInformation previousFlowInfo = currentFlowInformation;
            
            if (previousFlowInfo != null)
            {
                BroadcastHideAnimationCompletedEvent(previousFlowInfo.MarkAsCompletedAnimationCompletedEvent);
            }
            
            currentStepInfo = steps[currentIndex];
            currentFlowInformation = current;
            completeStepFlowEvent = currentFlowInformation.CompleteFlowStepOnEvent;
            progressTrackingEvents = currentFlowInformation.EventsToTrackProgress.ToList();
            initialTrackingEventsCount = progressTrackingEvents.Count;
            await currentStepElement.DisplayStepAsync(currentStepInfo, currentIndex + 1);

            if (currentFlowInformation.ProgressMethod is ProgressTrackMethod.Duration)
            {
                currentStepElement.StartProgressTimer(currentFlowInformation.ProgressDuration);
            }

            currentStepVO = GetCurrentStepVO();
            PlayDialogueAudioForCurrentStep();
        }

        /// <summary>
        /// Animates the attention line associated with the current step, if available.
        /// </summary>
        private async UniTask AnimateAttentionLineAsync()
        {
            if (!string.IsNullOrEmpty(currentFlowInformation.AnimatedAttentionLineId) && 
                transformIDAnimationLineRenderersMap.TryGetValue(currentFlowInformation.AnimatedAttentionLineId,
                    out currentAttentionLine))
            {
                await currentAttentionLine.AnimateAllLinePointsAsync();
            }
        }

        /// <summary>
        /// Broadcasts a tracking event to indicate that the show animation for the current step has completed.
        /// </summary>
        private void BroadcastShowAnimationCompletedEvent()
        {
            LdxTrackingManager.Instance.BroadcastTrackingEvent(currentFlowInformation.ShowAnimationCompletedEvent);
        }
        
        /// <summary>
        /// Broadcasts a tracking event to indicate that the hide animation for the current step has completed.
        /// </summary>
        /// <param name="hideEvent"> The event identifier to broadcast for the completed hide animation. </param>
        private void BroadcastHideAnimationCompletedEvent(string hideEvent)
        {
            LdxTrackingManager.Instance.BroadcastTrackingEvent(hideEvent);
            currentFlowInformation = null;
        }

        /// <summary>
        /// Handles progress for the current step and transitions to the next step when completed.
        /// </summary>
        private void ProcessCurrentStepProgress()
        {
            if (progressTrackingEvents.Count > 0)
            {
                if (currentFlowInformation.ProgressMethod is ProgressTrackMethod.TrackingEvents)
                {
                    currentStepElement.SetProgress(1f - (float)progressTrackingEvents.Count/initialTrackingEventsCount).Forget();
                }
            }
        }

        /// <summary>
        /// Marks the current step as completed and transitions to the next step or hides the flow if all steps are complete.
        /// </summary>
        private async UniTask CompleteStepAsync()
        {
            if (currentAttentionLine != null)
            {
                await currentAttentionLine.RemoveAllLinePointsAsync();
            }

            await currentStepElement.MarkAsCompletedAsync();
            BroadcastHideAnimationCompletedEvent(currentFlowInformation.MarkAsCompletedAnimationCompletedEvent);
            
            if (currentIndex + 1 >= steps.Count)
            {
                await UniTask.Delay(WAIT_TIME_BEFORE_HIDE.ToMilliseconds());
                await HideAsync();
            }
        }
        
        /// <summary>
        /// Handles the transition to the next step, including animations and setup.
        /// </summary>
        private async UniTask ProcessNextStep(StepFlowInformation current)
        {
            currentIndex++;

            if (currentIndex >= steps.Count)
            { 
                return;
            }
            
            await AnimateFutureStepsAsync();
            await SetupCurrentStepElementAsync(current);
            await AnimateAttentionLineAsync();
            BroadcastShowAnimationCompletedEvent();
            await AnimateCompletedStepsAsync();
        }
        
        #endregion
        
        #region Hide Logic
        
        /// <summary>
        /// Hides all UI elements in the Steps Flow display.
        /// </summary>
        /// <param name="instantly"> If true, all elements are hidden immediately without animations. </param>
        private async UniTask HideAsync(bool instantly = false)
        {
            futureStepElementTemplate.HideAsync(instantly).Forget();
            animatedLineRenderer.RemoveAllLinePointsAsync().Forget();
            
            await completedStepElementTemplate.HideAsync(instantly);
            foreach (CompletedStepElement completedStepElement in completedStepElements)
            {
                if (completedStepElement == completedStepElementTemplate)
                {
                    continue;
                }
                
                await completedStepElement.HideAsync(instantly);
            }
            
            await currentStepElement.HideAsync(instantly);

            foreach (AnimatedLineRenderer attentionLineRenderer in transformIDAnimationLineRenderersMap.Values)
            {
                attentionLineRenderer.RemoveLastLinePointAsync().Forget();
            }
        }
        
        #endregion
        
        #region Dialog Audio

        /// <summary>
        /// Plays the dialogue audio for the current step using the associated audio clip.
        /// Stops any previously playing audio before starting the new one.
        /// </summary>
        private void PlayDialogueAudioForCurrentStep()
        {
            if (currentStepVO == null)
            {
                return;
            }
            
            Audio.PlayDialogue(currentStepVO);
        }

        /// <summary>
        /// Retrieves the audio clip for the current step based on the active language.
        /// </summary>
        /// <returns> The AudioClip for the current step if available, or null if no matching clip is found. </returns>
        private AudioClip GetCurrentStepVO()
        {
            if (currentStepInfo.AudioClips is { Count: > 0 })
            {
                return currentStepInfo.AudioClips.FirstOrDefault(c => c.Language == LocalizationModel.CurrentLanguage)
                    ?.AudioClip;
            }

            return null;
        }

        #endregion
        
#if UNITY_EDITOR
        private void OnDrawGizmosSelected()
        {
            if (!futureStepElementTemplate || !completedStepElementTemplate) return;
            
            Gizmos.color = Color.cyan;
            Matrix4x4 futureMatrix = Matrix4x4.TRS(CalculateFutureOffset(), futureStepsParent.rotation, Vector3.one);
            Gizmos.matrix = futureMatrix;
            Gizmos.DrawWireCube(Vector3.zero, GetElementSize(futureStepElementTemplate.ElementRect));
            Gizmos.matrix = Matrix4x4.identity;
            
            Gizmos.color = Color.green;
            Matrix4x4 completedMatrix = Matrix4x4.TRS(CalculateCompletedOffset(), completedStepElementTemplate.transform.rotation, Vector3.one);
            Gizmos.matrix = completedMatrix;
            Gizmos.DrawWireCube(Vector3.zero, GetElementSize(completedStepElementTemplate.ElementRect));
            Gizmos.matrix = Matrix4x4.identity;
        }
        
        /// <summary>
        /// Calculates the position for the next future step element based on the vertical offset and alignment.
        /// </summary>
        /// <returns>The adjusted position as a Vector3.</returns>
        private Vector3 CalculateFutureOffset()
        {
            Vector3 basePosition = futureStepElementTemplate.transform.position;
            Quaternion parentRotation = futureStepsParent.transform.rotation;
            Vector3 verticalOffset = parentRotation * (Vector3.down * verticalOffsetBetweenFutureSteps);

            // Adjust for left or right alignment by considering the RectTransform's pivot
            float alignmentOffset = futureStepElementTemplate.ElementRect.rect.width * 
                                    (futureStepElementTemplate.ElementRect.pivot.x - 0.5f) * 
                                    futureStepElementTemplate.ElementRect.localScale.x;

            Vector3 horizontalOffset = parentRotation * (Vector3.right * alignmentOffset);
            return basePosition + verticalOffset + horizontalOffset;
        }

        /// <summary>
        /// Calculates the position for the next completed step element based on the vertical offset.
        /// </summary>
        /// <returns>The new position as a Vector3.</returns>
        private Vector3 CalculateCompletedOffset()
        {
            return completedStepElementTemplate.transform.position +
                   completedStepElementTemplate.transform.rotation * (Vector3.up * verticalOffsetBetweenCompletedSteps);
        }
        
        /// <summary>
        /// Calculates the size of a UI element based on its RectTransform and local scale.
        /// </summary>
        /// <param name="rectTransform">The RectTransform of the UI element.</param>
        /// <returns>A Vector3 representing the width and height of the element in world space.</returns>
        private Vector3 GetElementSize(RectTransform rectTransform)
        {
            if (rectTransform == null)
            {
                Debug.LogWarning("RectTransform is null. Returning default size.");
                return Vector3.zero;
            }

            // Calculate the size in local space and scale it by the element's local scale
            Vector3 size = new Vector3(
                rectTransform.rect.width * rectTransform.localScale.x,
                rectTransform.rect.height * rectTransform.localScale.y,
                0
            );

            return size;
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/StepsFlowDisplay.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/StepsFlowEventsTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0e4d9aa561064b55ba13411a5c4534bb
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using Systems.Objectives.EventData;
using UnityEngine; 

namespace Ldx.Framework.Systems.UI.StepsFlow
{
    public class StepsFlowEventsTracker : MonoBehaviour
    { 
        [SerializeField] [ReadOnly]
        private List<StepsFlowDisplay> stepsFlowDisplays = new();

        private readonly Dictionary<string, StepsFlowDisplay> stepsFlowDisplayMap = new();
        private readonly Dictionary<string, StepsFlowDisplay> stepsIdToFlowDisplayMap = new();

        private void OnValidate()
        {
            stepsFlowDisplays = FindObjectsByType<StepsFlowDisplay>(FindObjectsSortMode.None).ToList();
        } 

        private void Awake()
        {
            InitMap();
        }
        
        private void Start()
        {
            LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
        }

        private void OnDestroy()
        {
            if (LdxTrackingManager.IsValid)  
            {
                LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
            }
        }

        private void InitMap()
        {
            stepsFlowDisplays = FindObjectsByType<StepsFlowDisplay>(FindObjectsSortMode.None).ToList();
            stepsFlowDisplayMap.Clear();
            foreach (StepsFlowDisplay flowDisplay in stepsFlowDisplays)
            {
                if (string.IsNullOrEmpty(flowDisplay.DisplayID))
                {
                    continue;
                }
                
                stepsFlowDisplayMap.Add(flowDisplay.DisplayID, flowDisplay);
            }
        }

        private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
        {
            switch (eventData)
            {
                case SetupStepsFlowDisplay data:
                    if (string.IsNullOrEmpty(data.DisplayID))
                    {
                        return;
                    }

                    if (TryGetStepsFlowDisplayByDisplayID(data.DisplayID, out StepsFlowDisplay flowDisplay))
                    {
                        flowDisplay.SetupStepsFlow(data.StepsInformationContainer.ToList());

                        foreach (StepInformation information in data.StepsInformationContainer)
                        {
                            stepsIdToFlowDisplayMap.TryAdd(information.StepID, flowDisplay);
                        }
                    }
                    break;
                case TransitionToStepFlow data:
                    StepFlowInformation flowInformation = new(data);
                    if (string.IsNullOrEmpty(flowInformation.StepID))
                    {
                        return;
                    }

                    if (TryGetStepsFlowDisplayByStepID(flowInformation.StepID, out StepsFlowDisplay display))
                    {
                        display.TransitionToStepFlow(flowInformation);
                    }
                    break;
            }
        }

        private bool TryGetStepsFlowDisplayByDisplayID(string displayID, out StepsFlowDisplay display)
        {
            if (stepsFlowDisplayMap.TryGetValue(displayID, out display))
            {
                return true;
            }

            return false;
        }
        
        private bool TryGetStepsFlowDisplayByStepID(string stepID, out StepsFlowDisplay display)
        {
            if (stepsIdToFlowDisplayMap.TryGetValue(stepID, out display))
            {
                return true;
            }

            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/StepsFlow/StepsFlowEventsTracker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIAnchor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 42253892267341df9e20b4b4eb77d93f
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.UI.Dialog
{
	[ExecuteInEditMode]
	public class UIAnchor : MonoBehaviour, ISerializationCallbackReceiver
	{
		#if LDX_CONTROLLER_FREE_UL
		[SerializeField] private bool isCameraAnchor;
		public bool IsCameraAnchor => isCameraAnchor;
		#endif
		[SerializeField] private bool matchCameraY = true;
		public bool MatchCameraY => matchCameraY;

		[SerializeField, Range(0.1f, 1f)] private float scale = 1f;
		public float Scale => scale;

		private static PlayerStartPoint playerStartPoint;

		private static PlayerStartPoint PlayerStartPoint
		{
			get
			{
				if (playerStartPoint == null)
				{
					playerStartPoint = FindAnyObjectByType<PlayerStartPoint>();
				}

				return playerStartPoint;
			}
		}

		private void OnValidate()
		{
			if (scale == 0)
			{
				scale = 1;
			}

			transform.localScale = new Vector3(scale, scale, scale);
		}

		private void Start()
		{
			// In controller-free, the anchor controller exists in the bootstrapper. Because we have a separation of scenes,
			// We now must attempt to add ourselves to the UiAnchorController, because the scene will be loaded after the bootstrapper.
			// The anchor controller will handle it's own on awake, so this should avoid null or missing anchors.
			#if LDX_CONTROLLER_FREE_UL
			UIAnchorController.Instance.TryAddAnchor(this);
			#endif
		}

		private void Update()
		{
			if (Application.isPlaying || !matchCameraY)
			{
				return;
			}

			if (transform.hasChanged && PlayerStartPoint != null)
			{
				transform.position = transform.position.Modify(y: PlayerStartPoint.GetCameraPosition().y);
			}
		}

		public void OnBeforeSerialize()
		{
			if (this == null)
			{
				return;
			}

			int i = 0;
			
			if (transform.parent != null)
				foreach (Transform t in transform.parent)
				{
					if (t == transform)
					{
						#if !LDX_CONTROLLER_FREE_UL
                    name = $"Anchor {i}";
                    return;
						#endif
					}

					i++;
				}
		}

		public void OnAfterDeserialize()
		{
		}

		#if UNITY_EDITOR
        public void OnDrawGizmosSelected()
        {
            var controller = GetComponentInParent<UIAnchorController>();
            if (controller == null)
            {
                return;
            }
            controller.OnDrawGizmosSelected();
        }

        public void DrawSphereGizmo()
        {
            Gizmos.color = Color.yellow;
            Gizmos.DrawWireSphere(transform.position, 0.2f * scale);
        }
		#endif
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIAnchor.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIAnchorController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ff544ba18bf54330a3d7d6d208ccd3f2
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.UI.Dialog
{
	/// <summary>
	/// Places and retrieves anchors in the world
	/// Useful for any visual elements
	/// </summary>
#if !LDX_CONTROLLER_FREE_UL
	[SceneSetupLink(SceneSetupLinkGroup.Essential)]
#else
	[SceneSetupLink]
#endif
	public class UIAnchorController : Singleton<UIAnchorController>, ISaveSceneListener, IAnchorParent
	{
		public enum AnchorType
		{
			AnchorPoint = 0,
			AnchorGroup
		}

		[SerializeField] private List<UIAnchor> anchors = new List<UIAnchor>();
		public List<UIAnchor> Anchors => anchors;

		[SerializeField] private List<UIAnchorGroup> anchorGroups = new List<UIAnchorGroup>();


		[SerializeField] private AnchorType anchorType = AnchorType.AnchorPoint;
		public AnchorType CurrentAnchorType => anchorType;

		private Transform overridenCameraTransform;

		public UIAnchorGroup CurrentAnchorGroup { get; private set; }

		private Transform CameraTransform => GetCameraTransform();
		private RaycastHit[] hits;

		protected override void Awake()
		{
			base.Awake();

			if (anchorType == AnchorType.AnchorGroup)
			{
				MoveAnchorsToAnchorGroupParent();
				foreach (UIAnchorGroup anchorGroup in anchorGroups)
				{
					anchorGroup.gameObject.SetActive(false);
				}

				UIAnchorGroup activeAnchorGroup = anchorGroups[0];
				activeAnchorGroup.gameObject.SetActive(true);
				CurrentAnchorGroup = activeAnchorGroup;
			}
			else if (anchorType == AnchorType.AnchorPoint)
			{
				#if LDX_CONTROLLER_FREE_UL
				// Since the anchor controller is in the bootstrapper for controller-free, we need to be able to
				// add the first anchor, then we'll grab any additional. We might need to create an override
				// within the scene that will add them on scene load as well.
				if (anchors.Count != 0)
				{
					List<UIAnchor> anchorCache = GetComponentsInChildren<UIAnchor>().ToList();

					foreach (UIAnchor anchor in anchorCache)
					{
						TryAddAnchor(anchor);
					}
				}

				#else
                anchors = GetComponentsInChildren<UIAnchor>().ToList();
				#endif
			}
		}


		public UIAnchor GetNearestAnchor(float distance)
		{
			if (CameraTransform == null)
			{
				return null;
			}

			Vector3 targetPosition = CameraTransform.position + distance * CameraTransform.forward;

			switch (anchorType)
			{
				case AnchorType.AnchorPoint:
					return anchors
						.Where(anchor => anchor.gameObject.activeInHierarchy)
						.OrderBy(anchorPoint => (anchorPoint.transform.position - targetPosition).sqrMagnitude)
						.FirstOrDefault();
				case AnchorType.AnchorGroup:
					return CurrentAnchorGroup.AnchorPoints
						.OrderBy(anchorPoint => (anchorPoint.transform.position - targetPosition).sqrMagnitude)
						.FirstOrDefault();
				default:
					throw new ArgumentOutOfRangeException();
			}
		}

		public void OnSceneSaving()
		{
			if (anchorType == AnchorType.AnchorGroup)
			{
				MoveAnchorsToAnchorGroupParent();
			}
		}

		private void MoveAnchorsToAnchorGroupParent()
		{
			UIAnchor[] anchors = GetComponentsInChildren<UIAnchor>();

			if (anchorGroups.Count == 0 && anchors.Length > 0)
			{
				var o = new GameObject();
				o.transform.SetParent(transform);
				var anchorGroup = o.AddComponent<UIAnchorGroup>();
				anchorGroup.name = "Basic anchor group";
				anchorGroups.Add(anchorGroup);

				foreach (UIAnchor anchor in anchors)
				{
					anchorGroup.AnchorPoints.Add(anchor);
					anchor.transform.SetParent(anchorGroup.transform);
				}
			}
		}

		public void TryAddAnchor(UIAnchor anchor)
		{
			if (!anchors.Contains(anchor))
			{
				anchors.Add(anchor);
			} 
			else if (anchors.Contains(anchor) && anchor == null)
			{
				anchors.Remove(anchor);
			}
		}

		public void RefreshAnchorsList()
		{
			anchors = GetComponentsInChildren<UIAnchor>().ToList();
		}

		public void OverrideCameraTransform(Transform newCameraTransform)
		{
			overridenCameraTransform = newCameraTransform;
		}

		private Transform GetCameraTransform()
		{
			if (overridenCameraTransform != null)
			{
				return overridenCameraTransform;
			}

			PlayerController player = PlayerController.Instance;
			if (player == null)
			{
				return null;
			}

			return player.MainCamera.transform;
		}

		#if UNITY_EDITOR
        public void EDITOR_AddAnchor()
        {
            var o = new GameObject();
            o.transform.SetParent(transform);
            var anchor = o.AddComponent<UIAnchor>();
            if (anchors.Count > 0)
            {
                o.transform.position = anchors.Last().transform.position;
            }

            UnityEditor.Selection.activeObject = o;
            anchors.Add(anchor);
        }

        public void EDITOR_AddAnchorGroup()
        {
            var o = new GameObject();
            o.transform.SetParent(transform);
            var anchorGroup = o.AddComponent<UIAnchorGroup>();
            anchorGroup.name = "New Anchor Group";

            UnityEditor.Selection.activeObject = o;
            anchorGroups.Add(anchorGroup);
        }
        
        public void OnDrawGizmosSelected()
        {
            if (anchorType == AnchorType.AnchorGroup)
            {
                return;
            }
            
            foreach (var p in anchors)
            {
                if (p == null)
                {
                    continue;
                }
                p.DrawSphereGizmo();
            }
        }
		#endif
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIAnchorController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIAnchorGroup.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: aad3ca00849ba7743bf9b82a3dc479e8
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Utilities;
using UnityEngine;
using Ldx.Framework.Utilities.Attributes;

namespace Ldx.Framework.UI.Dialog
{
    [TrackedReference]
    public class UIAnchorGroup : MonoBehaviour, ISaveSceneListener, IAnchorParent
    {
        [SerializeField] 
        private string anchorGroup;
        public string AnchorGroup => anchorGroup;
        
        [SerializeField]
        private List<UIAnchor> anchorPoints = new List<UIAnchor>();
        public List<UIAnchor> AnchorPoints => anchorPoints;
        
        public float MaxAnchorY { get; private set; }

        private void Awake()
        {
            for (var i = anchorPoints.Count - 1; i >= 0; i--)
            {
                if (anchorPoints[i] == null)
                {
                    anchorPoints.RemoveAt(i);
                    continue;
                }

                MaxAnchorY = anchorPoints[i].transform.position.y;
            }
        }
        
#if UNITY_EDITOR
        public void OnDrawGizmosSelected()
        {
            foreach (var p in anchorPoints)
            {
                if (p == null)
                {
                    continue;
                }
                p.DrawSphereGizmo();
            }
        }
#endif
        public void OnSceneSaving()
        {
            anchorPoints = GetComponentsInChildren<UIAnchor>().ToList();
#if UNITY_EDITOR
            UnityEditor.EditorUtility.SetDirty(this);
#endif
        }

#if UNITY_EDITOR
        public void EDITOR_AddAnchor()
        {
            var o = new GameObject();
            o.transform.SetParent(transform);
            var anchor = o.AddComponent<UIAnchor>();
            if (anchorPoints.Count > 0)
            {
                o.transform.position = anchorPoints.Last().transform.position;
            }

            UnityEditor.Selection.activeObject = o;
            anchorPoints.Add(anchor);
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIAnchorGroup.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIArrowPointToTarget.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 25cb5e460158b47438735881275904fd
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

public class UIArrowPointToTarget : MonoBehaviour
{
    [Header("References")]
    [SerializeField]
    private RectTransform subtitleRect;
    [SerializeField]
    private RectTransform arrowRect;
    [SerializeField]
    private Transform target;
    [SerializeField]
    private Canvas canvas;

    [Header("Behavior")]
    [Min(0f)]
    [Tooltip("Pixels to keep the arrow outside the subtitle perimeter (also the corner radius).")]
    [SerializeField]
    private float buffer = 24f;
    
    [Header("Visual")]
    [Tooltip("Extra Z-rotation in degrees to match your sprites forward direction. 0 if sprite points up, -90 if it points right.")]
    [SerializeField]
    private float spriteRotationOffset = 0f;

    private void LateUpdate()
    {
        UpdateArrow();
    }

    public void SetTarget(Transform newTarget)
    {
        target = newTarget;
    }

    public void UpdateArrow()
    {
        if (subtitleRect == null || arrowRect == null || canvas == null)
            return;

        if (target == null)
        {
            if (arrowRect.gameObject.activeSelf)
                arrowRect.gameObject.SetActive(false);
            return;
        }

        // Local space relative to rect center
        Vector2 rectCenterPosition = subtitleRect.rect.center;
        Vector3 localTargetPosition = subtitleRect.InverseTransformPoint(target.position) - (Vector3)rectCenterPosition;

        Vector2 half = subtitleRect.rect.size * 0.5f;

        // Compute position and outward normal for arrow
        bool arrowShouldShow = GetPointAndNormalOnCorrectEdgeOfRect(localTargetPosition, half, buffer, out Vector2 pointLocalPosition, out Vector2 normal);
        if (!arrowShouldShow)
        {
            if (arrowRect.gameObject.activeSelf)
                arrowRect.gameObject.SetActive(false);
            return;
        }
        if (!arrowRect.gameObject.activeSelf)
            arrowRect.gameObject.SetActive(true);
            

        // To world
        Vector3 desiredWorldPos = subtitleRect.TransformPoint(pointLocalPosition + rectCenterPosition);
        Vector3 pointOutwardWorldNormal = subtitleRect.TransformVector(new Vector3(normal.x, normal.y, 0f)).normalized;

        arrowRect.position = desiredWorldPos;

        // Build rotation so the arrow "up" follows the outward normal on the UI plane
        Vector3 planeNormal = canvas.transform.forward;
        if (pointOutwardWorldNormal.sqrMagnitude > 1e-10f)
        {
            Quaternion look = Quaternion.LookRotation(planeNormal, pointOutwardWorldNormal);
            look = look * Quaternion.AngleAxis(spriteRotationOffset, planeNormal);
            arrowRect.rotation = look;
        }
    }

    //Calculates which side of the rect the arrow should show on to point towards the target.
    //Also determines if the target is On Target or within the X bounds of the rect.
    private bool GetPointAndNormalOnCorrectEdgeOfRect(
        Vector3 targetLocalPositionFromRectCenter, Vector2 rectHalfSize, float distanceFromEdge,
        out Vector2 pointLocalPosition, out Vector2 pointNormal)
    {
        float absoluteXFromRectCenter = Mathf.Abs(targetLocalPositionFromRectCenter.x);
        float signX = Mathf.Sign(targetLocalPositionFromRectCenter.x == 0 ? 1f : targetLocalPositionFromRectCenter.x);

        bool withinRectXBounds = absoluteXFromRectCenter <= rectHalfSize.x;

        //If within the vertical bounds of the rect (or Is on target)
        if (withinRectXBounds && targetLocalPositionFromRectCenter.z > 0)
        {
            //Don't show the arrow
            pointLocalPosition = Vector2.zero;
            pointNormal = Vector2.zero;
            return false;
        }
        //Line up the arrow to the middle of the correct side
        pointLocalPosition = new Vector2(signX * (rectHalfSize.x + distanceFromEdge), 0);
        pointNormal = new Vector2(signX, 0f);
        return true;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIArrowPointToTarget.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: decb1ded1cf509c44b947c120f8390e3
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using Ldx.Framework.Scripts.Systems.Scoring;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.Player.Hands;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Systems.Teleportation;
using Ldx.Framework.Systems.Tethers;
using Ldx.Framework.Systems.UI.Modules;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.UI;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Ldx.Framework.Systems.UI
{
    public class UIController : Singleton<UIController>
    {
        private const float PIVOT_UPDATE_THRESHOLD = 1.5f;
        private const string PLAYER_LAYER_MASK = "Player";
        private const string HAND_LAYER_MASK = "Hand";

        /// <summary>
        /// Milliseconds per word avg reading speed
        /// </summary>
        private const int ADDITIONAL_WARNING_TIME = 3000;

        public static LayerMask AvoidLayerMask;
        public static event Action<WindowType, bool> OnAnyWindowTypeOpenClosed;
        public static event Action<UIController, bool> OnMainMenuOpenClosed;
        public static event Action<UIController, bool> OnTransparentOverlayOpenClosed;
        public static event Action<UIController, bool> OnLanguageSelectionOpenClosed;
        
        private readonly HashSet<UIElement> allRegisteredWindows = new HashSet<UIElement>();
        public HashSet<UIElement> AllWindows => allRegisteredWindows;
        
        private readonly List<UIElement> windowsToDestroyOnScenarioEnd = new List<UIElement>();
        
        public enum WindowType
        {
            MainMenu = 0,
            Question = 1,
            ObjectiveList = 2,
            ScenarioEnd = 3,
            Warning = 4,
            Tooltip = 5,
            ScenarioSelection = 6,
            AutoRestart = 7,
        }

        [Header("Windows")] 
        [SerializeField] private UIElement mainMenuWindow;
        [SerializeField] private DialogueWindow dialogueWindow;
        [SerializeField] private UIElement autoRestartWindow;
        [SerializeField] private ScenarioEndWindow scenarioEndWindow;
        [SerializeField] private UIElement warningWindow;
        [SerializeField] private List<UIElement> allWindows = new();

        [Header("Overlay Fade")]
        [SerializeField]
        private UIOverlayFade uiLoadingFade;
        public UIOverlayFade UILoadingFade => uiLoadingFade;
        [SerializeField]
        private UIOverlayFade uiTransparentFade;
        [SerializeField]
        private Transform uiOverlayFadeCameraParent;
        [SerializeField]
        private ScenarioTransitionUI scenarioTransitionUI;

        [Header("World Space Parent")]
        [SerializeField]
        private Transform worldSpaceParent;
        [SerializeField]
        private Transform activeWindowTetherTarget;
        [SerializeField]
        private Transform mainWindowTetherTarget;
        
        [SerializeField] [RequireInterface(typeof(IUIModule))]
        private List<MonoBehaviour> modules = new();

        [Header("Buttons")]
        [SerializeField] private GameObject leftWristMenuButton;
        [SerializeField] private GameObject rightWristMenuButton;
        
        private float minPivotY = 1f;
        private Vector3 uiPivotPoint;
        private Vector3 previousUiPivotPoint;
        private Vector3 previousCameraPosition;
        private float sqrThreshold;
        private float lerpPercentage;
        private readonly HashSet<IUIModule> uiModules = new();
        private readonly HashSet<UIElement> activeWindows = new HashSet<UIElement>();
        private readonly Dictionary<UIElement, UIElement[]> windowFormerlyActiveWindowsCache =
            new Dictionary<UIElement, UIElement[]>();
        private readonly Dictionary<WindowType, UIElement> windowTypeWindowMap = new Dictionary<WindowType, UIElement>();
        private bool transparentOverlayWasShownCache;
        private Tween lerpPercentageTween;
        private Transform overridenCameraTransform;

        private Transform CameraTransform => GetCameraTransform();
        public DialogParameters CurrentDialogParameters { get; private set; } = null;

        protected override void Awake()
        {
            base.Awake();
            AvoidLayerMask = ~(1 << LayerMask.NameToLayer(PLAYER_LAYER_MASK) | 1 << LayerMask.NameToLayer (HAND_LAYER_MASK));
            foreach (MonoBehaviour module in modules)
            {
                uiModules.Add(module as IUIModule);
            }
            
            if (UIGlobalSettings.MainMenuWindowPrefab != null)
            {
                mainMenuWindow = Instantiate(UIGlobalSettings.MainMenuWindowPrefab, worldSpaceParent).GetComponent<UIElement>();
                mainMenuWindow.gameObject.SetActive(false);
            }
        }

        private void Start()
        {
            previousCameraPosition = Vector3.negativeInfinity;
            sqrThreshold = PIVOT_UPDATE_THRESHOLD * PIVOT_UPDATE_THRESHOLD;
            SubscribeToEvents();
            RegisterUIElements();
            SetCameraPositionRelatedWindowsAsync().Forget();
            ProcessLanguageSelection().Forget();
            DoTransparentFade(false, true);
        }

        private void OnDestroy()
        {
            UnsubscribeFromEvents();
        }

        /// <summary>
        /// Gets a UI window by type
        /// </summary>
        public T GetUIElement<T>() where T : UIElement
        {
            return allRegisteredWindows.FirstOrDefault(w => w is T) as T;
        }

        public void SetUIElementPositionMode<T>(UIElement.PositionMode positionMode) where T : UIElement
        {
            UIElement window = GetUIElement<T>();
            if (window != null)
            {
                window.ElementPositionMode = positionMode;
                UpdateTetherTargetVisibility();
            }
        }
        
        public void SetUIElementPositionMode(WindowType type, UIElement.PositionMode positionMode)
        {
            if (windowTypeWindowMap.TryGetValue(type, out UIElement window))
            {
                window.ElementPositionMode = positionMode;
                UpdateTetherTargetVisibility();
            }
        }
        
        private async UniTaskVoid SetCameraPositionRelatedWindowsAsync()
        {
            await UniTask.WaitUntil(() => CameraTransform != null);
            SetTransformParentToCamera(uiLoadingFade.transform);
            SetTransformParentToCamera(uiTransparentFade.transform);
        }

        private void SetTransformParentToCamera(Transform transform)
        {
            transform.SetParent(CameraTransform, false);
            transform.localRotation = Quaternion.identity;
            transform.localPosition = new Vector3(0, 0, 0.02f);
        }

        private void SubscribeToEvents()
        {
            UIEventsTracker.OnAnyQuestionShowRequest += HandleAnyQuestionShowRequest;
            UIEventsTracker.OnAnyQuestionHideRequest += HandleAnyQuestionHideRequest;
            ScenarioManager.OnLoadingStarted += HandleStartLoadingNewScene;
            ScenarioManager.Instance.OnScenarioCompleted += HandleScenarioCompleted;
            ScenarioManager.Instance.OnLobbyCompleted += HandleLobbyCompleted;
            ScenarioManager.Instance.OnUnloadingScenarioOrLobby += HandleUnloadingScenarioOrLobby;
            ScenarioManager.Instance.OnScenarioStarted += HandleScenarioStarted;
            PlayerTeleporter.OnTeleportationFinished += HandleTeleportationFinished;
            UIElement.OnAnyElementStatusChanged += HandleAnyWindowStatusChanged;
            UIButton.OnAnyUIButtonHover += HandleAnyUIButtonHover;
            ScoringSystem.OnCriticalScoreReached += HandleCriticalScoreReached;
        }

        private void UnsubscribeFromEvents()
        {
            UIEventsTracker.OnAnyQuestionShowRequest -= HandleAnyQuestionShowRequest;
            UIEventsTracker.OnAnyQuestionHideRequest -= HandleAnyQuestionHideRequest;
            ScenarioManager.OnLoadingStarted -= HandleStartLoadingNewScene;
            if (ScenarioManager.IsValid)
            {
                ScenarioManager.Instance.OnScenarioCompleted -= HandleScenarioCompleted;
                ScenarioManager.Instance.OnLobbyCompleted -= HandleLobbyCompleted;
                ScenarioManager.Instance.OnUnloadingScenarioOrLobby -= HandleUnloadingScenarioOrLobby;
                ScenarioManager.Instance.OnScenarioStarted -= HandleScenarioStarted;
            }
            PlayerTeleporter.OnTeleportationFinished -= HandleTeleportationFinished;
            UIElement.OnAnyElementStatusChanged -= HandleAnyWindowStatusChanged;
            UIButton.OnAnyUIButtonHover -= HandleAnyUIButtonHover;
            ScoringSystem.OnCriticalScoreReached += HandleCriticalScoreReached;
        }
        
        private async UniTask ProcessLanguageSelection()
        {
            if (ScenarioManager.IsCustomLoadingMode)
            {
                return;
            }
            if (!LocalizationGlobalSettings.ShowLanguageSelectionDialogue)
            {
                return;
            }

            DialogEventData.DialogInfo languageSelectionDialog = LocalizationGlobalSettings.LanguageSelectionDialog;
            DialogueWindow.OnAnyQuestionAnswered += handleLanguageQuestionAnswered;
            ScenarioManager.Instance.SetObjectiveSystemBlocked(true);
            
            await UniTask.WaitUntil(
                () => ScenarioManager.IsValid && ScenarioManager.Instance.LoadedScenario != null);
            
            DialogParameters parameters = new DialogParameters(languageSelectionDialog, string.Empty);
            OnLanguageSelectionOpenClosed?.Invoke(this, true);
            ShowQuestionWindow(parameters, true);
            void handleLanguageQuestionAnswered(DialogueWindow _, string dialogId, string answerText, bool isCorrect)
            {
                DialogueWindow.OnAnyQuestionAnswered -= handleLanguageQuestionAnswered;
                ScenarioManager.Instance.SetObjectiveSystemBlocked(false);
                var selectedLanguageInfo = LocalizationGlobalSettings.GetAvailableLanguagesInfo()
                    .FirstOrDefault(x => x.languageName == answerText);
                
                HideQuestionWindow();
                OnLanguageSelectionOpenClosed?.Invoke(this, false);

                if (selectedLanguageInfo != null)
                {
                    LocalizationModel.SetLanguage(selectedLanguageInfo.language);
                }
            }
        }

#if UNITY_EDITOR
        private void Update()
        {
            if (Keyboard.current != null && Keyboard.current.mKey.wasPressedThisFrame)
            {
                ToggleMainWindow();
            }
        }
#endif
        
        private void LateUpdate()
        {
            if (CameraTransform == null)
            {
                return;
            }
            UpdateUIPivotToCamera();
            
            foreach (UIElement element in allRegisteredWindows)
            {
                if (element == null || !element.gameObject.activeSelf)
                {
                    continue;
                }

                UpdateWindowPositioning(element);
            }
        }

        private void UpdateWindowPositioning(UIElement uiElement)
        {
            uiElement.UpdatePositioning(CameraTransform);
        }
        
        public async UniTask FadeInScreenAsync(bool instant = false, float overrideTime = -1f)
        {
            float duration = overrideTime <= 0 ? UIGlobalSettings.FadeInTime : overrideTime;
            await uiLoadingFade.FadeInScreenAsync(instant, duration);
        }
        
        public async UniTask FadeOutScreenAsync(bool instant = false, float overrideTime = -1f)
        {
            float duration = Double.PositiveInfinity <= 0 ? UIGlobalSettings.FadeOutTime : overrideTime;
            await uiLoadingFade.FadeOutScreenAsync(instant, duration);
        }
        
        public Func<bool> FadeInScreen(bool instant = false, float overrideTime = -1f, Action callback = null)
        {
            float duration = overrideTime <= 0 ? UIGlobalSettings.FadeInTime : overrideTime;
            uiLoadingFade.FadeInScreen(instant, duration, callback);
            return () => !uiLoadingFade.ScreenIsHidden;
        }

        public Func<bool> FadeOutScreen(bool instant = false, float overrideTime = -1f, Action callback = null)
        {
            float duration = overrideTime <= 0 ? UIGlobalSettings.FadeOutTime : overrideTime;
            uiLoadingFade.FadeOutScreen(instant, duration, callback);
            DoTransparentFade(false, instant);
            return () => uiLoadingFade.ScreenIsHidden;
        }

        private void DoTransparentFade(bool overlayShouldShow, bool instant = false)
        {
            if (overlayShouldShow && !uiTransparentFade.IsShown)
            {
                OnTransparentOverlayOpenClosed?.Invoke(this, true);
                uiTransparentFade.ShowTransparentOverlay();
            }
            else if(!overlayShouldShow && uiTransparentFade.IsShown)
            {
                OnTransparentOverlayOpenClosed?.Invoke(this, false);
                uiTransparentFade.FadeInScreen();
            }
        }

        /// <summary>
        /// Call to set the pivot point to the current camera x/z position.
        /// </summary>
        private void UpdateUIPivotToCamera(bool force = false)
        {
            if (CameraTransform == null)
            {
                return;
            }
            Vector3 cameraPos = CameraTransform.position;
            
            if (force || Vector3.SqrMagnitude(cameraPos - previousCameraPosition) >= sqrThreshold)
            {
                lerpPercentageTween?.Kill();
                lerpPercentageTween = DOTween.To(x => lerpPercentage = x, 0, 1, 0.5f);
                previousCameraPosition = cameraPos;
                previousCameraPosition.y = Mathf.Max(minPivotY, previousCameraPosition.y);
                previousUiPivotPoint = uiPivotPoint;
            }

            if (lerpPercentage < 1)
            {
                uiPivotPoint = Vector3.Lerp(previousUiPivotPoint, previousCameraPosition, lerpPercentage);
            }
        }

        /// <summary>
        /// Centralize a list of all UI windows for iteration purposes,
        /// and for editor-only use.
        /// </summary>
        private UIElement[] GetDefaultUIElements()
        {
            return new UIElement[]
            {
                mainMenuWindow,
                dialogueWindow,
                autoRestartWindow,
                scenarioEndWindow,
                warningWindow,
            };
        }

        /// <summary>
        /// Add UI Window canvases to HVR, set up windows, subscribe to events etc.
        /// </summary>
        private void RegisterUIElements()
        {
            foreach (UIElement window in GetDefaultUIElements())
            {
                if (window == null)
                {
                    continue;
                }
                RegisterUIElement(window);
            }

            foreach (UIElement window in allWindows)
            {
                if (window == null)
                {
                    continue;
                }
                RegisterUIElement(window);
            }
            windowTypeWindowMap.Add(WindowType.MainMenu, mainMenuWindow);
            windowTypeWindowMap.Add(WindowType.Question, dialogueWindow);
            windowTypeWindowMap.Add(WindowType.AutoRestart, autoRestartWindow);
            windowTypeWindowMap.Add(WindowType.ScenarioEnd, scenarioEndWindow);
            windowTypeWindowMap.Add(WindowType.Warning, warningWindow);
        }

        public void RegisterUIElement(UIElement window)
        {
            if (allRegisteredWindows.Contains(window))
            {
                return;
            }
            
            allRegisteredWindows.Add(window);
            HideWindow(window, true);
        }

        public void UnregisterUIElement(UIElement window)
        {
            allRegisteredWindows.Remove(window);
            windowsToDestroyOnScenarioEnd.Remove(window);
        }

        public void MoveUIElementToWorldParent(UIElement window)
        {
            window.transform.SetParent(worldSpaceParent);
            windowsToDestroyOnScenarioEnd.Add(window);
        }

        public void HideMainMenu(bool fadeScreen = true)
        {
            if (activeWindows.Contains(mainMenuWindow))
            {
                ToggleMainWindow(fadeScreen);
            }
        }
        
        public void ToggleMainWindow(bool fadeScreen = true)
        {
            if (ScenarioManager.Instance.IsLoading)
            {
                return;
            }
            
            ToggleWindowWithCaching(mainMenuWindow, fadeScreen);
        }

        private bool ToggleWindowWithCaching(UIElement window, bool fadeScreen = true)
        {
            if (activeWindows.Contains(window))
            {
                if (fadeScreen)
                {
                    if(!transparentOverlayWasShownCache)
                        DoTransparentFade(false);
                }
                transparentOverlayWasShownCache = false;

                HideWindow(window);
                if (windowFormerlyActiveWindowsCache.TryGetValue(window, out UIElement[] formerlyActiveWindows))
                {
                    // Return to formerly active windows
                    foreach (UIElement w in formerlyActiveWindows)
                    {
                        if (w is DialogueWindow && window.DialogueAnchor != null)
                        {
                            w.SetStaticAnchor(null);
                            continue;
                        }
                        ShowWindow(w);
                    }
                }

                windowFormerlyActiveWindowsCache.Clear();
                return false;
            }

            if (window.ElementPositionMode == UIElement.PositionMode.MovableOrb)
            {
                TetherController.Instance.SummonTetherToPlayer(
                    window == mainMenuWindow
                        ? TetherController.TetherEnum.MainMenu
                        : TetherController.TetherEnum.ActiveWindow, useTween: false);
            }

            // Cache active windows before warning popup hides them
            windowFormerlyActiveWindowsCache[window] = GetActiveWindowsArray();
            foreach (UIElement w in windowFormerlyActiveWindowsCache[window])
            {
                if (w is DialogueWindow && window.DialogueAnchor != null)
                {
                    dialogueWindow.SetStaticAnchor(window.DialogueAnchor);
                    continue;
                }
                
                w.HideElement();
            }
            
            if (fadeScreen)
            {
                transparentOverlayWasShownCache = uiTransparentFade.IsShown;
                DoTransparentFade(true);
            }

            ShowWindow(window);
            return true;
        }

        public void ShowWindow(UIElement window, bool instant = false)
        {
            if (activeWindows.Contains(window))
                return;

            if (window == mainMenuWindow)
            {
                OnMainMenuOpenClosed?.Invoke(this, true);
            }

            if (window is DialogueWindow dialogueWindow && activeWindows.Count > 0)
            {
                foreach (UIElement activeWindow in activeWindows)
                {
                    if (activeWindow.DialogueAnchor != null)
                    {
                        dialogueWindow.SetStaticAnchor(activeWindow.DialogueAnchor);
                        break;
                    }
                }
            }
            
            UpdateUIPivotToCamera(true);
            UpdateWindowPositioning(window);
            window.ShowElement(instant);
        }

        private void HideAllWindows()
        {
            // Copy references to array to allow removal from hashset (in HideWindow method) during iteration
            UIElement[] activeWindowsArray = GetActiveWindowsArray();
            foreach (UIElement window in activeWindowsArray)
            {
                HideWindow(window);
            }
        }

        private UIElement[] GetActiveWindowsArray()
        {
            UIElement[] activeWindowsArray = new UIElement[activeWindows.Count];

            int i = 0;
            foreach (UIElement window in activeWindows)
            {
                activeWindowsArray[i] = window;
                i++;
            }

            return activeWindowsArray;
        }

        public void HideWindow(UIElement window, bool instant = false)
        {
            if (window == null || window is UIOverlayFade)
            {
                return;
            }
            
            if(window == mainMenuWindow)
                OnMainMenuOpenClosed?.Invoke(this, false);
            
            window.HideElement(instant);
        }
        
        private void HandleAnyWindowStatusChanged(UIElement window, bool isActive)
        {
            if (window is UIOverlayFade)
                return;

            if (isActive)
            {
                activeWindows.Add(window);
            }
            else
            {
                activeWindows.Remove(window);
            }
            
            if(!allRegisteredWindows.Contains(window))
                RegisterUIElement(window);

            foreach ((WindowType type, UIElement w) in windowTypeWindowMap)
            {
                if (w == window)
                {
                    OnAnyWindowTypeOpenClosed?.Invoke(type, isActive);
                    break;
                }
            }
            
            UpdateTetherTargetVisibility();
        }
        
        private void HandleAnyUIButtonHover(UIButton button)
        {
            PlayerController.Instance.HandsController.VibrateHand(HandSide.Right, 0.5f, 0.25f);
        }

        private void UpdateTetherTargetVisibility()
        {
            activeWindowTetherTarget.gameObject.SetActive(activeWindows.Any(x => x != mainMenuWindow && x.ElementPositionMode == UIElement.PositionMode.MovableOrb));
            if (mainMenuWindow)
                mainWindowTetherTarget.gameObject.SetActive(mainMenuWindow.gameObject.activeInHierarchy && mainMenuWindow.ElementPositionMode == UIElement.PositionMode.MovableOrb);
        }
        
        private void OnDrawGizmos()
        {
            Color color = Gizmos.color;
            Vector3 uiPivot = new Vector3(uiPivotPoint.x, 0, uiPivotPoint.y);
            Gizmos.color = Color.magenta;
            Gizmos.DrawLine(uiPivot, uiPivot.Modify(y: 1.5f));
            
            GUIStyle textStyle = new GUIStyle
            {
                fontSize = 20,
                normal =
                {
                    textColor = Color.magenta
                }
            };
#if UNITY_EDITOR
            Handles.Label(uiPivotPoint, "UI Pivot", textStyle);
#endif            
            Gizmos.color = color;
        }

        public void ShowQuestionWindow(DialogParameters parameters, bool ignoreLoadingRestriction = false)
        {
            if (String.IsNullOrEmpty(parameters.Description) || parameters.Description.Trim().Length < 1 || (ScenarioManager.Instance.IsLoading && !ignoreLoadingRestriction))
            {
                return;
            }
            ShowWindow(dialogueWindow, true);
            dialogueWindow.SetupQuestion(parameters);
            CurrentDialogParameters = parameters;
            if(parameters.Answers != null && parameters.Answers.Count > 0)
                DoTransparentFade(true);
        }

        public void HideQuestionWindow(bool instant = false)
        {
            if(!activeWindows.Contains(mainMenuWindow) && !activeWindows.Contains(scenarioEndWindow))
                DoTransparentFade(false);
            CurrentDialogParameters = null;
            HideWindow(dialogueWindow, instant);
        }

        public void ShowModuleAutoRestartWindow()
        {
            ToggleWindowWithCaching(autoRestartWindow, false);
        }

        public void HideModuleAutoRestartWindow()
        {
            ToggleWindowWithCaching(autoRestartWindow, false);
        }
        
        #region Event Handlers

        private void HandleAnyQuestionShowRequest(DialogParameters parameters)
        {
            // Randomize answers if needed
            IEnumerable<DialogEventData.DialogInfo.AnswerInfo> answers = parameters.RandomizeAnswers ? 
                parameters.Answers.RandomizeList() : parameters.Answers;

            DialogEventData.DialogInfo.AnswersContainer answersContainer = new();
            if (answers != null)
            {
                answersContainer.AddRange(answers);
            }
            parameters.Answers = answersContainer;
            ShowQuestionWindow(parameters);
        }

        private void HandleAnyQuestionHideRequest()
        {
            HideQuestionWindow();
        }
        
        private void HandleCriticalScoreReached(ScoringSystem scoringSystem)
        {
            ProcessEndOfScenario(true);
        }

        private void HandleScenarioCompleted(ScenarioManager scenarioManager,
            ScenarioData.ScenarioEndBehaviourType endBehaviour, IScenarioCompletionResult result)
        {
            ProcessEndOfScenario(endBehaviour == ScenarioData.ScenarioEndBehaviourType.ShowEndScreen);
        }

        private void ProcessEndOfScenario(bool showEndScreen)
        {
            if (showEndScreen)
            {
                scenarioEndWindow.SetScenarioCompleteStatus(true);
                ToggleWindowWithCaching(scenarioEndWindow);
            }
            DestroyScenariosWindows();
        }

        private void HandleShowMidScenarioScoring()
        {
            ProcessMidScenarioScoringScreen();
        }

        private void ProcessMidScenarioScoringScreen()
        {
            scenarioEndWindow.SetScenarioCompleteStatus(false);
            ToggleWindowWithCaching(scenarioEndWindow);
        }

        private void HandleLobbyCompleted(ScenarioManager scenarioManager)
        {
            DestroyScenariosWindows();
        }
        
        private void HandleStartLoadingNewScene(ScenarioLoadingParameters param)
        {
            HideAllWindows();
        }
        
        private void HandleUnloadingScenarioOrLobby(ScenarioManager scenarioManager)
        {
            DoTransparentFade(false, true);
            HideAllWindows();
            
            foreach (IUIModule module in uiModules)
            {
                module.UnloadingScenarioOrLobby(scenarioManager);
            }
        }
        
        private void HandleScenarioStarted(ScenarioManager scenarioManager, ScenarioDataType _)
        {
            PlayerStartPoint point = ReferenceBank.GetFirstOrDefault<PlayerStartPoint>();
            if (point == null)
            {
                minPivotY = 1;
            }
            else
            {
                minPivotY = point.transform.position.y + 1f;
            }

            foreach (IUIModule module in uiModules)
            {
                module.ScenarioStarted(scenarioManager, _);
            }
        }

        private void DestroyScenariosWindows()
        {
            int count = windowsToDestroyOnScenarioEnd.Count;
            for (int i = 0; i < count; i++)
            {
                Destroy(windowsToDestroyOnScenarioEnd[i].gameObject);
            }
        }
        
        private void HandleTeleportationFinished(PlayerTeleporter playerTeleporter)
        {
            UpdateUIPivotToCamera(true);
        }
        
        private Transform GetCameraTransform()
        {
            if (overridenCameraTransform != null)
            {
                return overridenCameraTransform;
            }

            PlayerController player = PlayerController.Instance;
            if (player == null)
            {
                return null;
            }

            return player.MainCamera.transform;
        }
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIDistanceScaler.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9a034834ac2b0a54d9dbfc002d7e40c8
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

public class UIDistanceScaler : MonoBehaviour
{
    [SerializeField] private float referenceDistance = 2f;
    [SerializeField] private bool useMaxScale = false;
    [ShowIf("useMaxScale", MultiOp.Equals, true)]
    [SerializeField] private float maxScale = 4f;
    private Vector3 originalScale;
    private Transform cameraTransform;

    private void Awake()
    {
        cameraTransform = Camera.main.transform;
        originalScale = transform.localScale;
    }

    private void Update()
    {
        float distance = (cameraTransform.position - transform.position).magnitude;
        float scaleFactor = distance / referenceDistance;
        if(useMaxScale)
            transform.localScale = originalScale * Mathf.Min(maxScale, scaleFactor);
        else
            transform.localScale = originalScale * scaleFactor;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIDistanceScaler.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIElement.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e04fb57fd7c9e9e4a911faef2a22c8cd
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using DG.Tweening;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.Player.Hands;
using Ldx.Framework.Systems.UI.Interaction;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using UnityEngine.UI;

namespace Ldx.Framework.Systems.UI
{
    /// <summary>
    /// Base class for any UI element that stands alone and hosts other UI elements.
    /// E.g. Windows, modals, overlay fades. (Not text, icons, buttons, etc which have parent elements).
    /// </summary>
    public class UIElement : MonoBehaviour
    {
        private const float MAX_DURATION = 5f;
        private const float FADE_OUT_SCALE_MULTIPLIER = 0.8f;
        private const float SHOW_HIDE_TIME = 0.25f;
        private const float START_REPOSITION_THRESHOLD_ANGLE_DEGREES = 60f;
        private const float CONTINUE_REPOSITION_THRESHOLD_ANGLE_DEGREES = 1.5f;
        private const float WINDOW_REPOSITION_SPEED = 5f;
        private const float WINDOW_DISTANCE = 2f;
        private const float FRUSTUM_THRESHOLD = 0.05f;
        private const float MIN_DISTANCE_BETWEEN_UPDATES = 0.0001f; // Sqr 0.01
        private const float MAX_DISTANCE_FOR_ANCHOR = 13f;
        private const float FRUSTUM_THRESHOLD_FOR_ANCHOR = 0.35f;
        
        public static event Action<UIElement, bool> OnAnyElementStatusChanged;
        
        public enum PositionMode
        {
            Static,
            FixedToView,
            CircleFollow,
            FixedToNearestAnchor,
            StaticLookAtCamera,
            CircleFollowCameraFrustum,
            CircleFollowWithAnchorInFrustrum,
            MovableOrb,
            HandFollow,
            StaticAnchored
        }
        
        [SerializeField]
        public enum AnchorSide
        {
            Top,
            Bottom
        }
        
        [SerializeField]
        public PositionMode ElementPositionMode = PositionMode.CircleFollowCameraFrustum;
        [SerializeField]
        private Vector3 offset;
        [SerializeField][ShowIf("ElementPositionMode", MultiOp.Equals,PositionMode.CircleFollowWithAnchorInFrustrum)]
        protected AnchorSide anchorSide = AnchorSide.Top;

        [SerializeField] [ShowIf("ElementPositionMode", MultiOp.Equals, PositionMode.CircleFollowWithAnchorInFrustrum)]
        private RectTransform containerToAnchor;
        
        [SerializeField] [ShowIf("ElementPositionMode", MultiOp.Equals, PositionMode.HandFollow)]
        private HandSide handSide;

        [SerializeField] private float headRotationEffectAmount = 0f;
        
        [SerializeField]
        private Canvas canvas;
        public Canvas Canvas => canvas;
        
        [SerializeField]
        protected CanvasGroup canvasGroup;
        [SerializeField]
        protected Transform windowCanvasTransform;
        [SerializeField][Tooltip("Rect transforms to rebuild")]
        private List<RectTransform> rectTransforms = new List<RectTransform>();
        [Tooltip("Optional Setup")]
        [SerializeField] private Collider backCollider;

        [SerializeField] private Transform dialogueAnchor;
        public Transform DialogueAnchor => dialogueAnchor;
        
        [SerializeField] [SoundReference] private string elementOpenSound;
        [SerializeField] [SoundReference] private string elementCloseSound;

        public bool UsesAnchor => ElementPositionMode == PositionMode.CircleFollowWithAnchorInFrustrum;
        protected virtual float ShowHideTime => SHOW_HIDE_TIME;
        public bool IsShown { get; private set; }
        
        private bool isRepositioning;
        protected bool hasPositioned;
        private float sqrDistanceThreshold;
        private float sqrDistance;
        private float scaleValue;
        private Vector3 nextPosition;
        private Vector3 cachePlayerPosition;
        private Transform followAnchor;
        private Transform overrideStaticAnchor;
        private float sqrMaxAnchorDistance;
        
        private Sequence fadeTween;

        /// <summary>
        /// Gets the easing function used during show/hide fade animations.
        /// Override this property to customize the easing function according to specific UI element needs.
        /// </summary>
        protected virtual Ease ShowHideEase => Ease.Linear;
        
        /// <summary>
        /// Determines whether the UI element should scale during fade animations.
        /// Override this property to return true if the specific UI element needs to scale while fading. 
        /// For instance, if a "popping" effect is desired during appearance/disappearance.
        /// </summary>
        protected virtual bool ShouldScaleOnFade => false;
        
        /// <summary>
        /// Gets the original scale of the UI element, used to restore its scale after a fade.
        /// Override this property when the UI element should revert to a specific scale after or during animations, 
        /// especially if <see cref="ShouldScaleOnFade"/> is true and altering the scale dynamically is required.
        /// </summary>
        protected virtual Vector3 OriginalScale => Vector3.one;
        
        /// <summary>
        /// Indicates whether the UI element game object should be disabled/enabled upon hiding/showing.
        /// Override this property to control the active state of the UI element during and after fade animations.
        /// For example, return false if you want the UI element to remain active (e.g., to listen for events) even when it's invisible.
        /// </summary>
        protected virtual bool DisableEnableObjectOnFade => true; 
        
        protected virtual void OnValidate()
        {
            if (canvas == null)
            {
                canvas = GetComponentInChildren<Canvas>();
            }
            
            if (canvasGroup == null)
            {
                canvasGroup = GetComponentInChildren<CanvasGroup>();
            }
        }

        protected virtual void Awake() { }

        protected virtual void Start()
        {
            if (canvas.renderMode == RenderMode.WorldSpace)
            {
                canvas.worldCamera = LdxHandCanvasPointer.EventProcessingCamera;
            }
            sqrMaxAnchorDistance = MAX_DISTANCE_FOR_ANCHOR * MAX_DISTANCE_FOR_ANCHOR;
        }
        
        protected virtual void OnDisable() { }

        protected virtual void OnDestroy()
        {
            KillFadeTween();
        }
        
        /// <summary>
        /// Display the UI element, optionally bypassing custom fade duration
        /// </summary>
        /// <param name="instant">Indicates whether the element should be shown instantly</param>
        /// <param name="overrideTime">Custom duration for the fade, ignored if negative</param>
        /// <param name="callback">Optional callback to invoke upon completion</param>
        public void ShowElement(bool instant = false, float overrideTime = -1, Action callback = null) =>
            Fade(1.0f, instant, overrideTime, ShowElementBeginActions, () =>
            {
                ShowElementCompleted();
                callback?.Invoke();
            });
        
        /// <summary>
        /// Hide the UI element, optionally bypassing custom fade duration
        /// </summary>
        /// <param name="instant">Indicates whether the element should be hidden instantly</param>
        /// <param name="overrideTime">Custom duration for the fade, ignored if negative</param>
        /// <param name="callback">Optional callback to invoke upon completion</param>
        public void HideElement(bool instant = false, float overrideTime = -1, Action callback = null) =>
            Fade(0.0f, instant, overrideTime, HideElementBeginActions, () =>
            {
                HideElementCompleted(canvasGroup.alpha > 0);
                callback?.Invoke();
            }, FADE_OUT_SCALE_MULTIPLIER);
        
        /// <summary>
        /// Executes the fade transition of element canvas based on given parameters
        /// </summary>
        /// <param name="value">Target alpha value of the fade</param>
        /// <param name="instant">Indicates if the fade should happen instantly</param>
        /// <param name="overrideTime">Overrides default fade time if provided and is non-negative</param>
        /// <param name="startAction">Action to perform at the start of fade</param>
        /// <param name="callback">Callback to invoke upon fade completion</param>
        /// <param name="scaleMultiplier">Multiplier applied to the scale during the fade</param>
        protected void Fade(float value, bool instant, float overrideTime, Action<bool> startAction, Action callback, float scaleMultiplier = 1f)
        {
            // Terminate any previous fading tween to ensure a clean state
            KillFadeTween();
            
            // Invoke the starting action, if it's not null
            startAction?.Invoke(instant);

            // Check whether the fading should occur instantly or over time
            if (instant)
            {
                // Directly set the alpha to the target value
                canvasGroup.alpha = value;
                
                // If scaling during fade is enabled, adjust the local scale instantly
                if (ShouldScaleOnFade)
                {
                    windowCanvasTransform.localScale = OriginalScale * scaleMultiplier;
                }
                
                // Invoke the callback action, if it's not null
                callback?.Invoke();
            }
            else
            {
                if (Mathf.Approximately(canvasGroup.alpha, value))
                    return;
                
                // Determine the duration of the fade: either use the override time if it's valid, or derive from the active UI theme,
                // ensuring it doesn't exceed MAX_DURATION
                float duration = overrideTime < 0f  ? ShowHideTime : Mathf.Clamp(overrideTime, 0, MAX_DURATION);
                
                // Initialize a new DOTween sequence for the fade transition to gradually change the alpha of the canvas group
                fadeTween = DOTween.Sequence().SetRecyclable(false);
                    
                fadeTween.Join(canvasGroup.DOFade(value, duration).From(canvasGroup.alpha));

                // If scaling on fade is enabled, join a scale tween to smoothly change the local scale during the transition
                if (ShouldScaleOnFade)
                {
                    fadeTween.Join(windowCanvasTransform.DOScale(OriginalScale * scaleMultiplier, duration));
                }
                
                // Configure the tween to use the defined ease function, update even during Unitys pause state,
                // and invoke the callback upon completion
                fadeTween.SetUpdate(true)
                    .SetEase(ShowHideEase)
                    .OnComplete(() => callback?.Invoke());
            }
        }
        
        /// <summary>
        /// Executes actions in preparation for the UI element to be visible
        /// </summary>
        protected virtual void ShowElementBeginActions(bool instant)
        {
            OnAnyElementStatusChanged?.Invoke(this, true);
            IsShown = true;
            hasPositioned = false;
            if (DisableEnableObjectOnFade)
            {
                gameObject.SetActive(true);
            }
            
            if (!instant)
            {
                Audio.PlayOneShot(elementOpenSound, transform);
            }
        }
        
        /// <summary>
        /// Executes actions after the UI element has been fully visible
        /// </summary>
        protected virtual void ShowElementCompleted() { }

        /// <summary>
        /// Executes actions in preparation for the UI element to be hidden
        /// </summary>
        protected virtual void HideElementBeginActions(bool instant)
        {
            OnAnyElementStatusChanged?.Invoke(this, false);
            IsShown = false;
            if (!instant)
            {
                Audio.PlayOneShot(elementCloseSound, transform);
            }
        }
        
        /// <summary>
        /// Executes actions after the UI element has been fully hidden
        /// </summary>
        protected virtual void HideElementCompleted(bool wasActiveBefore)
        {
            foreach (UIButton button in GetComponentsInChildren<UIButton>())
            {
                button.ResetActions();
            }
            if (DisableEnableObjectOnFade)
            {
                gameObject.SetActive(false);
            }
        }

        /// <summary>
        /// Terminates any ongoing fade transitions to prevent unintended effects
        /// </summary>
        private void KillFadeTween()
        {
            fadeTween?.Kill(false);
            fadeTween = null;
        }
        
        protected virtual void RebuildLayouts()
        {
            foreach (RectTransform rectTransform in rectTransforms)
            {
                if (rectTransform == null)
                {
                    continue;
                }

                LayoutRebuilder.ForceRebuildLayoutImmediate(rectTransform);
            }
        }
        
        public void SetBackColliderActive(bool active)
        {
            if (backCollider == null)
            {
                return;
            }
            
            backCollider.enabled = active;
        }

        protected virtual void SetAnchor(Transform anchor)
        {
            followAnchor = anchor;
        }

        public void SetStaticAnchor(Transform anchor)
        {
            overrideStaticAnchor = anchor;
        }

        public void UpdatePositioning(Transform viewTransform)
        {
            PositionMode mode = ElementPositionMode;
            if (overrideStaticAnchor != null)
                mode = PositionMode.StaticAnchored;
            
            switch (mode)
            {
                case PositionMode.CircleFollow:
                    UpdateCircleFollowAroundPivot(viewTransform);
                    break;
                case PositionMode.CircleFollowCameraFrustum:
                    UpdateCircleFollowCameraFrustum(viewTransform);
                    break;
                case PositionMode.CircleFollowWithAnchorInFrustrum:
                    UpdateCircleFollowWithAnchorInFrustum(viewTransform);
                    break;
                case PositionMode.HandFollow:
                    UpdateHandFollow(viewTransform);
                    break;
                case PositionMode.StaticAnchored:
                    UpdateStaticAnchored();
                    break;
            }
        }
        
        private void UpdateContainerAnchor(float anchorMinY, float anchorMaxY, float pivotY, float anchorPositionY, bool instant)
        {
            Vector2 targetAnchorMin = new Vector2(containerToAnchor.anchorMin.x, anchorMinY);
            containerToAnchor.anchorMin = instant ? targetAnchorMin : Vector2.Lerp(containerToAnchor.anchorMin, targetAnchorMin,WINDOW_REPOSITION_SPEED * Time.deltaTime);
            Vector2 targetAnchorMax = new Vector2(containerToAnchor.anchorMax.x, anchorMaxY);
            containerToAnchor.anchorMax =  instant ? targetAnchorMax : Vector2.Lerp(containerToAnchor.anchorMax, new Vector2(containerToAnchor.anchorMax.x, anchorMaxY),WINDOW_REPOSITION_SPEED * Time.deltaTime);
            Vector2 targetPivot = new Vector2(containerToAnchor.pivot.x, pivotY);
            containerToAnchor.pivot = instant ? targetPivot : Vector2.Lerp(containerToAnchor.pivot, targetPivot,WINDOW_REPOSITION_SPEED * Time.deltaTime);
            Vector2 targetAnchoredPosition = new Vector2(containerToAnchor.anchoredPosition.x, anchorPositionY);
            containerToAnchor.anchoredPosition = instant ? targetAnchoredPosition : Vector2.Lerp(containerToAnchor.anchoredPosition, targetAnchoredPosition, WINDOW_REPOSITION_SPEED * Time.deltaTime);
        }
        
        public void UpdateCircleFollowAroundPivot(Transform viewTransform)
        {
            Vector3 canvasLocalPos = windowCanvasTransform.localPosition;
            Vector3 localOffset = viewTransform.TransformDirection(offset);
            Transform windowParentTransform = transform;
            PlayerController playerController = PlayerController.Instance;
           
            cachePlayerPosition = playerController.GetPlayerPosition;
            
            Vector3 XZViewForward = new Vector3(viewTransform.forward.x, 0f, viewTransform.forward.z).normalized;
            Vector3 nextPosition = viewTransform.position + XZViewForward * WINDOW_DISTANCE;
            if(!hasPositioned)
                windowParentTransform.position = nextPosition;
            else
                windowParentTransform.position = Vector3.Lerp(windowParentTransform.position, nextPosition, WINDOW_REPOSITION_SPEED * Time.unscaledDeltaTime);
            
            windowParentTransform.LookAt(viewTransform.position);
            windowParentTransform.rotation = Quaternion.Slerp(
                transform.rotation,
                Quaternion.LookRotation(-viewTransform.forward),
                headRotationEffectAmount);
            
            hasPositioned = true;
        }

        public void UpdateCircleFollowCameraFrustum(Transform viewTransform)
        {
            Transform windowParentTransform = transform;
            PlayerController playerController = PlayerController.Instance;
            
            // Calculate the desired position of the window based on the camera's forward direction and the offset
            Vector3 XZViewForward = new Vector3(viewTransform.forward.x, 0f, viewTransform.forward.z).normalized;
            Vector3 desiredPosition = viewTransform.position + XZViewForward * WINDOW_DISTANCE;
                                      //new Vector3(XZViewForward.x * circleFollowOffset.x, circleFollowOffset.y, XZViewForward.z * circleFollowOffset.z);

            // Calculate the window's position in viewport space
            Vector3 viewportPos =
                PlayerController.Instance.MainCamera.WorldToViewportPoint(windowParentTransform.position);

            // Check if the window is outside the frustum threshold
            if (viewportPos.x < FRUSTUM_THRESHOLD || viewportPos.x > 1 - FRUSTUM_THRESHOLD ||
                !hasPositioned)
            {
                // Set the position of the window parent to the desired position
                nextPosition = desiredPosition;
            }
            
            updatePosition();
            updateRotation(viewTransform.forward);
            
            cachePlayerPosition = playerController.GetPlayerPosition;

            void updateRotation(Vector3 XZViewForward)
            {
                windowParentTransform.LookAt(viewTransform.position);
                windowParentTransform.rotation = Quaternion.Slerp(
                    windowParentTransform.rotation,
                    Quaternion.LookRotation(-XZViewForward),
                    headRotationEffectAmount);
            }

            // We lerp it so it isn't as jittery feeling. 
            void updatePosition()
            {
                if (!hasPositioned)
                {
                    windowParentTransform.position = nextPosition;
                }
                else if (nextPosition != Vector3.zero && (nextPosition - windowParentTransform.position).sqrMagnitude > MIN_DISTANCE_BETWEEN_UPDATES)
                {
                    windowParentTransform.position = Vector3.Lerp(windowParentTransform.position, nextPosition, WINDOW_REPOSITION_SPEED * Time.unscaledDeltaTime);
                }
                hasPositioned = true;
            }
        }

        public void UpdateCircleFollowWithAnchorInFrustum(Transform viewTransform)
        {
            if (followAnchor == null)
            {
                DoBasicCircleFollow();
                return;
            }
            
            Transform windowParentTransform = transform;
            PlayerController playerController = PlayerController.Instance;
            
            // Calculate the anchor's position in viewport space
            Vector3 viewportPos =
                PlayerController.Instance.MainCamera.WorldToViewportPoint(followAnchor.position);

            // Check if the anchor is outside the frustum threshold
            bool withinView = viewportPos.x < FRUSTUM_THRESHOLD_FOR_ANCHOR ||
                              viewportPos.x > 1 - FRUSTUM_THRESHOLD_FOR_ANCHOR ||
                              viewportPos.z < 0;
            if (hasPositioned && withinView)
            {
                DoBasicCircleFollow();
                return;
            }
            int anchorAlignment = anchorSide == AnchorSide.Top ? 1 : 0;
            UpdateContainerAnchor(anchorAlignment, anchorAlignment, anchorAlignment == 0 ? 1 : 0, 0, !hasPositioned);
            
            Vector3 TowardsAnchor = followAnchor.position - viewTransform.position;
            Vector3 XZTowardsAnchor = new Vector3(TowardsAnchor.x, 0f, TowardsAnchor.z).normalized;
            Vector3 desiredPosition = viewTransform.position + XZTowardsAnchor * WINDOW_DISTANCE;
            desiredPosition = new Vector3(desiredPosition.x, followAnchor.position.y, desiredPosition.z);
            //If close enough, the anchor directly to the target position
            bool withinRange = (followAnchor.position - viewTransform.position).sqrMagnitude > sqrMaxAnchorDistance;
            bool initialPositioningPreventsDirectPosition = !withinView && !hasPositioned;
            nextPosition = withinRange && initialPositioningPreventsDirectPosition? desiredPosition : followAnchor.position;
            
            updatePosition();
            updateRotation();
            
            cachePlayerPosition = playerController.GetPlayerPosition;

            void updateRotation()
            {
                windowParentTransform.LookAt(viewTransform.position);
                windowParentTransform.rotation = Quaternion.Slerp(
                    transform.rotation,
                    Quaternion.LookRotation(-viewTransform.forward),
                    headRotationEffectAmount);
            }

            // We lerp it so it isn't as jittery feeling. 
            void updatePosition()
            {
                if (!hasPositioned)
                {
                    windowParentTransform.position = nextPosition;
                }
                else
                {
                    windowParentTransform.position = Vector3.Lerp(windowParentTransform.position, nextPosition, WINDOW_REPOSITION_SPEED * Time.deltaTime);
                }
                hasPositioned = true;
            }

            void DoBasicCircleFollow()
            {
                UpdateContainerAnchor(0,1,0.5f,offset.y, !hasPositioned);
                UpdateCircleFollowAroundPivot(viewTransform);
            }
        }

        public void UpdateHandFollow(Transform viewTransform)
        {
            Transform targetTransform = PlayerController.Instance.HandsController.GetHand(handSide).transform;
            
            // Build a basis at the target:
            // forward = from target toward player (so +Z goes further from target, toward the player)
            Vector3 forward = viewTransform.position - targetTransform.position;
            forward.y = 0;
            if (forward.sqrMagnitude < 1e-8f)
            {
                forward = targetTransform.forward; // fallback if on the same spot
            }
            else
            {
                forward.Normalize();
            }

            // Use a stable up reference; avoid near-parallel cases
            Vector3 upRef = Vector3.up;
            if (Mathf.Abs(Vector3.Dot(forward, upRef)) > 0.99f)
                upRef = Vector3.right;

            Quaternion basis = Quaternion.LookRotation(forward, upRef);
            Vector3 worldOffset = basis * offset;

            Vector3 desiredPosition = targetTransform.position + worldOffset;
            
            transform.position = !hasPositioned ? desiredPosition : 
                Vector3.Lerp(transform.position, desiredPosition, WINDOW_REPOSITION_SPEED * Time.deltaTime);
            transform.LookAt(viewTransform);
            hasPositioned = true;
        }

        public void UpdateStaticAnchored()
        {
            if (ElementPositionMode == PositionMode.CircleFollowWithAnchorInFrustrum && containerToAnchor != null)
            {
                UpdateContainerAnchor(0,1,0.5f,offset.y, true);
            }
            
            transform.position = overrideStaticAnchor.position;
            transform.rotation = overrideStaticAnchor.rotation;
            hasPositioned = true;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIElement.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIGlobalSettings.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c11ce384b7a743318677f96c68828f75
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using DG.Tweening;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.UI.Fading;
using Ldx.Framework.Systems.UI.Notifier;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Serializable;
using Ldx.Systems.UI.Font;
using TMPro;
using UnityEngine;
using FontStyle = Ldx.Systems.UI.Font.FontStyle;

namespace Ldx.Framework.Systems.UI
{
    [HasFrameworkDefault]
    public class UIGlobalSettings : GlobalSettings<UIGlobalSettings>
    {
        private const float DIALOG_OBJECT_DEFAULT_OUTLINE_WIDTH = 3.5f;

        [SerializeField] private bool enableAutoRestartModule = true;
        public static bool EnableAutoRestartModule => Instance.enableAutoRestartModule;

        [Header("Camera")]
        [SerializeField]
        private float mainWindowDistanceFromCamera = 5f;
        public static float MainWindowDistanceFromCamera => Instance.mainWindowDistanceFromCamera;
       
        [SerializeField]
        private float popoverDistanceFromCamera = 3f;
        public static float PopoverDistanceFromCamera => Instance.popoverDistanceFromCamera;
        
        [Header("Customized Menus")]
        [Tooltip("Disables Wrist UI if left blank.")]
        [SerializeField] private GameObject mainMenuWindowPrefab;
        public static GameObject MainMenuWindowPrefab => Instance.mainMenuWindowPrefab;

        [Header("Fonts")]
        [SerializeField]
        
        private TMP_FontAsset defaultFont;
        [SerializeField]
        private Material defaultFontMaterial;
        [SerializeField]
        private SerializableDictionary<Language, LanguageFonts> languageFontsMap = new();

        [Header("Logo Display")] 
        [SerializeField]
        private bool displayLogoWithDialogues;
        public static bool DisplayLogoWithDialogues => Instance.displayLogoWithDialogues;

        [SerializeField]
        private bool displayLogoOnEndScenarioWindow;
        public static bool DisplayLogoOnEndScenarioWindow => Instance.displayLogoOnEndScenarioWindow;
        
        [Header("Word Highlight")]
        [SerializeField] 
        private List<Color> highlightColors = new List<Color>(new Color[] {new Color(0.99f, 0.97f, 0.26f)});

        private List<string> highlightMarkupStrings = new List<string>();
        
        [Header("Localization")]
        [SerializeField]
        private string localizationTableName = "UI";
        public static string LocalizationTableName => Instance.localizationTableName;
        
        [SerializeField][LocalizationKey]
        private string percentageString;
        public static string PercentageString => Instance.percentageString;

        [SerializeField][LocalizationKey]
        private string valueString;
        public static string ValueString => Instance.valueString;
        
        [SerializeField][LocalizationKey]
        private string angleString;
        public static string AngleString => Instance.angleString;
        
        [Header("End scenario")]
        [SerializeField][LocalizationKey]
        private string defaultScenarioEndLabel;
        public static string DefaultScenarioEndLabel => Instance.defaultScenarioEndLabel;

        [Header("UI Notify")]
        [SerializeField]
        private SerializableDictionary<UINotify.NotifyType, Color> notifyColorMap =
            new SerializableDictionary<UINotify.NotifyType, Color>();
        
        [Header("UI Notify settings")]
        [SerializeField] private Vector3 notifyUpperPosition;
        public static Vector3 NotifyUpperPosition => Instance.notifyUpperPosition;
        
        [SerializeField] private float notifySpeedShown = 0.5f;
        public static float NotifySpeedShown => Instance.notifySpeedShown;

        [SerializeField] private float notifySpeedHidden = 0.1f;
        public static float NotifySpeedHidden => Instance.notifySpeedHidden;

        [SerializeField] private Ease notifyLowerEase = Ease.OutCirc;
        public static Ease NotifyLowerEase => Instance.notifyLowerEase;

        [SerializeField] private Ease notifyHideEase = Ease.Linear;
        public static Ease NotifyHideEase => Instance.notifyHideEase;

        [SerializeField] private float notifyCascadingTime = 0.2f;
        public static float NotifyCascadingTime => Instance.notifyCascadingTime;

        [Header("Dialog Objects")]
        [SerializeField]
        private bool addOutlineToDialogObjects = true;
        public static bool AddOutlineToDialogObjects => Instance.addOutlineToDialogObjects;

        [SerializeField]
        private Color dialogObjectsOutlineColor = new(0.015f, 1, 0.56f);
        public static Color DialogObjectsOutlineColor => Instance.dialogObjectsOutlineColor;

        [SerializeField]
        private float dialogObjectsOutlineWidth = DIALOG_OBJECT_DEFAULT_OUTLINE_WIDTH;
        public static float DialogObjectsOutlineWidth => Instance.dialogObjectsOutlineWidth;

        [Header("Value Broadcaster")]
        [SerializeField]
        private string sampleValueBroadcasterTitle;
        public static string SampleValueBroadcasterTitle => Instance.sampleValueBroadcasterTitle;

        [Header("Fade Settings")]
        [SerializeField] private bool overrideFadeValues;

        [ShowIf("overrideFadeValues", Op.Equals, true)]
        [SerializeField] private FadeOverrideConfig fadeOverrideConfig;
        
        [Header("Canvas Pointer")]
        [SerializeField]
        private Material onSelectLineMaterial;
        public static Material OnSelectLineMaterial => Instance.onSelectLineMaterial;

        [SerializeField]
        private Material onSelectMarkerMaterial;
        public static Material OnSelectMarkerMaterial => Instance.onSelectMarkerMaterial;

        [SerializeField]
        private Material onDeselectLineMaterial;
        public static Material OnDeselectLineMaterial => Instance.onDeselectLineMaterial;

        [SerializeField]
        private Material onDeselectMarkerMaterial;
        public static Material OnDeselectMarkerMaterial => Instance.onDeselectMarkerMaterial;
        
        [Header("Audio")]
        [SerializeField][SoundReference]
        private string onButtonHoverSound;
        public static string OnButtonHoverSound => Instance.onButtonHoverSound;
        
        [SerializeField][SoundReference]
        private string onButtonClickSound;
        public static string OnButtonClickSound => Instance.onButtonClickSound;
        
        public static float FadeOutTime => Instance.overrideFadeValues
            ? Instance.fadeOverrideConfig.FadeOutTime
            : ScreenFadeConsts.FADE_OUT_TIME;
        
        public static float MinInBetweenTime => Instance.overrideFadeValues
            ? Instance.fadeOverrideConfig.MinInBetweenTime
            : ScreenFadeConsts.MIN_IN_BETWEEN_TIME;
        
        public static float FadeInTime => Instance.overrideFadeValues
            ? Instance.fadeOverrideConfig.FadeInTime
            : ScreenFadeConsts.FADE_IN_TIME;
        
        public static string GetHighlightedWordString(string str)
        {
            Instance.highlightMarkupStrings.Clear();
            foreach (Color c in Instance.highlightColors)
            {
                Instance.highlightMarkupStrings.Add($"<color={c.ToRGBHex()}>");
            }
            
            var result = str;
            // regex for finding any number between [ ]
            int maxColorId = Instance.highlightColors.Count;
            var numOpenRegex = @"\[\d*?\]";
            var numClosedRegex = @"\[/\d*?\]";
            var closedMarkup = "</color>";
            var matches = Regex.Matches(str, numOpenRegex);
            foreach (Match m in matches)
            {
                // Find all possible numbers
                var value = int.Parse(m.Value.Substring(1, m.Value.Length-2));
                // Replace with maximum color if over possible number
                if (value > maxColorId)
                {
                    result = result.Replace(m.Value, Instance.highlightMarkupStrings[Instance.highlightMarkupStrings.Count-1]);
                }
                else if (value < 1)
                {
                    result = result.Replace(m.Value,Instance.highlightMarkupStrings[0]);
                }
            }
    
            for (int i = 0; i < Instance.highlightMarkupStrings.Count; i++)
            {
                result = result.Replace($"[{i + 1}]", Instance.highlightMarkupStrings[i]);
            }

            result = Regex.Replace(result, numClosedRegex, closedMarkup);

            return result;
        }
        
        public static Color GetNotifyColorByType(UINotify.NotifyType type)
        {
            if (Instance.notifyColorMap.TryGetValue(type, out Color color))
            {
                return color;
            }
            
            return Color.white;
        }

        #region Font

        /// <summary>
        /// Gets the TMP_FontAsset associated with current language
        /// </summary>
        /// <returns>Returns the TMP_FontAsset associated with a current language</returns>
        public static TMP_FontAsset GetFont(FontStyle style)
        {
            return GetFont(style, LocalizationModel.CurrentLanguage);
        }

        /// <summary>
        /// Gets the TMP_FontAsset associated with a specified language
        /// </summary>
        /// <returns>Returns the TMP_FontAsset associated with a specified language</returns>
        public static TMP_FontAsset GetFont(FontStyle style, Language language)
        {
            if (Instance.languageFontsMap.TryGetValue(language, out LanguageFonts fonts))
            {
                return fonts.GetFont(style).font;
            }

            return Instance.defaultFont;
        }
        
        /// <summary>
        /// Gets the Material associated with a specified language and style
        /// </summary>
        /// <returns>Returns the Material associated with a specified language and style</returns>
        public static Material GetFontMaterial(FontStyle style)
        {
            return GetFontMaterial(style, LocalizationModel.CurrentLanguage);
        }
        
        /// <summary>
        /// Gets the Material associated with a specified language and style
        /// </summary>
        /// <returns>Returns the Material associated with a specified language and style</returns>
        public static Material GetFontMaterial(FontStyle style, Language language)
        {
            if (Instance.languageFontsMap.TryGetValue(language, out LanguageFonts fonts))
            {
                return fonts.GetFont(style).GetMaterial(FontMaterialType.Standard);
            }

            return Instance.defaultFontMaterial;
        }
        
        #endregion
        
#if UNITY_EDITOR
        [UnityEditor.SettingsProvider]
        public static UnityEditor.SettingsProvider CreateSettingsProvider()
        {
            return CreateGlobalSettingsProvider("Project/LDX/Project/UI");
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIGlobalSettings.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIOverlayFade.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 19c8954dbc22e2949984fa50ce386b45
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.UI.Appearance;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace Ldx.Framework.Systems.UI
{
    /// <summary>
    /// UI component to fade in overtop of the entire 3D world.
    /// Can overlay between other UI elements, however, depending on depth.
    /// </summary>
    [RequireComponent(typeof(CanvasGroup))]
    public class UIOverlayFade : UIElement
    {
        private const float TRANSPARENT_COVER_OPACITY = 0.8f;

        public static event Action OnScreenFadeInComplete;
        public static event Action OnScreenFadeOutComplete;
        
        [SerializeField] private Image fadeImage;
        [SerializeField] private TextMeshProUGUI fadeText;
        private Color defaultColor;
        
        public bool ScreenIsHidden { private set; get; }
        public bool IsShown { private set; get; }

        protected override bool DisableEnableObjectOnFade => false;

        protected override void OnValidate()
        {
            base.OnValidate();

            if (fadeImage == null)
            {
                fadeImage = GetComponentInChildren<Image>();
            }
            
            canvasGroup.alpha = 0;
        }

        protected override void Awake()
        {
            base.Awake();
            if(fadeImage != null)
                defaultColor = fadeImage.color;
            FadeOutScreen(instant:true);
        }
        
        public async UniTask FadeOutScreenAsync(bool instant = false, float overrideTime = -1f)
        {
            bool isCompleted = false;
            ShowElement(instant, overrideTime, () => isCompleted = true);
            await UniTask.WaitUntil(() => isCompleted);
        }
        
        public async UniTask FadeInScreenAsync(bool instant = false, float overrideTime = -1f)
        {
            bool isCompleted = false;
            HideElement(instant, overrideTime, () => isCompleted = true);
            await UniTask.WaitUntil(() => isCompleted);
        }


        /// <summary>
        /// Fades out the screen by fading in the overlay either instantly or over time
        /// </summary>
        /// <param name="instant">Indicates if the fade out should happen instantly</param>
        /// <param name="overrideTime">Overrides default fade time if provided and is non-negative</param>
        /// <param name="callback">Optional callback to invoke upon completion</param>
        public void FadeOutScreen(bool instant = false, float overrideTime = -1f, Action callback = null) => ShowElement(instant, overrideTime, callback);
        
        /// <summary>
        /// Fades in the screen by fading out the overlay either instantly or over time
        /// </summary>
        /// <param name="instant">Indicates if the fade in should happen instantly</param>
        /// <param name="overrideTime">Overrides default fade time if provided and is non-negative</param>
        /// <param name="callback">Optional callback to invoke upon completion</param>
        public void FadeInScreen(bool instant = false, float overrideTime = -1f, Action callback = null) => HideElement(instant, overrideTime, callback);
        
        /// <summary>
        /// Displays a transparent overlay on the screen.
        /// </summary>
        public void ShowTransparentOverlay() => Fade(TRANSPARENT_COVER_OPACITY, false, -1f, ShowElementBeginActions, null);

        protected override void ShowElementBeginActions(bool instant)
        {
            base.ShowElementBeginActions(instant);
            IsShown = true;
        }

        /// <summary>
        /// Called when the fade out transition is completed (screen is hidden and overlay is fully opaque)
        /// </summary>
        protected override void ShowElementCompleted()
        {
            base.ShowElementCompleted();
            ScreenIsHidden = true;
            OnScreenFadeOutComplete?.Invoke();
        }

        protected override void HideElementBeginActions(bool instant)
        {
            base.HideElementBeginActions(instant);
            IsShown = false;
        }

        /// <summary>
        /// Called when the fade in transition is completed (screen is fully opaque and overlay is hidden)
        /// </summary>
        protected override void HideElementCompleted(bool wasActiveBefore)
        {
            base.HideElementCompleted(wasActiveBefore);
            ScreenIsHidden = false;
            OnScreenFadeInComplete?.Invoke();
        }

        public void ResetColor()
        {
            SetColor(defaultColor);
        }

        public void SetColor(Color newColor)
        {
            if(fadeImage != null)
                fadeImage.color = newColor;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIOverlayFade.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIToggle.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a586abd454b88a14a9ff66984fe1ee71
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using DG.Tweening;
using Ldx.Framework.Systems.AudioSystem;
using UnityEngine;
using UnityEngine.UI;

namespace Ldx.Framework.Systems.UI
{
    /// <summary>
    /// An on/off toggle switch.
    /// </summary>
    public class UIToggle : UIButton
    {
        private const float TOGGLE_DURATION = 0.25f;
        
        public event Action<UIToggle, bool> OnToggleSwitched;
        [SerializeField] private Image backgroundImage;
        [SerializeField] private RectTransform toggleKnobRT;
        [SerializeField] private float posXOffset = 25f;
        [SerializeField] private bool isOnOnStart;

        private Tween toggleKnobTween;
        private Tween colorChangeTween;

        private bool toggledOn;
        public bool ToggledOn
        {
            get => toggledOn;
            set
            {
                if (toggledOn == value)
                {
                    return;
                }
                
                toggledOn = value;
                ChangeToggleVisuals();
                OnToggleSwitched?.Invoke(this, toggledOn);
            }
        }
        
        protected override string HoverSound => null;
        protected override string ClickedSound => AudioGlobalSettings.SettingsButtonClick;

        private void Awake()
        {
            ToggledOn = isOnOnStart;
        }

        private void OnDestroy()
        {
            toggleKnobTween?.Kill();
            colorChangeTween?.Kill();
        }
        
        /// <summary>
        /// Set toggle value without invoking OnToggleSwitched callback.
        /// </summary>
        /// <param name="value"> The new value for toggle </param>
        public void SetValueWithoutNotify(bool value)
        {
            toggledOn = value;
            ChangeToggleVisuals();
        }

        public override void PressActions()
        {
            base.PressActions();
            ToggledOn = !ToggledOn;
        }

        private void ChangeToggleVisuals()
        {
            toggleKnobTween?.Kill();
            toggleKnobTween = toggleKnobRT.DOAnchorPosX(ToggledOn ? posXOffset : -posXOffset,
                 TOGGLE_DURATION);
            RefreshButtonColors();
        }

        private void RefreshButtonColors()
        {
            Color toggleBackgroundColor;

            //TODO Update this for brand color selection
            if (ToggledOn)
            {
                toggleBackgroundColor = Color.white;
            }
            else
            {
                toggleBackgroundColor = Color.black;
            }
            
            colorChangeTween?.Kill();

            if (!backgroundImage)
                return;
            if (Application.isPlaying)
            {
                colorChangeTween = backgroundImage.DOColor(toggleBackgroundColor, TOGGLE_DURATION);
            }
            else
            {
                backgroundImage.color = toggleBackgroundColor;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UIToggle.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UITweenedStates.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0e1201eccb0c52d4da0a19919e13b210
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using DG.Tweening;
using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.UI;

namespace Ldx.Framework.Systems.UI
{
    [Serializable]
    public class TweenTarget
    {
        [SerializeField] private GameObject targetObject;
        public GameObject TargetObject => targetObject;

        [Header("Toggle What to Tween")]
        [SerializeField] private bool usePosition = true;
        public bool UsePosition => usePosition;
        [SerializeField] private bool useScale = true;
        public bool UseScale => useScale;
        [SerializeField] private bool useColor = false;
        public bool UseColor => useColor;

        [SerializeField] private bool onlyUseZAxis = false;
        public bool OnlyUseZAxis => onlyUseZAxis;
        [FormerlySerializedAs("targetPosition")]
        [Tooltip("Used if 'Use Position' is enabled")]
        [SerializeField] [FormerlySerializedAs("targetPosition")] private Vector3 hoverPosition;
        public Vector3 HoverPosition => hoverPosition;
        [SerializeField] private Vector3 clickedPosition;
        public Vector3 ClickedPosition => clickedPosition;

        [Tooltip("Used if 'Use Scale' is enabled")]
        [SerializeField] [FormerlySerializedAs("targetScale")] private Vector3 hoverScale = Vector3.one;
        public Vector3 HoverScale => hoverScale;
        [SerializeField] private Vector3 clickedScale = Vector3.one;
        public Vector3 ClickedScale => clickedScale;

        [Tooltip("Used if 'Use Color' is enabled")]
        [SerializeField] [FormerlySerializedAs("targetColor")] private Color hoverColor = Color.white;
        public Color HoverColor => hoverColor;
        [SerializeField] private Color clickedColor = Color.white;
        public Color ClickedColor => clickedColor;


        [SerializeField] private float duration = 0.5f;
        public float Duration => duration;
        [SerializeField] private float delay = 0f;
        public float Delay => delay;
        [SerializeField] private Ease ease = Ease.OutQuad;
        public Ease Ease => ease;

        [HideInInspector] public Vector3 originalPosition;
        [HideInInspector] public Vector3 originalScale;
        [HideInInspector] public Color originalColor;
        [HideInInspector] public Renderer renderer;
        [HideInInspector] public Image image;
    }

    public class UITweenedStates : MonoBehaviour
    {
        public List<TweenTarget> targets = new();

        private Sequence sequence;
    
        private void Awake()
        {
            foreach (TweenTarget t in targets)
            {
                if (t.TargetObject == null) continue;

                t.originalPosition = t.TargetObject.transform.localPosition;
                t.originalScale = t.TargetObject.transform.localScale;

                if (t.UseColor)
                {
                    if (t.renderer == null)
                    {
                        t.renderer = t.TargetObject.GetComponent<Renderer>();
                    }
                    
                    if (t.renderer != null)
                    {
                        t.originalColor = t.renderer.material.color;
                    }
                    else
                    {
                        t.image = t.TargetObject.GetComponent<Image>();
                        if(t.image != null)
                            t.originalColor = t.image.color;   
                    }
                }
            }
        }

        private void OnEnable()
        {
            foreach (TweenTarget t in targets)
            {
                if (t.TargetObject == null) continue;

                t.TargetObject.transform.localPosition = t.originalPosition;
                t.TargetObject.transform.localScale = t.originalScale;

                if (t.UseColor)
                {
                    if (t.renderer != null)
                    {
                        t.renderer.material.color = t.originalColor;
                    }
                    else
                    {
                        if(t.image != null)
                            t.image.color = t.originalColor;   
                    }
                }
            }
        }

        private void OnDestroy()
        {
            sequence?.Kill();
        }

        public void SetState(bool state)
        {
            SetState(state ? ButtonState.Hover : ButtonState.Idle);
        }

        public void SetState(ButtonState state)
        {
            TweenTo(state);
        }

        private void TweenTo(ButtonState state)
        {
            sequence?.Kill();
            foreach (TweenTarget t in targets)
            {
                if (t.TargetObject == null) continue;

                sequence = DOTween.Sequence().SetUpdate(true);

                bool isPressed = state == ButtonState.Pressed;
                bool isHovered = state is ButtonState.Hover or ButtonState.Selected;

                if (t.UsePosition)
                {
                    Vector3 clickedPosition = t.OnlyUseZAxis ? new Vector3(t.TargetObject.transform.localPosition.x, t.TargetObject.transform.localPosition.y, t.ClickedPosition.z) : t.ClickedPosition;
                    Vector3 hoverPosition = t.OnlyUseZAxis ? new Vector3(t.TargetObject.transform.localPosition.x, t.TargetObject.transform.localPosition.y, t.HoverPosition.z) : t.HoverPosition;
                    Vector3 originalPosition = t.OnlyUseZAxis ? new Vector3(t.TargetObject.transform.localPosition.x, t.TargetObject.transform.localPosition.y, t.originalPosition.z) : t.originalPosition;
                    sequence.Join(t.TargetObject.transform.DOLocalMove(
                        isPressed ? clickedPosition : 
                        isHovered ? hoverPosition :
                        originalPosition, t.Duration).SetDelay(t.Delay).SetEase(t.Ease));
                }

                if (t.UseScale)
                    sequence.Join(t.TargetObject.transform.DOScale(
                        isPressed ? t.ClickedScale : 
                        isHovered ? t.HoverScale :
                        t.originalScale, t.Duration).SetDelay(t.Delay).SetEase(t.Ease));

                if (t.UseColor && t.renderer != null)
                {
                    sequence.Join(t.renderer.material.DOColor(
                        isPressed ? t.ClickedColor : 
                        isHovered ? t.HoverColor :
                        t.originalColor, t.Duration).SetDelay(t.Delay).SetEase(t.Ease));
                }
                else if (t.UseColor && t.image != null)
                {
                    sequence.Join(t.image.DOColor(
                        isPressed ? t.ClickedColor : 
                        isHovered ? t.HoverColor :
                        t.originalColor, t.Duration).SetDelay(t.Delay).SetEase(t.Ease));
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/UITweenedStates.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Video/LdxVideoPlayer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: dbd7e934b0b2d8548821a1a5e0d25e4d
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.UI.Dialog;
using Ldx.Framework.Utilities;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Video;

namespace Ldx.Framework.Systems.UI.Video
{
	public class LdxVideoPlayer : Singleton<LdxVideoPlayer>
	{
		private const float ANCHOR_DISTANCE = 2.0f;
		
		public event Action<LdxVideoPlayer> OnVideoPlayerFinished;

		[SerializeField]
		private VideoPlayer videoPlayer;
		[SerializeField]
		private GameObject previewScreen;
		[SerializeField]
		private GameObject display;
		[SerializeField]
		private GameObject skipButton;
		[SerializeField]
		private LdxVideoPlayerControlPanel videoControlPanel;
		[SerializeField]
		private Image previewImage;

		private bool IsPlaying { get; set; }
		private bool IsVideoPlayerActive { get; set; }
		private bool IsMuted { get; set; }

		private string videoFolderPath;
		private bool relyOnAnchor;
		private bool enableSkip;
		private float skipDelay;

		private void Start()
		{
			SetVisualsEnabled(false);
			LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
			LdxTrackingManager.OnAnyObjectiveComplete += HandleAnyObjectiveComplete;
			videoControlPanel.OnControlPanelButtonPressed += HandleControlPanelButtonPressed;
			videoFolderPath = Application.persistentDataPath + "/Resources/Videos/";
#if UNITY_EDITOR
			videoFolderPath = Application.dataPath + "/Resources/Videos/";
#endif
		}

		private void OnDestroy()
		{
			videoControlPanel.OnControlPanelButtonPressed -= HandleControlPanelButtonPressed;
			LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
			LdxTrackingManager.OnAnyObjectiveComplete -= HandleAnyObjectiveComplete;
		}

		private void HandleControlPanelButtonPressed(LdxVideoPlayerControlType controlType)
		{
			switch (controlType)
			{
				case LdxVideoPlayerControlType.Play:
					Play();
					break;
				case LdxVideoPlayerControlType.Pause:
					Pause();
					break;
				case LdxVideoPlayerControlType.Stop:
					Stop();
					break;
				case LdxVideoPlayerControlType.Skip:
					Skip();
					break;
				case LdxVideoPlayerControlType.Mute:
					ToggleMute();
					break;
				default:
					throw new ArgumentOutOfRangeException(nameof(controlType), controlType, "Control type not found.");
			}
		}

		private void ToggleMute()
		{
			IsMuted = !IsMuted;
			videoPlayer.SetDirectAudioMute(0, IsMuted);
			videoControlPanel.MuteIcon.enabled = IsMuted;
		}

		private void HandleAnyObjectiveComplete(IObjective obj)
		{
			if (!IsVideoPlayerActive)
			{
				return;
			}

			FinishVideo();
		}

		private void SetVisualsEnabled(bool enable)
		{
			display.SetActive(enable);
			videoControlPanel.gameObject.SetActive(enable);
		}

		private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
		{
			if (!(eventData is PlayVideoEventData data))
			{
				return;
			}
			IsVideoPlayerActive = true;

			relyOnAnchor = data.RelyOnNearestAnchorInstead;
            if (!relyOnAnchor)
			{
				Transform target = LdxReferenceIDTracker.Instance.GetTransform(data.PositionTransform);
				transform.position = target.position;
				transform.rotation = target.rotation;
			}

			SetVisualsEnabled(true);
			LoadVideo(data);
		}

		public void LoadVideo(PlayVideoEventData videoData)
		{
			videoPlayer.source = videoData.VideoSource;
			if (videoData.VideoSource == VideoSource.VideoClip)
			{
				videoPlayer.clip = videoData.VideoClip;
			}
			else
			{
				videoPlayer.url = videoFolderPath + videoData.VideoName + "." + videoData.Format.ToString().ToUpper().Trim();
			}

			if (string.IsNullOrEmpty(videoPlayer.url))
				Debug.Log($"Path: {videoPlayer.url}");

			enableSkip = videoData.EnableSkip;
			skipDelay = videoData.SkipDelay;

			if (videoData.Preview)
				previewImage.sprite = videoData.Preview;
			else
				previewImage.sprite = null;

			videoPlayer.Prepare();

			videoPlayer.prepareCompleted += OnPrepareCompleted;

			void OnPrepareCompleted(VideoPlayer source)
			{
				videoPlayer.prepareCompleted -= OnPrepareCompleted;
				videoPlayer.loopPointReached += Finished;

				if (videoData.PlayOnLoad)
					Play();
			}
		}

		private void Update()
		{
			if (!IsVideoPlayerActive || !relyOnAnchor)
			{
				return;
			}

			//TODO: update video player position
			transform.position = UIAnchorController.Instance.GetNearestAnchor(ANCHOR_DISTANCE).transform.position;

			if (IsPlaying)
			{
				videoControlPanel.SetVideoLengthSliderValue((float)videoPlayer.time / (float)videoPlayer.length);
			}
		}

		[ContextMenu("Play")]
		public void Play()
		{
			if (enableSkip && skipDelay < videoPlayer.length)
				StartCoroutine(SkipVideo(skipDelay));

			previewScreen.SetActive(false);
			videoPlayer.Play();
			IsPlaying = true;
		}

		[ContextMenu("Pause")]
		public void Pause()
		{
			videoPlayer.Pause();
			IsPlaying = false;
		}

		[ContextMenu("Stop")]
		public void Stop()
		{
			videoPlayer.Stop();
			IsPlaying = false;
			previewScreen.SetActive(true);
		}

		[ContextMenu("Skip")]
		public void Skip()
		{
			FinishVideo();
		}

		private void Finished(VideoPlayer source)
		{
			FinishVideo();
		}

		private void FinishVideo()
		{
			SetVisualsEnabled(false);

			if (!IsVideoPlayerActive)
			{
				return;
			}
			videoPlayer.Stop();
			IsVideoPlayerActive = false;
			IsPlaying = false;
			relyOnAnchor = false;
			previewScreen.SetActive(false);
			skipButton.SetActive(false);

			transform.position = Vector3.zero;

			OnVideoPlayerFinished?.Invoke(this);
			videoPlayer.loopPointReached -= Finished;
		}

		private IEnumerator SkipVideo(float delay)
		{
			yield return new WaitForSeconds(delay);

			skipButton.SetActive(true);

			yield return null;
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Video/LdxVideoPlayer.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Video/LdxVideoPlayerControlPanel.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5935bd33e3239db4da1138e98cfd8529
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;
using UnityEngine.UI;

namespace Ldx.Framework.Systems.UI.Video
{
    public class LdxVideoPlayerControlPanel : MonoBehaviour
    {
        public event Action<LdxVideoPlayerControlType> OnControlPanelButtonPressed;
        
        [SerializeField]
        private Slider videoLengthSlider;
        [SerializeField]
        private Image muteIcon;
        public Image MuteIcon => muteIcon;
        [SerializeField]
        private Button playButton;
        [SerializeField]
        private Button pauseButton;
        [SerializeField]
        private Button stopButton;
        [SerializeField]
        private Button skipButton;
        [SerializeField]
        private Button muteButton;
        
        private void OnEnable()
        {
            playButton.onClick.AddListener(() => HandleButtonPressed(LdxVideoPlayerControlType.Play));
            pauseButton.onClick.AddListener(() => HandleButtonPressed(LdxVideoPlayerControlType.Pause));
            stopButton.onClick.AddListener(() => HandleButtonPressed(LdxVideoPlayerControlType.Stop));
            skipButton.onClick.AddListener(() => HandleButtonPressed(LdxVideoPlayerControlType.Skip));
            muteButton.onClick.AddListener(() => HandleButtonPressed(LdxVideoPlayerControlType.Mute));
        }
        
        private void OnDisable()
        {
            playButton.onClick.RemoveAllListeners();
            pauseButton.onClick.RemoveAllListeners();
            stopButton.onClick.RemoveAllListeners();
            skipButton.onClick.RemoveAllListeners();
            muteButton.onClick.RemoveAllListeners();
        }
        
        private void HandleButtonPressed(LdxVideoPlayerControlType controlType)
        {
            OnControlPanelButtonPressed?.Invoke(controlType);
        }

        public void SetVideoLengthSliderValue(float value)
        {
            videoLengthSlider.value = Mathf.Clamp(value, 0, 1);
        }

        public void SetPlayButtonEnabled(bool enable)
        {
            playButton.gameObject.SetActive(enable);
        }

        public void SetPauseButtonEnabled(bool enable)
        {
            pauseButton.gameObject.SetActive(enable);
        }

        public void SetStopButtonEnabled(bool enable)
        {
            stopButton.gameObject.SetActive(enable);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Video/LdxVideoPlayerControlPanel.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Video/LdxVideoPlayerControlType.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 711da28bbe31aba46b899d5d2c9e916c
# ASMDEF: ldx.framework.runtime.dll
# ---
namespace Ldx.Framework.Systems.UI.Video
{
    public enum LdxVideoPlayerControlType 
    {
        Play = 0,
        Pause,
        Stop,
        Skip,
        Mute
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/UI/Video/LdxVideoPlayerControlType.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/VFX/AlignmentLineRenderer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f334463a56f043e08d93d260ef780821
# ASMDEF: ldx.framework.runtime.dll
# ---
using DG.Tweening;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Systems.VFX
{
    [RequireComponent(typeof(LineRenderer))]
    public class AlignmentLineRenderer : MonoBehaviour
    {        
        private static readonly int MainTex = Shader.PropertyToID("_MainTex");
        private static readonly int FadeLength = Shader.PropertyToID("_FadeLength");
        private static readonly int LineEnd = Shader.PropertyToID("_LineEnd");
        private static readonly int LineStart = Shader.PropertyToID("_LineStart");
        
        [SerializeField] private LineRenderer lineRenderer;
        [SerializeField] private float textureScrollSpeed = -0.5f;
        [SerializeField] private float fadeDistance = 0.3f;
        [SerializeField] private bool pulseWhenActive;
        [ShowIf(nameof(pulseWhenActive), Op.Equals, true)] 
        [SerializeField] private float pulseDuration = 1f;
        
        private Vector2 textureOffset;
        private Transform startTransform;
        private Transform endTransform;
        private Tween pulseLineMaterialTween;

        public bool IsActive { get; private set; }
        public Material Material => lineRenderer.material;
        
        private void OnValidate()
        {
            if (lineRenderer == null)
            {
                lineRenderer = GetComponent<LineRenderer>();
            }
        }

        private void Awake()
        {
            lineRenderer.useWorldSpace = true;
            textureOffset = Material.GetTextureOffset(MainTex);
            Deactivate();
        }

        private void OnDestroy()
        {
            pulseLineMaterialTween?.Kill();
        }

        private void Update()
        {
            if (!IsActive)
            {
                return;
            }
            
            UpdateLinePositions();
            UpdateTextureScroll();
        }

        public void Activate(Transform start, Transform end)
        {
            startTransform = start;
            endTransform = end;
            SetActive(true);
            if (pulseWhenActive)
            {
                PulseLineMaterial();
            }
        }

        public void Deactivate()
        {
            pulseLineMaterialTween?.Kill();
            SetActive(false);
        }

        private void UpdateLinePositions()
        {
            if (lineRenderer.positionCount != 2)
            {
                return;
            }

            if (startTransform == null || endTransform == null)
            {
                Deactivate();
                return;
            }
            
            lineRenderer.SetPosition(0, startTransform.position);
            lineRenderer.SetPosition(1, endTransform.position);
			Material.SetVector(LineStart, startTransform.position);
			Material.SetVector(LineEnd, endTransform.position);
			Material.SetFloat(FadeLength, fadeDistance);
        }

        private void UpdateTextureScroll()
        {
            textureOffset.x += textureScrollSpeed * Time.deltaTime;
            Material.SetTextureOffset(MainTex, textureOffset);
        }
        
        private void SetActive(bool isActive)
        {
            IsActive = isActive;
            lineRenderer.enabled = isActive;
        }

        private void PulseLineMaterial()
        {
            pulseLineMaterialTween?.Kill();
            pulseLineMaterialTween = 
                Material.DOFade(0, pulseDuration).SetEase(Ease.InOutSine).SetLoops(-1, LoopType.Yoyo);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/VFX/AlignmentLineRenderer.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/VFX/DynamicLineRenderer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cde474d716074b11ab3d1965f39db005
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using UnityEngine;

namespace Ldx.Framework.Systems.VFX
{
    [ExecuteInEditMode]
    public class DynamicLineRenderer : MonoBehaviour
    {
        [SerializeField] private LineRenderer lineRenderer;
        [SerializeField] private List<Transform> points = new();
        
        [Header("Curve Settings")]
        [SerializeField] private bool generateAsCurve;
        [SerializeField, Min(1)] private int resolution = 3;

        private List<Vector3> curvePoints = new List<Vector3>();

        private void OnValidate()
        {
            if (lineRenderer == null)
            {
                lineRenderer = GetComponent<LineRenderer>();
            }
        }

        private void Start()
        {
            lineRenderer.positionCount = points.Count;
        }

        private void LateUpdate()
        {
            if (lineRenderer == null || points.Count < 2)
            {
                if (lineRenderer != null) lineRenderer.positionCount = 0;
                return;
            }
            
            if (!generateAsCurve)
            {
                DrawStraightLines();
            }
            else
            {
                DrawCurve();
            }
        }

        private void DrawStraightLines()
        {
            lineRenderer.positionCount = points.Count;
            for (int i = 0; i < points.Count; i++)
            {
                if (points[i] != null)
                {
                    lineRenderer.SetPosition(i, points[i].position);
                }
            }
        }
        
        private void DrawCurve()
        {
            curvePoints.Clear();
            
            for (int i = 0; i < points.Count - 1; i++)
            {
                Vector3 p0 = i == 0 ? points[i].position : points[i - 1].position;
                Vector3 p1 = points[i].position;
                Vector3 p2 = points[i + 1].position;
                Vector3 p3 = (i + 2) >= points.Count ? p2 : points[i + 2].position;
                
                for (int j = 0; j <= resolution; j++)
                {
                    float t = j / (float)resolution;
                    Vector3 pointOnCurve = GetCatmullRomPosition(t, p0, p1, p2, p3);
                    
                    if (curvePoints.Count == 0 || curvePoints[curvePoints.Count - 1] != pointOnCurve)
                    {
                        curvePoints.Add(pointOnCurve);
                    }
                }
            }
        
            lineRenderer.positionCount = curvePoints.Count;
            lineRenderer.SetPositions(curvePoints.ToArray());
        }
        
        private Vector3 GetCatmullRomPosition(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
        {
            Vector3 a = 2f * p1;
            Vector3 b = p2 - p0;
            Vector3 c = 2f * p0 - 5f * p1 + 4f * p2 - p3;
            Vector3 d = -p0 + 3f * p1 - 3f * p2 + p3;
            return 0.5f * (a + (b * t) + (c * t * t) + (d * t * t * t));
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/VFX/DynamicLineRenderer.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/VFX/FXFeedbackUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 076086b115e8434196da5a2b001890fc
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.AudioSystem;
using UnityEngine;

namespace Ldx.Framework.Systems.VFX
{
    /// <summary>
    /// Simple utility to combine FX and SFX calls for correct/incorrect feedback
    /// </summary>
    public static class FXFeedbackUtility
    {
        private const float TIME_TO_DESTROY_FX = 1.0f;

        public static void SpawnCorrectFeedback(Vector3 position, float? adjustedScale = null)
        {
            SpawnFeedback(position, adjustedScale, LdxFxController.FX.Checkmark, AudioGlobalSettings.OnCorrectSound);
        }
        
        public static void SpawnIncorrectFeedback(Vector3 position, float? adjustedScale = null)
        {
            SpawnFeedback(position, adjustedScale, LdxFxController.FX.Incorrect, AudioGlobalSettings.OnIncorrectSound);
        }
        
        private static void SpawnFeedback(Vector3 position,
            float? adjustedScale, 
            LdxFxController.FX fxType,
            string audio)
        {
            LdxFxController.Instance.InstantiateFx(fxType, position,
                adjustedScale: adjustedScale,
                 destroyAfter: TIME_TO_DESTROY_FX, 
                destroyOnObjectiveEnd: false);
            Audio.PlayOneShot(audio);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/VFX/FXFeedbackUtility.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/VFX/LdxFxController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8811b6ef82993654b813787ed30180c8
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;

namespace Ldx.Framework.Systems.VFX
{
	public class LdxFxController : Singleton<LdxFxController>
	{
		[SerializeField]
		private SerializableDictionary<FX, VisualEffect> visualEffects = new SerializableDictionary<FX, VisualEffect>();
		[SerializeField]
		private AlignmentLineRenderer alignmentLineRendererTemplate;

		private SoundInstance objectiveCompletedAudioInstance;
		
		private readonly List<VisualEffect> currentEffects = new List<VisualEffect>();
		private readonly List<VisualEffect> effectsToClearOnObjectiveEnd = new List<VisualEffect>();
		private readonly Dictionary<(Transform, Transform), AlignmentLineRenderer> startEndAlignmentRendererMap = new();

		public enum FX
		{
			Arrow, 
			AuraLocation, 
			AuraObject, 
			WarningMessage,
			Checkmark,
			Incorrect,
			Complete
		}

		public Transform debugPosition;
		public float debugScale = 1.0f;
		public float debugDestroyAfter = 0;
		public Vector3 debugDirection = Vector3.zero;
		public Vector3 debugOffset = Vector3.zero;

		protected override void Awake()
		{
			base.Awake();
			LdxTrackingManager.OnAnyObjectiveComplete += HandleLdxObjectiveCompleted;
		}

		private void Start()
		{
			if (ObjectiveSystem.IsValid)
			{
				ObjectiveSystem.Instance.OnAnyObjectiveComplete += HandleObjectiveComplete;
			}

			if (ScenarioManager.Instance != null)
			{
				ScenarioManager.Instance.OnUnloadingScenarioOrLobby += HandleUnloadingScenarioOrLobby;
			}
		}

		private void OnDestroy()
		{
			LdxTrackingManager.OnAnyObjectiveComplete -= HandleLdxObjectiveCompleted;
			if (ObjectiveSystem.IsValid)
			{
				ObjectiveSystem.Instance.OnAnyObjectiveComplete -= HandleObjectiveComplete;
			}
			if (ScenarioManager.IsValid)
			{
				ScenarioManager.Instance.OnUnloadingScenarioOrLobby -= HandleUnloadingScenarioOrLobby;
			}
		}

		private void HandleUnloadingScenarioOrLobby(ScenarioManager mgr)
		{
			currentEffects.Clear();
			effectsToClearOnObjectiveEnd.Clear();
		}

		private void HandleObjectiveComplete(ObjectiveSystem system, BaseObjective obj)
		{
			ClearFxOnObjectiveEnd();
		}
		
		private void HandleLdxObjectiveCompleted(IObjective obj)
		{
			ClearFxOnObjectiveEnd();
		}

		private void ClearFxOnObjectiveEnd()
		{
			foreach (VisualEffect fx in effectsToClearOnObjectiveEnd)
			{
				if (fx == null)
				{
					continue;
				}
				currentEffects.Remove(fx);
				Destroy(fx.gameObject);
			}
			
			effectsToClearOnObjectiveEnd.Clear();
		}

		public void InstantiateFx(FX fxType, Vector3 position, 
			float? adjustedScale = 1.0f,
			float? destroyAfter = null,
			bool destroyOnObjectiveEnd = true)
		{
			if (!visualEffects.TryGetValue(fxType, out VisualEffect visualEffect))
			{
				return;
			}
			
			VisualEffect spawnedEffect = Instantiate(visualEffect);
			
			if (adjustedScale != null)
			{
				spawnedEffect.AdjustScale(1f);
			}
			
			spawnedEffect.transform.position = position;
			spawnedEffect.transform.LookAt(PlayerController.Instance.MainCamera.transform);
			currentEffects.Add(spawnedEffect);
			
			if (destroyOnObjectiveEnd)
			{
				effectsToClearOnObjectiveEnd.Add(spawnedEffect);
			}
			
			if (destroyAfter != null)
			{
				spawnedEffect.DestroyAfterSeconds(destroyAfter.Value);
				spawnedEffect.OnEffectDestroy += HandleEffectDestroyed;
			}
		}
		
		public VisualEffect InstantiateFx(FX fxType, Transform position, Vector3 offset, Vector3 direction,
			bool matchReferencedTransform = false, float adjustScale = 1,
			float destroyAfter = 0, bool destroyOnObjectiveEnd = true,
			bool parentTransform = true)
		{
			if (!visualEffects.TryGetValue(fxType, out VisualEffect visualEffect))
			{
				return null;
			}

			VisualEffect spawnedEffect;
			if (matchReferencedTransform)
			{
				spawnedEffect = Instantiate(visualEffect, parentTransform ? position.transform : null, true);
				spawnedEffect.transform.localPosition = offset;
				spawnedEffect.transform.localRotation = Quaternion.identity;
				spawnedEffect.transform.localScale = Vector3.one;
			}
			else
			{
				spawnedEffect = Instantiate(visualEffect, position.position + offset, Quaternion.identity, parentTransform ? position.transform : null);
			}
			currentEffects.Add(spawnedEffect);
			
			if (destroyOnObjectiveEnd)
			{
				effectsToClearOnObjectiveEnd.Add(spawnedEffect);
			}

			spawnedEffect.AdjustScale(adjustScale);

			if (direction != Vector3.zero)
			{
				spawnedEffect.SetDirection(direction);
			}

			if (destroyAfter > 0)
			{
				spawnedEffect.DestroyAfterSeconds(destroyAfter);
				spawnedEffect.OnEffectDestroy += HandleEffectDestroyed;
			}

			return spawnedEffect;
		}

		private void HandleEffectDestroyed(VisualEffect effect)
		{
			effect.OnEffectDestroy -= HandleEffectDestroyed;
			
			if (currentEffects.Contains(effect))
			{
				currentEffects.Remove(effect);
			}
			
			if (effectsToClearOnObjectiveEnd.Contains(effect))
			{
				effectsToClearOnObjectiveEnd.Remove(effect);
			}
		}

		public void SpawnObjectiveCompletionEffect(bool playCompletionSFX = true)
		{
			Transform camera = UnityEngine.Camera.main.transform;
			Vector3 pos = camera.position + camera.forward;
			Vector3 offset = transform.position - pos;
			InstantiateFx(FX.Checkmark, transform, offset, Vector3.zero, destroyAfter:1f);

			if (playCompletionSFX)
			{
				PlayObjectiveCompletionSFX();
			}
		}

		private void PlayObjectiveCompletionSFX()
		{
			if (objectiveCompletedAudioInstance != null)
			{
				objectiveCompletedAudioInstance.StopFadeOutAndRelease();
			}
            
			objectiveCompletedAudioInstance = Audio.CreateSoundInstance(AudioGlobalSettings.ObjectiveCompleteSoundRef);

			if (objectiveCompletedAudioInstance != null)
			{
				objectiveCompletedAudioInstance.Play();
				objectiveCompletedAudioInstance.Release();
			}
		}
		
		public void ClearFx(VisualEffect effect)
		{
			currentEffects.Remove(effect);
			effectsToClearOnObjectiveEnd.Remove(effect);
			if (Application.isPlaying)
			{
				Destroy(effect.gameObject);
			}
			else
			{
				DestroyImmediate(effect.gameObject);
			}
		}

		[ContextMenu("Clear FX")]
		public void ClearAllFx()
		{
			for (int i = currentEffects.Count-1; i >= 0; i--)
			{
				if (currentEffects[i] == null)
				{
					currentEffects.RemoveAt(i);
					continue;
				}
				ClearFx(currentEffects[i]);
			}
		}

		[ContextMenu("Test FX")]
		public void TestFx()
		{
			InstantiateFx(FX.Arrow, debugPosition, debugOffset, debugDirection, false, debugScale, debugDestroyAfter);
		}

		public void ActivateAlignmentRenderer(Transform start, Transform end)
		{
			if (start == null || end == null)
			{
				return;
			}
			
			(Transform StartTransform, Transform EndTransform) startEndPair = (start, end);
			if (startEndAlignmentRendererMap.ContainsKey(startEndPair))
			{
				return;
			}
			
			AlignmentLineRenderer alignmentLineRenderer = Instantiate(alignmentLineRendererTemplate, transform);
			alignmentLineRenderer.Activate(start, end);
			startEndAlignmentRendererMap.Add(startEndPair, alignmentLineRenderer);
		}

		public void DeactivateAlignmentRenderer(Transform start, Transform end)
		{
			if (start == null || end == null)
			{
				return;
			}
			
			(Transform StartTransform, Transform EndTransform) startEndPair = (start, end);
			if (startEndAlignmentRendererMap.TryGetValue(startEndPair, out AlignmentLineRenderer alignmentLineRenderer))
			{
				Destroy(alignmentLineRenderer.gameObject);
				startEndAlignmentRendererMap.Remove(startEndPair);
			}
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/VFX/LdxFxController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/VFX/LdxFxEventsTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c15ab05ce1699cb458f3758bb7fd9c89
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using UnityEngine;

namespace Ldx.Framework.Systems.VFX
{
	public class LdxFxEventsTracker : MonoBehaviour
	{
		private void Awake()
		{
			LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
		}

		private void OnDestroy()
		{
			if (LdxTrackingManager.IsValid)
			{
				LdxTrackingManager.Instance.OnObjectiveEvent -= HandleObjectiveEvent;
			}
		}

		private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData eventData)
		{
			switch (eventData)
			{
				case PlayFxEventData data:
					ProcessPlayFx(data);
					return;
				case ClearFXEventData data:
					ProcessClearFX(data);
					return;
				case PlayUIParticleEventData data:
					ProcessPlayUIParticle(data);
					break;
				case AlignmentLineRendererEventData data:
					ProcessAlignmentLineRenderer(data);
					break;
			}
		}
		
		private void ProcessPlayFx(PlayFxEventData data)
		{
			Transform atPosition = LdxReferenceIDTracker.Instance.GetTransform(data.Position);
			LdxFxController.Instance.InstantiateFx(data.FX, atPosition, data.Offset, data.Direction, data.MatchReferencedTransform, data.Scale, data.DestroyAfter, data.ClearsOnObjectiveEnd);
		}

		private void ProcessClearFX(ClearFXEventData data)
		{
			waitThenProcess().Forget();
			
			async UniTaskVoid waitThenProcess()
			{
				await UniTask.Delay(Mathf.FloorToInt(data.Delay * 1000));
				LdxFxController.Instance.ClearAllFx();
			}
		}
		
		private void ProcessPlayUIParticle(PlayUIParticleEventData data)
		{
			Transform camera = UnityEngine.Camera.main.transform;
			LdxFxController.Instance.InstantiateFx(data.IsCorrectParticles ? LdxFxController.FX.Checkmark : LdxFxController.FX.Incorrect, camera.transform, camera.forward, Vector3.up);
		}
		
		private void ProcessAlignmentLineRenderer(AlignmentLineRendererEventData data)
		{
			Transform startPosition = LdxReferenceIDTracker.Instance.GetTransform(data.StartTransform);
			Transform endPosition = LdxReferenceIDTracker.Instance.GetTransform(data.EndTransform);
			
			switch (data.Action)
			{
				case AlignmentLineRendererEventData.ActionType.Activate:
					LdxFxController.Instance.ActivateAlignmentRenderer(startPosition, endPosition);
					break;
				case AlignmentLineRendererEventData.ActionType.Deactivate:
					LdxFxController.Instance.DeactivateAlignmentRenderer(startPosition, endPosition);
					break;
				default:
					throw new ArgumentOutOfRangeException();
			}
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/VFX/LdxFxEventsTracker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Systems/VFX/VisualEffect.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 028137d88eb24fcd81ca8b517d001617
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Tools;
using UnityEngine;

namespace Ldx.Framework.Systems.VFX
{
    public class VisualEffect : MonoBehaviour
    {
        public event Action<VisualEffect> OnEffectDestroy;
        
        [SerializeField]
        private Transform[] scaleTransforms;

        private DestroyAfter destroyAfter;

        private void OnDestroy()
        {
            OnEffectDestroy?.Invoke(this);
        }

        public void AdjustScale(float scale)
        {
            foreach (Transform scaleTransform in scaleTransforms)
            {
                scaleTransform.transform.localScale = new Vector3(scale, scale, scale);
            }
        }

        public void SetDirection(Vector3 direction)
        {
            transform.LookAt(transform.position + direction);
        }

        public void DestroyAfterSeconds(float duration)
        {
            destroyAfter = gameObject.GetOrAddComponent<DestroyAfter>();
            destroyAfter.destroyAfter = duration;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Systems/VFX/VisualEffect.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/ActiveObjectWithDelay.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1101b3f0493e4474b1df05f1dea88ed4
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities
{
    public class ActiveObjectWithDelay : MonoBehaviour
    {
        [SerializeField]
        private float delay = 1;
        
        public void ActivateWithDelay()
        {
            Invoke(nameof(ActivateObject), delay);
        }

        private void ActivateObject()
        {
            gameObject.SetActive(true);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/ActiveObjectWithDelay.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenCanvasGroupFadeBehaviour.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7d332e1960354b98a7d564dd8a39a273
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using DG.Tweening;

namespace Ldx.Framework.Utilities.Animation
{
    [Serializable]
    public class DoTweenCanvasGroupFadeBehaviour : DoTweenCanvasGroupBaseBehaviour
    {
        public float endValue;
        public bool interactable;
        public bool blockRaycasts;

        private struct CanvasState
        {
            public float alpha;
            public bool interactable;
            public bool blockRaycasts;
        }

        private CanvasState? cachedState;
        
        public override Tween InitializeTween()
        {
            return DOTween.Sequence()
                .AppendCallback(() => canvasGroup.interactable = interactable)
                .AppendCallback(() => canvasGroup.blocksRaycasts = blockRaycasts)
                .Append(canvasGroup.DOFade(endValue, duration));
        }

        public override void CacheState()
        {
            cachedState = new CanvasState
            {
                alpha = canvasGroup.alpha,
                interactable = canvasGroup.interactable,
                blockRaycasts = canvasGroup.blocksRaycasts
            };
        }

        public override void ResetState()
        {
            if (cachedState.HasValue)
            {
                canvasGroup.alpha = cachedState.Value.alpha;
                canvasGroup.interactable = cachedState.Value.interactable;
                canvasGroup.blocksRaycasts = cachedState.Value.blockRaycasts;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenCanvasGroupFadeBehaviour.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenGraphicColorChangeBehaviour.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: adcda8a03b4640d2838949f696273f26
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using DG.Tweening;
using UnityEngine;

namespace Ldx.Framework.Utilities.Animation
{
    [Serializable]
    public class DoTweenGraphicColorChangeBehaviour : DoTweenGraphicBaseBehaviour
    {
        public Color endValue;

        private Color? cachedColor;
        
        public override Tween InitializeTween()
        {
            return graphic.DOColor(endValue, duration);
        }
        
        public override void CacheState()
        {
            cachedColor = graphic.material.color;
        }

        public override void ResetState()
        {
            if (cachedColor.HasValue)
            {
                graphic.material.color = cachedColor.Value;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenGraphicColorChangeBehaviour.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenGraphicFadeBehaviour.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9dc4ba1bd30b4205bda5657a40dc2041
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using DG.Tweening;
using Ldx.Framework.Utilities.Extensions;

namespace Ldx.Framework.Utilities.Animation
{
    [Serializable]
    public class DoTweenGraphicFadeBehaviour : DoTweenGraphicBaseBehaviour
    {
        public float endValue;
        public bool useStartValue;
        public float startValue;

        private float? cachedAlpha;
        
        public override Tween InitializeTween()
        {
            if (useStartValue)
            {
                graphic.material.color = graphic.material.color.Modify(a: startValue);
            }
            return graphic.DOFade(endValue, duration);
        }
        
        public override void CacheState()
        {
            cachedAlpha = graphic.material.color.a;
        }

        public override void ResetState()
        {
            if (cachedAlpha.HasValue)
            {
                graphic.material.color = graphic.material.color.Modify(a: cachedAlpha.Value);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenGraphicFadeBehaviour.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenLineRendererFadeBehaviour.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7555efcc56e947b7a29a7a1044bd75ed
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using DG.Tweening;
using UnityEngine;

namespace Ldx.Framework.Utilities.Animation
{
    [Serializable]
    public class DoTweenLineRendererFadeBehaviour : DoTweenLineRendererBaseBehaviour
    {
        private Material material;

        public float endValue = 1;
        public float startValue = 0;
        public string revealPropertyName = "_Reveal";

        private float? cachedRevealValue;

        public override Tween InitializeTween()
        {
            if (Application.isPlaying)
            {
                if (material == null)
                {
                    material = lineRenderer.material;
                }
            }
            else
            {
                material = lineRenderer.sharedMaterial;
            }
           
            material.SetFloat(revealPropertyName, startValue);
            return material.DOFloat(endValue, revealPropertyName, duration);
        }
        
        public override void CacheState()
        {
            if (!material)
            {
                return;
            }

            cachedRevealValue = material.GetFloat(revealPropertyName);
        }

        public override void ResetState()
        {
            if (cachedRevealValue.HasValue)
            {
                material.SetFloat(revealPropertyName, cachedRevealValue.Value);
            }
        }

        public override void Dispose()
        {
            base.Dispose();
            material = null;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenLineRendererFadeBehaviour.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenLineRendererPointToPositionBehaviour.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9eaa25086702458585f288031a07fa4d
# ASMDEF: ldx.framework.runtime.dll
# ---
using DG.Tweening;
using UnityEngine;

namespace Ldx.Framework.Utilities.Animation
{
    [System.Serializable]
    public class DoTweenLineRendererPointToPositionBehaviour : DoTweenLineRendererBaseBehaviour
    {
        [System.Serializable]
        public class PointToPositionGroup
        {
            public int pointIndex; 
            public Transform target;
            public bool resetBeforeTween;
            public Transform resetTarget;
        }
        
        public PointToPositionGroup[] pointToPositionGroups;
        
        private struct LineRendererState
        {
            public Vector3[] positions;
        }

        private LineRendererState? cachedState;

        public override Tween InitializeTween()
        {
            ResetToTargetPositions();
            
            Sequence tweenSequence = DOTween.Sequence();

            foreach (PointToPositionGroup group in pointToPositionGroups)
            {
                int pointIndex = group.pointIndex;
                Transform target = group.target;

                if (target == null)
                {
                    continue;
                }
                
                tweenSequence.Append(DOTween.To(
                        () => lineRenderer.GetPosition(pointIndex),
                        pos => lineRenderer.SetPosition(pointIndex, pos),
                        target.position, duration)
                    .SetEase(ease)
                    .SetDelay(delay));
            }

            return tweenSequence;
        }
        
        private void ResetToTargetPositions()
        {
            foreach (PointToPositionGroup group in pointToPositionGroups)
            {
                if (group.resetBeforeTween && group.resetTarget)
                {
                    lineRenderer.SetPosition(group.pointIndex, group.resetTarget.position);
                }
            }
        }
        
        public override void CacheState()
        {
            Vector3[] cachedPositions = new Vector3[lineRenderer.positionCount];
            lineRenderer.GetPositions(cachedPositions);

            cachedState = new LineRendererState
            {
                positions = cachedPositions
            };
        }

        public override void ResetState()
        {
            if (cachedState.HasValue)
            {
                lineRenderer.SetPositions(cachedState.Value.positions);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenLineRendererPointToPositionBehaviour.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenRectTransformDeltaSizeBehaviour.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8e73f8e4e62ba464c8479de75c697c7d
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using DG.Tweening;
using UnityEngine;

namespace Ldx.Framework.Utilities.Animation
{
    [Serializable]
    public class DoTweenRectTransformDeltaSizeBehaviour : DoTweenRectTransformBaseBehaviour
    {
        public bool snapping = false;
        public Vector3 endValue = Vector3.zero;

        private Vector3? cachedSize;
        
        public override Tween InitializeTween()
        {
            return rectTransform.DOSizeDelta(endValue, duration, snapping);
        }
        
        public override void CacheState()
        {
            cachedSize = rectTransform.sizeDelta;
        }

        public override void ResetState()
        {
            if (cachedSize.HasValue)
            {
                rectTransform.sizeDelta = cachedSize.Value;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenRectTransformDeltaSizeBehaviour.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenTransformMoveBehaviour.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4cab035a105d467291c9cd62b9b31405
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using DG.Tweening;
using UnityEngine;

namespace Ldx.Framework.Utilities.Animation
{
    [Serializable]
    public class DoTweenTransformMoveBehaviour : DoTweenTransformBaseBehaviour
    {
        public bool useLocal = true;
        public Vector3 endValue = Vector3.zero;
        public bool useStartValue;
        public Vector3 startValue = Vector3.zero;
        
        public bool useReferenceTransforms;
        public Transform startReference;
        public Transform endReference;
        private Vector3? cachedScale;

        public override Tween InitializeTween()
        {
            if (useLocal)
            {
                transform.localPosition = useStartValue 
                    ? useReferenceTransforms && startReference
                        ? transform.parent
                            ? transform.parent.InverseTransformPoint(startReference.position)
                            : startReference.position 
                        : startValue
                    : transform.localPosition;

                Vector3 endLocal = useReferenceTransforms && endReference
                    ? (transform.parent
                        ? transform.parent.InverseTransformPoint(endReference.position)
                        : endReference.position)
                    : endValue;

                return transform.DOLocalMove(endLocal, duration);
            }

            if (useStartValue)
            {
                transform.position = startReference ? startReference.position : startValue;
            }

            Vector3 endWorld = useReferenceTransforms && endReference
                ? endReference.position
                : endValue;

            return transform.DOMove(endWorld, duration);
        }

        public override void CacheState()
        {
            cachedScale = useLocal ? transform.localPosition : transform.position;
        }

        public override void ResetState()
        {
            if (!cachedScale.HasValue) 
                return;
            
            if (useLocal)
            {
                transform.localPosition = cachedScale.Value;
            }
            else
            {
                transform.position = cachedScale.Value;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenTransformMoveBehaviour.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenTransformRotateBehaviour.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 65d59e634c3507a409a41c767d7a0e75
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using DG.Tweening;
using UnityEngine;

namespace Ldx.Framework.Utilities.Animation
{
    /// <summary>
    /// Tween a Transform's rotation between a start and end (optionally from reference Transforms),
    /// respecting base behaviour delay/ease and Append/Join sequencing.
    /// </summary>
    [Serializable]
    public class DoTweenTransformRotateBehaviour : DoTweenTransformBaseBehaviour
    {
        public bool useLocal = true;

        public Vector3 endValue = Vector3.zero;
        public bool useStartValue;
        public Vector3 startValue = Vector3.zero;

        public bool useReferenceTransforms;
        public Transform startReference;
        public Transform endReference;

        public RotateMode rotateMode = RotateMode.Fast;

        private Quaternion? cachedRotation;

        public override Tween InitializeTween()
        {
            if (useLocal)
            {
                transform.localRotation = useStartValue 
                    ? useReferenceTransforms && startReference 
                        ? startReference.localRotation 
                        : Quaternion.Euler(startValue)
                    : transform.localRotation;

                Vector3 targetEuler = useReferenceTransforms && endReference
                    ? endReference.localEulerAngles
                    : endValue;

                return transform.DOLocalRotate(targetEuler, duration, rotateMode);
            }

            transform.rotation = useStartValue
                ? useReferenceTransforms && startReference
                    ? startReference.rotation
                    : Quaternion.Euler(startValue) 
                : transform.rotation;

            Vector3 worldEuler = useReferenceTransforms && endReference
                ? endReference.eulerAngles
                : endValue;

            return transform.DORotate(worldEuler, duration, rotateMode);
        }

        public override void CacheState()
        {
            cachedRotation = useLocal ? transform.localRotation : transform.rotation;
        }

        public override void ResetState()
        {
            if (!cachedRotation.HasValue) 
                return;
            
            if (useLocal)
            {
                transform.localRotation = cachedRotation.Value;
            }
            else
            {
                transform.rotation = cachedRotation.Value;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenTransformRotateBehaviour.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenTransformScaleBehaviour.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: fd6128a3df22454eb46ca8843bd519b5
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using DG.Tweening;
using UnityEngine;

namespace Ldx.Framework.Utilities.Animation
{
    [Serializable]
    public class DoTweenTransformScaleBehaviour : DoTweenTransformBaseBehaviour
    {
        public Vector3 endValue = Vector3.zero;
        public bool useStartValue;
        public Vector3 startValue = Vector3.zero;

        private Vector3? cachedScale;
        
        public override Tween InitializeTween()
        {
            if (useStartValue)
            {
                transform.localScale = startValue;
            }
            
            return transform.DOScale(endValue, duration);
        }

        public override void CacheState()
        {
            cachedScale = transform.localScale;
        }

        public override void ResetState()
        {
            if (cachedScale.HasValue)
            {
                transform.localScale = cachedScale.Value;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Behaviours/DoTweenTransformScaleBehaviour.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Common/DoTweenBaseBehaviour.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f2305739c61c437b84a16615f4b922c6
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using DG.Tweening;
using UnityEngine;

namespace Ldx.Framework.Utilities.Animation
{
    /// <summary>
    /// Represents the base behaviour for DoTween animations. This class is abstract and provides basic 
    /// functionality for tweening actions, such as setting delay, duration, and easing.
    /// </summary>
    [Serializable]
    public abstract class DoTweenBaseBehaviour : IDisposable
    {
        public enum BehaviourAction
        {
            Append,
            Join
        }
        
        [HideInInspector]
        public BehaviourAction action;
        [HideInInspector]
        public float delay = 0f;
        [HideInInspector]
        public float duration = 2f;
        [HideInInspector]
        public Ease ease = Ease.Linear;

#if UNITY_EDITOR
        public enum BehaviourCategory
        {
            None = 0,
            Transform = 1,
            RectTransform = 2,
            Graphic = 3,
            LineRenderer = 4,
            CanvasGroup = 5,
        }

        public virtual BehaviourCategory Category => BehaviourCategory.None;
#endif

        /// <summary>
        /// Creates and returns a Tween with the configured delay and easing. The actual tween is initialized
        /// by the derived class via the <see cref="InitializeTween"/> method.
        /// </summary>
        /// <returns>A Tween object with the configured settings.</returns>
        public virtual Tween Tween()
        {
            return InitializeTween().SetDelay(delay).SetEase(ease);
        }
        
        /// <summary>
        /// Initializes and returns the specific tween for this behaviour. 
        /// This method must be implemented by derived classes.
        /// </summary>
        /// <returns>The specific Tween for this behaviour.</returns>
        public abstract Tween InitializeTween();
        
        /// <summary>
        /// Caches the initial state of the object before the tween is applied.
        /// This method must be implemented by derived classes.
        /// </summary>
        public abstract void CacheState();
        
        /// <summary>
        /// Resets the object to its cached state after the tween has completed.
        /// This method must be implemented by derived classes.
        /// </summary>
        public abstract void ResetState();
        
        /// <summary>
        /// Disposes of any resources held by this behaviour. This is a virtual method that can be overridden if necessary.
        /// </summary>
        public virtual void Dispose() { }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Common/DoTweenBaseBehaviour.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Common/DoTweenCanvasGroupBaseBehaviour.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: aecea5cf9c1c4c75acee2397a49b45e1
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Animation
{
    public abstract class DoTweenCanvasGroupBaseBehaviour : DoTweenBaseBehaviour
    {
        public CanvasGroup canvasGroup;
        
#if UNITY_EDITOR
        public override BehaviourCategory Category => BehaviourCategory.CanvasGroup;
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Common/DoTweenCanvasGroupBaseBehaviour.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Common/DoTweenGraphicBaseBehaviour.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 00a8cebc99b6420692533a5a8c8e85c8
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;
using UnityEngine.UI;

namespace Ldx.Framework.Utilities.Animation
{
    public abstract class DoTweenGraphicBaseBehaviour : DoTweenBaseBehaviour
    {
        [Header("Graphic")]
        public Graphic graphic;
        
#if UNITY_EDITOR
        public override BehaviourCategory Category => BehaviourCategory.Graphic;
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Common/DoTweenGraphicBaseBehaviour.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Common/DoTweenLineRendererBaseBehaviour.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 631791ecb5d941749a3c6cb1de9e7e07
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Animation
{
    public abstract class DoTweenLineRendererBaseBehaviour : DoTweenBaseBehaviour
    {
        public LineRenderer lineRenderer;
        
#if UNITY_EDITOR
        public override BehaviourCategory Category => BehaviourCategory.LineRenderer;
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Common/DoTweenLineRendererBaseBehaviour.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Common/DoTweenRectTransformBaseBehaviour.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3ea710c6360745ae9179e65a784f91ca
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Animation
{
    public abstract class DoTweenRectTransformBaseBehaviour : DoTweenBaseBehaviour
    {
        public RectTransform rectTransform;
        
#if UNITY_EDITOR
        public override BehaviourCategory Category => BehaviourCategory.RectTransform;
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Common/DoTweenRectTransformBaseBehaviour.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Common/DoTweenTransformBaseBehaviour.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d62e61ed2b0a44cf83dc2cae95d209c2
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Animation
{
    public abstract class DoTweenTransformBaseBehaviour : DoTweenBaseBehaviour
    {
        public Transform transform;
        
#if UNITY_EDITOR
        public override BehaviourCategory Category => BehaviourCategory.Transform;
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/Common/DoTweenTransformBaseBehaviour.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/DoTweenAnimation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e4419d0c78e939048a3cb032bfb5c48a
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using Ldx.Framework.Features.Visual.Tweening;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Utilities.Animation
{
    /// <summary>
    /// A representation of a list of tween steps, containing a collection of DoTweenBaseBehaviour objects.
    /// </summary>
    [Serializable]
    public class DoTweenBehaviourContainer : IEnumerable<DoTweenBaseBehaviour>
    {
        [SerializeReference]
        private List<DoTweenBaseBehaviour> behaviours = new List<DoTweenBaseBehaviour>();

        public int Count => behaviours.Count;
        public DoTweenBaseBehaviour this[int i] => behaviours[i];

        public IEnumerator<DoTweenBaseBehaviour> GetEnumerator()
        {
            return behaviours.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
    
    /// <summary>
    /// A component that manages and plays a sequence of tween animations, using behaviours from DoTweenBehaviourContainer.
    /// </summary>
    public class DoTweenAnimation : MonoBehaviour, IAnimationPlayble
    {
        public event Action<IAnimationPlayble> OnFinishedPlaying;

        [SerializeField] private string id = "id";
        public string ID => id;
        
        [SerializeField] private bool playOnEnable = true;
        [SerializeField] private bool loop = true;
        [Min(-1)] 
        [SerializeField] private int loopCount = 1;
        [SerializeField] private LoopType loopType = LoopType.Restart;
        
        [SerializeField] 
        private DoTweenBehaviourContainer tweenBehaviourContainer = new DoTweenBehaviourContainer();
        
        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private List<string> playAnimationTriggerEvents = new List<string>();
        [SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        private List<string> stopAnimationTriggerEvents = new List<string>();
        
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string completedTrackingEventId = string.Empty;

        public DoTweenBehaviourContainer Behaviours => tweenBehaviourContainer;
        
        private Sequence tweenSequence;

        public bool IsPlaying => tweenSequence != null && tweenSequence.IsPlaying();
        
        private void OnEnable()
        {
            if (playOnEnable)
            {
                Play();
            }
        }

        private void Start()
        {
            StartAsync().Forget();
        }

        private async UniTaskVoid StartAsync()
        {
            await UniTask.WaitUntil(() => LdxTrackingManager.IsValid);
            LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
        }

        private void HandleTrackingEvent(string trackingEventID)
        {
            if (playAnimationTriggerEvents.Contains(trackingEventID))
            {
                Play();
            }
            else if(stopAnimationTriggerEvents.Contains(trackingEventID))
            {
                Stop();
            }
        }

        private void OnDisable()
        {
            Stop();
        }

        private void OnDestroy()
        {
            Stop();
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }
        }
        
        /// <summary>
        /// Plays the tween sequence. If the sequence is already playing, it will be stopped and restarted if forceRestart is true.
        /// </summary>
        public void Play()
        {
            Play(false);
        }
        
        /// <summary>
        /// Plays the tween sequence. If the sequence is already playing, it will be stopped and restarted if forceRestart is true.
        /// </summary>
        /// <param name="forceRestart">Indicates whether to forcefully restart the tween sequence if it is already playing.</param>
        public void Play(bool forceRestart)
        {
            if (IsPlaying)
            {
                if (forceRestart)
                {
                    Stop();
                }
                else
                {
                    return;
                }
            }
            tweenSequence = CreateSequence();
            tweenSequence.Play();
        }

        /// <summary>
        /// Creates a new tween sequence based on the behaviours in the tweenBehaviourContainer.
        /// </summary>
        /// <returns>A new Sequence object containing the tween steps.</returns>
        public Sequence CreateSequence()
        {
            Sequence sequence = DOTween.Sequence();
            foreach (DoTweenBaseBehaviour behaviour in tweenBehaviourContainer)
            {
                behaviour.CacheState();
                
                switch (behaviour.action)
                {
                    case DoTweenBaseBehaviour.BehaviourAction.Append:
                        sequence.Append(behaviour.Tween());
                        break;
                    case DoTweenBaseBehaviour.BehaviourAction.Join:
                        sequence.Join(behaviour.Tween());
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
            
            if (loop)
            {
                sequence.SetLoops(loopCount, loopType);
            }

            sequence.OnComplete(() =>
            {
                OnFinishedPlaying?.Invoke(this);
                LdxTrackingManager.Instance.BroadcastTrackingEvent(completedTrackingEventId);
            });
            return sequence;
        }

        /// <summary>
        /// Stops the currently playing tween sequence.
        /// </summary>
        public void Stop()
        {
            tweenSequence?.Kill(true);
            tweenSequence = null;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/DoTweenAnimation.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/DoTweenAnimationController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2c5c9d58fdd64f039a4f03c8924a6e82
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using UnityEngine;

namespace Ldx.Framework.Utilities.Animation
{
    public class DoTweenAnimationController : MonoBehaviour
    {
        [SerializeField]
        private List<DoTweenAnimation> animations = new List<DoTweenAnimation>();

        private readonly Dictionary<string, DoTweenAnimation> tweenAnimationsByID = new();

        private DoTweenAnimation currentAnimation;

        private void Awake()
        {
            foreach (DoTweenAnimation tweenAnimation in animations)
            {
                tweenAnimationsByID.TryAdd(tweenAnimation.ID, tweenAnimation);
            }
        }

        public void PlayAnimation(string id)
        {
            if (tweenAnimationsByID.TryGetValue(id, out DoTweenAnimation anim))
            {
                StopCurrentAnimation();

                currentAnimation = anim;
                currentAnimation.Play();
            }
        }

        public void StopAnimation(string id)
        {
            if (tweenAnimationsByID.TryGetValue(id, out DoTweenAnimation anim))
            {
                StopAnimation(anim);
            }
        }

        private void StopCurrentAnimation()
        {
            StopAnimation(currentAnimation);
            currentAnimation = null;
        }

        private void StopAnimation(DoTweenAnimation anim)
        {
            if (anim == null)
            {
                return;
            }
            
            anim.Stop();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Animation/DoTweenAnimationController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Async/AsyncOperationGroup.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6485ecf05cd448efbafa698ecd4263c1
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Cysharp.Threading.Tasks;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Ldx.Framework.Utilities.Async
{
    /// <summary>
    /// For handling and tracking group async operations, such as
    /// loading multiple resources at once
    /// </summary>
    public class AsyncOperationGroup
    {
        readonly private List<AsyncOperation> operations = new List<AsyncOperation>();

        private UniTask? operationTrackingTask;
        public float Progress => operations.Count > 0
            ? operations.Sum(o => o.progress) / operations.Count
            : FinishedOperationsCount > 0 ? 1 : 0;

        private bool ForceFinished { get; set; }
        public bool IsFinished => ForceFinished || (operations.Count == 0 && FinishedOperationsCount > 0);
        public int FinishedOperationsCount { get; set; }

        public void UnionWith(AsyncOperationGroup other)
        {
            other.operations.ForEach(TrackOperation);
        }

        public void AddOperation(AsyncOperation operation)
        {
            TrackOperation(operation);
        }

        public void ForceFinish()
        {
            ForceFinished = true;
        }

        public async UniTask<T> AddAssetRequestAsync<T>(ResourceRequest operation, Action<T> callback = null) where T : Object
        {
            TrackOperation(operation);
            await UniTask.WaitUntil(() => operation.isDone);
            T result = operation.asset as T;
            callback?.Invoke(result);
            return result;
        }

        public async UniTask Wait()
        {
            await UniTask.WaitUntil(() => IsFinished);
        }

        private void TrackOperation(AsyncOperation operation)
        {
            operations.Add(operation);
            if (operationTrackingTask == null)
            {
                operationTrackingTask = TrackOperationsAsync();
            }
        }

        private void RemoveOperation(AsyncOperation operation)
        {
            if (!operations.Contains(operation))
            {
                return;
            }
            operations.Remove(operation);
            FinishedOperationsCount++;
        }

        private async UniTask TrackOperationsAsync()
        {
            while (operations.Count > 0)
            {
                for (int i = operations.Count - 1; i >= 0; i--)
                {
                    AsyncOperation operation = operations[i];
                    
                    if (operation.isDone)
                    {
                        RemoveOperation(operation);
                    }
                }
                
                await UniTask.Yield();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Async/AsyncOperationGroup.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/ConvertsToAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7f62ba1756024cc08f91fd9c3d464bd7
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    [AttributeUsage(AttributeTargets.Class)]
    public class ConvertsToAttribute : PropertyAttribute
    {
        public Type Type { get; }

        public ConvertsToAttribute(Type type)
        {
            Type = type;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/ConvertsToAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/GroupAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 16be4504078349e883b1d2b249c7d872
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    /// <summary>
    /// Attribute used to group serialized fields under a foldout header in the inspector.
    /// </summary>
    [System.AttributeUsage(System.AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
    public class GroupAttribute : PropertyAttribute
    {
        public string GroupName { get; private set; }

        /// <summary>
        /// Groups serialized fields under a foldout header.
        /// </summary>
        /// <param name="groupName">The name of the group (header).</param>
        public GroupAttribute(string groupName)
        {
            GroupName = groupName;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/GroupAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/HelpBoxAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d057b5b4c59c49ceb254e6e1048a2764
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    [AttributeUsage(AttributeTargets.Field)]
    public class HelpBoxAttribute : PropertyAttribute 
    {
        public string Text { get; }
        
        public HelpBoxAttribute(string text)
        {
            Text = text;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/HelpBoxAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/HideAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8d716642de2c4c38adecefe703fe3ecb
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    [AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = true)]
    public class HideAttribute : PropertyAttribute
    {
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/HideAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/IDSelectionAllAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0ff74db50c1849099fcbbf65a3753fda
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives;

namespace Ldx.Framework.Utilities.Attributes
{
    [AttributeUsage(AttributeTargets.Field)]
    public class IDSelectionAllAttribute : IDSelectionAttribute
    {
        public IDSelectionAllAttribute(LdxIdSettings.IdType idType) : base(idType)
        {
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/IDSelectionAllAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/IDSelectionAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9da17078b3d44d968ab3e9f4a90f9143
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.ID;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    [AttributeUsage(AttributeTargets.Field)]
    public class IDSelectionAttribute : PropertyAttribute
    {
        public readonly IdTypeWrapper idType;

        public IDSelectionAttribute(IdTypeWrapper idType)
        {
            this.idType = idType;
        }
        
        public IDSelectionAttribute(LdxIdSettings.IdType idType)
        {
            this.idType = idType;
        }

        public IDSelectionAttribute(Type type)
        {
            // will be stripped anyway but just to be safe
#if UNITY_EDITOR
            Type baseType = typeof(ExtensionIDDefinition);

            if (type.IsAbstract || !type.IsClass || !baseType.IsAssignableFrom(type))
            {
                Debug.LogError($"[IDSelection]: {type.FullName} isn't a valid extension definition");
                return;
            }

            ExtensionIDDefinition instance = (ExtensionIDDefinition)Activator.CreateInstance(type);
            idType = instance.IdTypeWrapper;
#endif
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/IDSelectionAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/IDSelectionShowIfEventTypeAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 545c1759442d48249d072c9404492123
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives;

namespace Ldx.Framework.Utilities.Attributes
{
    [AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = true)]
    public class IDSelectionShowIfEventTypeAttribute : IDSelectionAttribute
    {
        public ObjectiveEventData.TriggerEventType TriggerFilterType { get; }
        public LdxIdSettings.IdType IDType { get; }
        
        public IDSelectionShowIfEventTypeAttribute(ObjectiveEventData.TriggerEventType triggerFilterType, LdxIdSettings.IdType idType) : base(idType)
        {
            TriggerFilterType = triggerFilterType;
            IDType = idType;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/IDSelectionShowIfEventTypeAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/InheritedClassContainerAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 45e5a8bb602f4c179e2a27b2a72d2810
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;

namespace Ldx.Framework.Utilities.Attributes
{
    [AttributeUsage(AttributeTargets.Field)]
    public class InheritedClassContainerAttribute : SerializableContainerAttribute
    {
        public Type Type { get; }
        public string SuffixToRemove { get; }
        public string ItemTitle { get; }
        public bool UniqueItemsOnly { get; }
        
        public InheritedClassContainerAttribute(Type type, string itemTitle = null, string suffixToRemove = null,  
            bool uniqueItemsOnly = false, bool drawAddRemoveButtons = true, string fieldName = null) 
        {
            Type = type;
            SuffixToRemove = suffixToRemove;
            ItemTitle = itemTitle;
            UniqueItemsOnly = uniqueItemsOnly;
            DrawAddRemoveButtons = drawAddRemoveButtons;
            FieldName = fieldName;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/InheritedClassContainerAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/InheritedClassDropdownAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: dfa63349e657447f86cb8b2a99cbd27f
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    /// <summary>
    /// Attribute for drawing a dropdown of inherited classes on a SerializedReference field
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    public class InheritedClassDropdownAttribute : PropertyAttribute
    {
        public Type BaseType { get; }
        public string TypeSuffixToExclude { get; }
        
        public InheritedClassDropdownAttribute(Type baseType, string typeSuffixToExclude = null)
        {
            BaseType = baseType;
            TypeSuffixToExclude = typeSuffixToExclude;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/InheritedClassDropdownAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/NodeMenuItemAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 88775c2663474fd38f0c76e4e738c45a
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;

namespace Ldx.Framework.Utilities.Attributes
{
    /// <summary>
    /// Register the node in the NodeProvider class. The node will also be available in the node creation window.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
    public class NodeMenuItemAttribute : Attribute
    {
        public string	menuTitle;
        public Type		onlyCompatibleWithGraph;

        /// <summary>
        /// Register the node in the NodeProvider class. The node will also be available in the node creation window.
        /// </summary>
        /// <param name="menuTitle">Path in the menu, use / as folder separators</param>
        public NodeMenuItemAttribute(string menuTitle = null, Type onlyCompatibleWithGraph = null)
        {
            this.menuTitle = menuTitle;
            this.onlyCompatibleWithGraph = onlyCompatibleWithGraph;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/NodeMenuItemAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/NoteAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7664513f0be9e244eb587bdc14f28204
# ASMDEF: ldx.framework.runtime.dll
# ---
// Runtime/Attributes/NoteAttribute.cs
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    /// <summary>Draws a HelpBox in place of the decorated field, hiding the field.</summary>
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
    public class NoteAttribute : PropertyAttribute
    {
        public enum NoteType { Info, Warning, Error }
        public string Message { get; private set; }
        public NoteType Type { get; private set; }

        public NoteAttribute(string message) { Message = message; Type = NoteType.Info; }
        public NoteAttribute(string message, NoteType type) { Message = message; Type = type; }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/NoteAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/ObjectiveCategoryAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ac4ff67a91ef4235862fe0c4ceadd479
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    /// <summary>
    /// Marks a specific category name for objectives or event data
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public class ObjectiveCategoryAttribute : PropertyAttribute
    {
        public string Category { get; }
        public bool SlashesSeparateCategories { get; }
        
        public ObjectiveCategoryAttribute(string category, bool slashesSeparateCategories = false)
        {
            Category = category;
            SlashesSeparateCategories = slashesSeparateCategories;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/ObjectiveCategoryAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/ObjectiveInspectorAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 320523d1941f4d8da603b0c3123b26c7
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;

namespace Ldx.Framework.Utilities.Attributes
{
    [AttributeUsage(AttributeTargets.Field)]
    public class ObjectiveInspectorAttribute : Attribute { }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/ObjectiveInspectorAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/ObjectiveSelectionAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 19f847deb23f40b4bc1ba6cd8e0f4ab8
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    [AttributeUsage(AttributeTargets.Field, Inherited = true)]
    public class ObjectiveSelectionAttribute : PropertyAttribute
    {
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/ObjectiveSelectionAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/ReadOnlyAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8a4ff490f6b86094f82d9ac4c67a0680
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    [AttributeUsage(AttributeTargets.Field)]
    public class ReadOnlyAttribute : PropertyAttribute
    {

    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/ReadOnlyAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/RequireComponentInSceneAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 859b69fb3b1b480db315a8507467a5a8
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    /// <summary>
    /// Attribute that ensures a component is present in the scene
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public class RequireComponentInSceneAttribute : PropertyAttribute
    {
        public Type Type { get; }

        public RequireComponentInSceneAttribute(Type type)
        {
            Type = type;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/RequireComponentInSceneAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/RequireInterfaceAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a750321046b345f7bcb80ae4b066d16f
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    /// <summary>
    /// Attribute that require implementation of the provided interface
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    public class RequireInterfaceAttribute : PropertyAttribute
    {
        /*
         *  Example
         * [RequireInterface(typeof(IMyInterface)]
         * [SerializeField]
         * private MonoBehaviour someField;
         *
         * public IMyInterface SomeField => (IMyInterface) someField; 
         */
        public Type RequiredType { get; }

        public RequireInterfaceAttribute(Type requiredType)
        {
            RequiredType = requiredType;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/RequireInterfaceAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/RequireTrackerAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1db90c73ebbb4d06b6ae0eb392e6a061
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    /// <summary>
    /// Placed on an event data block to spawn a tracker in the scene
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public class RequireTrackerAttribute : PropertyAttribute
    {
        public Type Type { get; }
        public string PrefabPath { get; } = null;
        
        /// <summary>
        /// Placed on an event data block to spawn a tracker in the scene
        /// </summary>
        /// <param name="type">Type of the tracker to spawn</param>
        public RequireTrackerAttribute(Type type)
        {
            Type = type;
        }
        
        /// <summary>
        /// Placed on an event data block to spawn a tracker in the scene
        /// </summary>
        /// <param name="type">Type of the tracker to spawn</param>
        /// <param name="prefabPath">Path to load the tracker prefab.
        /// Relative to any Resources folder in project/framework and without an extension.
        /// e.g. "Trackers/SomeTracker"</param>
        public RequireTrackerAttribute(Type type, string prefabPath)
        {
            Type = type;
            PrefabPath = prefabPath;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/RequireTrackerAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/SavePathAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 03d16d2cd22f495aa0c726a2455029d7
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    /// <summary>
    /// Attribute for generically specifying a save path
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public class SavePathAttribute : PropertyAttribute
    {
        public string Path { get; }

        public SavePathAttribute(string path)
        {
            Path = path;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/SavePathAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/SceneSavingAddOnAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 092100df21074247af39f6e203fd8cc9
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    /// <summary>
    /// Attribute for marking a scene saving add-on 
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public class SceneSavingAddOnAttribute : PropertyAttribute
    {
        public bool ExecutesOnEnteringPlayMode { get; }
        
        public SceneSavingAddOnAttribute(bool executesOnEnteringPlayMode = false)
        {
            ExecutesOnEnteringPlayMode = executesOnEnteringPlayMode;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/SceneSavingAddOnAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/SceneSetupLinkAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 17b066d6ad1240d690d204a4c870425b
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    /// <summary>
    /// Add this attribute to any class that should be available in the scenario management window
    /// as a framework component with a prefab at Runtime/Resources/SceneSetupPrefabs
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public class SceneSetupLinkAttribute : PropertyAttribute
    {
        public SceneSetupLinkGroup Group { get; }
        
        public SceneSetupLinkAttribute(SceneSetupLinkGroup group = SceneSetupLinkGroup.Optional)
        {
            Group = group;
        }
    }
    
    /// <summary>
    /// Group of the scene setup link to be considered during scene setup
    /// </summary>
    public enum SceneSetupLinkGroup
    {
        Essential = 0,
        Optional
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/SceneSetupLinkAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/SerializableContainerAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0777f23af92148ebbc4b7582c430dde5
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    [AttributeUsage(AttributeTargets.Field)]
    public class SerializableContainerAttribute : PropertyAttribute
    {
        public string ItemName { get; } = null;
        public int? MaxItems { get; } = null;
        public bool StartCountingFrom1 { get; }
        public bool DrawAddRemoveButtons { get; protected set; }
        public string FieldName { get; protected set; }
        
        public SerializableContainerAttribute(string itemName = null, int maxItems = -1, 
            bool startCountingFrom1 = false, bool drawAddRemoveButtons = true, string fieldName = null)
        {
            ItemName = itemName;
            MaxItems = maxItems == -1? null : maxItems;
            StartCountingFrom1 = startCountingFrom1;
            DrawAddRemoveButtons = drawAddRemoveButtons;
            FieldName = fieldName;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/SerializableContainerAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/ShowIfAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2a69c7462eac44f98bc8e8caf77710dc
# ASMDEF: ldx.framework.runtime.dll
# ---
// Credits: https://gist.github.com/Mikilo/8cb969a50a1eac87c9500d4f9f181324

using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    public enum MultiOp
    {
        None = -1,
        /// <summary>Checks if the field's value equals one of the requirements.</summary>
        Equals,
        /// <summary>Checks if the field's value differs from all the requirements.</summary>
        Diff,
    }

    public enum Op
    {
        None = -1,
        /// <summary>Checks if the field's value is equal to the requirement.</summary>
        Equals,
        /// <summary>Checks if the field's value is different from the requirement.</summary>
        Diff,
        /// <summary>Checks if the field's value is superior than the requirement.</summary>
        Sup,
        /// <summary>Checks if the field's value is less than the requirement.</summary>
        Inf,
        /// <summary>Checks if the field's value is greater or equal to the requirement.</summary>
        SupEquals,
        /// <summary>Checks if the field's value is less than or equal to the requirement.</summary>
        InfEquals,
    }
    
    public class ShowIfAttribute : PropertyAttribute
    {
        public readonly string fieldName;
        public readonly Op @operator;
        public readonly MultiOp multiOperator;
        public readonly object[] values;

        public ShowIfAttribute(string fieldName, Op @operator, object value)
        {
            this.fieldName = fieldName;
            this.@operator = @operator;
            this.multiOperator = MultiOp.None;
            this.values = new object[] {value};
        }

        public ShowIfAttribute(string fieldName, MultiOp multiOperator, params object[] values)
        {
            this.fieldName = fieldName;
            this.@operator = Op.None;
            this.multiOperator = multiOperator;
            this.values = values;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/ShowIfAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/ShowWhenAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 634000bc68f4ae94daf399b6ef7de388
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
	/// <summary>
	/// Attribute used to show or hide the Field depending on certain conditions
	/// </summary>
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = true, Inherited = true)]
	public class ShowWhenAttribute : PropertyAttribute
	{

		public readonly string conditionFieldName;
		public readonly object comparationValue;
		public readonly object[] comparationValueArray;

		/// <summary>
		/// Attribute used to show or hide the Field depending on certain conditions
		/// </summary>
		/// <param name="conditionFieldName">Name of the bool condition Field</param>
		public ShowWhenAttribute(string conditionFieldName)
		{
			this.conditionFieldName = conditionFieldName;
		}

		/// <summary>
		/// Attribute used to show or hide the Field depending on certain conditions
		/// </summary>
		/// <param name="conditionFieldName">Name of the Field to compare (bool, enum, int or float)</param>
		/// <param name="comparationValue">Value to compare</param>
		public ShowWhenAttribute(string conditionFieldName, object comparationValue = null)
		{
			this.conditionFieldName = conditionFieldName;
			this.comparationValue = comparationValue;
		}

		/// <summary>
		/// Attribute used to show or hide the Field depending on certain conditions
		/// </summary>
		/// <param name="conditionFieldName">Name of the Field to compare (bool, enum, int or float)</param>
		/// <param name="comparationValueArray">Array of values to compare (only for enums)</param>
		public ShowWhenAttribute(string conditionFieldName, object[] comparationValueArray = null)
		{
			this.conditionFieldName = conditionFieldName;
			this.comparationValueArray = comparationValueArray;
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/ShowWhenAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/SingletonSpawnableAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 589c2d81eaed49189abf369b4bab76f3
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    public enum SingletonSpawnOptions
    {
        EditAndPlayMode = 0,
        EditModeOnly,
        PlayModeOnly,
    }
    
    [AttributeUsage(AttributeTargets.Class)]
    public class SingletonSpawnableAttribute : PropertyAttribute
    {
        public SingletonSpawnOptions SingletonSpawnOption { get; }
        /// <summary>
        /// Only spawn in scenes where there's a scenario object
        /// </summary>
        public bool RequiresScenario { get; }
        
        /// <summary>
        /// Allow in lobby scenes
        /// </summary>
        public bool AllowInLobby { get; }
        
        public SingletonSpawnableAttribute(SingletonSpawnOptions singletonSpawnOption = SingletonSpawnOptions.PlayModeOnly, 
            bool requiresScenario = false, bool allowInLobby = true)
        {
            AllowInLobby = allowInLobby;
            RequiresScenario = requiresScenario;
            SingletonSpawnOption = singletonSpawnOption;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/SingletonSpawnableAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/SoundReferenceAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6f737551b51e4564588b5caabf397568
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    /// <summary>
    /// Attribute used on a string to designate it as a Sound path.
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    public class SoundReferenceAttribute : PropertyAttribute
    {
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/SoundReferenceAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/TrackedReferenceAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 168e97369eab4f6886b4ac44889c88ae
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    [AttributeUsage(AttributeTargets.Class)]
    public class TrackedReferenceAttribute : PropertyAttribute
    {
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/TrackedReferenceAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/WizardCategoryAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0e2a742e9f5e32a46a297dac0ec37213
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    /// <summary>
    /// Marks a specific category name for Setup Wizard Operations
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited = false)]
    public sealed class WizardCategoryAttribute : PropertyAttribute
    {
        public string Category { get; }
        public bool SlashesSeparateCategories { get; }
        
        public WizardCategoryAttribute(string category, bool slashesSeparateCategories = false)
        {
            Category = category;
            SlashesSeparateCategories = slashesSeparateCategories;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Attributes/WizardCategoryAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Axis.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7de5f9f3d58448698bad556a2afde1a7
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;

namespace Ldx.Framework.Utilities
{
    [Serializable]
    public enum Axis
    {
        X = 0, Y, Z
    }

    [Serializable]
    [Flags]
    public enum AxisWithFlags
    {
        None = 0,
        X = 1,
        Y = 2,
        Z = 4
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Axis.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Blockers/IBlocker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d424736d98958734fa03ac438b3cf5eb
# ASMDEF: ldx.framework.runtime.dll
# ---
namespace Utilities.Blockers
{
    /// <summary>
    /// Contract for components that can temporarily block a feature, action, or input pathway.
    /// </summary>
    /// <remarks>
    /// Usage overview:
    /// - Implementers:
    ///   - Maintain an internal boolean state representing whether this source is currently blocking.
    ///   - Expose that state via <see cref="IsBlocked"/> and invoke <see cref="OnBlockChanged"/> whenever it changes.
    ///   - Only raise the event when the state actually flips to avoid redundant notifications.
    ///   - Ensure you unsubscribe external listeners in your lifecycle (e.g., OnDisable/OnDestroy) on the subscriber side.
    ///
    /// - Consumers:
    ///   - Query <see cref="IsBlocked"/> to get the current state.
    ///   - Subscribe to <see cref="OnBlockChanged"/> to react in real time.
    ///   - If multiple blockers exist, consider the system "blocked" if any <see cref="IsBlocked"/> is true.
    ///</remarks>
    public interface IBlocker
    {
        /// <summary>
        /// Invoked whenever the blocking state of this blocker changes.
        /// The first argument is the blocker instance (this IBlocker).
        /// The second argument is the current state: true = blocked, false = unblocked.
        /// </summary>
        public event System.Action<IBlocker, bool> OnBlockChanged;
        bool IsBlocked { get; }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Blockers/IBlocker.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/CollisionUtilities.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cddda21bc92368849935be7f8a1a8356
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.Player;
using UnityEngine;

namespace Ldx.Framework.Utilities
{
    public static class CollisionUtilities
    {
        private const string HAND_LAYER = "Hand";

        /// <summary>
        /// Check if the game object 'other' is a collision of the type 'collisionType'. If so, return true.
        /// Used primarily for tracking event & tracking key colliders and triggers.
        /// </summary>
        /// <param name="other">The game object that is entering a collider/trigger.</param>
        /// <param name="collisionType">The type of collision to check for.</param>
        /// <param name="targetObjectGroup">If the collision type is ObjectGroup, then check against this object group ID.</param>
        /// <returns>True if the collision with the game object is of the specified type and/or object group.</returns>
        public static bool CheckCollision(GameObject other, CollisionType collisionType, string targetObjectGroup)
        {
            switch (collisionType)
            {
                case CollisionType.Hand:
                    if (other.layer != LayerMask.NameToLayer(HAND_LAYER))
                        return false;
                    break;
                case CollisionType.Player:
                    return other.GetComponent<PlayerPositionMarker>() != null;
                case CollisionType.ObjectGroup:
                    if (!other.TryGetComponent(out LdxObjectGroup group))
                        return false;
                    if (group.ObjectGroup == targetObjectGroup)
                        return true;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            return true;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/CollisionUtilities.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Constants.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 99eedeb6e464438cb6457f6a3d2e7078
# ASMDEF: ldx.framework.runtime.dll
# ---
namespace Ldx.Framework.Utilities
{
    public static class Constants
    {
        public const string WIKI_ROOT = "https://logicaldox.atlassian.net/wiki/spaces/LBVF/pages/";
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Constants.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/ConstrainAxis.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 00aac16c6f4669c4ba6602054e276157
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities
{
    /// <summary>
    /// Constrain an object's transform on a given axis through Update or FixedUpdate.
    /// </summary>
    public class ConstrainAxis : MonoBehaviour
    {
        private enum UpdateMode
        {
            Update,
            FixedUpdate
        }

        private enum PositionMode
        {
            World,
            Local
        }

        [Serializable]
        private class AxisConstraint
        {
            public Axis axis;
            public float minValue = float.MinValue;
            public float maxValue = float.MaxValue;
        }

        [SerializeField] private Transform transformToConstrain;
        [SerializeField] private UpdateMode updateMode;
        [SerializeField] private PositionMode positionMode;
        [SerializeField] private AxisConstraint[] axisConstraints;

        private void OnValidate()
        {
            if (transformToConstrain == null)
            {
                transformToConstrain = this.transform;
            }
        }

        private void Update()
        {
            if (updateMode != UpdateMode.Update) return;
            ConstrainToAxes();
        }

        private void FixedUpdate()
        {
            if (updateMode != UpdateMode.FixedUpdate) return;
            ConstrainToAxes();
        }

        private void ConstrainToAxes()
        {
            Vector3 position = positionMode is PositionMode.World ? transformToConstrain.position : transformToConstrain.localPosition;
            foreach (AxisConstraint axisConstraint in axisConstraints)
            {
                position[(int)axisConstraint.axis] = Mathf.Clamp(position[(int)axisConstraint.axis],
                    axisConstraint.minValue, axisConstraint.maxValue);
            }

            if (positionMode is PositionMode.World) transformToConstrain.position = position;
            else transformToConstrain.localPosition = position;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/ConstrainAxis.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/CoroutineUtilities.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c32c040388a7685478d3298e2b243c97
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections;
using UnityEngine;

namespace Ldx.Framework.Utilities
{
    /// <summary>
    /// Static utility methods for oft-repeated code around coroutine use.
    /// </summary>
    public static class CoroutineUtilities
    {
        /// <summary>
        /// Stop the given ref coroutine and set its reference to null.
        /// </summary>
        /// <param name="coroutine">The coroutine to stop and set to null</param>
        /// <param name="owningMonoBehaviour">The MonoBehaviour that owned the coroutine</param>
        public static void StopAndNullCoroutine(ref Coroutine coroutine, MonoBehaviour owningMonoBehaviour)
        {
            if (coroutine != null)
            {
                owningMonoBehaviour.StopCoroutine(coroutine);
                coroutine = null;
            }
        }

        /// <summary>
        /// Stops the coroutine at the given ref if it exists, and replaces it by starting a new
        /// coroutine using the given IEnumerator
        /// </summary>
        /// <param name="routine">The IEnumerator to use for the new coroutine</param>
        /// <param name="coroutine">The updated coroutine after starting the new routine</param>
        /// <param name="owningMonoBehaviour">The MonoBehaviour that owned the coroutine</param>
        public static void ReplaceAndStartCoroutine(ref Coroutine coroutine, IEnumerator routine,
            MonoBehaviour owningMonoBehaviour)
        {
            StopAndNullCoroutine(ref coroutine, owningMonoBehaviour);
            coroutine = owningMonoBehaviour.StartCoroutine(routine);
        }
        
        /// <summary>
        /// Handy method for a common use case: if the given coroutine is not null, stop it via the given
        /// MonoBehaviour, set it to null (using the reference so not just the copied pointer is set to null,
        /// but the actual reference inside the calling class) and returns true. Otherwise, just returns false
        /// </summary>
        /// <returns>Returns true if stop and null coroutine was a successful, false if coroutine was null before</returns>
        public static bool TryStopAndNullCoroutine(ref Coroutine coroutine, MonoBehaviour owningMonoBehaviour)
        {
            if (coroutine != null && owningMonoBehaviour != null)
            {
                owningMonoBehaviour.StopCoroutine(coroutine);
                coroutine = null;
                return true;
            }

            return false;
        }
        
        /// <summary>
        /// Waits the given seconds then invokes the given callback.
        /// Call from a MonoBehaviour like: myCoroutine = CoroutineUtility.TimeDelayCallback(this, callback, 0.5f);
        /// Returns the created Coroutine for use in your script.
        /// </summary>
        /// <param name="callingMonoBehaviour">The MonoBehaviour that should be used to start the coroutine.</param>
        /// <param name="callback">Parameterless callback function to be invoked after the 1-frame delay.</param>
        /// <param name="time">Seconds to wait before invoking the callback.</param>
        /// <returns>The created coroutine for use in your script.</returns>
        public static Coroutine TimeDelayCallback(MonoBehaviour callingMonoBehaviour, System.Action callback,
            float time, bool useScaledTime = true)
        {
            return callingMonoBehaviour.StartCoroutine(timeDelayCallbackRoutineInternal(callback, time, useScaledTime));
            
            static IEnumerator timeDelayCallbackRoutineInternal(System.Action callbackParameter, float timeParameter, bool useScaledTimeParameter)
            {
                float elapsed = 0f;
                while (elapsed < timeParameter)
                {
                    elapsed += useScaledTimeParameter ? Time.deltaTime : Time.unscaledDeltaTime;
                    yield return null;
                }

                callbackParameter.Invoke();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/CoroutineUtilities.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/DrawGizmo.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bcc5aa2294d1c2649a78cbe889509ebf
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
using UnityEngine.Serialization;

namespace Ldx.Framework.Utilities
{
    /// <summary>
    /// Draw gizmos
    /// </summary>
    public class DrawGizmo : MonoBehaviour
    {
        public enum GizmoType
        {
            WireCube,
            Cube,
            WireSphere,
            Sphere,
            DrawMesh,
            BoxCollider,
            WireCylinder
        }
        
        [SerializeField] private Color gizmosColor = Color.cyan.Modify(a: 0.2f);
        [SerializeField] private GizmoType gizmoType;
        [SerializeField] private BoxCollider boxCollider;
        [FormerlySerializedAs("drawGizmosPreview")]
        [SerializeField] private Mesh gizmoMesh;
        [SerializeField] private Vector3 offset = new Vector3(0, -0.1f, 0);
        [SerializeField] private Vector3 size = new Vector3(0.1f, 5, 0.1f);
        [ShowIf(nameof(gizmoType), Op.Equals, GizmoType.WireCylinder)]
        [SerializeField] private Axis cylinderAxis = Axis.Y;
        [ShowIf(nameof(gizmoType), Op.Equals, GizmoType.WireCylinder)]
        [Min(3)]
        [SerializeField] private int cylinderSegments = 32;
        [SerializeField] private float radius;
        [SerializeField] private string label = null;
        [SerializeField] private bool drawGizmos = true;

        [SerializeField, HideInInspector] private Color currentGizmo;

        public string Label
        {
            get => label;
            set => label = value;
        }

        public GizmoType Type
        {
            get => gizmoType;
            set => gizmoType = value;
        }

        public bool DrawGizmos
        {
            get => drawGizmos;
            set => drawGizmos = value;
        }
        
        public float Radius
        {
            get => radius;
            set => radius = value;
        }

        private BoxCollider BoxCollider
        {
            get
            {
                if (gizmoType == GizmoType.BoxCollider && boxCollider == null)
                {
                    boxCollider = GetComponent<BoxCollider>();
                }
                return boxCollider;
            }
        }

        private void OnValidate()
        {
            currentGizmo = gizmosColor;

            if (gizmoType == GizmoType.BoxCollider && boxCollider == null)
            {
                boxCollider = GetComponent<BoxCollider>();
            }
        }

        private void Start()
        {
            currentGizmo = gizmosColor;
        }

        private void OnDrawGizmos()
        {
            if (!DrawGizmos)
            {
                return;
            }

            Color originalColor = Gizmos.color;
            Gizmos.color = currentGizmo;

            switch (gizmoType)
            {
                case GizmoType.WireCube:
                    Gizmos.DrawWireCube(transform.position + offset, size);
                    break;
                case GizmoType.Cube:
                    Gizmos.DrawCube(transform.position + offset, size);
                    break;
                case GizmoType.WireSphere:
                    Gizmos.DrawWireSphere(transform.position + offset, radius);
                    break;
                case GizmoType.Sphere:
                    Gizmos.DrawSphere(transform.position + offset, radius);
                    break;
                case GizmoType.DrawMesh:
                    Gizmos.DrawMesh(gizmoMesh, transform.position, transform.rotation, transform.localScale);
                    break;
                case GizmoType.BoxCollider:
                    Matrix4x4 rotationMatrix = Matrix4x4.TRS(
                        BoxCollider.transform.position, 
                        BoxCollider.transform.rotation, 
                        BoxCollider.transform.lossyScale);
                    Matrix4x4 oldMatrix = Gizmos.matrix;
                    Gizmos.matrix = rotationMatrix;
                    Gizmos.DrawCube(BoxCollider.center, BoxCollider.size);
                    Gizmos.matrix = oldMatrix;
                    break;
                case GizmoType.WireCylinder:
                    DrawWireCylinder(transform.position + offset, transform.rotation, size, cylinderAxis, cylinderSegments);
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            if (!string.IsNullOrEmpty(label))
            {
                GUIStyle textStyle = new GUIStyle
                {
                    fontSize = 16,
                    normal =
                    {
                        textColor = currentGizmo.Opacity(1f),
                    }
                };
#if UNITY_EDITOR
                Handles.Label(transform.position, label, textStyle);
#endif
            }

            Gizmos.color = originalColor;
        }
        
        private void DrawWireCylinder(Vector3 position, Quaternion rotation, Vector3 scale, Axis heightAxis, int segments)
        {
            Vector3 up, right, forward;
            float height;
            float radius1, radius2;

            // Determine up/right/forward based on the heightAxis
            switch (heightAxis)
            {
                case Axis.X:
                    up = rotation * Vector3.right;
                    right = rotation * Vector3.up;
                    forward = rotation * Vector3.forward;
                    height = scale.x;
                    radius1 = scale.y / 2f;
                    radius2 = scale.z / 2f;
                    break;
                case Axis.Y:
                    up = rotation * Vector3.up;
                    right = rotation * Vector3.right;
                    forward = rotation * Vector3.forward;
                    height = scale.y;
                    radius1 = scale.x / 2f;
                    radius2 = scale.z / 2f;
                    break;
                case Axis.Z:
                    up = rotation * Vector3.forward;
                    right = rotation * Vector3.right;
                    forward = rotation * Vector3.up;
                    height = scale.z;
                    radius1 = scale.x / 2f;
                    radius2 = scale.y / 2f;
                    break;
                default:
                    return;
            }

            Vector3 topCenter = position + up * (height / 2f);
            Vector3 bottomCenter = position - up * (height / 2f);

            float angleStep = 360f / segments;
            Vector3[] topPoints = new Vector3[segments];
            Vector3[] bottomPoints = new Vector3[segments];

            for (int i = 0; i < segments; i++)
            {
                float angle = Mathf.Deg2Rad * i * angleStep;
                Vector3 offset = (right * Mathf.Cos(angle) * radius1) + (forward * Mathf.Sin(angle) * radius2);
                topPoints[i] = topCenter + offset;
                bottomPoints[i] = bottomCenter + offset;
            }

            for (int i = 0; i < segments; i++)
            {
                int next = (i + 1) % segments;

                // Draw top and bottom ellipses
                Gizmos.DrawLine(topPoints[i], topPoints[next]);
                Gizmos.DrawLine(bottomPoints[i], bottomPoints[next]);

                // Draw sides
                Gizmos.DrawLine(topPoints[i], bottomPoints[i]);
            }
        }

        public void SetGizmosUnique(bool isUnique)
        {
            currentGizmo = isUnique ? Color.red : Color.cyan;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/DrawGizmo.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/EditorNote.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f16f65ee01344d578e66bd6a375797a8
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities
{
    public class EditorNote : MonoBehaviour
    {
        [SerializeField] 
        private string noteText;
        public string NoteText
        {
            get => noteText;
            set => noteText = value;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/EditorNote.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/AnimationCurveExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7d948dab523a4c539eaa77ccfc1048a9
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class AnimationCurveExtensions
    {
        /// <summary>
        /// Basic inverse evaluation (can be slow, not perfectly accurate for all curve types)
        /// For more robust solution, consider pre-calculating or using a more specific math approach.
        /// </summary>
        /// <param name="curve">Animation curve to evaluate</param>
        /// <param name="value">Time value</param>
        /// <param name="iterations"></param>
        /// <param name="errorTolerance"></param>
        /// <returns></returns>
        public static float InverseEvaluate(this AnimationCurve curve, float value, int iterations = 10, float errorTolerance = 0.001f)
        {
            if (curve == null || curve.length == 0)
            {
                return 0f;
            }
            
            if (curve.length == 1)
            {
                return curve.keys[0].time;
            }

            float minTime = curve.keys[0].time;
            float maxTime = curve.keys[curve.length - 1].time;
            
            for (int i = 0; i < iterations; i++)
            {
                float midTime = (minTime + maxTime) / 2f;
                float midValue = curve.Evaluate(midTime);

                if (Mathf.Abs(midValue - value) < errorTolerance)
                    return midTime;

                if (midValue < value)
                    minTime = midTime;
                else
                    maxTime = midTime;
            }
            return (minTime + maxTime) / 2f; 
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/AnimationCurveExtensions.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/AssemblyUtilities.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 10efe6b0db3f4961a88e1814bc3b6d11
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class AssemblyUtilities
    {
        private const string FRAMEWORK_DOMAIN = "ldx";
        private const string PROJECT_RUNTIME_ASSEMBLY = "Assembly-CSharp";
        private const string PROJECT_EDITOR_ASSEMBLY = "Assembly-CSharp-Editor";
        
        public static IEnumerable<Assembly> GetProjectAndFrameworkAssemblies()
        {
            return AppDomain.CurrentDomain.GetAssemblies()
                .Where(a =>
                {
                    string name = a.GetName().Name;
                    return name.Contains(FRAMEWORK_DOMAIN, StringComparison.OrdinalIgnoreCase)
                           || name == PROJECT_RUNTIME_ASSEMBLY
                           || name == PROJECT_EDITOR_ASSEMBLY;
                });
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/AssemblyUtilities.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/CameraExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3c5254ad5d69472f96bd5f1c8bd0d347
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class CameraExtensions
    {
        private static Bounds tempBounds = new Bounds(Vector3.zero, Vector3.one);

        /// <summary>
        /// Determines whether a bounding box at the given position intersects with the camera's view frustum.
        /// Use this method when you need to determine if any part of an object (represented by its bounds) is visible in the scene,
        /// which is useful for visibility culling and rendering optimizations.
        /// </summary>
        /// <param name="camera">The camera to perform the view check against.</param>
        /// <param name="position">The center position of the object's bounding box.</param>
        /// <param name="offset">
        /// An optional offset to adjust the bounding box's center position.
        /// Use this if the object's pivot point is not at its center.
        /// </param>
        /// <returns>
        /// <c>true</c> if the bounding box intersects with the camera's view frustum, indicating that the object
        /// is at least partially visible; otherwise, <c>false</c>.
        /// </returns>
        public static bool IsInView(this Camera camera, Vector3 position, Vector3? offset = null)
        {
            Plane[] planes = GeometryUtility.CalculateFrustumPlanes(camera);
            tempBounds.center = position;

            if (offset != null)
            {
                tempBounds.center -= offset.Value;
            }

            return GeometryUtility.TestPlanesAABB(planes, tempBounds);
        }

        /// <summary>
        /// Determines whether a given position or transform is within the central portion of the camera's viewport,
        /// excluding the edges defined by the <paramref name="avoidEdgeAmount"/> parameter.
        /// Use this method when you need a lightweight check to see if an object is centrally visible on the screen,
        /// perhaps to focus attention or trigger events when the object is prominently in view.
        /// </summary>
        /// <param name="camera">The camera to perform the frustum check against.</param>
        /// <param name="transform">The transform of the object to check.</param>
        /// <param name="avoidEdgeAmount">
        /// The percentage of the screen edges to exclude from the frustum check.
        /// A value between 0 (no edge exclusion) and 0.5f (exclude up to half the screen).
        /// Default is 0.15f, meaning 15% edges are excluded, checking the central 70% of the screen.
        /// </param>
        /// <returns>
        /// <c>true</c> if the object's position is within the central portion of the camera's viewport (excluding edges);
        /// otherwise, <c>false</c>.
        /// </returns>
        public static bool IsInFrustum(this Camera camera, Transform transform, float avoidEdgeAmount = 0.15f)
        {
            return IsInFrustum(camera, transform.position, avoidEdgeAmount);
        }

        /// <summary>
        /// Determines whether a given world position is within the central portion of the camera's viewport,
        /// excluding the edges defined by the <paramref name="avoidEdgeAmount"/> parameter.
        /// Use this method when you need a lightweight check to see if a point is centrally visible on the screen,
        /// perhaps to focus attention or trigger events when the point is prominently in view.
        /// </summary>
        /// <param name="camera">The camera to perform the frustum check against.</param>
        /// <param name="position">The world position to check.</param>
        /// <param name="avoidEdgeAmount">
        /// The percentage of the screen edges to exclude from the frustum check.
        /// A value between 0 (no edge exclusion) and 0.5f (exclude up to half the screen).
        /// Default is 0.15f, meaning 15% edges are excluded, checking the central 70% of the screen.
        /// </param>
        /// <returns>
        /// <c>true</c> if the position is within the central portion of the camera's viewport (excluding edges);
        /// otherwise, <c>false</c>.
        /// </returns>
        public static bool IsInFrustum(this Camera camera, Vector3 position, float avoidEdgeAmount = 0.15f)
        {
            if (camera == null)
            {
                Debug.LogError("Camera is null in IsInFrustum check.");
                return false;
            }

            Vector3 viewportPoint = camera.WorldToViewportPoint(position);

            bool isInFrustum =
                viewportPoint.z > 0 && // In front of the camera
                viewportPoint.x > avoidEdgeAmount && viewportPoint.x < 1f - avoidEdgeAmount &&
                viewportPoint.y > avoidEdgeAmount && viewportPoint.y < 1f - avoidEdgeAmount;

            return isInFrustum;
        }
        
        /// <summary>
        /// This allows you to get the centremost object of type T when passing a collection of that type as a
        /// parameter. This also includes an optional filter function that can filter objects based on whether they
        /// are active, or any other conditions you choose, as long as it returns a bool. 
        /// </summary>
        /// <param name="camera">The camera to use in the calculation.</param>
        /// <param name="objects">The collection of objects passed to check for the centremost one.</param>
        /// <param name="filter">Filter functions to be applied to the object to check if it should be displayed</param>
        /// <typeparam name="T">The type, which must inherit from component</typeparam>
        /// <returns>The object in the collection which passes the filters and is also centremost in the viewport</returns>
        public static T GetCentremostObject<T>(this Camera camera, IEnumerable<T> objects, Func<T, bool> filter = null) where T : Component
        {
            T centremostObject = null;
            float lowestManhattanDistance = 2f;

            foreach (T obj in objects)
            {
                if (filter != null && !filter(obj))
                {
                    continue;
                }

                Vector3 viewportPosition = camera.WorldToViewportPoint(obj.transform.position);
                float currentManhattanDistance = Mathf.Abs(0.5f - viewportPosition.x) + Mathf.Abs(0.5f - viewportPosition.y);

                if (currentManhattanDistance < lowestManhattanDistance)
                {
                    lowestManhattanDistance = currentManhattanDistance;
                    centremostObject = obj;
                }
            }

            return centremostObject;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/CameraExtensions.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/ColorExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c621f74d776246adb99f64eb3c19edb2
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class ColorExtensions
    {
        /// <summary>
        /// Get a modified version of the color with one or more components modified
        /// </summary>
        /// <returns>A modified version of the color with the passed component configurations</returns>
        public static Color Modify(this Color color, float? r = null, float? g = null, float? b = null, float? a = null)
        {
            return new Color(r == null ? color.r : r.Value,
                g == null ? color.g : g.Value,
                b == null ? color.b : b.Value,
                a == null ? color.a : a.Value);
        }
        
        public static Color Opacity(this Color color, float opacity)
        {
            return new Color(color.r, color.g, color.b, opacity);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/ColorExtensions.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/Colors.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e59207f15b9748c9b9b38c783da05d5e
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Extensions
{
    /// <summary>
    /// Colors utility with a simplified name 
    /// </summary>
    public static class Colors
    {
        public static string ToRGBHex(this Color c)
        {
            return string.Format("#{0:X2}{1:X2}{2:X2}", ToByte(c.r), ToByte(c.g), ToByte(c.b));
        }
        
        private static byte ToByte(float f)
        {
            f = Mathf.Clamp01(f);
            return (byte)(f * 255);
        }

        /// <summary>
        /// Takes in standard RGBA values (0~255) and returns Unity-Compatible Color struct (0~1)
        /// </summary>
        public static Color FromRGBA(float r, float g, float b, float a = 1.0f)
        {
            return new Color(r / 255.0f, g / 255.0f, b / 255.0f, a);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/Colors.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/ComponentUtilities.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9b95b2e1f7f54c37b74a0c43bf25330e
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Linq;
using UnityEngine;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class ComponentUtilities
    {
        public static T GetOrAddComponent<T>(this GameObject gameObject) where T : Component
        {
            T foundComponent = gameObject.GetComponent<T>();
            
            if (foundComponent == null)
            {
                foundComponent = gameObject.AddComponent<T>();
            }

            return foundComponent;
        }
        
        public static bool TryGetComponentInParent<T>(this Component component, out T result) where T : Component
        {
            result = component.GetComponentInParent<T>();
            return result != null;
        }

        
        public static bool GetComponentInParentExcludeSelf<T>(this Component component) where T : Component
        {
            return component.GetComponentsInParent<T>().FirstOrDefault(c => c.gameObject != component.gameObject);
        }
        
        public static T GetOrAddComponent<T>(this Component component) where T : Component
        {
            T foundComponent = component.GetComponent<T>();

            if (foundComponent != null)
            {
                return foundComponent;
            }

            return component.gameObject.AddComponent<T>();
        }

        public static T GetComponentInChildrenExcludeSelf<T>(this Component component) where T : Component
        {
            return component.GetComponentsInChildren<T>().FirstOrDefault(c => c.gameObject != component.gameObject);
        }
        
        public static T AddComponentClone<T>(this GameObject destination, T original)
            where T : Component
        {
            T copy = destination.AddComponent<T>();
            return copy.CopyComponentFrom(original);
        }
        
        public static T CopyComponentFrom<T>(this T copyTo, T toCopy)
            where T : Component
        {
            System.Type type = toCopy.GetType();
            System.Reflection.FieldInfo[] fields = type.GetFields(); 
            foreach (System.Reflection.FieldInfo field in fields)
            {
                field.SetValue(copyTo, field.GetValue(toCopy));
            }

            return copyTo as T;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/ComponentUtilities.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/FloatExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 305158684b8b400bb5f660f51c0eb669
# ASMDEF: ldx.framework.runtime.dll
# ---
namespace Ldx.Framework.Utilities.Extensions
{
    public static class FloatExtensions
    {
        /// <summary>
        /// Determines where a value lies between two points. Extension of InverseLerp function but unclamped
        /// </summary>
        /// <param name="a">The start of the range.</param>
        /// <param name="b">The end of the range.</param>
        /// <param name="value">The point within the range you want to calculate.</param>
        /// <returns>
        ///   <para>A value between representing where the "value" parameter falls within the range defined by a and b. Can be outside of 0 and 1</para>
        /// </returns>
        public static float InverseLerpUnclamped(float a, float b, float value) => (double) a != (double) b ? (float) (((double) value - (double) a) / ((double) b - (double) a)) : 0.0f;
        
        /// <summary>
        /// This method takes an angle in degrees and normalizes it to be within the range of -180 to 180 degrees.
        /// </summary>
        /// <param name="angle">A float representing the angle in degrees that needs to be normalized.</param>
        /// <returns>A float representing the normalized angle within the range of -180 to 180 degrees.</returns>
        public static float NormalizeAngle(this float angle)
        {
            angle = angle % 360f;
            if (angle > 180f)
                angle -= 360f;
            else if (angle < -180f)
                angle += 360f;
            return angle;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/FloatExtensions.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/GameObjectExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4e61dc695124a1844834cf62c39a8974
# ASMDEF: ldx.framework.runtime.dll
# ---
using FluffyUnderware.DevTools.Extensions;
using UnityEngine;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class GameObjectExtensions
    {
        public static bool TryFindComponent<T>(this GameObject gameObject, out T component)
        {
            component = gameObject.FindComponent<T>();
            return component != null;
        }
    
        public static T FindComponent<T>(this GameObject gameObject)
        {
            if (gameObject.TryGetComponent(out T component))
            {
                return component;
            }

            component = gameObject.GetComponentInParent<T>();
            if (component != null)
            {
                return component;
            }

            component = gameObject.GetComponentInChildren<T>();
            return component ?? default(T);
        }
        
        /// <summary>
        /// Goes through all child meshes of an object and combines them all to
        /// a mesh collider on the parent
        /// </summary>
        public static void CombineChildMeshes(this GameObject parent, bool removeChildCollidersOnMeshes = false)
        {
            MeshCollider meshCollider = parent.GetOrAddComponent<MeshCollider>();
            
            MeshFilter[] meshFilters = parent.GetComponentsInChildren<MeshFilter>();
            
            CombineInstance[] combineInstances = new CombineInstance[meshFilters.Length];

            // Inverse of the parent's world transformation matrix, otherwise the meshes
            // will have a very wrong offset
            Matrix4x4 parentInverseTransform = parent.transform.localToWorldMatrix.inverse;
            
            for (int i = 0; i < meshFilters.Length; i++)
            {
                MeshFilter meshFilter = meshFilters[i];
                combineInstances[i].mesh = meshFilter.sharedMesh;
                combineInstances[i].transform = parentInverseTransform * meshFilter.transform.localToWorldMatrix;
                if (!removeChildCollidersOnMeshes || meshFilter.gameObject == parent)
                {
                    continue;
                }

                meshFilter.GetComponents<Collider>().ForEach(Object.DestroyImmediate);
            }

            // Create a new mesh and combine all the meshes from the children
            Mesh combinedMesh = new Mesh();
            combinedMesh.CombineMeshes(combineInstances, true, true);
            
            meshCollider.sharedMesh = combinedMesh;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/GameObjectExtensions.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/HighlighterHelper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9358d91b272c46219697b2f8a2acb78f
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Features.Highlighting;
using UnityEngine;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class HighlighterHelper
    {
        private const float FORWARD_MULTIPLIER = 3.0f;
        
        /// <summary>
        ///  Tries to get an LdxModalHighlighter from a raycast originating from the specified source.
        ///  </summary>
        ///  <param name="raycastSource">The origin of the raycast.</param>
        ///  <param name="highlighter">Out parameter that will hold the obtained highlighter if one is found.</param>
        /// <param name="hitPosition">Out parameter that will hold raycast hit position. If nothing was hit, will hold the forward vector from the source.</param>
        /// <returns>Returns true if an LdxModalHighlighter was successfully found, false otherwise.</returns>
        public static bool TryGetHighlighterFromRaycast(Transform raycastSource, out HighlightableObject highlighter, out Vector3 hitPosition)
        {
            highlighter = null;
            hitPosition = raycastSource.position + raycastSource.forward * FORWARD_MULTIPLIER;

            if (!Physics.Raycast(raycastSource.position, raycastSource.forward, out RaycastHit hit, Mathf.Infinity,
                    HighlightingGlobalSettings.ObjectTargetLayer))
            {
                return false;
            }

            hitPosition = hit.point;
            highlighter = hit.collider.GetComponent<HighlightableObject>() ??
                          hit.collider.GetComponentInParent<HighlightableObject>();
    
            return highlighter != null;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/HighlighterHelper.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/LayerExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7b23f4ae9bf54783a240a2d1e5bf4302
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class LayerExtensions
    {
        public static bool TryGetFirstLayer(this LayerMask layerMask, out int layer)
        {
            layer = -1;
            
            int mask = layerMask.value;
            for (int i = 0; i < 32; i++)
            {
                if ((mask & (1 << i)) != 0)
                {
                    layer = i;
                    return true;
                }
            }

            return false;
        }
        
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/LayerExtensions.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/LdxFileHandler.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2e128cf872b9f9344a34b26797d5bd70
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class LdxFileHandler
    {

        #region Fields and Properties

        public static string Directory = "/SaveData/";

        #endregion

        #region Custom Methods

        public static void SaveToJSON<T>(List<T> toSave, string fileName)
        {
            string content = ToJson<T>(toSave.ToArray());
            Console.WriteLine($"{content} saved to file");
            WriteFile(GetPath(fileName), content);
        }

        private static void WriteFile(string path, string content)
        {
            FileStream fileStream = new FileStream(path, FileMode.Create);

            using (StreamWriter writer = new StreamWriter(fileStream))
            {
                writer.Write(content);
            }
        }

        private static string GetPath(string fileName)
        {
            return Application.persistentDataPath + Directory + fileName;
        }

        public static T[] FromJson<T>(string json)
        {
            Wrapper<T> wrapper = JsonUtility.FromJson<Wrapper<T>>(json);
            return wrapper.Items;
        }

        public static string ToJson<T>(T[] array)
        {
            Wrapper<T> wrapper = new Wrapper<T>();
            wrapper.Items = array;
            return JsonUtility.ToJson(wrapper);
        }

        public static string ToJson<T>(T[] array, bool prettyPrint)
        {
            Wrapper<T> wrapper = new Wrapper<T>();
            wrapper.Items = array;
            return JsonUtility.ToJson(wrapper, prettyPrint);
        }

        public static List<T> ReadFromJSON<T>(string fileName)
        {
            string content = ReadFile(GetPath(fileName));

            if (string.IsNullOrEmpty(content) || content == "{}")
            {
                return new List<T>();
            }

            List<T> res = FromJson<T>(content).ToList();
            return res;
        }

        public static string ReadFile(string path)
        {
            if (File.Exists(path))
            {
                using (StreamReader reader = new StreamReader(path))
                {
                    string content = reader.ReadToEnd();
                    return content;
                }
            }
            return "";
        }

        [Serializable]
        private class Wrapper<T>
        {
            public T[] Items;
        }

        #endregion


    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/LdxFileHandler.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/ListUtilities.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 25ce636ad05646c09747b984e90a07e6
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Random = System.Random;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class ListUtilities
    {
        private static readonly Random Rnd = new Random();
        
        public static T Random<T>(this IList<T> list)
        {
            if (list == null || list.Count == 0)
                throw new InvalidOperationException("Cannot select a random element from an empty list.");

            int index = Rnd.Next(list.Count);
            return list[index];
        }
        
        public static List<T> Random<T>(this IList<T> list, int count)
        {
            if (list == null || list.Count == 0)
                throw new InvalidOperationException("Cannot select random elements from an empty list.");
            if (count < 0)
                throw new ArgumentOutOfRangeException(nameof(count), "Count must greater than 0");

            int randomCount = Mathf.Min(count, list.Count);
            List<T> randomElements = new List<T>(randomCount);
            HashSet<int> selectedIndices = new HashSet<int>();

            while (randomElements.Count < randomCount)
            {
                int index = Rnd.Next(list.Count);
                if (selectedIndices.Add(index))
                {
                    randomElements.Add(list[index]);
                }
            }

            return randomElements;
        }
        
        public static IEnumerable<T> RandomizeList<T>(this IEnumerable<T> list)
        {
            return list.OrderBy(l => Guid.NewGuid()).ToList();
        }
        
        public static void AddRepeated<T>(this List<T> list,T item, int count){
            IEnumerable<T> temp = Enumerable.Repeat(item,count);
            list.AddRange(temp);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/ListUtilities.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/NumberUtilities.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 93b07b4a0d854c9a87e923e28231ac69
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class NumberUtilities
    {
        /// <summary>
        /// Takes in a float in seconds, returns an int in milliseconds
        /// </summary>
        public static int ToMilliseconds(this float seconds)
        {
            return (int)(seconds * 1000);
        }
        
        public static string ToMinutesSecondsString(this float seconds)
        {
            TimeSpan time = TimeSpan.FromSeconds(seconds);
            
            return time.ToString(@"m\:ss").Trim();
        }

        /// <summary>
        /// Gives an ease-out curve value between 0 and 1
        /// of the exponentiation given by the int 'power'.
        /// </summary>
        public static float EaseOut01(float t, int power)
        {
            return Mathf.Clamp01(1 - Mathf.Pow(1 - t, power));
        }

        public static bool HasDecimal(this float number)
        {
            return number % 1 != 0;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/NumberUtilities.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/PathUtilities.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 943f50d8030e40a1961c15756b41bd79
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Diagnostics;
using System.IO;
using UnityEngine;
using Debug = UnityEngine.Debug;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class PathUtilities
    {
        /// <summary>
        /// Converts a Unity relative path that starts with 'Assets' to an absolute directory path
        /// </summary>
        public static string AssetsRelativePathToAbsolutePath(string relativePath)
        {
            if (!relativePath.StartsWith("Assets"))
            {
                return relativePath;
            }
            string projectFullPath = Application.dataPath.Replace("/Assets", "");
            string fullPath = System.IO.Path.Combine(projectFullPath, relativePath);
            return System.IO.Path.GetFullPath(fullPath);
        }

        /// <summary>
        /// Converts absolute path to an asset to a relative path
        /// </summary>
        public static string AssetAbsolutePathToRelativePath(string absolutePath)
        {
            absolutePath = absolutePath.Replace("\\", "/");

            string projectPath = Application.dataPath.Replace("/Assets", "");

            if (absolutePath.StartsWith(projectPath))
            {
                return absolutePath.Substring(projectPath.Length + 1);
            }
            // else
            Debug.LogError("The provided path is not within the Unity project.");
            return null;
        }
        
        /// <summary>
        /// Opens a path through file browser
        /// </summary>
        public static void OpenInFileBrowser(string path)
        {
            string fullPath = Path.GetFullPath(path);

            if (Directory.Exists(fullPath))
            {
                // For directories, open the folder
                Process.Start(GetFileExplorer(), fullPath);
            }
            else if (File.Exists(fullPath))
            {
                // For files, highlight the file
                Process.Start(GetFileExplorer(), $"/select,\"{fullPath}\"");
            }
            else
            {
                Debug.LogError("The specified path does not exist.");
            }
        }
        
        /// <summary>
        /// Returns the project name based on its directory
        /// </summary>
        public static string GetProjectDirectoryName()
        {
            // Last directory is /Assets, so the one before it is the project directory
            return Application.dataPath.Split('/')[^2];
        }
        
        private static string GetFileExplorer()
        {
            if (Application.platform == RuntimePlatform.WindowsEditor)
            {
                return "explorer.exe";
            }
            else if (Application.platform == RuntimePlatform.OSXEditor)
            {
                return "open";
            }
            else if (Application.platform == RuntimePlatform.LinuxEditor)
            {
                return "xdg-open";
            }
            else
            {
                Debug.LogError("Unsupported platform.");
                return null;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/PathUtilities.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/PlacePointExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b8989560f3c68894abe9dc91a8016509
# ASMDEF: ldx.framework.runtime.dll
# ---
using Autohand;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class PlacePointExtensions
    {
        /// <summary>
        /// Attempts to place a grabbable object into this point, performing safety checks and verifying the final state.
        /// </summary>
        /// <param name="point">Place point you're attempting to place the object in</param>
        /// <param name="grabbable">The object you're trying to place</param>
        /// <returns>True if the intended object is placed in the intended place point, otherwise false</returns>
        public static bool TryPlace(this PlacePoint point, Grabbable grabbable)
        {
            if (!point || !grabbable)
            {
                return false;
            }

            if (!point.CanPlace(grabbable))
            {
                return false;
            }

            point.TryPlace(grabbable);

            Grabbable placed = point.GetPlacedObject();

            return placed &&
                   placed.placePoint == point &&
                   grabbable.placePoint == point;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/PlacePointExtensions.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/PrefabHelper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 00cafc72d3854399bdbfd75be20bea67
# ASMDEF: ldx.framework.runtime.dll
# ---
namespace Ldx.Framework.Utilities.Extensions
{
    public static class PrefabHelper
    {
        public static bool IsInPrefabStaging()
        {
#if UNITY_EDITOR

#if UNITY_2021
            return UnityEditor.SceneManagement.PrefabStageUtility.GetCurrentPrefabStage() != null;
#elif UNITY_2019_1_OR_NEWER
            return UnityEditor.SceneManagement.PrefabStageUtility.GetCurrentPrefabStage() != null;
#endif
#else
            return false;
#endif
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/PrefabHelper.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/ProjectUtilities.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 427219eb5996423a8e2b27138366a94d
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine.Rendering;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class ProjectUtilities
    {
        public static bool IsProjectUsingURP()
        {
            RenderPipelineAsset asset = GraphicsSettings.currentRenderPipeline;
            return asset != null && asset.GetType().Name.ToLower().Contains("universal");
        }
        
        /// <summary>
        /// Ensures that the directory for the specified path exists. Creates the directory if it does not exist.
        /// </summary>
        /// <param name="path">The path for which to ensure the directory exists.</param>
        public static void EnsureDirectoryExists(string path)
        {
            // Extract the directory path from the given path
            string directoryPath = System.IO.Path.GetDirectoryName(path);

            // Check if the directory exists
            if (!System.IO.Directory.Exists(directoryPath))
            {
                // If the directory does not exist, create it
                System.IO.Directory.CreateDirectory(directoryPath);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/ProjectUtilities.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/RectExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a485339faf37440fb839bb9995ad7bbb
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class RectExtensions
    {
        public static Vector2 TopLeft(this Rect rect)
        {
            return new Vector2(rect.xMin, rect.yMin);
        }
            
        public static Rect ScaleSizeBy(this Rect rect, float scale)
        {
            return rect.ScaleSizeBy(scale, rect.center);
        }
            
        public static Rect ScaleSizeBy(this Rect rect, float scale, Vector2 pivotPoint)
        {
            Rect result = rect;
            result.x -= pivotPoint.x;
            result.y -= pivotPoint.y;
            result.xMin *= scale;
            result.xMax *= scale;
            result.yMin *= scale;
            result.yMax *= scale;
            result.x += pivotPoint.x;
            result.y += pivotPoint.y;
            return result;
        }
            
        public static Rect ScaleSizeBy(this Rect rect, Vector2 scale)
        {
            return rect.ScaleSizeBy(scale, rect.center);
        }
            
        public static Rect ScaleSizeBy(this Rect rect, Vector2 scale, Vector2 pivotPoint)
        {
            Rect result = rect;
            result.x -= pivotPoint.x;
            result.y -= pivotPoint.y;
            result.xMin *= scale.x;
            result.xMax *= scale.x;
            result.yMin *= scale.y;
            result.yMax *= scale.y;
            result.x += pivotPoint.x;
            result.y += pivotPoint.y;
            return result;
        }

        /// <summary>
        /// Get a modified version of the rect with one or more components modified
        /// </summary>
        public static Rect Modify(this Rect rect, float? x = null, float? y = null,
            float? width = null, float? height = null)
        {
            return
                new Rect(
                    x ?? rect.x,
                    y ?? rect.y,
                    width ?? rect.width,
                    height ?? rect.height);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/RectExtensions.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/ReflectionHelpers.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d7600dc8153344fa9f627c846c3c6d23
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Reflection;
using FluffyUnderware.DevTools.Extensions;
using UnityEngine;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class ReflectionHelpers
    {
        /// <summary>
        /// Finds all classes with the attribute T
        /// </summary>
        public static List<Type> FindClassesWithAttribute<T>() where T : Attribute
        {
            List<Type> result = new List<Type>();

            // Get all assemblies in the current AppDomain
            Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();

            foreach (Assembly assembly in assemblies)
            {
                // Iterate through the types in the assembly
                Type[] types = assembly.GetTypes();

                foreach (Type type in types)
                {
                    // Check if the type has the specified attribute
                    if (type.GetCustomAttribute<T>() != null)
                    {
                        result.Add(type);
                    }
                }
            }
            return result;
        }
        
        /// <summary>
        /// Invokes a static method on a specific type
        /// </summary>
        public static void TryInvokeStaticMethod(this Type type, string methodName)
        {
            try
            {
                // Find the static method with the specified method name
                MethodInfo methodInfo = type.GetMethod(methodName, BindingFlags.Public | BindingFlags.Static);

                if (methodInfo != null)
                {
                    // Invoke the static method
                    methodInfo.Invoke(null, null);
                }
                else
                {
                    UnityEngine.Debug.LogError($"Method not found: {methodName}");
                }
            }
            catch (Exception e)
            {
                UnityEngine.Debug.LogError($"Error invoking method {methodName}: {e.Message}");
            }
        }
        
        /// <summary>
        /// Returns a HashSet of the unique types in the scene
        /// </summary>
        public static HashSet<Type> GetUniqueTypesInScene()
        {
            HashSet<Type> uniqueTypesSet = new HashSet<Type>();

            // Iterate through all game objects in the scene
            GameObject[] gameObjects = UnityEngine.SceneManagement.SceneManager.GetActiveScene().GetRootGameObjects();

            foreach (GameObject go in gameObjects)
            {
                // Get all components attached to the game object
                Component[] components = go.GetComponentsInChildren<Component>(true);

                foreach (Component component in components)
                {
                    if (component != null)
                    {
                        // Add the component's type to the set of unique types
                        uniqueTypesSet.Add(component.GetType());
                    }
                }
            }

            return uniqueTypesSet;
        }
        
        public static IEnumerable<TEnum> GetAllEnumValuesWithAttribute<TEnum, TAttribute>()
            where TEnum : Enum
            where TAttribute : Attribute
        {
            Type enumType = typeof(TEnum);
            FieldInfo[] enumFields = enumType.GetFields(BindingFlags.Static | BindingFlags.Public);

            foreach (FieldInfo fieldInfo in enumFields)
            {
                TEnum enumValue = (TEnum)fieldInfo.GetValue(null);

                TAttribute attribute = (TAttribute)fieldInfo.GetCustomAttribute(typeof(TAttribute));

                if (attribute != null)
                {
                    yield return enumValue;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/ReflectionHelpers.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/ReflectionUtilities.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 96e7da92ca0e4172909ec95c01d47fad
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Reflection;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class ReflectionUtilities
    {
        public static T CloneObject<T>(this T copyTo, T toCopy) where T : class
        {
            System.Type type = toCopy.GetType();
            System.Reflection.FieldInfo[] fields = type.GetFields(); 
            foreach (System.Reflection.FieldInfo field in fields)
            {
                field.SetValue(copyTo, field.GetValue(toCopy));
            }

            return copyTo;
        }

        public static T1 CloneFieldsWithTheSameName<T1, T2>(this T1 copyTo, T2 toCopy) 
            where T1 : class
            where T2 : class
        {
            Type copyToType = copyTo.GetType(); 
            Type toCopyType = toCopy.GetType();
            FieldInfo[] fieldsToCopy = toCopyType.GetFields(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
            FieldInfo[] fieldsToSet = copyToType.GetFields(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);

            foreach (FieldInfo fieldToCopy in fieldsToCopy)
            {
                FieldInfo matchingFieldToSet = Array.Find(fieldsToSet, f => f.Name == fieldToCopy.Name && f.FieldType == fieldToCopy.FieldType);
                if (matchingFieldToSet != null)
                {
                    matchingFieldToSet.SetValue(copyTo, fieldToCopy.GetValue(toCopy));
                }
            }

            return copyTo;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/ReflectionUtilities.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/SceneUtilities.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 669ffb848f614760b74cb880f6b9db73
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Systems.ScenarioManagement;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class SceneUtilities
    {
        /// <summary>
        /// Gets a list of scenes that are currently really loaded
        /// </summary>
        /// <returns></returns>
        public static List<Scene> GetAllLoadedScenes()
        {
            List<Scene> scenes = new List<Scene>();
            for (int i = 0; i < SceneManager.sceneCount; i++)
            {
                Scene scene = SceneManager.GetSceneAt(i);
                if (!scene.isLoaded)
                {
                    continue;
                }
                scenes.Add(scene);
            }

            return scenes;
        }

        /// <summary>
        /// Tries to get the loaded scenario scene name
        /// </summary>
        public static bool TryGetLoadedScenarioSceneName(out string scenarioSceneName, out bool isStandIn)
        {
            scenarioSceneName = null;
            isStandIn = false;

            BaseScenario scenario = Object.FindAnyObjectByType<BaseScenario>();
            if (scenario == null)
            {
                return false;
            }

            scenarioSceneName = scenario.gameObject.scene.name;
            return true;
        }
        
        /// <summary>
        /// Tries to get the loaded lobby scene name
        /// </summary>
        public static bool TryGetLoadedLobbySceneName(out string lobbyName)
        {
            LobbyScenario lobby = Object.FindAnyObjectByType<LobbyScenario>();
            if (lobby == null)
            {
                lobbyName = null;
                return false;
            }

            lobbyName = lobby.gameObject.scene.name;
            return true;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/SceneUtilities.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/ScriptableObjectUtilities.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b8d73fb9a3a34853b22332fe39c94cef
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.IO;
using FluffyUnderware.DevTools.Extensions;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using System.Linq;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class ScriptableObjectUtilities
    {
        private static char Separator => Path.DirectorySeparatorChar;

        private static string ProjectFullPath => Application.dataPath.Replace($"/Assets", $"/")
            .Replace('\\', Separator).Replace('/', Separator);

        public static T CreateInstanceAndFile<T>()
            where T : ScriptableObject
        {
            return CreateInstanceAndFile<T>(GetSavePath<T>());
        }

        /// <summary>
        /// Given a filePath, creates an instance of the scriptable object there
        /// </summary>
        public static T CreateInstanceAndFile<T>(string filePath) where T : ScriptableObject
        {
            T instance = ScriptableObject.CreateInstance<T>();
#if UNITY_EDITOR
            filePath = filePath.Replace('/', Separator).Replace('\\', Separator);
            string fullDirPath = ProjectFullPath + filePath.Substring(0, filePath.LastIndexOf(Separator));
            if (!Directory.Exists(fullDirPath))
            {
                Directory.CreateDirectory(fullDirPath);
            }

            string debugString = string.Format("{0} not found in Resources, creating new {0} at {1}",
                instance.GetType().Name, filePath);
            UnityEngine.Debug.LogWarning(debugString, instance);
            UnityEditor.AssetDatabase.CreateAsset(instance, filePath);
            UnityEditor.AssetDatabase.SaveAssets();
#endif
            return instance;
        }

        /// <summary>
        /// Gets scriptable object's save path, which can be specified
        /// with a [SavePath] attribute
        /// </summary>
        public static string GetSavePath<T>() where T : ScriptableObject
        {
            Type type = typeof(T);
            SavePathAttribute attr = type.GetCustomAttribute<SavePathAttribute>();
            string fileName = type.Name;
            if (attr == null)
            {
                return string.Format("Assets{0}Resources{0}{1}.asset",
                    Path.DirectorySeparatorChar,
                    fileName);
            }

            string path = attr.Path
                .Replace('\\', Path.DirectorySeparatorChar)
                .Replace('/', Path.DirectorySeparatorChar);
            if (path.Last() == Path.DirectorySeparatorChar)
            {
                path = path.Substring(0, path.Length - 1);
            }

            return $"{path}{Path.DirectorySeparatorChar}{fileName}.asset";
        }
        
        /// <summary>
        /// Gets scriptable object's load path, which can be specified
        /// with a [SavePath] attribute
        /// </summary>
        public static string GetLoadPath<T>() where T : ScriptableObject
        {
            Type type = typeof(T);
            SavePathAttribute attr = type.GetCustomAttribute<SavePathAttribute>();
            string fileName = type.Name;
            if (attr == null)
            {
                return fileName;
            }

            string path = attr.Path
                .Replace('\\', Path.DirectorySeparatorChar)
                .Replace('/', Path.DirectorySeparatorChar);
            if (path.Last() == Path.DirectorySeparatorChar)
            {
                path = path.Substring(0, path.Length - 1);
            }

            path = path.Replace($"Assets{Separator}Resources{Separator}", "");
            
            return $"{path}{Path.DirectorySeparatorChar}{fileName}";
        }
#if UNITY_EDITOR
        public static T[] GetAllInstances<T>() where T : ScriptableObject
        {
            string[] guids = UnityEditor.AssetDatabase.FindAssets("t:" + typeof(T).Name);
            T[] a = new T[guids.Length];
            for (int i = 0; i < guids.Length; i++)
            {
                string path = UnityEditor.AssetDatabase.GUIDToAssetPath(guids[i]);
                a[i] = UnityEditor.AssetDatabase.LoadAssetAtPath<T>(path);
            }

            return a;
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/ScriptableObjectUtilities.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/SerializableDictionaryExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7123bf323b8f48f283088c53bbcef927
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities.Serializable;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class SerializableDictionaryExtensions
    {
        public static TValue GetValueOrDefault<TKey, TValue>(this SerializableDictionary<TKey, TValue> dict, TKey key, TValue defaultValue)
        {
            if (dict.TryGetValue(key, out TValue value))
            {
                return value;
            }
            return defaultValue;
        }
        
        public static bool TryGetValueOrDefault<TKey, TValue>(this SerializableDictionary<TKey, TValue> dict, TKey key, TValue defaultValue, out TValue foundValue)
        {
            if (dict.TryGetValue(key, out TValue value))
            {
                foundValue = value;
                return true;
            }
            foundValue = defaultValue;
            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/SerializableDictionaryExtensions.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/SerializedObjectUtilities.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e41d4d856d12460b89a6af807fcb818c
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class SerializedObjectUtilities
    {
        public static T DeepClone<T>(this T obj)
        {
            using (var ms = new MemoryStream())
            {
                var formatter = new BinaryFormatter();
                formatter.Serialize(ms, obj);
                ms.Position = 0;

                return (T)formatter.Deserialize(ms);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/SerializedObjectUtilities.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/StringUtilities.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6117c33cb4524800a49b20dbfa741486
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Text;
using Random = UnityEngine.Random;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class StringUtilities
    {
        private struct IntRange
        {
            public int Min { get; }
            public int Max { get; }
            
            public IntRange(int min, int max)
            {
                Min = min;
                Max = max;
            }
        }
        
        private const float PER_WORD_DELAY = 0.5f;
        private static char S => Path.DirectorySeparatorChar;
        
        public static string GenerateUniqueId(int minLength = 5, int maxLength = 9, List<string> exclude = null)
        {
            int length = Random.Range(minLength, maxLength + 1);
            // array for character ranges (numbers, upper letters, and lower letters)
            IntRange[] charRanges = new IntRange[3];
            charRanges[0] = new IntRange('0', '9');
            charRanges[1] = new IntRange('A', 'Z');
            charRanges[2] = new IntRange('a', 'z');
            string str = String.Empty;
            
            bool passed = false;

            while (!passed)
            {
                str = String.Empty;
               
                for (int i = 0; i < length; i++)
                {
                    // Select a random char range
                    IntRange r = charRanges[Random.Range(0, charRanges.Length)];
               
                    // Use this range to get a random character and add it
                    str += (char) Random.Range(r.Min, r.Max + 1);
                }

                if (exclude == null)
                {
                    passed = true;
                }
                else
                {
                    passed = !exclude.Contains(str);
                }
            }
            
            return str;
        }

        /// <summary>
        /// Gets reading time of text in seconds
        /// </summary>
        public static float GetReadingTimeSeconds(this string input)
        {
            int numWords = input.Split(' ').Length + 1;
            return numWords * PER_WORD_DELAY;
        }

        /// <summary>
        /// Gets reading time of text in MS
        /// </summary>
        public static int GetReadingTimeMS(this string input)
        {
            return (int)(input.GetReadingTimeSeconds() * 1000.0f);
        }

        public static string GetSanitizedPath(this string path)
        {
            return path.Replace('\\', S).Replace('/', S);
        }
        
        public static string SeparateWords(this string input)
        {
            if (string.IsNullOrWhiteSpace(input))
            {
                return input;
            }

            var result = new StringBuilder();
            bool lastCharUpperOrDigit = false;
            bool secondLastCharUpperOrDigit = false;

            for (int i = 0; i < input.Length; i++)
            {
                char currentChar = input[i];
                bool currentCharUpperOrDigit = Char.IsUpper(currentChar) || Char.IsDigit(currentChar);

                if (i > 0)
                {
                    // Handle transitions from uppercase/digit to lowercase
                    if (currentCharUpperOrDigit)
                    {
                        if (!lastCharUpperOrDigit)
                        {
                            result.Append(' ');
                        }
                        else if (i < input.Length - 1 && !Char.IsUpper(input[i + 1]) && !Char.IsDigit(input[i + 1]))
                        {
                            result.Append(' ');
                        }
                    }
                    else if (lastCharUpperOrDigit && secondLastCharUpperOrDigit)
                    {
                        result.Append(' ');
                    }
                }

                result.Append(currentChar);

                secondLastCharUpperOrDigit = lastCharUpperOrDigit;
                lastCharUpperOrDigit = currentCharUpperOrDigit;
            }

            return result.ToString().Trim();
        }

        /// <summary>
        /// Given a string, returns a version without commonly
        /// illegal special characters
        /// </summary>
        public static string RemoveSpecialCharacters(this string str, params char[] exceptions)
        {
            HashSet<char> exceptionsSet = new HashSet<char>(exceptions);

            StringBuilder sb = new StringBuilder();
            foreach (char c in str)
            {
                if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '_' || exceptionsSet.Contains(c))
                {
                    sb.Append(c);
                }
            }

            return sb.ToString();
        }
        
        /// <summary>
        /// Converts an input to a lower case underline format
        /// </summary>
        public static string ToLowerCaseUnderlineFormat(this string input)
        {
            string buffer = input.Replace(' ', '_').RemoveSpecialCharacters();
            string result = "";
            for (int i = 0; i < buffer.Length; i++)
            {
                result += Char.ToLower(buffer[i]);
            }
            return result;
        }
        
        /// <summary>
        /// Converts an input to an upper camel case dash format
        /// </summary>
        public static string ToUpperCamelCaseDashFormat(this string input)
        {
            string buffer = input.Replace(' ', '-').RemoveSpecialCharacters(new []{'-'});
            string result = "";
            for (int i = 0; i < buffer.Length; i++)
            {
                if (i == 0 || buffer[i - 1] == '-')
                {
                    result += Char.ToUpper(buffer[i]);
                    continue;
                }
                result += Char.ToLower(buffer[i]);
            }
            return result;
        }
        
        public static bool IsSimilarName(string inputName, string existingName)
        {
            // Normalize strings (to lowercase for this example)
            string normalizedInput = inputName.ToLower();
            string normalizedExisting = existingName.ToLower();

            // Split names into words
            var inputWords = normalizedInput.Split(' ');
            var existingWords = normalizedExisting.Split(' ');

            // Check for common words
            if (inputWords.Any(word => existingWords.Contains(word)))
                return true;

            // Optional: Implement Levenshtein distance check for more refined comparison
            // if (LevenshteinDistance(normalizedInput, normalizedExisting) < threshold)
            //     return true;

            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/StringUtilities.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/TaskExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3b235af05e754409a1a805b5a8dded11
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Threading;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class TaskExtensions
    {
        /// <summary>
        /// Safely cancels and disposes a cancellation token source, handling
        /// the exception resulting from the source being disposed and suppressing it
        /// </summary>
        public static void SafeCancelAndDispose(this CancellationTokenSource cts)
        {
            if (cts == null) return;

            try
            {
                cts.Cancel();
                cts.Dispose();
            }
            catch (Exception e)
            {
                // Ignored 
            }
        }

        /// <summary>
        /// Cancels and disposes a CancellationTokenSource reference, creates a new one
        /// </summary>
        public static void DisposeAndReplaceTokenSource(ref CancellationTokenSource cts)
        {
            cts.SafeCancelAndDispose();
            cts = new CancellationTokenSource();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/TaskExtensions.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/TextureExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c99caec0410640a89969a779e58fbec3
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class TextureUtilities
    {
        /// <summary>
        /// Creates a texture with rounded edges
        /// </summary>
        public static Texture2D CreateRoundedTexture(int width, int height, int radius, Color color)
        {
            Texture2D texture = new Texture2D(width, height);
            Color clear = new Color(0, 0, 0, 0);

            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    if ((x < radius && y < radius && Mathf.Pow(x - radius, 2) + Mathf.Pow(y - radius, 2) > Mathf.Pow(radius, 2)) ||
                        (x >= width - radius && y < radius && Mathf.Pow(x - (width - radius - 1), 2) + Mathf.Pow(y - radius, 2) > Mathf.Pow(radius, 2)) ||
                        (x < radius && y >= height - radius && Mathf.Pow(x - radius, 2) + Mathf.Pow(y - (height - radius - 1), 2) > Mathf.Pow(radius, 2)) ||
                        (x >= width - radius && y >= height - radius && Mathf.Pow(x - (width - radius - 1), 2) + Mathf.Pow(y - (height - radius - 1), 2) > Mathf.Pow(radius, 2)))
                    {
                        texture.SetPixel(x, y, clear);
                    }
                    else
                    {
                        texture.SetPixel(x, y, color);
                    }
                }
            }

            texture.Apply();
            return texture;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/TextureExtensions.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/TimeUtilities.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 75bdc59b07324267aa94fe229ec29a3b
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;
using Debug = Ldx.Framework.Utilities.Logging.Debug;

namespace Ldx.Framework.Utilities.Extensions
{
	public static class TimeUtilities
	{
		public static DateTime GetTimeNowEST()
		{
			DateTime utcNow = DateTime.UtcNow;
			string timeZoneId;

			// Check platform and choose appropriate time zone ID
			if (Application.platform == RuntimePlatform.WindowsEditor ||
			    Application.platform == RuntimePlatform.WindowsPlayer)
			{
				timeZoneId = "Eastern Standard Time"; // Windows time zone ID
			}
			else
			{
				timeZoneId = "America/New_York"; // IANA time zone ID, used by Linux/Android/macOS
			}

			try
			{
				TimeZoneInfo estZone = TimeZoneInfo.FindSystemTimeZoneById(timeZoneId);
				return TimeZoneInfo.ConvertTimeFromUtc(utcNow, estZone);
			}
			catch (TimeZoneNotFoundException)
			{
				Debug.LogWarning($"The time zone '{timeZoneId}' could not be found, falling back on UTC");
				return utcNow; // Fallback to UTC if the time zone is not found
			}
			catch (InvalidTimeZoneException)
			{
				Debug.LogWarning($"The time zone '{timeZoneId}' is invalid, falling back on UTC");
				return utcNow; // Fallback to UTC if the time zone is invalid
			}
		}

		public static string GetTimeNowESTString(char separator = ':')
		{
			return GetTimeNowEST().ToString($"HH{separator}mm{separator}ss");
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/TimeUtilities.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/TransformUtilities.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0772e61e4d1f4c279b24226272510570
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using UnityEngine;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class TransformUtilities
    {
        public static List<Transform> SortClockwiseOrCounterClockwise(this List<Transform> transformList, bool clockwise)
        {
            Vector3 sum = Vector3.zero;
        
            foreach (Transform t in transformList)
            {
                sum += t.position;
            }

            Vector3 centerPoint = sum / transformList.Count; 
            
            transformList.Sort((a, b) => {
                float angleA = Mathf.Atan2(a.position.z - centerPoint.z, a.position.x - centerPoint.x) * Mathf.Rad2Deg;
                float angleB = Mathf.Atan2(b.position.z - centerPoint.z, b.position.x - centerPoint.x) * Mathf.Rad2Deg;

                if (angleA < 0) angleA += 360f;
                if (angleB < 0) angleB += 360f;

                if (clockwise)
                {
                    return angleB.CompareTo(angleA);  // Clockwise
                }
                else
                {
                    return angleA.CompareTo(angleB);  // Counter Clockwise
                }
            });

            return transformList;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/TransformUtilities.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/VectorExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 930fe79cd9e2460e9b0ac3b0f83f8325
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Extensions
{

    public static class VectorExtensions
    {
        public static float InverseLerp(Vector3 a, Vector3 b, Vector3 value)
        {
            Vector3 ab = b - a;
            Vector3 av = value - a;
            return Vector3.Dot(av, ab) / Vector3.Dot(ab, ab);
        }
        
        /// <summary>
        /// Returns a modified version of the vector with one or more components modified
        /// </summary>
        /// <param name="x">X component to modify</param>
        /// <param name="y">Y component to modify</param>
        /// <returns>A modified version of the vector with the passed component configurations</returns>
        public static Vector2 Modify(this Vector2 point, float? x = null, float? y = null)
        {
            // transform.position = transform.position.Modify(y: 0)
            return new Vector2(x == null ? point.x : x.Value, y == null ? point.y : y.Value);
        }

        /// <summary>
        /// Get a modified version of the vector with one or more components modified
        /// </summary>
        /// <param name="x">X component to modify</param>
        /// <param name="y">Y component to modify</param>
        /// <param name="z">Z component to modify</param>
        /// <returns>A modified version of the vector with the passed component configurations</returns>
        public static Vector3 Modify(this Vector3 point, float? x = null, float? y = null, float? z = null)
        {
            // transform.position = transform.position.Modify(z: 0)
            return new Vector3(x == null ? point.x : x.Value, y == null ? point.y : y.Value,
                z == null ? point.z : z.Value);
        }
        
        public static Vector3 Modify(this Vector3 point, Axis axis, float value)
        {
            // transform.position = transform.position.Modify(Axis.X, 180)
            point[(int)axis] = value;
            return point;
        }
        
        public static float GetAxis(this Vector3 point, Axis axis)
        {
            return point[(int)axis];
        }

        public static Vector3 GetRotationAxis(Axis axis)
        {
            return Vector3.zero.Modify(axis, 1);
        }

        /// <summary>
        /// Get a modified version of the vector with one or more components modified
        /// </summary>
        /// <param name="x">X component to modify</param>
        /// <param name="y">Y component to modify</param>
        /// <param name="z">Z component to modify</param>
        /// <param name="w">W component to modify</param>
        /// <returns>A modified version of the vector with the passed component configurations</returns>
        public static Vector4 Modify(this Vector4 point, float? x = null, float? y = null, float? z = null,
            float? w = null)
        {
            // transform.position = transform.position.Modify(w: 0)
            return new Vector4(
                x == null ? point.x : x.Value,
                y == null ? point.y : y.Value,
                z == null ? point.z : z.Value,
                w == null ? point.w : w.Value);
        }
        
                /// <summary>
        /// Adds specified values to the respective components of a Vector2.
        /// </summary>
        /// <param name="vector">The original Vector2.</param>
        /// <param name="x">The value to add to the X component.</param>
        /// <param name="y">The value to add to the Y component.</param>
        /// <returns>A new Vector2 with adjusted components.</returns>
        public static Vector2 Add(this Vector2 vector, float? x = null, float? y = null)
        {
            return new Vector2(
                x.HasValue ? vector.x + x.Value : vector.x,
                y.HasValue ? vector.y + y.Value : vector.y
            );
        }

        /// <summary>
        /// Adds specified values to the respective components of a Vector3.
        /// </summary>
        /// <param name="vector">The original Vector3.</param>
        /// <param name="x">The value to add to the X component.</param>
        /// <param name="y">The value to add to the Y component.</param>
        /// <param name="z">The value to add to the Z component.</param>
        /// <returns>A new Vector3 with adjusted components.</returns>
        public static Vector3 Add(this Vector3 vector, float? x = null, float? y = null, float? z = null)
        {
            return new Vector3(
                x.HasValue ? vector.x + x.Value : vector.x,
                y.HasValue ? vector.y + y.Value : vector.y,
                z.HasValue ? vector.z + z.Value : vector.z
            );
        }

        /// <summary>
        /// Adds specified values to the respective components of a Vector4.
        /// </summary>
        /// <param name="vector">The original Vector4.</param>
        /// <param name="x">The value to add to the X component.</param>
        /// <param name="y">The value to add to the Y component.</param>
        /// <param name="z">The value to add to the Z component.</param>
        /// <param name="w">The value to add to the W component.</param>
        /// <returns>A new Vector4 with adjusted components.</returns>
        public static Vector4 Add(this Vector4 vector, float? x = null, float? y = null, float? z = null, float? w = null)
        {
            return new Vector4(
                x.HasValue ? vector.x + x.Value : vector.x,
                y.HasValue ? vector.y + y.Value : vector.y,
                z.HasValue ? vector.z + z.Value : vector.z,
                w.HasValue ? vector.w + w.Value : vector.w
            );
        }

        /// <summary>
        /// Multiplies specified values with the respective components of a Vector2.
        /// </summary>
        /// <param name="vector">The original Vector2.</param>
        /// <param name="x">The value to multiply the X component.</param>
        /// <param name="y">The value to multiply the Y component.</param>
        /// <returns>A new Vector2 with adjusted components.</returns>
        public static Vector2 Multiply(this Vector2 vector, float? x = null, float? y = null)
        {
            return new Vector2(
                x.HasValue ? vector.x * x.Value : vector.x,
                y.HasValue ? vector.y * y.Value : vector.y
            );
        }

        /// <summary>
        /// Multiplies specified values with the respective components of a Vector3.
        /// </summary>
        /// <param name="vector">The original Vector3.</param>
        /// <param name="x">The value to multiply the X component.</param>
        /// <param name="y">The value to multiply the Y component.</param>
        /// <param name="z">The value to multiply the Z component.</param>
        /// <returns>A new Vector3 with adjusted components.</returns>
        public static Vector3 Multiply(this Vector3 vector, float? x = null, float? y = null, float? z = null)
        {
            return new Vector3(
                x.HasValue ? vector.x * x.Value : vector.x,
                y.HasValue ? vector.y * y.Value : vector.y,
                z.HasValue ? vector.z * z.Value : vector.z
            );
        }

        /// <summary>
        /// Multiplies specified values with the respective components of a Vector4.
        /// </summary>
        /// <param name="vector">The original Vector4.</param>
        /// <param name="x">The value to multiply the X component.</param>
        /// <param name="y">The value to multiply the Y component.</param>
        /// <param name="z">The value to multiply the Z component.</param>
        /// <param name="w">The value to multiply the W component.</param>
        /// <returns>A new Vector4 with adjusted components.</returns>
        public static Vector4 Multiply(this Vector4 vector, float? x = null, float? y = null, float? z = null, float? w = null)
        {
            return new Vector4(
                x.HasValue ? vector.x * x.Value : vector.x,
                y.HasValue ? vector.y * y.Value : vector.y,
                z.HasValue ? vector.z * z.Value : vector.z,
                w.HasValue ? vector.w * w.Value : vector.w
            );
        }
        
        /// <summary>
        /// Calculates the normalized direction vector from this vector to the target vector.
        /// </summary>
        /// <param name="from">The starting point (this vector).</param>
        /// <param name="to">The target point.</param>
        /// <returns>The normalized direction vector pointing from this vector to the 'to' vector.</returns>
        public static Vector3 GetDirection(this Vector3 from, Vector3 to)
        {
            return (to - from).normalized;
        }

        /// <summary>
        /// Calculates the squared distance between two points using vector subtraction and sqrMagnitude.
        /// This is preferred when you only need to compare distances.
        /// </summary>
        /// <param name="from">The starting point (this vector).</param>
        /// <param name="to">The target point.</param>
        /// <returns>The distance between this vector and the 'to' vector.</returns>
        public static float GetSqrDistance(this Vector3 from, Vector3 to)
        {
            return (to - from).sqrMagnitude;
        }
        
        
        /// <summary>
        /// Calculates the distance between two points using vector subtraction and magnitude.
        /// This is preferred alternative to Vector3.distance, and will give you the same outcome.
        /// </summary>
        /// <param name="from">The starting point (this vector).</param>
        /// <param name="to">The target point.</param>
        /// <returns>The distance between this vector and the 'to' vector.</returns>
        public static float GetDistance(this Vector3 from, Vector3 to)
        {
            return (to - from).magnitude;
        }

    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/VectorExtensions.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/VisualElementExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: fa37280d6a1045529f8b758d61ef5dda
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine.UIElements;

namespace Ldx.Framework.Utilities.Extensions
{
    public static class VisualElementExtensions
    {
        /// <summary>
        /// Toggles a class on or off for the specified VisualElement based on the setActive flag.
        /// </summary>
        /// <param name="visualElement">The VisualElement to modify.</param>
        /// <param name="className">The name of the class to toggle.</param>
        /// <param name="setActive">If true, the class will be added; if false, it will be removed.</param>
        public static void ToggleClass(this VisualElement visualElement, string className, bool setActive)
        {
            if (visualElement == null)
            {
                return;
            }
            
            if (setActive)
            {
                if (!visualElement.ClassListContains(className))
                {
                    visualElement.AddToClassList(className);
                }
            }
            else
            {
                if (visualElement.ClassListContains(className))
                {
                    visualElement.RemoveFromClassList(className);
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Extensions/VisualElementExtensions.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/GlobalSettings.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a419f18f780048b3bfd813b8eddfe5e3
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

#if UNITY_EDITOR
using System.Reflection;
using UnityEditor;
#endif

namespace Ldx.Framework.Utilities
{
    /// <summary>
    /// Identifies a field as belonging to a settings group.
    /// Groups can be displayed separately within ProjectSettings
    /// </summary>
    public class GlobalSettingsGroup : PropertyAttribute
    {
        public string groupID;

        public GlobalSettingsGroup(string groupID)
        {
            this.groupID = groupID;
        }
    }
    
    public abstract class GlobalSettings<T> : ScriptableSingleton<T> where T : ScriptableObject
    {
#if UNITY_EDITOR
        protected static SettingsProvider CreateGlobalSettingsProvider(string path, params string[] acceptedGroupIDs)
        {
            return CreateGlobalSettingsProvider(path, SettingsScope.Project, acceptedGroupIDs);
        }
        
        protected static SettingsProvider CreateGlobalSettingsProvider(string path, SettingsScope settingsScope, params string[] acceptedGroupIDs)
        {
            SerializedObject settings = new SerializedObject(Instance);
            FieldInfo[] classFields = Instance.GetType().GetFields(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
            Dictionary<string, FieldInfo> infoByProperty = new Dictionary<string, FieldInfo>();
            HashSet<SerializedProperty> permittedProperties = new HashSet<SerializedProperty>();

            foreach (FieldInfo fieldInfo in classFields)
            {
                infoByProperty.Add(fieldInfo.Name, fieldInfo);
            }
            
            List<string> displayNames = new List<string>();
            SerializedProperty propertyIterator =  settings.GetIterator();

            if (propertyIterator.NextVisible(true))
            {
                do
                {
                    displayNames.Add(propertyIterator.displayName);

                    if (acceptedGroupIDs == null ||
                        acceptedGroupIDs.Length <= 0 ||
                        (infoByProperty.ContainsKey(propertyIterator.name) &&
                         FieldHasAPermittedAttribute(infoByProperty[propertyIterator.name], acceptedGroupIDs)))
                    {
                        permittedProperties.Add(propertyIterator.Copy());
                    }
                } while (propertyIterator.NextVisible(false));
            }
            

            // First parameter is the path in the Settings window.
            // Second parameter is the scope of this setting: it only appears in the Project Settings window.
            SettingsProvider provider = new SettingsProvider(path, settingsScope)
            {
                titleBarGuiHandler = () =>
                {
                    EditorGUI.BeginDisabledGroup(true);
                    EditorGUIUtility.labelWidth *= 2f;
                    GUIStyle style = new GUIStyle(EditorStyles.label);
                    style.alignment = TextAnchor.MiddleRight;
                    style.clipping = TextClipping.Overflow;
                    style.stretchWidth = true;
                    EditorGUILayout.LabelField(path, style);
                    EditorGUIUtility.labelWidth *= 0.5f;
                    EditorGUI.EndDisabledGroup();
                },
                guiHandler = (searchContext) =>
                {
                    string trimmedSearchContext = new string(searchContext.Where(char.IsLetterOrDigit).ToArray());
                    
                    EditorGUIUtility.labelWidth *= 2f;

                    foreach (SerializedProperty property in permittedProperties)
                    {
                        if (property.displayName.
                                IndexOf(trimmedSearchContext, StringComparison.InvariantCultureIgnoreCase) >= 0 &&
                            permittedProperties.Contains(property))
                        {
                            EditorGUILayout.PropertyField(property, true);
                        }
                    }

                    EditorGUIUtility.labelWidth *= 0.5f;
                    settings.ApplyModifiedProperties();
                },
                // Populate the search keywords to enable smart search filtering and label highlighting:
                keywords = displayNames.ToArray()
            };

            return provider;
        }

        public static void SetGlobalSettingDirty()
        {
            AssetDatabase.Refresh();
            EditorUtility.SetDirty(Instance);
        }

        private static bool FieldHasAPermittedAttribute(FieldInfo fieldInfo, string[] acceptedGroupIDs)
        {
            foreach (Attribute attribute in fieldInfo.GetCustomAttributes())
            {
                if (attribute is GlobalSettingsGroup globalSettingsGroup)
                {
                    foreach (string acceptedGroupID in acceptedGroupIDs)
                    {
                        if (globalSettingsGroup.groupID == acceptedGroupID)
                        {
                            return true;
                        }
                    }
                }
            }

            return false;
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/GlobalSettings.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Graphics/SwapShaderIfSRP.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cb1a9e1cf06242f5a5eceaa870c40c66
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Utilities.Graphics
{
    /// <summary>
    /// Assuming our common materials utilize URP, use this script to check
    /// if the project is using SRP, and swap the shaders at runtime
    /// </summary>
    public class SwapShaderIfSRP : MonoBehaviour, ISaveSceneListener
    {
        [HelpBox("If left empty, shader will be swapped with 'Standard'")]
        [SerializeField]
        private Shader srpShader;
        [SerializeField]
        private bool applyToAllChildren;
        [ReadOnly]
        [SerializeField] 
        private List<MeshRenderer> meshRenderers = new List<MeshRenderer>();
        [ReadOnly]
        [SerializeField] 
        private List<SkinnedMeshRenderer> skinnedMeshRenderers = new List<SkinnedMeshRenderer>();
        private Shader ReplacementShader { get; set; }

        public void OnSceneSaving()
        {
            meshRenderers.Clear();
            skinnedMeshRenderers.Clear();
            if (applyToAllChildren)
            {
                meshRenderers = GetComponentsInChildren<MeshRenderer>(true)
                    .Where(r => r.GetComponent<SwapShaderIfSRP>() == null)
                    .ToList();
                
                skinnedMeshRenderers = GetComponentsInChildren<SkinnedMeshRenderer>(true)
                    .Where(r => r.GetComponent<SwapShaderIfSRP>() == null)
                    .ToList();
            }
            meshRenderers.AddRange(GetComponents<MeshRenderer>());
            skinnedMeshRenderers.AddRange(GetComponents<SkinnedMeshRenderer>());
        }
        
        private void Awake()
        {
            InitReplacementShader();
            TrySwapShaders();
        }

        private void InitReplacementShader()
        {
            if (srpShader != null)
            {
                ReplacementShader = srpShader;
                return;
            }
            ReplacementShader = Shader.Find("Standard");
        }

        private void TrySwapShaders()
        {
            if (ProjectUtilities.IsProjectUsingURP())
            {
                return;
            }
            
            foreach (MeshRenderer r in meshRenderers)
            {
                for (int i = 0; i < r.materials.Length; i++)
                {
                    if (!r.materials[i].shader.name.ToLower().Contains("universal"))
                    {
                        continue;
                    }
                    r.materials[i].shader = ReplacementShader;
                }
            }
            
            foreach (SkinnedMeshRenderer r in skinnedMeshRenderers)
            {
                for (int i = 0; i < r.materials.Length; i++)
                {
                    if (!r.materials[i].shader.name.ToLower().Contains("universal"))
                    {
                        continue;
                    }
                    r.materials[i].shader = ReplacementShader;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Graphics/SwapShaderIfSRP.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/HasFrameworkDefaultAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4b23477b59ec45e9b34248660086513c
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;

namespace Ldx.Framework.Utilities
{
    /// <summary>
    /// Apply this attribute to a ScriptableSingleton class to indicate that it uses
    /// the hierarchical loading system (i.e., it has a master default in the framework
    /// and a potential override in the project's Resources).
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public sealed class HasFrameworkDefaultAttribute : Attribute { }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/HasFrameworkDefaultAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Hierarchy/HierarchyColor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 16ef0f90931e40a895cc470ea8c92ade
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Utilities.Hierarchy
{
    /// <summary>
    /// Used to specify a specific color for this item in the hierarchy
    /// </summary>
    public class HierarchyColor : MonoBehaviour
    {
        private void OnValidate()
        {
            if (!ReferenceBank.IsValid)
            {
                return;
            }

            if (ReferenceBank.Instance.ContainsHierarchyColor(this))
            {
                return;
            }
            ReferenceBank.Instance.RefreshHierarchyColorReferences();
        }

        [SerializeField] private bool applyToChildren = true;
        public bool ApplyToChildren => applyToChildren;
        
        [SerializeField] private HierarchyType hierarchyType;
        public HierarchyType HierarchyType => hierarchyType;

        [ShowIf("hierarchyType", Op.Equals, HierarchyType.Custom)]
        [SerializeField] 
        private Color customColor = Color.gray;
        public Color CustomColor => customColor;
    }
    
    [Serializable]
    public enum HierarchyType
    {
        ScenarioSetup = 0,
        Global,
        Features,
        Environment,
        Custom
    }

}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Hierarchy/HierarchyColor.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Hierarchy/HierarchyColorSettings.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2d604347857e4aa688957dc0d1cdb345
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;

namespace Ldx.Framework.Utilities.Hierarchy
{
    /// <summary>
    /// Scriptable object containing settings for hierarchy colors
    /// </summary>
    [CreateAssetMenu(fileName = "HierarchyColorSettings", menuName = "Hierarchy/HierarchyColorSettings", order = 0)]
    public class HierarchyColorSettings : ScriptableSingleton<HierarchyColorSettings>
    {
        [Range(0.0f, 1.0f)]
        [SerializeField] private float colorAlpha = 0.3f;
        public static float ColorAlpha => Instance.colorAlpha;
        
        [SerializeField] 
        private SerializableDictionary<HierarchyType, Color> hierarchyColors;

        [Header("Previous Selection")] 
        [SerializeField] private Color previousSelectionColor = Color.yellow;
        public static Color PreviousSelectionColor => Instance.previousSelectionColor;
        
        [Range(0.0f, 1.0f)]
        [SerializeField] private float previousSelectionAlpha = 0.2f;
        public static float PreviousSelectionAlpha => Instance.previousSelectionAlpha;
        
        private void OnValidate()
        {
            if (hierarchyColors.ContainsKey(HierarchyType.Custom))
            {
                hierarchyColors.Remove(HierarchyType.Custom);
            }
        }

        public static Color? GetColorForHierarchyType(HierarchyType type)
        {
            if (!Instance.hierarchyColors.TryGetValue(type, out Color color))
            {
                return null;
            }

            return color;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Hierarchy/HierarchyColorSettings.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/InputUtilities/ControllerButtonInput.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6646312a82c88584d9e909922058094e
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Autohand.Demo;
using Ldx.Framework.Systems.Player.Hands;
using Ldx.Framework.Systems.Player.Input;
using UnityEngine;

namespace Ldx.Framework.Utilities.InputUtilities
{
    public class ControllerButtonInput : MonoBehaviour
    {
        public event Action<bool> OnButtonStateChange;
        
        [Header("Controller Binding")]
        [SerializeField] List<HandSide> handSides;
        [SerializeField] private CommonButton buttonBinding = CommonButton.primaryButton;
        
        private readonly List<XRHandControllerLink> targetControllers = new();
        private readonly Dictionary<XRHandControllerLink, bool> lastControllerStates = new();
        
        private void Start()
        {
            InitializeControllers();
        }

        private void InitializeControllers()
        {
            targetControllers.Clear();
            lastControllerStates.Clear();
            foreach (HandSide side in handSides)
            {
                XRHandControllerLink controllerLink = side is HandSide.Left ? ControllersInputModule.LeftHand : ControllersInputModule.RightHand;
                targetControllers.Add(controllerLink);
                lastControllerStates.Add(controllerLink, false);
            }
        }
        
        private void Update()
        {
            if (targetControllers.Count == 0)
            {
                return;
            }
            
            foreach (XRHandControllerLink controller in targetControllers)
            {
                bool currentState = controller.ButtonPressed(buttonBinding);
                
                if (currentState != lastControllerStates[controller])
                {
                    OnButtonStateChange?.Invoke(currentState);
                    lastControllerStates[controller] = currentState;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/InputUtilities/ControllerButtonInput.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/ISaveSceneListener.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6321a8d4371e45029f939a2f0dd36620
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;

namespace Ldx.Framework.Utilities
{
    public interface ISaveSceneListener
    {
        static Action OnSceneSavingEvent;
        void OnSceneSaving();
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/ISaveSceneListener.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/LdxDebugUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 32d0d913e7077834a9b69e876ab552f0
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections;
using TMPro;
using UnityEngine;

namespace Ldx.Framework.Utilities
{
    public class LdxDebugUI : MonoBehaviour
    {
        public static LdxDebugUI Instance { get; private set; }

        [SerializeField] private TextMeshProUGUI ui;
        [SerializeField] private float timeToScale = 2f;
        [SerializeField] private float scaleMultiplier = 2f;

        private Vector3 originalScale;
        private bool isDisplaying = false;

        private void Awake()
        {
            if (Instance != null && Instance != this)
            {
                Destroy(gameObject);
                return;
            }

            Instance = this;
            originalScale = transform.localScale;
            ui.enabled = false;
            PositionUI();
        }

        private void PositionUI()
        {
            Transform camTransform = Camera.main.transform;
            transform.position = camTransform.position + camTransform.forward * 2f;
            transform.LookAt(camTransform);
            transform.Rotate(0f, 180f, 0f);
        }

        public static void Display(string text, float duration = 0, bool useScale = false)
        {
            if (Instance == null)
            {
                Debug.LogError("LdxDebugUI instance not found. Ensure it is added to the scene.");
                return;
            }
            Instance.DisplayText(text, duration, useScale);
        }

        private void DisplayText(string text, float duration = 0, bool useScale = false)
        {
            if (string.IsNullOrEmpty(text)) return;

            ui.text = text;
            ui.enabled = true;

            if (isDisplaying) return;

            if (useScale)
                StartCoroutine(AnimateScale());
            else if (duration > 0)
                StartCoroutine(HideAfterTime(duration));
        }

        private IEnumerator HideAfterTime(float duration)
        {
            isDisplaying = true;
            yield return new WaitForSeconds(duration);
            ui.enabled = false;
            isDisplaying = false;
        }

        private IEnumerator AnimateScale()
        {
            isDisplaying = true;
            Vector3 targetScale = originalScale * scaleMultiplier;

            float halfTime = timeToScale / 2;
            yield return ScaleOverTime(originalScale, targetScale, halfTime);
            yield return ScaleOverTime(targetScale, originalScale, halfTime);

            ui.enabled = false;
            isDisplaying = false;
        }

        private IEnumerator ScaleOverTime(Vector3 startScale, Vector3 endScale, float duration)
        {
            float timer = 0;
            while (timer < duration)
            {
                transform.localScale = Vector3.Lerp(startScale, endScale, timer / duration);
                timer += Time.deltaTime;
                yield return null;
            }
            transform.localScale = endScale;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/LdxDebugUI.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Logging/BatteryLogger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5023237d71045df41b8ef0f5a81fd499
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.IO;
using UnityEngine;

namespace Ldx.Framework.Utilities.Logging
{
    public class BatteryLogger : MonoBehaviour
    {
        private const float WARNING_HIGH_BATTERY_USE = 2;
        private const float WARNING_EXTREME_BATTERY_USE = 3;
        private const string FILENAME = "BatteryLog.txt";
        
        private float startBatteryLevel;
        private DateTime sessionStartTime;
        private string logFilePath;

        private void Start()
        {
            #if !UNITY_EDITOR && LDX_INTERNAL_DEBUG
        LogBegin();
            #endif
        }

        private void OnDestroy()
        {
            #if !UNITY_EDITOR && LDX_INTERNAL_DEBUG
        LogCompletion();
            #endif
        }

        private void LogBegin()
        {
            logFilePath = Path.Combine(Application.persistentDataPath, FILENAME);

            // Log the start of the session
            sessionStartTime = DateTime.Now;
            startBatteryLevel = GetBatteryLevel();
            LogToFile($"Session Start: {sessionStartTime}");
            LogToFile($"Starting Battery Level: {startBatteryLevel}%");
        }

        private void LogCompletion()
        {
            DateTime sessionEndTime = DateTime.Now;
            float endBatteryLevel = GetBatteryLevel();
            TimeSpan sessionDuration = sessionEndTime - sessionStartTime;
            float batteryUsed = startBatteryLevel - endBatteryLevel;
            double batteryPerMinute = batteryUsed / sessionDuration.TotalMinutes;

            LogToFile($"Session End: {sessionEndTime}");
            LogToFile($"Ending Battery Level: {endBatteryLevel}%");
            LogToFile($"Session Duration: {sessionDuration}");
            LogToFile($"Battery Used: {batteryUsed}%");
            LogToFile($"Battery Usage per Minute: {batteryPerMinute:0.00}%");
            LogToFile("-------------------------------------------------");
            LogToFile(GetBatteryConsumptionReadout(batteryPerMinute));
            LogToFile("-------------------------------------------------");
        }

        private string GetBatteryConsumptionReadout(double average)
        {
            switch (average)
            {
                case var level when level >= WARNING_EXTREME_BATTERY_USE:
                    return "Extreme battery usage!";
                case var level when level >= WARNING_HIGH_BATTERY_USE:
                    return "High battery usage.";
                default:
                    return "Normal battery usage.";
            }
        }


        private float GetBatteryLevel()
        {
            return
                SystemInfo.batteryLevel *
                100f; // Returns a value between 0 and 1, so multiply by 100 to get percentage.
        }

        private void LogToFile(string message)
        {
            try
            {
                using (StreamWriter writer = new StreamWriter(logFilePath, true))
                {
                    writer.WriteLine(message);
                }
            }
            catch (Exception e)
            {
                Debug.LogError("Failed to log to file: " + e.Message);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Logging/BatteryLogger.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Logging/DebugExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 320d4e0a0ce8afa4c859110306e04ac1
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Ldx.Framework.Utilities.Logging
{
    public static class Debug
    {
        public static Action<LogVerbosity, string> OnDebugLog;
        
        public class LogMessage
        {
            public string Message { get; }
            public string StackTrace { get; }
            public LogType LogType { get; }
            public string Time { get; }

            public LogMessage(string message, string stackTrace, LogType logType, string time)
            {
                Message = message;
                StackTrace = stackTrace;
                LogType = logType;
                Time = time;
            }
        }

        private const bool IGNORE_VERBOSITY_IN_BUILD = true;
        
        public static readonly List<LogMessage> Logs = new ();

        [RuntimeInitializeOnLoadMethod]
        public static void InitializeOnLoad()
        {
            Application.logMessageReceived += HandleLogCallback;
        }

        private static void HandleLogCallback(string message, string stackTrace, LogType type)
        {
            string time = TimeUtilities.GetTimeNowESTString();
            
            Logs.Add(new LogMessage(message, stackTrace, type, time));
        }
        
        public static void LogVerbose(object message, Object context = null)
        {
            Log(LogCategory.Other, LogVerbosity.Verbose, message, context);
        }

        // Sometimes generating a log message has side effects that incur a performance cost such as
        // memory allocation or CPU queries. This filter uses a delegate to only incur this cost if
        // the message passes the verbosity filter and the message is actually required. (If Swift style
        // autoclosures ever make their way to C# this would be an excellent candidate for them)
        public static void Log(LogVerbosity verbosity, System.Func<object> message, Object context = null)
        {
            Log(LogCategory.Other, verbosity, message, context);
        }

        public static void Log(LogCategory category, LogVerbosity verbosity, System.Func<object> message, Object context = null)
        {
            LogVerbosity verbosityFilter = LogGlobalSettings.GetLogCategoryVerbosity(category);

            if (verbosityFilter <= verbosity)
            {
                Log(category, verbosity, message(), context);
            }
        }
        
        public static void LogVerbose(LogCategory category, object message, Object context = null)
        {
            Log(category, LogVerbosity.Verbose, message, context);
        }
        
        public static void Log(object message, Object context = null)
        {
            Log(LogCategory.Other, LogVerbosity.Log, message, context);
        }
        
        public static void Log(LogCategory category, object message, Object context = null)
        {
            Log(category, LogVerbosity.Log, message, context);
        }
        
        public static void Log(LogVerbosity verbosity, object message, Object context = null)
        {
            Log(LogCategory.Other, verbosity, message, context);
        }
        
        public static void LogWarning(object message, Object context = null)
        {
            Log(LogCategory.Other, LogVerbosity.Warning, message, context);
        }
        
        public static void LogWarning(LogCategory category, object message, Object context = null)
        {
            Log(category, LogVerbosity.Warning, message, context);
        }
        
        public static void LogError(object message, Object context = null)
        {
            Log(LogCategory.Other, LogVerbosity.Error, message, context);
        }
        
        public static void LogError(LogCategory category, object message, Object context = null)
        {
            Log(category, LogVerbosity.Error, message, context);
        }

        private static void Log(LogCategory category, LogVerbosity verbosity, object message, Object context = null)
        {
            LogVerbosity verbosityFilter = LogGlobalSettings.GetLogCategoryVerbosity(category);
            bool ignoreVerbosity = IGNORE_VERBOSITY_IN_BUILD && !Application.isEditor;
            
            if (ignoreVerbosity || verbosityFilter <= verbosity)
            {
                string modifiedMessage = $"{category}: {message}";
                OnDebugLog?.Invoke(verbosity, message.ToString());
                
                switch (verbosity)
                {
                    case LogVerbosity.Warning:
                        UnityEngine.Debug.LogWarning(modifiedMessage, context);
                        break;
                    case LogVerbosity.Error:
                        UnityEngine.Debug.LogError(modifiedMessage, context);
                        break;
                    default:
                        UnityEngine.Debug.Log(modifiedMessage, context);
                        break;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Logging/DebugExtensions.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Logging/LogCategories.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ec33f69dc5db493439c8257e628dbcac
# ASMDEF: ldx.framework.runtime.dll
# ---
namespace Ldx.Framework.Utilities.Logging
{
    public enum LogCategory
    {
        Other = 0,
        SaveSystem,
        Localization,
        Tutorial,
        Input,
        Player,
        UI,
        Audio,
        GameLoad,
        ObjectiveSystem,
        TrackingManager,
        ScenarioManager,
        VisualEffects,
        EventData,
        Networking,
        Physics,
        Inventory
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Logging/LogCategories.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Logging/LogGlobalSettings.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5883fd5f93862b342b0ecc747fc9ea69
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Ldx.Framework.Utilities.Logging
{
    [HasFrameworkDefault]
    public class LogGlobalSettings : GlobalSettings<LogGlobalSettings>
    {        
        private static readonly Dictionary<LogCategory, LogVerbosity> runtimeVerbosityByCategory = new Dictionary<LogCategory, LogVerbosity>();

        [SerializeField]
        private LogVerbosityCollection logSettings;
        
        private void OnValidate()
        {
            LogCategory[] categories = (LogCategory[])Enum.GetValues(typeof(LogCategory));

            if (logSettings.Length != categories.Length)
            {
                LogVerbosity[] newSettings = new LogVerbosity[categories.Length];
                
                for (int i = 0; i < categories.Length; i++)
                {
                    if (logSettings.Length > i)
                    {
                        newSettings[i] = logSettings[i];
                    }
                    else
                    {
                        newSettings[i] = LogVerbosity.Log;
                    }
                }

                logSettings = new LogVerbosityCollection(newSettings);
            }
        }

        public static LogVerbosity GetLogCategoryVerbosity(LogCategory category)
        {
#if UNITY_EDITOR
            if (runtimeVerbosityByCategory.Count <= 0)
            {
                LogCategory[] categories = (LogCategory[])Enum.GetValues(typeof(LogCategory));
                LogVerbosityCollection verbosityArray = Instance.logSettings;
                
                for(int i = 0; i < verbosityArray.Length; i++)
                {
                    runtimeVerbosityByCategory.Add(categories[i], verbosityArray[i]);
                }
            }

            return (runtimeVerbosityByCategory.ContainsKey(category)) ? runtimeVerbosityByCategory[category] : LogVerbosity.Log;
#else
            return LogVerbosity.Verbose;
#endif
        }

#if UNITY_EDITOR
        [UnityEditor.SettingsProvider]
        public static UnityEditor.SettingsProvider DisplayInProjectSettings()
        {
            return CreateGlobalSettingsProvider("Project/LDX/Systems/Logging");
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Logging/LogGlobalSettings.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Logging/LogVerbosity.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 72fa1d538e36c9d47b220249d79cbbec
# ASMDEF: ldx.framework.runtime.dll
# ---
namespace Ldx.Framework.Utilities.Logging
{
    public enum LogVerbosity
    {
        Verbose = 0,
        Log,
        Warning,
        Error,
        NoLogging
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Logging/LogVerbosity.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Logging/LogVerbosityCollection.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 61b7b6dfbbbbf124e94ce611796b1d22
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Logging
{
    [System.Serializable]
    public class LogVerbosityCollection
    {
        [SerializeField]
        private LogVerbosity[] logVerbositySettings;
        public LogVerbosity[] LogVerbositySettings => logVerbositySettings;

        public int Length => logVerbositySettings.Length;
        
        public LogVerbosityCollection(LogVerbosity[] verbosityArray)
        {
            logVerbositySettings = verbosityArray;
        }
        
        public LogVerbosity this[int index]
        {
            get => logVerbositySettings[index];
            set => logVerbositySettings[index] = value;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Logging/LogVerbosityCollection.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Logging/Reporters/CollisionReporter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5af8120cd74686e44b00c2bda9f9f149
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Logging
{
	public class CollisionReporter : MonoBehaviour
	{
		public bool reportStay;
		public bool reportCollide = true;

		private void OnCollisionEnter(Collision other)
		{
			if (reportCollide)
				Debug.Log(category: LogCategory.Physics, $"[Enter] {gameObject} has collided with {other.gameObject}");
		}

		private void OnCollisionStay(Collision other)
		{
			if (reportStay)
			{
				Debug.Log(category: LogCategory.Physics, $"[Stay] {gameObject} is colliding with {other.gameObject}");
			}
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Logging/Reporters/CollisionReporter.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Misc/LdxCollisionEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 31e61b183d7424d40be958585ef2884c
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.AudioSystem;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// This is a clone of HvrCollisionEvents (licensed), extended for our own assembly of classes so that we can customize it without it being effected by HVR updates.
/// </summary>
namespace Ldx.Framework.Utilities.Misc
{
    [RequireComponent(typeof(LdxSoundManagerExtension))]
    public class LdxCollisionEvents : MonoBehaviour
    {
        [Header("Settings")]

        public CollisionEventType CollisionType = CollisionEventType.Impulse;

        [Tooltip("Force threshold to breach to fire the ThresholdMet event")]
        public float ForceThreshold;

        [Tooltip("Collision velocity threshold to breach to fire the ThresholdMetEvent")]
        public float VelocityThreshold;

        public UnityEvent ThresholdMet = new UnityEvent();

        //LDX
        private float lastTime;
        public float minTimeBetweenSounds = 0.25f;

        [Header("Debug")]
        public float LastImpulse;
        public float LastVelocity;

        public float MaxImpulse;
        public float MaxVelocity;




        private void OnCollisionEnter(Collision other)
        {
            LastImpulse = other.impulse.magnitude;
            LastVelocity = other.relativeVelocity.magnitude;

            MaxImpulse = Mathf.Max(MaxImpulse, LastImpulse);
            MaxVelocity = Mathf.Max(MaxVelocity, LastVelocity);

            var forceMet = LastImpulse > ForceThreshold;
            var velocityMet = LastVelocity > VelocityThreshold;


            if ((CollisionType == CollisionEventType.Impulse && forceMet ||
                CollisionType == CollisionEventType.Velocity && velocityMet ||
                CollisionType == CollisionEventType.ImpulseOrVelocity && (forceMet || velocityMet))
                && Time.time > lastTime + minTimeBetweenSounds)
            {
                lastTime = Time.time;
                ThresholdMet.Invoke();
            }
        }
    }

    [Serializable]
    public enum CollisionEventType
    {
        Impulse, Velocity, ImpulseOrVelocity
    }

}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Misc/LdxCollisionEvents.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Misc/Outline.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5fea29bb7c508c244a1f805a5fd3fc4d
# ASMDEF: ldx.framework.runtime.dll
# ---
//
//  Outline.cs
//  QuickOutline
//
//  Created by Chris Nolet on 3/30/18.
//  Copyright  2018 Chris Nolet. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Ldx.Framework.Utilities.Misc
{
    [Serializable]
    public class OutlineProfile
    {
        public Outline.Mode mode = Outline.Mode.OutlineAll;
        public Color outlineColor = Color.white;
        public float outlineThickness = 0f;
        public bool precomputeOutline = true;
    }
    
    [DisallowMultipleComponent]
    public class Outline : MonoBehaviour 
    {
        private static HashSet<Mesh> registeredMeshes = new HashSet<Mesh>();

        public enum Mode {
            OutlineAll,
            OutlineVisible,
            OutlineHidden,
            OutlineAndSilhouette,
            SilhouetteOnly
        }

        public Mode OutlineMode {
            get { return outlineMode; }
            set {
                outlineMode = value;
                needsUpdate = true;
            }
        }

        public Color OutlineColor {
            get { return outlineColor; }
            set {
                outlineColor = value;
                needsUpdate = true;
            }
        }

        public float OutlineWidth {
            get { return outlineWidth; }
            set {
                outlineWidth = value;
                needsUpdate = true;
            }
        }

        [Serializable]
        private class ListVector3 {
            public List<Vector3> data;
        }

        [SerializeField]
        private Mode outlineMode;

        [SerializeField]
        private Color outlineColor = Color.white;

        [SerializeField, Range(0f, 10f)]
        private float outlineWidth = 2f;

        [Header("Optional")]

        [SerializeField, Tooltip("Precompute enabled: Per-vertex calculations are performed in the editor and serialized with the object. "
                                 + "Precompute disabled: Per-vertex calculations are performed at runtime in Awake(). This may cause a pause for large meshes.")]
        private bool precomputeOutline;

        [SerializeField, HideInInspector]
        private List<Mesh> bakeKeys = new List<Mesh>();

        [SerializeField, HideInInspector]
        private List<ListVector3> bakeValues = new List<ListVector3>();

        private Renderer[] renderers;
        private Material outlineMaskMaterial;
        private Material outlineFillMaterial;

        private bool needsUpdate;

        public void LoadProfile(OutlineProfile profile)
        {
            outlineMode = profile.mode;
            outlineColor = profile.outlineColor;
            outlineWidth = profile.outlineThickness;
            precomputeOutline = profile.precomputeOutline;
        }

        private void Awake() 
        {
            // Cache renderers
            renderers = GetComponentsInChildren<Renderer>();

            // Instantiate outline materials
            outlineMaskMaterial = Instantiate(Resources.Load<Material>(@"Materials/OutlineMask"));
            outlineFillMaterial = Instantiate(Resources.Load<Material>(@"Materials/OutlineFill"));

            outlineMaskMaterial.name = "OutlineMask (Instance)";
            outlineFillMaterial.name = "OutlineFill (Instance)";

            // Retrieve or generate smooth normals
            LoadSmoothNormals();

            // Apply material properties immediately
            needsUpdate = true;
        }

        private void OnEnable() 
        {
            foreach (Renderer renderer in renderers) 
            {
                // Append outline shaders
                List<Material> materials = renderer.sharedMaterials.ToList();

                materials.Add(outlineMaskMaterial);
                materials.Add(outlineFillMaterial);

                renderer.materials = materials.ToArray();
            }
        }

        private void OnValidate() 
        {
            // Update material properties
            needsUpdate = true;

            // Clear cache when baking is disabled or corrupted
            if (!precomputeOutline && bakeKeys.Count != 0 || bakeKeys.Count != bakeValues.Count) 
            {
                bakeKeys.Clear();
                bakeValues.Clear();
            }

            // Generate smooth normals when baking is enabled
            if (precomputeOutline && bakeKeys.Count == 0) 
            {
                Bake();
            }
        }

        private void Update() 
        {
            if (needsUpdate) 
            {
                needsUpdate = false;
                UpdateMaterialProperties();
            }
        }

        private void OnDisable() 
        {
            foreach (Renderer rend in renderers) 
            {
                // Remove outline shaders
                List<Material> materials = rend.sharedMaterials.ToList();

                materials.Remove(outlineMaskMaterial);
                materials.Remove(outlineFillMaterial);

                rend.materials = materials.ToArray();
            }
        }

        private void OnDestroy()
        {
            // Destroy material instances
            Destroy(outlineMaskMaterial);
            Destroy(outlineFillMaterial);
        }

        private void Bake() 
        {
            // Generate smooth normals for each mesh
            HashSet<Mesh> bakedMeshes = new HashSet<Mesh>();

            foreach (MeshFilter meshFilter in GetComponentsInChildren<MeshFilter>()) 
            {
                // Skip duplicates
                if (!bakedMeshes.Add(meshFilter.sharedMesh)) 
                {
                    continue;
                }

                // Serialize smooth normals
                List<Vector3> smoothNormals = SmoothNormals(meshFilter.sharedMesh);

                bakeKeys.Add(meshFilter.sharedMesh);
                bakeValues.Add(new ListVector3() { data = smoothNormals });
            }
        }

        private void LoadSmoothNormals() 
        {
            // Retrieve or generate smooth normals
            foreach (MeshFilter meshFilter in GetComponentsInChildren<MeshFilter>())
            {
                // Skip if smooth normals have already been adopted
                if (meshFilter == null || 
                    meshFilter.sharedMesh == null ||
                    !registeredMeshes.Add(meshFilter.sharedMesh))
                {
                    continue;
                }

                // Retrieve or generate smooth normals
                int index = bakeKeys.IndexOf(meshFilter.sharedMesh);
                List<Vector3> smoothNormals = (index >= 0) ? bakeValues[index].data : SmoothNormals(meshFilter.sharedMesh);

                // Store smooth normals in UV3
                meshFilter.sharedMesh.SetUVs(3, smoothNormals);
            }

            // Clear UV3 on skinned mesh renderers
            foreach (SkinnedMeshRenderer skinnedMeshRenderer in GetComponentsInChildren<SkinnedMeshRenderer>()) 
            {
                if (registeredMeshes.Add(skinnedMeshRenderer.sharedMesh)) 
                {
                    skinnedMeshRenderer.sharedMesh.uv4 = new Vector2[skinnedMeshRenderer.sharedMesh.vertexCount];
                }
            }
        }

        private List<Vector3> SmoothNormals(Mesh mesh) 
        {
            if (mesh == null)
            {
                return new List<Vector3>();
            }
    
            // Group vertices by location
            IEnumerable<IGrouping<Vector3, KeyValuePair<Vector3, int>>> groups = mesh.vertices.Select((vertex, index) => new KeyValuePair<Vector3, int>(vertex, index)).GroupBy(pair => pair.Key);

            // Copy normals to a new list
            List<Vector3> smoothNormals = new List<Vector3>(mesh.normals);

            // Average normals for grouped vertices
            foreach (IGrouping<Vector3, KeyValuePair<Vector3, int>> group in groups) 
            {
                // Skip single vertices
                if (group.Count() == 1) 
                {
                    continue;
                }

                // Calculate the average normal
                Vector3 smoothNormal = Vector3.zero;

                foreach (KeyValuePair<Vector3, int> pair in group)
                {
                    smoothNormal += mesh.normals[pair.Value];
                }

                smoothNormal.Normalize();

                // Assign smooth normal to each vertex
                foreach (KeyValuePair<Vector3, int> pair in group)
                {
                    smoothNormals[pair.Value] = smoothNormal;
                }
            }

            return smoothNormals;
        }

        private void UpdateMaterialProperties() 
        {
            // Apply properties according to mode
            outlineFillMaterial.SetColor("_OutlineColor", outlineColor);

            switch (outlineMode) 
            {
                case Mode.OutlineAll:
                    outlineMaskMaterial.SetFloat("_ZTest", (float)UnityEngine.Rendering.CompareFunction.Always);
                    outlineFillMaterial.SetFloat("_ZTest", (float)UnityEngine.Rendering.CompareFunction.Always);
                    outlineFillMaterial.SetFloat("_OutlineWidth", outlineWidth);
                    break;

                case Mode.OutlineVisible:
                    outlineMaskMaterial.SetFloat("_ZTest", (float)UnityEngine.Rendering.CompareFunction.Always);
                    outlineFillMaterial.SetFloat("_ZTest", (float)UnityEngine.Rendering.CompareFunction.LessEqual);
                    outlineFillMaterial.SetFloat("_OutlineWidth", outlineWidth);
                    break;

                case Mode.OutlineHidden:
                    outlineMaskMaterial.SetFloat("_ZTest", (float)UnityEngine.Rendering.CompareFunction.Always);
                    outlineFillMaterial.SetFloat("_ZTest", (float)UnityEngine.Rendering.CompareFunction.Greater);
                    outlineFillMaterial.SetFloat("_OutlineWidth", outlineWidth);
                    break;

                case Mode.OutlineAndSilhouette:
                    outlineMaskMaterial.SetFloat("_ZTest", (float)UnityEngine.Rendering.CompareFunction.LessEqual);
                    outlineFillMaterial.SetFloat("_ZTest", (float)UnityEngine.Rendering.CompareFunction.Always);
                    outlineFillMaterial.SetFloat("_OutlineWidth", outlineWidth);
                    break;

                case Mode.SilhouetteOnly:
                    outlineMaskMaterial.SetFloat("_ZTest", (float)UnityEngine.Rendering.CompareFunction.LessEqual);
                    outlineFillMaterial.SetFloat("_ZTest", (float)UnityEngine.Rendering.CompareFunction.Greater);
                    outlineFillMaterial.SetFloat("_OutlineWidth", 0);
                    break;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Misc/Outline.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Misc/PlayerHolster.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d78c6f87be424ec6a732fa1ae92a5e80
# ASMDEF: ldx.framework.runtime.dll
# ---
/*using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using HurricaneVR.Framework.Core;
using HurricaneVR.Framework.Core.Grabbers;
using HurricaneVR.Samples;
using Ldx.Framework.Features.SocketFilter;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using UnityEngine;

namespace Ldx.Framework.Utilities.Misc
{
    /// <summary>
    /// Expanded version of HVR's holsters to allow us to add more functionality
    /// </summary>
    public class PlayerHolster : Holster
    {
        [SerializeField] private float movementDuration = 0.5f;
        [SerializeField] private Ease movementEase = Ease.OutQuad;
        
        private List<MeshRenderer> meshRenderers = new();
        
        private Vector3 startLocalPosition;
        private Vector3 offsetLocalPosition;

        private bool movesToOffset;
        private Tween tween;
        private HVRGrabbable initialItem;
        
        // For the event data
        private bool returnSocketOnRelease = true;
        private bool applyToTargetedIds;
        private HashSet<string> targetSocketableIDsSet = new();

        protected override void Start()
        {
            base.Start();
            Grabbed.AddListener(HandleGrabbed);
            Released.AddListener(HandleReleased);
            ScenarioManager.Instance.OnScenarioStarted += HandleScenarioStarted;
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
            tween?.Kill();
            Grabbed.RemoveListener(HandleGrabbed);
            Released.RemoveListener(HandleReleased);
            ScenarioManager.Instance.OnScenarioStarted -= HandleScenarioStarted;
        }

        private void HandleScenarioStarted(ScenarioManager scrMgr, ScenarioDataType scrDataType)
        {
            LdxTrackingManager.Instance.OnObjectiveEvent += HandleObjectiveEvent;
        }

        private void HandleObjectiveEvent(IObjective objective, ObjectiveEventData objectiveEventData)
        {

            switch (objectiveEventData)
            {
                case ApplyHolsterOffsetEventData applyHolsterOffsetEventData:
                    ProcessApplyHolsterOffsetEventData(applyHolsterOffsetEventData);
                    break;
                case SetHolsterVisibleEventData setHolsterVisibleEventData:
                    ProcessSetHolsterVisibleEventData(setHolsterVisibleEventData);
                    break;
            }
        }

        public void Initialize(HVRGrabbable initialGrabbable, List<MeshRenderer> renderers)
        {
            initialItem = initialGrabbable;
            meshRenderers = renderers;
        }

        public void SetHolsterAndItemVisible(bool visible)
        {
            if (!visible)
            {
                if (initialItem != null && initialItem.IsHandGrabbed)
                {
                    initialItem.ForceRelease();
                }
            }
            foreach (MeshRenderer r in meshRenderers)
            {
                r.enabled = visible;
            }
            CanRemoveGrabbable = visible;
        }
        
        private void ProcessApplyHolsterOffsetEventData(ApplyHolsterOffsetEventData eventData)
        {
            Vector3 offset = eventData.Offset;
            movesToOffset = true;
            applyToTargetedIds = true;
            targetSocketableIDsSet = new(eventData.SocketableIDs);
            startLocalPosition = transform.localPosition;
            offsetLocalPosition = startLocalPosition + offset;
            returnSocketOnRelease = eventData.ReturnSocketOnRelease;

            if (eventData.ClearsOnObjectiveEnd)
            {
                LdxTrackingManager.OnAnyObjectiveComplete += handleObjectiveComplete;
            }
            
            applyAnimationIfSocketedObjectIsValid();
            
            void handleObjectiveComplete(IObjective objective)
            {
                LdxTrackingManager.OnAnyObjectiveComplete -= handleObjectiveComplete;
                movesToOffset = false;
                applyToTargetedIds = false;
                targetSocketableIDsSet.Clear();
                AnimateToPositionAsync(startLocalPosition).Forget();
            }
            
            void applyAnimationIfSocketedObjectIsValid()
            {
                if (GrabbedTarget == null)
                {
                    return;
                }

                if (!IsSocketedObjectValid(GrabbedTarget))
                {
                    return;
                }
                AnimateToPositionAsync(offsetLocalPosition).Forget();
            }
        }

        private void ProcessSetHolsterVisibleEventData(SetHolsterVisibleEventData eventData)
        {
            if (GrabbedTarget == null || !GrabbedTarget.TryGetComponent(out IDSocketable idSocketable))
            {
                return;
            }

            if (!eventData.SocketableIDs.Contains(idSocketable.ID))
            {
                return;
            }
            
            SetHolsterAndItemVisible(eventData.Visible);
        }

        private bool IsSocketedObjectValid(HVRGrabbable grabbable)
        {
            IDSocketable idSocketable = grabbable.GetComponent<IDSocketable>();
            if (idSocketable == null)
            {
                return false;
            }
            if (!targetSocketableIDsSet.Contains(idSocketable.ID))
            {
                return false;
            }

            return true;
        }
        
        private void HandleGrabbed(HVRGrabberBase grabberBase, HVRGrabbable grabbable)
        {
            if(!movesToOffset || !returnSocketOnRelease)
                return;

            if (applyToTargetedIds && !IsSocketedObjectValid(grabbable))
            {
                return;
            }
            AnimateToPositionAsync(offsetLocalPosition).Forget();
        }

        private void HandleReleased(HVRGrabberBase grabberBase, HVRGrabbable grabbable)
        {
            if (!movesToOffset || !returnSocketOnRelease)
                return;

            AnimateToPositionAsync(startLocalPosition).Forget();
        }

        public void EnabledHolsterOffset(Vector3 offset)
        {
            movesToOffset = true;
            startLocalPosition = transform.localPosition;
            offsetLocalPosition = startLocalPosition + offset;
        }

        private async UniTaskVoid AnimateToPositionAsync(Vector3 position)
        {  
            tween?.Kill();
            tween = transform.DOLocalMove(position, movementDuration).SetEase(movementEase);
            bool previousCanRemoveGrabbable = CanRemoveGrabbable;
            CanRemoveGrabbable = false;
            await tween;
            tween = null;
            CanRemoveGrabbable = true;
        }
    }
}*/
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Misc/PlayerHolster.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Misc/ReturnToTargetPosition.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ab1b3de9edb736c448024965533728a7
# ASMDEF: ldx.framework.runtime.dll
# ---
using Autohand;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Utilities.Misc
{
    /// <summary>
    /// This component will cause a game object to return to a target position depending on the type of action to
    /// trigger the return.
    /// </summary>
    [RequireComponent(typeof(Grabbable))]
    public class ReturnToTargetPosition : MonoBehaviour
    {
        private enum ReturnType
        {
            Released,
            EventTriggered
        }

        private enum ReturnLocation
        {
            StartPosition,
            ReferencedTransform
        }
        
        [Header("Events:")]
        [ShowIf(nameof(currentReturnType), Op.Equals, ReturnType.EventTriggered)]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string returnToTargetPositionEvent;
        [SerializeField] private bool broadcastEventWhenReturned;
        [ShowIf(nameof(broadcastEventWhenReturned), MultiOp.Equals, true)]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string movementCompletedEvent;

        [Header("Settings:")]
        [SerializeField] private ReturnType currentReturnType;
        [SerializeField] private ReturnLocation currentReturnLocation;
        [ShowIf(nameof(currentReturnLocation), Op.Equals, ReturnLocation.ReferencedTransform)]
        [SerializeField] private Transform returnTransform;
        [SerializeField] private float animationTime = 1f;
        [SerializeField] private bool disableAfterReturn;
        [SerializeField] private bool blockReturnMovement;
        public bool BlockReturnMovement
        {
            get => blockReturnMovement;
            set => blockReturnMovement = value;
        }
        [HideInInspector]
        [SerializeField] private Grabbable grabbable;

        private Vector3 startPosition;
        private Quaternion startRotation;
        private Tween movementTween;
        public bool IsMoving { get; private set; }

        private void OnValidate()
        {
            if (grabbable == null)
            {
                grabbable = GetComponent<Grabbable>();
            }
        }

        private void OnEnable()
        {
            OnEnableAsync().Forget();
        }

        private async UniTaskVoid OnEnableAsync()
        {
            await UniTask.WaitUntil(() => LdxTrackingManager.IsValid);
            LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
            grabbable.OnReleaseEvent += HandleReleased;
            startPosition = transform.position;
            startRotation = transform.rotation;
        }

        private void OnDisable()
        {
            movementTween?.Kill();
            grabbable.OnReleaseEvent -= HandleReleased;
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }
        }

        private void HandleReleased(Hand hand, Grabbable _)
        {
            if (currentReturnType == ReturnType.Released && grabbable.HeldCount() < 1)
            {
                MoveToTarget();
            }
        }

        private void HandleTrackingEvent(string eventId)
        {
            if (eventId == returnToTargetPositionEvent && currentReturnType == ReturnType.EventTriggered)
            {
                MoveToTarget();
            }
        }

        /// <summary>
        /// Moves the object to the set position (whether the start position or a set target position) when activated
        /// by one of the return types.
        /// </summary>
        private void MoveToTarget()
        {
            IsMoving = true;
            if (blockReturnMovement)
            {
                return;
            }
            
            Vector3 targetPosition = currentReturnLocation == ReturnLocation.StartPosition
                ? startPosition
                : returnTransform.position;
            Quaternion targetRotation = currentReturnLocation == ReturnLocation.StartPosition
                ? startRotation
                : returnTransform.rotation;
            
            movementTween?.Kill();
            movementTween = DOTween.Sequence()
                .Append(transform.DOMove(targetPosition, animationTime))
                .Join(transform.DORotateQuaternion(targetRotation, animationTime))
                .SetEase(Ease.InOutSine)
                .OnComplete(completeReturn);
            return;

            void completeReturn()
            {
                IsMoving = false;
                if (broadcastEventWhenReturned)
                {
                    BroadcastEvent(movementCompletedEvent);
                }

                if (disableAfterReturn)
                {
                    gameObject.SetActive(false);
                }
            }
        }

        /// <summary>
        /// Change the return type to event triggered from Released from other scripts.
        /// </summary>
        /// <param name="newReturnToTargetEvent">The event ID that should be listened for to trigger the return.</param>
        public void ChangeReturnTypeToEventTriggered(string newReturnToTargetEvent)
        {
            currentReturnType = ReturnType.EventTriggered;
            returnToTargetPositionEvent = newReturnToTargetEvent;
        }

        /// <summary>
        /// If the return trigger is event triggered, changes it to released
        /// </summary>
        public void ChangeReturnTypeToOnReleased()
        {
            currentReturnType = ReturnType.Released;
        }

        /// <summary>
        /// Changes the return location to the transform provided.
        /// </summary>
        /// <param name="newReturnTransform">Transform for the position you want the object to return to</param>
        public void ChangeReturnLocationToTransform(Transform newReturnTransform)
        {
            currentReturnLocation = ReturnLocation.ReferencedTransform;
            returnTransform = newReturnTransform;
        }

        /// <summary>
        /// Changes the location to return to into the object's initial location.
        /// </summary>
        public void ChangeReturnLocationToStart()
        {
            currentReturnLocation = ReturnLocation.StartPosition;
        }

        /// <summary>
        /// Public method to trigger the return to target functionality.
        /// </summary>
        public void TriggerReturnToTarget()
        {
            MoveToTarget();
        }

        private void BroadcastEvent(string eventId)
        {
            LdxTrackingManager.Instance.BroadcastTrackingEvent(eventId);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Misc/ReturnToTargetPosition.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/PathFinding/AStarPathfinding.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1f165d3bc5c94622867571ba36d3499a
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using UnityEngine;

namespace Ldx.Framework.Utilities.PathFinding
{
    /// <summary>
    /// Implementation of A* path finding
    /// Works with GraphNode
    /// </summary>
    public static class AStarPathfinding
    {
        /// <summary>
        /// Takes in a start and goal nodes, and uses A* to find a walkable path between them
        /// </summary>
        /// <param name="start">Start node</param>
        /// <param name="goal">Goal node</param>
        /// <param name="occupiedNodesSet">Optional set of nodes to skip</param>
        /// <returns>A walkable path between start and goal</returns>
        public static List<GraphNode> FindPath(GraphNode start, GraphNode goal,
            HashSet<GraphNode> occupiedNodesSet = null)
        {
            PriorityQueue<GraphNode> unvisitedQueue = new PriorityQueue<GraphNode>();
            // Using this to track parents
            Dictionary<GraphNode, GraphNode> cameFromMap = new Dictionary<GraphNode, GraphNode>();

            // gScore = actual total cost of moving
            Dictionary<GraphNode, float> gScore = new Dictionary<GraphNode, float>();
            // Combines g with h score, lower fScore = more suitable
            Dictionary<GraphNode, float> fScore = new Dictionary<GraphNode, float>();

            unvisitedQueue.Enqueue(start, 0);
            gScore[start] = 0;
            fScore[start] = GetHeuristic(start, goal);

            while (unvisitedQueue.Count > 0)
            {
                GraphNode current = unvisitedQueue.Dequeue();

                // We reached the goal, return the constructed path
                if (current == goal)
                {
                    return ReconstructPath(cameFromMap, current);
                }

                foreach (GraphNode neighbour in current.Neighbours)
                {
                    // Skipping neighbour (because it's occupied)
                    if (occupiedNodesSet != null && occupiedNodesSet.Contains(neighbour))
                    {
                        continue;
                    }
                    float tentativeGScore = gScore[current] + 1;

                    if (gScore.ContainsKey(neighbour) && tentativeGScore >= gScore[neighbour])
                    {
                        continue;
                    }

                    cameFromMap[neighbour] = current;
                    gScore[neighbour] = tentativeGScore;
                    fScore[neighbour] = tentativeGScore + GetHeuristic(neighbour, goal);

                    if (!unvisitedQueue.Contains(neighbour))
                    {
                        unvisitedQueue.Enqueue(neighbour, fScore[neighbour]);
                    }
                }
            }

            return null;
        }

        private static float GetHeuristic(GraphNode a, GraphNode b)
        {
            return Vector3.SqrMagnitude(a.Position - b.Position);
        }
        
        private static List<GraphNode> ReconstructPath(Dictionary<GraphNode, GraphNode> cameFrom, GraphNode current)
        {
            List<GraphNode> path = new List<GraphNode> { current };
            while (cameFrom.ContainsKey(current))
            {
                current = cameFrom[current];
                path.Insert(0, current);
            }

            return path;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/PathFinding/AStarPathfinding.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/PathFinding/GraphNode.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 430549d3c9ff4026a258eb76f4b2f66d
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Ldx.Framework.Utilities.PathFinding
{
    /// <summary>
    /// Represents a node in a graph, connected to neighbours 
    /// </summary>
    public class GraphNode : MonoBehaviour, ISaveSceneListener
    {
        private const float GIZMO_RADIUS = 0.03f;

        [SerializeField] private List<GraphNode> neighbours = new();
        public List<GraphNode> Neighbours => neighbours;
        public Vector3 Position => transform.position;

#if UNITY_EDITOR
        public static float EDITOR_GizmoSizeMultiplier { get; set; } = 1.0f;
        private static float EDITOR_GizmoRadius => GIZMO_RADIUS * EDITOR_GizmoSizeMultiplier;
#endif

        public void OnSceneSaving()
        {
            neighbours = neighbours.Where(n => n != null).ToList();

            foreach (GraphNode node in neighbours)
            {
                if (!node.neighbours.Contains(this))
                {
                    node.neighbours.Add(this);
#if UNITY_EDITOR
                    EditorUtility.SetDirty(node);
#endif
                }
            }
        }

        private void OnDrawGizmos()
        {
#if UNITY_EDITOR
            Gizmos.color = Color.yellow;
            Gizmos.DrawSphere(transform.position, EDITOR_GizmoRadius);
            for (int i = neighbours.Count - 1; i >= 0; i--)
            {
                GraphNode node = neighbours[i];
                if (node == null)
                {
                    neighbours.RemoveAt(i);
                    continue;
                }

                Gizmos.DrawLine(Position, node.Position);
            }
#endif
        }

        private void OnDrawGizmosSelected()
        {
#if UNITY_EDITOR
            Gizmos.color = Color.red;
            Gizmos.DrawSphere(transform.position, EDITOR_GizmoRadius);
#endif
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/PathFinding/GraphNode.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/PriorityQueue.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d297ef3f7fad41caa72e59430dd17a4b
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Ldx.Framework.Utilities
{
    /// <summary>
    /// Priority queue implementation
    /// Ensures elements in the queue are sorted by priority
    /// </summary>
    public class PriorityQueue<T> : IEnumerable<T>
    {
        private List<KeyValuePair<T, float>> elements = new();

        public int Count => elements.Count;

        public void Enqueue(T item, float priority)
        {
            elements.Add(new KeyValuePair<T, float>(item, priority));
            elements.Sort((a, b) => a.Value.CompareTo(b.Value)); // Keep lowest priority first
        }

        public T Dequeue()
        {
            KeyValuePair<T, float> item = elements[0];
            elements.RemoveAt(0);
            return item.Key;
        }

        public bool Contains(T item)
        {
            return elements.Exists(x => x.Key.Equals(item));
        }

        public IEnumerator<T> GetEnumerator()
        {
            return elements.Select(e => e.Key).GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/PriorityQueue.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Range.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e54f6fc8d5314ea9a0913e0812576c48
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Ldx.Framework.Utilities
{
    [Serializable]
    public class Range
    {
        [SerializeField]
        private float min;
        public float Min => min;
        
        [SerializeField] 
        private float max;
        public float Max => max;

        public bool IsInRange(float value)
        {
            return value >= min && value <= max;
        }

        public float GetRandom()
        {
            return Random.Range(min, max);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Range.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Reactive/ReactiveProperty.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7c975e8532294b6b8f70eaabe7d303d6
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;

namespace Ldx.Framework.Utilities.Reactive
{
    /// <summary>
    /// A generic wrapper class for a reactive property, allowing dynamic getter and setter logic.
    /// The property value is retrieved and updated through provided delegates, enabling custom behavior.
    /// </summary>
    public class ReactiveProperty<T>
    {
        public event Action<ReactiveProperty<T>, T> OnValueChanged;
        
        private readonly Func<T> getter;
        private readonly Action<T> setter;

        public T Value
        {
            get => getter();
            set
            {
                if (Equals(value, getter()))
                {
                    return;
                }
                setter(value);
                OnValueChanged?.Invoke(this, value);
            }
        }

        public ReactiveProperty(Func<T> getter, Action<T> setter)
        {
            this.getter = getter ?? throw new ArgumentNullException(nameof(getter));
            this.setter = setter ?? throw new ArgumentNullException(nameof(setter));
        }
        
        public ReactiveProperty(ReactiveProperty<T> copy)
        {
            getter = copy.getter;
            setter = copy.setter;
        }
        
        public static implicit operator T(ReactiveProperty<T> reactiveProperty)
        {
            return reactiveProperty.Value;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Reactive/ReactiveProperty.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/ReferenceBank.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 006fce25c5814f56a1fcd6d2ead33b16
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Reflection;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Hierarchy;
using Ldx.Framework.Utilities.Serializable;
using UnityEngine;
using Application = UnityEngine.Device.Application;
using Object = UnityEngine.Object;

namespace Ldx.Framework.Utilities
{
    [ExecuteInEditMode]
    [SingletonSpawnable(SingletonSpawnOptions.EditModeOnly, requiresScenario: true, allowInLobby: true)]
    public class ReferenceBank : Singleton<ReferenceBank>, ISaveSceneListener
    {
        [Serializable]
        public class BankEntry
        {
            [SerializeField] private string typeName;
            public string TypeName => typeName;

            [SerializeField] private List<MonoBehaviour> references;
            public List<MonoBehaviour> References => references;

            public BankEntry(string typeName, List<MonoBehaviour> references)
            {
                this.typeName = typeName;
                this.references = references;
            }
        }

        [MarkupAttributes.ReadOnly] [SerializeField]
        private List<BankEntry> trackedEntries = new();

        [SerializeField] private SerializableDictionary<GameObject, HierarchyColor> objectToHierarchyColor = new();

        private bool initializedMap;

        private Dictionary<string, List<MonoBehaviour>> typeNameToReferencesMap = new();

        protected override void Awake()
        {
            base.Awake();
            InitMap();
            if (Application.isEditor)
            {
                RefreshHierarchyColorReferences();
            }
        }

        public static List<T> Get<T>() where T : MonoBehaviour
        {
            if (Instance == null)
            {
                Debug.LogError("No bank found!");
                return null;
            }

            if (!Instance.initializedMap)
            {
                Instance.InitMap();
            }

            if (!Instance.typeNameToReferencesMap.TryGetValue(typeof(T).Name, out List<MonoBehaviour> list))
            {
                return null;
            }

            List<T> result = new List<T>();
            foreach (MonoBehaviour m in list)
            {
                result.Add((T)m);
            }

            return result;
        }

        public static T GetFirstOrDefault<T>() where T : MonoBehaviour
        {
            if (Instance == null)
            {
                Debug.LogError("No bank found!");
                return null;
            }

            if (!Instance.initializedMap)
            {
                Instance.InitMap();
            }

            if (!Instance.typeNameToReferencesMap.TryGetValue(typeof(T).Name, out List<MonoBehaviour> list))
            {
                Debug.LogError($"Couldn't find type: {typeof(T).Name}");
                return null;
            }

            if (list.Count == 0)
            {
                Debug.LogError($"No instances of type: {typeof(T).Name}");
                return null;
            }

            return list[0] as T;
        }

        private void InitMap()
        {
            if (initializedMap)
            {
                return;
            }

            typeNameToReferencesMap.Clear();
            foreach (BankEntry entry in trackedEntries)
            {
                typeNameToReferencesMap.Add(entry.TypeName, entry.References);
            }

            initializedMap = true;
        }

        public void RefreshHierarchyColorReferences()
        {
            objectToHierarchyColor.Clear();
            foreach (HierarchyColor hierarchyColor in FindObjectsByType<HierarchyColor>(FindObjectsSortMode.None))
            {
                objectToHierarchyColor.Add(hierarchyColor.gameObject, hierarchyColor);
            }
        }

        public bool ContainsHierarchyColor(HierarchyColor hierarchyColor)
        {
            return objectToHierarchyColor.Contains(hierarchyColor);
        }

        public Color? GetHierarchyColorForObject(GameObject obj, bool fromChild = false)
        {
            if (objectToHierarchyColor.TryGetValue(obj, out HierarchyColor hierarchyColor))
            {
                if (fromChild && !hierarchyColor.ApplyToChildren)
                {
                    return null;
                }

                Color? foundColor = HierarchyColorSettings.GetColorForHierarchyType(hierarchyColor.HierarchyType);
                if (foundColor == null)
                {
                    return hierarchyColor.CustomColor;
                }

                return foundColor.Value;
            }

            Transform root = obj.transform.root;
            if (obj.transform.parent != null && root != null && objectToHierarchyColor.Contains(root.gameObject))
            {
                return GetHierarchyColorForObject(root.gameObject, true);
            }

            return null;
        }

        public void OnSceneSaving()
        {
            RefreshHierarchyColorReferences();
#if UNITY_EDITOR
            trackedEntries.Clear();
            foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                foreach (Type type in assembly.GetTypes())
                {
                    if (!type.IsDefined(typeof(TrackedReferenceAttribute), true))
                    {
                        continue;
                    }

                    List<MonoBehaviour> refs = new();
                    foreach (Object obj in FindObjectsByType(type, FindObjectsInactive.Include, FindObjectsSortMode.None))
                    {
                        if (obj is not MonoBehaviour reference)
                        {
                            continue;
                        }

                        if (reference.gameObject.scene.name != gameObject.scene.name)
                        {
                            continue;
                        }
                        refs.Add(reference);
                    }

                    if (refs.Count == 0)
                    {
                        continue;
                    }
                    trackedEntries.Add(new BankEntry(type.Name, refs));
                }
            }
#endif
        }

#if UNITY_EDITOR
        [UnityEditor.Callbacks.DidReloadScripts]
        private static void DidReloadScripts()
        {
            ReferenceBank referenceBank = FindAnyObjectByType<ReferenceBank>();
            if (referenceBank != null)
            {
                referenceBank.Awake();
            }
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/ReferenceBank.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Routines/Routine.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0ddd0a1123e04da4b2af2571f46a6dab
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using UnityEngine;

namespace Ldx.Framework.Utilities.Routines
{
    /// <summary>
    /// A routine utility that tracks whether a routine is still active or not
    /// </summary>
    public class Routine
    {
        /// <summary>
        /// The halting type of the routine
        /// </summary>
        public enum RoutineHaltType
        {
            Error,
            Disabled,
        }

        /// <summary>
        /// Triggers when the routine finished execution
        /// </summary>
        public event Action<Routine> OnRoutineFinished;

        /// <summary>
        /// Triggers when the routine unexpectedly halts
        /// </summary>
        public event Action<Routine, RoutineHaltType> OnRoutineHalted;

        private readonly IEnumerator routineEnumerator;
        private readonly MonoBehaviour owner;
        private Coroutine coroutine = null;

        /// <summary>
        /// Indicates whether the routine is still running
        /// </summary>
        public bool IsRunning => coroutine != null;

        // Private so we can only start it with the static method
        private Routine(MonoBehaviour owner, IEnumerator routineEnumerator)
        {
            this.owner = owner;
            this.routineEnumerator = routineEnumerator;
        }

        /// <summary>
        /// Creates a new routine object and starts it
        /// </summary>
        /// <param name="owner">The owner of the coroutine</param>
        /// <param name="routineEnumerator">The routine enumerator</param>
        /// <returns>The newly created Routine reference</returns>
        public static Routine StartRoutine(MonoBehaviour owner, IEnumerator routineEnumerator)
        {
            Routine routine = new Routine(owner, routineEnumerator);
            routine.StartInternal();
            return routine;
        }

        /// <summary>
        /// Creates a new routine object and starts it, using the RoutineManager as the owner
        /// </summary>
        /// <param name="routineEnumerator">The routine enumerator</param>
        /// <returns>The newly created Routine reference</returns>
        public static Routine StartRoutine(IEnumerator routineEnumerator)
        {
            return StartRoutine(RoutineManager.Instance, routineEnumerator);
        }

        /// <summary>
        /// Stops the coroutine if it's running
        /// </summary>
        public void StopCoroutine()
        {
            if (coroutine != null)
            {
                owner.StopCoroutine(coroutine);
                coroutine = null;
            }
        }

        private void StopInternal(bool reportFinished = false)
        {
            StopCoroutine();
            if (reportFinished)
            {
                OnRoutineFinished?.Invoke(this);
            }
        }

        private void StartInternal()
        {
            if (coroutine != null)
            {
                return;
            }

            coroutine = owner.StartCoroutine(ProcessRoutineAsync(routineEnumerator));
            RoutineManager.Instance.AddTrackedRoutine(this, owner);
        }

        /// <summary>
        /// Notifies the routine that it was halted, providing the halt type
        /// </summary>
        /// <param name="haltType">The reported halt type</param>
        public void NotifyHalted(RoutineHaltType haltType)
        {
            OnRoutineHalted?.Invoke(this, haltType);
            if (coroutine != null)
            {
                owner.StopCoroutine(coroutine);
                coroutine = null;
            }
        }

        private IEnumerator ProcessRoutineAsync(IEnumerator enumerator)
        {
            while (true)
            {
                try
                {
                    // No next steps, that's when we stop the current routine
                    if (!enumerator.MoveNext())
                    {
                        // This is the root routine? Then stop it and and report that it's finished
                        if (enumerator == routineEnumerator)
                        {
                            StopInternal(true);
                        }

                        break;
                    }
                }
                // Indicate end of coroutine and fire halting due to an error event
                catch (Exception e)
                {
                    UnityEngine.Debug.LogError(e);
                    NotifyHalted(RoutineHaltType.Error);
                    break;
                }

                // Four possibilities here: either Current is null (yield return null in the instructions)
                // It's a YieldInstruction (a Unity instruction like WaitUntil())
                // Or it's a CustomYieldInstruction, which is a custom-specified instruction (like this class)..in all cases, yield return it. 
                if (enumerator.Current == null
                    || enumerator.Current is YieldInstruction
                    || enumerator.Current is CustomYieldInstruction)
                {
                    yield return enumerator.Current;
                    continue;
                }

                // The fourth case is that it's an IEnumerator (yield routine SomeRoutine()),
                // in which case we need to process its instructions within our loop
                yield return ProcessRoutineAsync(enumerator.Current as IEnumerator);
            }
        }

        #region Comparison

        // To ensure routine == null will return true if it's not running
        public static bool operator ==(Routine a, Routine b)
        {
            if (b is null)
            {
                if (a is null)
                {
                    return true;
                }

                return !a.IsRunning;
            }

            if (a is null)
            {
                return !b.IsRunning;
            }

            return a.Equals(b);
        }

        public static bool operator !=(Routine a, Routine b)
        {
            return !(a == b);
        }

        public override bool Equals(object obj)
        {
            if (obj is null)
            {
                return IsRunning;
            }

            return base.Equals(obj);
        }

        public override int GetHashCode()
        {
            int hash = 17;
            hash = hash * 31 + owner.GetHashCode();
            hash = hash * 31 + routineEnumerator.GetHashCode();
            hash = hash * 31 +  RoutineManager.Instance.CreatedRoutineCount;
            return hash;
        }

        #endregion
    }

    public static class RoutineExtensions
    {
        public static Routine StartRoutine(this MonoBehaviour owner, IEnumerator routineEnumerator)
        {
            return Routine.StartRoutine(owner, routineEnumerator);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Routines/Routine.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Routines/RoutineManager.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3c9b568a667949b0931163b159717f18
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Utilities.Routines
{
    /// <summary>
    /// Manages routines created through Routine
    /// </summary>
    [SingletonSpawnable(SingletonSpawnOptions.PlayModeOnly)]
    public class RoutineManager : Singleton<RoutineManager>
    {
        private class RoutineInfo
        {
            public Routine Routine { get; set; }
            public MonoBehaviour Owner { get; set; }
        }

        private List<RoutineInfo> routineInfo = new List<RoutineInfo>();

        public int CreatedRoutineCount { get; private set; }

        /// <summary>
        /// Adds a routine to be tracked
        /// </summary>
        /// <param name="routine">The routine to track</param>
        /// <param name="owner">Its owner</param>
        public void AddTrackedRoutine(Routine routine, MonoBehaviour owner)
        {
            CreatedRoutineCount++;
            if (owner == this)
            {
                return;
            }

            routineInfo.Add(new RoutineInfo() { Routine = routine, Owner = owner });
        }

        private void Update()
        {
            UpdateRoutines();
        }

        private void UpdateRoutines()
        {
            for (int i = routineInfo.Count - 1; i >= 0; i--)
            {
                RoutineInfo info = routineInfo[i];
                if (info.Owner == null || !info.Routine.IsRunning)
                {
                    routineInfo.RemoveAt(i);
                    continue;
                }

                if (!info.Owner.isActiveAndEnabled)
                {
                    info.Routine.NotifyHalted(Routine.RoutineHaltType.Disabled);
                    routineInfo.RemoveAt(i);
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Routines/RoutineManager.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/ScriptableSingleton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: fd1456c6f9054f34af2f74b88d40e959
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.IO;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities
{
    public abstract class ScriptableSingleton : ScriptableObject
    {
    }
    
    public abstract class ScriptableSingleton<T> : ScriptableSingleton where T : ScriptableObject
    {
        private const string FRAMEWORK_RESOURCES_PATH = "Packages/com_ldx_framework/Runtime/Resources";
        
        private static T instance;
        public static T Instance => InternalGetInstance();

        private static T InternalGetInstance(bool createIfNotFound = true)
        {
            if (instance == null)
            {
                string resourcePath = ScriptableObjectUtilities.GetLoadPath<T>();
                instance = Resources.Load<T>(resourcePath);
                
#if UNITY_EDITOR
                if (instance == null && createIfNotFound)
                {
                    bool usesFrameworkLogic = typeof(T).IsDefined(typeof(HasFrameworkDefaultAttribute), false);
                    instance = usesFrameworkLogic ? EDITOR_CreateFromFrameworkMaster(resourcePath) : ScriptableObjectUtilities.CreateInstanceAndFile<T>();
                }
#endif
            }

            return instance;
        }


        public static bool IsValid => InternalGetInstance(createIfNotFound: false) != null;

#if UNITY_EDITOR
        // Called through reflections, try not to change name
        public static void EDITOR_InitializeOnLoad()
        {
            // Basically create the file (if not created) and set the instance
            InternalGetInstance();
        }

        public void EDITOR_SetAssetDirty()
        {
            if (Instance != null)
            {
                EditorUtility.SetDirty(Instance);
            }
        }
        
        /// <summary>
        /// Handles the creation logic for singletons that use the framework/project override system.
        /// </summary>
        private static T EDITOR_CreateFromFrameworkMaster(string resourcePathKey)
        {
            string typeName = typeof(T).Name;
            string frameworkTypeName = $"Framework{typeName}";
            string frameworkMasterPath = $"{FRAMEWORK_RESOURCES_PATH}/{frameworkTypeName}.asset";
            T masterInstance = AssetDatabase.LoadAssetAtPath<T>(frameworkMasterPath);

            // If the framework master asset doesn't exist, create it.
            if (masterInstance == null)
            {
                Debug.LogWarning($"[{typeName}] Framework master not found at '{frameworkMasterPath}'. A new one will be created.");
                EDITOR_EnsureDirectoryExists(FRAMEWORK_RESOURCES_PATH);
                masterInstance = CreateInstance<T>();
                AssetDatabase.CreateAsset(masterInstance, frameworkMasterPath);
                AssetDatabase.SaveAssets();
                Debug.Log($"[{typeName}] Successfully created new framework master asset.");
            }

            // Now that a master is guaranteed to exist, copy it to the project.
            string projectAssetPath = $"Assets/Resources/{resourcePathKey}.asset";
            EDITOR_EnsureDirectoryExists("Assets/Resources");
            AssetDatabase.CopyAsset(frameworkMasterPath, projectAssetPath);
            Debug.Log($"[{typeName}] Copied framework master to create project-local instance at '{projectAssetPath}'.");

            // Finally, load the newly created project-local instance.
            return Resources.Load<T>(resourcePathKey);
        }
        
        /// <summary>
        /// A helper method to ensure a directory path exists, creating it if necessary.
        /// </summary>
        private static void EDITOR_EnsureDirectoryExists(string path)
        {
            if (AssetDatabase.IsValidFolder(path))
            {
                return;
            }

            string[] folders = path.Split('/');
            string currentPath = folders[0];

            for (int i = 1; i < folders.Length; i++)
            {
                string nextPath = Path.Combine(currentPath, folders[i]).Replace("\\", "/");
                if (!AssetDatabase.IsValidFolder(nextPath))
                {
                    AssetDatabase.CreateFolder(currentPath, folders[i]);
                }
                currentPath = nextPath;
            }
            AssetDatabase.Refresh();
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/ScriptableSingleton.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Serializable/ListHashSet.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cc8c51f99c4748af904caeee1e980229
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using Ldx.Framework.Utilities;
using UnityEngine;

namespace Ldx.Framework.Utilities.Serializable
{
    /// <summary>
    /// A serializable data structure that doubles the memory to achieve the performance benefits
    /// of both a list (quick index access) and a hashset (quick item inclusion checks)
    /// </summary>
    [Serializable]
    public class ListHashSet<T> : ISerializationCallbackReceiver, IEnumerable<T>
    {
        [SerializeField]
        private List<T> list = new();
        private HashSet<T> hashset = new();

        public T this[int index]
        {
            get { return list[index]; }
            set
            {
                if (!hashset.Contains(value))
                {
                    hashset.Remove(list[index]);
                    list[index] = value;
                    hashset.Add(value);
                }
            }
        }

        public int Count => list.Count;

        public ListHashSet()
        {
            if (Application.isEditor)
            {
                ISaveSceneListener.OnSceneSavingEvent -= HandleSceneSaving;
                ISaveSceneListener.OnSceneSavingEvent += HandleSceneSaving;
            }
        }

        ~ListHashSet()
        {
            if (Application.isEditor)
            {
                ISaveSceneListener.OnSceneSavingEvent -= HandleSceneSaving;
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public ListHashSet(ListHashSet<T> other)
        {
            list = new(other.list);
            hashset = new(other.hashset);
        }
        
        public bool Add(T item)
        {
            if (hashset.Add(item))
            {
                list.Add(item);
                return true;
            }
            return false;
        }

        public bool Remove(T item)
        {
            if (hashset.Remove(item))
            {
                list.Remove(item);
                return true;
            }
            return false;
        }

        public bool Contains(T item)
        {
            return hashset.Contains(item);
        }

        public void Clear()
        {
            list.Clear();
            hashset.Clear();
        }

        public IEnumerator<T> GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public void OnBeforeSerialize()
        {
        }

        public void OnAfterDeserialize()
        {
            hashset.Clear();
            foreach (T item in list)
            {
                hashset.Add(item);
            }
        }
        
        private void HandleSceneSaving()
        {
            // To keep items unique
            list = new List<T>(hashset);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Serializable/ListHashSet.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Serializable/SerializableDictionary.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3779c04a2b064ad6801b8275fbc7d05e
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Serialization;
using UnityEngine;

namespace Ldx.Framework.Utilities.Serializable
{
    public abstract class SerializableDictionaryBase
    {
        public abstract class Storage {}

        protected class Dictionary<TKey, TValue> : System.Collections.Generic.Dictionary<TKey, TValue>
        {
            public Dictionary() {}
            public Dictionary(IDictionary<TKey, TValue> dict) : base(dict) {}
            public Dictionary(SerializationInfo info, StreamingContext context) : base(info, context) {}
        }
    }

    [Serializable]
    public abstract class SerializableDictionaryBase<TKey, TValue, TValueStorage> : SerializableDictionaryBase, IDictionary<TKey, TValue>, IDictionary, ISerializationCallbackReceiver, IDeserializationCallback, ISerializable
    {
        [SerializeField]
        private TKey[] m_keys;
        [SerializeField]
        private TValueStorage[] m_values;
        
        private Dictionary<TKey, TValue> mDict;

        public SerializableDictionaryBase()
        {
            mDict = new Dictionary<TKey, TValue>();
        }

        public SerializableDictionaryBase(IDictionary<TKey, TValue> dict)
        {	
            mDict = new Dictionary<TKey, TValue>(dict);
        }

        protected abstract void SetValue(TValueStorage[] storage, int i, TValue value);
        protected abstract TValue GetValue(TValueStorage[] storage, int i);

        public void CopyFrom(IDictionary<TKey, TValue> dict)
        {
            mDict.Clear();
            foreach (var kvp in dict)
            {
                mDict[kvp.Key] = kvp.Value;
            }
        }

        public void OnAfterDeserialize()
        {
            if(m_keys != null && m_values != null && m_keys.Length == m_values.Length)
            {
                mDict.Clear();
                int n = m_keys.Length;
                for(int i = 0; i < n; ++i)
                {
                    mDict[m_keys[i]] = GetValue(m_values, i);
                }

                m_keys = null;
                m_values = null;
            }
        }

        public void OnBeforeSerialize()
        {
            int n = mDict.Count;
            m_keys = new TKey[n];
            m_values = new TValueStorage[n];

            int i = 0;
            foreach(var kvp in mDict)
            {
                m_keys[i] = kvp.Key;
                SetValue(m_values, i, kvp.Value);
                ++i;
            }
        }

        #region IDictionary<TKey, TValue>
	
        public ICollection<TKey> Keys {	get { return ((IDictionary<TKey, TValue>)mDict).Keys; } }
        public ICollection<TValue> Values { get { return ((IDictionary<TKey, TValue>)mDict).Values; } }
        public int Count { get { return ((IDictionary<TKey, TValue>)mDict).Count; } }
        public bool IsReadOnly { get { return ((IDictionary<TKey, TValue>)mDict).IsReadOnly; } }

        public TValue this[TKey key]
        {
            get { return ((IDictionary<TKey, TValue>)mDict)[key]; }
            set { ((IDictionary<TKey, TValue>)mDict)[key] = value; }
        }

        public void Add(TKey key, TValue value)
        {
            ((IDictionary<TKey, TValue>)mDict).Add(key, value);
        }

        public bool ContainsKey(TKey key)
        {
            return ((IDictionary<TKey, TValue>)mDict).ContainsKey(key);
        }

        public bool Remove(TKey key)
        {
            return ((IDictionary<TKey, TValue>)mDict).Remove(key);
        }

        public bool TryGetValue(TKey key, out TValue value)
        {
            return ((IDictionary<TKey, TValue>)mDict).TryGetValue(key, out value);
        }

        public void Add(KeyValuePair<TKey, TValue> item)
        {
            ((IDictionary<TKey, TValue>)mDict).Add(item);
        }

        public void Clear()
        {
            ((IDictionary<TKey, TValue>)mDict).Clear();
        }

        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            return ((IDictionary<TKey, TValue>)mDict).Contains(item);
        }

        public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
        {
            ((IDictionary<TKey, TValue>)mDict).CopyTo(array, arrayIndex);
        }

        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            return ((IDictionary<TKey, TValue>)mDict).Remove(item);
        }

        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
        {
            return ((IDictionary<TKey, TValue>)mDict).GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return ((IDictionary<TKey, TValue>)mDict).GetEnumerator();
        }

        #endregion

        #region IDictionary

        public bool IsFixedSize { get { return ((IDictionary)mDict).IsFixedSize; } }
        ICollection IDictionary.Keys { get { return ((IDictionary)mDict).Keys; } }
        ICollection IDictionary.Values { get { return ((IDictionary)mDict).Values; } }
        public bool IsSynchronized { get { return ((IDictionary)mDict).IsSynchronized; } }
        public object SyncRoot { get { return ((IDictionary)mDict).SyncRoot; } }

        public object this[object key]
        {
            get { return ((IDictionary)mDict)[key]; }
            set { ((IDictionary)mDict)[key] = value; }
        }

        public void Add(object key, object value)
        {
            ((IDictionary)mDict).Add(key, value);
        }

        public bool Contains(object key)
        {
            return ((IDictionary)mDict).Contains(key);
        }

        IDictionaryEnumerator IDictionary.GetEnumerator()
        {
            return ((IDictionary)mDict).GetEnumerator();
        }

        public void Remove(object key)
        {
            ((IDictionary)mDict).Remove(key);
        }

        public void CopyTo(Array array, int index)
        {
            ((IDictionary)mDict).CopyTo(array, index);
        }

        #endregion

        #region IDeserializationCallback

        public void OnDeserialization(object sender)
        {
            ((IDeserializationCallback)mDict).OnDeserialization(sender);
        }

        #endregion

        #region ISerializable

        protected SerializableDictionaryBase(SerializationInfo info, StreamingContext context) 
        {
            mDict = new Dictionary<TKey, TValue>(info, context);
        }

        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            ((ISerializable)mDict).GetObjectData(info, context);
        }

        #endregion
    }

    public static class SerializableDictionary
    {
        public class Storage<T> : SerializableDictionaryBase.Storage
        {
            public T data;
        }
    }

    [Serializable]
    public class SerializableDictionary<TKey, TValue> : SerializableDictionaryBase<TKey, TValue, TValue>
    {
        public SerializableDictionary() {}
        public SerializableDictionary(IDictionary<TKey, TValue> dict) : base(dict) {}
        protected SerializableDictionary(SerializationInfo info, StreamingContext context) : base(info, context) {}

        protected override TValue GetValue(TValue[] storage, int i)
        {
            return storage[i];
        }

        protected override void SetValue(TValue[] storage, int i, TValue value)
        {
            storage[i] = value;
        }
    }

    [Serializable]
    public class SerializableDictionary<TKey, TValue, TValueStorage> : SerializableDictionaryBase<TKey, TValue, TValueStorage> where TValueStorage : SerializableDictionary.Storage<TValue>, new()
    {
        public SerializableDictionary() {}
        public SerializableDictionary(IDictionary<TKey, TValue> dict) : base(dict) {}
        protected SerializableDictionary(SerializationInfo info, StreamingContext context) : base(info, context) {}

        protected override TValue GetValue(TValueStorage[] storage, int i)
        {
            return storage[i].data;
        }

        protected override void SetValue(TValueStorage[] storage, int i, TValue value)
        {
            storage[i] = new TValueStorage();
            storage[i].data = value;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Serializable/SerializableDictionary.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Serializable/SerializableHashSet.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 054dd6b7e3904085bcd002e30b90f09c
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Serialization;
using UnityEngine;

namespace Utilities.Serializable
{
	public abstract class SerializableHashSetBase
	{
		public abstract class Storage {}

		protected class HashSet<TValue> : System.Collections.Generic.HashSet<TValue>
		{
			public HashSet() {}
			public HashSet(ISet<TValue> set) : base(set) {}
			public HashSet(SerializationInfo info, StreamingContext context) : base(info, context) {}
		}
	}

	[Serializable]
	public abstract class SerializableHashSet<T> : SerializableHashSetBase, ISet<T>, ISerializationCallbackReceiver, IDeserializationCallback, ISerializable
	{
		[SerializeField]
		private T[] m_keys;

		private HashSet<T> mHashSet;
	
		public SerializableHashSet()
		{
			mHashSet = new HashSet<T>();
		}

		public SerializableHashSet(ISet<T> set)
		{	
			mHashSet = new HashSet<T>(set);
		}

		public void CopyFrom(ISet<T> set)
		{
			mHashSet.Clear();
			foreach (var value in set)
			{
				mHashSet.Add(value);
			}
		}

		public void OnAfterDeserialize()
		{
			if(m_keys != null)
			{
				mHashSet.Clear();
				int n = m_keys.Length;
				for(int i = 0; i < n; ++i)
				{
					mHashSet.Add(m_keys[i]);
				}

				m_keys = null;
			}
		}

		public void OnBeforeSerialize()
		{
			int n = mHashSet.Count;
			m_keys = new T[n];

			int i = 0;
			foreach(var value in mHashSet)
			{
				m_keys[i] = value;
				++i;
			}
		}

		#region ISet<TValue>

		public int Count { get { return ((ISet<T>)mHashSet).Count; }}
		public bool IsReadOnly { get { return  ((ISet<T>)mHashSet).IsReadOnly; } }

		public bool Add(T item)
		{
			return ((ISet<T>)mHashSet).Add(item);
		}

		public void ExceptWith(IEnumerable<T> other)
		{
			((ISet<T>)mHashSet).ExceptWith(other);
		}

		public void IntersectWith(IEnumerable<T> other)
		{
			((ISet<T>)mHashSet).IntersectWith(other);
		}

		public bool IsProperSubsetOf(IEnumerable<T> other)
		{
			return ((ISet<T>)mHashSet).IsProperSubsetOf(other);
		}

		public bool IsProperSupersetOf(IEnumerable<T> other)
		{
			return ((ISet<T>)mHashSet).IsProperSupersetOf(other);
		}

		public bool IsSubsetOf(IEnumerable<T> other)
		{
			return ((ISet<T>)mHashSet).IsSubsetOf(other);
		}

		public bool IsSupersetOf(IEnumerable<T> other)
		{
			return ((ISet<T>)mHashSet).IsSupersetOf(other);
		}

		public bool Overlaps(IEnumerable<T> other)
		{
			return ((ISet<T>)mHashSet).Overlaps(other);
		}

		public bool SetEquals(IEnumerable<T> other)
		{
			return ((ISet<T>)mHashSet).SetEquals(other);
		}

		public void SymmetricExceptWith(IEnumerable<T> other)
		{
			((ISet<T>)mHashSet).SymmetricExceptWith(other);
		}

		public void UnionWith(IEnumerable<T> other)
		{
			((ISet<T>)mHashSet).UnionWith(other);
		}

		void ICollection<T>.Add(T item)
		{
			((ISet<T>)mHashSet).Add(item);
		}

		public void Clear()
		{
			((ISet<T>)mHashSet).Clear();
		}

		public bool Contains(T item)
		{
			return ((ISet<T>)mHashSet).Contains(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			((ISet<T>)mHashSet).CopyTo(array, arrayIndex);
		}

		public bool Remove(T item)
		{
			return ((ISet<T>)mHashSet).Remove(item);
		}

		public IEnumerator<T> GetEnumerator()
		{
			return ((ISet<T>)mHashSet).GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((ISet<T>)mHashSet).GetEnumerator();
		}

		#endregion

		#region IDeserializationCallback

		public void OnDeserialization(object sender)
		{
			((IDeserializationCallback)mHashSet).OnDeserialization(sender);
		}

		#endregion

		#region ISerializable

		protected SerializableHashSet(SerializationInfo info, StreamingContext context) 
		{
			mHashSet = new HashSet<T>(info, context);
		}

		public void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			((ISerializable)mHashSet).GetObjectData(info, context);
		}

		#endregion
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Serializable/SerializableHashSet.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/SerializedObjectUtilities.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 78b2511497434b388f733c2f4195ff22
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;

namespace Ldx.Framework.Utilities
{
    public static class SerializedObjectUtilities
    {
        public static T DeepClone<T>(this T obj)
        {
            using (var ms = new MemoryStream())
            {
                var formatter = new BinaryFormatter();
                formatter.Serialize(ms, obj);
                ms.Position = 0;

                return (T)formatter.Deserialize(ms);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/SerializedObjectUtilities.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Seurat/EnvironmentTransitionController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e7189653656eb6646af5b8429d4b8e3e
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Utilities.Seurat
{
	public class EnvironmentTransitionController : MonoBehaviour, ISaveSceneListener
	{
		[SerializeField] private BoxCollider[] zoneCollider;
		[SerializeField] private List<EnvironmentTransitionZone> zoneList = new List<EnvironmentTransitionZone>();

		private EnvironmentTransitionZone lastZone;
		private EnvironmentTransitionZone currentZone;

		public int ColliderCount => zoneCollider?.Length ?? 0;

		public Vector3 SceneViewLocation { get; set; } // Do not remove, this is used.
		public MeshRenderer SelectedRenderer { get; private set; }
		
		private void Awake()
		{
			EnvironmentTransitionZone.OnAnyZoneColliderZoneEntered += HandleOnAnyZoneColliderZoneEntered;
			Initialize();
		}

		private void Start()
		{
			ScenarioManager.Instance.OnScenarioStarted += HandleSceneSetup;
		}

		private void OnDestroy()
		{
			EnvironmentTransitionZone.OnAnyZoneColliderZoneEntered -= HandleOnAnyZoneColliderZoneEntered;

			if (ScenarioManager.IsValid)
				ScenarioManager.Instance.OnScenarioStarted -= HandleSceneSetup;
		}

		private void HandleSceneSetup(ScenarioManager manager, ScenarioDataType dataType)
		{
			foreach (BoxCollider col in zoneCollider)
			{
				EnvironmentTransitionZone zone = col.GetOrAddComponent<EnvironmentTransitionZone>();
				zoneList.Add(zone);
				PlayerStartPoint startPoint = FindAnyObjectByType<PlayerStartPoint>();
				if (col.bounds.Contains(startPoint != null? startPoint.transform.position : PlayerController.Instance.MainCamera.transform.position))
				{
					zone.SetMeshRendererEnabled(true);
					break;
				}

				zone.SetMeshRendererEnabled(false);
			}

			if (!FailCheck())
				GetClosestZone()?.SetMeshRendererEnabled(true);
		}

		private void Initialize()
		{
			if (ColliderCount < 1)
			{
				Logging.Debug.LogError(
					$"Missing children on Environment Transition Controller object {gameObject.name}. " +
					$"Please ensure that this controller is the parent of all seurat headboxes, with boxcollider" +
					$"children marked as trigger, then try again.");
				return;
			}
		}

		private bool FailCheck()
		{
			foreach (EnvironmentTransitionZone zone in zoneList)
			{
				if (zone.Renderer.enabled)
					return true;
			}

			Logging.Debug.LogError("User is currently starting out of a seurat zone. Rework starting points/zone!");
			return false;
		}

		private EnvironmentTransitionZone GetClosestZone()
		{
			if (zoneList == null || zoneList.Count == 0)
			{
				return null;
			}

			Vector3 cameraPosition = PlayerController.Instance.MainCamera.transform.position;

			return zoneList
				.OrderBy(zone => (zone.transform.position - cameraPosition).sqrMagnitude)
				.FirstOrDefault();
		}

		private void HandleOnAnyZoneColliderZoneEntered(EnvironmentTransitionZone zone)
		{
			SetZone(zone);
		}

		private void SetZone(EnvironmentTransitionZone zone)
		{
			if (currentZone == zone)
			{
				return;
			}

			if (currentZone != null)
			{
				lastZone = currentZone;
			}

			currentZone = zone;

			if (lastZone != null)
			{
				lastZone.SetMeshRendererEnabled(false);
			}

			currentZone.SetMeshRendererEnabled(true);
		}

		public void OnSceneSaving()
		{
			zoneCollider = GetComponentsInChildren<BoxCollider>();
		}

		public void DisableAllRenderers()
		{
			//   #if UNITY_EDITOR
			foreach (BoxCollider col in zoneCollider)
			{
				col.GetComponentInChildren<MeshRenderer>().enabled = false;
			}
			//  #endif
		}

		public void EnableAllRenderers()
		{
			#if UNITY_EDITOR
                    foreach (BoxCollider col in zoneCollider)
                    {
                        col.GetComponentInChildren<MeshRenderer>().enabled = true;
                    }
			#endif
		}

		public void VisualizeCurrentCamera(Vector3 location)
		{
			#if UNITY_EDITOR
                    foreach (BoxCollider col in zoneCollider)
                    {
                        var zone = col.GetComponentInChildren<MeshRenderer>();
                        if (zone != null && col.bounds.Contains(location))
                        {
                            DisableAllRenderers();
                            zone.enabled = true;
                            SelectedRenderer = zone;
                            break;
                        }
                    }
			#endif
		}


		private void OnDrawGizmosSelected()
		{
			if (SelectedRenderer != null)
			{
				Gizmos.color = Color.red;
				Gizmos.DrawSphere(SelectedRenderer.transform.position, 0.25f);
				Gizmos.DrawWireCube(SelectedRenderer.transform.position,
					SelectedRenderer.GetComponentInParent<BoxCollider>().size);
			}
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Seurat/EnvironmentTransitionController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Seurat/EnvironmentTransitionZone.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ccbcd9b211baaf44f8b7b0b6225a604c
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Systems.Player;
using UnityEngine;

namespace Ldx.Framework.Utilities.Seurat
{
    public class EnvironmentTransitionZone : MonoBehaviour
    {
        public static event Action<EnvironmentTransitionZone> OnAnyZoneColliderZoneEntered;

        private MeshRenderer rend;
        public MeshRenderer Renderer => rend == null ? rend = GetComponentInChildren<MeshRenderer>() : rend;
        private GameObject PlayerCamera => PlayerController.Instance.MainCamera.gameObject;

        private void OnTriggerEnter(Collider other)
        {
            if (other.gameObject == PlayerCamera)
                OnAnyZoneColliderZoneEntered?.Invoke(this);
        }

        public void SetMeshRendererEnabled(bool enable)
        {
            Renderer.enabled = enable;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Seurat/EnvironmentTransitionZone.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Seurat/SeuratEnvironment.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6ff30afd12c284d48a473847fd1a66b9
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;
using UnityEngine.Serialization;

namespace Ldx.Framework.Utilities.Seurat
{
    [ExecuteInEditMode]
    [RequireComponent(typeof(Renderer))]
    public class SeuratEnvironment : MonoBehaviour
    {
        [SerializeField]
        private string seuratID = string.Empty;
        public string SeuratID => seuratID;

        [SerializeField]
        private Texture mainTexture;

        [SerializeField]
        private Transform referenceObject;

        [SerializeField][Range(0, 10000)]
        private float cullDistance = 250;

        [FormerlySerializedAs("_ChromaKeyColor")]
        [SerializeField]
        private Color chromaKeyColor = Color.white;

        [FormerlySerializedAs("_HueRange")]
        [SerializeField][Range(0, 1)]
        private float hueRange = 0.1f;

        [FormerlySerializedAs("_SaturationRange")]
        [SerializeField][Range(0, 1)]
        private float saturationRange = 1f;

        [FormerlySerializedAs("_ValueRange")]
        [SerializeField][Range(0, 1)]
        private float valueRange = 1f;

        [FormerlySerializedAs("_Threshold")]
        [SerializeField][Range(0, 1)]
        private float threshold = 1f;

        private Material materialInstance;
        private Shader seuratShader;
        private Renderer lastChildRenderer;

        public void Start()
        {
            seuratShader = Shader.Find("GoogleVR/Seurat/AlphaBlended_SinglePass");

            if (seuratShader == null)
            {
                Debug.LogWarning("SEURAT: Seurat shader wasn't found at path 'GoogleVR/Seurat/AlphaBlended_SinglePass'.");
            }
            
            CreateMaterialInstance();
            UpdateLastChild();
        }

        private void CreateMaterialInstance()
        {
            materialInstance = new Material(seuratShader);
            if (TryGetComponent(out Renderer rend))
            {
                rend.material = materialInstance;
            }
        }

        private void Update()
        {
            ApplyMaterialToLastChild();
            UpdateMaterialSettings();
            UpdateLastChild();
            UpdateMeshRenderer();
        }

        private void UpdateMaterialSettings()
        {
            if (materialInstance && referenceObject)
            {
                materialInstance.SetVector("_ReferencePoint", referenceObject.position);
                materialInstance.SetFloat("_CullDistance", cullDistance);
                materialInstance.SetColor("_ChromaKeyColor", chromaKeyColor);
                materialInstance.SetFloat("_HueRange", hueRange);
                materialInstance.SetFloat("_SaturationRange", saturationRange);
                materialInstance.SetFloat("_ValueRange", valueRange);
                materialInstance.SetFloat("_Threshold", threshold);
            }

            if (mainTexture)
            {
                materialInstance.SetTexture("_MainTex", mainTexture);
            }
        }

        private void UpdateMeshRenderer()
        {
            if (lastChildRenderer == null || lastChildRenderer is not MeshRenderer meshRenderer)
            {
                return;
            }

            meshRenderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;
            meshRenderer.lightProbeUsage = UnityEngine.Rendering.LightProbeUsage.Off;
        }

        public void ApplyMaterialToLastChild()
        {
            if (lastChildRenderer == null)
            {
                return;
            }

            lastChildRenderer.material = materialInstance;
        }

        private void UpdateLastChild()
        {
            lastChildRenderer = FindLastChildRenderer(gameObject);
        }

        private Renderer FindLastChildRenderer(GameObject parent)
        {
            Transform lastTransform = FindLastTransform(parent.transform);

            if (lastTransform != null && lastTransform.TryGetComponent(out Renderer childRenderer))
            {
                return childRenderer;
            }

            Debug.LogWarning(lastTransform == null
                ? "SEURAT: No last child found."
                : "SEURAT: Last child does not have a Renderer component.");

            return null;
        }

        private Transform FindLastTransform(Transform parent)
        {
            if (parent.childCount == 0)
            {
                return parent;
            }

            Transform lastChildObject = parent.GetChild(parent.childCount - 1);
            return FindLastTransform(lastChildObject);
        }

        public void SetReferenceObject(Transform reference, Texture texture)
        {
            mainTexture = texture;
            referenceObject = reference;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Seurat/SeuratEnvironment.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Singleton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2836398d2b124c51b0ceeb3446c02006
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Reflection;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Ldx.Framework.Utilities
{
    /// <summary>
    /// A base class for implementing the singleton pattern
    /// Inherit from this if you want your MonoBehaviour to be a Singleton
    /// </summary>
    /// <typeparam name="T">The type of the Singleton instance (your child class)</typeparam>
    public abstract class Singleton<T> : MonoBehaviour where T : MonoBehaviour
    {
        private static T instance;
        
        /// <summary>
        /// Instance getter of the singleton
        /// </summary>
        public static T Instance
        {
            get
            {
                if (instance == null)
                {
                    instance = FindAnyObjectByType<T>();
                    if (instance == null)
                    {
                        var spawnable = typeof(T).GetCustomAttribute<SingletonSpawnableAttribute>();
                        if (spawnable == null)
                        {
                            return null;
                        }
                        SingletonSpawnOptions option = spawnable.SingletonSpawnOption;
                        if(option == SingletonSpawnOptions.EditModeOnly)
                        {
                            if (!Application.isEditor || Application.isPlaying)
                            {
                                return null;
                            }

                            if (SceneManager.GetActiveScene().name.ToLower().Contains("bootstrap"))
                            {
                                return null;
                            }
                        }
                        if(option == SingletonSpawnOptions.PlayModeOnly && !Application.isPlaying)
                        {
                            return null;
                        }
                        
                        instance = SpawnSingleton(spawnable.RequiresScenario, spawnable.AllowInLobby);
                    }
                }

                return instance;
            }
        }
        
        public static bool IsValid => instance != null;

        private static T SpawnSingleton(bool requiresScenario, bool allowInLobby)
        {
            if (allowInLobby)
            {
                if (SceneUtilities.TryGetLoadedLobbySceneName(out string lobbySceneName))
                {
                    Scene prevScene = SceneManager.GetActiveScene();
                    SceneManager.SetActiveScene(SceneManager.GetSceneByName(lobbySceneName));
                    T ins = new GameObject(typeof(T).Name.Replace("Ldx", "")).AddComponent<T>();
                    SceneManager.SetActiveScene(prevScene);
                    return ins;
                }
            }
            // Doesn't require scenario scene
            if (!requiresScenario)
            {
                return new GameObject(typeof(T).Name.Replace("Ldx", "")).AddComponent<T>();
            }
            if(!SceneUtilities.TryGetLoadedScenarioSceneName(out string scenarioSceneName, out bool isStandIn))
            {
                return null;
            }
            Scene prevActiveScene = SceneManager.GetActiveScene();
            SceneManager.SetActiveScene(SceneManager.GetSceneByName(scenarioSceneName));
            T spawnedInstance = new GameObject(typeof(T).Name.Replace("Ldx", "")).AddComponent<T>();
            SceneManager.SetActiveScene(prevActiveScene);
            return spawnedInstance;
        }

        
        /// <summary>
        /// Base of Unity's Awake() method
        /// Children should have base.Awake() if overriding 
        /// </summary>
        protected virtual void Awake()
        {
            // If 'instance' already exists and it isn't this instance, destroy the object
            if (instance != null && instance != this)
            {
                Logging.Debug.LogError($"We have detected two {name} singletons: \n" +
                                       $"{name}:{gameObject.scene.name} and \n {instance.gameObject.name}: {instance.gameObject.scene.name}. \n" + 
                                       $"Destroying {name}, but please review scene flow and get rid of any duplicates, as this will" +
                                       $"prevent null reference errors.");
                Destroy(gameObject);
            }
            
            instance = this as T;
            Init();
            InitReferences();
        }

        /// <summary>
        /// Initialization for this Singleton
        /// </summary>
        protected virtual void Init() { }

        /// <summary>
        /// Initialization for this Singleton's references
        /// </summary>
        protected virtual void InitReferences() { }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Singleton.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/SyncTransformWithTarget.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9db5c20995c549648cfdc205a4b7de20
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities
{
    public class SyncTransformWithTarget : MonoBehaviour
    {
        [SerializeField] 
        private Transform target;
        public Transform Target => target;
        
        [SerializeField] 
        private bool syncPosition = true;
        [SerializeField] 
        private bool syncRotation = true;

        private void Update()
        {
            if (target == null)
            {
               return;
            }
            
            if (syncPosition)
            {
                transform.position = target.position;
            }

            if (syncRotation)
            {
                transform.rotation = target.rotation;
            }
        }

        public void SetTarget(Transform target)
        {
            this.target = target;
        }

        public void Configure(bool syncPosition = true, bool syncRotation = true)
        {
            this.syncPosition = syncPosition;
            this.syncRotation = syncRotation;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/SyncTransformWithTarget.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/AlwaysFaceCamera.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ffcba21c180445a4aa352341d9867060
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
	public class AlwaysFaceCamera : MonoBehaviour
	{
		[SerializeField] private bool useLookAt = true;

		[Tooltip("Optional target to look at. If not set, will default to the main camera.")]
		[SerializeField] private Transform lookAt;

		[Tooltip("Axes to apply rotation on.")]
		[SerializeField] private AxisWithFlags rotationAxes = AxisWithFlags.X | AxisWithFlags.Y | AxisWithFlags.Z;

		[Tooltip("Optional rotation offset (in degrees). This will help adjust for any 90-degree offset issues.")]
		[SerializeField] private Vector3 rotationOffset = Vector3.zero;

		private Transform camTransform;
		private Camera cam;
		private Transform targetTransform;
		private bool initialized;

		private void OnEnable()
		{
			if (ScenarioManager.IsValid && PlayerController.IsValid)
			{
				HandleScenarioStarted(ScenarioManager.Instance, ScenarioDataType.Scenario);
				return;
			}
			
			ScenarioManager.Instance.OnScenarioStarted += HandleScenarioStarted;
		}

		private void OnDisable()
		{
			if (!initialized)
				return;

			if (ScenarioManager.IsValid)
			{
				ScenarioManager.Instance.OnScenarioStarted -= HandleScenarioStarted;
			}
		}

		private void HandleScenarioStarted(ScenarioManager manager, ScenarioDataType dataType)
		{
			cam = PlayerController.Instance.MainCamera;
			camTransform = cam.transform;
			targetTransform = useLookAt && lookAt ? lookAt : camTransform;
			initialized = true;
		}

		private void LateUpdate()
		{
			SetLookRotation();
		}

		private void SetLookRotation()
		{
			if (!initialized)
				return;
			
			Quaternion targetRotation = useLookAt ? GetLookAtRotation() : targetTransform.rotation;

			targetRotation *= Quaternion.Euler(rotationOffset);
			ApplyRotationWithConstraints(targetRotation);
		}

		private Quaternion GetLookAtRotation()
		{
			Vector3 direction = targetTransform.position - transform.position;
			return Quaternion.LookRotation(direction);
		}

		private void ApplyRotationWithConstraints(Quaternion targetRotation)
		{
			Vector3 eulerAngles = targetRotation.eulerAngles;
			Vector3 currentEulerAngles = transform.eulerAngles;

			if (!rotationAxes.HasFlag(AxisWithFlags.X))
				eulerAngles.x = currentEulerAngles.x;

			if (!rotationAxes.HasFlag(AxisWithFlags.Y))
				eulerAngles.y = currentEulerAngles.y;

			if (!rotationAxes.HasFlag(AxisWithFlags.Z))
				eulerAngles.z = currentEulerAngles.z;

			transform.rotation = Quaternion.Euler(eulerAngles);
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/AlwaysFaceCamera.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/AudioRuntimeEditorDebug.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3a065b88e69898c41be71023046544a0
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections;
using System.Collections.Generic;
using System.Text;
using Ldx.Framework.Systems.AudioSystem;
using TMPro;
using UnityEngine;

namespace Ldx.Framework.Systems.Tools
{
    /// <summary>
    /// Shows useful runtime information for audio performance debugging & optimization:
    /// audio source pools, loaded sounds, instance counts etc.
    /// </summary>
    public class AudioRuntimeEditorDebug : MonoBehaviour
    {
#if UNITY_EDITOR
        [SerializeField] private TextMeshProUGUI debugText;
        
        private AudioRuntimeManager audioRuntimeManager;
        private bool allowUpdate;
        private readonly StringBuilder sb = new StringBuilder();

        private IEnumerator Start()
        {
            while (!AudioRuntimeManager.IsValid)
            {
                yield return null;
            }
            audioRuntimeManager = AudioRuntimeManager.Instance;
            allowUpdate = true;
        }

        private void Update()
        {
            if (!allowUpdate)
            {
                return;
            }
            
            sb.Clear();
            
            // Show title
            sb.AppendLine("<color=yellow>Audio Runtime Manager Debug</color>");
            sb.AppendLine();

            // Show pool size
            sb.AppendLine($"<color=yellow>AudioSource Pool Size:</color> {audioRuntimeManager.EDITOR_GetAudioSourcePool().Count}");
            sb.AppendLine();
            
            // Show loaded sounds count
            sb.AppendLine($"<color=yellow>Loaded Sounds Count:</color> {audioRuntimeManager.EDITOR_GetLoadedSounds().Count}");
            sb.AppendLine();

            // Show instance counts
            sb.AppendLine("<color=yellow>Instance Counts:</color>");
            Dictionary<string, int> instanceCounter = audioRuntimeManager.EDITOR_GetInstanceCounter();
            foreach (string path in instanceCounter.Keys)
            {
                sb.AppendLine($"{path}: {instanceCounter[path]}");
            }

            debugText.text = sb.ToString();
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/AudioRuntimeEditorDebug.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/ConstrainMotion.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f56d176e07ae4abe9462ac7cb7acd082
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    public class ConstrainMotion : MonoBehaviour
    {
        /// <summary>
        /// Defines what motions are to be frozen
        /// </summary>
        [System.Flags]
        public enum MotionConstraints
        {
            /// <summary>
            /// No constraints.
            /// </summary>
            None = 0,
            /// <summary>
            /// Freeze motion along the X-axis.
            /// </summary>
            FreezePositionX = 1 << 0,
            /// <summary>
            /// Freeze motion along the Y-axis.
            /// </summary>
            FreezePositionY = 1 << 1,
            /// <summary>
            /// Freeze motion along the Z-axis.
            /// </summary>
            FreezePositionZ = 1 << 2,
            /// <summary>
            /// Freeze rotation along the X-axis.
            /// </summary>
            FreezeRotationX = 1 << 3,
            /// <summary>
            /// Freeze rotation along the Y-axis.
            /// </summary>
            FreezeRotationY = 1 << 4,
            /// <summary>
            /// Freeze rotation along the Z-axis.
            /// </summary>
            FreezeRotationZ = 1 << 5,
        }

        [SerializeField] private MotionConstraints motionConstraints = MotionConstraints.None;
        [SerializeField] private bool useLocalSystem = true;
        
        private Vector3 initialPosition;
        private Vector3 initialRotation;
        private Rigidbody rb;
        
        private void Start()
        {
            rb = GetComponent<Rigidbody>();
            
            initialPosition = useLocalSystem ? transform.localPosition : transform.position;
            initialRotation = useLocalSystem ? transform.localEulerAngles : transform.eulerAngles;
        }

        private void Update()
        {
            ApplyConstraints();
        }

        private void ApplyConstraints()
        {
            Vector3 constrainedPosition;
            Vector3 constrainedRotation;

            if (rb != null)
            {
                constrainedPosition = useLocalSystem ? rb.transform.localPosition : rb.position;
                constrainedRotation = useLocalSystem ? rb.transform.localEulerAngles : rb.rotation.eulerAngles;
            }
            else
            {
                constrainedPosition = useLocalSystem ? transform.localPosition : transform.position;
                constrainedRotation = useLocalSystem ? transform.localEulerAngles : transform.eulerAngles;
            }
        
            if ((motionConstraints & MotionConstraints.FreezePositionX) == MotionConstraints.FreezePositionX)
                constrainedPosition.x = initialPosition.x;
            if ((motionConstraints & MotionConstraints.FreezePositionY) == MotionConstraints.FreezePositionY)
                constrainedPosition.y = initialPosition.y;
            if ((motionConstraints & MotionConstraints.FreezePositionZ) == MotionConstraints.FreezePositionZ)
                constrainedPosition.z = initialPosition.z;
        
            if ((motionConstraints & MotionConstraints.FreezeRotationX) == MotionConstraints.FreezeRotationX)
                constrainedRotation.x = initialRotation.x;
            if ((motionConstraints & MotionConstraints.FreezeRotationY) == MotionConstraints.FreezeRotationY)
                constrainedRotation.y = initialRotation.y;
            if ((motionConstraints & MotionConstraints.FreezeRotationZ) == MotionConstraints.FreezeRotationZ)
                constrainedRotation.z = initialRotation.z;
        
            if (rb != null)
            {
                if (useLocalSystem)
                {
                    rb.transform.localPosition = constrainedPosition;
                    rb.transform.localEulerAngles = constrainedRotation;
                }
                else
                {
                    rb.MovePosition(constrainedPosition);
                    rb.MoveRotation(Quaternion.Euler(constrainedRotation));
                }
            }
            else
            {
                if (useLocalSystem)
                {
                    transform.localPosition = constrainedPosition;
                    transform.localEulerAngles = constrainedRotation;
                }
                else
                {
                    transform.position = constrainedPosition;
                    transform.eulerAngles = constrainedRotation;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/ConstrainMotion.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/DestroyAfter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6d5ff307f7a8b0d44b2256d1866fe486
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
	public class DestroyAfter : MonoBehaviour
	{
		public event Action<DestroyAfter> OnDestroyed; 
		public float destroyAfter = 2f;

		private void Start()
		{
			Destroy(gameObject, destroyAfter);
		}

		private void OnDestroy()
		{
			OnDestroyed?.Invoke(this);
		}

		public static void DestroyObjectAfterTime(GameObject gameObject, float time)
		{
			var destroy = gameObject.AddComponent<DestroyAfter>();
			destroy.destroyAfter = time;
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/DestroyAfter.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/DestroyObjectOnUnloading.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c4dd48c9c17b4471aebb2fa46b22176b
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.ScenarioManagement;
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    /// <summary>
    /// Destroys object at the end of the scenario
    /// </summary>
    public class DestroyObjectOnUnloading : MonoBehaviour
    {
        private void Awake()
        {
            if (ScenarioManager.Instance != null)
            {
                ScenarioManager.Instance.OnUnloadingScenarioOrLobby += HandleUnloadingScenarioOrLobby;
            }
        }

        private void OnDestroy()
        {
            if (ScenarioManager.Instance != null)
            {
                ScenarioManager.Instance.OnUnloadingScenarioOrLobby -= HandleUnloadingScenarioOrLobby;
            }
        }

        private void HandleUnloadingScenarioOrLobby(ScenarioManager manager)
        {
            Destroy(gameObject);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/DestroyObjectOnUnloading.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/DisableScriptsWhenHandSideGrabs.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 95a9458f55484f05b7e33f91930cb1af
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Autohand;
using Ldx.Framework.Systems.Player.Hands;
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    /// <summary>
    /// Disables a list of scripts when a specific hand side grabs a target
    /// Enables them back when released
    /// </summary>
    public class DisableScriptsWhenHandSideGrabs : MonoBehaviour
    {
        [SerializeField] private Grabbable targetGrabbable;
        [SerializeField] private bool bothSides;
        [SerializeField] private HandSide handSide;
        [SerializeField] private bool reenableOnRelease = true;
        [SerializeField] private List<MonoBehaviour> scriptsToDisable = new();

        private HandSide grabbedSide;

        private void Start()
        {
            targetGrabbable.OnGrabEvent += HandleHandGrabbed;
            targetGrabbable.OnReleaseEvent += HandleHandReleased;
        }

        private void OnDestroy()
        {
            targetGrabbable.OnGrabEvent -= HandleHandGrabbed;
            targetGrabbable.OnReleaseEvent -= HandleHandReleased;
        }

        private void HandleHandGrabbed(Hand hand, Grabbable _)
        {
            ProcessHandEvent(hand, false);
        }
        
        private void HandleHandReleased(Hand hand, Grabbable _)
        {
            if (!reenableOnRelease)
            {
                return;
            }
            ProcessHandEvent(hand, true);
        }

        private void ProcessHandEvent(Hand handGrabber, bool shouldEnable)
        {
            HandSide side = handGrabber.left ? HandSide.Left : HandSide.Right;
            if (bothSides)
            {
                if (!shouldEnable && side != grabbedSide)
                {
                    return;
                }
            }
            else if(side != handSide)
            {
                return;
            }
            
            grabbedSide = side;
            
            foreach (MonoBehaviour script in scriptsToDisable)
            {
                if (script == null)
                {
                    continue;
                }
                script.enabled = shouldEnable;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/DisableScriptsWhenHandSideGrabs.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/EventOnCollision.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e971e9b255f748b5ba4318dc46d7a5f9
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    /// <summary>
    /// Detects when a specific target starts or stops physically colliding with this object and fires corresponding events.
    /// This component requires a Collider on the same GameObject with its "Is Trigger" property set to false.
    /// For collision events to be detected, at least one of the two colliding objects must have a Rigidbody component.
    /// The target can be defined by player identity, a tag, a specific collider reference, or a custom TransformID.
    /// It can broadcast tracking events via the LdxTrackingManager and invoke C# events for other components to subscribe to.
    /// </summary>
    public class EventOnCollision : PhysicsTargetDetectorBase
    {
        /// <summary>
        /// Fired when the specified target starts colliding with this object.
        /// </summary>
        /// <param name="eventOnCollision">The EventOnCollision instance that fired the event.</param>
        /// <param name="collision">The Collision data object containing detailed information about the collision.</param>
        public event Action<EventOnCollision, Collision> OnTargetCollisionEnter; 
        
        /// <summary>
        /// Fired when the specified target stops colliding with this object.
        /// </summary>
        /// <param name="eventOnCollision">The EventOnCollision instance that fired the event.</param>
        /// <param name="collision">The Collision data object containing detailed information about the collision.</param>
        public event Action<EventOnCollision, Collision> OnTargetCollisionExit; 

        private void OnCollisionEnter(Collision collision)
        {
            if (ShouldReturnOnEnter || !IsTarget(collision.collider)) return;
            
            ProcessTargetEntered();
            OnTargetCollisionEnter?.Invoke(this, collision);
        }

        private void OnCollisionExit(Collision collision)
        {
            if (ShouldReturnOnExit || !IsTarget(collision.collider)) return;
            
            ProcessTargetExited();
            OnTargetCollisionExit?.Invoke(this, collision);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/EventOnCollision.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/EventOnTrigger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b4e84fd98e317de43bc2b91b4874d60d
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    /// <summary>
    /// Detects when a specific target enters or exits this object's trigger volume and fires corresponding events.
    /// This component requires a Collider on the same GameObject with its "Is Trigger" property set to true.
    /// The target can be defined by player identity, a tag, a specific collider reference, or a custom TransformID.
    /// It can broadcast tracking events via the LdxTrackingManager and invoke C# events for other components to subscribe to.
    /// </summary>
    public class EventOnTrigger : PhysicsTargetDetectorBase
    {
        /// <summary>
        /// Fired when the specified target enters the trigger.
        /// </summary>
        /// <param name="eventOnTrigger">The EventOnTrigger instance that fired the event.</param>
        /// <param name="other">The Collider of the object that entered the trigger.</param>
        public event Action<EventOnTrigger, Collider> OnTargetTriggerEnter; 
        
        /// <summary>
        /// Fired when the specified target exits the trigger.
        /// </summary>
        /// <param name="eventOnTrigger">The EventOnTrigger instance that fired the event.</param>
        /// <param name="other">The Collider of the object that exited the trigger.</param>
        public event Action<EventOnTrigger, Collider> OnTargetTriggerExit; 
        
        private void OnTriggerEnter(Collider other)
        {
            if (ShouldReturnOnEnter || !IsTarget(other))
                return;

            ProcessTargetEntered();
            OnTargetTriggerEnter?.Invoke(this, other);
        }

        private void OnTriggerExit(Collider other)
        {
            if (ShouldReturnOnExit  || !IsTarget(other))
                return;

            ProcessTargetExited();
            OnTargetTriggerExit?.Invoke(this, other);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/EventOnTrigger.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/IgnoreCollision.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 79b0c3ab2ede88d4b9fb1fa8ab6be48d
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    public class IgnoreCollision : MonoBehaviour
    {
        public Collider m_collider;
        public Collider colliderToIgnore;
        public bool ignoreOnStart = false;

        public void Start()
        {
            if (ignoreOnStart)
            {
                SetIgnoreCollision(true);
            }
        }

        public void SetIgnoreCollision(bool state)
        {
            Physics.IgnoreCollision(m_collider, colliderToIgnore, state);
        }

    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/IgnoreCollision.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LayerSwap.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1f86283f39d45584daba4f459613c0e5
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

// a very simple modular component to swap layers.
namespace Ldx.Framework.Utilities.Tools
{
    public class LayerSwap : MonoBehaviour
    {
        [SerializeField] private GameObject target;

        public void SwapLayer(string newLayer)
        {
            target.layer = LayerMask.NameToLayer(newLayer);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LayerSwap.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxAddPersistentVelocity.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9e8ae9da45f88f2499daffbe5b096011
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    public class LdxAddPersistentVelocity : MonoBehaviour
    {
        [SerializeField] private Rigidbody rb;
        [Tooltip("If the object should not move immediately, keep false")]
        private bool canMove = false;


        [SerializeField] private float maxSpeed = 200f;
        [SerializeField] private float accel = 100f;
        [SerializeField] private float minDistanceToStop = 0.1f;
        [SerializeField] private Transform whereToStop;
        [Space(1)]
        [SerializeField] private bool debug;

        private void Start()
        {
            InvokeRepeating(nameof(IsFarEnoughToMove), 2, 2);
        }

        void FixedUpdate()
        {
            if (rb.isKinematic || !canMove)
                return;

            if (rb.linearVelocity.magnitude <= maxSpeed)
                rb.AddRelativeForce(Vector3.left * accel);
        }

        private void IsFarEnoughToMove()
        {
            if (Vector3.Distance(rb.transform.position, whereToStop.transform.position) > minDistanceToStop)
            {
                if (debug)
                    UnityEngine.Debug.Log($"Distance is {Vector3.Distance(rb.transform.position, whereToStop.transform.position)}");

                canMove = true;
                return;
            }

            if (debug)
                UnityEngine.Debug.Log($"Not far enough to move, will not add force to {gameObject.name}");

            canMove = false;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxAddPersistentVelocity.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxAdjustHeightToObject.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4470117661be4123ab77d2e3da1c651b
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    public class LdxAdjustHeightToObject : MonoBehaviour
    {
        [Serializable]
        public enum AdjustmentType
        {
            ToCamera = 0,
            ToTransform
        }

        [SerializeField]
        private AdjustmentType adjustmentType;

        [ShowIf("adjustmentType", Op.Equals, AdjustmentType.ToTransform)]
        [SerializeField]
        private Transform targetTransform;

        private Camera mainCamera;

        private void Awake()
        {
            mainCamera = Camera.main;
        }

        private void Update()
        {
            AdjustHeight();
        }

        private void AdjustHeight()
        {
            switch (adjustmentType)
            {
                case AdjustmentType.ToCamera:
                    transform.position = transform.position.Modify(y: mainCamera.transform.position.y);
                    break;
                case AdjustmentType.ToTransform:
                    transform.position = transform.position.Modify(y: targetTransform.transform.position.y);
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxAdjustHeightToObject.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxAlwaysFaceCamera.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b003c715bea445c98c8695b2fbc0ebbc
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.Player;
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    public class LdxAlwaysFaceCamera : MonoBehaviour
    {
        private Transform cameraTransform;

        private Transform CameraTransform
        {
            get
            {
                if (cameraTransform == null && PlayerController.Instance != null)
                {
                    cameraTransform = PlayerController.Instance.MainCamera.transform;
                }
                return cameraTransform;
            }
        }

        private void Update()
        {
            if (CameraTransform == null)
            {
                return;
            }
            transform.LookAt(CameraTransform);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxAlwaysFaceCamera.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxAnimate.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ae7143bc8e2cb5840b3a19218904e63e
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    public class LdxAnimate : MonoBehaviour
    {

        #region Fields and Properties

        [SerializeField] private Animator animator;

        #endregion

        #region Custom Methods

        /// <summary>
        /// These are overly simplified (one parameter) methods so that they can be accessed via editor
        /// </summary>
        public void FlipBool(string boolName)
        {
            animator.SetBool(boolName, !animator.GetBool(boolName));
        }

        public void SetTrigger(string triggerName)
        {
            animator.SetTrigger(triggerName);
        }

        #endregion


    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxAnimate.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxCollisionGroupInvisibleInGame.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 31cd21738f6f42f7a9f79ecc9d31a9a8
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    public class LdxCollisionGroupInvisibleInGame : MonoBehaviour
    {
        [SerializeField] 
        private Material materialToUseInEditor;

        [SerializeField] 
        private MeshRenderer[] meshRenderers;

        private void OnValidate()
        {
            meshRenderers = GetComponentsInChildren<MeshRenderer>(true);
      
            foreach (var r in meshRenderers)
            {
                if (r.TryGetComponent(out Collider col))
                {
                    r.enabled = col.enabled;
                }
                if (materialToUseInEditor == null)
                {
                    continue;
                }
                r.sharedMaterial = materialToUseInEditor;
            }
        }

        private void Start()
        {
            foreach (var r in meshRenderers)
            {
                r.enabled = false;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxCollisionGroupInvisibleInGame.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxDisableAfterSeconds.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4df1f8531542de9458bc3ea62e31d148
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    public class LdxDisableAfterSeconds : MonoBehaviour
    {
        [SerializeField]
        private float seconds = 1f;

        private void OnEnable()
        {
            Invoke(nameof(DisableThis), seconds);
        }

        private void DisableThis()
        {
            gameObject.SetActive(false);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxDisableAfterSeconds.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxLifecycleUnityEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ae2c7611c236475f89949df5dd83f993
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;
using UnityEngine.Events;

namespace Ldx.Framework.Utilities.Tools
{
    public class LdxLifecycleUnityEvents : MonoBehaviour
    {
        public UnityEvent OnAwakeUE;
        public UnityEvent OnStartUE;
        public UnityEvent OnDestroyUE;
        public UnityEvent OnEnableUE;
        public UnityEvent OnDisableUE;

        private void Awake()
        {
            OnAwakeUE?.Invoke();
        }

        private void Start()
        {
            OnStartUE?.Invoke();
        }

        private void OnDestroy()
        {
            OnDestroyUE?.Invoke();
        }

        private void OnEnable()
        {
            OnEnableUE?.Invoke();
        }

        private void OnDisable()
        {
            OnDisableUE?.Invoke();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxLifecycleUnityEvents.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxMaterialSwap.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: df2c6b7752c625f43bffbdb4fcbbd253
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Serialization;

namespace Ldx.Framework.Utilities.Tools
{
    [RequireComponent(typeof(MeshRenderer))]
    public class LdxMaterialSwap : MonoBehaviour
    {
        [System.Serializable]
        public class MaterialSwapEvent : UnityEvent<LdxMaterialSwap, Material, bool> { }
        
        [SerializeField] private MeshRenderer materialTarget;
        [SerializeField] private int materialIndex = 0;
        [SerializeField] private Material initialMat;
        [SerializeField] private Material newMat;
        [FormerlySerializedAs("OnMaterialSwap")]
        [SerializeField] private MaterialSwapEvent onMaterialSwap;

#if UNITY_EDITOR
        private void OnValidate()
        {
            if (materialTarget == null)
            {
                materialTarget = GetComponent<MeshRenderer>();
            }
        }
#endif

        private void Start()
        {
            initialMat = materialTarget.material;
        }

        public void SetNewMat()
        {
            if (materialTarget.materials.Length > 1)
            {
                Material[] mats = materialTarget.materials;
                mats[materialIndex] = newMat;
                materialTarget.materials = mats;
            }
            else
            {
                materialTarget.material = newMat;
            }

            onMaterialSwap.Invoke(this, newMat, true);
        }

        public void SetOldMat()
        {
            materialTarget.material = initialMat;
            onMaterialSwap.Invoke(this, initialMat, false);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxMaterialSwap.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxMoveTransform.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e6bddb8f5cb4a2744a0eae92aeefbce4
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections;
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
	public class LdxMoveTransform : MonoBehaviour
	{

		#region Fields and Properties

		[SerializeField] private Transform toMove;
		[SerializeField] private Transform newLocation;
		[SerializeField] private float minDistance = 0.1f;
		[SerializeField] private float totalTime;
		private bool isMoving = false;

		#endregion

		#region Unity Methods

		#endregion

		#region Custom Methods

		public void MoveToLocation()
		{
			if (!isMoving)
				StartCoroutine(OnMoveToLocation());
		}

		#endregion

		#region Coroutines

		private IEnumerator OnMoveToLocation()
		{
			float curTime = 0f;
			isMoving = true;
			Vector3 locationCache = newLocation.position;

			while (Vector3.Distance(toMove.position, locationCache) > minDistance)
			{
				Vector3.Lerp(toMove.position, newLocation.position, curTime / totalTime);
				curTime += Time.deltaTime;
				yield return null;
			}

			isMoving = false;
		}

		#endregion

	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxMoveTransform.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxOnDisableEnable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b56c2df748c77ff4499b079448b48dca
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;
using UnityEngine.Events;

namespace Ldx.Framework.Utilities.Tools
{
    public class LdxOnDisableEnable : MonoBehaviour
    {
        public UnityEvent onEnable;
        public UnityEvent onDisable;

        private void OnEnable()
        {
            onEnable.Invoke();
        }
        private void OnDisable()
        {
            onDisable.Invoke();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxOnDisableEnable.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxOnEnableDisable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 26a7149764b3d104c93a0eda33c2e936
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.Events;

namespace Ldx.Framework.Utilities.Tools
{
	public class LdxOnEnableDisable : MonoBehaviour
	{
		public UnityEvent onEnable;
		public UnityEvent onDisable;

		public float Timer = 0;

		public async void OnEnable()
		{
			if (Timer == 0)
				onEnable.Invoke();
			else
			{
				await Task.Delay(Mathf.FloorToInt(Timer * 100f));
				onEnable.Invoke();
			}
		}

		private void CallEvent(UnityEvent _event)
		{
			_event.Invoke();
		}

		public async void OnDisable()
		{
			if (Timer == 0)
				onDisable.Invoke();
			else
			{
				await Task.Delay(Mathf.FloorToInt(Timer * 100f));
				onDisable.Invoke();
			}
		}

	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxOnEnableDisable.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxPlaceBetweenTransforms.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cc38b12cc76d4b50abad8060baa6d3f1
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    public class LdxPlaceBetweenTransforms : MonoBehaviour
    {
        [SerializeField] 
        private List<Transform> transforms = new List<Transform>();

        private void Update()
        {
            Vector3 pos = Vector3.zero;
            foreach (var t in transforms)
            {
                pos += t.position;
            }

            pos /= transforms.Count;
            transform.position = pos;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxPlaceBetweenTransforms.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxRendererEnabler.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6ee3255379e232943b57118d14f9cafa
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    /// <summary>
    /// Includes public methods to enable or disable the
    /// given renderers.
    /// </summary>
    public class LdxRendererEnabler : MonoBehaviour
    {
        [SerializeField] private Renderer[] renderers;

        public void EnableRenderers() => EnableInternal(true);
        public void DisableRenderers() => EnableInternal(false);

        private void EnableInternal(bool enable)
        {
            if (renderers == null)
            {
                return;
            }
        
            foreach (Renderer rdr in renderers)
            {
                if (rdr != null)
                {
                    rdr.enabled = enable;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxRendererEnabler.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxReturnObjectAfterFall.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1e31931bcfdd427bb21153aa0929506e
# ASMDEF: ldx.framework.runtime.dll
# ---
using Autohand;
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    public class LdxReturnObjectAfterFall : MonoBehaviour, ISaveSceneListener
    {
        [SerializeField] private float amountOfYDropToTriggerReturn = 2.0f;
        [SerializeField] private bool dontReturnIfGrabbedOrSocketed = true;
        [SerializeField] private Grabbable grabbable;

        private Vector3 initialPosition;
        
        public void OnSceneSaving()
        {
            if (grabbable == null)
            {
                grabbable = GetComponent<Grabbable>();
            }
        }
        
        private void Awake()
        {
            initialPosition = transform.position;
        }

        public void OverrideInitialPosition(Vector3 pos)
        {
            initialPosition = pos;
        }

        private void Update()
        {
            if (initialPosition.y - transform.position.y > amountOfYDropToTriggerReturn)
            {
                TryReturnObject();
            }
        }

        private void TryReturnObject()
        {
            if (dontReturnIfGrabbedOrSocketed && grabbable != null)
            {
                if (grabbable.IsHeld() || grabbable.placePoint)
                {
                    return;
                }
            }

            transform.position = initialPosition;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxReturnObjectAfterFall.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxScaleOnCollision.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c07eb1cfb84eb6843964c86e891116e0
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    public class LdxScaleOnCollision : MonoBehaviour
    {
        [SerializeField] private Transform transformToScale;
        [SerializeField] private Vector3 endScale;
        [SerializeField] private float lerpSpeed = 2f;
        [SerializeField] private LayerMask collisionLayerMask;
        [SerializeField] private Vector3 normal;
        [SerializeField] private Vector3 transformUpDirection;

        private float deltaTime = -1;
        private GameObject collidedObject = null;

        private Vector3 startScale, lerpStartScale, lerpEndScale;

        private void Awake()
        {
            startScale = transformToScale.localScale;
        }

        private void Update()
        {
            if (deltaTime == -1) return;

            deltaTime += Time.deltaTime * lerpSpeed;

            if (deltaTime > 1)
            {
                deltaTime = -1;
                transformToScale.localScale = lerpEndScale;
                return;
            }

            transformToScale.localScale = Vector3.Lerp(lerpStartScale, lerpEndScale, deltaTime);
        }

        private void OnCollisionStay(Collision col)
        {
            if (collidedObject != null) return;
            if (collisionLayerMask != (collisionLayerMask | (1 << col.gameObject.layer))) return;

            if (normal != Vector3.zero)
            {
                if (Vector3.Dot(col.contacts[0].normal, normal) <= 0.5)
                {
                    return;
                }
            }

            if (transformUpDirection != Vector3.zero)
            {
                if (Vector3.Dot(transformToScale.up, transformUpDirection) <= 0.5)
                {
                    return;
                }
            }

            collidedObject = col.gameObject;
            deltaTime = 0;
            lerpStartScale = transformToScale.localScale;
            lerpEndScale = endScale;
        }

        private void OnCollisionExit(Collision col)
        {
            if (col.gameObject != collidedObject) return;
            collidedObject = null;
            deltaTime = 0;
            lerpStartScale = transformToScale.localScale;
            lerpEndScale = startScale;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxScaleOnCollision.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxScaleRelativeToDistance.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e141146df0b4a5b4b93fde17cb596544
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    public class LdxScaleRelativeToDistance : MonoBehaviour
    {

        #region Fields and Properties

        [SerializeField]
        float largestScale = 2;
        [SerializeField]
        float smallestScale = 0.5f;

        float scaledDistance;

		[Tooltip("This is the factor that we multiply the distance between you and the object by." +
                 "for example, at 10 meters, multiplied by 0.1, the scale will be set to 1.")]
        public float relativeScale = 0.01f;


        #endregion

        #region Unity Methods

        void LateUpdate()
        {
            scaledDistance = Vector3.Distance(transform.position, Camera.main.transform.position);
            // 1 should be .01, 10 should be .1
            scaledDistance = Mathf.Clamp((scaledDistance * relativeScale), smallestScale, largestScale);
            transform.localScale = new Vector3(scaledDistance, scaledDistance);

        }

        #endregion

    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LdxScaleRelativeToDistance.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LookAtTarget.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2bb89728c71681542b9194689a849d7e
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
namespace Ldx.Framework.Utilities.Tools
{
    public class LookAtTarget : MonoBehaviour
    {
        [SerializeField] private bool lookAtPlayer = false;
        [ShowIf(nameof(lookAtPlayer), MultiOp.Equals ,false)]
        [SerializeField] private Transform transformToPointTowards;
        [SerializeField] private Vector3 offset;

        private void Start()
        {
            if (lookAtPlayer)
                transformToPointTowards = PlayerController.Instance.MainCamera.transform;
        }

        private void Update()
        {
            if (transformToPointTowards == null)
            {
                return;
            }
            
            transform.LookAt(transformToPointTowards.position, Vector3.up);
            transform.eulerAngles = new Vector3(0, transform.eulerAngles.y, 0);
            transform.eulerAngles += offset;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/LookAtTarget.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/OverrideCanvasOrder.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a04bb101eb3cf6743b7035fe32618c2e
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    /// <summary>
    /// a script to override Unity's natural canvas order for dropdown menus that it automatically forces.
    /// </summary>
    public class OverrideCanvasOrder : MonoBehaviour
    {
        [SerializeField]
        private int orderNumber;


        private void OnEnable()
        {
            Canvas canvas = GetComponent<Canvas>();
            if (canvas)
            {
                canvas.sortingOrder = orderNumber;
            }
        }

    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/OverrideCanvasOrder.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/PhysicsTargetDetectorBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 42d46437175744dfb19341b066047f6a
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using FluffyUnderware.DevTools;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    /// <summary>
    /// An abstract base class for components that detect a target via Unity's physics system (triggers or collisions).
    /// It provides the core logic for target identification, event broadcasting, and state management.
    /// Child classes must implement the specific physics callback (e.g., OnTriggerEnter, OnCollisionEnter).
    /// </summary>
    public class PhysicsTargetDetectorBase : MonoBehaviour
    {
        /// <summary>
        /// Fired specifically when the target is the player and they are detected.
        /// </summary>
        public event Action OnPlayerEnter;
        
        protected enum Target
        {
            Player,
            Tag,
            Collider,
            TransformID,
            PlayerHand
        }

        [Tooltip("The type of target to detect.")]
        [SerializeField]
        protected Target target = Target.Player;
        
        [Tooltip("The specific Collider to detect. Only used if Target is 'Collider'.")]
        [SerializeField][ShowIf(nameof(target), Op.Equals, Target.Collider)]
        protected Collider targetCollider;

        [Tooltip("The tag to detect. Only used if Target is 'Tag'.")]
        [SerializeField][ShowIf(nameof(target), Op.Equals, Target.Tag)][Tag]
        protected string targetTag;
        
        [Tooltip("The Transform ID to detect. Used for identifying specific objective-related transforms. Only used if Target is 'TransformID'.")]
        [SerializeField] [ShowIf(nameof(target), Op.Equals, Target.TransformID)]
        [IDSelection(LdxIdSettings.IdType.Transform)]
        protected string targetTransformID;

        [Tooltip("If true, the enter and exit events will only be broadcast once each.")]
        [SerializeField] protected bool broadcastOnce;
        
        [Tooltip("If true, this GameObject will be deactivated after any detection event (enter or exit) occurs.")]
        [SerializeField] protected bool disableAfterDetection;
        
        [Space]
        [Tooltip("The tracking event ID to broadcast via LdxTrackingManager when the target is detected.")]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)] [SerializeField]
        protected string eventOnEnter;

        [Tooltip("The tracking event ID to broadcast via LdxTrackingManager when the target is no longer detected.")]
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)] [SerializeField]
        protected string eventOnExit;
        
        protected bool wasEnterBroadcasted;
        protected bool wasExitBroadcasted;

        /// <summary>
        /// Gets a value indicating whether the specified target is currently detected.
        /// </summary>
        /// <value>True if the target is currently detected; otherwise, false.</value>
        public bool IsTargetDetected { get; protected set; }
        
        protected GameObject PlayerCamera => PlayerController.Instance.MainCamera.gameObject;
        protected GameObject PlayerLeftHand => PlayerController.Instance.HandsController.LeftHand.gameObject;
        protected GameObject PlayerRightHand => PlayerController.Instance.HandsController.RightHand.gameObject;
        protected GameObject BodyCollider => PlayerController.Instance.PlayerBodyCollider.gameObject;
        protected bool ShouldReturnOnEnter => broadcastOnce && wasEnterBroadcasted;
        protected bool ShouldReturnOnExit => broadcastOnce && wasExitBroadcasted;

        /// <summary>
        /// Checks if the provided collider matches the current target settings.
        /// </summary>
        /// <param name="other">The collider to check against the target criteria.</param>
        /// <returns>True if the collider is the specified target; otherwise, false.</returns>
        protected bool IsTarget(Collider other)
        {
            switch (target)
            {
                case Target.Player:
                    return other.gameObject == PlayerCamera || other.gameObject == BodyCollider;
                case Target.Tag:
                    return other.CompareTag(targetTag);
                case Target.Collider:
                    return other == targetCollider;
                case Target.TransformID:
                    return (other.TryGetComponent(out ObjectiveTransform objectiveTransform) ||
                            other.TryGetComponentInParent(out objectiveTransform))
                           && objectiveTransform.TransformPoint == targetTransformID;
                case Target.PlayerHand:
                    return other.gameObject == PlayerLeftHand || other.gameObject == PlayerRightHand;
                default:
                    Debug.LogError($"No target check is implemented for target type {target}", gameObject);
                    return false;
            }
        }

        /// <summary>
        /// Contains the core logic to execute when a target is first detected.
        /// Manages state, broadcasts tracking events, and handles deactivation.
        /// </summary>
        protected void ProcessTargetEntered()
        {
            wasEnterBroadcasted = true;
            IsTargetDetected = true;
            
            BroadcastEvent(eventOnEnter);
            
            if (target == Target.Player)
            {
                OnPlayerEnter?.Invoke();
            }

            if (disableAfterDetection)
            {
                gameObject.SetActive(false);
            }
        }

        /// <summary>
        /// Contains the core logic to execute when a target is no longer detected.
        /// Manages state, broadcasts tracking events, and handles deactivation.
        /// </summary>
        protected void ProcessTargetExited()
        {
            wasExitBroadcasted = true;
            IsTargetDetected = false;
            
            BroadcastEvent(eventOnExit);
            
            if (disableAfterDetection)
            {
                gameObject.SetActive(false);
            }
        }

        private void BroadcastEvent(string eventToBroadcast)
        {
            if (!string.IsNullOrEmpty(eventToBroadcast))
            {
                LdxTrackingManager.Instance.BroadcastTrackingEvent(eventToBroadcast);
            }
        }

        /// <summary>
        /// Resets the 'broadcastOnce' flags, allowing detection events to be fired again.
        /// </summary>
        public void ResetBroadcaster()
        {
            wasEnterBroadcasted = false;
            wasExitBroadcasted = false;
        }

        /// <summary>
        /// Programmatically sets the target to be a specific collider.
        /// </summary>
        /// <param name="col">The collider to set as the new target.</param>
        public void SetTargetCollider(Collider col)
        {
            target = Target.Collider;
            targetCollider = col;
        }

        #region EDITOR
        
        /// <summary>
        /// [EDITOR ONLY] Assigns a collider reference and sets the target type to 'Collider'.
        /// </summary>
        /// <param name="other">The collider to assign as the target.</param>
        [ContextMenu("Assign Collider Reference In Editor")]
        public void EDITOR_AssignColliderReference(Collider other)
        {
            target = Target.Collider;
            targetCollider = other;
        }
        
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/PhysicsTargetDetectorBase.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/ReplaceHierarchyChildrenShaders.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 88830958994b42e5894c5a92dadf5806
# ASMDEF: ldx.framework.runtime.dll
# ---
#if UNITY_EDITOR
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    /// <summary>
    /// Applied to the hierarchy children of the game object the script is applied to
    /// Modifies all the materials to use a specified shader 
    /// </summary>
    public class ReplaceHierarchyChildrenShaders : MonoBehaviour
    {
        [SerializeField]
        private Shader replacementShader;
        public Shader ReplacementShader => replacementShader;
    }

    [CustomEditor(typeof(ReplaceHierarchyChildrenShaders))]
    public class ReplaceHierarchyChildrenShadersEditor : UnityEditor.Editor
    {
        private List<Material> materialsToReplace;
        private ReplaceHierarchyChildrenShaders Target => (ReplaceHierarchyChildrenShaders)target;
        
        private void OnEnable()
        {
            HashSet<Material> materialsSet = new HashSet<Material>();

            foreach (MeshRenderer renderer in Target.GetComponentsInChildren<MeshRenderer>())
            {
                Material mat = renderer.sharedMaterials.Length == 0 ? renderer.sharedMaterial : renderer.sharedMaterials[0];
                if (mat == null)
                {
                    continue;
                }

                if (materialsSet.Contains(mat))
                {
                    continue;
                }
                
                materialsSet.Add(mat);
            }   
            
            foreach (SkinnedMeshRenderer renderer in Target.GetComponentsInChildren<SkinnedMeshRenderer>())
            {
                Material mat = renderer.sharedMaterials.Length == 0 ? renderer.sharedMaterial : renderer.sharedMaterials[0];
                if (mat == null)
                {
                    continue;
                }
                
                if (materialsSet.Contains(mat))
                {
                    continue;
                }
                
                materialsSet.Add(mat);
            }

            materialsToReplace = new List<Material>(materialsSet);
        }

        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
            DrawReplaceButton();   
        }

        private void DrawReplaceButton()
        {
            if (GUILayout.Button("Replace Shaders in Children"))
            {
                ReplaceAllShaders();
            }
        }

        private void ReplaceAllShaders()
        {
            Shader shader = Target.ReplacementShader;
            foreach (Material material in materialsToReplace)
            {
                material.shader = shader;
            }
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/ReplaceHierarchyChildrenShaders.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/Resocketing/ResocketableItem.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 347d6f08231048d39688aba17010a76a
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Autohand;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using FluffyUnderware.DevTools.Extensions;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools.Resocketing
{
    [RequireComponent(typeof(Grabbable))]
    public class ResocketableItem : MonoBehaviour
    {
        private const float IN_FRONT_USER_ANIMATION_DURATION = 0.25f;
        private const float RESOCKET_ANIMATION_DURATION = 1.5f;
        private const float RESOCKET_OFFSET_FROM_PLAYER = 1f;

        // Could be used for sound?
        public static event Action<ResocketableItem, Sequence> OnResocketingStarted;

        [ReadOnly]
        [SerializeField] private bool resocketingEnabled = true;
        [SerializeField] private List<ResocketOptions> resocketOptions = new List<ResocketOptions>();
        [SerializeField] private Grabbable grabbable;
        [SerializeField] private float timeToResocket = 2.0f;
        [SerializeField] private bool moveInFrontOfUserBeforeResocketing;

        private bool ignoreReturn = false;
        public bool IgnoreReturn
        {
            get => ignoreReturn;
            set
            {
                ignoreReturn = value;

                if (!ignoreReturn)
                {
                    TryResocket();
                }
            }
        }

        private SocketResocketingInfo lastSocketResocketingInfo;
        private SocketResocketingInfo firstHolsterResocketingInfo;
        
        // Tweening
        private Sequence resocketSequence;
        private CancellationTokenSource cts;
        
        private void OnValidate()
        {
            if (grabbable == null)
            {
                grabbable = GetComponent<Grabbable>();
            }
        }

        private void Awake()
        {
            resocketingEnabled = true;
            grabbable.OnPlacePointAddEvent += HandleSocketed;
            grabbable.OnPlacePointRemoveEvent += HandleUnsocketed;
            grabbable.OnGrabEvent += HandleGrabbed;
            grabbable.OnReleaseEvent += HandleReleased;
        }

        private void OnDestroy()
        {
            grabbable.OnPlacePointAddEvent -= HandleSocketed;
            grabbable.OnPlacePointRemoveEvent -= HandleUnsocketed;
            grabbable.OnGrabEvent -= HandleGrabbed;
            grabbable.OnReleaseEvent -= HandleReleased;
            cts.SafeCancelAndDispose();
        }

        public void SetResocketingEnabled(bool resocketingEnabled)
        {
            this.resocketingEnabled = resocketingEnabled;
        }
        
        private void HandleGrabbed(Hand hand, Grabbable grabbableHand)
        {
            cts.SafeCancelAndDispose();
        }
        
        private async void HandleSocketed(PlacePoint point, Grabbable grabbableHand)
        {
            if (!resocketingEnabled || !ShouldRememberPlacePoint(point))
            {
                return;
            }
            
            await UniTask.Yield();
            lastSocketResocketingInfo = SocketResocketingInfo.Create(this, point);
        }
        
        private void HandleUnsocketed(PlacePoint point, Grabbable grabbableHand)
        {
            if (!resocketingEnabled)
            {
                return;
            }
            
            cts.SafeCancelAndDispose();
            cts = new CancellationTokenSource();
            ResocketAsync(GetActiveResocketingInfo(point), cts.Token).Forget();
        }
        
        private void HandleReleased(Hand hand, Grabbable grabbableHand)
        {
            if (!resocketingEnabled)
            {
                return;
            }

            ResocketToLastSocket();
        }

        /// <summary>
        /// Gets the current active resocketing info to use based on the options
        /// </summary>
        private SocketResocketingInfo GetActiveResocketingInfo(PlacePoint point)
        {
            //TODO: hoster
            /*if (socket is Holster)
            {
                // This socket is a holster, and we have the options set to try and reset back to the first holster this was socketed into
                if (resocketOptions.Contains(ResocketOptions.TryResocketBackToTheFirstHolster) && firstHolsterResocketingInfo != null)
                {
                    // What if first holster has an item? We get the next available holster then
                    if (firstHolsterResocketingInfo.Socket.IsGrabbing)
                    {
                        return GetAvailableHolsterResocketingInfo();
                    }
                    return firstHolsterResocketingInfo;
                }
            }*/

            // Not a holster, or no option to try resocket to the first holster? Just use the last socket
            return lastSocketResocketingInfo;
        }

        /// <summary>
        /// Gets an available holster to socket to, and returns appropriate resocketing info
        /// </summary>
        private SocketResocketingInfo GetAvailableHolsterResocketingInfo()
        {
            ///TODO: hoslster
            /*Holster availableHolster = PlayerController.Instance.WaistController.GetAvailableHolsters(grabbable).FirstOrDefault();
            if (availableHolster == null)
            {
                Logging.Debug.LogError("No available holster found for this grabbable found while attempting resocketing");
                return null;
            }

            return SocketResocketingInfo.CloneWithSocketOverride(firstHolsterResocketingInfo, availableHolster);*/
            return null;
        }
        
        /// <summary>
        /// Given a socket and provided options, determines if this socket should be remembered to resocket to when the item
        /// is dropped 
        /// </summary>
        private bool ShouldRememberPlacePoint(PlacePoint socket)
        {
            if (resocketOptions.Contains(ResocketOptions.TryResocketBackToTheFirstHolster))
            {
                //TODO: holster
                if (/*!(socket is Holster) &&*/ firstHolsterResocketingInfo != null )
                {
                    return false;
                }
            }
            
            //TODO: holster
            /*if (socket is Holster && resocketOptions.Contains(ResocketOptions.ForceRememberHolsters))
            {
                if (firstHolsterResocketingInfo == null)
                {
                    firstHolsterResocketingInfo = SocketResocketingInfo.Create(this, socket);
                    lastSocketResocketingInfo = firstHolsterResocketingInfo;
                }
                return true;
            }*/

            if (resocketOptions.Contains(ResocketOptions.OnlyRememberFirstSocket))
            {
                return lastSocketResocketingInfo == null;
            }
            
            return true;
        }

        public void TryResocket()
        {
            if (grabbable.placePoint)
            {
                return;
            }

            ResocketToLastSocket();
        }
        
        public void ResocketToLastSocket()
        {
            cts.SafeCancelAndDispose();
            cts = new CancellationTokenSource();
            ResocketAsync(lastSocketResocketingInfo, cts.Token).Forget();
        }
        
        private async UniTask ResocketAsync(SocketResocketingInfo resocketingInfo, CancellationToken cancellationToken)
        {
            await UniTask.Yield();
            await UniTask.WaitUntil(() => !grabbable.IsHeld(), cancellationToken: cancellationToken);
            await UniTask.Delay((int)(timeToResocket * 1000.0f), cancellationToken: cancellationToken);
            await UniTask.WaitUntil(() => !ignoreReturn, cancellationToken: cancellationToken);
            
            if (cancellationToken.IsCancellationRequested || 
                !resocketingEnabled || grabbable.placePoint || 
                grabbable.IsHeld() || !grabbable.isGrabbable)
            {
                return;
            }

            Camera cam = PlayerController.Instance.MainCamera;
            
            DisablePhysics(out Collider[] colliders, out Rigidbody[] rigidbodies);
            transform.SetParent(resocketingInfo.PlacePoint.transform);
            resocketSequence?.Kill();
            resocketSequence = DOTween.Sequence();

            if (moveInFrontOfUserBeforeResocketing)
            {
                Vector3 pos = cam.transform.position + (cam.transform.forward * RESOCKET_OFFSET_FROM_PLAYER);
                resocketSequence.Append(transform.DOMove(pos, IN_FRONT_USER_ANIMATION_DURATION));
            }
            
            resocketSequence
                .Join(transform.DOLocalMove(resocketingInfo.LocalPosition, RESOCKET_ANIMATION_DURATION).SetEase(Ease.OutQuad))
                .Join(transform.DOLocalRotate(resocketingInfo.LocalRotation.eulerAngles, RESOCKET_ANIMATION_DURATION)
                    .SetEase(Ease.OutQuad));
            
            OnResocketingStarted?.Invoke(this, resocketSequence);
            await resocketSequence.WithCancellation(cancellationToken);
            ResetPhysics(colliders, rigidbodies);
            resocketingInfo.PlacePoint.TryPlace(grabbable);
        }

        private void DisablePhysics(out Collider[] colliders, out Rigidbody[] rigidbodies)
        {
            colliders = GetComponentsInChildren<Collider>();
            rigidbodies = GetComponentsInChildren<Rigidbody>().Where(r=>r.isKinematic == false).ToArray();
            colliders.ForEach(c => c.enabled = false);
            rigidbodies.ForEach(r => r.isKinematic = true);
        }

        private void ResetPhysics(Collider[] colliders, Rigidbody[] rigidbodies)
        {
            colliders.ForEach(c => c.enabled = true);
            rigidbodies.ForEach(r => r.isKinematic = false);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/Resocketing/ResocketableItem.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/Resocketing/ResocketOptions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a0ec3b65db6748039dd1135fad7dd425
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;

namespace Ldx.Framework.Utilities.Tools.Resocketing
{
    /// <summary>
    /// Options for resocketable items
    /// </summary>
    [Serializable]
    public enum ResocketOptions
    {
        /// <summary>
        /// Resockets only to the first socket (as long as remembering a holster socket is not being forced)
        /// </summary>
        OnlyRememberFirstSocket = 0,
        /// <summary>
        /// When added, will override any other options to remember the holster as the last socket when socketed into one
        /// </summary>
        ForceRememberHolsters,
        /// <summary>
        /// When added, if the last socket is a holster, will try to resocket into the first holster this item was socketed into instead
        /// If not possible, will find the first available one
        /// </summary>
        TryResocketBackToTheFirstHolster
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/Resocketing/ResocketOptions.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/Resocketing/SocketResocketingInfo.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8d360c200c8044cf8dd6d4e4cb09631d
# ASMDEF: ldx.framework.runtime.dll
# ---
using Autohand;
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools.Resocketing
{
    /// <summary>
    /// Info to resocket an object after it was dropped
    /// </summary>
    public class SocketResocketingInfo
    {
        public PlacePoint PlacePoint { get; private set; }
        public Vector3 LocalPosition { get; private set; }
        public Quaternion LocalRotation { get; private set; }

        /// <summary>
        /// Private constructor to prevent instantiation that doesn't go through this class
        /// Used to maintain consistency and authenticity of the cache
        /// </summary>
        private SocketResocketingInfo() { }
        
        /// <summary>
        /// Creates an info cache to be reused when animating the resocket
        /// </summary>
        public static SocketResocketingInfo Create(ResocketableItem item, PlacePoint placePoint)
        {
            SocketResocketingInfo info = new()
            {
                PlacePoint = placePoint
            };
            Transform transform = item.transform;
            item.transform.SetParent(placePoint.transform);
            info.LocalPosition = transform.localPosition;
            info.LocalRotation = transform.localRotation;
            return info;
        }
        
        /// <summary>
        /// Clones socket info, replacing the socket reference
        /// </summary>
        public static SocketResocketingInfo CloneWithSocketOverride(SocketResocketingInfo source, PlacePoint placePoint)
        {
            SocketResocketingInfo cloned = new()
            {
                LocalPosition = source.LocalPosition,
                LocalRotation = source.LocalRotation,
                PlacePoint = placePoint
            };
            return cloned;
        }

    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/Resocketing/SocketResocketingInfo.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/SetParentOnTrackingEvent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f21b7a8f72014bf5903ba625b7058de8
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    public class SetParentOnTrackingEvent : MonoBehaviour
    {
        [SerializeField][IDSelection(LdxIdSettings.IdType.TrackingEvent)] 
        private string trackingEvent;
        [SerializeField]
        private Transform target;
        [SerializeField]
        private Transform newParent;

        private void Start()
        {
            LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
        }

        private void OnDestroy()
        {
            if (LdxTrackingManager.IsValid)
            {
                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
            }
        }

        private void HandleTrackingEvent(string id)
        {
            if (id == trackingEvent)
            {
                target.SetParent(newParent);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/SetParentOnTrackingEvent.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/SmoothPlayerFollower.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 80ad2e1a13b84e71a9db1f456ef763a4
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.Teleportation;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using Utilities.Blockers;

namespace Ldx.Framework.Utilities.Tools
{
    /// <summary>
    /// Smoothly follows the player's camera at a configurable distance and offset.
    /// It uses SmoothDamp for fluid movement and will snap instantly to the target if the distance
    /// exceeds the teleportThreshold, if the player teleports, or if unblocked,
    /// making it responsive to large player movements.
    /// </summary>
    public class SmoothPlayerFollower : MonoBehaviour
    {
        private enum ForwardDirection
        {
            PlayerForward,
            CameraForward
        }

        [Header("Positioning")] [Tooltip("The distance from the player's camera to place the object.")] [SerializeField]
        private float distanceFromPlayer = 0.8f;

        [Tooltip(
            "An additional positional offset in the camera's local space. Useful for placing the object slightly to the side or below the center of view.")]
        [SerializeField]
        private Vector3 positionalOffset = Vector3.zero;

        [Tooltip("Determines the forward direction for positioning the object relative to the player or camera.")]
        [SerializeField]
        private ForwardDirection forwardDirection = ForwardDirection.PlayerForward;

        [Tooltip(
            "Approximately the time it will take to reach the target. A smaller value will reach the target faster.")]
        [SerializeField]
        private float smoothTime = 0.3f;

        [Tooltip(
            "If the distance to the target is greater than this value, the object will snap to the target instantly. Useful for teleports.")]
        [SerializeField]
        private float teleportThreshold = 10f;

        [Header("Rotation")]
        [Tooltip("Should this object's own rotation be updated to always face the player?")]
        [SerializeField]
        private bool followRotation;

        [Tooltip("How quickly the object rotates to match the target rotation. A higher value is faster.")]
        [SerializeField]
        private float rotationSmoothTime = 8f;
        
        [Header("Blockers")] 
        [SerializeField]
        [ReadOnly]
        private List<MonoBehaviour> blockers = new List<MonoBehaviour>();

        private bool isBlocked = false;

        private Transform cameraTransform;
        private Vector3 velocity = Vector3.zero;
        private float sqrTeleportThreshold;
        
        private void OnValidate()
        {
            blockers = GetComponents<IBlocker>()
                .Cast<MonoBehaviour>() // must cast back to MonoBehaviour for serialization
                .ToList();
        }

        private void Awake()
        {
            foreach (IBlocker blocker in blockers)
            {
                blocker.OnBlockChanged += HandleBlockerChanged;
            }
            
            PlayerTeleporter.OnTeleportationFinished += HandleTeleportFinished;
        }

        private void OnDestroy()
        {
            foreach (IBlocker blocker in blockers)
            {
                blocker.OnBlockChanged -= HandleBlockerChanged;
            }
            
            PlayerTeleporter.OnTeleportationFinished -= HandleTeleportFinished;
        }

        private void Start()
        {
            PlayerController playerController = PlayerController.Instance;
            if (playerController.AutoHandPlayer == null || playerController.MainCamera == null)
            {
                Debug.LogError(
                    "SmoothPlayerFollower: PlayerController, AutoHandPlayer, or MainCamera not found! Component will be disabled.",
                    this);
                enabled = false;
                return;
            }

            cameraTransform = playerController.MainCamera.transform;
            sqrTeleportThreshold = teleportThreshold * teleportThreshold;
            
            if (cameraTransform == null)
            {
                return;
            }
            //Initial positioning
            DoInstantTransition();
        }

        private void LateUpdate()
        {
            if (cameraTransform == null || isBlocked)
            {
                return;
            }

            // 1. Calculate the final target position
            Vector3 targetPosition = CalculateFinalPosition();

            // Check for snapping
            float sqrDistanceToTarget = targetPosition.GetSqrDistance(transform.position);
            if (sqrDistanceToTarget > sqrTeleportThreshold)
            {
                transform.position = targetPosition;
                velocity = Vector3.zero;
            }
            else
            {
                transform.position = Vector3.SmoothDamp(transform.position, targetPosition, ref velocity, smoothTime);
            }

            // Update rotation to face the player, if enabled.
            if (followRotation)
            {
                Quaternion lookRotation = CalculateLookRotation();
                transform.rotation = sqrDistanceToTarget > sqrTeleportThreshold
                    ? lookRotation
                    : Quaternion.Slerp(transform.rotation, lookRotation, Time.deltaTime * rotationSmoothTime);
            }
        }

        private Vector3 CalculateFinalPosition()
        {
            Vector3 worldOffset = Vector3.zero;
            if (forwardDirection == ForwardDirection.PlayerForward)
            {
                Vector3 cameraXZForward =
                    new Vector3(cameraTransform.forward.x, 0f, cameraTransform.forward.z).normalized;
                worldOffset = (cameraXZForward * distanceFromPlayer) +
                              Vector3.ProjectOnPlane(positionalOffset, cameraXZForward);
            }
            else if (forwardDirection == ForwardDirection.CameraForward)
            {
                worldOffset = (cameraTransform.forward * distanceFromPlayer) +
                              cameraTransform.TransformDirection(positionalOffset);
            }
            
            return cameraTransform.position + worldOffset;
        }

        private Quaternion CalculateLookRotation()
        {
            return Quaternion.LookRotation(transform.position - cameraTransform.position);
        }

        private void DoInstantTransition()
        {
            if (cameraTransform == null)
                return;
            
            transform.position = CalculateFinalPosition();
            if (followRotation)
                transform.rotation = CalculateLookRotation();
        }

        private void HandleTeleportFinished(PlayerTeleporter teleporter)
        {
            DoInstantTransition();
        }
        
        private void HandleBlockerChanged(IBlocker blocker, bool state)
        {
            if (blockers.Any(x => (x as IBlocker).IsBlocked))
            {
                isBlocked = true;
            }
            else
            {
                //Instantly move to the target position after being unblocked
                if (isBlocked)
                {
                    DoInstantTransition();
                }
                isBlocked = false;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/SmoothPlayerFollower.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/StickToPlayerPosition.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b50fe24e58354aefacb3d7db098cf9d8
# ASMDEF: ldx.framework.runtime.dll
# ---
using Ldx.Framework.Systems.Player;
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    public class StickToPlayerPosition : MonoBehaviour
    {
        private Transform playerTransform;
        
        private void Start()
        {
            playerTransform = PlayerController.Instance?.AutoHandPlayer.transform;
        }

        private void Update()
        {
            if (playerTransform == null)
            {
                return;
            }
            
            transform.position = playerTransform.position;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/StickToPlayerPosition.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/StickToTargetPosition.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c51ca6a20def4f04ae98d9a72a7ca025
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;
using UnityEngine.Serialization;

namespace Ldx.Framework.Utilities.Tools
{
    /// <summary>
    /// A utility script that makes the GameObject stick to a target's position and rotation, 
    /// with optional offsets and smoothing.
    /// </summary>
    [ExecuteInEditMode]
    public class StickToTargetPosition : MonoBehaviour
    {
        [SerializeField] private bool destroyOnPlaymodeEnter;
        
        [Header("Targeting")]
        [SerializeField] private Transform mainTransform;
        [SerializeField] private Transform target;
        
        [Header("Position Constraints")]
        [Tooltip("Which axes should be affected by the target's position.")]
        [SerializeField] private AxisWithFlags positionalAxis =  AxisWithFlags.X | AxisWithFlags.Y | AxisWithFlags.Z;
        [Tooltip("Use a world-space offset instead of a local-space offset from the target.")]
        [SerializeField] private bool useWorldOffset = true;
        [FormerlySerializedAs("worldOffset")]
        [SerializeField] private Vector3 offset;
        public Vector3 Offset => offset;

        [Header("Rotation Constraints")]
        [Tooltip("Should this object track the target's rotation?")]
        [SerializeField] private bool trackRotation;
        [Tooltip("Which axes should be affected by the target's rotation.")]
        [SerializeField] private AxisWithFlags rotationAxis;
        
        [Header("Smoothing (Optional)")]
        [Tooltip("Enable to smoothly follow the target instead of snapping instantly.")]
        [SerializeField] private bool useSmoothing;
        [Tooltip("How quickly the object moves to the target's position. Higher values are faster.")]
        [SerializeField] private float positionSmoothSpeed = 10f;
        [Tooltip("How quickly the object rotates to match the target's rotation. Higher values are faster.")]
        [SerializeField] private float rotationSmoothSpeed = 10f;
        
        private Quaternion rotationOffset;

        private void Awake()
        {
            if (Application.isPlaying && destroyOnPlaymodeEnter)
            {
                Destroy(this);
            }
        }

        private void OnEnable()
        {
            if (mainTransform == null)
            {
                mainTransform = transform;
            }
            
            if (target != null)
            {
                CaptureInitialRotationOffset();
            }
        }
        
        private void Update()
        {
            if (target == null)
            {
                return;
            }
            
            if (!Application.isPlaying && trackRotation)
            {
                CaptureInitialRotationOffset();
            }
            
            Vector3 desiredPosition = target.position + (useWorldOffset ? offset : target.TransformDirection(offset));
            
            Quaternion desiredRotation = mainTransform.rotation;
            if (trackRotation)
            {
                desiredRotation = target.rotation * rotationOffset;
            }
            
            // --- SMOOTH FOLLOW ---
            if (useSmoothing && Application.isPlaying)
            {
                Vector3 smoothedPosition = Vector3.Lerp(mainTransform.position, desiredPosition, positionSmoothSpeed * Time.deltaTime);
                ApplyPositionWithAxisConstraints(smoothedPosition);

                if (trackRotation)
                {
                    Quaternion smoothedIntermediateRotation = Quaternion.Slerp(mainTransform.rotation, desiredRotation, rotationSmoothSpeed * Time.deltaTime);
                    ApplyRotationWithAxisConstraints(smoothedIntermediateRotation);
                }
            }
            // --- INSTANT FOLLOW ---
            else
            {
                ApplyPositionWithAxisConstraints(desiredPosition);

                if (trackRotation)
                {
                    ApplyRotationWithAxisConstraints(desiredRotation);
                }
            }
        }

        public void SetOffset(Vector3 newOffset)
        {
            offset = newOffset;
        }
        
        /// <summary>
        /// Sets the transform's position by combining the target position and current position
        /// based on the selected axis constraints.
        /// </summary>
        private void ApplyPositionWithAxisConstraints(Vector3 targetPosition)
        {
            Vector3 currentPosition = mainTransform.position;
            
            Vector3 finalPosition = new(
                (positionalAxis & AxisWithFlags.X) != 0 ? targetPosition.x : currentPosition.x,
                (positionalAxis & AxisWithFlags.Y) != 0 ? targetPosition.y : currentPosition.y,
                (positionalAxis & AxisWithFlags.Z) != 0 ? targetPosition.z : currentPosition.z
            );

            mainTransform.position = finalPosition;
        }
        
        /// <summary>
        /// Applies a rotation while respecting the chosen axis constraints.
        /// </summary>
        /// <param name="targetRotation">The rotation to apply.</param>
        private void ApplyRotationWithAxisConstraints(Quaternion targetRotation)
        {
            Vector3 targetEuler = targetRotation.eulerAngles;
            Vector3 currentEuler = mainTransform.eulerAngles;
            
            Vector3 finalEuler = new(
                (rotationAxis & AxisWithFlags.X) != 0 ? targetEuler.x : currentEuler.x,
                (rotationAxis & AxisWithFlags.Y) != 0 ? targetEuler.y : currentEuler.y,
                (rotationAxis & AxisWithFlags.Z) != 0 ? targetEuler.z : currentEuler.z
            );
            
            mainTransform.rotation = Quaternion.Euler(finalEuler);
        }

        /// <summary>
        /// Captures the initial rotational difference between this object and the target.
        /// This allows the object to maintain its initial orientation relative to the target.
        /// </summary>
        private void CaptureInitialRotationOffset()
        {
            if (target == null)
            {
                Debug.LogWarning("Cannot set rotation offset: Target is not assigned.", this);
                return;
            }
            
            rotationOffset = Quaternion.Inverse(target.rotation) * mainTransform.rotation;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/StickToTargetPosition.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/StickToTargetsPosition.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a7f495cc8b3f4e36bbb4a438d52bd7f9
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    [ExecuteInEditMode]
    public class StickToTargetsPosition : MonoBehaviour
    {
        [SerializeField] private List<Transform> targets = new List<Transform>();
        [SerializeField] private Vector3 worldOffset;

        private void Update()
        {
            if (targets.Count < 1)
            {
                return;
            }
            
            Vector3 average = Vector3.zero;
            foreach (Transform target in targets)
            {
                average += target.position;
            }
            
            average /= targets.Count;
            transform.position = average + worldOffset;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Tools/StickToTargetsPosition.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/WebConnection/EmailController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e6018c4277b48054fac465977ca9fa9d
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Cysharp.Threading.Tasks;
using Microsoft.MixedReality.Toolkit.Experimental.UI;
using Newtonsoft.Json;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.UI;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Logging;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Security;
using UnityEngine;
using UnityEngine.Networking;
using Debug = Ldx.Framework.Utilities.Logging.Debug;

namespace Ldx.Framework.Utilities.WebConnection
{
	public class EmailController : MonoBehaviour
	{
		private const string INTERNAL_LOG_FILE = "InternalLog.json";
		private const string EMAIL_CACHE_KEY = "EmailCache";
		private const string CURRENT_EMAIL_CACHE_KEY = "CurrentEmailCache";
		private const string MASTER_EMAIL_LIST_KEY = "MasterEmailList";

		[SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
		private string eventShowKeyboard;

		[SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
		private string eventHideKeyboard;

		[SerializeField] [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
		private string eventComplete;

		[SerializeField]
		private string clientSecurityKey = "IBEW"; // We'll hash this, and the server will look for it in the header

		[SerializeField] private string endpointURL = "https://qa.outreach.ibew353.logicaldox.dev/api/registrations";
		[SerializeField] private bool useNativeKeyboard;
		[SerializeField] private bool debugEnabled = true;

		private EmailList emailCache = new EmailList();
		private EmailList masterEmailList = new EmailList();
		private TouchScreenKeyboard nativeKeyboard;
		private string cacheKeyboardText;

		#region Email subclasses

		[Serializable]
		public class EmailItem
		{
			[JsonProperty("email")] public string Email { get; set; }

			[JsonProperty("registration_datetime")]
			public string RegistrationDateTime { get; set; }

			public EmailItem(string email)
			{
				Email = email;
				RegistrationDateTime = TimeUtilities.GetTimeNowEST().ToString("o"); // ISO 8601 format
			}
		}

		[Serializable]
		public class EmailList
		{
			[JsonProperty("emails")] public List<EmailItem> Emails { get; set; } = new List<EmailItem>();

			public void AddEmail(string email)
			{
				Emails.Add(new EmailItem(email));
			}

			public void Clear()
			{
				Emails.Clear();
			}

			public string ToJson()
			{
				return JsonConvert.SerializeObject(this);
			}

			public static EmailList FromJson(string json)
			{
				return JsonConvert.DeserializeObject<EmailList>(json) ?? new EmailList();
			}
		}

		private class LogEntry
		{
			public string Timestamp { get; set; }
			public string Message { get; set; }
		}

		#endregion

		protected virtual IEnumerator Start()
		{
			LoadEmailCache();
			LoadMasterEmailList();

			yield return new WaitUntil(() => LdxTrackingManager.IsValid);

			LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;
			SetNativeKeyboardReference();
			SubmissionSubscriptionHandlerAsync(true).Forget();
		}

		private void OnDisable()
		{
			if (!LdxTrackingManager.IsValid)
				return;

			SubmissionSubscriptionHandlerAsync(false).Forget();
			LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;
		}

		private void LateUpdate()
		{
			KeyboardManager();
		}

		private async UniTaskVoid SubmissionSubscriptionHandlerAsync(bool enable)
		{
			KeyboardWindow keyboardWindow = UIController.Instance.GetUIElement<KeyboardWindow>();

			if (enable && keyboardWindow == null)
			{
				await UniTask.WaitUntil(() =>
				{
					keyboardWindow = UIController.Instance.GetUIElement<KeyboardWindow>();
					return keyboardWindow != null;
				});
			}
			
			if (enable)
			{
				keyboardWindow.OnSubmitted += HandleTextSubmitted;
			}
			else
			{
				keyboardWindow.OnSubmitted -= HandleTextSubmitted;
			}
		}

		private void SetNativeKeyboardReference()
		{
			// This needs to happen even if we don't use native keyboard so that we can disable it later
			nativeKeyboard = TouchScreenKeyboard.Open("", TouchScreenKeyboardType.EmailAddress, false, false, false);
			nativeKeyboard.active = false;
		}

		private void KeyboardManager()
		{
			if (useNativeKeyboard)
			{
				ManageNativeKeyboard();
			}
			else
			{
				ManageLdxKeyboard();
			}
		}

		private void ManageLdxKeyboard()
		{
			// Our only managing of keyboards from the LdxKeyboard side consists of making sure the active keyboard is not the native. The native
			// keyboard will often try to force it's way open, so we need to ensure we close it if it does.
			if (nativeKeyboard != null && nativeKeyboard.active)
			{
				nativeKeyboard.active = false;
			}
		}

		private void ManageNativeKeyboard()
		{
			if (nativeKeyboard != null && nativeKeyboard.active)
			{
				HideLdxKeyboard();

				if (!String.IsNullOrEmpty(nativeKeyboard.text))
				{
					cacheKeyboardText = nativeKeyboard.text;
				}

				if (nativeKeyboard.status == TouchScreenKeyboard.Status.Done)
				{
					AddAndUploadEmail(!String.IsNullOrEmpty(nativeKeyboard.text)
						? nativeKeyboard.text
						: cacheKeyboardText);
					HideKeyboard();
				}
			}
		}

		private void HandleTrackingEvent(string id)
		{
			if (id == eventShowKeyboard)
			{
				ShowKeyboard();
			}
			else if (id == eventHideKeyboard)
			{
				HideKeyboard();
			}
		}

		private void ShowKeyboard()
		{
			if (!useNativeKeyboard || Application.isEditor)
			{
				ShowLdxKeyboard();
			}
			else
			{
				ShowNativeKeyboard();
			}
		}

		private void HideKeyboard()
		{
			if (!useNativeKeyboard || Application.isEditor)
			{
				HideLdxKeyboard();
			}
			else
			{
				HideNativeKeyboard();
			}
		}

		private void ShowNativeKeyboard()
		{
			if (nativeKeyboard == null || nativeKeyboard.status == TouchScreenKeyboard.Status.Done)
			{
				nativeKeyboard = TouchScreenKeyboard.Open("", TouchScreenKeyboardType.EmailAddress);
			}
			else
			{
				nativeKeyboard.active = true;
			}
		}

		private void HideNativeKeyboard()
		{
			if (nativeKeyboard != null)
			{
				nativeKeyboard.active = false;
			}
		}

		private void ShowLdxKeyboard()
		{
			NonNativeKeyboard.Instance.PresentKeyboard();
			HideNativeKeyboard();
		}

		private void HideLdxKeyboard()
		{
			if (NonNativeKeyboard.Instance != null)
			{
				NonNativeKeyboard.Instance.Close();
			}
		}

		private void HandleTextSubmitted(KeyboardWindow keyboardWindow, string submittedText)
		{
			SendCompleteEvent();
			AddAndUploadEmail(submittedText);
		}
		
		private void HandleTextSubmittedOld(object sender, EventArgs e)
		{
			NonNativeKeyboard keyboard = sender as NonNativeKeyboard;
			if (keyboard != null)
			{
				string submittedText = keyboard.InputField.text;
				SendCompleteEvent();

				if (!submittedText.Contains("@"))
				{
					Log("Email not valid, returning", logInternally: true, error: true);
					return;
				}

				AddAndUploadEmail(submittedText);
				Log($"Handled keyboard entry {submittedText} and passed to email controller.");
			}
		}

		private void SendCompleteEvent()
		{
			LdxTrackingManager.Instance.BroadcastTrackingEvent(eventComplete);
		}

		public void SaveMasterEmailList()
		{
			string json = masterEmailList.ToJson();
			PlayerPrefs.SetString(MASTER_EMAIL_LIST_KEY, json);
			Debug.Log($"Saved master email list: {json}");
		}

		public void LoadMasterEmailList()
		{
			string json = PlayerPrefs.GetString(MASTER_EMAIL_LIST_KEY, null);
			if (String.IsNullOrEmpty(json))
			{
				Debug.Log($"No saved email master list found");
				return;
			}

			masterEmailList = EmailList.FromJson(json);
			Debug.Log($"Loaded master email list: {json}");
		}

		public void SaveEmailCache()
		{
			string json = emailCache.ToJson();
			PlayerPrefs.SetString(EMAIL_CACHE_KEY, json);
			Debug.Log($"Saved email cache: {json}");
		}

		public void LoadEmailCache()
		{
			string json = PlayerPrefs.GetString(EMAIL_CACHE_KEY, "");
			emailCache = EmailList.FromJson(json);
			Debug.Log($"Loaded email cache: {json}");
		}

		private void Log(string message, bool logInternally = false, bool error = false)
		{
			if (debugEnabled)
			{
				if (error)
					Debug.LogError(LogCategory.UI, message);
				else
					Debug.Log(LogCategory.UI, message);

				return;
			}

			if (error)
				Debug.LogError(LogCategory.UI, message);
			else
				Debug.LogVerbose(LogCategory.UI, message);

			if (logInternally)
			{
				LogInternally(message);
			}
		}

		public static void LogInternally(string message)
		{
			string logFilePath = Path.Combine(Application.persistentDataPath, INTERNAL_LOG_FILE);

			List<LogEntry> logEntries = new List<LogEntry>();

			// Read existing log entries if the file exists
			if (File.Exists(logFilePath))
			{
				string json = File.ReadAllText(logFilePath);
				logEntries = JsonConvert.DeserializeObject<List<LogEntry>>(json) ?? new List<LogEntry>();
			}

			// Create a new log entry
			LogEntry newEntry = new LogEntry
			{
				Timestamp = DateTime.Now.ToString("o"), // ISO 8601 format
				Message = message
			};

			// Add the new entry to the list
			logEntries.Add(newEntry);

			// Serialize the updated log entries back to the file
			string updatedJson = JsonConvert.SerializeObject(logEntries, Formatting.Indented);
			File.WriteAllText(logFilePath, updatedJson);
		}

		[ContextMenu("Send Emails To Server")]
		public void SendEmailsToServer()
		{
			UploadEmailDataAsync().Forget();
		}

		[ContextMenu("Clear Email Cache")]
		public void ClearEmailCache()
		{
			emailCache.Clear();
			PlayerPrefs.DeleteKey(EMAIL_CACHE_KEY);
			PlayerPrefs.DeleteKey(CURRENT_EMAIL_CACHE_KEY);
			Log("Email caches cleared.");
		}

		[ContextMenu("Clear Master Email Cache")]
		public void ClearEmailMaster()
		{
			PlayerPrefs.DeleteKey(MASTER_EMAIL_LIST_KEY);
			Log("Master email list cleared.");
		}

		public void AddAndUploadEmail(string email)
		{
			if (string.IsNullOrWhiteSpace(email))
			{
				Debug.LogWarning("User tried to enter an empty string as email");
				return;
			}

			if (masterEmailList.Emails.Find(e => e.Email == email) == null)
			{
				masterEmailList.AddEmail(email);
				SaveMasterEmailList();
			}
			else
			{
				Log("User tried to enter email that is already on master list");
			}

			emailCache.AddEmail(email);
			SaveEmailCache();
			SendEmailsToServer();
			Log($"Added email: {email}");
		}

		private async UniTaskVoid UploadEmailDataAsync()
		{
			if (emailCache.Emails.Count == 0)
			{
				Log("No emails to upload. Aborting operation.");
				return;
			}

			string jsonPayload = emailCache.ToJson();
			string hashedKey = Hashing.GetHashKeyBasic(clientSecurityKey);
			Log($"Uploading emails: {jsonPayload}");

			using (UnityWebRequest www = new UnityWebRequest(endpointURL, "POST"))
			{
				byte[] bodyRaw = Encoding.UTF8.GetBytes(jsonPayload);
				www.uploadHandler = new UploadHandlerRaw(bodyRaw);
				www.downloadHandler = new DownloadHandlerBuffer();
				www.SetRequestHeader("Content-Type", "application/json");
				www.SetRequestHeader("Accept", "application/json");
				www.SetRequestHeader("Client-Security-Hash", hashedKey);

				await www.SendWebRequest();

				if (www.result != UnityWebRequest.Result.Success)
				{
					Log($"Error uploading emails: {www.error}", true, true);
				}
				else
				{
					Log($"Emails successfully uploaded. Response: {www.downloadHandler.text}", logInternally: true);
					ClearEmailCache();
				}
			}
		}

		#if UNITY_EDITOR
        #region Testing
        
        private string EDITOR_GetMasterEmailList()
        {
	        string json = PlayerPrefs.GetString(MASTER_EMAIL_LIST_KEY, "No master list found");
	        return json;
        }

        [ContextMenu("Test Server Connection with GET")]
        private void EDITOR_TestServerVoid()
        {
            EDITOR_TestServerConnection().Forget();
        }

        private async UniTaskVoid EDITOR_TestServerConnection()
        {
            using (UnityWebRequest www = UnityWebRequest.Get("http://m9pbd4tmro.laravel-sail.site:8080"))
            {
                await www.SendWebRequest();

                if (www.result != UnityWebRequest.Result.Success)
                {
                    Debug.LogError($"Error connecting to server: {www.error}");
                }
                else
                {
                    Debug.Log($"Server response: {www.downloadHandler.text}");
                }
            }
        }

        [ContextMenu("Add Test Email")]
        private void EDITOR_AddTestEmail()
        {
            AddAndUploadEmail($"test{UnityEngine.Random.Range(1000, 9999)}@example.com");
        }

        [ContextMenu("Display Master Email List")]
        private void EDITOR_DisplayMasterEmails()
        {
            string displayText = string.Join(", ",
                masterEmailList.Emails.Select(email => email.Email + " - " + email.RegistrationDateTime));
            Log("Master Email List: " + displayText);
            Log("Master Email List JSON: " + EDITOR_GetMasterEmailList());
        }

        [ContextMenu("Display Cached Emails")]
        private void EDITOR_DisplayCachedEmails()
        {
            string displayText = string.Join(", ",
                emailCache.Emails.Select(email => email.Email + " - " + email.RegistrationDateTime));
            Log("Cached Emails: " + displayText);
            // After which we show exactly how the json will appear
            Log("Cached Email List JSON: " + EDITOR_GetEmailCacheJson());
        }

        private string EDITOR_GetEmailCacheJson()
        {
            return emailCache.ToJson();
        }

        #endregion
		#endif
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/WebConnection/EmailController.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/WebConnection/Hashing.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8256d4ae737563649bc067a27d0ad9f3
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Security.Cryptography;
using System.Text;

namespace Ldx.Framework.Utilities.Security
{
	public static class Hashing
	{
		/// <summary>
		/// This will get you a basic SHA256 hashed key from a single string.
		/// </summary>
		/// <param name="key">the key to be hashed. This could be a client name, or a version number for example.</param>
		/// <param name="forceLowercase">if we want the key to be forced to lowercase before conversion</param>
		/// <returns></returns>
		public static string GetHashKeyBasic(string key, bool forceLowercase = true)
		{
			if (forceLowercase)
				key = key.ToLower();

			using (SHA256 sha256Hash = SHA256.Create())
			{
				byte[] bytes = sha256Hash.ComputeHash(Encoding.UTF8.GetBytes(key));
				StringBuilder builder = new StringBuilder();

				for (int i = 0; i < bytes.Length; i++)
				{
					builder.Append(bytes[i].ToString("x2"));
				}

				return builder.ToString();
			}
		}

		public static bool ValidateHashBasic(string receivedHash, string key)
		{
			string expectedHash = GetHashKeyBasic(key);
			return receivedHash.Equals(expectedHash, StringComparison.OrdinalIgnoreCase);
		}
		
		public static string GetHashByDay(string key)
		{
			// Temporarily commenting out, as it seems the correct methods were lost
			//string dayKey = key + TimeUtilities.GetSpecificTime(TimeUtilities.TimeComponent.Day);
			//return GetHashKeyBasic(dayKey);
			return key;
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/WebConnection/Hashing.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/WebConnection/WebRequests.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: fe1365be2c5d473a8316f366363af567
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.Networking;

namespace Ldx.Framework.Utilities.WebConnection
{
    public static class WebRequests {

        private static Coroutine getRoutine;
        private static Coroutine postRoutine;
        private static Coroutine putRoutine;
        private static Coroutine getTextureRoutine;

        public static async UniTask Get(string url, Action<string> onError, Action<string> onSuccess, string token = null)
        {
            await GetCoroutine(url, s =>
                {
                    onError?.Invoke(s);
                }, s =>
                {
                    onSuccess?.Invoke(s);
                },
                token: token);
        }
        
        public static async UniTask Post(string url, Dictionary<string, string> formFields, Action<string> onError, Action<string> onSuccess)
        {
            await GetCoroutinePost(url, formFields, s =>
            {
                onError?.Invoke(s);
            }, s =>
            {
                onSuccess?.Invoke(s);
            });
        }

        private static IEnumerator GetCoroutine(string url, Action<string> onError, Action<string> onSuccess, string token = null) {
            using (UnityWebRequest unityWebRequest = UnityWebRequest.Get(url)) {
                if (token != null)
                {
                    unityWebRequest.SetRequestHeader("Authorization", "Bearer " + token);
                }                
                yield return unityWebRequest.SendWebRequest();

                if (unityWebRequest.result == UnityWebRequest.Result.ConnectionError ||
                    unityWebRequest.result == UnityWebRequest.Result.DataProcessingError ||
                    unityWebRequest.result == UnityWebRequest.Result.ProtocolError) {
                    // Error
                    onError(unityWebRequest.error);
                } else {
                    onSuccess(unityWebRequest.downloadHandler.text);
                }
            }
        }

        public static async UniTask Post(string url, string postData, Action<string> onError, Action<string> onSuccess)
        {
            await GetCoroutinePost(url, postData, s =>
            {
                onError?.Invoke(s);
            }, s =>
            {
                onSuccess?.Invoke(s);
            });
        }
        
        public static async UniTask Post(string url, byte[] postData, Action<string> onError, Action<string> onSuccess)
        {
            await GetCoroutinePost(url, postData, s =>
            {
                onError?.Invoke(s);
            }, s =>
            {
                onSuccess?.Invoke(s);
            });
        }

        public static async UniTask PostJson(string url, string jsonData, Action<string> onError, Action<string> onSuccess, string token = null)
        {
            await GetCoroutinePostJson(url, jsonData, s =>
                {
                    onError?.Invoke(s);
                }, s =>
                {
                    onSuccess?.Invoke(s);
                },
                token: token);
        }

        private static IEnumerator GetCoroutinePost(string url, Dictionary<string, string> formFields, Action<string> onError, Action<string> onSuccess) {
            using (UnityWebRequest unityWebRequest = UnityWebRequest.Post(url, formFields)) {
                yield return unityWebRequest.SendWebRequest();

                if (unityWebRequest.result == UnityWebRequest.Result.ConnectionError ||
                    unityWebRequest.result == UnityWebRequest.Result.DataProcessingError ||
                    unityWebRequest.result == UnityWebRequest.Result.ProtocolError) {
                    // Error
                    onError(unityWebRequest.error);
                } else {
                    onSuccess(unityWebRequest.downloadHandler.text);
                }
            }
        }

        private static IEnumerator GetCoroutinePost(string url, string postData, Action<string> onError, Action<string> onSuccess) {
            using (UnityWebRequest unityWebRequest = UnityWebRequest.PostWwwForm(url, postData)) {
                byte[] jsonToSend = new System.Text.UTF8Encoding().GetBytes(postData);
                unityWebRequest.uploadHandler = new UploadHandlerRaw(jsonToSend);
                unityWebRequest.downloadHandler = new DownloadHandlerBuffer();
                unityWebRequest.SetRequestHeader("Content-Type", "application/json");
                yield return unityWebRequest.SendWebRequest();
                if (unityWebRequest.result == UnityWebRequest.Result.ConnectionError ||
                    unityWebRequest.result == UnityWebRequest.Result.DataProcessingError ||
                    unityWebRequest.result == UnityWebRequest.Result.ProtocolError) {
                    // Error
                    onError(unityWebRequest.error);
                } else {
                    onSuccess(unityWebRequest.downloadHandler.text);
                }
            }
        }
        
        private static IEnumerator GetCoroutinePost(string url, byte[] postData, Action<string> onError, Action<string> onSuccess) {
            WWWForm form = new WWWForm();
            form.AddField("text", "Screenshot from Unity:");
            form.AddBinaryData("file", postData, "screenshot.png", "image/png");
            
            using (UnityWebRequest unityWebRequest = UnityWebRequest.Post(url, form)) {
                yield return unityWebRequest.SendWebRequest();

                if (unityWebRequest.result == UnityWebRequest.Result.ConnectionError ||
                    unityWebRequest.result == UnityWebRequest.Result.DataProcessingError ||
                    unityWebRequest.result == UnityWebRequest.Result.ProtocolError) {
                    // Error
                    onError(unityWebRequest.error);
                } else {
                    onSuccess(unityWebRequest.downloadHandler.text);
                }
            }
        }

        private static IEnumerator GetCoroutinePostJson(string url, string jsonData, Action<string> onError, Action<string> onSuccess, string token = null) {
            using (UnityWebRequest unityWebRequest = new UnityWebRequest(url, "POST")) {
                byte[] bodyRaw = Encoding.UTF8.GetBytes(jsonData);
                unityWebRequest.uploadHandler = (UploadHandler)new UploadHandlerRaw(bodyRaw);
                unityWebRequest.downloadHandler = (DownloadHandler)new DownloadHandlerBuffer();
                unityWebRequest.SetRequestHeader("Content-Type", "application/json");
                if (token != null)
                {
                    unityWebRequest.SetRequestHeader("Authorization", "Bearer " + token);
                }

                yield return unityWebRequest.SendWebRequest();

                if (unityWebRequest.result == UnityWebRequest.Result.ConnectionError ||
                    unityWebRequest.result == UnityWebRequest.Result.DataProcessingError ||
                    unityWebRequest.result == UnityWebRequest.Result.ProtocolError) {
                    // Error
                    onError(unityWebRequest.error);
                } else {
                    onSuccess(unityWebRequest.downloadHandler.text);
                }
            }
        }

        public static async UniTask Put(string url, string bodyData, Action<string> onError, Action<string> onSuccess)
        {
            await GetCoroutinePut(url, bodyData, s =>
            {
                onError?.Invoke(s);
            }, s =>
            {
                onSuccess?.Invoke(s);
            });
        }

        private static IEnumerator GetCoroutinePut(string url, string bodyData, Action<string> onError, Action<string> onSuccess) {
            using (UnityWebRequest unityWebRequest = UnityWebRequest.Put(url, bodyData)) {
                yield return unityWebRequest.SendWebRequest();

                if (unityWebRequest.result == UnityWebRequest.Result.ConnectionError ||
                    unityWebRequest.result == UnityWebRequest.Result.DataProcessingError ||
                    unityWebRequest.result == UnityWebRequest.Result.ProtocolError) {
                    // Error
                    onError(unityWebRequest.error);
                } else {
                    onSuccess(unityWebRequest.downloadHandler.text);
                }
            }
        }

        public static async UniTask GetTexture(string url, Action<string> onError, Action<Texture2D> onSuccess)
        {
            await GetTextureCoroutine(url, s =>
            {
                onError?.Invoke(s);
            }, s =>
            {
                onSuccess?.Invoke(s);
            });
        }

        private static IEnumerator GetTextureCoroutine(string url, Action<string> onError, Action<Texture2D> onSuccess) {
            using (UnityWebRequest unityWebRequest = UnityWebRequestTexture.GetTexture(url)) {
                yield return unityWebRequest.SendWebRequest();

                if (unityWebRequest.result == UnityWebRequest.Result.ConnectionError ||
                    unityWebRequest.result == UnityWebRequest.Result.DataProcessingError ||
                    unityWebRequest.result == UnityWebRequest.Result.ProtocolError) {
                    // Error
                    onError(unityWebRequest.error);
                } else {
                    DownloadHandlerTexture downloadHandlerTexture = unityWebRequest.downloadHandler as DownloadHandlerTexture;
                    onSuccess(downloadHandlerTexture.texture);
                }
            }
        }

    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/WebConnection/WebRequests.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Wizard/ColliderTypes.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8c372bdd9dc044c6a87452cd2a17b8e8
# ASMDEF: ldx.framework.runtime.dll
# ---
namespace Ldx.Framework.Utilities.Wizard
{
    /// <summary>
    /// Collider type enum to be used with wizard configs
    /// </summary>
    public enum ColliderTypes
    {
        Box = 0,
        Sphere,
        Mesh,
        None
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Wizard/ColliderTypes.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Wizard/SetupWizard.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b22a9808730a4277a0d44142515ada4d
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Wizard
{
    /// <summary>
    /// A wizard to help setup common features quickly
    /// </summary>
    public class SetupWizard : MonoBehaviour
    {
        [SerializeReference]
        private WizardOperation operation;

        public WizardOperation Operation => operation;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Wizard/SetupWizard.cs

# FILE: Packages/com_ldx_framework/Runtime/Scripts/Utilities/Wizard/WizardOperation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2b808c4fe99a412387143443cc0977f6
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using UnityEngine;

namespace Ldx.Framework.Utilities.Wizard
{
    public static class WizardCategoryList
    {
        public const string GRABBING_AND_SOCKETING = "Grabbing and Socketing";
        public const string HIGHLIGHTING = "Highlighting";
        public const string MESHES_AND_COLLIDERS = "Meshes and Colliders";
        public const string OBJECTIVE_SYSTEM = "Objective System";
        public const string RENDERING = "Rendering";
        public const string SPLINES = "Splines";
        public const string FEATURES = "Features";
    }
    /// <summary>
    /// Base class for setup wizard operations
    /// </summary>
    [Serializable]
    public abstract class WizardOperation
    {
        /// <summary>
        /// Provides a description of the wizard operation, displayed in the user interface.
        /// </summary>
        public abstract string Description { get; }
        
        /// <summary>
        /// Validates the configuration of the operation to ensure all required references and settings are provided.
        /// </summary>
        /// <param name="errors">A list of error messages describing configuration issues if validation fails.</param>
        /// <returns> Returns `true` if the operation is correctly configured; otherwise, `false`. </returns>
        public abstract bool IsConfigurationValid(out List<string> errors);
        
        /// <summary>
        /// Executes the wizard operation asynchronously on the specified target GameObject.
        /// </summary>
        /// <param name="target">The GameObject on which the operation will be performed.</param>
        /// <returns> A `UniTask` representing the asynchronous execution of the operation. </returns>
        public abstract UniTask PerformAsync(GameObject target);
    }
}
# --- end Packages/com_ldx_framework/Runtime/Scripts/Utilities/Wizard/WizardOperation.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryAlwaysRender.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e2d6e02e134906942bad71c1434453fa
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[HelpURL("https://geom.io/bakery/wiki/index.php?title=Manual#Bakery_Always_Render")]
public class BakeryAlwaysRender : MonoBehaviour {
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryAlwaysRender.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryDirectLight.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c74ce2158ae608549902afb4112fd042
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
using UnityEngine;

#if UNITY_EDITOR
using UnityEditor;
#endif

using System;
using System.Collections;
using System.Collections.Generic;

[HelpURL("https://geom.io/bakery/wiki/index.php?title=Manual#Bakery_Direct_Light")]
[ExecuteInEditMode]
[DisallowMultipleComponent]
public class BakeryDirectLight : MonoBehaviour
{
    public Color color = Color.white;
    public float intensity = 1.0f;
    public float shadowSpread = 0.01f;//0.05f;
    public int samples = 16;
    //public uint bitmask = 1;
    public int bitmask = 1;
    public bool bakeToIndirect = false;
    public bool shadowmask = false;
    public bool shadowmaskDenoise = false;
    public float indirectIntensity = 1.0f;
    public Texture2D cloudShadow;
    public float cloudShadowTilingX = 0.01f;
    public float cloudShadowTilingY = 0.01f;
    public float cloudShadowOffsetX, cloudShadowOffsetY;
    public bool supersample = false;

    public int UID;

    public static int lightsChanged = 0; // 1 = const, 2 = full

    static GameObject objShownError;

#if UNITY_EDITOR
    void OnValidate()
    {
        if (lightsChanged == 0) lightsChanged = 1;
    }
    void OnEnable()
    {
        lightsChanged = 2;
    }
    void OnDisable()
    {
        lightsChanged = 2;
    }

    public void Start()
    {
        if (EditorApplication.isPlayingOrWillChangePlaymode) return;
        
        if (gameObject.GetComponent<BakerySkyLight>() != null ||
            gameObject.GetComponent<BakeryPointLight>() != null ||
            gameObject.GetComponent<BakeryLightMesh>() != null)
        {
            if (objShownError != gameObject)
            {
                EditorUtility.DisplayDialog("Bakery", "Can't have more than one Bakery light on one object", "OK");
                objShownError = gameObject;
            }
            else
            {
                Debug.LogError("Can't have more than one Bakery light on one object");
            }
            DestroyImmediate(this);
            return;
        }

        if (UID == 0) UID = Guid.NewGuid().GetHashCode(); // legacy
    }

    void OnDrawGizmos()
    {
      Gizmos.color = Color.yellow;
      Gizmos.DrawSphere(transform.position, 0.1f);

      //Gizmos.DrawWireSphere(transform.position, 0.5f);
    }

    void OnDrawGizmosSelected()
    {
      Gizmos.color = Color.yellow;
      var endPoint = transform.position + transform.forward * 2;
      Gizmos.DrawLine(transform.position, endPoint);

      //Gizmos.color = Color.blue;
      Gizmos.DrawWireSphere(transform.position, 0.2f);

      Gizmos.DrawLine(endPoint, endPoint + (transform.position + transform.right - endPoint).normalized * 0.5f);
      Gizmos.DrawLine(endPoint, endPoint + (transform.position - transform.right - endPoint).normalized * 0.5f);
      Gizmos.DrawLine(endPoint, endPoint + (transform.position + transform.up - endPoint).normalized * 0.5f);
      Gizmos.DrawLine(endPoint, endPoint + (transform.position - transform.up - endPoint).normalized * 0.5f);
    }

#endif
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryDirectLight.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryLightmapGroup.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ec0b4dd729a12d046982652f834580a2
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
using UnityEngine;

#if UNITY_EDITOR
using UnityEditor;
#endif

public struct BakeryLightmapGroupPlain
{
    public string name;
    public int resolution, id, renderMode, renderDirMode, atlasPacker;
    public bool vertexBake;
    public bool containsTerrains;
    public bool probes;
    public bool isImplicit;
    public bool computeSSS;
    public int sssSamples;
    public float sssDensity;
    public float sssR, sssG, sssB;
    public float fakeShadowBias;
    public bool transparentSelfShadow;
    public bool flipNormal;
    public string parentName;
    public int sceneLodLevel;
    public bool autoResolution;
    public int holeFilling;
    public int vertexSamplingDensity;
    //public bool forceBakeWithNormalMaps;
};

[CreateAssetMenu(menuName = "Bakery lightmap group")]
public class BakeryLightmapGroup : ScriptableObject
{
    public enum ftLMGroupMode
    {
        OriginalUV = 0,
        PackAtlas = 1,
        Vertex = 2,
    };

    public enum RenderMode
    {
        FullLighting = 0,
        Indirect = 1,
        Shadowmask = 2,
        Subtractive = 3,
        AmbientOcclusionOnly = 4,
        Auto = 1000
    };

    public enum RenderDirMode
    {
        None = 0,
        BakedNormalMaps = 1,
        DominantDirection = 2,
        RNM = 3,
        SH = 4,
        ProbeSH = 5,
        MonoSH = 6,
        ProbeSHL2 = 7,
        Auto = 1000
    };

    public enum AtlasPacker
    {
        Default = 0,
        xatlas = 1,
        Auto = 1000
    };

    public enum HoleFilling
    {
        Auto = 0,
        Yes = 1,
        No = 2
    };

    [SerializeField, Range(1, 8192)]
    public int resolution = 512;

    [SerializeField]
    public int bitmask = 1;

    [SerializeField]
    public int id = -1;

    public int sortingID = -1;

    [SerializeField]
    public bool isImplicit = false;

    [SerializeField]
    public float area = 0.0f;

    [SerializeField]
    public int totalVertexCount = 0;

    [SerializeField]
    public int vertexCounter = 0;

    [SerializeField]
    public int sceneLodLevel = -1;

    [SerializeField]
    public bool autoResolution = false;

    [SerializeField]
    public string sceneName;

    [SerializeField]
    public int tag = -1;

    [SerializeField]
    public bool containsTerrains;

    [SerializeField]
    public bool probes;

    [SerializeField]
    public ftLMGroupMode mode = ftLMGroupMode.PackAtlas;

    [SerializeField]
    public RenderMode renderMode = RenderMode.Auto;

    [SerializeField]
    public RenderDirMode renderDirMode = RenderDirMode.Auto;

    [SerializeField]
    public AtlasPacker atlasPacker = AtlasPacker.Auto;

    [SerializeField]
    public HoleFilling holeFilling = HoleFilling.Auto;

    [SerializeField]
    public int vertexSamplingDensity = 0;

    //[SerializeField]
    //public bool forceBakeWithNormalMaps = false;

    //[SerializeField]
    //public bool aoIsThickness = false;

    [SerializeField]
    public bool computeSSS = false;

    [SerializeField]
    public int sssSamples = 16;

    [SerializeField]
    public float sssDensity = 10;

    [SerializeField]
    public Color sssColor = Color.white;

    [SerializeField]
    public float sssScale = 1.0f;

    [SerializeField]
    public float fakeShadowBias = 0.0f;

    [SerializeField]
    public bool transparentSelfShadow = false;

    [SerializeField]
    public bool flipNormal = false;

    [SerializeField]
    public string parentName;

    [SerializeField]
    public string overridePath = "";

    [SerializeField]
    public bool fixPos3D = false;

    [SerializeField]
    public Vector3 voxelSize = Vector3.one;

    public int passedFilter;

    public BakeryLightmapGroupPlain GetPlainStruct()
    {
        BakeryLightmapGroupPlain str;
        str.name = name;
        str.id = id;
        str.resolution = resolution;
        str.vertexBake = mode == ftLMGroupMode.Vertex;
        str.isImplicit = isImplicit;
        str.renderMode = (int)renderMode;
        str.renderDirMode = (int)renderDirMode;
        str.atlasPacker = (int)atlasPacker;
        str.holeFilling = (int)holeFilling;
        str.vertexSamplingDensity = vertexSamplingDensity;
        //str.forceBakeWithNormalMaps = forceBakeWithNormalMaps;
        str.computeSSS = computeSSS;
        str.sssSamples = sssSamples;
        str.sssDensity = sssDensity;
        str.sssR = sssColor.r * sssScale;
        str.sssG = sssColor.g * sssScale;
        str.sssB = sssColor.b * sssScale;
        str.containsTerrains = containsTerrains;
        str.probes = probes;
        str.fakeShadowBias = fakeShadowBias;
        str.transparentSelfShadow = transparentSelfShadow;
        str.flipNormal = flipNormal;
        str.parentName = parentName;
        str.sceneLodLevel = sceneLodLevel;
        str.autoResolution = autoResolution;
        return str;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryLightmapGroup.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryLightmapGroupSelector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0a747f33c53bd3042af4ac90fc2a1fd3
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
using UnityEngine;

[HelpURL("https://geom.io/bakery/wiki/index.php?title=Manual#Bakery_Lightmap_Group_Selector")]
public class BakeryLightmapGroupSelector : MonoBehaviour
{
	public bool active = true;
    public Object lmgroupAsset;
    public bool instanceResolutionOverride = false;
    public int instanceResolution = 256;
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryLightmapGroupSelector.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryLightmappedPrefab.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6090ef81e51c0ad4da5a1a37e6cf65cf
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
#if UNITY_EDITOR
using UnityEditor;
#endif
using UnityEngine;

// Disable 'obsolete' warnings
#pragma warning disable 0618

[HelpURL("https://geom.io/bakery/wiki/index.php?title=Manual#Bakery_Lightmapped_Prefab")]
[DisallowMultipleComponent]
public class BakeryLightmappedPrefab : MonoBehaviour
{
#if UNITY_EDITOR
    public bool enableBaking = true;
    public bool ignoreWarnings = false;
    public string errorMessage;

    public bool IsValid()
    {
        errorMessage = "";

        if (!enableBaking)
        {
            return false;
        }

        if (ignoreWarnings) return true;

        bool isPartOfPrefab = PrefabUtility.GetPrefabType(gameObject) == PrefabType.PrefabInstance;
        if (!isPartOfPrefab)
        {
            errorMessage = "this GameObject is not a prefab";
            return false;
        }

        bool prefabIsRoot = PrefabUtility.FindPrefabRoot(gameObject) == gameObject;
        if (!prefabIsRoot)
        {
            errorMessage = "this GameObject is not a root prefab object";
            return false;
        }

        var transforms = GetComponentsInChildren<Transform>();
        for(int i=0; i<transforms.Length; i++)
        {
            if (PrefabUtility.FindPrefabRoot(transforms[i].gameObject) != gameObject)
            {
                errorMessage = "prefab contains unapplied object (" + transforms[i].name + ")";
                return false;
            }
        }

        var prefabRootObj = PrefabUtility.GetPrefabObject(gameObject);
        //var prefabRootObj2 = PrefabUtility.FindPrefabRoot(gameObject);

        var mods = PrefabUtility.GetPropertyModifications(gameObject);
        if (mods != null)
        {
            for(int i=0; i<mods.Length; i++)
            {
                if (mods[i] == null) continue;
#if UNITY_2018_3_OR_NEWER
                if (PrefabUtility.IsDefaultOverride(mods[i])) continue;
#endif
                if (mods[i].propertyPath == "m_RootOrder") continue;
                if (mods[i].propertyPath == "errorMessage") continue;
                if (mods[i].propertyPath == "enableBaking") continue;
                if (mods[i].propertyPath.IndexOf("idremap") >= 0) continue;
                if (mods[i].target != null && mods[i].target.name == gameObject.name)
                {
                    if (mods[i].propertyPath.Contains("m_LocalPosition")) continue;
                    if (mods[i].propertyPath.Contains("m_LocalRotation")) continue;
                    if (mods[i].propertyPath.Contains("m_LocalScale")) continue;
                }

                errorMessage = "prefab contains unapplied data (" + mods[i].target+"."+mods[i].propertyPath + ")";
                return false;
            }
        }

        var comps = gameObject.GetComponents<Component>();
        var comps2 = gameObject.GetComponentsInChildren<Component>();

        for(int t=0; t<2; t++)
        {
            var comps3 = t == 0 ? comps : comps2;
            for(int c=0; c<comps3.Length; c++)
            {
                var prefabObj = PrefabUtility.GetPrefabObject(comps3[c]);
                if (prefabObj != prefabRootObj)
                {
                    errorMessage = "prefab contains unapplied component (" + comps3[c] + ")";
                    return false;
                }

                /*bool isRoot = comps3[c].gameObject == gameObject;

                var mods = PrefabUtility.GetPropertyModifications(comps3[c]);
                if (mods == null) continue;
                for(int i=0; i<mods.Length; i++)
                {
                    if (mods[i].propertyPath == "m_RootOrder") continue;
                    if (isRoot)
                    {
                        if (mods[i].propertyPath == "errorMessage") continue;
                        if (mods[i].propertyPath == "enableBaking") continue;
                        if (mods[i].propertyPath.Contains("m_LocalPosition")) continue;
                        if (mods[i].propertyPath.Contains("m_LocalRotation")) continue;
                        if (mods[i].propertyPath.Contains("m_LocalScale")) continue;
                    }
                    else
                    {
                        if (mods[i].propertyPath.Contains("m_LocalPosition"))
                        {
                            var dist = (comps3[c].transform.position - (PrefabUtility.GetPrefabParent(comps3[c].gameObject) as GameObject).transform.position).sqrMagnitude;
                            Debug.LogError(dist);
                            if (dist < 0.001f) continue;
                        }
                        else if (mods[i].propertyPath.Contains("m_LocalRotation"))
                        {
                            continue;
                        }
                    }
                    errorMessage = "Error: prefab contains unapplied data (" + mods[i].target+"."+mods[i].propertyPath + ")";
                    return false;
                }*/
            }
        }

        return true;
    }
#endif
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryLightmappedPrefab.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryLightMesh.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a28e27cacfc7e70479097f0a63c37217
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
using UnityEngine;

#if UNITY_EDITOR
using UnityEditor;
#endif

using System;
using System.Collections;
using System.Collections.Generic;

[HelpURL("https://geom.io/bakery/wiki/index.php?title=Manual#Bakery_Light_Mesh")]
[ExecuteInEditMode]
[DisallowMultipleComponent]
public class BakeryLightMesh : MonoBehaviour
{
    public int UID;

    public Color color = Color.white;
    public float intensity = 1.0f;
    public Texture2D texture = null;
    //public Vector2 texScale = new Vector2(1,1);
    //public Vector2 texOffset = new Vector2(0,0);
    public float cutoff = 100;
    public int samples = 256;
    public int samples2 = 16;
    public int samples2_previous = 16;
    public int bitmask = 1;
    public bool selfShadow = true;
    public bool bakeToIndirect = true;
    public bool shadowmask = false;
    public float indirectIntensity = 1.0f;
    public bool shadowmaskFalloff = false;
    public int maskChannel;

    public int lmid = -2;

    public static int lightsChanged = 0;

    static GameObject objShownError;

#if UNITY_EDITOR
    void OnValidate()
    {
        if (lightsChanged == 0) lightsChanged = 1;
    }

    public void Start()
    {
        if (EditorApplication.isPlayingOrWillChangePlaymode) return;

        if (gameObject.GetComponent<BakeryDirectLight>() != null ||
            gameObject.GetComponent<BakeryPointLight>() != null ||
            gameObject.GetComponent<BakerySkyLight>() != null)
        {
            if (objShownError != gameObject)
            {
                EditorUtility.DisplayDialog("Bakery", "Can't have more than one Bakery light on one object", "OK");
                objShownError = gameObject;
            }
            else
            {
                Debug.LogError("Can't have more than one Bakery light on one object");
            }
            DestroyImmediate(this);
            return;
        }

        if (UID == 0) UID = Guid.NewGuid().GetHashCode(); // legacy
    }

#endif

	void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.yellow;
        var mr = gameObject.GetComponent<MeshRenderer>();
        if (mr!=null) Gizmos.DrawWireSphere(mr.bounds.center, cutoff);
	}
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryLightMesh.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryPackAsSingleSquare.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cf72c611dfa77174e811af15d6ba69da
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[HelpURL("https://geom.io/bakery/wiki/index.php?title=Manual#Bakery_Pack_As_Single_Square")]
public class BakeryPackAsSingleSquare : MonoBehaviour {
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryPackAsSingleSquare.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryPointLight.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 57f24a4aaa0761b45ba25e7e5108e2c7
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
using UnityEngine;

#if UNITY_EDITOR
using UnityEditor;
#endif

using System;
using System.Collections;
using System.Collections.Generic;

[HelpURL("https://geom.io/bakery/wiki/index.php?title=Manual#Bakery_Point_Light")]
[ExecuteInEditMode]
[DisallowMultipleComponent]
public class BakeryPointLight : MonoBehaviour
{
    public enum ftLightProjectionMode
    {
        Omni = 0,
        Cookie = 1,
        Cubemap = 2,
        IES = 3,
        Cone = 4
    };

    public enum Direction
    {
        NegativeY = 0,
        PositiveZ = 1
    };

    public int UID;
    public Color color = Color.white;
    public float intensity = 1.0f;
    public float shadowSpread = 0.05f;
    public float cutoff = 10.0f;
    public bool realisticFalloff = false;
    public bool legacySampling = true;
    public int samples = 8;
    public ftLightProjectionMode projMode;
    public Texture2D cookie;
    public float angle = 30.0f;
    public float innerAngle = 0;
    public Cubemap cubemap;
    public UnityEngine.Object iesFile;
    public int bitmask = 1;
    public bool bakeToIndirect = false;
    public bool shadowmask = false;
    public bool shadowmaskFalloff = false;
    public float indirectIntensity = 1.0f;
    public float falloffMinRadius = 1.0f;
    public int shadowmaskGroupID = 0;
    public bool correctCookieDistortion = false;
    public Direction directionMode = Direction.NegativeY;
    public int maskChannel;

    const float GIZMO_MAXSIZE = 0.1f;
    const float GIZMO_SCALE = 0.01f;

    public static int lightsChanged = 0; // 1 = const, 2 = full

    static GameObject objShownError;

#if UNITY_EDITOR
    float screenRadius = GIZMO_MAXSIZE;

    void OnValidate()
    {
        if (lightsChanged == 0) lightsChanged = 1;
    }
    void OnEnable()
    {
        lightsChanged = 2;
    }
    void OnDisable()
    {
        lightsChanged = 2;
    }

    public void Start()
    {
        if (EditorApplication.isPlayingOrWillChangePlaymode) return;
        
        if (gameObject.GetComponent<BakeryDirectLight>() != null ||
            gameObject.GetComponent<BakerySkyLight>() != null ||
            gameObject.GetComponent<BakeryLightMesh>() != null)
        {
            if (objShownError != gameObject)
            {
                EditorUtility.DisplayDialog("Bakery", "Can't have more than one Bakery light on one object", "OK");
                objShownError = gameObject;
            }
            else
            {
                Debug.LogError("Can't have more than one Bakery light on one object");
            }
            DestroyImmediate(this);
            return;
        }

        if (UID == 0) UID = Guid.NewGuid().GetHashCode(); // legacy
    }

    void OnDrawGizmos()
    {
        Gizmos.color = color;
        var curCam = Camera.current;
        if (curCam != null)
        {
            screenRadius = Mathf.Min((transform.position - curCam.transform.position).magnitude * GIZMO_SCALE, GIZMO_MAXSIZE);
        }
        Gizmos.DrawSphere(transform.position, screenRadius);
    }

    void DrawArrow(Vector3 a, Vector3 b)
    {
        //const float len = 0.125f;

        b = a + b * (shadowSpread + 0.05f);
        Gizmos.DrawLine(a, b);
    }

    void OnDrawGizmosSelected()
    {
      Gizmos.color = color;//Color.yellow;
      Gizmos.DrawWireSphere(transform.position, shadowSpread);

      Gizmos.color = new Color(color.r, color.g, color.b, 0.25f);//Color.gray;
      if (projMode != ftLightProjectionMode.Cookie && projMode != ftLightProjectionMode.Cone) Gizmos.DrawWireSphere(transform.position, cutoff);

      if (projMode != 0)
      {
          Gizmos.color = color;//Color.yellow;
          Vector3 endPoint;
          if (projMode == ftLightProjectionMode.Cookie || projMode == ftLightProjectionMode.Cone)
          {
            endPoint = transform.forward * 2;
            Gizmos.DrawRay(transform.position, endPoint);

            float angle2 = (180 - angle) * Mathf.Deg2Rad * 0.5f;
            //float x = Mathf.Cos(angle2);
            //float radius = x * cutoff;

            float x = 1 / Mathf.Sin(angle2);
            x = Mathf.Sqrt(x * x - 1);
            float radius = x * cutoff;

            const int segments = 16;
            for(int i=0; i<segments; i++)
            {
                float p1 = i / (float)segments;
                float p2 = (i+1) / (float)segments;

                float x1 = Mathf.Cos(p1 * Mathf.PI*2);
                float y1 = Mathf.Sin(p1 * Mathf.PI*2);

                float x2 = Mathf.Cos(p2 * Mathf.PI*2);
                float y2 = Mathf.Sin(p2 * Mathf.PI*2);

                Vector3 A = transform.position + transform.forward * cutoff + transform.right * x1 * radius + transform.up * y1 * radius;
                Vector3 B = transform.position + transform.forward * cutoff + transform.right * x2 * radius + transform.up * y2 * radius;
                Gizmos.DrawLine(A, B);

                if (i % 4 == 0) Gizmos.DrawLine(transform.position, A);
            }
          }
          else
          {
            if (projMode == ftLightProjectionMode.IES && directionMode == Direction.PositiveZ)
            {
                endPoint = transform.forward * 2;
            }
            else
            {
                endPoint = -transform.up * 2;
            }
            Gizmos.DrawRay(transform.position, endPoint);
          }
          endPoint += transform.position;
          Gizmos.DrawLine(endPoint, endPoint + (transform.position + transform.right - endPoint).normalized * 0.5f);
          Gizmos.DrawLine(endPoint, endPoint + (transform.position - transform.right - endPoint).normalized * 0.5f);
          Gizmos.DrawLine(endPoint, endPoint + (transform.position + transform.up - endPoint).normalized * 0.5f);
          Gizmos.DrawLine(endPoint, endPoint + (transform.position - transform.up - endPoint).normalized * 0.5f);
      }
    }
#endif
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryPointLight.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryProjectSettings.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 05ce0574111032a418688d5d3961cb09
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
#if UNITY_EDITOR

using UnityEditor;
using UnityEngine;

public class BakeryProjectSettings : ScriptableObject
{
    // Affects texture import settings for lightmaps
    [SerializeField]
    public bool mipmapLightmaps = false;

    // Use PNG instead of TGA for shadowmasks, directions and L1 maps?
    // 'Asset' converts to Unity's own format. It is possible to limit the mipmap count here.
    public enum FileFormat
    {
        TGA = 0,
        PNG = 1,
        Asset = 2
    }
    [SerializeField]
    public FileFormat format8bit = FileFormat.TGA;

    // Use .hdr files or Unity assets for color/RNM/L0 lightmaps
    public enum FileFormatHDR
    {
        HDR = 0,
        Asset = 1
    }

    public enum Rounding
    {
        ToSmaller = 0,
        ToLarger = 1
    }

    [SerializeField]
    public FileFormatHDR formatHDR = FileFormatHDR.HDR;

    // Compress lightmaps?
    public enum Compression
    {
        CompressButAllowOverridingAsset = 0, // default behaviour
        ForceCompress = 1,
        ForceNoCompress = 2
    }
    [SerializeField]
    public Compression lightmapCompression = Compression.CompressButAllowOverridingAsset;

    // Max mipmap count when format8bit or formatHDR are set to Asset
    [SerializeField]
    public int maxAssetMip = 100;

    // Use high quality compression for directional and SH L1 maps? (on desktop, high = BC7, not high = DXT1)
    [SerializeField]
    public bool dirHighQuality = true;

    // Padding values for atlas packers
    [SerializeField]
    public int texelPaddingForDefaultAtlasPacker = 3;
    [SerializeField]
    public int texelPaddingForXatlasAtlasPacker = 1;

    // Scales resolution for alpha Meta Pass maps
    [SerializeField]
    public int alphaMetaPassResolutionMultiplier = 2;

    // Render mode for all volumes in the scene. Defaults to Auto, which uses global scene render mode.
    [SerializeField]
    public int volumeRenderMode = 1000;//BakeryLightmapGroup.RenderMode.Auto;

    // Should previously rendered Bakery lightmaps be deleted before the new bake?
    // Turned off by default because I'm scared of deleting anything
    [SerializeField]
    public bool deletePreviousLightmapsBeforeBake = false;

    // Print information about the bake process to console?
    [System.FlagsAttribute]
    public enum LogLevel
    {
        Nothing = 0,
        Info = 1,   // print to Debug.Log
        Warning = 2 // print to Debug.LogWarning
    }
    [SerializeField]
    public int logLevel = (int)(LogLevel.Info | LogLevel.Warning);

    // Make it work more similar to original Unity behaviour
    [SerializeField]
    public bool alternativeScaleInLightmap = false;

    // How texels are rounded
    [SerializeField]
    public Rounding texelRoundingBehaviour = Rounding.ToSmaller;

    // Another approach to maintain better texel uniformity, suggested by Jan
    [SerializeField]
    public bool alternativeGroupPacking = false;

    // Make xatlas align charts to 4x4 block boundaries to make texture compression happy
    [SerializeField]
    public bool alignToTextureBlocksWithXatlas = true;

    // Should we adjust sample positions to prevent incorrect shadowing on very low-poly meshes with smooth normals?
    [SerializeField]
    public bool generateSmoothPos = true;

    [SerializeField]
    public bool perTriangleSmoothPos = true;

    // Use renderer.receiveGI
    [SerializeField]
    public bool takeReceiveGIIntoAccount = true;

    // Remove ringing in Legacy light probes?
    [SerializeField]
    public bool removeRinging = false;

    // Remove directional/point light ringing in Legacy light probes?
    [SerializeField]
    public bool removeDirectRinging = true;

    // Deringing parameter for L2 light probes / APVs
    [SerializeField]
    public int deringL2MaxLaplacian = 0;

    // Render ref probes automatically after the lightmap render?
    [SerializeField]
    public bool autoRenderRefProbes = false;

    // Use the old volume position adjustment algorithm?
    [SerializeField]
    public bool legacyFixPos3D = false;

    // Use new fast LOD tracing technique?
    [SerializeField]
    public bool optimizedLODs = true;

    // Enable "streaming" option on the texture importer?
    [SerializeField]
    public bool streamingMipmaps = false;

    // Set the "streaming priority" on the texture importer
    [SerializeField]
    public int streamingPriority = 0;

    [SerializeField]
    public TextureImporterFormat forceSpecificColorFormat = (TextureImporterFormat)(-1);

    [SerializeField]
    public TextureImporterFormat forceSpecificDirFormat = (TextureImporterFormat)(-1);

    [SerializeField]
    public TextureImporterFormat forceSpecificMaskFormat = (TextureImporterFormat)(-1);
}

#endif
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryProjectSettings.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakerySector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d10ab396b89a06942afcc1005cd4e1f2
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[HelpURL("https://geom.io/bakery/wiki/index.php?title=Partial_scene_baking")]
public class BakerySector : MonoBehaviour
{
    public enum CaptureMode
    {
        None = -1,
        CaptureInPlace = 0,
        CaptureToAsset = 1,
        LoadCaptured = 2
    }

    public CaptureMode captureMode = CaptureMode.CaptureInPlace;
    public string captureAssetName = "";
    public BakerySectorCapture captureAsset;
    public bool allowUVPaddingAdjustment = false;
    public List<Transform> tforms = new List<Transform>();
    public List<Transform> cpoints = new List<Transform>();

#if UNITY_EDITOR
    public List<Renderer> previewDisabledRenderers;
    public List<GameObject> previewTempObjects;
    public bool previewEnabled = false;
    public bool bakeChildLightProbeGroups = false;
#endif

    void OnDrawGizmosSelected()
    {
        Gizmos.color = Color.green;
        for(int i=0; i<cpoints.Count; i++)
        {
            if (cpoints[i] != null) Gizmos.DrawWireSphere(cpoints[i].position, 1.0f);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakerySector.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakerySectorCapture.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6f1a86d43dd48934fb3a04c088307681
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
using UnityEngine;
using System.Collections.Generic;

public class BakerySectorCapture : ScriptableObject
{
#if UNITY_EDITOR
    [SerializeField]
    public Vector3 sectorPos;

    [SerializeField]
    public Quaternion sectorRot;

    [SerializeField]
    public List<Mesh> meshes;

    [SerializeField]
    public List<Vector3> positions;

    [SerializeField]
    public List<Texture2D> textures;

    public List<Renderer> outsideRenderers;
    public bool write = false;

#endif
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakerySectorCapture.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakerySharedLodUv.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d0f69bc078114144aac4fad044334647
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[HelpURL("https://geom.io/bakery/wiki/index.php?title=Manual#Bakery_Shared_LOD_UV")]
public class BakerySharedLodUv : MonoBehaviour{
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakerySharedLodUv.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakerySkyLight.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 306a56f30ff21b5439963fc745cfe9cc
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
using UnityEngine;

#if UNITY_EDITOR
using UnityEditor;
#endif

using System;
using System.Collections;
using System.Collections.Generic;

[HelpURL("https://geom.io/bakery/wiki/index.php?title=Manual#Bakery_Sky_Light")]
[ExecuteInEditMode]
[DisallowMultipleComponent]
public class BakerySkyLight : MonoBehaviour
{
    public string texName = "sky.dds";
    public Color color = Color.white;
    public float intensity = 1.0f;
    public int samples = 32;
    public bool hemispherical = false;
    public int bitmask = 1;
    public bool bakeToIndirect = true;
    public float indirectIntensity = 1.0f;
    public bool tangentSH = false;
    public bool correctRotation = false;

    public Cubemap cubemap;

    public int UID;

    public static int lightsChanged = 0; // 1 = const, 2 = full

    static GameObject objShownError;

#if UNITY_EDITOR
    void OnValidate()
    {
        if (lightsChanged == 0) lightsChanged = 1;
    }
    void OnEnable()
    {
        lightsChanged = 2;
    }
    void OnDisable()
    {
        lightsChanged = 2;
    }

    public void Start()
    {
        if (EditorApplication.isPlayingOrWillChangePlaymode) return;
        
        if (gameObject.GetComponent<BakeryDirectLight>() != null ||
            gameObject.GetComponent<BakeryPointLight>() != null ||
            gameObject.GetComponent<BakeryLightMesh>() != null)
        {
            if (objShownError != gameObject)
            {
                EditorUtility.DisplayDialog("Bakery", "Can't have more than one Bakery light on one object", "OK");
                objShownError = gameObject;
            }
            else
            {
                Debug.LogError("Can't have more than one Bakery light on one object");
            }
            DestroyImmediate(this);
            return;
        }

        if (UID == 0) UID = Guid.NewGuid().GetHashCode(); // legacy
    }

    void OnDrawGizmos()
    {
      Gizmos.color = new Color(49/255.0f, 91/255.0f, 191/255.0f);
      Gizmos.DrawSphere(transform.position, 0.1f);
    }

    void OnDrawGizmosSelected()
    {
        Gizmos.color = new Color(49/255.0f, 91/255.0f, 191/255.0f);
        Vector3 origin = transform.position;
        const int segments = 16;
        for(int i=0; i<segments; i++)
        {
            float p1 = i / (float)segments;
            float p2 = (i+1) / (float)segments;

            float x1 = Mathf.Cos(p1 * Mathf.PI*2);
            float y1 = Mathf.Sin(p1 * Mathf.PI*2);

            float x2 = Mathf.Cos(p2 * Mathf.PI*2);
            float y2 = Mathf.Sin(p2 * Mathf.PI*2);

            Gizmos.DrawLine(origin + new Vector3(x1,0,y1), origin + new Vector3(x2,0,y2));

            if (hemispherical)
            {
                x1 = Mathf.Cos(p1 * Mathf.PI);
                y1 = Mathf.Sin(p1 * Mathf.PI);

                x2 = Mathf.Cos(p2 * Mathf.PI);
                y2 = Mathf.Sin(p2 * Mathf.PI);
            }

            Gizmos.DrawLine(origin + new Vector3(x1,y1,0), origin + new Vector3(x2,y2,0));
            Gizmos.DrawLine(origin + new Vector3(0,y1,x1), origin + new Vector3(0,y2,x2));
        }
    }

#endif
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakerySkyLight.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryVolume.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 17ce3c1d3490b7143a67ebdc73cab6c1
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.IMGUI.Controls;
#endif

[HelpURL("https://geom.io/bakery/wiki/index.php?title=Manual#Bakery_Volume")]
[ExecuteInEditMode]
public class BakeryVolume : MonoBehaviour
{
    public enum Encoding
    {
        // HDR L1 SH, half-float:
        // Tex0 = L0,  L1z.r
        // Tex1 = L1x, L1z.g
        // Tex2 = L1y, L1z.b
        Half4,

        // LDR L1 SH, 8-bit. Components are stored the same way as in Half4,
        // but L1 must be unpacked following way:
        // L1n = (L1n * 2 - 1) * L0 * 0.5 + 0.5
        RGBA8,

        // LDR L1 SH with monochrome directional component (= single color and direction), 8-bit.
        // Tex0 = L0    (alpha unused)
        // Tex1 = L1xyz (alpha unused)
        RGBA8Mono
    }

    public enum ShadowmaskEncoding
    {
        RGBA8,
        A8
    }

    public bool enableBaking = true;
    public Bounds bounds = new Bounds(Vector3.zero, Vector3.one);
    public bool adaptiveRes = true;
    public float voxelsPerUnit = 0.5f;
    public int resolutionX = 16;
    public int resolutionY = 16;
    public int resolutionZ = 16;
    public Encoding encoding = Encoding.Half4;
    public ShadowmaskEncoding shadowmaskEncoding = ShadowmaskEncoding.RGBA8;
    public bool firstLightIsAlwaysAlpha = false;
    public bool denoise = false;
    public bool isGlobal = false;
    public Texture3D bakedTexture0, bakedTexture1, bakedTexture2, bakedTexture3, bakedMask;
    public bool supportRotationAfterBake;
    public bool rotateAroundY;
    public bool _rotateAroundXYZ;

    public int multiVolumePriority = 0;

    public static BakeryVolume globalVolume;

    public static bool showAll = false;

#if UNITY_EDITOR
    // Visualization
    static int probesPreviewCount = 1;
    static int probesPreviewCountCached = -1;
    static Material probesPreviewMaterial;
    static ComputeBuffer probesPreviewPositionBuffer;
    static ComputeBuffer probesPreviewArgsBuffer;
    static uint[] args = new uint[5] { 0, 0, 0, 0, 0 };
    static Vector3[] probesPreviewPositions;
    static Vector3 probesPreviewResolution;
  
    public static bool showIndirectOnly = false;
    public static bool showProbesPreview = false;
    public static float probesPreviewMul = 1.0f;
    public static float probesPreviewSize = 0.15f;
    public static bool showBakedTexture = true;
    static Mesh probePreviewMesh; // shared mesh
    static bool callbackSet = false;
#endif
    
    /*private void OnDrawGizmosSelected()
    {
        if (showProbesPreview) return;
        Gizmos.color = new Color(0.4f, 1f, 0.0f, 0.15f);
        Gizmos.DrawCube( bounds.center , -bounds.size);
        Gizmos.color = new Color(1f, 0.7f, 0.2f, 0.22f);
        Gizmos.DrawCube( bounds.center , bounds.size);
    }*/

    Transform tform;

    public Vector3 GetMin()
    {
        if (rotateAroundY)
        {
            var sc = GetRotationY();
            var p = bounds.min - bounds.center;
            return new Vector3(p.x*sc.y + p.z*sc.x,
                               p.y,
                               p.x*-sc.x + p.z*sc.y) + bounds.center;
        }
        return bounds.min;
    }

    public Vector3 GetMax()
    {
        if (rotateAroundY)
        {
            var sc = GetRotationY();
            var p = bounds.max - bounds.center;
            return new Vector3(p.x*sc.y + p.z*sc.x,
                               p.y,
                               p.x*-sc.x + p.z*sc.y) + bounds.center;
        }
        return bounds.max;
    }

    Vector3 TransformPoint(Vector3 p, Vector3 center, Vector2 sc)
    {
        p -= center;
        return new Vector3(p.x*sc.y + p.z*sc.x,
                           p.y,
                           p.x*-sc.x + p.z*sc.y) + center;
    }

    public Vector4 GetWorldXZMinMax()
    {
        var bmin = bounds.min;
        var bmax = bounds.max;
        if (rotateAroundY)
        {
            var sc = GetRotationY();
            var center = bounds.center;
            var p00 = bounds.min;
            var p10 = new Vector3(bounds.max.x, 0, bounds.min.z);
            var p11 = bounds.max;
            var p01 = new Vector3(bounds.min.x, 0, bounds.max.z);

            p00 = TransformPoint(p00, center, sc);
            p10 = TransformPoint(p10, center, sc);
            p11 = TransformPoint(p11, center, sc);
            p01 = TransformPoint(p01, center, sc);

            float minx = Mathf.Min(Mathf.Min(Mathf.Min(p00.x, p10.x), p11.x), p01.x);
            float minz = Mathf.Min(Mathf.Min(Mathf.Min(p00.z, p10.z), p11.z), p01.z);

            float maxx = Mathf.Max(Mathf.Max(Mathf.Max(p00.x, p10.x), p11.x), p01.x);
            float maxz = Mathf.Max(Mathf.Max(Mathf.Max(p00.z, p10.z), p11.z), p01.z);

            return new Vector4(minx, minz, maxx, maxz);
        }
        return new Vector4(bmin.x, bmin.z, bmax.x, bmax.z);
    }

    public Vector3 GetMaxXMinZ()
    {
        if (rotateAroundY)
        {
            var sc = GetRotationY();
            var p = new Vector3(bounds.max.x, 0, bounds.min.z) - bounds.center;
            return new Vector3(p.x*sc.y + p.z*sc.x,
                               p.y,
                               p.x*-sc.x + p.z*sc.y) + bounds.center;
        }
        return bounds.max;
    }

    public Vector3 GetInvSize()
    {
        var b = bounds;
        return new Vector3(1.0f/b.size.x, 1.0f/b.size.y, 1.0f/b.size.z);;
    }

    public Matrix4x4 GetMatrix()
    {
        if (tform == null) tform = transform;
        return Matrix4x4.TRS(tform.position, tform.rotation, Vector3.one).inverse;
    }

    public Vector2 GetRotationY()
    {
        if (!rotateAroundY) return new Vector2(0,1);
        if (tform == null) tform = transform;
        float a = tform.eulerAngles.y * Mathf.Deg2Rad;
        return new Vector2(Mathf.Sin(a), Mathf.Cos(a));
    }

    public void SetGlobalParams()
    {
        Shader.SetGlobalTexture("_Volume0", bakedTexture0);
        Shader.SetGlobalTexture("_Volume1", bakedTexture1);
        Shader.SetGlobalTexture("_Volume2", bakedTexture2);
        if (bakedTexture3 != null) Shader.SetGlobalTexture("_Volume3", bakedTexture3);
        Shader.SetGlobalTexture("_VolumeMask", bakedMask);
        Shader.SetGlobalVector("_GlobalVolumeMin", GetMin());
        Shader.SetGlobalVector("_GlobalVolumeInvSize", GetInvSize());
        if (supportRotationAfterBake) Shader.SetGlobalMatrix("_GlobalVolumeMatrix", GetMatrix());
        if (rotateAroundY) Shader.SetGlobalVector("_GlobalVolumeRY", GetRotationY());
        if (bakedTexture0 != null) Shader.SetGlobalVector("_GlobalVolumeVoxelSize", new Vector3(1.0f/bakedTexture0.width, 1.0f/bakedTexture0.height, 1.0f/bakedTexture0.depth));
    }

    public void UpdateBounds()
    {
        var pos = transform.position;
        var size = bounds.size;
        bounds = new Bounds(pos, size);
    }

    public void OnEnable()
    {
        if (isGlobal)
        {
            globalVolume = this;
            SetGlobalParams();
        }
    }

#if UNITY_EDITOR
    static void ProbePreviewUpdate()
    {
        UnityEditor.SceneView.RepaintAll();
    }

    private void Update()
    {
        if (!showProbesPreview && callbackSet)
        {
            EditorApplication.update -= ProbePreviewUpdate;
            callbackSet = false;
            probesPreviewCountCached = -1;
        }
        else if (showProbesPreview && !callbackSet)
        {
            EditorApplication.update -= ProbePreviewUpdate;
            EditorApplication.update += ProbePreviewUpdate;
            callbackSet = true;
        }

        if (Selection.activeObject != gameObject || !showProbesPreview)
        {
            // Reset buffers
            probesPreviewCountCached = -1;
            return;
        }
        
        if (probePreviewMesh == null)
        {
            probePreviewMesh = GenerateSphereMesh();
        }
        
        var bakedTexPreview = showBakedTexture && bakedTexture0 != null;
        if (bakedTexPreview)
        {
            probesPreviewResolution = new Vector3(bakedTexture0.width, bakedTexture0.height, bakedTexture0.depth);
        }
        else
        {
            probesPreviewResolution = new Vector3(resolutionX, resolutionY, resolutionZ);
        }      
        
        probesPreviewCount = (int)(probesPreviewResolution.x * probesPreviewResolution.y * probesPreviewResolution.z);

        if (probesPreviewCountCached != probesPreviewCount || probesPreviewMaterial == null)
        {
            ProbesPreviewCreateResources();
            probesPreviewCountCached = probesPreviewCount;
        }
        
        var probesSize = probesPreviewSize / Mathf.Max(Mathf.Max(probesPreviewResolution.x / bounds.size.x,
                                    probesPreviewResolution.y / bounds.size.y),
                                    probesPreviewResolution.z / bounds.size.z);

        probesPreviewMaterial.SetFloat("_ProbeSize", probesSize);
        probesPreviewMaterial.SetFloat("_ProbeMul", probesPreviewMul);
        probesPreviewMaterial.SetVector("_GridPosition", bounds.center);
        probesPreviewMaterial.SetVector("_GridSize", bounds.size);
        probesPreviewMaterial.SetTexture("_VolumePreview0", bakedTexture0);
        probesPreviewMaterial.SetTexture("_VolumePreview1", bakedTexture1);
        probesPreviewMaterial.SetTexture("_VolumePreview2", bakedTexture2);
        probesPreviewMaterial.SetTexture("_VolumePreview3", bakedTexture3);
        probesPreviewMaterial.SetTexture("_VolumePreviewMask", bakedMask);
        
        float bakedMaskState = -1;
        if (bakedMask != null)
            bakedMaskState = shadowmaskEncoding == ShadowmaskEncoding.RGBA8 ? 1 : 2;
        if (showIndirectOnly)
            bakedMaskState = 0;

        probesPreviewMaterial.SetFloat("_ShadowMask", bakedMaskState);
        probesPreviewMaterial.SetFloat("_Encoding", (int)encoding);
        probesPreviewMaterial.SetFloat("_EmptyProbes", bakedTexPreview ? 0 : 1);
        probesPreviewMaterial.SetBuffer("positionBuffer", probesPreviewPositionBuffer);
        // bool isMobilePlatform = EditorUserBuildSettings.activeBuildTarget == BuildTarget.Android ||
        //                         EditorUserBuildSettings.activeBuildTarget == BuildTarget.iOS;
        // if(isMobilePlatform)
        //     probesPreviewMaterial.EnableKeyword("BAKERY_COMPRESSED_VOLUME_RGBM");
        // else
        //     probesPreviewMaterial.DisableKeyword("BAKERY_COMPRESSED_VOLUME_RGBM");
        
        Graphics.DrawMeshInstancedIndirect(probePreviewMesh, 0, probesPreviewMaterial, bounds, probesPreviewArgsBuffer);
    }
    
    private void ProbesPreviewCreateResources()
    {
        if (probesPreviewMaterial == null)
        {
            probesPreviewMaterial = new Material(Shader.Find("Hidden/ftVolumePreview"));
        }

        // Indirect args
        if (probesPreviewArgsBuffer != null) probesPreviewArgsBuffer.Release();
        probesPreviewArgsBuffer = new ComputeBuffer(1, args.Length * sizeof(uint), ComputeBufferType.IndirectArguments);
        args[0] = (uint)probePreviewMesh.GetIndexCount(0);
        args[1] = (uint)probesPreviewCount;
        args[2] = 0;//(uint)probePreviewMesh.GetIndexStart(0);
        args[3] = 0;//(uint)probePreviewMesh.GetBaseVertex(0);

        probesPreviewArgsBuffer.SetData(args);          
        
        // Positions
        if (probesPreviewPositionBuffer != null) probesPreviewPositionBuffer.Release();
        probesPreviewPositionBuffer = new ComputeBuffer(probesPreviewCount, 12);
        
        probesPreviewPositions = new Vector3[probesPreviewCount];
        int index = 0;
        for (int x = 0; x < probesPreviewResolution.x; x++)
        {
            for (int y = 0; y < probesPreviewResolution.y; y++)
            {
                for (int z = 0; z < probesPreviewResolution.z; z++)
                {
                    probesPreviewPositions[index] = new Vector3((x + 0.5f) / (float)probesPreviewResolution.x - 0.5f,
                        (y + 0.5f) / (float)probesPreviewResolution.y - 0.5f,
                        (z + 0.5f) / (float)probesPreviewResolution.z - 0.5f);
                    index++;
                }
            }
        }

        probesPreviewPositionBuffer.SetData(probesPreviewPositions);
    }
    
    void OnDestroy()
    {
        if (probesPreviewPositionBuffer != null) probesPreviewPositionBuffer.Release();
        probesPreviewPositionBuffer = null;

        if (probesPreviewArgsBuffer != null) probesPreviewArgsBuffer.Release();
        probesPreviewArgsBuffer = null;
    } 
    
    private static Mesh GenerateSphereMesh(int stacks = 4, int slices = 6, float radius = 0.5f)
    {
        int vertexCount = (stacks + 1) * (slices + 1);
        Vector3[] vertices = new Vector3[vertexCount];
        Vector3[] normal = new Vector3[vertexCount];
        List<int> indices = new List<int>();
        Mesh mesh = new Mesh();

        int index = 0;
        for (int stack = 0; stack <= stacks; stack++)
        {
            float thetaV = Mathf.PI * ((float)stack / (float)stacks);
            float r = radius * Mathf.Sin(thetaV);
            float y = radius * Mathf.Cos(thetaV);
            for (int slice = 0; slice <= slices; slice++)
            {
                float thetaH = 2.0f * Mathf.PI * ((float)slice / (float)slices);
                float x = r * Mathf.Cos(thetaH);
                float z = r * Mathf.Sin(thetaH);
                vertices[index] = new Vector3(x, y, z);

                index++;
            }
        }

        for (int stack = 0; stack < stacks; stack++)
        {
            for (int slice = 0; slice < slices; slice++)
            {
                int count = slice + ((slices + 1) * stack);

                indices.Add(count);
                indices.Add(count + 1);
                indices.Add(count + slices + 2);

                indices.Add(count);
                indices.Add(count + slices + 2);
                indices.Add(count + slices + 1);
            }
        }
	    
        for (int i = 0; i < vertices.Length; i++)
        {
            normal[i] = vertices[i].normalized;
        }

        mesh.vertices = vertices;
        mesh.normals = normal;
        mesh.triangles = indices.ToArray();
        //mesh.Optimize();
        MeshUtility.Optimize(mesh);
        mesh.RecalculateBounds();

        return mesh;
    }      
    
#endif

    void OnDrawGizmos()
    {
        if (!showAll) return;

        Gizmos.color = new Color(1, 1, 1, 0.35f);

        var tform = transform;
        if (rotateAroundY)
        {
            var e = tform.eulerAngles;
            var r = Quaternion.Euler(0, e.y, 0);
            Gizmos.matrix = Matrix4x4.TRS(r * -tform.position + tform.position, r, Vector3.one);
        }

        Gizmos.DrawWireCube(tform.position, bounds.size);
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/BakeryVolume.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/examples/scripts/BakeryVolumeReceiver.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2b3f9409bbd2d70498366efc67277202
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

// Example script, a counterpart to BakeryVolumeTrigger.cs (see that script for more info)
//
public class BakeryVolumeReceiver : MonoBehaviour
{
    public bool forceUsage = false;

    // used by triggers
    internal int enterCounter = 0;
    internal BakeryVolumeTrigger movableTrigger = null;

    Renderer[] renderers;
    MaterialPropertyBlock current;

    // Cache renderers affected by volumes
    void Awake()
    {
        if (renderers == null) renderers = GetComponentsInChildren<Renderer>() as Renderer[];
        if (forceUsage)
        {
            //  HDRP can sometimes (?) fail to use globally set volumes when SRP batching is enabled, so disable it for this object.
            SetPropertyBlock(new MaterialPropertyBlock());
        }
    }

    // Called by triggers
    public void SetPropertyBlock(MaterialPropertyBlock mb)
    {
        if (renderers == null) renderers = GetComponentsInChildren<Renderer>() as Renderer[];
        for(int i=0; i<renderers.Length; i++)
        {
            renderers[i].SetPropertyBlock(mb);
        }
        current = mb;
    }

    // Update shader properties here if the volume is moving
    void LateUpdate()
    {
        if (movableTrigger == null) return;

        movableTrigger.UpdateBounds();
        SetPropertyBlock(current);
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/examples/scripts/BakeryVolumeReceiver.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/examples/scripts/BakeryVolumeTrigger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 88131403915d92648ac25dbc4ffb0e1b
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

// Example volume switching script
//
// The high-level logic is following:
//
// - Volumes overlap each other a bit, so we don't need blending! The size of the overlap is the size of your largest dynamic object.
// - As object enters the volume, set volume data to it. Increment the counter.
// - As object leaves the volume, decrement the counter. If it equals 0, use global volume (set empty property block).
// - If the volume is moving, set volume data every frame, in LateUpdate.
//
public class BakeryVolumeTrigger : MonoBehaviour
{
    public bool movable;

    BakeryVolume vol;
    MaterialPropertyBlock mb; // current volume shader properties

    static MaterialPropertyBlock mbEmpty; // default empty block, no values (will revert to global volume)
    static int mVolumeMin, mVolumeInvSize; // shader property IDs

    void Awake()
    {
        if (mbEmpty == null) mbEmpty = new MaterialPropertyBlock();

        // Create a MaterialPropertyBlock with Volume parameters for future use
        vol = GetComponent<BakeryVolume>();
        mb = new MaterialPropertyBlock();
        if (vol.bakedTexture0 != null)
        {
            mb.SetTexture("_Volume0", vol.bakedTexture0);
            mb.SetTexture("_Volume1", vol.bakedTexture1);
            mb.SetTexture("_Volume2", vol.bakedTexture2);
            if (vol.bakedTexture3 != null) mb.SetTexture("_Volume3", vol.bakedTexture3);
        }
        if (vol.bakedMask != null) mb.SetTexture("_VolumeMask", vol.bakedMask);
        if (mVolumeMin == 0) mVolumeMin = Shader.PropertyToID("_VolumeMin");
        if (mVolumeInvSize == 0) mVolumeInvSize = Shader.PropertyToID("_VolumeInvSize");
        mb.SetVector(mVolumeMin, vol.GetMin());
        mb.SetVector(mVolumeInvSize, vol.GetInvSize());
        if (vol.supportRotationAfterBake) mb.SetMatrix("_VolumeMatrix", vol.GetMatrix());
        if (vol.rotateAroundY) mb.SetVector("_VolumeRY", vol.GetRotationY());
        mb.SetVector("_VolumeVoxelSize", new Vector3(1.0f/vol.bakedTexture0.width, 1.0f/vol.bakedTexture0.height, 1.0f/vol.bakedTexture0.depth));
    }

    // Apply MaterialPropertyBlock to renderers entering the trigger
    void OnTriggerEnter(Collider c)
    {
        var rcv = c.GetComponent<BakeryVolumeReceiver>();
        if (rcv == null) return;

        Debug.Log(c.name + " entered " + this.name);

        rcv.enterCounter++;
        rcv.movableTrigger = movable ? this : null;
        rcv.SetPropertyBlock(mb);
    }

    // Handle exiting the trigger
    void OnTriggerExit(Collider c)
    {
        var rcv = c.GetComponent<BakeryVolumeReceiver>();
        if (rcv == null) return;

        Debug.Log(c.name + " exited " + this.name);

        // Only set empty property block, if the counter is 0 (= exited ALL volumes)
        rcv.enterCounter--;
        if (rcv.enterCounter == 0) rcv.SetPropertyBlock(mbEmpty);
    }

    public void UpdateBounds()
    {
        vol.UpdateBounds();
        mb.SetVector(mVolumeMin, vol.GetMin());
        mb.SetVector(mVolumeInvSize, vol.GetInvSize());
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/examples/scripts/BakeryVolumeTrigger.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/examples/scripts/VolumeTestScene2.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f7a6f035f96fb254a92088728f6ac9f7
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class VolumeTestScene2 : MonoBehaviour
{
    public Transform secondFloor;
    public BakeryVolumeTrigger[] secondFloorVolumes;
    public float secondFloorHeight;
    public bool randomizeLastRoom;
    public Transform baseRoom;
    public Transform alternativeRoom;

    void SwapRooms()
    {
        var tmp = alternativeRoom.position;
        alternativeRoom.position = baseRoom.position;
        baseRoom.position = tmp;
    }

    void UpdateRooms()
    {
        for(int i=0; i<secondFloorVolumes.Length; i++)
        {
            secondFloorVolumes[i].UpdateBounds();
        }
    }

    void Start()
    {
        if (randomizeLastRoom)
        {
            if (Random.Range(0,2) == 1)
            {
                SwapRooms();
            }
        }

        secondFloor.position += Vector3.up * secondFloorHeight;

        UpdateRooms();
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            SwapRooms();
            UpdateRooms();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/examples/scripts/VolumeTestScene2.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/ftGlobalStorage.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c789d55c4f1cff34799abba03737e8f7
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
using UnityEngine;
using System.Collections.Generic;

#if UNITY_EDITOR
using UnityEditor;
#endif

public class ftGlobalStorage : ScriptableObject
{

#if UNITY_EDITOR

    [System.Serializable]
    public struct AdjustedMesh
    {
        //[SerializeField]
        //public string assetPath;

        [SerializeField]
        public List<string> meshName;

        [SerializeField]
        public List<int> padding;

        [SerializeField]
        public List<int> unwrapper;
    };

    [System.Serializable]
    public struct TagData
    {
        [SerializeField]
        public int tag;

        [SerializeField]
        public int renderMode;

        [SerializeField]
        public int renderDirMode;

        [SerializeField]
        public int bitmask;

        [SerializeField]
        public bool computeSSS;

        [SerializeField]
        public int sssSamples;

        [SerializeField]
        public float sssDensity;

        [SerializeField]
        public Color sssColor;

        [SerializeField]
        public bool transparentSelfShadow;
    };

    [System.Serializable]
    public enum Unwrapper
    {
        Default,
        xatlas
    };

    [System.Serializable]
    public enum AtlasPacker
    {
        Default,
        xatlas
    }

    [System.Serializable]
    public enum DenoiserType
    {
        Optix5 = 5, // "Legacy denoiser"
        Optix6 = 6, // Default denoiser
        Optix7 = 7, // New denoiser
        OpenImageDenoise = 100,
        OpenImageDenoise2 = 101
    };

    // UV adjustment

    [SerializeField]
    public List<string> modifiedAssetPathList = new List<string>();

    [SerializeField]
    public List<int> modifiedAssetPaddingHash = new List<int>();

    // Legacy
    [SerializeField]
    public List<Mesh> modifiedMeshList = new List<Mesh>();
    [SerializeField]
    public List<int> modifiedMeshPaddingList = new List<int>();

    [SerializeField]
    public List<AdjustedMesh> modifiedAssets = new List<AdjustedMesh>();

    // UV overlap marks

    [SerializeField]
    public List<string> assetList = new List<string>();

    [SerializeField]
    public List<int> uvOverlapAssetList = new List<int>(); // -1 = no UV1, 0 = no overlap, 1 = overlap

    [SerializeField]
    public bool xatlasWarningShown = false;

    [SerializeField]
    public bool foundCompatibleSetup = false;

    [SerializeField]
    public string gpuName = "";

    [SerializeField]
    public bool runsNonRTX = true;

    [SerializeField]
    public bool runsOptix5 = true;

    [SerializeField]
    public bool runsOptix6 = true;

    [SerializeField]
    public bool runsOptix7 = true;

    [SerializeField]
    public bool runsOIDN = true;

    [SerializeField]
    public bool runsOIDN2 = true;

    [SerializeField]
    public bool alwaysEnableRTX = false;

    [SerializeField]
    public bool checkerPreviewOn = false;

    [SerializeField]
    public bool rtSceneViewPreviewOn = false;

    // Defaults
    [SerializeField]
    public int renderSettingsBounces = 5;
    [SerializeField]
    public int renderSettingsGISamples = 16;
    [SerializeField]
    public float renderSettingsGIBackFaceWeight = 0;
    [SerializeField]
    public int renderSettingsTileSize = 512;
    [SerializeField]
    public float renderSettingsPriority = 2;
    [SerializeField]
    public float renderSettingsTexelsPerUnit = 20;
    [SerializeField]
    public bool renderSettingsForceRefresh = true;
    [SerializeField]
    public bool renderSettingsForceRebuildGeometry = true;
    [SerializeField]
    public bool renderSettingsPerformRendering = true;
    [SerializeField]
    public int renderSettingsUserRenderMode = 0;
    [SerializeField]
    public bool renderSettingsDistanceShadowmask = false;
    [SerializeField]
    public int renderSettingsSettingsMode = 0;
    [SerializeField]
    public bool renderSettingsFixSeams = true;
    [SerializeField]
    public bool renderSettingsDenoise = true;
    [SerializeField]
    public bool renderSettingsDenoise2x = false;
    [SerializeField]
    public bool renderSettingsEncode = true;
    [SerializeField]
    public int renderSettingsEncodeMode = 0;
    [SerializeField]
    public bool renderSettingsOverwriteWarning = false;
    [SerializeField]
    public bool renderSettingsAutoAtlas = true;
    [SerializeField]
    public bool renderSettingsUnwrapUVs = true;
    [SerializeField]
    public bool renderSettingsForceDisableUnwrapUVs = false;
    [SerializeField]
    public int renderSettingsMaxAutoResolution = 4096;
    [SerializeField]
    public int renderSettingsMinAutoResolution = 16;
    [SerializeField]
    public bool renderSettingsUnloadScenes = true;
    [SerializeField]
    public bool renderSettingsAdjustSamples = true;
    [SerializeField]
    public bool renderSettingsCheckOverlaps = false;
    [SerializeField]
    public bool renderSettingsSkipOutOfBoundsUVs = true;
    [SerializeField]
    public float renderSettingsHackEmissiveBoost = 1;
    [SerializeField]
    public float renderSettingsHackIndirectBoost = 1;
    [SerializeField]
    public string renderSettingsTempPath = "";
    [SerializeField]
    public string renderSettingsOutPath = "";
    [SerializeField]
    public bool renderSettingsUseScenePath = false;
    [SerializeField]
    public float renderSettingsHackAOIntensity = 0;
    [SerializeField]
    public int renderSettingsHackAOSamples = 16;
    [SerializeField]
    public bool renderSettingsHackAOSofter = false;
    [SerializeField]
    public float renderSettingsHackAORadius = 1;
    [SerializeField]
    public bool renderSettingsShowAOSettings = false;
    [SerializeField]
    public bool renderSettingsShowTasks = true;
    [SerializeField]
    public bool renderSettingsShowTasks2 = false;
    [SerializeField]
    public bool renderSettingsShowPaths = true;
    [SerializeField]
    public bool renderSettingsShowNet = true;
    [SerializeField]
    public bool renderSettingsShowSettingsAsset = true;
    [SerializeField]
    public bool renderSettingsShowAPV = false;
    [SerializeField]
    public bool renderSettingsUseAPVSkyOcclusion = false;
    [SerializeField]
    public bool renderSettingsOcclusionProbes = false;
    [SerializeField]
    public bool renderSettingsTexelsPerMap = false;
    [SerializeField]
    public float renderSettingsTexelsColor = 1;
    [SerializeField]
    public float renderSettingsTexelsMask = 1;
    [SerializeField]
    public float renderSettingsTexelsDir = 1;
    [SerializeField]
    public bool renderSettingsShowDirWarning = true;
    [SerializeField]
    public int renderSettingsRenderDirMode = 0;
    [SerializeField]
    public bool renderSettingsShowCheckerSettings = false;
    [SerializeField]
    public bool renderSettingsSamplesWarning = true;
    [SerializeField]
    public bool renderSettingsSuppressPopups = false;
    [SerializeField]
    public bool renderSettingsSectorWarning = false;
    [SerializeField]
    public bool renderSettingsPrefabWarning = true;
    [SerializeField]
    public bool renderSettingsSplitByScene = false;
    [SerializeField]
    public bool renderSettingsSplitByTag = false;
    [SerializeField]
    public bool renderSettingsUVPaddingMax = false;
    [SerializeField]
    public bool renderSettingsUVPaddingPreserveIfExisted = false;
    [SerializeField]
    public bool renderSettingsPostPacking = true;
    [SerializeField]
    public bool renderSettingsHoleFilling = false;
    [SerializeField]
    public bool renderSettingsBruteForce = true;
    [SerializeField]
    public bool renderSettingsAlphaDithering = false;
    [SerializeField]
    public bool renderSettingsBeepOnFinish = false;
    [SerializeField]
    public bool renderSettingsExportTerrainAsHeightmap = true;
    [SerializeField]
    public bool renderSettingsRTXMode = false;
    [SerializeField]
    public int renderSettingsLightProbeMode = 1;
    [SerializeField]
    public bool renderSettingsClientMode = false;
    [SerializeField]
    public string renderSettingsServerAddress = "127.0.0.1";
    [SerializeField]
    public int renderSettingsUnwrapper = 0;
    [SerializeField]
    public int renderSettingsDenoiserType = (int)DenoiserType.OpenImageDenoise;
    [SerializeField]
    public bool renderSettingsExportTerrainTrees = false;
    [SerializeField]
    public bool renderSettingsShowPerf = true;
    [SerializeField]
    public int renderSettingsSampleDiv = 1;
    //[SerializeField]
    //public bool renderSettingsLegacyDenoiser = false;
    [SerializeField]
    public AtlasPacker renderSettingsAtlasPacker = AtlasPacker.Default;
    [SerializeField]
    public bool renderSettingsBatchPoints = true;
    [SerializeField]
    public bool renderSettingsCompressVolumes = false;
    [SerializeField]
    public int renderSettingsBatchAreaLightSampleLimit = 0;
    [SerializeField]
    public bool renderSettingsRTPVExport = true;
    [SerializeField]
    public bool renderSettingsRTPVSceneView = false;
    [SerializeField]
    public bool renderSettingsRTPVHDR = false;
    [SerializeField]
    public int renderSettingsRTPVWidth = 640;
    [SerializeField]
    public int renderSettingsRTPVHeight = 360;
    [SerializeField]
    public float renderSettingsRTPVExposure = 1.0f;
    [SerializeField]
    public bool renderSettingsRemoveDuplicateLightmaps = false;
    // Tag overrides
    [SerializeField]
    public List<TagData> tagOverrides = new List<TagData>();

    // Temp

    public Dictionary<string, int> modifiedMeshMap;
    //public string modifiedMeshPaddingMapAssetName;
    public List<int> modifiedMeshPaddingArray;
    public List<int> modifiedMeshUnwrapperArray;

    // For parallel import
    //public List<string> texSettingsKey;
    //public List<Vector2> texSettingsVal;

    public void InitModifiedMeshMap(string assetPath) {

        modifiedMeshMap = new Dictionary<string, int>();

        var index = modifiedAssetPathList.IndexOf(assetPath);
        if (index < 0) return;
        var m = modifiedAssets[index];
        for(int j=0; j<m.meshName.Count; j++)
        {
            modifiedMeshMap[m.meshName[j]] = j;//m.padding[j];
        }

        modifiedMeshPaddingArray = m.padding;
        modifiedMeshUnwrapperArray = m.unwrapper;

        //modifiedMeshPaddingMapAssetName = assetPath;
    }

    public void ConvertFromLegacy()
    {
        for(int a=0; a<modifiedAssetPathList.Count; a++)
        {
            while(modifiedAssets.Count <= a)
            {
                var str = new AdjustedMesh();
                str.meshName = new List<string>();
                str.padding = new List<int>();
                modifiedAssets.Add(str);
            }
            var assetPath = modifiedAssetPathList[a];
            for(int i=0; i<modifiedMeshList.Count; i++) {
                var m = modifiedMeshList[i];
                if (m == null) continue;
                var mpath = AssetDatabase.GetAssetPath(m);
                if (mpath != assetPath) continue;

                modifiedAssets[a].meshName.Add(m.name);
                modifiedAssets[a].padding.Add(modifiedMeshPaddingList[i]);
            }
        }
        modifiedMeshList = new List<Mesh>();
        modifiedMeshPaddingList = new List<int>();
    }

    public int CalculatePaddingHash(int id)
    {
        string s = "";
        var list = modifiedAssets[id].padding;
        for(int i=0; i<list.Count; i++) s += list[i]+"_";
        return s.GetHashCode();
    }

    public TagData DefaultTagData()
    {
        var d = new TagData();
        d.renderMode = 1000; // auto
        d.renderDirMode = 1000; // auto
        d.computeSSS = false;
        d.sssSamples = 16;
        d.sssDensity = 10;
        d.sssColor = Color.white;
        d.transparentSelfShadow = false;
        d.bitmask = 1;
        return d;
    }

#if UNITY_2017_1_OR_NEWER
    public void SyncModifiedAsset(int index)
    {
        var importer = AssetImporter.GetAtPath(modifiedAssetPathList[index]) as ModelImporter;
        if (importer == null)
        {
            Debug.LogError("Can't get importer for " + modifiedAssetPathList[index]);
            return;
        }
        var data = modifiedAssets[index];
        var str = JsonUtility.ToJson(data);
        var props = importer.extraUserProperties;

        // check if Bakery properties already present
        int propID = -1;
        for(int i=0; i<props.Length; i++)
        {
            if (props[i].Substring(0,7) == "#BAKERY")
            {
                propID = i;
                break;
            }
        }

        if (propID < 0)
        {
            // keep existing properties
            var newProps = new string[props.Length + 1];
            for(int i=0; i<props.Length; i++) newProps[i] = props[i];
            props = newProps;
            propID = props.Length - 1;
        }

        props[propID] = "#BAKERY" + str;

        importer.extraUserProperties = props;
    }
#endif

    public void ClearAssetModifications(int index)
    {
        var importer = AssetImporter.GetAtPath(modifiedAssetPathList[index]) as ModelImporter;
        if (importer == null)
        {
            Debug.LogError("Can't get importer for " + modifiedAssetPathList[index]);
            return;
        }

        modifiedAssetPathList.RemoveAt(index);
        modifiedAssets.RemoveAt(index);
        modifiedAssetPaddingHash.RemoveAt(index);
        EditorUtility.SetDirty(this);

#if UNITY_2017_1_OR_NEWER
        var props = importer.extraUserProperties;
        if (props == null)
        {
            Debug.LogError("extraUserProperties is null");
            return;
        }
        var newProps = new List<string>();
        for(int i=0; i<props.Length; i++)
        {
            var prop = props[i];
            if (prop.Substring(0,7) != "#BAKERY")
            {
                newProps.Add(prop);
            }
        }
        importer.extraUserProperties = newProps.ToArray();
#endif

        importer.SaveAndReimport();
    }

#endif

}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/ftGlobalStorage.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/ftLightmaps.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7a45445dfd5b7b44cb9545da4e5ed41c
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
#define USE_TERRAINS

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

// Disable 'obsolete' warnings
#pragma warning disable 0618

#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.SceneManagement;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.IO;
#endif

using UnityEngine.SceneManagement;

#if UNITY_EDITOR
[InitializeOnLoad]
#endif
public class ftLightmaps {

    struct LightmapAdditionalData
    {
       public Texture2D rnm0, rnm1, rnm2;
       public int mode;
    };

    static List<int> lightmapRefCount;
    static List<LightmapAdditionalData> globalMapsAdditional;
    static int directionalMode = -1; // -1 undefined, 0 off, 1 on
    //static List<ftLightmapsStorage> loadedStorages;

#if UNITY_EDITOR
    public static bool mustReloadRenderSettings = false;
    static ftGlobalStorage gstorage;
    static ftLocalStorage lstorage;
    static BakeryProjectSettings pstorage;
    static bool editorUpdateCalled = false;

    public static string _bakeryRuntimePath = "";
    public static string _bakeryEditorPath = "";
    public static string GetRuntimePath()
    {
        if (_bakeryRuntimePath.Length == 0)
        {
            // Try default path
            // (start with AssetDatabase assuming it's faster than GetFiles)
            var a = AssetDatabase.LoadAssetAtPath("Assets/Bakery/ftDefaultAreaLightMat.mat", typeof(Material)) as Material;
            if (a == null)
            {
                // Find elsewhere
                var assetGUIDs = AssetDatabase.FindAssets("ftDefaultAreaLightMat", null);
                if (assetGUIDs.Length == 0)
                {
                    // No extra data present - find the script at least
                    var res = Directory.GetFiles(Application.dataPath, "ftLightmaps.cs", SearchOption.AllDirectories);
                    if (res.Length == 0)
                    {
                        Debug.LogError("Can't locate Bakery folder");
                        return "";
                    }
                    return "Assets" + res[0].Replace("ftLightmaps.cs", "").Replace("\\", "/").Replace(Application.dataPath, "");
                }
                if (assetGUIDs.Length > 1)
                {
                    Debug.LogError("ftDefaultAreaLightMat was found in more than one folder. Do you have multiple installations of Bakery?");
                }
                var guid = assetGUIDs[0];
                _bakeryRuntimePath = System.IO.Path.GetDirectoryName(AssetDatabase.GUIDToAssetPath(guid)) + "/";
                return _bakeryRuntimePath;
            }
            _bakeryRuntimePath = "Assets/Bakery/";
        }
        return _bakeryRuntimePath;
    }

    public static string GetEditorPath()
    {
        if (_bakeryEditorPath.Length == 0)
        {
            // Try default path
            var a = AssetDatabase.LoadAssetAtPath("Assets/Editor/x64/Bakery/NormalsFittingTexture_dds", typeof(Object));
            if (a == null)
            {
                // Find elsewhere
                var assetGUIDs = AssetDatabase.FindAssets("NormalsFittingTexture_dds", null);
                if (assetGUIDs.Length == 0)
                {
                    // No extra data present - find ftModelPostProcessor at least (minimum required editor script)
                    var res = Directory.GetFiles(Application.dataPath, "ftModelPostProcessor.cs", SearchOption.AllDirectories);
                    if (res.Length == 0)
                    {
                        Debug.LogError("Can't locate Bakery folder");
                        return "";
                    }
                    return "Assets" + res[0].Replace("ftModelPostProcessor.cs", "").Replace("\\", "/").Replace(Application.dataPath, "");
                }
                if (assetGUIDs.Length > 1)
                {
                    Debug.LogError("NormalsFittingTexture_dds was found in more than one folder. Do you have multiple installations of Bakery?");
                }
                var guid = assetGUIDs[0];
                _bakeryEditorPath = System.IO.Path.GetDirectoryName(AssetDatabase.GUIDToAssetPath(guid)) + "/";
                return _bakeryEditorPath;
            }
            _bakeryEditorPath = "Assets/Editor/x64/Bakery/";
        }
        return _bakeryEditorPath;
    }

    public static string GetProjectSettingsPathOld()
    {
        return "Assets/Settings/";
    }

    public static string GetProjectSettingsPathNew()
    {
        var path = GetRuntimePath();
        for(int i=path.Length-2; i>=0; i--)
        {
            char c = path[i];
            if (c == '/' || c == '\\')
            {
                path = path.Substring(0, i);
                break;
            }
        }
        return path + "/Settings/";
    }

    public static ftGlobalStorage GetGlobalStorage()
    {
        if (gstorage != null) return gstorage;
        var bakeryRuntimePath = GetRuntimePath();
        gstorage = AssetDatabase.LoadAssetAtPath(bakeryRuntimePath + "ftGlobalStorage.asset", typeof(ftGlobalStorage)) as ftGlobalStorage;
        if (gstorage == null && editorUpdateCalled) // if editorUpdateCalled==false, it may be not imported yet
        {
            var gstorageDefault = AssetDatabase.LoadAssetAtPath(bakeryRuntimePath + "ftDefaultGlobalStorage.asset", typeof(ftGlobalStorage)) as ftGlobalStorage;

            if (gstorageDefault != null)
            {
                if (AssetDatabase.CopyAsset(bakeryRuntimePath + "ftDefaultGlobalStorage.asset", bakeryRuntimePath + "ftGlobalStorage.asset"))
                {
                    AssetDatabase.Refresh();
                    gstorage = AssetDatabase.LoadAssetAtPath(bakeryRuntimePath + "ftGlobalStorage.asset", typeof(ftGlobalStorage)) as ftGlobalStorage;
                }
            }

            if (gstorage == null)
            {
                Debug.Log("Created Bakery GlobalStorage");
                gstorage = ScriptableObject.CreateInstance<ftGlobalStorage>();
                AssetDatabase.CreateAsset(gstorage, bakeryRuntimePath + "ftGlobalStorage.asset");
                AssetDatabase.SaveAssets();
            }
            else
            {
                Debug.Log("Created Bakery GlobalStorage from DefaultGlobalStorage");
            }
        }

        if (gstorage != null)
        {
            if (gstorage.modifiedMeshList.Count > 0)
            {
                gstorage.ConvertFromLegacy();
            }
        }

        return gstorage;
    }

    static ftLocalStorage GetLocalStorage()
    {
        if (lstorage != null) return lstorage;
        var bakeryRuntimePath = GetRuntimePath();
        lstorage = AssetDatabase.LoadAssetAtPath(bakeryRuntimePath + "ftLocalStorage.asset", typeof(ftLocalStorage)) as ftLocalStorage;
        if (lstorage == null)
        {
            Debug.Log("Created Bakery LocalStorage");
            lstorage = ScriptableObject.CreateInstance<ftLocalStorage>();
            AssetDatabase.CreateAsset(lstorage, bakeryRuntimePath + "ftLocalStorage.asset");
            AssetDatabase.SaveAssets();
        }
        return lstorage;
    }

    public static BakeryProjectSettings GetProjectSettings()
    {
        if (pstorage != null) return pstorage;
        var path = GetProjectSettingsPathOld();
        if (!Directory.Exists(path))
        {
            path = GetProjectSettingsPathNew();
            if (!Directory.Exists(path))
            {
                Directory.CreateDirectory(path);
            }
        }
        pstorage = AssetDatabase.LoadAssetAtPath(path + "BakeryProjectSettings.asset", typeof(BakeryProjectSettings)) as BakeryProjectSettings;
        if (pstorage == null)
        {
            Debug.Log("Created Bakery ProjectSettings");
            pstorage = ScriptableObject.CreateInstance<BakeryProjectSettings>();
            AssetDatabase.CreateAsset(pstorage, path + "BakeryProjectSettings.asset");
            AssetDatabase.SaveAssets();
        }
        return pstorage;
    }

    static void CreateGlobalStorageAsset()
    {
        if (gstorage == null) gstorage = GetGlobalStorage();
        if (lstorage == null) lstorage = GetLocalStorage();

        if (Application.isPlaying) return;

        var listToProccess = gstorage.modifiedAssetPathList;
        var listToProcessHash = gstorage.modifiedAssetPaddingHash;
        var listProcessed = lstorage.modifiedAssetPathList;
        var listProcessedHash = lstorage.modifiedAssetPaddingHash;
        for(int i=0; i<listToProccess.Count; i++)
        {
            int localID = listProcessed.IndexOf(listToProccess[i]);
            if (localID >= 0)
            {
                if (listToProcessHash.Count > i)
                {
                    int globalPaddingHash = listToProcessHash[i];
                    if (listProcessedHash.Count > localID)
                    {
                        int localPaddingHash = listProcessedHash[localID];
                        if (globalPaddingHash == localPaddingHash)
                        {
                            continue;
                        }
                    }
                }
                else
                {
                    // Hash is not initialized = legacy
                    continue;
                }
            }

#if UNITY_2017_1_OR_NEWER
            var importer = AssetImporter.GetAtPath(listToProccess[i]) as ModelImporter;
            if (importer != null)
            {
                var props = importer.extraUserProperties;
                int propID = -1;
                for(int p=0; p<props.Length; p++)
                {
                    if (props[p].Substring(0,7) == "#BAKERY")
                    {
                        propID = p;
                        break;
                    }
                }
                if (propID >= 0) continue; // should be fine without additional reimport - metadata is always loaded with model
            }
#endif

            var asset = AssetDatabase.LoadAssetAtPath(listToProccess[i], typeof(GameObject)) as GameObject;
            if (asset == null) continue;
            if (asset.tag == "BakeryProcessed") continue; // legacy
            //if (asset.tag != "BakeryProcessed") AssetDatabase.ImportAsset(list[i], ImportAssetOptions.ForceUpdate);
            Debug.Log("Reimporting to adjust UVs: " + listToProccess[i]);
            AssetDatabase.ImportAsset(listToProccess[i], ImportAssetOptions.ForceUpdate);
        }
    }

    /*public static bool IsModelProcessed(string path)
    {
        if (lstorage == null) lstorage = GetLocalStorage();
        var listProcessed = lstorage.modifiedAssetPathList;
        return listProcessed.Contains(path);
    }*/

    public static void MarkModelProcessed(string path, bool enabled)
    {
        if (lstorage == null) lstorage = GetLocalStorage();
        if (gstorage == null) gstorage = GetGlobalStorage();
        if (enabled)
        {
            int gid = gstorage.modifiedAssetPathList.IndexOf(path);
            if (gid < 0) return;
            int hash = gstorage.CalculatePaddingHash(gid);
            while(gstorage.modifiedAssetPaddingHash.Count <= gid) gstorage.modifiedAssetPaddingHash.Add(0);
            gstorage.modifiedAssetPaddingHash[gid] = hash;

            int id = lstorage.modifiedAssetPathList.IndexOf(path);
            if (id < 0)
            {
                lstorage.modifiedAssetPathList.Add(path);
                id = lstorage.modifiedAssetPathList.Count - 1;
            }
            while(lstorage.modifiedAssetPaddingHash.Count <= id) lstorage.modifiedAssetPaddingHash.Add(0);
            lstorage.modifiedAssetPaddingHash[id] = hash;
            EditorUtility.SetDirty(gstorage);
            EditorSceneManager.MarkAllScenesDirty();
        }
        else
        {
            int id = lstorage.modifiedAssetPathList.IndexOf(path);
            if (id >= 0)
            {
                lstorage.modifiedAssetPathList.RemoveAt(id);
                if (lstorage.modifiedAssetPaddingHash.Count > id) lstorage.modifiedAssetPaddingHash.RemoveAt(id);
            }
        }
        EditorUtility.SetDirty(lstorage);
    }

#endif

    static ftLightmaps() {

#if UNITY_EDITOR
        EditorSceneManager.sceneOpening -= OnSceneOpening; // Andrew fix
        EditorSceneManager.sceneOpening += OnSceneOpening;

        EditorApplication.update -= FirstUpdate; // Andrew fix
        EditorApplication.update += FirstUpdate;

        EditorApplication.hierarchyWindowChanged -= OnSceneChangedEditor;
        EditorApplication.hierarchyWindowChanged += OnSceneChangedEditor;
#endif

        SceneManager.activeSceneChanged -= OnSceneChangedPlay;
        SceneManager.activeSceneChanged += OnSceneChangedPlay;
    }

#if UNITY_EDITOR
    static void FirstUpdate()
    {
        editorUpdateCalled = true;
        CreateGlobalStorageAsset();
        GetProjectSettings();
        EditorApplication.update -= FirstUpdate;
    }
#endif

    static void SetDirectionalMode()
    {
        if (directionalMode >= 0) LightmapSettings.lightmapsMode =  directionalMode==1 ? LightmapsMode.CombinedDirectional : LightmapsMode.NonDirectional;
    }

    static void OnSceneChangedPlay(Scene prev, Scene next) {
        //if (Lightmapping.lightingDataAsset == null) {
            SetDirectionalMode();
        //}
    }

#if UNITY_EDITOR
    static void OnSceneChangedEditor() {
        // Unity can modify directional mode on scene change, have to force the correct one
        // activeSceneChangedInEditMode isn't always available
        //if (Lightmapping.lightingDataAsset == null) {
            SetDirectionalMode();
        //}
    }

    // using Opening instead of Opened because it's called before lightmap data is loaded and proper directional mode is set
    //static void OnSceneOpened(Scene scene, OpenSceneMode mode) {
    static void OnSceneOpening(string path, OpenSceneMode mode) {
        //Refresh();
        //if (scene.name == "_tempScene") return;
        if (Path.GetFileNameWithoutExtension(path) == "_tempScene") return;
        mustReloadRenderSettings = true;
        directionalMode = -1;
        /*if (!finalInitDone)
        {
            CreateGlobalStorageAsset();
            finalInitDone = true;
        }*/
    }
#endif

    public static void RefreshFull()
    {
        var activeScene = SceneManager.GetActiveScene();
        var sceneCount = SceneManager.sceneCount;

        for(int i=0; i<sceneCount; i++)
        {
            var scene = SceneManager.GetSceneAt(i);
            if (!scene.isLoaded) continue;
#if UNITY_6000_0_OR_NEWER
            if (scene.isSubScene) continue;
#endif
            SceneManager.SetActiveScene(scene);
            if (!FindInScene("!ftraceLightmaps", scene)) continue;
            LightmapSettings.lightmaps = new LightmapData[0];
        }

        for(int i=0; i<sceneCount; i++)
        {
            var scene = SceneManager.GetSceneAt(i);
#if UNITY_6000_0_OR_NEWER
            if (scene.isSubScene) continue;
#endif
            RefreshScene(scene, null, true);
        }
        SceneManager.SetActiveScene(activeScene);
    }

    public static GameObject FindInScene(string nm, Scene scn)
    {
        var objs = scn.GetRootGameObjects();
        for(int i=0; i<objs.Length; i++)
        {
            if (objs[i].name == nm) return objs[i];
            var obj = objs[i].transform.Find(nm);
            if (obj != null) return obj.gameObject;
        }
        return null;
    }

/*    public static void RefreshScene(int sceneID, ref List<LightmapData> lmaps, int lmCounter) {
        RefreshScene(scene);
    }*/

    static Texture2D GetEmptyDirectionTex(ftLightmapsStorage storage)
    {
#if UNITY_EDITOR
        if (storage.emptyDirectionTex == null)
        {
            var bakeryRuntimePath = GetRuntimePath();
            storage.emptyDirectionTex = AssetDatabase.LoadAssetAtPath(bakeryRuntimePath + "emptyDirection.tga", typeof(Texture2D)) as Texture2D;
        }
#endif
        return storage.emptyDirectionTex;
    }

    public static void RefreshScene(Scene scene, ftLightmapsStorage storage = null, bool updateNonBaked = false, bool incrementRefcount = false) {
        var sceneCount = SceneManager.sceneCount;

        if (globalMapsAdditional == null) globalMapsAdditional = new List<LightmapAdditionalData>();

        var lmaps = new List<LightmapData>();
        var lmapsAdditional = new List<LightmapAdditionalData>();
        var existingLmaps = LightmapSettings.lightmaps;
        var existingLmapsAdditional = globalMapsAdditional;

        // Acquire storage
        if (storage == null)
        {
            if (!scene.isLoaded)
            {
                //Debug.LogError("dbg: Scene not loaded");
                return;
            }
            SceneManager.SetActiveScene(scene);

            var go = FindInScene("!ftraceLightmaps", scene);
            if (go==null) {
                //Debug.LogError("dbg: no storage");
                return;
            }

            storage = go.GetComponent<ftLightmapsStorage>();
            if (storage == null) {
                //Debug.LogError("dbg: no storage 2");
                return;
            }
        }
        if (storage.idremap == null || storage.idremap.Length != storage.maps.Count)
        {
            storage.idremap = new int[storage.maps.Count];
        }

        // Decide which global engine lightmapping mode to use
        // TODO: allow mixing different modes
        directionalMode = storage.dirMaps.Count != 0 ? 1 : 0;
        bool patchedDirection = false;
        SetDirectionalMode();

        // Set dummy directional tex for non-directional lightmaps in directional mode
        if (directionalMode == 1)
        {
            for(int i=0; i<existingLmaps.Length; i++)
            {
                if (existingLmaps[i].lightmapDir == null)
                {
                    var lm = existingLmaps[i];
                    lm.lightmapDir = GetEmptyDirectionTex(storage);
                    existingLmaps[i] = lm;
                    patchedDirection = true;
                }
            }
        }

        // Detect if changes to lightmap array are necessary
        bool sameArray = false;
        if (existingLmaps.Length == storage.maps.Count)
        {
            sameArray = true;
            for(int i=0; i<storage.maps.Count; i++)
            {
                if (existingLmaps[i].lightmapColor != storage.maps[i])
                {
                    sameArray = false;
                    break;
                }
                if (storage.rnmMaps0.Count > i && (existingLmapsAdditional.Count <= i || existingLmapsAdditional[i].rnm0 != storage.rnmMaps0[i]))
                {
                    sameArray = false;
                    break;
                }
            }
        }

        if (!sameArray) // create new lightmap array
        {
            if (sceneCount >= 1)
            {
                // first add old
                for(int i=0; i<existingLmaps.Length; i++) {
                    // skip empty lightmaps (can be created by 5.6 ldata asset or vertex color)
                    // ... unless there are valid lightmaps around them
                    bool lightmapIsEmpty = existingLmaps[i] == null || (existingLmaps[i].lightmapColor == null && existingLmaps[i].shadowMask == null);
                    bool lightmapCanBeSkipped = lightmapIsEmpty && (i == 0 || i == existingLmaps.Length - 1);
                    if (!lightmapCanBeSkipped)
                    {
                        lmaps.Add(existingLmaps[i]);
                        if (existingLmapsAdditional.Count > i) lmapsAdditional.Add(existingLmapsAdditional[i]);
                    }
                }
            }

            for(int i=0; i<storage.maps.Count; i++) {

                var texlm = storage.maps[i];
                Texture2D texmask = null;
                Texture2D texdir = null;
                Texture2D texrnm0 = null;
                Texture2D texrnm1 = null;
                Texture2D texrnm2 = null;
                int mapMode = 0;
                if (storage.masks.Count > i) texmask = storage.masks[i];
                if (storage.dirMaps.Count > i) texdir = storage.dirMaps[i];
                if (storage.rnmMaps0.Count > i)
                {
                    texrnm0 = storage.rnmMaps0[i];
                    texrnm1 = storage.rnmMaps1[i];
                    texrnm2 = storage.rnmMaps2[i];
                    mapMode = storage.mapsMode[i];
                }

                bool found = false;
                int firstEmpty = -1;
                for(int j=0; j<lmaps.Count; j++) {
                    if (lmaps[j].lightmapColor == texlm && lmaps[j].shadowMask == texmask)
                    {
                        // lightmap already added - reuse
                        storage.idremap[i] = j;
                        found = true;

                        //Debug.LogError("reused "+j);

                        // additional maps array could be flushed due to script recompilation - recover
                        if (texrnm0 != null && (lmapsAdditional.Count <= j || lmapsAdditional[j].rnm0 == null))
                        {
                            while(lmapsAdditional.Count <= j) lmapsAdditional.Add(new LightmapAdditionalData());
                            var l = new LightmapAdditionalData();
                            l.rnm0 = texrnm0;
                            l.rnm1 = texrnm1;
                            l.rnm2 = texrnm2;
                            l.mode = mapMode;
                            lmapsAdditional[j] = l;
                        }

                        break;
                    }
                    else if (firstEmpty < 0 && lmaps[j].lightmapColor == null && lmaps[j].shadowMask == null)
                    {
                        // free (deleted) entry in existing lightmap list - possibly reuse
                        storage.idremap[i] = j;
                        firstEmpty = j;
                    }
                }

                if (!found)
                {
                    LightmapData lm;
                    if (firstEmpty >= 0)
                    {
                        lm = lmaps[firstEmpty];
                    }
                    else
                    {
                        lm = new LightmapData();
                    }

                    lm.lightmapColor = texlm;
                    if (storage.masks.Count > i)
                    {
                        lm.shadowMask = texmask;
                    }
                    if (storage.dirMaps.Count > i && texdir != null)
                    {
                        lm.lightmapDir = texdir;
                    }
                    else if (directionalMode == 1)
                    {
                        lm.lightmapDir = GetEmptyDirectionTex(storage);
                    }

                    if (firstEmpty < 0)
                    {
                        lmaps.Add(lm);
                        storage.idremap[i] = lmaps.Count - 1;
                    }
                    else
                    {
                        lmaps[firstEmpty] = lm;
                    }

                    if (storage.rnmMaps0.Count > i)
                    {
                        var l = new LightmapAdditionalData();
                        l.rnm0 = texrnm0;
                        l.rnm1 = texrnm1;
                        l.rnm2 = texrnm2;
                        l.mode = mapMode;

                        if (firstEmpty < 0)
                        {
                            //Debug.LogError("added "+(lmaps.Count-1));
                            while(lmapsAdditional.Count < lmaps.Count-1) lmapsAdditional.Add(new LightmapAdditionalData());
                            lmapsAdditional.Add(l);
                        }
                        else
                        {
                            //Debug.LogError("set " + firstEmpty);
                            while(lmapsAdditional.Count < firstEmpty+1) lmapsAdditional.Add(new LightmapAdditionalData());
                            lmapsAdditional[firstEmpty] = l;
                        }
                    }
                }
            }
        }
        else // reuse existing lightmap array, only remap IDs
        {
            for(int i=0; i<storage.maps.Count; i++) {
                storage.idremap[i] = i;

                //Debug.LogError("full reuse");

                /*if (storage.rnmMaps0.Count > i)
                {
                    var l = new LightmapAdditionalData();
                    l.rnm0 = storage.rnmMaps0[i];
                    l.rnm1 = storage.rnmMaps1[i];
                    l.rnm2 = storage.rnmMaps2[i];
                    l.mode = storage.mapsMode[i];
                    lmapsAdditional.Add(l);
                }*/
            }
        }

#if UNITY_EDITOR
        // Set editor lighting mode
        if (storage.bakedRenderers != null && storage.bakedRenderers.Count > 0)
        {
            Lightmapping.giWorkflowMode = Lightmapping.GIWorkflowMode.OnDemand;
            Lightmapping.realtimeGI = storage.usesRealtimeGI;
            //Lightmapping.bakedGI = true; // ? only used for enlighten ? makes editor laggy ?
        }
#endif

        // Replace the lightmap array if needed
        if (sameArray && patchedDirection) LightmapSettings.lightmaps = existingLmaps;
        if (!sameArray)
        {
            LightmapSettings.lightmaps = lmaps.ToArray();
            globalMapsAdditional = lmapsAdditional;
        }

        /*
        // Debug
        var lms = LightmapSettings.lightmaps;
        for(int i=0; i<lms.Length; i++)
        {
            var name1 = ((lms[i]==null || lms[i].lightmapColor==null) ? "-" : lms[i].lightmapColor.name);
            var name2 = (globalMapsAdditional.Count > i ?(globalMapsAdditional[i].rnm0==null?"x":globalMapsAdditional[i].rnm0.name) : "-");
            Debug.LogError(i+" "+name1+" "+name2);
        }
        */

        // Attempt to update skybox probe
        if (RenderSettings.ambientMode == UnityEngine.Rendering.AmbientMode.Skybox)// && Lightmapping.lightingDataAsset == null)
        {
            var probe = RenderSettings.ambientProbe ;
            int isEmpty = -1;
            for(int i=0; i<3; i++)
            {
                for(int j=0; j<9; j++)
                {
                    // default bugged probes are [almost] black or 1302?
                    float a = Mathf.Abs(probe[i,j]);
                    if (a > 1000.0f || a < 0.000001f)
                    {
                        isEmpty = 1;
                        break;
                    }
                    if (probe[i,j] != 0)
                    {
                        isEmpty = 0;
                        break;
                    }
                }
                if (isEmpty >= 0) break;
            }
            if (isEmpty != 0)
            {
               DynamicGI.UpdateEnvironment();
            }
        }

        // Set lightmap data on mesh renderers
        var emptyVec4 = new Vector4(1,1,0,0);
        for(int i=0; i<storage.bakedRenderers.Count; i++)
        {
            var r = storage.bakedRenderers[i];
            if (r == null)
            {
                continue;
            }
            //if (r.isPartOfStaticBatch) continue;
            var id = storage.bakedIDs[i];
            Mesh vmesh = null;
            if (i < storage.bakedVertexColorMesh.Count) vmesh = storage.bakedVertexColorMesh[i];

            if (vmesh != null)
            {
                var r2 = r as MeshRenderer;
                if (r2 == null)
                {
                    Debug.LogError("Unity cannot use additionalVertexStreams on non-MeshRenderer");
                }
                else
                {
                    r2.additionalVertexStreams = vmesh;
                    r2.lightmapIndex = 0xFFFF;
                    var prop = new MaterialPropertyBlock();
                    prop.SetFloat("bakeryLightmapMode", 1);
                    r2.SetPropertyBlock(prop);
                }
                continue;
            }

            int globalID = (id < 0 || id >= storage.idremap.Length) ? id : storage.idremap[id];
            r.lightmapIndex = globalID;

            if (!r.isPartOfStaticBatch)
            {
                // scaleOffset is baked on static batches already
                var scaleOffset = id < 0 ? emptyVec4 : storage.bakedScaleOffset[i];
                r.lightmapScaleOffset = scaleOffset;
            }

            if (r.lightmapIndex >= 0 && globalID < globalMapsAdditional.Count)
            {
                var lmap = globalMapsAdditional[globalID];
                if (lmap.rnm0 != null)
                {
                    var prop = new MaterialPropertyBlock();
                    prop.SetTexture("_RNM0", lmap.rnm0);
                    prop.SetTexture("_RNM1", lmap.rnm1);
                    prop.SetTexture("_RNM2", lmap.rnm2);
                    prop.SetFloat("bakeryLightmapMode", lmap.mode);
                    r.SetPropertyBlock(prop);
                }
            }
        }

        // Set lightmap data on definitely-not-baked mesh renderers (can be possibly avoided)
        if (updateNonBaked)
        {
            for(int i=0; i<storage.nonBakedRenderers.Count; i++)
            {
                var r = storage.nonBakedRenderers[i];
                if (r == null) continue;
                if (r.isPartOfStaticBatch) continue;
                r.lightmapIndex = 0xFFFE;
            }
        }

#if USE_TERRAINS
        // Set lightmap data on terrains
        for(int i=0; i<storage.bakedRenderersTerrain.Count; i++)
        {
            var r = storage.bakedRenderersTerrain[i];
            if (r == null)
            {
                continue;
            }
            var id = storage.bakedIDsTerrain[i];
            r.lightmapIndex = (id < 0 || id >= storage.idremap.Length) ? id : storage.idremap[id];

            var scaleOffset = id < 0 ? emptyVec4 : storage.bakedScaleOffsetTerrain[i];
            r.lightmapScaleOffset = scaleOffset;

            if (r.lightmapIndex >= 0 && r.lightmapIndex < globalMapsAdditional.Count)
            {
                var lmap = globalMapsAdditional[r.lightmapIndex];
                if (lmap.rnm0 != null)
                {
                    var prop = new MaterialPropertyBlock();
                    prop.SetTexture("_RNM0", lmap.rnm0);
                    prop.SetTexture("_RNM1", lmap.rnm1);
                    prop.SetTexture("_RNM2", lmap.rnm2);
                    prop.SetFloat("bakeryLightmapMode", lmap.mode);
                    r.SetSplatMaterialPropertyBlock(prop);
                }
            }
        }
#endif

        // Set shadowmask parameters on lights
        for(int i=0; i<storage.bakedLights.Count; i++)
        {
#if UNITY_2017_3_OR_NEWER
            if (storage.bakedLights[i] == null) continue;

            int channel = storage.bakedLightChannels[i];
            var output = new LightBakingOutput();
            output.isBaked = true;
            if (channel < 0)
            {
                output.lightmapBakeType = LightmapBakeType.Baked;
            }
            else
            {
                output.lightmapBakeType = LightmapBakeType.Mixed;
                output.mixedLightingMode = channel >= 100 ? MixedLightingMode.Subtractive : MixedLightingMode.Shadowmask;
                output.occlusionMaskChannel = channel >= 100 ? (channel-100) : channel;
                output.probeOcclusionLightIndex  = storage.bakedLights[i].bakingOutput.probeOcclusionLightIndex;
            }
            storage.bakedLights[i].bakingOutput = output;
#endif
        }

        // Increment lightmap refcounts
        if (incrementRefcount)
        {
            if (lightmapRefCount == null) lightmapRefCount = new List<int>();
            for(int i=0; i<storage.idremap.Length; i++)
            {
                int currentID = storage.idremap[i];
                while(lightmapRefCount.Count <= currentID) lightmapRefCount.Add(0);
                if (lightmapRefCount[currentID] < 0) lightmapRefCount[currentID] = 0;
                lightmapRefCount[currentID]++;
            }
        }
        //if (loadedStorages == null) loadedStorages = new List<ftLightmapsStorage>();
        //if (loadedStorages.Contains(storage)) loadedStorages.Add(storage);

        //return appendOffset;
    }

    public static void UnloadScene(ftLightmapsStorage storage)
    {
        if (lightmapRefCount == null) return;
        if (storage.idremap == null) return;

        //int idx = loadedStorages.IndexOf(storage);
        //if (idx >= 0) loadedStorages.RemoveAt(idx);

        LightmapData[] existingLmaps = null;
        List<LightmapAdditionalData> existingLmapsAdditional = null;
        //bool rebuild = false;
        for(int i=0; i<storage.idremap.Length; i++)
        {
            int currentID = storage.idremap[i];

            // just never unload the 1st lightmap to prevent Unity from losing LM encoding settings
            // remapping all IDs at runtime would introduce a perf hiccup
            if (currentID == 0) continue;

            if (lightmapRefCount.Count <= currentID) continue;
            lightmapRefCount[currentID]--;
            //Debug.LogError("rem: "+currentID+" "+lightmapRefCount[currentID]);
            if (lightmapRefCount[currentID] == 0)
            {
                if (existingLmaps == null) existingLmaps = LightmapSettings.lightmaps;

                if (existingLmaps.Length > currentID)
                {
                    existingLmaps[currentID].lightmapColor = null;
                    existingLmaps[currentID].lightmapDir = null;
                    existingLmaps[currentID].shadowMask = null;

                    if (existingLmapsAdditional == null) existingLmapsAdditional = globalMapsAdditional;
                    if (existingLmapsAdditional != null && existingLmapsAdditional.Count > currentID)
                    {
                        var emptyEntry = new LightmapAdditionalData();
                        existingLmapsAdditional[currentID] = emptyEntry;
                    }
                }
                //if (currentID == 0) rebuild = true;
            }
        }

        /*
        // If the first lightmap was unloaded, we need to rebuild the lightmap array
        // because Unity uses 1st lightmap to determine encoding
        if (rebuild)
        {
            int newLength = 0;
            for(int i=0; i<existingLmaps.Length; i++)
            {
                if (existingLmaps[i].lightmapColor != null) newLength++;
            }
            var existingLmaps2 = new LightmapData[newLength];
            int ctr = 0;
            for(int i=0; i<existingLmaps.Length; i++)
            {
                if (existingLmaps[i].lightmapColor != null)
                {
                    existingLmaps2[ctr] = existingLmaps[i];
                    ctr++;
                }
            }
            existingLmaps = existingLmaps2;

            for(int i=0; i<)
        }
        */

        if (existingLmaps != null) LightmapSettings.lightmaps = existingLmaps;
    }

    public static void RefreshScene2(Scene scene, ftLightmapsStorage storage)
    {
        Renderer r;
        int id;
        for(int i=0; i<storage.bakedRenderers.Count; i++)
        {
            r = storage.bakedRenderers[i];
            if (r == null) continue;

            id = storage.bakedIDs[i];
            r.lightmapIndex = (id < 0 || id >= storage.idremap.Length) ? id : storage.idremap[id];
        }

#if USE_TERRAINS
        Terrain r2;
        for(int i=0; i<storage.bakedRenderersTerrain.Count; i++)
        {
            r2 = storage.bakedRenderersTerrain[i];
            if (r2 == null) continue;

            id = storage.bakedIDsTerrain[i];
            r2.lightmapIndex = (id < 0 || id >= storage.idremap.Length) ? id : storage.idremap[id];
        }
#endif

        if (storage.anyVolumes)
        {
            if (storage.compressedVolumes)
            {
                Shader.EnableKeyword("BAKERY_COMPRESSED_VOLUME");
            }
            else
            {
                Shader.DisableKeyword("BAKERY_COMPRESSED_VOLUME");
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/ftLightmaps.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/ftLightmapsStorage.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b7fa80e7116296f4eb4f49ec1544ee22
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
#define USE_TERRAINS
//#define BAKERY_STORE_OUTSIDE_OF_SCENE

#if UNITY_EDITOR
#define VALIDATE_MULTIPLE_STORAGES
#endif

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;

#if UNITY_EDITOR
using UnityEditor;
#endif

[ExecuteInEditMode]
public class ftLightmapsStorage : MonoBehaviour{

#if BAKERY_STORE_OUTSIDE_OF_SCENE
    public const bool externalStorage = true;
#else
    public const bool externalStorage = false;
#endif

#if UNITY_EDITOR
        [System.Serializable]
        public class LightData
        {
            public Matrix4x4 tform;
            public Color color;
            public float intensity, range, radius;
            public int samples, samples2;
            public int bitmask;
            public bool bakeToIndirect;
            public bool selfShadow = false;
            public bool realisticFalloff = false;
            public int projMode;
            public Object cookie;
            public float angle = 30.0f;
            public int UID;
        }

        public class ImplicitLightmapData
        {
            public Dictionary<GameObject, Object> implicitGroupMap = null;
        }

        // Saved render settings
        public int renderSettingsBounces = 5;
        public int renderSettingsGISamples = 16;
        public float renderSettingsGIBackFaceWeight = 0;
        public int renderSettingsTileSize = 512;
        public float renderSettingsPriority = 2;
        public float renderSettingsTexelsPerUnit = 20;
        public bool renderSettingsForceRefresh = true;
        public bool renderSettingsForceRebuildGeometry = true;
        public bool renderSettingsPerformRendering = true;
        public int renderSettingsUserRenderMode = 0;
        public bool renderSettingsDistanceShadowmask = false;
        public int renderSettingsSettingsMode = 0;
        public bool renderSettingsFixSeams = true;
        public bool renderSettingsDenoise = true;
        public bool renderSettingsDenoise2x = false;
        public bool renderSettingsEncode = true;
        public int renderSettingsEncodeMode = 0;
        public bool renderSettingsOverwriteWarning = false;
        public bool renderSettingsAutoAtlas = true;
        public bool renderSettingsUnwrapUVs = true;
        public bool renderSettingsForceDisableUnwrapUVs = false;
        public int renderSettingsMaxAutoResolution = 4096;
        public int renderSettingsMinAutoResolution = 16;
        public bool renderSettingsUnloadScenes = true;
        public bool renderSettingsAdjustSamples = true;
        public bool renderSettingsCheckOverlaps = false;
        public bool renderSettingsSkipOutOfBoundsUVs = true;
        public float renderSettingsHackEmissiveBoost = 1;
        public float renderSettingsHackIndirectBoost = 1;
        public string renderSettingsTempPath = "";
        public string renderSettingsOutPath = "";
        public bool renderSettingsUseScenePath = false;
        public float renderSettingsHackAOIntensity = 0;
        public int renderSettingsHackAOSamples = 16;
        public bool renderSettingsHackAOSofter = false;
        public float renderSettingsHackAORadius = 1;
        public bool renderSettingsShowAOSettings = false;
        public bool renderSettingsShowTasks = true;
        public bool renderSettingsShowTasks2 = false;
        public bool renderSettingsShowPaths = true;
        public bool renderSettingsShowNet = true;
        public bool renderSettingsShowSettingsAsset = false;
        public bool renderSettingsShowAPV = false;
        public bool renderSettingsUseAPVSkyOcclusion = false;
        public bool renderSettingsOcclusionProbes = false;
        public bool renderSettingsTexelsPerMap = false;
        public float renderSettingsTexelsColor = 1;
        public float renderSettingsTexelsMask = 1;
        public float renderSettingsTexelsDir = 1;
        public bool renderSettingsShowDirWarning = true;
        public int renderSettingsRenderDirMode = 0;
        public bool renderSettingsShowCheckerSettings = false;
        public bool renderSettingsSamplesWarning = true;
        public bool renderSettingsSuppressPopups = false;
        public bool renderSettingsSectorWarning = false;
        public bool renderSettingsPrefabWarning = true;
        public bool renderSettingsSplitByScene = false;
        public bool renderSettingsSplitByTag = false;
        public bool renderSettingsUVPaddingMax = false;
        public bool renderSettingsUVPaddingPreserveIfExisted = false;
        public bool renderSettingsPostPacking = true;
        public bool renderSettingsHoleFilling = false;
        public bool renderSettingsBruteForce = true;
        public bool renderSettingsAlphaDithering = false;
        public bool renderSettingsBeepOnFinish = false;
        public bool renderSettingsExportTerrainAsHeightmap = true;
        public bool renderSettingsRTXMode = false;
        public int renderSettingsLightProbeMode = 1;
        public bool renderSettingsClientMode = false;
        public string renderSettingsServerAddress = "127.0.0.1";
        public int renderSettingsUnwrapper = 0;
        public int renderSettingsDenoiserType = (int)ftGlobalStorage.DenoiserType.OpenImageDenoise;
        public bool renderSettingsExportTerrainTrees = false;
        public bool renderSettingsShowPerf = true;
        public int renderSettingsSampleDiv = 1;
        public ftGlobalStorage.AtlasPacker renderSettingsAtlasPacker = ftGlobalStorage.AtlasPacker.xatlas;
        public bool renderSettingsBatchPoints = true;
        public bool renderSettingsCompressVolumes = false;
        public int renderSettingsBatchAreaLightSampleLimit = 0;
        public UnityEngine.Object renderSettingsSector = null;
        public UnityEngine.Object renderSettingsAsset = null;
        public bool renderSettingsRTPVExport = true;
        public bool renderSettingsRTPVSceneView = false;
        public bool renderSettingsRTPVHDR = false;
        public int renderSettingsRTPVWidth = 640;
        public int renderSettingsRTPVHeight = 360;
        public float renderSettingsRTPVExposure = 1.0f;
        public bool renderSettingsRemoveDuplicateLightmaps = false;
        public int lastBakeTime = 0;

        public bool enlightenWarningShown = false;
        public bool enlightenWarningShown2 = false;

        // Light settings from the last bake
        public List<GameObject> uniqueLights = new List<GameObject>();
        public Dictionary<GameObject, LightData> lightsDict;

        // List of implicit groups
        //public List<BakeryLightmapGroup> implicitGroups = new List<BakeryLightmapGroup>();
        public List<Object> implicitGroups = new List<Object>();
        public List<GameObject> implicitGroupedObjects;

#if BAKERY_STORE_OUTSIDE_OF_SCENE
#else
        //public List<BakeryLightmapGroupPlain> previouslyBakedGroups = new List<BakeryLightmapGroupPlain>();

        // List of baked lightmap world-space bounds
        public List<Bounds> bounds = new List<Bounds>();

        // Per-lightmap flags
        public List<bool> hasEmissive = new List<bool>();

        //public float[][] uvSrc;
        //public float[][] uvDest;
        //public int[][] lmrIndices;
        public int[] uvBuffOffsets;
        public int[] uvBuffLengths;
        public float[] uvSrcBuff;
        public float[] uvDestBuff;
        public int[] lmrIndicesOffsets;
        public int[] lmrIndicesLengths;
        public int[] lmrIndicesBuff;

        public int[] lmGroupLODResFlags; // bits which lods are needed for which LMGroups
        public int[] lmGroupMinLOD; // minimum possible resolution for given LMGroup given UV island count
        public int[] lmGroupLODMatrix;

        // Reuired for network bakes
        public List<string> serverGetFileList = new List<string>();
        public List<bool> lightmapHasColor = new List<bool>();
        public List<int> lightmapHasMask = new List<int>();
        public List<bool> lightmapHasDir = new List<bool>();
        public List<bool> lightmapHasRNM = new List<bool>();

        public List<LightData> lights = new List<LightData>();

        // Partial copy of GlobalStorage to recover UV padding if needed
        public List<string> modifiedAssetPathList = new List<string>();
        public List<ftGlobalStorage.AdjustedMesh> modifiedAssets = new List<ftGlobalStorage.AdjustedMesh>();
#endif

#if VALIDATE_MULTIPLE_STORAGES
        static Dictionary<Scene, ftLightmapsStorage> sceneToStorage = new Dictionary<Scene, ftLightmapsStorage>();
#endif

        //public Texture2D debugTex;
        //public RenderTexture debugRT;

        public void Init(bool forceRefresh)
        {
            lightsDict = new Dictionary<GameObject, LightData>();
            if (uniqueLights == null) uniqueLights = new List<GameObject>();
            if (lights == null || uniqueLights == null)
            {
                forceRefresh = true;
            }
            else if (lights.Count != uniqueLights.Count)
            {
                forceRefresh = true;
            }

            if (forceRefresh)
            {
                lights = new List<LightData>();
                uniqueLights = new List<GameObject>();
            }
            else
            {
                for(int i=0; i<lights.Count; i++)
                {
                    if (uniqueLights[i] != null)
                    {
                        lightsDict[uniqueLights[i]] = lights[i];
                    }
                }
            }
        }

        public void StoreLight(GameObject u, LightData light)
        {
            if (uniqueLights == null) uniqueLights = new List<GameObject>();
            if (lights == null) lights = new List<LightData>();
            light.UID = uniqueLights.Count + 1;
            uniqueLights.Add(u);
            lights.Add(light);
            lightsDict[u] = light;
        }

        public static void CopySettings(ftLightmapsStorage src, ftLightmapsStorage dest)
        {
            dest.renderSettingsBounces = src.renderSettingsBounces;
            dest.renderSettingsGISamples = src.renderSettingsGISamples;
            dest.renderSettingsGIBackFaceWeight = src.renderSettingsGIBackFaceWeight;
            dest.renderSettingsTileSize = src.renderSettingsTileSize;
            dest.renderSettingsPriority = src.renderSettingsPriority;
            dest.renderSettingsTexelsPerUnit = src.renderSettingsTexelsPerUnit;
            dest.renderSettingsForceRefresh = src.renderSettingsForceRefresh;
            dest.renderSettingsForceRebuildGeometry = src.renderSettingsForceRebuildGeometry;
            dest.renderSettingsPerformRendering = src.renderSettingsPerformRendering;
            dest.renderSettingsUserRenderMode = src.renderSettingsUserRenderMode;
            dest.renderSettingsDistanceShadowmask = src.renderSettingsDistanceShadowmask;
            dest.renderSettingsSettingsMode = src.renderSettingsSettingsMode;
            dest.renderSettingsFixSeams = src.renderSettingsFixSeams;
            dest.renderSettingsDenoise = src.renderSettingsDenoise;
            dest.renderSettingsDenoise2x = src.renderSettingsDenoise2x;
            dest.renderSettingsEncode = src.renderSettingsEncode;
            dest.renderSettingsEncodeMode = src.renderSettingsEncodeMode;
            dest.renderSettingsOverwriteWarning = src.renderSettingsOverwriteWarning;
            dest.renderSettingsAutoAtlas = src.renderSettingsAutoAtlas;
            dest.renderSettingsUnwrapUVs = src.renderSettingsUnwrapUVs;
            dest.renderSettingsForceDisableUnwrapUVs = src.renderSettingsForceDisableUnwrapUVs;
            dest.renderSettingsMaxAutoResolution = src.renderSettingsMaxAutoResolution;
            dest.renderSettingsMinAutoResolution = src.renderSettingsMinAutoResolution;
            dest.renderSettingsUnloadScenes = src.renderSettingsUnloadScenes;
            dest.renderSettingsAdjustSamples = src.renderSettingsAdjustSamples;
            dest.renderSettingsCheckOverlaps = src.renderSettingsCheckOverlaps;
            dest.renderSettingsSkipOutOfBoundsUVs = src.renderSettingsSkipOutOfBoundsUVs;
            dest.renderSettingsHackEmissiveBoost = src.renderSettingsHackEmissiveBoost;
            dest.renderSettingsHackIndirectBoost = src.renderSettingsHackIndirectBoost;
            dest.renderSettingsTempPath = src.renderSettingsTempPath;
            dest.renderSettingsOutPath = src.renderSettingsOutPath;
            dest.renderSettingsUseScenePath = src.renderSettingsUseScenePath;
            dest.renderSettingsHackAOIntensity = src.renderSettingsHackAOIntensity;
            dest.renderSettingsHackAOSamples = src.renderSettingsHackAOSamples;
            dest.renderSettingsHackAOSofter = src.renderSettingsHackAOSofter;
            dest.renderSettingsHackAORadius = src.renderSettingsHackAORadius;
            dest.renderSettingsShowAOSettings = src.renderSettingsShowAOSettings;
            dest.renderSettingsShowTasks = src.renderSettingsShowTasks;
            dest.renderSettingsShowTasks2 = src.renderSettingsShowTasks2;
            dest.renderSettingsShowPaths = src.renderSettingsShowPaths;
            dest.renderSettingsShowNet = src.renderSettingsShowNet;
            dest.renderSettingsShowSettingsAsset = src.renderSettingsShowSettingsAsset;
            dest.renderSettingsShowAPV = src.renderSettingsShowAPV;
            dest.renderSettingsUseAPVSkyOcclusion = src.renderSettingsUseAPVSkyOcclusion;
            dest.renderSettingsOcclusionProbes = src.renderSettingsOcclusionProbes;
            dest.renderSettingsTexelsPerMap = src.renderSettingsTexelsPerMap;
            dest.renderSettingsTexelsColor = src.renderSettingsTexelsColor;
            dest.renderSettingsTexelsMask = src.renderSettingsTexelsMask;
            dest.renderSettingsTexelsDir = src.renderSettingsTexelsDir;
            dest.renderSettingsShowDirWarning = src.renderSettingsShowDirWarning;
            dest.renderSettingsRenderDirMode = src.renderSettingsRenderDirMode;
            dest.renderSettingsShowCheckerSettings = src.renderSettingsShowCheckerSettings;
            dest.renderSettingsSamplesWarning = src.renderSettingsSamplesWarning;
            dest.renderSettingsSuppressPopups = src.renderSettingsSuppressPopups;
            dest.renderSettingsPrefabWarning = src.renderSettingsPrefabWarning;
            dest.renderSettingsSectorWarning = src.renderSettingsSectorWarning;
            dest.renderSettingsSplitByScene = src.renderSettingsSplitByScene;
            dest.renderSettingsSplitByTag = src.renderSettingsSplitByTag;
            dest.renderSettingsUVPaddingMax = src.renderSettingsUVPaddingMax;
            dest.renderSettingsUVPaddingPreserveIfExisted = src.renderSettingsUVPaddingPreserveIfExisted;
            dest.renderSettingsPostPacking = src.renderSettingsPostPacking;
            dest.renderSettingsHoleFilling = src.renderSettingsHoleFilling;
            dest.renderSettingsBruteForce = src.renderSettingsBruteForce;
            dest.renderSettingsAlphaDithering = src.renderSettingsAlphaDithering;
            dest.renderSettingsBeepOnFinish = src.renderSettingsBeepOnFinish;
            dest.renderSettingsExportTerrainAsHeightmap = src.renderSettingsExportTerrainAsHeightmap;
            dest.renderSettingsRTXMode = src.renderSettingsRTXMode;
            dest.renderSettingsLightProbeMode = src.renderSettingsLightProbeMode;
            dest.renderSettingsClientMode = src.renderSettingsClientMode;
            dest.renderSettingsServerAddress = src.renderSettingsServerAddress;
            dest.renderSettingsUnwrapper = src.renderSettingsUnwrapper;
            dest.renderSettingsDenoiserType = src.renderSettingsDenoiserType;
            dest.renderSettingsExportTerrainTrees = src.renderSettingsExportTerrainTrees;
            dest.renderSettingsSampleDiv = src.renderSettingsSampleDiv;
            dest.renderSettingsAutoAtlas = src.renderSettingsAutoAtlas;
            dest.renderSettingsBatchPoints = src.renderSettingsBatchPoints;
            dest.renderSettingsCompressVolumes = src.renderSettingsCompressVolumes;
            dest.renderSettingsBatchAreaLightSampleLimit = src.renderSettingsBatchAreaLightSampleLimit;
            dest.renderSettingsRTPVExport = src.renderSettingsRTPVExport;
            dest.renderSettingsRTPVSceneView = src.renderSettingsRTPVSceneView;
            dest.renderSettingsRTPVHDR = src.renderSettingsRTPVHDR;
            dest.renderSettingsRTPVWidth = src.renderSettingsRTPVWidth;
            dest.renderSettingsRTPVHeight = src.renderSettingsRTPVHeight;
            dest.renderSettingsRTPVExposure = src.renderSettingsRTPVExposure;
            dest.renderSettingsAtlasPacker = src.renderSettingsAtlasPacker;
            dest.renderSettingsRemoveDuplicateLightmaps = src.renderSettingsRemoveDuplicateLightmaps;
            dest.renderSettingsShowPerf = src.renderSettingsShowPerf;
        }

        public static void CopySettings(ftLightmapsStorage src, ftGlobalStorage dest)
        {
            dest.renderSettingsBounces = src.renderSettingsBounces;
            dest.renderSettingsGISamples = src.renderSettingsGISamples;
            dest.renderSettingsGIBackFaceWeight = src.renderSettingsGIBackFaceWeight;
            dest.renderSettingsTileSize = src.renderSettingsTileSize;
            dest.renderSettingsPriority = src.renderSettingsPriority;
            dest.renderSettingsTexelsPerUnit = src.renderSettingsTexelsPerUnit;
            dest.renderSettingsForceRefresh = src.renderSettingsForceRefresh;
            dest.renderSettingsForceRebuildGeometry = src.renderSettingsForceRebuildGeometry;
            dest.renderSettingsPerformRendering = src.renderSettingsPerformRendering;
            dest.renderSettingsUserRenderMode = src.renderSettingsUserRenderMode;
            dest.renderSettingsDistanceShadowmask = src.renderSettingsDistanceShadowmask;
            dest.renderSettingsSettingsMode = src.renderSettingsSettingsMode;
            dest.renderSettingsFixSeams = src.renderSettingsFixSeams;
            dest.renderSettingsDenoise = src.renderSettingsDenoise;
            dest.renderSettingsDenoise2x = src.renderSettingsDenoise2x;
            dest.renderSettingsEncode = src.renderSettingsEncode;
            dest.renderSettingsEncodeMode = src.renderSettingsEncodeMode;
            dest.renderSettingsOverwriteWarning = src.renderSettingsOverwriteWarning;
            dest.renderSettingsAutoAtlas = src.renderSettingsAutoAtlas;
            dest.renderSettingsUnwrapUVs = src.renderSettingsUnwrapUVs;
            dest.renderSettingsForceDisableUnwrapUVs = src.renderSettingsForceDisableUnwrapUVs;
            dest.renderSettingsMaxAutoResolution = src.renderSettingsMaxAutoResolution;
            dest.renderSettingsMinAutoResolution = src.renderSettingsMinAutoResolution;
            dest.renderSettingsUnloadScenes = src.renderSettingsUnloadScenes;
            dest.renderSettingsAdjustSamples = src.renderSettingsAdjustSamples;
            dest.renderSettingsCheckOverlaps = src.renderSettingsCheckOverlaps;
            dest.renderSettingsSkipOutOfBoundsUVs = src.renderSettingsSkipOutOfBoundsUVs;
            dest.renderSettingsHackEmissiveBoost = src.renderSettingsHackEmissiveBoost;
            dest.renderSettingsHackIndirectBoost = src.renderSettingsHackIndirectBoost;
            dest.renderSettingsTempPath = src.renderSettingsTempPath;
            dest.renderSettingsOutPath = src.renderSettingsOutPath;
            dest.renderSettingsUseScenePath = src.renderSettingsUseScenePath;
            dest.renderSettingsHackAOIntensity = src.renderSettingsHackAOIntensity;
            dest.renderSettingsHackAOSamples = src.renderSettingsHackAOSamples;
            dest.renderSettingsHackAOSofter = src.renderSettingsHackAOSofter;
            dest.renderSettingsHackAORadius = src.renderSettingsHackAORadius;
            dest.renderSettingsShowAOSettings = src.renderSettingsShowAOSettings;
            dest.renderSettingsShowTasks = src.renderSettingsShowTasks;
            dest.renderSettingsShowTasks2 = src.renderSettingsShowTasks2;
            dest.renderSettingsShowPaths = src.renderSettingsShowPaths;
            dest.renderSettingsShowNet = src.renderSettingsShowNet;
            dest.renderSettingsShowSettingsAsset = src.renderSettingsShowSettingsAsset;
            dest.renderSettingsShowAPV = src.renderSettingsShowAPV;
            dest.renderSettingsUseAPVSkyOcclusion = src.renderSettingsUseAPVSkyOcclusion;
            dest.renderSettingsOcclusionProbes = src.renderSettingsOcclusionProbes;
            dest.renderSettingsTexelsPerMap = src.renderSettingsTexelsPerMap;
            dest.renderSettingsTexelsColor = src.renderSettingsTexelsColor;
            dest.renderSettingsTexelsMask = src.renderSettingsTexelsMask;
            dest.renderSettingsTexelsDir = src.renderSettingsTexelsDir;
            dest.renderSettingsShowDirWarning = src.renderSettingsShowDirWarning;
            dest.renderSettingsRenderDirMode = src.renderSettingsRenderDirMode;
            dest.renderSettingsShowCheckerSettings = src.renderSettingsShowCheckerSettings;
            dest.renderSettingsSamplesWarning = src.renderSettingsSamplesWarning;
            dest.renderSettingsSuppressPopups = src.renderSettingsSuppressPopups;
            dest.renderSettingsSectorWarning = src.renderSettingsSectorWarning;
            dest.renderSettingsPrefabWarning = src.renderSettingsPrefabWarning;
            dest.renderSettingsSplitByScene = src.renderSettingsSplitByScene;
            dest.renderSettingsSplitByTag = src.renderSettingsSplitByTag;
            dest.renderSettingsUVPaddingMax = src.renderSettingsUVPaddingMax;
            dest.renderSettingsUVPaddingPreserveIfExisted = src.renderSettingsUVPaddingPreserveIfExisted;
            dest.renderSettingsPostPacking = src.renderSettingsPostPacking;
            dest.renderSettingsHoleFilling = src.renderSettingsHoleFilling;
            dest.renderSettingsBruteForce = src.renderSettingsBruteForce;
            dest.renderSettingsAlphaDithering = src.renderSettingsAlphaDithering;
            dest.renderSettingsBeepOnFinish = src.renderSettingsBeepOnFinish;
            dest.renderSettingsExportTerrainAsHeightmap = src.renderSettingsExportTerrainAsHeightmap;
            dest.renderSettingsRTXMode = src.renderSettingsRTXMode;
            dest.renderSettingsLightProbeMode = src.renderSettingsLightProbeMode;
            dest.renderSettingsClientMode = src.renderSettingsClientMode;
            dest.renderSettingsServerAddress = src.renderSettingsServerAddress;
            dest.renderSettingsUnwrapper = src.renderSettingsUnwrapper;
            dest.renderSettingsDenoiserType = src.renderSettingsDenoiserType;
            dest.renderSettingsExportTerrainTrees = src.renderSettingsExportTerrainTrees;
            dest.renderSettingsShowPerf = src.renderSettingsShowPerf;
            dest.renderSettingsSampleDiv = src.renderSettingsSampleDiv;
            dest.renderSettingsBatchPoints = src.renderSettingsBatchPoints;
            dest.renderSettingsCompressVolumes = src.renderSettingsCompressVolumes;
            dest.renderSettingsBatchAreaLightSampleLimit = src.renderSettingsBatchAreaLightSampleLimit;
            dest.renderSettingsRTPVExport = src.renderSettingsRTPVExport;
            dest.renderSettingsRTPVSceneView = src.renderSettingsRTPVSceneView;
            dest.renderSettingsRTPVHDR = src.renderSettingsRTPVHDR;
            dest.renderSettingsRTPVWidth = src.renderSettingsRTPVWidth;
            dest.renderSettingsRTPVHeight = src.renderSettingsRTPVHeight;
            dest.renderSettingsRTPVExposure = src.renderSettingsRTPVExposure;
            dest.renderSettingsAtlasPacker = src.renderSettingsAtlasPacker;
            dest.renderSettingsAutoAtlas = src.renderSettingsAutoAtlas;
            dest.renderSettingsRemoveDuplicateLightmaps = src.renderSettingsRemoveDuplicateLightmaps;
        }

        public static void CopySettings(ftGlobalStorage src, ftLightmapsStorage dest)
        {
            dest.renderSettingsBounces = src.renderSettingsBounces;
            dest.renderSettingsGISamples = src.renderSettingsGISamples;
            dest.renderSettingsGIBackFaceWeight = src.renderSettingsGIBackFaceWeight;
            dest.renderSettingsTileSize = src.renderSettingsTileSize;
            dest.renderSettingsPriority = src.renderSettingsPriority;
            dest.renderSettingsTexelsPerUnit = src.renderSettingsTexelsPerUnit;
            dest.renderSettingsForceRefresh = src.renderSettingsForceRefresh;
            dest.renderSettingsForceRebuildGeometry = src.renderSettingsForceRebuildGeometry;
            dest.renderSettingsPerformRendering = src.renderSettingsPerformRendering;
            dest.renderSettingsUserRenderMode = src.renderSettingsUserRenderMode;
            dest.renderSettingsDistanceShadowmask = src.renderSettingsDistanceShadowmask;
            dest.renderSettingsSettingsMode = src.renderSettingsSettingsMode;
            dest.renderSettingsFixSeams = src.renderSettingsFixSeams;
            dest.renderSettingsDenoise = src.renderSettingsDenoise;
            dest.renderSettingsDenoise2x = src.renderSettingsDenoise2x;
            dest.renderSettingsEncode = src.renderSettingsEncode;
            dest.renderSettingsEncodeMode = src.renderSettingsEncodeMode;
            dest.renderSettingsOverwriteWarning = src.renderSettingsOverwriteWarning;
            dest.renderSettingsAutoAtlas = src.renderSettingsAutoAtlas;
            dest.renderSettingsUnwrapUVs = src.renderSettingsUnwrapUVs;
            dest.renderSettingsForceDisableUnwrapUVs = src.renderSettingsForceDisableUnwrapUVs;
            dest.renderSettingsMaxAutoResolution = src.renderSettingsMaxAutoResolution;
            dest.renderSettingsMinAutoResolution = src.renderSettingsMinAutoResolution;
            dest.renderSettingsUnloadScenes = src.renderSettingsUnloadScenes;
            dest.renderSettingsAdjustSamples = src.renderSettingsAdjustSamples;
            dest.renderSettingsCheckOverlaps = src.renderSettingsCheckOverlaps;
            dest.renderSettingsSkipOutOfBoundsUVs = src.renderSettingsSkipOutOfBoundsUVs;
            dest.renderSettingsHackEmissiveBoost = src.renderSettingsHackEmissiveBoost;
            dest.renderSettingsHackIndirectBoost = src.renderSettingsHackIndirectBoost;
            dest.renderSettingsTempPath = src.renderSettingsTempPath;
            dest.renderSettingsOutPath = src.renderSettingsOutPath;
            dest.renderSettingsUseScenePath = src.renderSettingsUseScenePath;
            dest.renderSettingsHackAOIntensity = src.renderSettingsHackAOIntensity;
            dest.renderSettingsHackAOSamples = src.renderSettingsHackAOSamples;
            dest.renderSettingsHackAOSofter = src.renderSettingsHackAOSofter;
            dest.renderSettingsHackAORadius = src.renderSettingsHackAORadius;
            dest.renderSettingsShowAOSettings = src.renderSettingsShowAOSettings;
            dest.renderSettingsShowTasks = src.renderSettingsShowTasks;
            dest.renderSettingsShowTasks2 = src.renderSettingsShowTasks2;
            dest.renderSettingsShowPaths = src.renderSettingsShowPaths;
            dest.renderSettingsShowNet = src.renderSettingsShowNet;
            dest.renderSettingsShowSettingsAsset = src.renderSettingsShowSettingsAsset;
            dest.renderSettingsShowAPV = src.renderSettingsShowAPV;
            dest.renderSettingsUseAPVSkyOcclusion = src.renderSettingsUseAPVSkyOcclusion;
            dest.renderSettingsOcclusionProbes = src.renderSettingsOcclusionProbes;
            dest.renderSettingsTexelsPerMap = src.renderSettingsTexelsPerMap;
            dest.renderSettingsTexelsColor = src.renderSettingsTexelsColor;
            dest.renderSettingsTexelsMask = src.renderSettingsTexelsMask;
            dest.renderSettingsTexelsDir = src.renderSettingsTexelsDir;
            dest.renderSettingsShowDirWarning = src.renderSettingsShowDirWarning;
            dest.renderSettingsRenderDirMode = src.renderSettingsRenderDirMode;
            dest.renderSettingsShowCheckerSettings = src.renderSettingsShowCheckerSettings;
            dest.renderSettingsSamplesWarning = src.renderSettingsSamplesWarning;
            dest.renderSettingsSuppressPopups = src.renderSettingsSuppressPopups;
            dest.renderSettingsSectorWarning = src.renderSettingsSectorWarning;
            dest.renderSettingsPrefabWarning = src.renderSettingsPrefabWarning;
            dest.renderSettingsSplitByScene = src.renderSettingsSplitByScene;
            dest.renderSettingsSplitByTag = src.renderSettingsSplitByTag;
            dest.renderSettingsUVPaddingMax = src.renderSettingsUVPaddingMax;
            dest.renderSettingsUVPaddingPreserveIfExisted = src.renderSettingsUVPaddingPreserveIfExisted;
            dest.renderSettingsPostPacking = src.renderSettingsPostPacking;
            dest.renderSettingsHoleFilling = src.renderSettingsHoleFilling;
            dest.renderSettingsBruteForce = src.renderSettingsBruteForce;
            dest.renderSettingsAlphaDithering = src.renderSettingsAlphaDithering;
            dest.renderSettingsBeepOnFinish = src.renderSettingsBeepOnFinish;
            dest.renderSettingsExportTerrainAsHeightmap = src.renderSettingsExportTerrainAsHeightmap;
            dest.renderSettingsRTXMode = src.renderSettingsRTXMode;
            dest.renderSettingsLightProbeMode = src.renderSettingsLightProbeMode;
            dest.renderSettingsClientMode = src.renderSettingsClientMode;
            dest.renderSettingsServerAddress = src.renderSettingsServerAddress;
            dest.renderSettingsUnwrapper = src.renderSettingsUnwrapper;
            dest.renderSettingsDenoiserType = src.renderSettingsDenoiserType;
            dest.renderSettingsExportTerrainTrees = src.renderSettingsExportTerrainTrees;
            dest.renderSettingsShowPerf = src.renderSettingsShowPerf;
            dest.renderSettingsSampleDiv = src.renderSettingsSampleDiv;
            dest.renderSettingsBatchPoints = src.renderSettingsBatchPoints;
            dest.renderSettingsCompressVolumes = src.renderSettingsCompressVolumes;
            dest.renderSettingsBatchAreaLightSampleLimit = src.renderSettingsBatchAreaLightSampleLimit;
            dest.renderSettingsRTPVExport = src.renderSettingsRTPVExport;
            dest.renderSettingsRTPVSceneView = src.renderSettingsRTPVSceneView;
            dest.renderSettingsRTPVHDR = src.renderSettingsRTPVHDR;
            dest.renderSettingsRTPVWidth = src.renderSettingsRTPVWidth;
            dest.renderSettingsRTPVHeight = src.renderSettingsRTPVHeight;
            dest.renderSettingsRTPVExposure = src.renderSettingsRTPVExposure;
            dest.renderSettingsAtlasPacker = src.renderSettingsAtlasPacker;
            dest.renderSettingsAutoAtlas = src.renderSettingsAutoAtlas;
            dest.renderSettingsRemoveDuplicateLightmaps = src.renderSettingsRemoveDuplicateLightmaps;
        }

        public static void CopySettings(ftLightmapsStorage src, ftSettingsAsset dest)
        {
            dest.renderSettingsBounces = src.renderSettingsBounces;
            dest.renderSettingsGISamples = src.renderSettingsGISamples;
            dest.renderSettingsGIBackFaceWeight = src.renderSettingsGIBackFaceWeight;
            dest.renderSettingsTileSize = src.renderSettingsTileSize;
            dest.renderSettingsPriority = src.renderSettingsPriority;
            dest.renderSettingsTexelsPerUnit = src.renderSettingsTexelsPerUnit;
            dest.renderSettingsForceRefresh = src.renderSettingsForceRefresh;
            dest.renderSettingsForceRebuildGeometry = src.renderSettingsForceRebuildGeometry;
            dest.renderSettingsPerformRendering = src.renderSettingsPerformRendering;
            dest.renderSettingsUserRenderMode = src.renderSettingsUserRenderMode;
            dest.renderSettingsDistanceShadowmask = src.renderSettingsDistanceShadowmask;
            dest.renderSettingsSettingsMode = src.renderSettingsSettingsMode;
            dest.renderSettingsFixSeams = src.renderSettingsFixSeams;
            dest.renderSettingsDenoise = src.renderSettingsDenoise;
            dest.renderSettingsDenoise2x = src.renderSettingsDenoise2x;
            dest.renderSettingsEncode = src.renderSettingsEncode;
            dest.renderSettingsEncodeMode = src.renderSettingsEncodeMode;
            dest.renderSettingsOverwriteWarning = src.renderSettingsOverwriteWarning;
            dest.renderSettingsAutoAtlas = src.renderSettingsAutoAtlas;
            dest.renderSettingsUnwrapUVs = src.renderSettingsUnwrapUVs;
            dest.renderSettingsForceDisableUnwrapUVs = src.renderSettingsForceDisableUnwrapUVs;
            dest.renderSettingsMaxAutoResolution = src.renderSettingsMaxAutoResolution;
            dest.renderSettingsMinAutoResolution = src.renderSettingsMinAutoResolution;
            dest.renderSettingsUnloadScenes = src.renderSettingsUnloadScenes;
            dest.renderSettingsAdjustSamples = src.renderSettingsAdjustSamples;
            dest.renderSettingsCheckOverlaps = src.renderSettingsCheckOverlaps;
            dest.renderSettingsSkipOutOfBoundsUVs = src.renderSettingsSkipOutOfBoundsUVs;
            dest.renderSettingsHackEmissiveBoost = src.renderSettingsHackEmissiveBoost;
            dest.renderSettingsHackIndirectBoost = src.renderSettingsHackIndirectBoost;
            dest.renderSettingsTempPath = src.renderSettingsTempPath;
            dest.renderSettingsOutPath = src.renderSettingsOutPath;
            dest.renderSettingsUseScenePath = src.renderSettingsUseScenePath;
            dest.renderSettingsHackAOIntensity = src.renderSettingsHackAOIntensity;
            dest.renderSettingsHackAOSamples = src.renderSettingsHackAOSamples;
            dest.renderSettingsHackAOSofter = src.renderSettingsHackAOSofter;
            dest.renderSettingsHackAORadius = src.renderSettingsHackAORadius;
            dest.renderSettingsShowAOSettings = src.renderSettingsShowAOSettings;
            dest.renderSettingsShowTasks = src.renderSettingsShowTasks;
            dest.renderSettingsShowTasks2 = src.renderSettingsShowTasks2;
            dest.renderSettingsShowPaths = src.renderSettingsShowPaths;
            dest.renderSettingsShowNet = src.renderSettingsShowNet;
            dest.renderSettingsShowSettingsAsset = src.renderSettingsShowSettingsAsset;
            dest.renderSettingsShowAPV = src.renderSettingsShowAPV;
            dest.renderSettingsUseAPVSkyOcclusion = src.renderSettingsUseAPVSkyOcclusion;
            dest.renderSettingsOcclusionProbes = src.renderSettingsOcclusionProbes;
            dest.renderSettingsTexelsPerMap = src.renderSettingsTexelsPerMap;
            dest.renderSettingsTexelsColor = src.renderSettingsTexelsColor;
            dest.renderSettingsTexelsMask = src.renderSettingsTexelsMask;
            dest.renderSettingsTexelsDir = src.renderSettingsTexelsDir;
            dest.renderSettingsShowDirWarning = src.renderSettingsShowDirWarning;
            dest.renderSettingsRenderDirMode = src.renderSettingsRenderDirMode;
            dest.renderSettingsShowCheckerSettings = src.renderSettingsShowCheckerSettings;
            dest.renderSettingsSamplesWarning = src.renderSettingsSamplesWarning;
            dest.renderSettingsSuppressPopups = src.renderSettingsSuppressPopups;
            dest.renderSettingsSectorWarning = src.renderSettingsSectorWarning;
            dest.renderSettingsPrefabWarning = src.renderSettingsPrefabWarning;
            dest.renderSettingsSplitByScene = src.renderSettingsSplitByScene;
            dest.renderSettingsSplitByTag = src.renderSettingsSplitByTag;
            dest.renderSettingsUVPaddingMax = src.renderSettingsUVPaddingMax;
            dest.renderSettingsUVPaddingPreserveIfExisted = src.renderSettingsUVPaddingPreserveIfExisted;
            dest.renderSettingsPostPacking = src.renderSettingsPostPacking;
            dest.renderSettingsHoleFilling = src.renderSettingsHoleFilling;
            dest.renderSettingsBruteForce = src.renderSettingsBruteForce;
            dest.renderSettingsAlphaDithering = src.renderSettingsAlphaDithering;
            dest.renderSettingsBeepOnFinish = src.renderSettingsBeepOnFinish;
            dest.renderSettingsExportTerrainAsHeightmap = src.renderSettingsExportTerrainAsHeightmap;
            dest.renderSettingsRTXMode = src.renderSettingsRTXMode;
            dest.renderSettingsLightProbeMode = src.renderSettingsLightProbeMode;
            dest.renderSettingsClientMode = src.renderSettingsClientMode;
            dest.renderSettingsServerAddress = src.renderSettingsServerAddress;
            dest.renderSettingsUnwrapper = src.renderSettingsUnwrapper;
            dest.renderSettingsDenoiserType = src.renderSettingsDenoiserType;
            dest.renderSettingsExportTerrainTrees = src.renderSettingsExportTerrainTrees;
            dest.renderSettingsShowPerf = src.renderSettingsShowPerf;
            dest.renderSettingsSampleDiv = src.renderSettingsSampleDiv;
            dest.renderSettingsBatchPoints = src.renderSettingsBatchPoints;
            dest.renderSettingsCompressVolumes = src.renderSettingsCompressVolumes;
            dest.renderSettingsBatchAreaLightSampleLimit = src.renderSettingsBatchAreaLightSampleLimit;
            dest.renderSettingsRTPVExport = src.renderSettingsRTPVExport;
            dest.renderSettingsRTPVSceneView = src.renderSettingsRTPVSceneView;
            dest.renderSettingsRTPVHDR = src.renderSettingsRTPVHDR;
            dest.renderSettingsRTPVWidth = src.renderSettingsRTPVWidth;
            dest.renderSettingsRTPVHeight = src.renderSettingsRTPVHeight;
            dest.renderSettingsRTPVExposure = src.renderSettingsRTPVExposure;
            dest.renderSettingsAtlasPacker = src.renderSettingsAtlasPacker;
            dest.renderSettingsAutoAtlas = src.renderSettingsAutoAtlas;
            dest.renderSettingsRemoveDuplicateLightmaps = src.renderSettingsRemoveDuplicateLightmaps;
        }

        public static void CopySettings(ftSettingsAsset src, ftLightmapsStorage dest)
        {
            dest.renderSettingsBounces = src.renderSettingsBounces;
            dest.renderSettingsGISamples = src.renderSettingsGISamples;
            dest.renderSettingsGIBackFaceWeight = src.renderSettingsGIBackFaceWeight;
            dest.renderSettingsTileSize = src.renderSettingsTileSize;
            dest.renderSettingsPriority = src.renderSettingsPriority;
            dest.renderSettingsTexelsPerUnit = src.renderSettingsTexelsPerUnit;
            dest.renderSettingsForceRefresh = src.renderSettingsForceRefresh;
            dest.renderSettingsForceRebuildGeometry = src.renderSettingsForceRebuildGeometry;
            dest.renderSettingsPerformRendering = src.renderSettingsPerformRendering;
            dest.renderSettingsUserRenderMode = src.renderSettingsUserRenderMode;
            dest.renderSettingsDistanceShadowmask = src.renderSettingsDistanceShadowmask;
            dest.renderSettingsSettingsMode = src.renderSettingsSettingsMode;
            dest.renderSettingsFixSeams = src.renderSettingsFixSeams;
            dest.renderSettingsDenoise = src.renderSettingsDenoise;
            dest.renderSettingsDenoise2x = src.renderSettingsDenoise2x;
            dest.renderSettingsEncode = src.renderSettingsEncode;
            dest.renderSettingsEncodeMode = src.renderSettingsEncodeMode;
            dest.renderSettingsOverwriteWarning = src.renderSettingsOverwriteWarning;
            dest.renderSettingsAutoAtlas = src.renderSettingsAutoAtlas;
            dest.renderSettingsUnwrapUVs = src.renderSettingsUnwrapUVs;
            dest.renderSettingsForceDisableUnwrapUVs = src.renderSettingsForceDisableUnwrapUVs;
            dest.renderSettingsMaxAutoResolution = src.renderSettingsMaxAutoResolution;
            dest.renderSettingsMinAutoResolution = src.renderSettingsMinAutoResolution;
            dest.renderSettingsUnloadScenes = src.renderSettingsUnloadScenes;
            dest.renderSettingsAdjustSamples = src.renderSettingsAdjustSamples;
            dest.renderSettingsCheckOverlaps = src.renderSettingsCheckOverlaps;
            dest.renderSettingsSkipOutOfBoundsUVs = src.renderSettingsSkipOutOfBoundsUVs;
            dest.renderSettingsHackEmissiveBoost = src.renderSettingsHackEmissiveBoost;
            dest.renderSettingsHackIndirectBoost = src.renderSettingsHackIndirectBoost;
            dest.renderSettingsTempPath = src.renderSettingsTempPath;
            dest.renderSettingsOutPath = src.renderSettingsOutPath;
            dest.renderSettingsUseScenePath = src.renderSettingsUseScenePath;
            dest.renderSettingsHackAOIntensity = src.renderSettingsHackAOIntensity;
            dest.renderSettingsHackAOSamples = src.renderSettingsHackAOSamples;
            dest.renderSettingsHackAOSofter = src.renderSettingsHackAOSofter;
            dest.renderSettingsHackAORadius = src.renderSettingsHackAORadius;
            dest.renderSettingsShowAOSettings = src.renderSettingsShowAOSettings;
            dest.renderSettingsShowTasks = src.renderSettingsShowTasks;
            dest.renderSettingsShowTasks2 = src.renderSettingsShowTasks2;
            dest.renderSettingsShowPaths = src.renderSettingsShowPaths;
            dest.renderSettingsShowNet = src.renderSettingsShowNet;
            dest.renderSettingsShowSettingsAsset = src.renderSettingsShowSettingsAsset;
            dest.renderSettingsShowAPV = src.renderSettingsShowAPV;
            dest.renderSettingsUseAPVSkyOcclusion = src.renderSettingsUseAPVSkyOcclusion;
            dest.renderSettingsOcclusionProbes = src.renderSettingsOcclusionProbes;
            dest.renderSettingsTexelsPerMap = src.renderSettingsTexelsPerMap;
            dest.renderSettingsTexelsColor = src.renderSettingsTexelsColor;
            dest.renderSettingsTexelsMask = src.renderSettingsTexelsMask;
            dest.renderSettingsTexelsDir = src.renderSettingsTexelsDir;
            dest.renderSettingsShowDirWarning = src.renderSettingsShowDirWarning;
            dest.renderSettingsRenderDirMode = src.renderSettingsRenderDirMode;
            dest.renderSettingsShowCheckerSettings = src.renderSettingsShowCheckerSettings;
            dest.renderSettingsSamplesWarning = src.renderSettingsSamplesWarning;
            dest.renderSettingsSuppressPopups = src.renderSettingsSuppressPopups;
            dest.renderSettingsSectorWarning = src.renderSettingsSectorWarning;
            dest.renderSettingsPrefabWarning = src.renderSettingsPrefabWarning;
            dest.renderSettingsSplitByScene = src.renderSettingsSplitByScene;
            dest.renderSettingsSplitByTag = src.renderSettingsSplitByTag;
            dest.renderSettingsUVPaddingMax = src.renderSettingsUVPaddingMax;
            dest.renderSettingsUVPaddingPreserveIfExisted = src.renderSettingsUVPaddingPreserveIfExisted;
            dest.renderSettingsPostPacking = src.renderSettingsPostPacking;
            dest.renderSettingsHoleFilling = src.renderSettingsHoleFilling;
            dest.renderSettingsBruteForce = src.renderSettingsBruteForce;
            dest.renderSettingsAlphaDithering = src.renderSettingsAlphaDithering;
            dest.renderSettingsBeepOnFinish = src.renderSettingsBeepOnFinish;
            dest.renderSettingsExportTerrainAsHeightmap = src.renderSettingsExportTerrainAsHeightmap;
            dest.renderSettingsRTXMode = src.renderSettingsRTXMode;
            dest.renderSettingsLightProbeMode = src.renderSettingsLightProbeMode;
            dest.renderSettingsClientMode = src.renderSettingsClientMode;
            dest.renderSettingsServerAddress = src.renderSettingsServerAddress;
            dest.renderSettingsUnwrapper = src.renderSettingsUnwrapper;
            dest.renderSettingsDenoiserType = src.renderSettingsDenoiserType;
            dest.renderSettingsExportTerrainTrees = src.renderSettingsExportTerrainTrees;
            dest.renderSettingsShowPerf = src.renderSettingsShowPerf;
            dest.renderSettingsSampleDiv = src.renderSettingsSampleDiv;
            dest.renderSettingsBatchPoints = src.renderSettingsBatchPoints;
            dest.renderSettingsCompressVolumes = src.renderSettingsCompressVolumes;
            dest.renderSettingsBatchAreaLightSampleLimit = src.renderSettingsBatchAreaLightSampleLimit;
            dest.renderSettingsRTPVExport = src.renderSettingsRTPVExport;
            dest.renderSettingsRTPVSceneView = src.renderSettingsRTPVSceneView;
            dest.renderSettingsRTPVHDR = src.renderSettingsRTPVHDR;
            dest.renderSettingsRTPVWidth = src.renderSettingsRTPVWidth;
            dest.renderSettingsRTPVHeight = src.renderSettingsRTPVHeight;
            dest.renderSettingsRTPVExposure = src.renderSettingsRTPVExposure;
            dest.renderSettingsAtlasPacker = src.renderSettingsAtlasPacker;
            dest.renderSettingsAutoAtlas = src.renderSettingsAutoAtlas;
            dest.renderSettingsRemoveDuplicateLightmaps = src.renderSettingsRemoveDuplicateLightmaps;
        }
#endif

    public List<Renderer> bakedRenderers = new List<Renderer>();
    public List<Renderer> nonBakedRenderers = new List<Renderer>();
    public List<Light> bakedLights = new List<Light>();
#if USE_TERRAINS
    public List<Terrain> bakedRenderersTerrain = new List<Terrain>();
#endif

#if BAKERY_STORE_OUTSIDE_OF_SCENE
    
    public ftStorageAsset _s;

    void _init()
    {
        var curScenePath = gameObject.scene.path;
        if (_s == null)
        {
            var s = ScriptableObject.CreateInstance<ftStorageAsset>();
            s.path = curScenePath;
            AssetDatabase.CreateAsset(s, System.IO.Path.ChangeExtension(curScenePath, null) + "_lightmapStorage.asset");
            AssetDatabase.SaveAssets();
            _s = s;
        }
        else
        {
            if (_s.path != curScenePath)
            {
                var s = ScriptableObject.CreateInstance<ftStorageAsset>();
                s.path = curScenePath;
                EditorUtility.CopySerialized(_s, s);
                AssetDatabase.CreateAsset(s, System.IO.Path.ChangeExtension(curScenePath, null) + "_lightmapStorage.asset");
                AssetDatabase.SaveAssets();
                _s = s;
            }
        }
        EditorUtility.SetDirty(_s);
    }

    public int[] idremap{get{_init();return _s.idremap;} set{_init();_s.idremap=value;}}

    public List<Texture2D> maps{get{_init();return _s.maps;} set{_init();_s.maps=value;}}
    public List<Texture2D> masks{get{_init();return _s.masks;} set{_init();_s.masks=value;}}
    public List<Texture2D> dirMaps{get{_init();return _s.dirMaps;} set{_init();_s.dirMaps=value;}}
    public List<Texture2D> rnmMaps0{get{_init();return _s.rnmMaps0;} set{_init();_s.rnmMaps0=value;}}
    public List<Texture2D> rnmMaps1{get{_init();return _s.rnmMaps1;} set{_init();_s.rnmMaps1=value;}}
    public List<Texture2D> rnmMaps2{get{_init();return _s.rnmMaps2;} set{_init();_s.rnmMaps2=value;}}
    public List<int> mapsMode{get{_init();return _s.mapsMode;} set{_init();_s.mapsMode=value;}}

    public List<int> bakedIDs{get{_init();return _s.bakedIDs;} set{_init();_s.bakedIDs=value;}}
    public List<Vector4> bakedScaleOffset{get{_init();return _s.bakedScaleOffset;} set{_init();_s.bakedScaleOffset=value;}}
    public List<Mesh> bakedVertexColorMesh{get{_init();return _s.bakedVertexColorMesh;} set{_init();_s.bakedVertexColorMesh=value;}}
    public List<int> bakedLightChannels{get{_init();return _s.bakedLightChannels;} set{_init();_s.bakedLightChannels=value;}}

#if USE_TERRAINS
    public List<int> bakedIDsTerrain{get{_init();return _s.bakedIDsTerrain;} set{_init();_s.bakedIDsTerrain=value;}}
    public List<Vector4> bakedScaleOffsetTerrain{get{_init();return _s.bakedScaleOffsetTerrain;} set{_init();_s.bakedScaleOffsetTerrain=value;}}
#endif

#if UNITY_EDITOR
    public List<LightData> lights{get{_init();return _s.lights;} set{_init();_s.lights=value;}}
    public List<int> bakedVertexOffset{get{_init();return _s.bakedVertexOffset;} set{_init();_s.bakedVertexOffset=value;}}

    public int[] uvBuffOffsets{get{_init();return _s.uvBuffOffsets;} set{_init();_s.uvBuffOffsets=value;}}
    public int[] uvBuffLengths{get{_init();return _s.uvBuffLengths;} set{_init();_s.uvBuffLengths=value;}}
    public float[] uvSrcBuff{get{_init();return _s.uvSrcBuff;} set{_init();_s.uvSrcBuff=value;}}
    public float[] uvDestBuff{get{_init();return _s.uvDestBuff;} set{_init();_s.uvDestBuff=value;}}
    public int[] lmrIndicesOffsets{get{_init();return _s.lmrIndicesOffsets;} set{_init();_s.lmrIndicesOffsets=value;}}
    public int[] lmrIndicesLengths{get{_init();return _s.lmrIndicesLengths;} set{_init();_s.lmrIndicesLengths=value;}}
    public int[] lmrIndicesBuff{get{_init();return _s.lmrIndicesBuff;} set{_init();_s.lmrIndicesBuff=value;}}

    public int[] lmGroupLODResFlags{get{_init();return _s.lmGroupLODResFlags;} set{_init();_s.lmGroupLODResFlags=value;}}
    public int[] lmGroupMinLOD{get{_init();return _s.lmGroupMinLOD;} set{_init();_s.lmGroupMinLOD=value;}}
    public int[] lmGroupLODMatrix{get{_init();return _s.lmGroupLODMatrix;} set{_init();_s.lmGroupLODMatrix=value;}}

    public List<bool> hasEmissive{get{_init();return _s.hasEmissive;} set{_init();_s.hasEmissive=value;}}

    public List<Bounds> bounds{get{_init();return _s.bounds;} set{_init();_s.bounds=value;}}

    public List<string> modifiedAssetPathList{get{_init();return _s.modifiedAssetPathList;} set{_init();_s.modifiedAssetPathList=value;}}
    public List<ftGlobalStorage.AdjustedMesh> modifiedAssets{get{_init();return _s.modifiedAssets;} set{_init();_s.modifiedAssets=value;}}

    public List<string> serverGetFileList{get{_init();return _s.serverGetFileList;} set{_init();_s.serverGetFileList=value;}}
    public List<bool> lightmapHasColor{get{_init();return _s.lightmapHasColor;} set{_init();_s.lightmapHasColor=value;}}
    public List<int> lightmapHasMask{get{_init();return _s.lightmapHasMask;} set{_init();_s.lightmapHasMask=value;}}
    public List<bool> lightmapHasDir{get{_init();return _s.lightmapHasDir;} set{_init();_s.lightmapHasDir=value;}}
    public List<bool> lightmapHasRNM{get{_init();return _s.lightmapHasRNM;} set{_init();_s.lightmapHasRNM=value;}}
    
    public L2[] prevBakedProbes{get{_init();return _s.prevBakedProbes;} set{_init();_s.prevBakedProbes=value;}}
    public Vector3[] prevBakedProbePos{get{_init();return _s.prevBakedProbePos;} set{_init();_s.prevBakedProbePos=value;}}
#endif

#else
    // List of baked lightmaps
    public List<Texture2D> maps = new List<Texture2D>();
    public List<Texture2D> masks = new List<Texture2D>();
    public List<Texture2D> dirMaps = new List<Texture2D>();
    public List<Texture2D> rnmMaps0 = new List<Texture2D>();
    public List<Texture2D> rnmMaps1 = new List<Texture2D>();
    public List<Texture2D> rnmMaps2 = new List<Texture2D>();
    public List<int> mapsMode = new List<int>();

    // new props
    public List<int> bakedIDs = new List<int>();
    public List<Vector4> bakedScaleOffset = new List<Vector4>();
#if UNITY_EDITOR
    public List<int> bakedVertexOffset = new List<int>();
#endif
    public List<Mesh> bakedVertexColorMesh = new List<Mesh>();

    public List<int> bakedLightChannels = new List<int>();

#if USE_TERRAINS
    public List<int> bakedIDsTerrain = new List<int>();
    public List<Vector4> bakedScaleOffsetTerrain = new List<Vector4>();
#endif

    public List<string> assetList = new List<string>();
    public List<int> uvOverlapAssetList = new List<int>(); // -1 = no UV1, 0 = no overlap, 1 = overlap

    public int[] idremap;
#endif

    public bool usesRealtimeGI;

    public Texture2D emptyDirectionTex;

    public bool anyVolumes = false;
    public bool compressedVolumes = false;

#if UNITY_EDITOR
    [System.Serializable]
    public class SectorData
    {
        public string name;

        public List<Texture2D> maps = new List<Texture2D>();
        public List<Texture2D> masks = new List<Texture2D>();
        public List<Texture2D> dirMaps = new List<Texture2D>();
        public List<Texture2D> rnmMaps0 = new List<Texture2D>();
        public List<Texture2D> rnmMaps1 = new List<Texture2D>();
        public List<Texture2D> rnmMaps2 = new List<Texture2D>();
        public List<int> mapsMode = new List<int>();

        public List<Renderer> bakedRenderers = new List<Renderer>();
        public List<int> bakedIDs = new List<int>();
        public List<Vector4> bakedScaleOffset = new List<Vector4>();
        public List<Mesh> bakedVertexColorMesh = new List<Mesh>();

#if USE_TERRAINS
        public List<Terrain> bakedRenderersTerrain = new List<Terrain>();
        public List<int> bakedIDsTerrain = new List<int>();
        public List<Vector4> bakedScaleOffsetTerrain = new List<Vector4>();
#endif

        public List<Renderer> nonBakedRenderers = new List<Renderer>();
    }

    public List<SectorData> sectors = new List<SectorData>();

    // Unity cannot serialize SphericalHarmonicsL2
    [System.Serializable]
    public struct L2
    {
        public float f00;
        public float f10;
        public float f20;

        public float f01;
        public float f11;
        public float f21;

        public float f02;
        public float f12;
        public float f22;

        public float f03;
        public float f13;
        public float f23;

        public float f04;
        public float f14;
        public float f24;

        public float f05;
        public float f15;
        public float f25;

        public float f06;
        public float f16;
        public float f26;

        public float f07;
        public float f17;
        public float f27;

        public float f08;
        public float f18;
        public float f28;

        public SphericalHarmonicsL2 GetSH()
        {
            var sh = new SphericalHarmonicsL2();

            sh[0,0] = f00;
            sh[1,0] = f10;
            sh[2,0] = f20;

            sh[0,1] = f01;
            sh[1,1] = f11;
            sh[2,1] = f21;

            sh[0,2] = f02;
            sh[1,2] = f12;
            sh[2,2] = f22;

            sh[0,3] = f03;
            sh[1,3] = f13;
            sh[2,3] = f23;

            sh[0,4] = f04;
            sh[1,4] = f14;
            sh[2,4] = f24;

            sh[0,5] = f05;
            sh[1,5] = f15;
            sh[2,5] = f25;

            sh[0,6] = f06;
            sh[1,6] = f16;
            sh[2,6] = f26;

            sh[0,7] = f07;
            sh[1,7] = f17;
            sh[2,7] = f27;

            sh[0,8] = f08;
            sh[1,8] = f18;
            sh[2,8] = f28;

            return sh;
        }

        public void SetSH(SphericalHarmonicsL2 sh)
        {
            f00 = sh[0,0];
            f10 = sh[1,0];
            f20 = sh[2,0];

            f01 = sh[0,1];
            f11 = sh[1,1];
            f21 = sh[2,1];

            f02 = sh[0,2];
            f12 = sh[1,2];
            f22 = sh[2,2];

            f03 = sh[0,3];
            f13 = sh[1,3];
            f23 = sh[2,3];

            f04 = sh[0,4];
            f14 = sh[1,4];
            f24 = sh[2,4];

            f05 = sh[0,5];
            f15 = sh[1,5];
            f25 = sh[2,5];

            f06 = sh[0,6];
            f16 = sh[1,6];
            f26 = sh[2,6];

            f07 = sh[0,7];
            f17 = sh[1,7];
            f27 = sh[2,7];
            
            f08 = sh[0,8];
            f18 = sh[1,8];
            f28 = sh[2,8];
        }
    };

#if BAKERY_STORE_OUTSIDE_OF_SCENE
#else
    public L2[] prevBakedProbes;
    public Vector3[] prevBakedProbePos;
#endif

#endif

    void Awake()
    {
        ftLightmaps.RefreshScene(gameObject.scene, this, false, true);
    }

    void Start()
    {
        // Unity can for some reason alter lightmapIndex after the scene is loaded in a multi-scene setup, so fix that
#if UNITY_2021_1_OR_NEWER
         ftLightmaps.RefreshScene(gameObject.scene, this, false, false); // new Unity can destroy lightmaps after Awake if the lighting data asset is set
#endif
        ftLightmaps.RefreshScene2(gameObject.scene, this);//, appendOffset);

#if VALIDATE_MULTIPLE_STORAGES
        if (sceneToStorage == null) sceneToStorage = new Dictionary<Scene, ftLightmapsStorage>();
        if (gameObject.name == "!ftraceLightmaps")
        {
            ftLightmapsStorage existing;
            sceneToStorage.TryGetValue(gameObject.scene, out existing);
            if (existing != null && existing != this)
            {
                Debug.LogError("Multiple lightmap storages detected. Try Bakery->Utilities->Clear baked data (Data and Settings) and rebaking. If you remember a specific sequence of actions leading to this error, please report to https://github.com/guycalledfrank/bakery-issues/issues");
            }
            sceneToStorage[gameObject.scene] = this;
        }
#endif
    }

    void OnDestroy()
    {
        ftLightmaps.UnloadScene(this);
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/ftLightmapsStorage.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/ftLocalStorage.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 05ca84e725c7c764aa5ed097918d14b7
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
using UnityEngine;
using System.Collections.Generic;

#if UNITY_EDITOR
using UnityEditor;
#endif

public class ftLocalStorage : ScriptableObject
{
    [SerializeField]
    public List<string> modifiedAssetPathList = new List<string>(); // marks model as processed

    [SerializeField]
    public List<int> modifiedAssetPaddingHash = new List<int>();
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/ftLocalStorage.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/ftSettingsAsset.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 865d4ba4c897b7740aeef30667eab799
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
#if UNITY_EDITOR

using UnityEngine;
using System.Collections.Generic;
using UnityEditor;

public class ftSettingsAsset : ScriptableObject
{
    // Defaults
    [SerializeField]
    public int renderSettingsBounces = 5;
    [SerializeField]
    public int renderSettingsGISamples = 16;
    [SerializeField]
    public float renderSettingsGIBackFaceWeight = 0;
    [SerializeField]
    public int renderSettingsTileSize = 512;
    [SerializeField]
    public float renderSettingsPriority = 2;
    [SerializeField]
    public float renderSettingsTexelsPerUnit = 20;
    [SerializeField]
    public bool renderSettingsForceRefresh = true;
    [SerializeField]
    public bool renderSettingsForceRebuildGeometry = true;
    [SerializeField]
    public bool renderSettingsPerformRendering = true;
    [SerializeField]
    public int renderSettingsUserRenderMode = 0;
    [SerializeField]
    public bool renderSettingsDistanceShadowmask = false;
    [SerializeField]
    public int renderSettingsSettingsMode = 0;
    [SerializeField]
    public bool renderSettingsFixSeams = true;
    [SerializeField]
    public bool renderSettingsDenoise = true;
    [SerializeField]
    public bool renderSettingsDenoise2x = false;
    [SerializeField]
    public bool renderSettingsEncode = true;
    [SerializeField]
    public int renderSettingsEncodeMode = 0;
    [SerializeField]
    public bool renderSettingsOverwriteWarning = false;
    [SerializeField]
    public bool renderSettingsAutoAtlas = true;
    [SerializeField]
    public bool renderSettingsUnwrapUVs = true;
    [SerializeField]
    public bool renderSettingsForceDisableUnwrapUVs = false;
    [SerializeField]
    public int renderSettingsMaxAutoResolution = 4096;
    [SerializeField]
    public int renderSettingsMinAutoResolution = 16;
    [SerializeField]
    public bool renderSettingsUnloadScenes = true;
    [SerializeField]
    public bool renderSettingsAdjustSamples = true;
    [SerializeField]
    public bool renderSettingsCheckOverlaps = false;
    [SerializeField]
    public bool renderSettingsSkipOutOfBoundsUVs = true;
    [SerializeField]
    public float renderSettingsHackEmissiveBoost = 1;
    [SerializeField]
    public float renderSettingsHackIndirectBoost = 1;
    [SerializeField]
    public string renderSettingsTempPath = "";
    [SerializeField]
    public string renderSettingsOutPath = "";
    [SerializeField]
    public bool renderSettingsUseScenePath = false;
    [SerializeField]
    public float renderSettingsHackAOIntensity = 0;
    [SerializeField]
    public int renderSettingsHackAOSamples = 16;
    [SerializeField]
    public bool renderSettingsHackAOSofter = false;
    [SerializeField]
    public float renderSettingsHackAORadius = 1;
    [SerializeField]
    public bool renderSettingsShowAOSettings = false;
    [SerializeField]
    public bool renderSettingsShowTasks = true;
    [SerializeField]
    public bool renderSettingsShowTasks2 = false;
    [SerializeField]
    public bool renderSettingsShowPaths = true;
    [SerializeField]
    public bool renderSettingsShowNet = true;
    [SerializeField]
    public bool renderSettingsShowSettingsAsset = false;
    [SerializeField]
    public bool renderSettingsShowAPV = false;
    [SerializeField]
    public bool renderSettingsUseAPVSkyOcclusion = false;
    [SerializeField]
    public bool renderSettingsOcclusionProbes = false;
    [SerializeField]
    public bool renderSettingsTexelsPerMap = false;
    [SerializeField]
    public float renderSettingsTexelsColor = 1;
    [SerializeField]
    public float renderSettingsTexelsMask = 1;
    [SerializeField]
    public float renderSettingsTexelsDir = 1;
    [SerializeField]
    public bool renderSettingsShowDirWarning = true;
    [SerializeField]
    public int renderSettingsRenderDirMode = 0;
    [SerializeField]
    public bool renderSettingsShowCheckerSettings = false;
    [SerializeField]
    public bool renderSettingsSamplesWarning = true;
    [SerializeField]
    public bool renderSettingsSuppressPopups = false;
    [SerializeField]
    public bool renderSettingsSectorWarning = false;
    [SerializeField]
    public bool renderSettingsPrefabWarning = true;
    [SerializeField]
    public bool renderSettingsSplitByScene = false;
    [SerializeField]
    public bool renderSettingsSplitByTag = false;
    [SerializeField]
    public bool renderSettingsUVPaddingMax = false;
    [SerializeField]
    public bool renderSettingsUVPaddingPreserveIfExisted = false;
    [SerializeField]
    public bool renderSettingsPostPacking = true;
    [SerializeField]
    public bool renderSettingsHoleFilling = false;
    [SerializeField]
    public bool renderSettingsBruteForce = true;
    [SerializeField]
    public bool renderSettingsAlphaDithering = false;
    [SerializeField]
    public bool renderSettingsBeepOnFinish = false;
    [SerializeField]
    public bool renderSettingsExportTerrainAsHeightmap = true;
    [SerializeField]
    public bool renderSettingsRTXMode = false;
    [SerializeField]
    public int renderSettingsLightProbeMode = 1;
    [SerializeField]
    public bool renderSettingsClientMode = false;
    [SerializeField]
    public string renderSettingsServerAddress = "127.0.0.1";
    [SerializeField]
    public int renderSettingsUnwrapper = 0;
    [SerializeField]
    public int renderSettingsDenoiserType = (int)ftGlobalStorage.DenoiserType.OpenImageDenoise;
    [SerializeField]
    public bool renderSettingsExportTerrainTrees = false;
    [SerializeField]
    public bool renderSettingsShowPerf = true;
    [SerializeField]
    public int renderSettingsSampleDiv = 1;
    //[SerializeField]
    //public bool renderSettingsLegacyDenoiser = false;
    [SerializeField]
    public ftGlobalStorage.AtlasPacker renderSettingsAtlasPacker = ftGlobalStorage.AtlasPacker.Default;
    [SerializeField]
    public bool renderSettingsBatchPoints = true;
    [SerializeField]
    public bool renderSettingsCompressVolumes = false;
    [SerializeField]
    public int renderSettingsBatchAreaLightSampleLimit = 0;
    [SerializeField]
    public bool renderSettingsRTPVExport = true;
    [SerializeField]
    public bool renderSettingsRTPVSceneView = false;
    [SerializeField]
    public bool renderSettingsRTPVHDR = false;
    [SerializeField]
    public int renderSettingsRTPVWidth = 640;
    [SerializeField]
    public int renderSettingsRTPVHeight = 360;
    [SerializeField]
    public float renderSettingsRTPVExposure = 1.0f;

    [SerializeField]
    public bool renderSettingsRemoveDuplicateLightmaps = false;
}

#endif
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/ftSettingsAsset.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Bakery/ftStorageAsset.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cb5307357a713e3418d2049bee218850
# ASMDEF: BakeryRuntimeAssembly.dll
# ---
#define USE_TERRAINS

using UnityEngine;
using System.Collections.Generic;

public class ftStorageAsset : ScriptableObject
{
#if UNITY_EDITOR

    [SerializeField]
    public string path;

    // Light settings from the last bake
    [SerializeField]
    public List<ftLightmapsStorage.LightData> lights = new List<ftLightmapsStorage.LightData>();

    // List of baked lightmap world-space bounds
    [SerializeField]
    public List<Bounds> bounds = new List<Bounds>();

    // Per-lightmap flags
    [SerializeField]
    public List<bool> hasEmissive = new List<bool>();

    [SerializeField]
    public int[] uvBuffOffsets;
    [SerializeField]
    public int[] uvBuffLengths;
    [SerializeField]
    public float[] uvSrcBuff;
    [SerializeField]
    public float[] uvDestBuff;
    [SerializeField]
    public int[] lmrIndicesOffsets;
    [SerializeField]
    public int[] lmrIndicesLengths;
    [SerializeField]
    public int[] lmrIndicesBuff;

    [SerializeField]
    public int[] lmGroupLODResFlags; // bits which lods are needed for which LMGroups
    [SerializeField]
    public int[] lmGroupMinLOD; // minimum possible resolution for given LMGroup given UV island count
    [SerializeField]
    public int[] lmGroupLODMatrix;

    // Reuired for network bakes
    [SerializeField]
    public List<string> serverGetFileList = new List<string>();
    [SerializeField]
    public List<bool> lightmapHasColor = new List<bool>();
    [SerializeField]
    public List<int> lightmapHasMask = new List<int>();
    [SerializeField]
    public List<bool> lightmapHasDir = new List<bool>();
    [SerializeField]
    public List<bool> lightmapHasRNM = new List<bool>();

    // Partial copy of GlobalStorage to recover UV padding if needed
    [SerializeField]
    public List<string> modifiedAssetPathList = new List<string>();
    [SerializeField]
    public List<ftGlobalStorage.AdjustedMesh> modifiedAssets = new List<ftGlobalStorage.AdjustedMesh>();
    [SerializeField]
    public ftLightmapsStorage.L2[] prevBakedProbes;
    [SerializeField]
    public Vector3[] prevBakedProbePos;
#endif

    // List of baked lightmaps
    [SerializeField]
    public List<Texture2D> maps = new List<Texture2D>();
    [SerializeField]
    public List<Texture2D> masks = new List<Texture2D>();
    [SerializeField]
    public List<Texture2D> dirMaps = new List<Texture2D>();
    [SerializeField]
    public List<Texture2D> rnmMaps0 = new List<Texture2D>();
    [SerializeField]
    public List<Texture2D> rnmMaps1 = new List<Texture2D>();
    [SerializeField]
    public List<Texture2D> rnmMaps2 = new List<Texture2D>();
    [SerializeField]
    public List<int> mapsMode = new List<int>();

    // new props
    [SerializeField]
    public List<int> bakedIDs = new List<int>();
    [SerializeField]
    public List<Vector4> bakedScaleOffset = new List<Vector4>();
#if UNITY_EDITOR
    [SerializeField]
    public List<int> bakedVertexOffset = new List<int>();
#endif
    [SerializeField]
    public List<Mesh> bakedVertexColorMesh = new List<Mesh>();

    [SerializeField]
    public List<int> bakedLightChannels = new List<int>();

#if USE_TERRAINS
    [SerializeField]
    public List<int> bakedIDsTerrain = new List<int>();
    [SerializeField]
    public List<Vector4> bakedScaleOffsetTerrain = new List<Vector4>();
#endif

    [SerializeField]
    public List<string> assetList = new List<string>();
    [SerializeField]
    public List<int> uvOverlapAssetList = new List<int>(); // -1 = no UV1, 0 = no overlap, 1 = overlap

    [SerializeField]
    public int[] idremap;
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Bakery/ftStorageAsset.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModuleAudio.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b766d08851589514b97afb23c6f30a70
# ASMDEF: DOTween.Modules.dll
# ---
// Author: Daniele Giardini - http://www.demigiant.com
// Created: 2018/07/13

#if true // MODULE_MARKER
using System;
using DG.Tweening.Core;
using DG.Tweening.Plugins.Options;
using UnityEngine;
#if UNITY_5 || UNITY_2017_1_OR_NEWER
using UnityEngine.Audio; // Required for AudioMixer
#endif

#pragma warning disable 1591
namespace DG.Tweening
{
	public static class DOTweenModuleAudio
    {
        #region Shortcuts

        #region Audio

        /// <summary>Tweens an AudioSource's volume to the given value.
        /// Also stores the AudioSource as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach (0 to 1)</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<float, float, FloatOptions> DOFade(this AudioSource target, float endValue, float duration)
        {
            if (endValue < 0) endValue = 0;
            else if (endValue > 1) endValue = 1;
            TweenerCore<float, float, FloatOptions> t = DOTween.To(() => target.volume, x => target.volume = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens an AudioSource's pitch to the given value.
        /// Also stores the AudioSource as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<float, float, FloatOptions> DOPitch(this AudioSource target, float endValue, float duration)
        {
            TweenerCore<float, float, FloatOptions> t = DOTween.To(() => target.pitch, x => target.pitch = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        #endregion

#if UNITY_5 || UNITY_2017_1_OR_NEWER
        #region AudioMixer (Unity 5 or Newer)

        /// <summary>Tweens an AudioMixer's exposed float to the given value.
        /// Also stores the AudioMixer as the tween's target so it can be used for filtered operations.
        /// Note that you need to manually expose a float in an AudioMixerGroup in order to be able to tween it from an AudioMixer.</summary>
        /// <param name="floatName">Name given to the exposed float to set</param>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<float, float, FloatOptions> DOSetFloat(this AudioMixer target, string floatName, float endValue, float duration)
        {
            TweenerCore<float, float, FloatOptions> t = DOTween.To(()=> {
                    float currVal;
                    target.GetFloat(floatName, out currVal);
                    return currVal;
                }, x=> target.SetFloat(floatName, x), endValue, duration);
            t.SetTarget(target);
            return t;
        }

        #region Operation Shortcuts

        /// <summary>
        /// Completes all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens completed
        /// (meaning the tweens that don't have infinite loops and were not already complete)
        /// </summary>
        /// <param name="withCallbacks">For Sequences only: if TRUE also internal Sequence callbacks will be fired,
        /// otherwise they will be ignored</param>
        public static int DOComplete(this AudioMixer target, bool withCallbacks = false)
        {
            return DOTween.Complete(target, withCallbacks);
        }

        /// <summary>
        /// Kills all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens killed.
        /// </summary>
        /// <param name="complete">If TRUE completes the tween before killing it</param>
        public static int DOKill(this AudioMixer target, bool complete = false)
        {
            return DOTween.Kill(target, complete);
        }

        /// <summary>
        /// Flips the direction (backwards if it was going forward or viceversa) of all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens flipped.
        /// </summary>
        public static int DOFlip(this AudioMixer target)
        {
            return DOTween.Flip(target);
        }

        /// <summary>
        /// Sends to the given position all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens involved.
        /// </summary>
        /// <param name="to">Time position to reach
        /// (if higher than the whole tween duration the tween will simply reach its end)</param>
        /// <param name="andPlay">If TRUE will play the tween after reaching the given position, otherwise it will pause it</param>
        public static int DOGoto(this AudioMixer target, float to, bool andPlay = false)
        {
            return DOTween.Goto(target, to, andPlay);
        }

        /// <summary>
        /// Pauses all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens paused.
        /// </summary>
        public static int DOPause(this AudioMixer target)
        {
            return DOTween.Pause(target);
        }

        /// <summary>
        /// Plays all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens played.
        /// </summary>
        public static int DOPlay(this AudioMixer target)
        {
            return DOTween.Play(target);
        }

        /// <summary>
        /// Plays backwards all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens played.
        /// </summary>
        public static int DOPlayBackwards(this AudioMixer target)
        {
            return DOTween.PlayBackwards(target);
        }

        /// <summary>
        /// Plays forward all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens played.
        /// </summary>
        public static int DOPlayForward(this AudioMixer target)
        {
            return DOTween.PlayForward(target);
        }

        /// <summary>
        /// Restarts all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens restarted.
        /// </summary>
        public static int DORestart(this AudioMixer target)
        {
            return DOTween.Restart(target);
        }

        /// <summary>
        /// Rewinds all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens rewinded.
        /// </summary>
        public static int DORewind(this AudioMixer target)
        {
            return DOTween.Rewind(target);
        }

        /// <summary>
        /// Smoothly rewinds all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens rewinded.
        /// </summary>
        public static int DOSmoothRewind(this AudioMixer target)
        {
            return DOTween.SmoothRewind(target);
        }

        /// <summary>
        /// Toggles the paused state (plays if it was paused, pauses if it was playing) of all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens involved.
        /// </summary>
        public static int DOTogglePause(this AudioMixer target)
        {
            return DOTween.TogglePause(target);
        }

        #endregion

        #endregion
#endif

        #endregion
    }
}
#endif
# --- end Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModuleAudio.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModuleEPOOutline.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e944529dcaee98f4e9498d80e541d93e
# ASMDEF: DOTween.Modules.dll
# ---
using UnityEngine;

#if false || EPO_DOTWEEN // MODULE_MARKER

using EPOOutline;
using DG.Tweening.Plugins.Options;
using DG.Tweening;
using DG.Tweening.Core;

namespace DG.Tweening
{
    public static class DOTweenModuleEPOOutline
    {
        public static int DOKill(this SerializedPass target, bool complete)
        {
            return DOTween.Kill(target, complete);
        }

        public static TweenerCore<float, float, FloatOptions> DOFloat(this SerializedPass target, string propertyName, float endValue, float duration)
        {
            var tweener = DOTween.To(() => target.GetFloat(propertyName), x => target.SetFloat(propertyName, x), endValue, duration);
            tweener.SetOptions(true).SetTarget(target);
            return tweener;
        }

        public static TweenerCore<Color, Color, ColorOptions> DOFade(this SerializedPass target, string propertyName, float endValue, float duration)
        {
            var tweener = DOTween.ToAlpha(() => target.GetColor(propertyName), x => target.SetColor(propertyName, x), endValue, duration);
            tweener.SetOptions(true).SetTarget(target);
            return tweener;
        }

        public static TweenerCore<Color, Color, ColorOptions> DOColor(this SerializedPass target, string propertyName, Color endValue, float duration)
        {
            var tweener = DOTween.To(() => target.GetColor(propertyName), x => target.SetColor(propertyName, x), endValue, duration);
            tweener.SetOptions(false).SetTarget(target);
            return tweener;
        }

        public static TweenerCore<Vector4, Vector4, VectorOptions> DOVector(this SerializedPass target, string propertyName, Vector4 endValue, float duration)
        {
            var tweener = DOTween.To(() => target.GetVector(propertyName), x => target.SetVector(propertyName, x), endValue, duration);
            tweener.SetOptions(false).SetTarget(target);
            return tweener;
        }

        public static TweenerCore<float, float, FloatOptions> DOFloat(this SerializedPass target, int propertyId, float endValue, float duration)
        {
            var tweener = DOTween.To(() => target.GetFloat(propertyId), x => target.SetFloat(propertyId, x), endValue, duration);
            tweener.SetOptions(true).SetTarget(target);
            return tweener;
        }

        public static TweenerCore<Color, Color, ColorOptions> DOFade(this SerializedPass target, int propertyId, float endValue, float duration)
        {
            var tweener = DOTween.ToAlpha(() => target.GetColor(propertyId), x => target.SetColor(propertyId, x), endValue, duration);
            tweener.SetOptions(true).SetTarget(target);
            return tweener;
        }

        public static TweenerCore<Color, Color, ColorOptions> DOColor(this SerializedPass target, int propertyId, Color endValue, float duration)
        {
            var tweener = DOTween.To(() => target.GetColor(propertyId), x => target.SetColor(propertyId, x), endValue, duration);
            tweener.SetOptions(false).SetTarget(target);
            return tweener;
        }

        public static TweenerCore<Vector4, Vector4, VectorOptions> DOVector(this SerializedPass target, int propertyId, Vector4 endValue, float duration)
        {
            var tweener = DOTween.To(() => target.GetVector(propertyId), x => target.SetVector(propertyId, x), endValue, duration);
            tweener.SetOptions(false).SetTarget(target);
            return tweener;
        }

        public static int DOKill(this Outlinable.OutlineProperties target, bool complete = false)
        {
            return DOTween.Kill(target, complete);
        }

        public static int DOKill(this Outliner target, bool complete = false)
        {
            return DOTween.Kill(target, complete);
        }

        public static TweenerCore<Color, Color, ColorOptions> DOFade(this Outlinable.OutlineProperties target, float endValue, float duration)
        {
            var tweener = DOTween.ToAlpha(() => target.Color, x => target.Color = x, endValue, duration);
            tweener.SetOptions(true).SetTarget(target);
            return tweener;
        }

        public static TweenerCore<Color, Color, ColorOptions> DOColor(this Outlinable.OutlineProperties target, Color endValue, float duration)
        {
            var tweener = DOTween.To(() => target.Color, x => target.Color = x, endValue, duration);
            tweener.SetOptions(false).SetTarget(target);
            return tweener;
        }

        public static TweenerCore<float, float, FloatOptions> DODilateShift(this Outlinable.OutlineProperties target, float endValue, float duration, bool snapping = false)
        {
            var tweener = DOTween.To(() => target.DilateShift, x => target.DilateShift = x, endValue, duration);
            tweener.SetOptions(snapping).SetTarget(target);
            return tweener;
        }

        public static TweenerCore<float, float, FloatOptions> DOBlurShift(this Outlinable.OutlineProperties target, float endValue, float duration, bool snapping = false)
        {
            var tweener = DOTween.To(() => target.BlurShift, x => target.BlurShift = x, endValue, duration);
            tweener.SetOptions(snapping).SetTarget(target);
            return tweener;
        }

        public static TweenerCore<float, float, FloatOptions> DOBlurShift(this Outliner target, float endValue, float duration, bool snapping = false)
        {
            var tweener = DOTween.To(() => target.BlurShift, x => target.BlurShift = x, endValue, duration);
            tweener.SetOptions(snapping).SetTarget(target);
            return tweener;
        }

        public static TweenerCore<float, float, FloatOptions> DODilateShift(this Outliner target, float endValue, float duration, bool snapping = false)
        {
            var tweener = DOTween.To(() => target.DilateShift, x => target.DilateShift = x, endValue, duration);
            tweener.SetOptions(snapping).SetTarget(target);
            return tweener;
        }

        public static TweenerCore<float, float, FloatOptions> DOInfoRendererScale(this Outliner target, float endValue, float duration, bool snapping = false)
        {
            var tweener = DOTween.To(() => target.InfoRendererScale, x => target.InfoRendererScale = x, endValue, duration);
            tweener.SetOptions(snapping).SetTarget(target);
            return tweener;
        }

        public static TweenerCore<float, float, FloatOptions> DOPrimaryRendererScale(this Outliner target, float endValue, float duration, bool snapping = false)
        {
            var tweener = DOTween.To(() => target.PrimaryRendererScale, x => target.PrimaryRendererScale = x, endValue, duration);
            tweener.SetOptions(snapping).SetTarget(target);
            return tweener;
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModuleEPOOutline.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModulePhysics.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: dae9aa560b4242648a3affa2bfabc365
# ASMDEF: DOTween.Modules.dll
# ---
// Author: Daniele Giardini - http://www.demigiant.com
// Created: 2018/07/13

#if true // MODULE_MARKER
using System;
using DG.Tweening.Core;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins;
using DG.Tweening.Plugins.Core.PathCore;
using DG.Tweening.Plugins.Options;
using UnityEngine;

#pragma warning disable 1591
namespace DG.Tweening
{
	public static class DOTweenModulePhysics
    {
        #region Shortcuts

        #region Rigidbody

        /// <summary>Tweens a Rigidbody's position to the given value.
        /// Also stores the rigidbody as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector3, Vector3, VectorOptions> DOMove(this Rigidbody target, Vector3 endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.position, target.MovePosition, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Rigidbody's X position to the given value.
        /// Also stores the rigidbody as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector3, Vector3, VectorOptions> DOMoveX(this Rigidbody target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.position, target.MovePosition, new Vector3(endValue, 0, 0), duration);
            t.SetOptions(AxisConstraint.X, snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Rigidbody's Y position to the given value.
        /// Also stores the rigidbody as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector3, Vector3, VectorOptions> DOMoveY(this Rigidbody target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.position, target.MovePosition, new Vector3(0, endValue, 0), duration);
            t.SetOptions(AxisConstraint.Y, snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Rigidbody's Z position to the given value.
        /// Also stores the rigidbody as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector3, Vector3, VectorOptions> DOMoveZ(this Rigidbody target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.position, target.MovePosition, new Vector3(0, 0, endValue), duration);
            t.SetOptions(AxisConstraint.Z, snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Rigidbody's rotation to the given value.
        /// Also stores the rigidbody as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="mode">Rotation mode</param>
        public static TweenerCore<Quaternion, Vector3, QuaternionOptions> DORotate(this Rigidbody target, Vector3 endValue, float duration, RotateMode mode = RotateMode.Fast)
        {
            TweenerCore<Quaternion, Vector3, QuaternionOptions> t = DOTween.To(() => target.rotation, target.MoveRotation, endValue, duration);
            t.SetTarget(target);
            t.plugOptions.rotateMode = mode;
            return t;
        }

        /// <summary>Tweens a Rigidbody's rotation so that it will look towards the given position.
        /// Also stores the rigidbody as the tween's target so it can be used for filtered operations</summary>
        /// <param name="towards">The position to look at</param><param name="duration">The duration of the tween</param>
        /// <param name="axisConstraint">Eventual axis constraint for the rotation</param>
        /// <param name="up">The vector that defines in which direction up is (default: Vector3.up)</param>
        public static TweenerCore<Quaternion, Vector3, QuaternionOptions> DOLookAt(this Rigidbody target, Vector3 towards, float duration, AxisConstraint axisConstraint = AxisConstraint.None, Vector3? up = null)
        {
            TweenerCore<Quaternion, Vector3, QuaternionOptions> t = DOTween.To(() => target.rotation, target.MoveRotation, towards, duration)
                .SetTarget(target).SetSpecialStartupMode(SpecialStartupMode.SetLookAt);
            t.plugOptions.axisConstraint = axisConstraint;
            t.plugOptions.up = (up == null) ? Vector3.up : (Vector3)up;
            return t;
        }

        #region Special

        /// <summary>Tweens a Rigidbody's position to the given value, while also applying a jump effect along the Y axis.
        /// Returns a Sequence instead of a Tweener.
        /// Also stores the Rigidbody as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param>
        /// <param name="jumpPower">Power of the jump (the max height of the jump is represented by this plus the final Y offset)</param>
        /// <param name="numJumps">Total number of jumps</param>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static Sequence DOJump(this Rigidbody target, Vector3 endValue, float jumpPower, int numJumps, float duration, bool snapping = false)
        {
            if (numJumps < 1) numJumps = 1;
            float startPosY = 0;
            float offsetY = -1;
            bool offsetYSet = false;
            Sequence s = DOTween.Sequence();
            Tween yTween = DOTween.To(() => target.position, target.MovePosition, new Vector3(0, jumpPower, 0), duration / (numJumps * 2))
                .SetOptions(AxisConstraint.Y, snapping).SetEase(Ease.OutQuad).SetRelative()
                .SetLoops(numJumps * 2, LoopType.Yoyo)
                .OnStart(() => startPosY = target.position.y);
            s.Append(DOTween.To(() => target.position, target.MovePosition, new Vector3(endValue.x, 0, 0), duration)
                    .SetOptions(AxisConstraint.X, snapping).SetEase(Ease.Linear)
                ).Join(DOTween.To(() => target.position, target.MovePosition, new Vector3(0, 0, endValue.z), duration)
                    .SetOptions(AxisConstraint.Z, snapping).SetEase(Ease.Linear)
                ).Join(yTween)
                .SetTarget(target).SetEase(DOTween.defaultEaseType);
            yTween.OnUpdate(() => {
                if (!offsetYSet) {
                    offsetYSet = true;
                    offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                }
                Vector3 pos = target.position;
                pos.y += DOVirtual.EasedValue(0, offsetY, yTween.ElapsedPercentage(), Ease.OutQuad);
                target.MovePosition(pos);
            });
            return s;
        }

        /// <summary>Tweens a Rigidbody's position through the given path waypoints, using the chosen path algorithm.
        /// Also stores the Rigidbody as the tween's target so it can be used for filtered operations.
        /// <para>NOTE: to tween a rigidbody correctly it should be set to kinematic at least while being tweened.</para>
        /// <para>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
        /// If you plan to publish there you should use a regular transform.DOPath.</para></summary>
        /// <param name="path">The waypoints to go through</param>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="pathType">The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)</param>
        /// <param name="pathMode">The path mode: 3D, side-scroller 2D, top-down 2D</param>
        /// <param name="resolution">The resolution of the path (useless in case of Linear paths): higher resolutions make for more detailed curved paths but are more expensive.
        /// Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints</param>
        /// <param name="gizmoColor">The color of the path (shown when gizmos are active in the Play panel and the tween is running)</param>
        public static TweenerCore<Vector3, Path, PathOptions> DOPath(
            this Rigidbody target, Vector3[] path, float duration, PathType pathType = PathType.Linear,
            PathMode pathMode = PathMode.Full3D, int resolution = 10, Color? gizmoColor = null
        )
        {
            if (resolution < 1) resolution = 1;
            TweenerCore<Vector3, Path, PathOptions> t = DOTween.To(PathPlugin.Get(), () => target.position, target.MovePosition, new Path(pathType, path, resolution, gizmoColor), duration)
                .SetTarget(target).SetUpdate(UpdateType.Fixed);

            t.plugOptions.isRigidbody = true;
            t.plugOptions.mode = pathMode;
            return t;
        }
        /// <summary>Tweens a Rigidbody's localPosition through the given path waypoints, using the chosen path algorithm.
        /// Also stores the Rigidbody as the tween's target so it can be used for filtered operations
        /// <para>NOTE: to tween a rigidbody correctly it should be set to kinematic at least while being tweened.</para>
        /// <para>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
        /// If you plan to publish there you should use a regular transform.DOLocalPath.</para></summary>
        /// <param name="path">The waypoint to go through</param>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="pathType">The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)</param>
        /// <param name="pathMode">The path mode: 3D, side-scroller 2D, top-down 2D</param>
        /// <param name="resolution">The resolution of the path: higher resolutions make for more detailed curved paths but are more expensive.
        /// Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints</param>
        /// <param name="gizmoColor">The color of the path (shown when gizmos are active in the Play panel and the tween is running)</param>
        public static TweenerCore<Vector3, Path, PathOptions> DOLocalPath(
            this Rigidbody target, Vector3[] path, float duration, PathType pathType = PathType.Linear,
            PathMode pathMode = PathMode.Full3D, int resolution = 10, Color? gizmoColor = null
        )
        {
            if (resolution < 1) resolution = 1;
            Transform trans = target.transform;
            TweenerCore<Vector3, Path, PathOptions> t = DOTween.To(PathPlugin.Get(), () => trans.localPosition, x => target.MovePosition(trans.parent == null ? x : trans.parent.TransformPoint(x)), new Path(pathType, path, resolution, gizmoColor), duration)
                .SetTarget(target).SetUpdate(UpdateType.Fixed);

            t.plugOptions.isRigidbody = true;
            t.plugOptions.mode = pathMode;
            t.plugOptions.useLocalPosition = true;
            return t;
        }
        // Used by path editor when creating the actual tween, so it can pass a pre-compiled path
        internal static TweenerCore<Vector3, Path, PathOptions> DOPath(
            this Rigidbody target, Path path, float duration, PathMode pathMode = PathMode.Full3D
        )
        {
            TweenerCore<Vector3, Path, PathOptions> t = DOTween.To(PathPlugin.Get(), () => target.position, target.MovePosition, path, duration)
                .SetTarget(target);

            t.plugOptions.isRigidbody = true;
            t.plugOptions.mode = pathMode;
            return t;
        }
        internal static TweenerCore<Vector3, Path, PathOptions> DOLocalPath(
            this Rigidbody target, Path path, float duration, PathMode pathMode = PathMode.Full3D
        )
        {
            Transform trans = target.transform;
            TweenerCore<Vector3, Path, PathOptions> t = DOTween.To(PathPlugin.Get(), () => trans.localPosition, x => target.MovePosition(trans.parent == null ? x : trans.parent.TransformPoint(x)), path, duration)
                .SetTarget(target);

            t.plugOptions.isRigidbody = true;
            t.plugOptions.mode = pathMode;
            t.plugOptions.useLocalPosition = true;
            return t;
        }

        #endregion

        #endregion

        #endregion
	}
}
#endif
# --- end Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModulePhysics.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModulePhysics2D.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 230fe34542e175245ba74b4659dae700
# ASMDEF: DOTween.Modules.dll
# ---
// Author: Daniele Giardini - http://www.demigiant.com
// Created: 2018/07/13

#if false && (UNITY_4_3 || UNITY_4_4 || UNITY_4_5 || UNITY_4_6 || UNITY_5 || UNITY_2017_1_OR_NEWER) // MODULE_MARKER
using System;
using DG.Tweening.Core;
using DG.Tweening.Plugins;
using DG.Tweening.Plugins.Core.PathCore;
using DG.Tweening.Plugins.Options;
using UnityEngine;

#pragma warning disable 1591
namespace DG.Tweening
{
	public static class DOTweenModulePhysics2D
    {
        #region Shortcuts

        #region Rigidbody2D Shortcuts

        /// <summary>Tweens a Rigidbody2D's position to the given value.
        /// Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOMove(this Rigidbody2D target, Vector2 endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.position, target.MovePosition, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Rigidbody2D's X position to the given value.
        /// Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOMoveX(this Rigidbody2D target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.position, target.MovePosition, new Vector2(endValue, 0), duration);
            t.SetOptions(AxisConstraint.X, snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Rigidbody2D's Y position to the given value.
        /// Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOMoveY(this Rigidbody2D target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.position, target.MovePosition, new Vector2(0, endValue), duration);
            t.SetOptions(AxisConstraint.Y, snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Rigidbody2D's rotation to the given value.
        /// Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<float, float, FloatOptions> DORotate(this Rigidbody2D target, float endValue, float duration)
        {
            TweenerCore<float, float, FloatOptions> t = DOTween.To(() => target.rotation, target.MoveRotation, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        #region Special

        /// <summary>Tweens a Rigidbody2D's position to the given value, while also applying a jump effect along the Y axis.
        /// Returns a Sequence instead of a Tweener.
        /// Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations.
        /// <para>IMPORTANT: a rigidbody2D can't be animated in a jump arc using MovePosition, so the tween will directly set the position</para></summary>
        /// <param name="endValue">The end value to reach</param>
        /// <param name="jumpPower">Power of the jump (the max height of the jump is represented by this plus the final Y offset)</param>
        /// <param name="numJumps">Total number of jumps</param>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static Sequence DOJump(this Rigidbody2D target, Vector2 endValue, float jumpPower, int numJumps, float duration, bool snapping = false)
        {
            if (numJumps < 1) numJumps = 1;
            float startPosY = 0;
            float offsetY = -1;
            bool offsetYSet = false;
            Sequence s = DOTween.Sequence();
            Tween yTween = DOTween.To(() => target.position, x => target.position = x, new Vector2(0, jumpPower), duration / (numJumps * 2))
                .SetOptions(AxisConstraint.Y, snapping).SetEase(Ease.OutQuad).SetRelative()
                .SetLoops(numJumps * 2, LoopType.Yoyo)
                .OnStart(() => startPosY = target.position.y);
            s.Append(DOTween.To(() => target.position, x => target.position = x, new Vector2(endValue.x, 0), duration)
                    .SetOptions(AxisConstraint.X, snapping).SetEase(Ease.Linear)
                ).Join(yTween)
                .SetTarget(target).SetEase(DOTween.defaultEaseType);
            yTween.OnUpdate(() => {
                if (!offsetYSet) {
                    offsetYSet = true;
                    offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                }
                Vector3 pos = target.position;
                pos.y += DOVirtual.EasedValue(0, offsetY, yTween.ElapsedPercentage(), Ease.OutQuad);
                target.MovePosition(pos);
            });
            return s;
        }

        /// <summary>Tweens a Rigidbody2D's position through the given path waypoints, using the chosen path algorithm.
        /// Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations.
        /// <para>NOTE: to tween a Rigidbody2D correctly it should be set to kinematic at least while being tweened.</para>
        /// <para>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
        /// If you plan to publish there you should use a regular transform.DOPath.</para></summary>
        /// <param name="path">The waypoints to go through</param>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="pathType">The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)</param>
        /// <param name="pathMode">The path mode: 3D, side-scroller 2D, top-down 2D</param>
        /// <param name="resolution">The resolution of the path (useless in case of Linear paths): higher resolutions make for more detailed curved paths but are more expensive.
        /// Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints</param>
        /// <param name="gizmoColor">The color of the path (shown when gizmos are active in the Play panel and the tween is running)</param>
        public static TweenerCore<Vector3, Path, PathOptions> DOPath(
            this Rigidbody2D target, Vector2[] path, float duration, PathType pathType = PathType.Linear,
            PathMode pathMode = PathMode.Full3D, int resolution = 10, Color? gizmoColor = null
        )
        {
            if (resolution < 1) resolution = 1;
            int len = path.Length;
            Vector3[] path3D = new Vector3[len];
            for (int i = 0; i < len; ++i) path3D[i] = path[i];
            TweenerCore<Vector3, Path, PathOptions> t = DOTween.To(PathPlugin.Get(), () => target.position, x => target.MovePosition(x), new Path(pathType, path3D, resolution, gizmoColor), duration)
                .SetTarget(target).SetUpdate(UpdateType.Fixed);

            t.plugOptions.isRigidbody2D = true;
            t.plugOptions.mode = pathMode;
            return t;
        }
        /// <summary>Tweens a Rigidbody2D's localPosition through the given path waypoints, using the chosen path algorithm.
        /// Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
        /// <para>NOTE: to tween a Rigidbody2D correctly it should be set to kinematic at least while being tweened.</para>
        /// <para>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
        /// If you plan to publish there you should use a regular transform.DOLocalPath.</para></summary>
        /// <param name="path">The waypoint to go through</param>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="pathType">The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)</param>
        /// <param name="pathMode">The path mode: 3D, side-scroller 2D, top-down 2D</param>
        /// <param name="resolution">The resolution of the path: higher resolutions make for more detailed curved paths but are more expensive.
        /// Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints</param>
        /// <param name="gizmoColor">The color of the path (shown when gizmos are active in the Play panel and the tween is running)</param>
        public static TweenerCore<Vector3, Path, PathOptions> DOLocalPath(
            this Rigidbody2D target, Vector2[] path, float duration, PathType pathType = PathType.Linear,
            PathMode pathMode = PathMode.Full3D, int resolution = 10, Color? gizmoColor = null
        )
        {
            if (resolution < 1) resolution = 1;
            int len = path.Length;
            Vector3[] path3D = new Vector3[len];
            for (int i = 0; i < len; ++i) path3D[i] = path[i];
            Transform trans = target.transform;
            TweenerCore<Vector3, Path, PathOptions> t = DOTween.To(PathPlugin.Get(), () => trans.localPosition, x => target.MovePosition(trans.parent == null ? x : trans.parent.TransformPoint(x)), new Path(pathType, path3D, resolution, gizmoColor), duration)
                .SetTarget(target).SetUpdate(UpdateType.Fixed);

            t.plugOptions.isRigidbody2D = true;
            t.plugOptions.mode = pathMode;
            t.plugOptions.useLocalPosition = true;
            return t;
        }
        // Used by path editor when creating the actual tween, so it can pass a pre-compiled path
        internal static TweenerCore<Vector3, Path, PathOptions> DOPath(
            this Rigidbody2D target, Path path, float duration, PathMode pathMode = PathMode.Full3D
        )
        {
            TweenerCore<Vector3, Path, PathOptions> t = DOTween.To(PathPlugin.Get(), () => target.position, x => target.MovePosition(x), path, duration)
                .SetTarget(target);

            t.plugOptions.isRigidbody2D = true;
            t.plugOptions.mode = pathMode;
            return t;
        }
        internal static TweenerCore<Vector3, Path, PathOptions> DOLocalPath(
            this Rigidbody2D target, Path path, float duration, PathMode pathMode = PathMode.Full3D
        )
        {
            Transform trans = target.transform;
            TweenerCore<Vector3, Path, PathOptions> t = DOTween.To(PathPlugin.Get(), () => trans.localPosition, x => target.MovePosition(trans.parent == null ? x : trans.parent.TransformPoint(x)), path, duration)
                .SetTarget(target);

            t.plugOptions.isRigidbody2D = true;
            t.plugOptions.mode = pathMode;
            t.plugOptions.useLocalPosition = true;
            return t;
        }

        #endregion

        #endregion

        #endregion
	}
}
#endif
# --- end Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModulePhysics2D.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModuleSprite.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 188918ab119d93148aa0de59ccf5286b
# ASMDEF: DOTween.Modules.dll
# ---
// Author: Daniele Giardini - http://www.demigiant.com
// Created: 2018/07/13

#if true && (UNITY_4_3 || UNITY_4_4 || UNITY_4_5 || UNITY_4_6 || UNITY_5 || UNITY_2017_1_OR_NEWER) // MODULE_MARKER
using System;
using UnityEngine;
using DG.Tweening.Core;
using DG.Tweening.Plugins.Options;

#pragma warning disable 1591
namespace DG.Tweening
{
	public static class DOTweenModuleSprite
    {
        #region Shortcuts

        #region SpriteRenderer

        /// <summary>Tweens a SpriteRenderer's color to the given value.
        /// Also stores the spriteRenderer as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Color, Color, ColorOptions> DOColor(this SpriteRenderer target, Color endValue, float duration)
        {
            TweenerCore<Color, Color, ColorOptions> t = DOTween.To(() => target.color, x => target.color = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Material's alpha color to the given value.
        /// Also stores the spriteRenderer as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Color, Color, ColorOptions> DOFade(this SpriteRenderer target, float endValue, float duration)
        {
            TweenerCore<Color, Color, ColorOptions> t = DOTween.ToAlpha(() => target.color, x => target.color = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens a SpriteRenderer's color using the given gradient
        /// (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
        /// Also stores the image as the tween's target so it can be used for filtered operations</summary>
        /// <param name="gradient">The gradient to use</param><param name="duration">The duration of the tween</param>
        public static Sequence DOGradientColor(this SpriteRenderer target, Gradient gradient, float duration)
        {
            Sequence s = DOTween.Sequence();
            GradientColorKey[] colors = gradient.colorKeys;
            int len = colors.Length;
            for (int i = 0; i < len; ++i) {
                GradientColorKey c = colors[i];
                if (i == 0 && c.time <= 0) {
                    target.color = c.color;
                    continue;
                }
                float colorDuration = i == len - 1
                    ? duration - s.Duration(false) // Verifies that total duration is correct
                    : duration * (i == 0 ? c.time : c.time - colors[i - 1].time);
                s.Append(target.DOColor(c.color, colorDuration).SetEase(Ease.Linear));
            }
            s.SetTarget(target);
            return s;
        }

        #endregion

        #region Blendables

        #region SpriteRenderer

        /// <summary>Tweens a SpriteRenderer's color to the given value,
        /// in a way that allows other DOBlendableColor tweens to work together on the same target,
        /// instead than fight each other as multiple DOColor would do.
        /// Also stores the SpriteRenderer as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The value to tween to</param><param name="duration">The duration of the tween</param>
        public static Tweener DOBlendableColor(this SpriteRenderer target, Color endValue, float duration)
        {
            endValue = endValue - target.color;
            Color to = new Color(0, 0, 0, 0);
            return DOTween.To(() => to, x => {
                    Color diff = x - to;
                    to = x;
                    target.color += diff;
                }, endValue, duration)
                .Blendable().SetTarget(target);
        }

        #endregion

        #endregion

        #endregion
	}
}
#endif
# --- end Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModuleSprite.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModuleUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a060394c03331a64392db53a10e7f2d1
# ASMDEF: DOTween.Modules.dll
# ---
// Author: Daniele Giardini - http://www.demigiant.com
// Created: 2018/07/13

#if true && (UNITY_4_6 || UNITY_5 || UNITY_2017_1_OR_NEWER) // MODULE_MARKER

using System;
using System.Globalization;
using UnityEngine;
using UnityEngine.UI;
using DG.Tweening.Core;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins;
using DG.Tweening.Plugins.Options;
using Text = UnityEngine.UI.Text;

#pragma warning disable 1591
namespace DG.Tweening
{
	public static class DOTweenModuleUI
    {
        #region Shortcuts

        #region CanvasGroup

        /// <summary>Tweens a CanvasGroup's alpha color to the given value.
        /// Also stores the canvasGroup as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<float, float, FloatOptions> DOFade(this CanvasGroup target, float endValue, float duration)
        {
            TweenerCore<float, float, FloatOptions> t = DOTween.To(() => target.alpha, x => target.alpha = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        #endregion

        #region Graphic

        /// <summary>Tweens an Graphic's color to the given value.
        /// Also stores the image as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Color, Color, ColorOptions> DOColor(this Graphic target, Color endValue, float duration)
        {
            TweenerCore<Color, Color, ColorOptions> t = DOTween.To(() => target.color, x => target.color = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens an Graphic's alpha color to the given value.
        /// Also stores the image as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Color, Color, ColorOptions> DOFade(this Graphic target, float endValue, float duration)
        {
            TweenerCore<Color, Color, ColorOptions> t = DOTween.ToAlpha(() => target.color, x => target.color = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        #endregion

        #region Image

        /// <summary>Tweens an Image's color to the given value.
        /// Also stores the image as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Color, Color, ColorOptions> DOColor(this Image target, Color endValue, float duration)
        {
            TweenerCore<Color, Color, ColorOptions> t = DOTween.To(() => target.color, x => target.color = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens an Image's alpha color to the given value.
        /// Also stores the image as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Color, Color, ColorOptions> DOFade(this Image target, float endValue, float duration)
        {
            TweenerCore<Color, Color, ColorOptions> t = DOTween.ToAlpha(() => target.color, x => target.color = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens an Image's fillAmount to the given value.
        /// Also stores the image as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach (0 to 1)</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<float, float, FloatOptions> DOFillAmount(this Image target, float endValue, float duration)
        {
            if (endValue > 1) endValue = 1;
            else if (endValue < 0) endValue = 0;
            TweenerCore<float, float, FloatOptions> t = DOTween.To(() => target.fillAmount, x => target.fillAmount = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens an Image's colors using the given gradient
        /// (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
        /// Also stores the image as the tween's target so it can be used for filtered operations</summary>
        /// <param name="gradient">The gradient to use</param><param name="duration">The duration of the tween</param>
        public static Sequence DOGradientColor(this Image target, Gradient gradient, float duration)
        {
            Sequence s = DOTween.Sequence();
            GradientColorKey[] colors = gradient.colorKeys;
            int len = colors.Length;
            for (int i = 0; i < len; ++i) {
                GradientColorKey c = colors[i];
                if (i == 0 && c.time <= 0) {
                    target.color = c.color;
                    continue;
                }
                float colorDuration = i == len - 1
                    ? duration - s.Duration(false) // Verifies that total duration is correct
                    : duration * (i == 0 ? c.time : c.time - colors[i - 1].time);
                s.Append(target.DOColor(c.color, colorDuration).SetEase(Ease.Linear));
            }
            s.SetTarget(target);
            return s;
        }

        #endregion

        #region LayoutElement

        /// <summary>Tweens an LayoutElement's flexibleWidth/Height to the given value.
        /// Also stores the LayoutElement as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOFlexibleSize(this LayoutElement target, Vector2 endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => new Vector2(target.flexibleWidth, target.flexibleHeight), x => {
                    target.flexibleWidth = x.x;
                    target.flexibleHeight = x.y;
                }, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens an LayoutElement's minWidth/Height to the given value.
        /// Also stores the LayoutElement as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOMinSize(this LayoutElement target, Vector2 endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => new Vector2(target.minWidth, target.minHeight), x => {
                target.minWidth = x.x;
                target.minHeight = x.y;
            }, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens an LayoutElement's preferredWidth/Height to the given value.
        /// Also stores the LayoutElement as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOPreferredSize(this LayoutElement target, Vector2 endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => new Vector2(target.preferredWidth, target.preferredHeight), x => {
                target.preferredWidth = x.x;
                target.preferredHeight = x.y;
            }, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }

        #endregion

        #region Outline

        /// <summary>Tweens a Outline's effectColor to the given value.
        /// Also stores the Outline as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Color, Color, ColorOptions> DOColor(this UnityEngine.UI.Outline target, Color endValue, float duration)
        {
            TweenerCore<Color, Color, ColorOptions> t = DOTween.To(() => target.effectColor, x => target.effectColor = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Outline's effectColor alpha to the given value.
        /// Also stores the Outline as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Color, Color, ColorOptions> DOFade(this UnityEngine.UI.Outline target, float endValue, float duration)
        {
            TweenerCore<Color, Color, ColorOptions> t = DOTween.ToAlpha(() => target.effectColor, x => target.effectColor = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Outline's effectDistance to the given value.
        /// Also stores the Outline as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOScale(this UnityEngine.UI.Outline target, Vector2 endValue, float duration)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.effectDistance, x => target.effectDistance = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        #endregion

        #region RectTransform

        /// <summary>Tweens a RectTransform's anchoredPosition to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorPos(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.anchoredPosition, x => target.anchoredPosition = x, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }
        /// <summary>Tweens a RectTransform's anchoredPosition X to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorPosX(this RectTransform target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.anchoredPosition, x => target.anchoredPosition = x, new Vector2(endValue, 0), duration);
            t.SetOptions(AxisConstraint.X, snapping).SetTarget(target);
            return t;
        }
        /// <summary>Tweens a RectTransform's anchoredPosition Y to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorPosY(this RectTransform target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.anchoredPosition, x => target.anchoredPosition = x, new Vector2(0, endValue), duration);
            t.SetOptions(AxisConstraint.Y, snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a RectTransform's anchoredPosition3D to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector3, Vector3, VectorOptions> DOAnchorPos3D(this RectTransform target, Vector3 endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.anchoredPosition3D, x => target.anchoredPosition3D = x, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }
        /// <summary>Tweens a RectTransform's anchoredPosition3D X to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector3, Vector3, VectorOptions> DOAnchorPos3DX(this RectTransform target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.anchoredPosition3D, x => target.anchoredPosition3D = x, new Vector3(endValue, 0, 0), duration);
            t.SetOptions(AxisConstraint.X, snapping).SetTarget(target);
            return t;
        }
        /// <summary>Tweens a RectTransform's anchoredPosition3D Y to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector3, Vector3, VectorOptions> DOAnchorPos3DY(this RectTransform target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.anchoredPosition3D, x => target.anchoredPosition3D = x, new Vector3(0, endValue, 0), duration);
            t.SetOptions(AxisConstraint.Y, snapping).SetTarget(target);
            return t;
        }
        /// <summary>Tweens a RectTransform's anchoredPosition3D Z to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector3, Vector3, VectorOptions> DOAnchorPos3DZ(this RectTransform target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.anchoredPosition3D, x => target.anchoredPosition3D = x, new Vector3(0, 0, endValue), duration);
            t.SetOptions(AxisConstraint.Z, snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a RectTransform's anchorMax to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorMax(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.anchorMax, x => target.anchorMax = x, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a RectTransform's anchorMin to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorMin(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.anchorMin, x => target.anchorMin = x, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a RectTransform's pivot to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOPivot(this RectTransform target, Vector2 endValue, float duration)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.pivot, x => target.pivot = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }
        /// <summary>Tweens a RectTransform's pivot X to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOPivotX(this RectTransform target, float endValue, float duration)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.pivot, x => target.pivot = x, new Vector2(endValue, 0), duration);
            t.SetOptions(AxisConstraint.X).SetTarget(target);
            return t;
        }
        /// <summary>Tweens a RectTransform's pivot Y to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOPivotY(this RectTransform target, float endValue, float duration)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.pivot, x => target.pivot = x, new Vector2(0, endValue), duration);
            t.SetOptions(AxisConstraint.Y).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a RectTransform's sizeDelta to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOSizeDelta(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.sizeDelta, x => target.sizeDelta = x, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }

        /// <summary>Punches a RectTransform's anchoredPosition towards the given direction and then back to the starting one
        /// as if it was connected to the starting position via an elastic.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="punch">The direction and strength of the punch (added to the RectTransform's current position)</param>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="vibrato">Indicates how much will the punch vibrate</param>
        /// <param name="elasticity">Represents how much (0 to 1) the vector will go beyond the starting position when bouncing backwards.
        /// 1 creates a full oscillation between the punch direction and the opposite direction,
        /// while 0 oscillates only between the punch and the start position</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static Tweener DOPunchAnchorPos(this RectTransform target, Vector2 punch, float duration, int vibrato = 10, float elasticity = 1, bool snapping = false)
        {
            return DOTween.Punch(() => target.anchoredPosition, x => target.anchoredPosition = x, punch, duration, vibrato, elasticity)
                .SetTarget(target).SetOptions(snapping);
        }

        /// <summary>Shakes a RectTransform's anchoredPosition with the given values.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="strength">The shake strength</param>
        /// <param name="vibrato">Indicates how much will the shake vibrate</param>
        /// <param name="randomness">Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
        /// Setting it to 0 will shake along a single direction.</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        /// <param name="fadeOut">If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not</param>
        public static Tweener DOShakeAnchorPos(this RectTransform target, float duration, float strength = 100, int vibrato = 10, float randomness = 90, bool snapping = false, bool fadeOut = true)
        {
            return DOTween.Shake(() => target.anchoredPosition, x => target.anchoredPosition = x, duration, strength, vibrato, randomness, true, fadeOut)
                .SetTarget(target).SetSpecialStartupMode(SpecialStartupMode.SetShake).SetOptions(snapping);
        }
        /// <summary>Shakes a RectTransform's anchoredPosition with the given values.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="strength">The shake strength on each axis</param>
        /// <param name="vibrato">Indicates how much will the shake vibrate</param>
        /// <param name="randomness">Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
        /// Setting it to 0 will shake along a single direction.</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        /// <param name="fadeOut">If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not</param>
        public static Tweener DOShakeAnchorPos(this RectTransform target, float duration, Vector2 strength, int vibrato = 10, float randomness = 90, bool snapping = false, bool fadeOut = true)
        {
            return DOTween.Shake(() => target.anchoredPosition, x => target.anchoredPosition = x, duration, strength, vibrato, randomness, fadeOut)
                .SetTarget(target).SetSpecialStartupMode(SpecialStartupMode.SetShake).SetOptions(snapping);
        }

        #region Special

        /// <summary>Tweens a RectTransform's anchoredPosition to the given value, while also applying a jump effect along the Y axis.
        /// Returns a Sequence instead of a Tweener.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param>
        /// <param name="jumpPower">Power of the jump (the max height of the jump is represented by this plus the final Y offset)</param>
        /// <param name="numJumps">Total number of jumps</param>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static Sequence DOJumpAnchorPos(this RectTransform target, Vector2 endValue, float jumpPower, int numJumps, float duration, bool snapping = false)
        {
            if (numJumps < 1) numJumps = 1;
            float startPosY = 0;
            float offsetY = -1;
            bool offsetYSet = false;

            // Separate Y Tween so we can elaborate elapsedPercentage on that insted of on the Sequence
            // (in case users add a delay or other elements to the Sequence)
            Sequence s = DOTween.Sequence();
            Tween yTween = DOTween.To(() => target.anchoredPosition, x => target.anchoredPosition = x, new Vector2(0, jumpPower), duration / (numJumps * 2))
                .SetOptions(AxisConstraint.Y, snapping).SetEase(Ease.OutQuad).SetRelative()
                .SetLoops(numJumps * 2, LoopType.Yoyo)
                .OnStart(()=> startPosY = target.anchoredPosition.y);
            s.Append(DOTween.To(() => target.anchoredPosition, x => target.anchoredPosition = x, new Vector2(endValue.x, 0), duration)
                    .SetOptions(AxisConstraint.X, snapping).SetEase(Ease.Linear)
                ).Join(yTween)
                .SetTarget(target).SetEase(DOTween.defaultEaseType);
            s.OnUpdate(() => {
                if (!offsetYSet) {
                    offsetYSet = true;
                    offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                }
                Vector2 pos = target.anchoredPosition;
                pos.y += DOVirtual.EasedValue(0, offsetY, s.ElapsedDirectionalPercentage(), Ease.OutQuad);
                target.anchoredPosition = pos;
            });
            return s;
        }

        #endregion

        #endregion

        #region ScrollRect

        /// <summary>Tweens a ScrollRect's horizontal/verticalNormalizedPosition to the given value.
        /// Also stores the ScrollRect as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static Tweener DONormalizedPos(this ScrollRect target, Vector2 endValue, float duration, bool snapping = false)
        {
            return DOTween.To(() => new Vector2(target.horizontalNormalizedPosition, target.verticalNormalizedPosition),
                x => {
                    target.horizontalNormalizedPosition = x.x;
                    target.verticalNormalizedPosition = x.y;
                }, endValue, duration)
                .SetOptions(snapping).SetTarget(target);
        }
        /// <summary>Tweens a ScrollRect's horizontalNormalizedPosition to the given value.
        /// Also stores the ScrollRect as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static Tweener DOHorizontalNormalizedPos(this ScrollRect target, float endValue, float duration, bool snapping = false)
        {
            return DOTween.To(() => target.horizontalNormalizedPosition, x => target.horizontalNormalizedPosition = x, endValue, duration)
                .SetOptions(snapping).SetTarget(target);
        }
        /// <summary>Tweens a ScrollRect's verticalNormalizedPosition to the given value.
        /// Also stores the ScrollRect as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static Tweener DOVerticalNormalizedPos(this ScrollRect target, float endValue, float duration, bool snapping = false)
        {
            return DOTween.To(() => target.verticalNormalizedPosition, x => target.verticalNormalizedPosition = x, endValue, duration)
                .SetOptions(snapping).SetTarget(target);
        }

        #endregion

        #region Slider

        /// <summary>Tweens a Slider's value to the given value.
        /// Also stores the Slider as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<float, float, FloatOptions> DOValue(this Slider target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<float, float, FloatOptions> t = DOTween.To(() => target.value, x => target.value = x, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }

        #endregion

        #region Text

        /// <summary>Tweens a Text's color to the given value.
        /// Also stores the Text as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Color, Color, ColorOptions> DOColor(this Text target, Color endValue, float duration)
        {
            TweenerCore<Color, Color, ColorOptions> t = DOTween.To(() => target.color, x => target.color = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>
        /// Tweens a Text's text from one integer to another, with options for thousands separators
        /// </summary>
        /// <param name="fromValue">The value to start from</param>
        /// <param name="endValue">The end value to reach</param>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="addThousandsSeparator">If TRUE (default) also adds thousands separators</param>
        /// <param name="culture">The <see cref="CultureInfo"/> to use (InvariantCulture if NULL)</param>
        public static TweenerCore<int, int, NoOptions> DOCounter(
            this Text target, int fromValue, int endValue, float duration, bool addThousandsSeparator = true, CultureInfo culture = null
        ){
            int v = fromValue;
            CultureInfo cInfo = !addThousandsSeparator ? null : culture ?? CultureInfo.InvariantCulture;
            TweenerCore<int, int, NoOptions> t = DOTween.To(() => v, x => {
                v = x;
                target.text = addThousandsSeparator
                    ? v.ToString("N0", cInfo)
                    : v.ToString();
            }, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Text's alpha color to the given value.
        /// Also stores the Text as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Color, Color, ColorOptions> DOFade(this Text target, float endValue, float duration)
        {
            TweenerCore<Color, Color, ColorOptions> t = DOTween.ToAlpha(() => target.color, x => target.color = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Text's text to the given value.
        /// Also stores the Text as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end string to tween to</param><param name="duration">The duration of the tween</param>
        /// <param name="richTextEnabled">If TRUE (default), rich text will be interpreted correctly while animated,
        /// otherwise all tags will be considered as normal text</param>
        /// <param name="scrambleMode">The type of scramble mode to use, if any</param>
        /// <param name="scrambleChars">A string containing the characters to use for scrambling.
        /// Use as many characters as possible (minimum 10) because DOTween uses a fast scramble mode which gives better results with more characters.
        /// Leave it to NULL (default) to use default ones</param>
        public static TweenerCore<string, string, StringOptions> DOText(this Text target, string endValue, float duration, bool richTextEnabled = true, ScrambleMode scrambleMode = ScrambleMode.None, string scrambleChars = null)
        {
            if (endValue == null) {
                if (Debugger.logPriority > 0) Debugger.LogWarning("You can't pass a NULL string to DOText: an empty string will be used instead to avoid errors");
                endValue = "";
            }
            TweenerCore<string, string, StringOptions> t = DOTween.To(() => target.text, x => target.text = x, endValue, duration);
            t.SetOptions(richTextEnabled, scrambleMode, scrambleChars)
                .SetTarget(target);
            return t;
        }

        #endregion

        #region Blendables

        #region Graphic

        /// <summary>Tweens a Graphic's color to the given value,
        /// in a way that allows other DOBlendableColor tweens to work together on the same target,
        /// instead than fight each other as multiple DOColor would do.
        /// Also stores the Graphic as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The value to tween to</param><param name="duration">The duration of the tween</param>
        public static Tweener DOBlendableColor(this Graphic target, Color endValue, float duration)
        {
            endValue = endValue - target.color;
            Color to = new Color(0, 0, 0, 0);
            return DOTween.To(() => to, x => {
                Color diff = x - to;
                to = x;
                target.color += diff;
            }, endValue, duration)
                .Blendable().SetTarget(target);
        }

        #endregion

        #region Image

        /// <summary>Tweens a Image's color to the given value,
        /// in a way that allows other DOBlendableColor tweens to work together on the same target,
        /// instead than fight each other as multiple DOColor would do.
        /// Also stores the Image as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The value to tween to</param><param name="duration">The duration of the tween</param>
        public static Tweener DOBlendableColor(this Image target, Color endValue, float duration)
        {
            endValue = endValue - target.color;
            Color to = new Color(0, 0, 0, 0);
            return DOTween.To(() => to, x => {
                Color diff = x - to;
                to = x;
                target.color += diff;
            }, endValue, duration)
                .Blendable().SetTarget(target);
        }

        #endregion

        #region Text

        /// <summary>Tweens a Text's color BY the given value,
        /// in a way that allows other DOBlendableColor tweens to work together on the same target,
        /// instead than fight each other as multiple DOColor would do.
        /// Also stores the Text as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The value to tween to</param><param name="duration">The duration of the tween</param>
        public static Tweener DOBlendableColor(this Text target, Color endValue, float duration)
        {
            endValue = endValue - target.color;
            Color to = new Color(0, 0, 0, 0);
            return DOTween.To(() => to, x => {
                Color diff = x - to;
                to = x;
                target.color += diff;
            }, endValue, duration)
                .Blendable().SetTarget(target);
        }

        #endregion

        #endregion

        #region Shapes

        /// <summary>Tweens a RectTransform's anchoredPosition so that it draws a circle around the given center.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations.<para/>
        /// IMPORTANT: SetFrom(value) requires a <see cref="Vector2"/> instead of a float, where the X property represents the "from degrees value"</summary>
        /// <param name="center">Circle-center/pivot around which to rotate (in UI anchoredPosition coordinates)</param>
        /// <param name="endValueDegrees">The end value degrees to reach (to rotate counter-clockwise pass a negative value)</param>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="relativeCenter">If TRUE the <see cref="center"/> coordinates will be considered as relative to the target's current anchoredPosition</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, CircleOptions> DOShapeCircle(
            this RectTransform target, Vector2 center, float endValueDegrees, float duration, bool relativeCenter = false, bool snapping = false
        )
        {
            TweenerCore<Vector2, Vector2, CircleOptions> t = DOTween.To(
                CirclePlugin.Get(), () => target.anchoredPosition, x => target.anchoredPosition = x, center, duration
            );
            t.SetOptions(endValueDegrees, relativeCenter, snapping).SetTarget(target);
            return t;
        }

        #endregion

        #endregion

        // 
        //  INTERNAL CLASSES 
        // 

        public static class Utils
        {
            /// <summary>
            /// Converts the anchoredPosition of the first RectTransform to the second RectTransform,
            /// taking into consideration offset, anchors and pivot, and returns the new anchoredPosition
            /// </summary>
            public static Vector2 SwitchToRectTransform(RectTransform from, RectTransform to)
            {
                Vector2 localPoint;
                Vector2 fromPivotDerivedOffset = new Vector2(from.rect.width * 0.5f + from.rect.xMin, from.rect.height * 0.5f + from.rect.yMin);
                Vector2 screenP = RectTransformUtility.WorldToScreenPoint(null, from.position);
                screenP += fromPivotDerivedOffset;
                RectTransformUtility.ScreenPointToLocalPointInRectangle(to, screenP, null, out localPoint);
                Vector2 pivotDerivedOffset = new Vector2(to.rect.width * 0.5f + to.rect.xMin, to.rect.height * 0.5f + to.rect.yMin);
                return to.anchoredPosition + localPoint - pivotDerivedOffset;
            }
        }
	}
}
#endif
# --- end Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModuleUI.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModuleUnityVersion.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 63c02322328255542995bd02b47b0457
# ASMDEF: DOTween.Modules.dll
# ---
// Author: Daniele Giardini - http://www.demigiant.com
// Created: 2018/07/13

using System;
using UnityEngine;
using DG.Tweening.Core;
using DG.Tweening.Plugins.Options;
//#if UNITY_2018_1_OR_NEWER && (NET_4_6 || NET_STANDARD_2_0)
//using Task = System.Threading.Tasks.Task;
//#endif

#pragma warning disable 1591
namespace DG.Tweening
{
    /// <summary>
    /// Shortcuts/functions that are not strictly related to specific Modules
    /// but are available only on some Unity versions
    /// </summary>
	public static class DOTweenModuleUnityVersion
    {
#if UNITY_4_3 || UNITY_4_4 || UNITY_4_5 || UNITY_4_6 || UNITY_5 || UNITY_2017_1_OR_NEWER
        #region Unity 4.3 or Newer

        #region Material

        /// <summary>Tweens a Material's color using the given gradient
        /// (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
        /// Also stores the image as the tween's target so it can be used for filtered operations</summary>
        /// <param name="gradient">The gradient to use</param><param name="duration">The duration of the tween</param>
        public static Sequence DOGradientColor(this Material target, Gradient gradient, float duration)
        {
            Sequence s = DOTween.Sequence();
            GradientColorKey[] colors = gradient.colorKeys;
            int len = colors.Length;
            for (int i = 0; i < len; ++i) {
                GradientColorKey c = colors[i];
                if (i == 0 && c.time <= 0) {
                    target.color = c.color;
                    continue;
                }
                float colorDuration = i == len - 1
                    ? duration - s.Duration(false) // Verifies that total duration is correct
                    : duration * (i == 0 ? c.time : c.time - colors[i - 1].time);
                s.Append(target.DOColor(c.color, colorDuration).SetEase(Ease.Linear));
            }
            s.SetTarget(target);
            return s;
        }
        /// <summary>Tweens a Material's named color property using the given gradient
        /// (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
        /// Also stores the image as the tween's target so it can be used for filtered operations</summary>
        /// <param name="gradient">The gradient to use</param>
        /// <param name="property">The name of the material property to tween (like _Tint or _SpecColor)</param>
        /// <param name="duration">The duration of the tween</param>
        public static Sequence DOGradientColor(this Material target, Gradient gradient, string property, float duration)
        {
            Sequence s = DOTween.Sequence();
            GradientColorKey[] colors = gradient.colorKeys;
            int len = colors.Length;
            for (int i = 0; i < len; ++i) {
                GradientColorKey c = colors[i];
                if (i == 0 && c.time <= 0) {
                    target.SetColor(property, c.color);
                    continue;
                }
                float colorDuration = i == len - 1
                    ? duration - s.Duration(false) // Verifies that total duration is correct
                    : duration * (i == 0 ? c.time : c.time - colors[i - 1].time);
                s.Append(target.DOColor(c.color, property, colorDuration).SetEase(Ease.Linear));
            }
            s.SetTarget(target);
            return s;
        }

        #endregion

        #endregion
#endif

#if UNITY_5_3_OR_NEWER || UNITY_2017_1_OR_NEWER
        #region Unity 5.3 or Newer

        #region CustomYieldInstructions

        /// <summary>
        /// Returns a <see cref="CustomYieldInstruction"/> that waits until the tween is killed or complete.
        /// It can be used inside a coroutine as a yield.
        /// <para>Example usage:</para><code>yield return myTween.WaitForCompletion(true);</code>
        /// </summary>
        public static CustomYieldInstruction WaitForCompletion(this Tween t, bool returnCustomYieldInstruction)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return null;
            }
            return new DOTweenCYInstruction.WaitForCompletion(t);
        }

        /// <summary>
        /// Returns a <see cref="CustomYieldInstruction"/> that waits until the tween is killed or rewinded.
        /// It can be used inside a coroutine as a yield.
        /// <para>Example usage:</para><code>yield return myTween.WaitForRewind();</code>
        /// </summary>
        public static CustomYieldInstruction WaitForRewind(this Tween t, bool returnCustomYieldInstruction)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return null;
            }
            return new DOTweenCYInstruction.WaitForRewind(t);
        }

        /// <summary>
        /// Returns a <see cref="CustomYieldInstruction"/> that waits until the tween is killed.
        /// It can be used inside a coroutine as a yield.
        /// <para>Example usage:</para><code>yield return myTween.WaitForKill();</code>
        /// </summary>
        public static CustomYieldInstruction WaitForKill(this Tween t, bool returnCustomYieldInstruction)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return null;
            }
            return new DOTweenCYInstruction.WaitForKill(t);
        }

        /// <summary>
        /// Returns a <see cref="CustomYieldInstruction"/> that waits until the tween is killed or has gone through the given amount of loops.
        /// It can be used inside a coroutine as a yield.
        /// <para>Example usage:</para><code>yield return myTween.WaitForElapsedLoops(2);</code>
        /// </summary>
        /// <param name="elapsedLoops">Elapsed loops to wait for</param>
        public static CustomYieldInstruction WaitForElapsedLoops(this Tween t, int elapsedLoops, bool returnCustomYieldInstruction)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return null;
            }
            return new DOTweenCYInstruction.WaitForElapsedLoops(t, elapsedLoops);
        }

        /// <summary>
        /// Returns a <see cref="CustomYieldInstruction"/> that waits until the tween is killed
        /// or has reached the given time position (loops included, delays excluded).
        /// It can be used inside a coroutine as a yield.
        /// <para>Example usage:</para><code>yield return myTween.WaitForPosition(2.5f);</code>
        /// </summary>
        /// <param name="position">Position (loops included, delays excluded) to wait for</param>
        public static CustomYieldInstruction WaitForPosition(this Tween t, float position, bool returnCustomYieldInstruction)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return null;
            }
            return new DOTweenCYInstruction.WaitForPosition(t, position);
        }

        /// <summary>
        /// Returns a <see cref="CustomYieldInstruction"/> that waits until the tween is killed or started
        /// (meaning when the tween is set in a playing state the first time, after any eventual delay).
        /// It can be used inside a coroutine as a yield.
        /// <para>Example usage:</para><code>yield return myTween.WaitForStart();</code>
        /// </summary>
        public static CustomYieldInstruction WaitForStart(this Tween t, bool returnCustomYieldInstruction)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return null;
            }
            return new DOTweenCYInstruction.WaitForStart(t);
        }

        #endregion

        #endregion
#endif

#if UNITY_2018_1_OR_NEWER
        #region Unity 2018.1 or Newer

        #region Material

        /// <summary>Tweens a Material's named texture offset property with the given ID to the given value.
        /// Also stores the material as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param>
        /// <param name="propertyID">The ID of the material property to tween (also called nameID in Unity's manual)</param>
        /// <param name="duration">The duration of the tween</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOOffset(this Material target, Vector2 endValue, int propertyID, float duration)
        {
            if (!target.HasProperty(propertyID)) {
                if (Debugger.logPriority > 0) Debugger.LogMissingMaterialProperty(propertyID);
                return null;
            }
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.GetTextureOffset(propertyID), x => target.SetTextureOffset(propertyID, x), endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Material's named texture scale property with the given ID to the given value.
        /// Also stores the material as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param>
        /// <param name="propertyID">The ID of the material property to tween (also called nameID in Unity's manual)</param>
        /// <param name="duration">The duration of the tween</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOTiling(this Material target, Vector2 endValue, int propertyID, float duration)
        {
            if (!target.HasProperty(propertyID)) {
                if (Debugger.logPriority > 0) Debugger.LogMissingMaterialProperty(propertyID);
                return null;
            }
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.GetTextureScale(propertyID), x => target.SetTextureScale(propertyID, x), endValue, duration);
            t.SetTarget(target);
            return t;
        }

        #endregion

        #region .NET 4.6 or Newer

#if UNITY_2018_1_OR_NEWER && (NET_4_6 || NET_STANDARD_2_0)

        #region Async Instructions

        /// <summary>
        /// Returns an async <see cref="System.Threading.Tasks.Task"/> that waits until the tween is killed or complete.
        /// It can be used inside an async operation.
        /// <para>Example usage:</para><code>await myTween.WaitForCompletion();</code>
        /// </summary>
        public static async System.Threading.Tasks.Task AsyncWaitForCompletion(this Tween t)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return;
            }
            while (t.active && !t.IsComplete()) await System.Threading.Tasks.Task.Yield();
        }

        /// <summary>
        /// Returns an async <see cref="System.Threading.Tasks.Task"/> that waits until the tween is killed or rewinded.
        /// It can be used inside an async operation.
        /// <para>Example usage:</para><code>await myTween.AsyncWaitForRewind();</code>
        /// </summary>
        public static async System.Threading.Tasks.Task AsyncWaitForRewind(this Tween t)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return;
            }
            while (t.active && (!t.playedOnce || t.position * (t.CompletedLoops() + 1) > 0)) await System.Threading.Tasks.Task.Yield();
        }

        /// <summary>
        /// Returns an async <see cref="System.Threading.Tasks.Task"/> that waits until the tween is killed.
        /// It can be used inside an async operation.
        /// <para>Example usage:</para><code>await myTween.AsyncWaitForKill();</code>
        /// </summary>
        public static async System.Threading.Tasks.Task AsyncWaitForKill(this Tween t)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return;
            }
            while (t.active) await System.Threading.Tasks.Task.Yield();
        }

        /// <summary>
        /// Returns an async <see cref="System.Threading.Tasks.Task"/> that waits until the tween is killed or has gone through the given amount of loops.
        /// It can be used inside an async operation.
        /// <para>Example usage:</para><code>await myTween.AsyncWaitForElapsedLoops();</code>
        /// </summary>
        /// <param name="elapsedLoops">Elapsed loops to wait for</param>
        public static async System.Threading.Tasks.Task AsyncWaitForElapsedLoops(this Tween t, int elapsedLoops)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return;
            }
            while (t.active && t.CompletedLoops() < elapsedLoops) await System.Threading.Tasks.Task.Yield();
        }

        /// <summary>
        /// Returns an async <see cref="System.Threading.Tasks.Task"/> that waits until the tween is killed or started
        /// (meaning when the tween is set in a playing state the first time, after any eventual delay).
        /// It can be used inside an async operation.
        /// <para>Example usage:</para><code>await myTween.AsyncWaitForPosition();</code>
        /// </summary>
        /// <param name="position">Position (loops included, delays excluded) to wait for</param>
        public static async System.Threading.Tasks.Task AsyncWaitForPosition(this Tween t, float position)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return;
            }
            while (t.active && t.position * (t.CompletedLoops() + 1) < position) await System.Threading.Tasks.Task.Yield();
        }

        /// <summary>
        /// Returns an async <see cref="System.Threading.Tasks.Task"/> that waits until the tween is killed.
        /// It can be used inside an async operation.
        /// <para>Example usage:</para><code>await myTween.AsyncWaitForKill();</code>
        /// </summary>
        public static async System.Threading.Tasks.Task AsyncWaitForStart(this Tween t)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return;
            }
            while (t.active && !t.playedOnce) await System.Threading.Tasks.Task.Yield();
        }

        #endregion
#endif

        #endregion

        #endregion
#endif
    }

    // 
    //  CLASSES 
    // 

#if UNITY_5_3_OR_NEWER || UNITY_2017_1_OR_NEWER
    public static class DOTweenCYInstruction
    {
        public class WaitForCompletion : CustomYieldInstruction
        {
            public override bool keepWaiting { get {
                return t.active && !t.IsComplete();
            }}
            readonly Tween t;
            public WaitForCompletion(Tween tween)
            {
                t = tween;
            }
        }

        public class WaitForRewind : CustomYieldInstruction
        {
            public override bool keepWaiting { get {
                return t.active && (!t.playedOnce || t.position * (t.CompletedLoops() + 1) > 0);
            }}
            readonly Tween t;
            public WaitForRewind(Tween tween)
            {
                t = tween;
            }
        }

        public class WaitForKill : CustomYieldInstruction
        {
            public override bool keepWaiting { get {
                return t.active;
            }}
            readonly Tween t;
            public WaitForKill(Tween tween)
            {
                t = tween;
            }
        }

        public class WaitForElapsedLoops : CustomYieldInstruction
        {
            public override bool keepWaiting { get {
                return t.active && t.CompletedLoops() < elapsedLoops;
            }}
            readonly Tween t;
            readonly int elapsedLoops;
            public WaitForElapsedLoops(Tween tween, int elapsedLoops)
            {
                t = tween;
                this.elapsedLoops = elapsedLoops;
            }
        }

        public class WaitForPosition : CustomYieldInstruction
        {
            public override bool keepWaiting { get {
                return t.active && t.position * (t.CompletedLoops() + 1) < position;
            }}
            readonly Tween t;
            readonly float position;
            public WaitForPosition(Tween tween, float position)
            {
                t = tween;
                this.position = position;
            }
        }

        public class WaitForStart : CustomYieldInstruction
        {
            public override bool keepWaiting { get {
                return t.active && !t.playedOnce;
            }}
            readonly Tween t;
            public WaitForStart(Tween tween)
            {
                t = tween;
            }
        }
    }
#endif
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModuleUnityVersion.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModuleUtils.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7bcaf917d9cf5b84090421a5a2abe42e
# ASMDEF: DOTween.Modules.dll
# ---
// Author: Daniele Giardini - http://www.demigiant.com
// Created: 2018/07/13

using System;
using System.Reflection;
using UnityEngine;
using DG.Tweening.Core;
using DG.Tweening.Plugins.Core.PathCore;
using DG.Tweening.Plugins.Options;

#pragma warning disable 1591
namespace DG.Tweening
{
    /// <summary>
    /// Utility functions that deal with available Modules.
    /// Modules defines:
    /// - DOTAUDIO
    /// - DOTPHYSICS
    /// - DOTPHYSICS2D
    /// - DOTSPRITE
    /// - DOTUI
    /// Extra defines set and used for implementation of external assets:
    /// - DOTWEEN_TMP  TextMesh Pro
    /// - DOTWEEN_TK2D  2D Toolkit
    /// </summary>
	public static class DOTweenModuleUtils
    {
        static bool _initialized;

        #region Reflection

        /// <summary>
        /// Called via Reflection by DOTweenComponent on Awake
        /// </summary>
#if UNITY_2018_1_OR_NEWER
        [UnityEngine.Scripting.Preserve]
#endif
        public static void Init()
        {
            if (_initialized) return;

            _initialized = true;
            DOTweenExternalCommand.SetOrientationOnPath += Physics.SetOrientationOnPath;

#if UNITY_EDITOR
#if UNITY_4_3 || UNITY_4_4 || UNITY_4_5 || UNITY_4_6 || UNITY_5 || UNITY_2017_1
            UnityEditor.EditorApplication.playmodeStateChanged += PlaymodeStateChanged;
#else
            UnityEditor.EditorApplication.playModeStateChanged += PlaymodeStateChanged;
#endif
#endif
        }

#if UNITY_2018_1_OR_NEWER
#pragma warning disable
        [UnityEngine.Scripting.Preserve]
        // Just used to preserve methods when building, never called
        static void Preserver()
        {
            Assembly[] loadedAssemblies = AppDomain.CurrentDomain.GetAssemblies();
            MethodInfo mi = typeof(MonoBehaviour).GetMethod("Stub");
        }
#pragma warning restore
#endif

        #endregion

#if UNITY_EDITOR
        // Fires OnApplicationPause in DOTweenComponent even when Editor is paused (otherwise it's only fired at runtime)
#if UNITY_4_3 || UNITY_4_4 || UNITY_4_5 || UNITY_4_6 || UNITY_5 || UNITY_2017_1
        static void PlaymodeStateChanged()
        #else
        static void PlaymodeStateChanged(UnityEditor.PlayModeStateChange state)
#endif
        {
            if (DOTween.instance == null) return;
            DOTween.instance.OnApplicationPause(UnityEditor.EditorApplication.isPaused);
        }
#endif

        // 
        //  INTERNAL CLASSES 
        // 

        public static class Physics
        {
            // Called via DOTweenExternalCommand callback
            public static void SetOrientationOnPath(PathOptions options, Tween t, Quaternion newRot, Transform trans)
            {
#if true // PHYSICS_MARKER
                if (options.isRigidbody) ((Rigidbody)t.target).rotation = newRot;
                else trans.rotation = newRot;
#else
                trans.rotation = newRot;
#endif
            }

            // Returns FALSE if the DOTween's Physics2D Module is disabled, or if there's no Rigidbody2D attached
            public static bool HasRigidbody2D(Component target)
            {
#if false // PHYSICS2D_MARKER
                return target.GetComponent<Rigidbody2D>() != null;
#else
                return false;
#endif
            }

            #region Called via Reflection


            // Called via Reflection by DOTweenPathInspector
            // Returns FALSE if the DOTween's Physics Module is disabled, or if there's no rigidbody attached
#if UNITY_2018_1_OR_NEWER
            [UnityEngine.Scripting.Preserve]
#endif
            public static bool HasRigidbody(Component target)
            {
#if true // PHYSICS_MARKER
                return target.GetComponent<Rigidbody>() != null;
#else
                return false;
#endif
            }

            // Called via Reflection by DOTweenPath
#if UNITY_2018_1_OR_NEWER
            [UnityEngine.Scripting.Preserve]
#endif
            public static TweenerCore<Vector3, Path, PathOptions> CreateDOTweenPathTween(
                MonoBehaviour target, bool tweenRigidbody, bool isLocal, Path path, float duration, PathMode pathMode
            ){
                TweenerCore<Vector3, Path, PathOptions> t = null;
                bool rBodyFoundAndTweened = false;
#if true // PHYSICS_MARKER
                if (tweenRigidbody) {
                    Rigidbody rBody = target.GetComponent<Rigidbody>();
                    if (rBody != null) {
                        rBodyFoundAndTweened = true;
                        t = isLocal
                            ? rBody.DOLocalPath(path, duration, pathMode)
                            : rBody.DOPath(path, duration, pathMode);
                    }
                }
#endif
#if false // PHYSICS2D_MARKER
                if (!rBodyFoundAndTweened && tweenRigidbody) {
                    Rigidbody2D rBody2D = target.GetComponent<Rigidbody2D>();
                    if (rBody2D != null) {
                        rBodyFoundAndTweened = true;
                        t = isLocal
                            ? rBody2D.DOLocalPath(path, duration, pathMode)
                            : rBody2D.DOPath(path, duration, pathMode);
                    }
                }
#endif
                if (!rBodyFoundAndTweened) {
                    t = isLocal
                        ? target.transform.DOLocalPath(path, duration, pathMode)
                        : target.transform.DOPath(path, duration, pathMode);
                }
                return t;
            }

            #endregion
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/DOTween/Modules/DOTweenModuleUtils.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/BoxAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b2a26efbf2325a4478a2a08675adf3c5
# ASMDEF: MarkupAttributes.Runtime.dll
# ---
using System;

namespace MarkupAttributes
{
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
    public class BoxAttribute : LayoutGroupAttribute
    {
        public BoxAttribute(string path, bool labeled = true, float space = 0)
        {
            Path = path;
            Type = LayoutGroupType.Vertical;
            if (labeled)
                HeaderFlags = MarkupHeaderFlags.Label;
            BodyStyle = MarkupBodyStyle.Box;
            Space = space;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/BoxAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/ConditionalAttributes.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 12249ffbb2f480643af8eb899a078082
# ASMDEF: MarkupAttributes.Runtime.dll
# ---
using System;

namespace MarkupAttributes
{
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
    public class HideIfAttribute : Attribute
    {
        public ConditionDescriptor Condition { get; protected set; }

        public HideIfAttribute(string memberName)
        {
            Condition = new ConditionDescriptor(memberName, false);
        }

        public HideIfAttribute(string memberName, object value)
        {
            Condition = new ConditionDescriptor(memberName, false, value);
        }
    }

    [AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
    public class ShowIfAttribute : HideIfAttribute
    {
        public ShowIfAttribute(string memberName) : base(memberName)
        {
            Condition.isInverted = true;
        }

        public ShowIfAttribute(string memberName, object value) : base(memberName, value)
        {
            Condition.isInverted = true;
        }
    }

    [AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
    public class DisableIfAttribute : Attribute
    {
        public ConditionDescriptor Condition { get; protected set; }

        public DisableIfAttribute(string memberName)
        {
            Condition = new ConditionDescriptor(memberName, false);
        }

        public DisableIfAttribute(string memberName, object value)
        {
            Condition = new ConditionDescriptor(memberName, false, value);
        }

        protected DisableIfAttribute(bool fixedValue)
        {
            Condition = new ConditionDescriptor(fixedValue);
        }
    }

    [AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
    public class EnableIfAttribute : DisableIfAttribute
    {
        public EnableIfAttribute(string memberName) : base(memberName)
        {
            Condition.isInverted = true;
        }

        public EnableIfAttribute(string memberName, object value) : base(memberName, value)
        {
            Condition.isInverted = true;
        }
    }

    [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
    public class ReadOnlyAttribute : DisableIfAttribute
    {
        public ReadOnlyAttribute() : base(true)
        {
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/ConditionalAttributes.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/ConditionDescriptor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cf90fd5976be86d498c4b145d2ec9f20
# ASMDEF: MarkupAttributes.Runtime.dll
# ---
namespace MarkupAttributes
{
    public class ConditionDescriptor
    {
        public bool? fixedValue;
        public string memberName;
        public bool isInverted;
        public object value;
        public bool hasValue;

        internal ConditionDescriptor(string memberName, bool isInverted)
        {
            this.memberName = memberName;
            this.isInverted = isInverted;
        }

        internal ConditionDescriptor(string memberName, bool isInverted, object value)
        {
            this.memberName = memberName;
            this.isInverted = isInverted;
            this.value = value;
            hasValue = true;
        }

        internal ConditionDescriptor(bool fixedValue)
        {
            this.fixedValue = fixedValue;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/ConditionDescriptor.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/DisableIfGroupAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2d299807849367f43ba95af37e298159
# ASMDEF: MarkupAttributes.Runtime.dll
# ---
using System;

namespace MarkupAttributes
{
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
    public class DisableIfGroupAttribute : LayoutGroupAttribute
    {
        public DisableIfGroupAttribute(string path, string memberName)
        {
            Path = path;
            Type = LayoutGroupType.DisableIf;
            Condition = new ConditionDescriptor(memberName, false);
        }

        public DisableIfGroupAttribute(string path, string memberName, object value)
        {
            Path = path;
            Type = LayoutGroupType.DisableIf;
            Condition = new ConditionDescriptor(memberName, false, value);
        }

        protected DisableIfGroupAttribute(string path, bool fixedValue)
        {
            Path = path;
            Type = LayoutGroupType.DisableIf;
            Condition = new ConditionDescriptor(fixedValue);
        }
    }

    [AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
    public class EnableIfGroupAttribute : DisableIfGroupAttribute
    {
        public EnableIfGroupAttribute(string path, string memberName) : base(path, memberName)
        {
            Condition.isInverted = true;
        }

        public EnableIfGroupAttribute(string path, string memberName, object value) : base(path, memberName, value)
        {
            Condition.isInverted = true;
        }
    }

    [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
    public class ReadOnlyGroupAttribute : DisableIfGroupAttribute
    {
        public ReadOnlyGroupAttribute(string path) : base(path, true)
        {
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/DisableIfGroupAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/EndGroupAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 594fb932cab52014ab5531f31ff3d191
# ASMDEF: MarkupAttributes.Runtime.dll
# ---
using System;

namespace MarkupAttributes
{
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
    public class EndGroupAttribute : Attribute
    {
        public string GroupName { get; private set; }

        public EndGroupAttribute(string groupName = null)
        {
            GroupName = groupName;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/EndGroupAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/FoldoutAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 19f4c4fd7b8e60f42a5afc0dc472502c
# ASMDEF: MarkupAttributes.Runtime.dll
# ---
using System;

namespace MarkupAttributes
{
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
    public class FoldoutAttribute : LayoutGroupAttribute
    {
        public FoldoutAttribute(string path, bool box = true, float space = 0)
        {
            Path = path;
            Type = LayoutGroupType.Vertical;
            HeaderFlags = MarkupHeaderFlags.Label | MarkupHeaderFlags.Foldable;
            BodyStyle = box ? MarkupBodyStyle.Box : MarkupBodyStyle.ContentBox;
            Space = space;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/FoldoutAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/HideIfGroupAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 46043c5c6bf9d49478f1b2f89b5a970c
# ASMDEF: MarkupAttributes.Runtime.dll
# ---
using System;

namespace MarkupAttributes
{
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
    public class HideIfGroupAttribute : LayoutGroupAttribute
    {
        public HideIfGroupAttribute(string path, string memberName)
        {
            Path = path;
            Type = LayoutGroupType.HideIf;
            Condition = new ConditionDescriptor(memberName, false);
        }

        public HideIfGroupAttribute(string path, string memberName, object value)
        {
            Path = path;
            Type = LayoutGroupType.HideIf;
            Condition = new ConditionDescriptor(memberName, false, value);
        }
    }

    [AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
    public class ShowIfGroupAttribute : HideIfGroupAttribute
    {
        public ShowIfGroupAttribute(string path, string memberName) : base(path, memberName)
        {
            Condition.isInverted = true;
        }

        public ShowIfGroupAttribute(string path, string memberName, object value) : base(path, memberName, value)
        {
            Condition.isInverted = true;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/HideIfGroupAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/HorizontalGroupAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2b405e2cc000dc44bbcaf87f8f90c5c3
# ASMDEF: MarkupAttributes.Runtime.dll
# ---
using System;

namespace MarkupAttributes
{
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
    public class HorizontalGroupAttribute : LayoutGroupAttribute
    {
        public HorizontalGroupAttribute(string path, float labelWidth, float space = 0)
        {
            Path = path;
            Type = LayoutGroupType.Horizontal;
            LabelWidth = labelWidth;
            Space = space;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/HorizontalGroupAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/InlineEditorAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c61668501ba8f234e891f5c56b87b3ce
# ASMDEF: MarkupAttributes.Runtime.dll
# ---
using System;

namespace MarkupAttributes
{
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
    public class InlineEditorAttribute : Attribute
    {
        public InlineEditorMode Mode { get; private set; }

        public InlineEditorAttribute(InlineEditorMode mode = InlineEditorMode.Box)
        {
            Mode = mode;
        }
    }

    public enum InlineEditorMode { Box, ContentBox, Stripped }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/InlineEditorAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/LayoutGroupAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9c64f79f65e37574c90d92ed0d08074f
# ASMDEF: MarkupAttributes.Runtime.dll
# ---
using System;

namespace MarkupAttributes
{
    public abstract class LayoutGroupAttribute : Attribute
    {
        public string Path { get; protected set; }
        public LayoutGroupType Type { get; protected set; }
        public MarkupHeaderFlags HeaderFlags { get; protected set; } 
        public MarkupBodyStyle BodyStyle { get; protected set; } 
        public float LabelWidth { get; protected set; }
        public float Space { get; protected set; }
        public string[] Tabs { get; protected set; }
        public ConditionDescriptor Condition { get; protected set; }
        public bool Toggle { get; protected set; }
        public string ToggleShaderKeyword { get; protected set; }

        public bool HasCondition => Type == LayoutGroupType.DisableIf
            || Type == LayoutGroupType.HideIf;
    }

    public enum LayoutGroupType
    {
        LocalScope,
        Vertical,
        Horizontal,
        TabScope,
        Tab,
        DisableIf,
        HideIf
    }

    public enum MarkupHeaderFlags
    {
        None = 0,
        Label = 1,
        Foldable = 2,
        Underline = 4
    }

    public enum MarkupBodyStyle
    {
        None,
        ContentBox,
        Box
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/LayoutGroupAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/MarkedUpTypeAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 249453f5a78bfba4bbfd9dd19d35fdb2
# ASMDEF: MarkupAttributes.Runtime.dll
# ---
using System;

namespace MarkupAttributes
{
    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = false)]
    public class MarkedUpTypeAttribute : Attribute
    {
        public bool ShowControl { get; protected set; }
        public bool IndentChildren { get; protected set; }

        public MarkedUpTypeAttribute(bool showControl = true, bool indentChildren = true)
        {
            ShowControl = showControl;
            IndentChildren = indentChildren;
        }
    }

    [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
    public class MarkedUpFieldAttribute : MarkedUpTypeAttribute
    {
        public MarkedUpFieldAttribute(bool showControl = true, bool indentChildren = true)
        {
            ShowControl = showControl;
            IndentChildren = indentChildren;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/MarkedUpTypeAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/TabAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: aa362f73caf54dd42a79c7213b35d52e
# ASMDEF: MarkupAttributes.Runtime.dll
# ---
using System;

namespace MarkupAttributes
{
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
    public class TabAttribute : LayoutGroupAttribute
    {
        public TabAttribute(string path)
        {
            Path = path;
            Type = LayoutGroupType.Tab;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/TabAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/TabScopeAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: dec9e4c9933c4464abd14c877cb5d035
# ASMDEF: MarkupAttributes.Runtime.dll
# ---
using System;

namespace MarkupAttributes
{
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
    public class TabScopeAttribute : LayoutGroupAttribute
    {
        public TabScopeAttribute(string path, string tabs, bool box = false, float space = 0)
        {
            Path = path;
            Type = LayoutGroupType.TabScope;
            Tabs = tabs.Split('|');
            if (box)
                BodyStyle = MarkupBodyStyle.Box;
            Space = space;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/TabScopeAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/TitleGroupAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7aa5ee9a7934af64f90537ba22862a68
# ASMDEF: MarkupAttributes.Runtime.dll
# ---
using System;

namespace MarkupAttributes
{
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
    public class TitleGroupAttribute : LayoutGroupAttribute
    {
        public TitleGroupAttribute(string path, bool contentBox = false, bool underline = true, float space = 3)
        {
            Path = path;
            Type = LayoutGroupType.Vertical;
            HeaderFlags = MarkupHeaderFlags.Label;
            if (underline)
                HeaderFlags |= MarkupHeaderFlags.Underline;
            BodyStyle = contentBox ? MarkupBodyStyle.ContentBox : MarkupBodyStyle.None;
            Space = space;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/TitleGroupAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/ToggleGroupAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 419aa3fdb4e9180438e406f70490213a
# ASMDEF: MarkupAttributes.Runtime.dll
# ---
using System;

namespace MarkupAttributes
{
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
    public class ToggleGroupAttribute : LayoutGroupAttribute
    {
        public ToggleGroupAttribute(string path, bool foldable = false, bool box = true, float space = 0)
        {
            Path = path;
            Toggle = true;
            Type = LayoutGroupType.Vertical;
            HeaderFlags = MarkupHeaderFlags.Label;
            if (foldable)
                HeaderFlags |= MarkupHeaderFlags.Foldable;
            BodyStyle = box ? MarkupBodyStyle.Box : MarkupBodyStyle.ContentBox;
            Space = space;
        }

        public static ToggleGroupAttribute CreateForShader(string path, bool foldable, bool box, string shaderKeyword)
        {
            var value = new ToggleGroupAttribute(path, foldable, box);
            value.ToggleShaderKeyword = shaderKeyword;
            return value;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/ToggleGroupAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/VerticalGroupAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1c8773c14c997de44b4d58709b2fb43b
# ASMDEF: MarkupAttributes.Runtime.dll
# ---
using System;

namespace MarkupAttributes
{
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
    public class VerticalGroupAttribute : LayoutGroupAttribute
    {
        public VerticalGroupAttribute(string path, float space = 0)
        {
            Path = path;
            Type = LayoutGroupType.Vertical;
            Space = space;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/Runtime/VerticalGroupAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Rope/Core/DisableInPlayModeAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 41aa8ad4cfb989c4bba7e1e5615356cd
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;

namespace RopeToolkit
{
    public class DisableInPlayModeAttribute : PropertyAttribute
    {
        public DisableInPlayModeAttribute()
        { }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Rope/Core/DisableInPlayModeAttribute.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Rope/Core/PointsExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 460fdf7888d541b48bd9e15bfcb51528
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;
using Unity.Mathematics;
using Unity.Collections;
using System.Collections.Generic;
using System.Linq;

namespace RopeToolkit
{
    public static class PointsExtensions
    {
        // Curve length
        public static float GetLengthOfCurve(this NativeArray<float3> curve, ref float4x4 transform, bool isLoop = false)
        {
            if (curve == null || curve.Length == 0)
            {
                return 0.0f;
            }
            var sum = 0.0f;
            var firstPoint = math.mul(transform, new float4(curve[0], 1.0f)).xyz;
            var lastPoint = firstPoint;
            for (int i = 1; i < curve.Length; i++)
            {
                var point = math.mul(transform, new float4(curve[i], 1.0f)).xyz;
                sum += math.distance(lastPoint, point);
                lastPoint = point;
            }
            if (isLoop)
            {
                sum += math.distance(lastPoint, firstPoint);
            }
            return sum;
        }

        public static float GetLengthOfCurve(this NativeArray<float3> curve, bool isLoop = false)
        {
            var transform = float4x4.identity;
            return curve.GetLengthOfCurve(ref transform, isLoop);
        }

        public static float GetLengthOfCurve(this IEnumerable<float3> curve, ref float4x4 transform, bool isLoop = false)
        {
            var array = new NativeArray<float3>(curve.ToArray(), Allocator.Temp);
            var sum = array.GetLengthOfCurve(ref transform, isLoop);
            array.Dispose();
            return sum;
        }

        public static float GetLengthOfCurve(this IEnumerable<float3> curve, bool isLoop = false)
        {
            var transform = float4x4.identity;
            return curve.GetLengthOfCurve(ref transform, isLoop);
        }

        // Curve points
        private static void GetPointAlongCurve(this NativeArray<float3> curve, ref float4x4 transform, float distance, out float3 point, ref int currentTargetIndex, ref float accumulatedLength)
        {
            if (curve.Length < 2)
            {
                throw new System.ArgumentException(nameof(curve));
            }
            if (currentTargetIndex < 1 || currentTargetIndex >= curve.Length)
            {
                throw new System.ArgumentOutOfRangeException(nameof(currentTargetIndex));
            }

            var previousTarget = curve[currentTargetIndex - 1];
            while (currentTargetIndex < curve.Length)
            {
                var target = curve[currentTargetIndex];
                var segmentLength = math.distance(previousTarget, target);

                if (distance <= accumulatedLength + segmentLength)
                {
                    var interpolated = math.lerp(previousTarget, target, (distance - accumulatedLength) / segmentLength);
                    point = math.mul(transform, new float4(interpolated, 1.0f)).xyz;
                    return;
                }

                currentTargetIndex++;
                accumulatedLength += segmentLength;
                previousTarget = target;
            }

            // numerical precision made this happen, just return last point
            currentTargetIndex = curve.Length - 1;
            point = math.mul(transform, new float4(previousTarget, 1.0f)).xyz;
        }

        public static void GetPointAlongCurve(this NativeArray<float3> curve, ref float4x4 transform, float distance, out float3 point)
        {
            var currentTargetIndex = 1;
            var accumulatedLength = 0.0f;
            curve.GetPointAlongCurve(ref transform, distance, out point, ref currentTargetIndex, ref accumulatedLength);
        }

        public static void GetPointAlongCurve(this NativeArray<float3> curve, float distance, out float3 point)
        {
            var transform = float4x4.identity;
            curve.GetPointAlongCurve(ref transform, distance, out point);
        }

        public static void GetPointAlongCurve(this IEnumerable<float3> curve, ref float4x4 transform, float distance, out float3 point)
        {
            var array = new NativeArray<float3>(curve.ToArray(), Allocator.Temp);
            array.GetPointAlongCurve(ref transform, distance, out point);
            array.Dispose();
        }

        public static void GetPointAlongCurve(this IEnumerable<float3> curve, float distance, out float3 point)
        {
            var transform = float4x4.identity;
            curve.GetPointAlongCurve(ref transform, distance, out point);
        }

        public static void GetPointsAlongCurve(this NativeArray<float3> curve, ref float4x4 transform, float desiredPointDistance, NativeArray<float3> result)
        {
            var currentTargetIndex = 1;
            var accumulatedLength = 0.0f;
            for (int i = 0; i < result.Length; i++)
            {
                curve.GetPointAlongCurve(ref transform, desiredPointDistance * i, out float3 point, ref currentTargetIndex, ref accumulatedLength);

                result[i] = point;
            }
        }

        public static void GetPointsAlongCurve(this NativeArray<float3> curve, float desiredPointDistance, NativeArray<float3> result)
        {
            var transform = float4x4.identity;
            curve.GetPointsAlongCurve(ref transform, desiredPointDistance, result);
        }

        public static void GetPointsAlongCurve(this IEnumerable<float3> curve, ref float4x4 transform, float desiredPointDistance, NativeArray<float3> result)
        {
            var array = new NativeArray<float3>(curve.ToArray(), Allocator.Temp);
            array.GetPointsAlongCurve(ref transform, desiredPointDistance, result);
            array.Dispose();
        }

        public static void GetPointsAlongCurve(this IEnumerable<float3> curve, float desiredPointDistance, NativeArray<float3> result)
        {
            var transform = float4x4.identity;
            curve.GetPointsAlongCurve(ref transform, desiredPointDistance, result);
        }

        // Closest point
        public static void GetClosestPoint(this NativeArray<float3> curve, float3 point, out int index, out float distance)
        {
            index = 0;
            var closestDistanceSq = math.distancesq(curve[0], point);
            for (int i = 1; i < curve.Length; i++)
            {
                var distSq = math.distancesq(curve[i], point);
                if (distSq < closestDistanceSq)
                {
                    index = i;
                    closestDistanceSq = distSq;
                }
            }
            distance = math.sqrt(closestDistanceSq);
        }

        public static void GetClosestPoint(this NativeArray<float3> curve, Ray ray, out int index, out float distance, out float distanceAlongRay)
        {
            index = 0;
            var origin = (float3)ray.origin;
            var dir = math.normalizesafe(ray.direction);
            var closestDistanceAlongRay = math.dot(curve[0] - origin, dir);
            var closestDistanceSq = math.distancesq(origin + closestDistanceAlongRay * dir, curve[0]);
            for (int i = 1; i < curve.Length; i++)
            {
                var position = curve[i];
                var rayDist = math.dot(position - origin, dir);
                var distSq = math.distancesq(origin + rayDist * dir, position);
                if (distSq < closestDistanceSq)
                {
                    index = i;
                    closestDistanceAlongRay = rayDist;
                    closestDistanceSq = distSq;
                }
            }
            distance = math.sqrt(closestDistanceSq);
            distanceAlongRay = closestDistanceAlongRay;
        }

        // Distance
        public static void KeepAtDistance(this ref float3 point, ref float3 otherPoint, float distance, float stiffness = 1.0f)
        {
            var delta = otherPoint - point;

            var currentDistance = math.length(delta);
            if (currentDistance > 0.0f)
            {
                delta /= currentDistance;
            }
            else
            {
                delta = float3.zero;
            }
            delta *= (currentDistance - distance) * stiffness;

            point += delta;
            otherPoint -= delta;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Rope/Core/PointsExtensions.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Rope/Core/RigidbodyExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 40ab74e53dce5804b8debdf053bccfae
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;
using Unity.Mathematics;
using Unity.Collections;
using System.Collections.Generic;
using System.Linq;

namespace RopeToolkit
{
    public static class RigidbodyExtensions
    {
        public static void GetLocalInertiaTensor(this Rigidbody rb, out float3x3 localInertiaTensor)
        {
            var rot = new float3x3(rb.inertiaTensorRotation);
            var invRot = math.transpose(rot);

            localInertiaTensor = math.mul(math.mul(rot, float3x3.Scale(rb.inertiaTensor)), invRot);
        }

        public static void GetInertiaTensor(this Rigidbody rb, out float3x3 inertiaTensor)
        {
            rb.GetLocalInertiaTensor(out float3x3 localInertiaTensor);

            var rot = new float3x3(rb.rotation);
            var invRot = math.transpose(rot);

            inertiaTensor = math.mul(math.mul(rot, localInertiaTensor), invRot);
        }

        public static void GetInvInertiaTensor(this Rigidbody rb, out float3x3 invInertiaTensor)
        {
            rb.GetLocalInertiaTensor(out float3x3 localTensor);

            float3x3 invLocalTensor = float3x3.zero;
            if (math.determinant(localTensor) != 0.0f)
            {
                invLocalTensor = math.inverse(localTensor);
            }

            var rot = new float3x3(rb.rotation);
            var invRot = math.transpose(rot);

            invInertiaTensor = math.mul(math.mul(rot, invLocalTensor), invRot);
        }

        public static void ApplyImpulseNow(this Rigidbody rb, ref float3x3 invInertiaTensor, float3 point, float3 impulse)
        {
            if (rb.mass == 0.0f)
            {
                return;
            }

            var relativePoint = point - (float3)rb.worldCenterOfMass;
            var angularMomentumChange = math.cross(relativePoint, impulse);
            var angularVelocityChange = math.mul(invInertiaTensor, angularMomentumChange);

            rb.linearVelocity += (Vector3)impulse / rb.mass;
            rb.angularVelocity += (Vector3)angularVelocityChange;
        }

        public static void ApplyImpulseNow(this Rigidbody rb, float3 point, float3 impulse)
        {
            rb.GetInvInertiaTensor(out float3x3 invInertiaTensor);
            rb.ApplyImpulseNow(ref invInertiaTensor, point, impulse);
        }

        public static void SetPointVelocityNow(this Rigidbody rb, ref float3x3 invInertiaTensor, float3 point, float3 normal, float desiredSpeed, float damping = 1.0f)
        {
            if (rb.mass == 0.0f)
            {
                return;
            }

            var velocityChange = desiredSpeed - math.dot(rb.GetPointVelocity(point), normal) * damping;
            var relativePoint = point - (float3)rb.worldCenterOfMass;

            var denominator = (1.0f / rb.mass) + math.dot(math.cross(math.mul(invInertiaTensor, math.cross(relativePoint, normal)), relativePoint), normal);
            if (denominator == 0.0f)
            {
                return;
            }

            var j = velocityChange / denominator;
            rb.ApplyImpulseNow(ref invInertiaTensor, point, j * normal);
        }

        public static void SetPointVelocityNow(this Rigidbody rb, float3 point, float3 normal, float desiredSpeed, float damping = 1.0f)
        {
            rb.GetInvInertiaTensor(out float3x3 invInertiaTensor);
            rb.SetPointVelocityNow(ref invInertiaTensor, point, normal, desiredSpeed, damping);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Rope/Core/RigidbodyExtensions.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Rope/Rope.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 325b217b839086b4ca705834516bc0d5
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections.Generic;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Profiling;
using UnityEngine.Rendering;

namespace RopeToolkit
{
    public enum RopeInterpolation
    {
        None = 0,
        Interpolate,
        Extrapolate,
    }

    public class Rope : MonoBehaviour
    {
        protected const int MaxCollisionPlanesPerParticle = 3;
        protected const int InitialParticleTargets = 3;
        protected const int MaxRigidbodyConnections = 24;

        public struct Measurements
        {
            public float spawnCurveLength;
            public float realCurveLength;
            public int segmentCount;
            public int particleCount;
            public float particleSpacing;

            public int GetParticleIndexAt(float distance)
            {
                return math.clamp((int)(distance / particleSpacing + 0.5f), 0, particleCount - 1);
            }
        }

        public struct OnSplitParams
        {
            public int minParticleIndex;
            public int maxParticleIndex;
            public Measurements preSplitMeasurements;
        }

        public struct EditorColors
        {
            public Color ropeSegments;
            public Color simulationParticle;
            public Color collisionParticle;
            public Color spawnPointHandle;
        }

        public static readonly EditorColors Colors = new EditorColors()
        {
            ropeSegments = Color.black,
            simulationParticle = new Color(0.2f, 0.8f, 0.2f, 0.5f),
            collisionParticle = new Color(1.0f, 0.92f, 0.016f, 0.5f),
            spawnPointHandle = new Color(0.1f, 0.5f, 0.8f),
        };

        [Tooltip("The radius of the rope. This value is used both for constructing the visual mesh and handling collisions.")]
        [Range(0.01f, 1.0f)]
        public float radius = 0.05f;

        [Tooltip("The number of vertices to use for each segment of the rope's visual mesh. More vertices results in a rounder looking rope but increases the overall vertex and triangle count of the visual mesh. This value does not influence the simulation of the rope at all.")]
        [DisableInPlayMode]
        [Range(3, 32)]
        public int radialVertices = 6;

        [Tooltip("Whether or not the rope is a circular loop. If enabled, the last spawn point of the rope will be connected to the first spawn point.")]
        [DisableInPlayMode]
        public bool isLoop = false;

        [Tooltip("The material used to render the rope. This can be any material that uses vertex positions and optionally normals.")]
        public Material material;

        [Tooltip("The shadow casting mode to use for the rope")]
        public ShadowCastingMode shadowMode = ShadowCastingMode.On;

        [System.Serializable]
        public struct CustomMeshSettings
        {
            [Tooltip("If specified, this mesh is rendered instead of the default rope cylinder at each simulation particle. The z-axis of the mesh will align with the rope tangent and the mesh will be scaled so that z=0 is the current simulation particle and z=1 is the next simulation particle. The material specified for the rope must support instancing.")]
            public Mesh mesh;

            [Tooltip("When using a custom mesh, this property specifies how much to rotate the mesh around the z-axis for every link in the chain of simulation particles.")]
            [Range(0.0f, 360.0f)]
            public float rotation;

            [Tooltip("When using a custom mesh, this property can be used to tweak the scale")]
            public Vector3 scale;

            [Tooltip("When using a custom mesh, this property specifies whether or not the mesh should be stretched lengthwise along with the rope.")]
            public bool stretch;
        }

        public CustomMeshSettings customMesh = new CustomMeshSettings()
        {
            mesh = null,
            rotation = 90.0f,
            scale = Vector3.one,
            stretch = false,
        };

        [Tooltip("The spawn points used to initially place the rope in the world. Currently, pairs of consequtive spawn points are considered linear line segments.")]
        [DisableInPlayMode]
        public List<float3> spawnPoints = new List<float3>();

        [Tooltip("The interpolation mode to use in between calls to FixedUpdate(). Only meaningful if the fixed update rate is low. See documentation for Rigidbody.interpolation for more information.")]
        [DisableInPlayMode]
        public RopeInterpolation interpolation = RopeInterpolation.None;

        [System.Serializable]
        public struct SimulationSettings
        {
            [Tooltip("Turns on or off the simulation independently of the rendering of the rope. A use case could be to programmatically disable ropes that are too far away from the camera or ropes that are not visible.")]
            public bool enabled;

            [Header("Base characteristics")]

            [Tooltip("The number of simulation particles per meter. A higher resolution results in a smoother looking rope but requires more compute.")]
            [DisableInPlayMode]
            public float resolution;

            [Tooltip("The mass per meter of the rope. This value is used when interacting with rigidbodies via RopeRigidbodyConnection components.")]
            [Delayed]
            public float massPerMeter;

            [Tooltip("A measure of the stiffness of the rope. Note that the actual stiffness is heavily dependent on the number of solver iterations and the size of the physics time step used, if you change one value you problably need to re-tweak the other(s). This particular value does not influence performance.")]
            [Range(0.01f, 1.0f)]
            public float stiffness;

            [Tooltip("The percentage of energy to remove from the simulation each fixed update. Useful to model air resistance. Does not influence performance.")]
            [Range(0.0f, 1.0f)]
            public float energyLoss;

            [Header("Modifiers")]

            [Tooltip("A value that dynamically shortens or lengthens the rope by a multiplicative factor. This can be used to create a retractable grappling hook for example.")]
            [Range(0.0f, 2.0f)]
            public float lengthMultiplier;

            [Tooltip("The percentage of the gravity force to apply to the rope. A low gravity multiplier might be useful to straighten out ropes that otherwise sack but should be considered a 'hack' as the rope will behave as if it is in space.")]
            [Range(0.0f, 1.0f)]
            public float gravityMultiplier;

            [Tooltip("Whether to use a custom gravity value from this component or the global physics gravity")]
            public bool useCustomGravity;

            [Tooltip("The gravity force to use for this particular rope when not using global gravity")]
            public float3 customGravity;

            [Header("Advanced (changing these will require tweaking base characteristics)")]

            [Range(1, 10)]
            [Tooltip("The number of substeps that each fixed update should be divided into. A high substep count results in stiffer simulations since small deflections due to gravity can be countered early. The exception is if the rope is fixed between 2 rigidbodies, then the fixed update rate of the project determines stiffness.")]
            public int substeps;

            [Tooltip("The number of solver iterations to run for this rope. High resolution ropes need more iterations to become stiff. More iterations requires more compute.")]
            [Range(1, 32)]
            public int solverIterations;
        }

        [Space]
        public SimulationSettings simulation = new SimulationSettings()
        {
            enabled = true,
            resolution = 10.0f,
            massPerMeter = 0.2f,
            stiffness = 1.0f,
            lengthMultiplier = 1.0f,
            energyLoss = 0.0025f,
            gravityMultiplier = 1.0f,
            useCustomGravity = false,
            customGravity = Physics.gravity,
            substeps = 4,
            solverIterations = 2,
        };

        [System.Serializable]
        public struct CollisionSettings
        {
            [Tooltip("Enables collision handling for the rope so that it reacts to colliders other than the ones it is connected to via RopeConnection components. Performance intensive on the main thread.")]
            public bool enabled;

            [Tooltip("Whether or not the rope should influence rigidbodies when it collides with them.")]
            public bool influenceRigidbodies;

            [Tooltip(
                "Check and respond to collisions on every n:th simulation particle. A value of one will make every simulated particle react to collisions, a value " +
                "of two will make every other particle react to collisions and so on. As one sphere-overlap test is performed per particle, a low value is very " +
                "performance intensive. Collision particles are visualized by yellow spheres when the rope is selected.")]
            [Range(1, 20)]
            public int stride;

            [Tooltip("The dynamic friction coefficient of the rope. Used to slow the rope down if it is dragged along the ground for example.")]
            [Range(0.0f, 20.0f)]
            public float friction;

            [Tooltip("An extra distance (added ontop of the rope radius) that prevents small radius ropes from falling through geometry easily")]
            [Range(0.0f, 1.0f)]
            public float collisionMargin;

            public LayerMask ignoreLayers;
        }

        [Space]
        public CollisionSettings collisions = new CollisionSettings()
        {
            enabled = false,
            influenceRigidbodies = true,
            stride = 2,
            friction = 0.1f,
            collisionMargin = 0.025f,
            ignoreLayers = 0,
        };

        protected struct CollisionPlane
        {
            public float3 point;
            public float3 normal;
            public float3 velocityChange;

            public float3 feedback;
        }

        protected struct ParticleTarget
        {
            public int particleIndex;
            public float3 position;
            public float stiffness;
        }

        protected struct RigidbodyConnection
        {
            public Rigidbody rigidbody;
            public float rigidbodyDamping;
            public ParticleTarget target;
        }

        protected bool initialized;
        protected bool computingSimulationFrame;
        protected bool simulationDisabledPrevFrame;
        protected bool wasSplit;
        protected float timeSinceFixedUpdate;
        protected JobHandle simulationFrameHandle;

        // State
        protected NativeArray<float3> positions;
        protected NativeArray<float3> prevPositions;
        protected NativeArray<float3> interpolatedPositions;
        protected NativeArray<float3> bitangents;
        protected NativeArray<float> massMultipliers;

        // Collision handling
        protected NativeArray<int> collisionPlanesActive;
        protected NativeArray<CollisionPlane> collisionPlanes;
        protected Rigidbody[] collisionRigidbodies;

        // Rigidbody connections
        protected List<RigidbodyConnection> queuedRigidbodyConnections;
        protected List<RigidbodyConnection> liveRigidbodyConnections;
        protected NativeArray<ParticleTarget> particleTargets;
        protected NativeArray<float3> particleTargetFeedbacks;

        // Rendering
        protected NativeArray<Vector3> vertices;
        protected NativeArray<Vector3> normals;
        protected NativeArray<float3> cosLookup;
        protected NativeArray<float3> sinLookup;

        protected Mesh mesh;

        protected Measurements _measurements;

        /// <summary>
        /// Returns the measurements of the rope. The measurements remain constant after the rope is first initialized.
        /// </summary>
        public Measurements measurements
        {
            get
            {
                if (!Initialize())
                {
                    return new Measurements();
                }
                return _measurements;
            }
        }

        /// <summary>
        /// The current world-space bounds of the visual mesh
        /// </summary>
        public Bounds currentBounds
        {
            get
            {
                if (!Initialize())
                {
                    return new Bounds();
                }
                return mesh.bounds;
            }
        }

        public void OnValidate()
        {
            simulation.resolution = Mathf.Max(0.01f, simulation.resolution);
            simulation.massPerMeter = Mathf.Max(0.01f, simulation.massPerMeter);
        }

        /// <summary>
        /// Adds a new spawn point to the rope. May be called from edit-mode.
        /// </summary>
        public void PushSpawnPoint()
        {
            if (spawnPoints.Count == 0)
            {
                spawnPoints.Add(Vector3.right);
                return;
            }
            var prev = spawnPoints.Count >= 2 ? spawnPoints[spawnPoints.Count - 2] : float3.zero;
            var current = spawnPoints[spawnPoints.Count - 1];
            spawnPoints.Add(current + math.normalizesafe(current - prev));
        }

        /// <summary>
        /// Removes the last spawn point of the rope. May be called from edit-mode.
        /// </summary>
        public void PopSpawnPoint()
        {
            if (spawnPoints.Count <= 2)
            {
                return;
            }
            spawnPoints.RemoveAt(spawnPoints.Count - 1);
        }

        /// <summary>
        /// Returns the index of the simulation particle at a particular distance along the curve of the rope
        /// </summary>
        /// <param name="distance">The distance along the curve of the rope</param>
        /// <returns>The particle index</returns>
        public int GetParticleIndexAt(float distance)
        {
            if (!Initialize() || _measurements.particleSpacing == 0.0f)
            {
                return 0;
            }
            return _measurements.GetParticleIndexAt(distance);
        }

        /// <summary>
        /// Returns the scalar distance along the curve of the rope that a particular simulation particle is located at. The scalar distance is
        /// a value between 0 and 1. The lengthMultiplier is not taken into account. To get the distance along the rope in world space, multiply
        /// the scalar distance by the realCurveLength measurement.
        /// </summary>
        /// <param name="particleIndex">The index of the simulation particle</param>
        /// <returns>The scalar distance</returns>
        public float GetScalarDistanceAt(int particleIndex)
        {
            if (!Initialize() || particleIndex < 0 || particleIndex >= positions.Length)
            {
                return 0.0f;
            }
            return math.clamp((float)particleIndex / (measurements.particleCount - 1), 0.0f, 1.0f);
        }

        /// <summary>
        /// Returns the current position of a particular simulation particle
        /// </summary>
        /// <param name="particleIndex">The index of the simulation particle</param>
        /// <param name="respectInterpolation">Whether or not the returned position should respect the interpolation setting of the rope.</param>
        /// <returns>The current position in world-space</returns>
        public float3 GetPositionAt(int particleIndex, bool respectInterpolation = false)
        {
            if (!Initialize() || particleIndex < 0 || particleIndex >= positions.Length)
            {
                return float3.zero;
            }
            CompletePreviousSimulationFrame();
            if (respectInterpolation && interpolation != RopeInterpolation.None)
            {
                return interpolatedPositions[particleIndex];
            }
            else
            {
                return positions[particleIndex];
            }
        }

        /// <summary>
        /// Sets the position of a particular simulation particle. Because of the integration scheme used for particles
        /// this also updates the velocity. If the velocity of the particle should stay the same, also set the velocity
        /// to what it was prior to the call to SetPositionAt(). The reason it works like this is because this integration
        /// scheme makes it easy to update positions while respecting multiple constraints at the same time.
        /// </summary>
        /// <param name="particleIndex">The index of the simulation particle</param>
        /// <param name="position">The desired position in world-space</param>
        public void SetPositionAt(int particleIndex, float3 position)
        {
            if (!Initialize() || particleIndex < 0 || particleIndex >= positions.Length)
            {
                return;
            }
            CompletePreviousSimulationFrame();
            positions[particleIndex] = position;
        }

        /// <summary>
        /// Returns the current velocity of a particular simulation particle
        /// </summary>
        /// <param name="particleIndex">The index of the simulation particle</param>
        /// <returns>The velocity in world-space</returns>
        public float3 GetVelocityAt(int particleIndex)
        {
            if (!Initialize() || particleIndex < 0 || particleIndex >= positions.Length)
            {
                return float3.zero;
            }
            CompletePreviousSimulationFrame();
            return (positions[particleIndex] - prevPositions[particleIndex]) / Time.fixedDeltaTime;
        }

        /// <summary>
        /// Sets the velocity of a particular simulation particle
        /// </summary>
        /// <param name="particleIndex">The index of the simulation particle</param>
        /// <param name="velocity">The desired velocity in world-space</param>
        public void SetVelocityAt(int particleIndex, float3 velocity)
        {
            if (!Initialize() || particleIndex < 0 || particleIndex >= positions.Length)
            {
                return;
            }
            CompletePreviousSimulationFrame();
            prevPositions[particleIndex] = positions[particleIndex] - velocity * Time.fixedDeltaTime;
        }

        /// <summary>
        /// Returns the mass multiplier of a particular simulation particle. This value can be used to increase or decrease
        /// the weight of a section of the rope. A value of 0 will make the particle immovable. A value of 2 will make the
        /// particle twice as heavy as its neighbors. The default value is 1.
        /// </summary>
        /// <param name="particleIndex">The index of the simulation particle</param>
        /// <returns>The mass multiplier</returns>
        public float GetMassMultiplierAt(int particleIndex)
        {
            if (!Initialize() || particleIndex < 0 || particleIndex >= positions.Length)
            {
                return 0.0f;
            }
            CompletePreviousSimulationFrame();
            return massMultipliers[particleIndex];
        }

        /// <summary>
        /// Sets the mass multiplier of a particular simulation particle. This value can be used to increase or decrease
        /// the weight of a section of the rope. A value of 0 will make the particle immovable. A value of 2 will make the
        /// particle twice as heavy as its neighbors. The default value is 1.
        /// </summary>
        /// <param name="particleIndex">The index of the simulation particle</param>
        /// <param name="value">The desired mass multiplier</param>
        public void SetMassMultiplierAt(int particleIndex, float value)
        {
            if (!Initialize() || particleIndex < 0 || particleIndex >= positions.Length)
            {
                return;
            }
            CompletePreviousSimulationFrame();
            massMultipliers[particleIndex] = value;
        }

        /// <summary>
        /// Finds the simulation particle closest to a particular point
        /// </summary>
        /// <param name="point">The point in world-space</param>
        /// <param name="particleIndex">The index of the closest simulation particle</param>
        /// <param name="distance">The distance along the rope of the closest simulation particle in world-space</param>
        public void GetClosestParticle(float3 point, out int particleIndex, out float distance)
        {
            if (!Initialize())
            {
                particleIndex = -1;
                distance = 0.0f;
                return;
            }
            CompletePreviousSimulationFrame();
            positions.GetClosestPoint(point, out particleIndex, out distance);
        }

        /// <summary>
        /// Finds the simulation particle closest to a particular ray
        /// </summary>
        /// <param name="ray">The ray in world-space</param>
        /// <param name="particleIndex">The index of the closest simulation particle</param>
        /// <param name="distance">The distance along the rope of the closest simulation particle in world-space</param>
        /// <param name="distanceAlongRay">The distance along the ray to the point on the ray that is closest to the simulation particle</param>
        public void GetClosestParticle(Ray ray, out int particleIndex, out float distance, out float distanceAlongRay)
        {
            if (!Initialize())
            {
                particleIndex = -1;
                distance = 0.0f;
                distanceAlongRay = 0.0f;
                return;
            }
            CompletePreviousSimulationFrame();
            positions.GetClosestPoint(ray, out particleIndex, out distance, out distanceAlongRay);
        }

        /// <summary>
        /// Registers a rigidbody connection for the next simulation frame. A rigidbody connection is a two-way coupling of a simulation particle
        /// to a traditional rigidbody. Make sure to call this method from FixedUpdate(). Any simulation particle involved in a rigidbody connection
        /// will get its mass multiplier reset to 1 at the end of the simulation frame.
        /// </summary>
        /// <param name="particleIndex">The index of the simulation particle to connect</param>
        /// <param name="rigidbody">The rigidbody to connect</param>
        /// <param name="rigidbodyDamping">The amount of damping to apply to the rigidbody in the range [0, 1]</param>
        /// <param name="pointOnBody">The world-space point on the rigidbody to connect</param>
        /// <param name="stiffness">The stiffness of the connection in the range [0, 1]</param>
        public void RegisterRigidbodyConnection(int particleIndex, Rigidbody rigidbody, float rigidbodyDamping, float3 pointOnBody, float stiffness)
        {
            if (!Initialize() || particleIndex < 0 || particleIndex >= positions.Length || !enabled || !simulation.enabled)
            {
                return;
            }
            queuedRigidbodyConnections.Add(new RigidbodyConnection()
            {
                rigidbody = rigidbody,
                rigidbodyDamping = rigidbodyDamping,
                target = new ParticleTarget()
                {
                    particleIndex = particleIndex,
                    position = pointOnBody,
                    stiffness = stiffness,
                },
            });
        }

        /// <summary>
        /// Resets the rope to its original shape relative to the current transform. Useful when activating a pooled game object that is
        /// deactivated and re-activated instead of destroyed and instantiated.
        /// </summary>
        public void ResetToSpawnCurve()
        {
            if (!Initialize())
            {
                return;
            }

            CompletePreviousSimulationFrame();

            var localToWorld = (float4x4)transform.localToWorldMatrix;

            spawnPoints.GetPointsAlongCurve(ref localToWorld, _measurements.particleSpacing, positions);
            positions.CopyTo(prevPositions);
        }

        /// <summary>
        /// Computes the current length of the rope. In contrast to the measurements.realCurveLength field, this value includes the stretching
        /// of the rope due to stress.
        /// </summary>
        public float GetCurrentLength()
        {
            if (!Initialize())
            {
                return 0.0f;
            }

            CompletePreviousSimulationFrame();

            return positions.GetLengthOfCurve(isLoop);
        }

        protected Rope InstantiateSplitRope(int minIdx, int maxIdx, string identifier)
        {
            var count = maxIdx - minIdx + 1;
            if (minIdx < 0 || maxIdx > positions.Length - 1 || count < 2)
            {
                return null;
            }

            // Create two spawn points that are roughly placed where the new rope will be (this will create nice bitangents)
            var targetLength = _measurements.realCurveLength * ((float)count / _measurements.particleCount);
            var point0 = positions[minIdx];
            var point1 = positions[maxIdx];
            var delta = point1 - point0;
            var simplifiedLength = math.length(delta);
            point1 += math.normalizesafe(delta) * (targetLength - simplifiedLength);

            var rope = Instantiate(gameObject, Vector3.zero, Quaternion.identity).GetComponent<Rope>();
            rope.name = identifier;
            rope.isLoop = false;
            rope.spawnPoints = new List<float3>()
            {
                point0,
                point1,
            };

            if (rope.Initialize())
            {
                // Now update the simulation particles to exactly match those of the original rope
                for (int i = 0; i < rope.positions.Length; i++)
                {
                    var sourceIdx = minIdx + i;
                    if (sourceIdx >= positions.Length)
                    {
                        break;
                    }
                    rope.positions[i] = positions[sourceIdx];
                    rope.prevPositions[i] = prevPositions[sourceIdx];
                }

                // Make new rope the same size as old rope
                rope._measurements.realCurveLength = rope.GetCurrentLength();
                rope._measurements.particleSpacing = _measurements.particleSpacing;

                var param = new OnSplitParams()
                {
                    minParticleIndex = minIdx,
                    maxParticleIndex = maxIdx,
                    preSplitMeasurements = _measurements,
                };

                rope.SendMessage("OnRopeSplit", param, SendMessageOptions.DontRequireReceiver);
            }

            return rope;
        }

        /// <summary>
        /// Splits the rope at a specific simulation particle and returns the rope components of the newly instantiated game objects. Make sure
        /// that the supplied array has exactly 2 slots. A Unity message 'OnRopeSplit(Rope.OnSplitParams)' will be sent to each newly created rope.
        /// </summary>
        /// <param name="particleIndex">The index of the simulation particle at which point to split</param>
        /// <param name="outNewRopes">If not null, an array with exactly 2 elements where the new rope game objects will be returned</param>
        public void SplitAt(int particleIndex, Rope[] outNewRopes = null)
        {
            if (!Initialize() || (outNewRopes != null && outNewRopes.Length != 2) || wasSplit)
            {
                return;
            }
            wasSplit = true;

            var fst = InstantiateSplitRope(0, particleIndex, name + "_split0");
            var snd = InstantiateSplitRope(particleIndex + 1, positions.Length - 1, name + "_split1");

            Destroy(gameObject);

            if (outNewRopes != null)
            {
                outNewRopes[0] = fst;
                outNewRopes[1] = snd;
            }
        }

        protected void ComputeRealCurve(Allocator allocator, out Measurements measurements, out NativeArray<float3> points)
        {
            var localToWorld = (float4x4)transform.localToWorldMatrix;

            var spawnCurveLength = spawnPoints.GetLengthOfCurve(ref localToWorld);
            var segmentCount = math.max(1, (int)(spawnCurveLength * simulation.resolution));
            var particleCount = segmentCount + 1;
            var particleSpacing = spawnCurveLength / segmentCount;

            points = new NativeArray<float3>(particleCount, allocator);
            spawnPoints.GetPointsAlongCurve(ref localToWorld, particleSpacing, points);
            var realCurveLength = points.GetLengthOfCurve(ref localToWorld);

            measurements = new Measurements()
            {
                spawnCurveLength = spawnCurveLength,
                realCurveLength = realCurveLength,
                segmentCount = segmentCount,
                particleCount = particleCount,
                particleSpacing = particleSpacing,
            };
        }

        public void OnEnable()
        {
            if (!initialized)
            {
                return;
            }

            CompletePreviousSimulationFrame();
        }

        public void Start()
        {
            Initialize();
        }

        public void OnDisable()
        {
            if (!initialized)
            {
                return;
            }

            CompletePreviousSimulationFrame();

            simulationDisabledPrevFrame = true;
        }

        public void OnDestroy()
        {
            if (!initialized)
            {
                return;
            }

            CompletePreviousSimulationFrame();

            // State
            positions.Dispose();
            prevPositions.Dispose();
            if (interpolatedPositions.IsCreated)
            {
                interpolatedPositions.Dispose();
            }
            bitangents.Dispose();
            massMultipliers.Dispose();

            // Collision handling
            collisionPlanesActive.Dispose();
            collisionPlanes.Dispose();
            collisionRigidbodies = null;

            // Rigidbody connections
            particleTargets.Dispose();
            particleTargetFeedbacks.Dispose();

            // Rendering
            vertices.Dispose();
            normals.Dispose();
            cosLookup.Dispose();
            sinLookup.Dispose();

            Destroy(mesh);
        }

        protected bool Initialize()
        {
            if (initialized)
            {
                return true;
            }
            if (!Application.isPlaying || spawnPoints.Count < 2)
            {
                // Not designed for edit-mode execution
                return false;
            }

            // State
            ComputeRealCurve(Allocator.Persistent, out _measurements, out positions);

            prevPositions = new NativeArray<float3>(_measurements.particleCount, Allocator.Persistent);
            positions.CopyTo(prevPositions);
            if (interpolation != RopeInterpolation.None)
            {
                interpolatedPositions = new NativeArray<float3>(_measurements.particleCount, Allocator.Persistent);
                positions.CopyTo(interpolatedPositions);
            }

            bitangents = new NativeArray<float3>(_measurements.particleCount, Allocator.Persistent);
            {
                var up = new float3(0.0f, 1.0f, 0.0f);

                for (int i = 0; i < bitangents.Length; i++)
                {
                    var tangent = positions[(i + 1) % bitangents.Length] - positions[i];

                    var bitangent = math.normalizesafe(math.cross(up, tangent));
                    if (math.all(bitangent == float3.zero))
                    {
                        bitangent = math.normalizesafe(math.cross(up + new float3(0.0f, 0.0f, -1.0f), tangent));
                    }
                    bitangents[i] = bitangent;

                    up = math.cross(tangent, bitangent);
                }

                if (!isLoop)
                {
                    bitangents[bitangents.Length - 1] = bitangents[bitangents.Length - 2];
                }
            }

            massMultipliers = new NativeArray<float>(_measurements.particleCount, Allocator.Persistent);
            for (int i = 0; i < massMultipliers.Length; i++)
            {
                massMultipliers[i] = 1.0f;
            }

            // Collision handling
            collisionPlanesActive = new NativeArray<int>(_measurements.particleCount, Allocator.Persistent);
            collisionPlanes = new NativeArray<CollisionPlane>(_measurements.particleCount * MaxCollisionPlanesPerParticle, Allocator.Persistent);
            collisionRigidbodies = new Rigidbody[collisionPlanes.Length];

            // Rigidbody connections
            queuedRigidbodyConnections = new List<RigidbodyConnection>();
            liveRigidbodyConnections = new List<RigidbodyConnection>();
            particleTargets = new NativeArray<ParticleTarget>(InitialParticleTargets, Allocator.Persistent);
            particleTargetFeedbacks = new NativeArray<float3>(InitialParticleTargets, Allocator.Persistent);

            // Rendering
            vertices = new NativeArray<Vector3>(_measurements.particleCount * radialVertices, Allocator.Persistent);
            normals = new NativeArray<Vector3>(vertices.Length, Allocator.Persistent);
            cosLookup = new NativeArray<float3>(radialVertices, Allocator.Persistent);
            sinLookup = new NativeArray<float3>(radialVertices, Allocator.Persistent);

            for (int i = 0; i < radialVertices; i++)
            {
                var angle = ((float)i / (radialVertices - 1)) * Mathf.PI * 2.0f;
                cosLookup[i] = Mathf.Cos(angle);
                sinLookup[i] = Mathf.Sin(angle);
            }

            // Note that triangles and uvs are unchanged after mesh creation
            var triangleParticleMax = isLoop ? _measurements.particleCount : _measurements.particleCount - 1;
            var radialTriangleCount = triangleParticleMax * (radialVertices - 1) * 2 * 3;
            var capTriangleCount = isLoop ? 0 : 2 * (radialVertices - 3) * 3;
            var triangleCount = radialTriangleCount + capTriangleCount;
            var triangles = new int[triangleCount];

            int idx = 0;
            for (int i = 0; i < triangleParticleMax; i++)
            {
                int vertexOffset0 = i * radialVertices;
                int vertexOffset1 = ((i + 1) % _measurements.particleCount) * radialVertices;

                for (int j = 0; j < radialVertices - 1; j++)
                {
                    int v0 = vertexOffset0 + j + 0;
                    int v1 = vertexOffset0 + j + 1;
                    int v2 = vertexOffset1 + j + 0;
                    int v3 = vertexOffset1 + j + 1;

                    triangles[idx++] = v0;
                    triangles[idx++] = v1;
                    triangles[idx++] = v2;
                    triangles[idx++] = v2;
                    triangles[idx++] = v1;
                    triangles[idx++] = v3;
                }
            }
            if (!isLoop)
            {
                for (int i = 1; i < radialVertices - 2; i++)
                {
                    triangles[idx++] = 0;
                    triangles[idx++] = i + 1;
                    triangles[idx++] = i;
                }
                int vertexOffset = triangleParticleMax * radialVertices;
                for (int i = 1; i < radialVertices - 2; i++)
                {
                    triangles[idx++] = vertexOffset;
                    triangles[idx++] = vertexOffset + i;
                    triangles[idx++] = vertexOffset + i + 1;
                }
            }

            var uvs = new Vector2[vertices.Length];
            for (int i = 0; i < _measurements.particleCount; i++)
            {
                var uv = new Vector2
                {
                    x = ((float)i / (_measurements.particleCount - 1)) * _measurements.realCurveLength,
                };

                for (int j = 0; j < radialVertices; j++)
                {
                    uv.y = (float)j / (radialVertices - 1);
                    uvs[i * radialVertices + j] = uv;
                }
            }

            mesh = new Mesh
            {
                name = gameObject.name + "_rope"
            };
            mesh.MarkDynamic();
            mesh.SetVertices(vertices);
            mesh.SetNormals(normals);
            mesh.uv = uvs;
            mesh.triangles = triangles;

            initialized = true;
            computingSimulationFrame = false;
            return true;
        }

        protected Collider[] collisionQueryBuffer = new Collider[MaxCollisionPlanesPerParticle];

        public void UpdateCollisionPlanes()
        {
            if (!collisions.enabled)
            {
                return;
            }

            Profiler.BeginSample(nameof(UpdateCollisionPlanes));

            var deltaTime = Time.fixedDeltaTime;
            var layerMask = ~collisions.ignoreLayers;
            var safeRadius = radius + collisions.collisionMargin;
            var safeRadiusSq = safeRadius * safeRadius;
            var extendedRadius = safeRadius * 1.5f;

            for (int i = 0; i < collisionPlanesActive.Length; i++)
            {
                if (i % collisions.stride != 0)
                {
                    collisionPlanesActive[i] = 0;
                    for (int j = 0; j < MaxCollisionPlanesPerParticle; j++)
                    {
                        collisionRigidbodies[i * MaxCollisionPlanesPerParticle + j] = null;
                    }
                    continue;
                }

                var planeCount = 0;

                // Use projected positions for the next frame
                var pos = positions[i];
                var prevPos = prevPositions[i];
                var vel = pos - prevPos;
                prevPos = pos;
                pos += vel;

                // Check for overlap
                var hitCount = Physics.OverlapSphereNonAlloc(pos, extendedRadius, collisionQueryBuffer, layerMask); // use a slightly larger sphere to catch more collisions
                for (int j = 0; j < hitCount && planeCount < MaxCollisionPlanesPerParticle; j++)
                {
                    var collider = collisionQueryBuffer[j];
                    var meshCollider = collider as MeshCollider;

                    if (collider is BoxCollider ||
                        collider is SphereCollider ||
                        collider is CapsuleCollider ||
                        (meshCollider != null && meshCollider.convex))
                    {
                        var closestPoint = (float3)Physics.ClosestPoint(pos, collider, collider.transform.position, collider.transform.rotation);

                        var normal = math.normalizesafe(pos - closestPoint);
                        if (math.all(normal == float3.zero))
                        {
                            continue;
                        }

                        collisionPlanes[i * MaxCollisionPlanesPerParticle + planeCount] = new CollisionPlane()
                        {
                            point = closestPoint,
                            normal = normal,
                            velocityChange = collider.attachedRigidbody != null
                                ? (float3)collider.attachedRigidbody.GetPointVelocity(closestPoint) * deltaTime
                                : float3.zero,
                        };
                        collisionRigidbodies[i * MaxCollisionPlanesPerParticle + planeCount] = collider.attachedRigidbody;
                        planeCount++;
                    }
                }

                // Check fast movements
                if (planeCount < MaxCollisionPlanesPerParticle)
                {
                    var movementSq = math.lengthsq(vel);
                    if (movementSq > safeRadiusSq)
                    {
                        if (Physics.Linecast(prevPos, pos, out RaycastHit hit, layerMask))
                        {
                            collisionPlanes[i * MaxCollisionPlanesPerParticle + planeCount] = new CollisionPlane()
                            {
                                point = hit.point,
                                normal = hit.normal,
                                velocityChange = hit.rigidbody != null
                                    ? (float3)hit.rigidbody.GetPointVelocity(hit.point) * deltaTime
                                    : float3.zero,
                            };
                            collisionRigidbodies[i * MaxCollisionPlanesPerParticle + planeCount] = hit.rigidbody;
                            planeCount++;
                        }
                    }
                }

                collisionPlanesActive[i] = planeCount;
            }

            Profiler.EndSample();
        }

        protected void PrepareRigidbodyConnections()
        {
            Profiler.BeginSample(nameof(PrepareRigidbodyConnections));

            liveRigidbodyConnections.AddRange(queuedRigidbodyConnections);
            queuedRigidbodyConnections.Clear();

            if (liveRigidbodyConnections.Count > particleTargets.Length)
            {
                if (liveRigidbodyConnections.Count > MaxRigidbodyConnections)
                {
                    Debug.LogWarning(
                        $"Encountered too many live rigid body connections ({liveRigidbodyConnections.Count}) this frame. " +
                        $"Limiting enforcement to the max value ({MaxRigidbodyConnections}) to avoid a performance drop...");
                }
                else
                {
                    var newCapacity = liveRigidbodyConnections.Count * 2;

                    particleTargets.Dispose();
                    particleTargets = new NativeArray<ParticleTarget>(newCapacity, Allocator.Persistent);
                    particleTargetFeedbacks.Dispose();
                    particleTargetFeedbacks = new NativeArray<float3>(newCapacity, Allocator.Persistent);
                }
            }

            for (int i = 0; i < particleTargets.Length; i++)
            {
                if (i < liveRigidbodyConnections.Count)
                {
                    var c = liveRigidbodyConnections[i];

                    if (!c.rigidbody)
                    {
                        c.target.stiffness = 0.0f;
                    }

                    particleTargets[i] = c.target;

                    // Make particle immovable if rigidbody is kinematic
                    if (c.rigidbody && c.rigidbody.isKinematic)
                    {
                        massMultipliers[c.target.particleIndex] = 0.0f;
                    }
                }
                else
                {
                    particleTargets[i] = new ParticleTarget()
                    {
                        particleIndex = -1,
                    };
                }
            }

            Profiler.EndSample();
        }

        protected void ApplyRigidbodyFeedback()
        {
            Profiler.BeginSample(nameof(ApplyRigidbodyFeedback));

            var particleMass = simulation.massPerMeter * _measurements.realCurveLength / _measurements.particleCount;
            var invDtAndSim = 1.0f / (Time.fixedDeltaTime * simulation.substeps * simulation.solverIterations);

            // Collisions
            if (collisions.enabled && collisions.influenceRigidbodies)
            {
                for (int i = 0; i < collisionPlanesActive.Length; i++)
                {
                    if (i % collisions.stride != 0)
                    {
                        continue;
                    }

                    int activePlaneCount = collisionPlanesActive[i];
                    for (int j = 0; j < activePlaneCount; j++)
                    {
                        Rigidbody rb = collisionRigidbodies[i * MaxCollisionPlanesPerParticle + j];
                        if (rb != null && !rb.isKinematic)
                        {
                            CollisionPlane plane = collisionPlanes[i * MaxCollisionPlanesPerParticle + j];
                            float3 impulse = plane.feedback * (particleMass * invDtAndSim);
                            rb.ApplyImpulseNow(plane.point, impulse);
                        }
                    }
                }
            }

            // Connections
            if (liveRigidbodyConnections.Count > 0)
            {
                var iterationCount = math.min(liveRigidbodyConnections.Count, particleTargetFeedbacks.Length);

                for (int i = 0; i < iterationCount; i++)
                {
                    var c = liveRigidbodyConnections[i];

                    // Apply impulse
                    if (c.rigidbody)
                    {
                        float3 impulse = particleTargetFeedbacks[i] * (particleMass * invDtAndSim);
                        c.rigidbody.ApplyImpulseNow(c.target.position, impulse);

                        if (c.rigidbodyDamping > 0.0f)
                        {
                            float3 normal = math.normalizesafe(impulse);
                            c.rigidbody.SetPointVelocityNow(c.target.position, normal, 0.0f, c.rigidbodyDamping);
                        }
                    }

                    // Reset particle mass multiplier (may have changed if body was kinematic)
                    massMultipliers[c.target.particleIndex] = 1.0f;
                }

                liveRigidbodyConnections.Clear();
            }

            Profiler.EndSample();
        }

        protected void ScheduleNextSimulationFrame()
        {
            Profiler.BeginSample(nameof(ScheduleNextSimulationFrame));

            computingSimulationFrame = true;

            var gravity = simulation.useCustomGravity ? simulation.customGravity : (float3)Physics.gravity;

            var simulate = new SimulateJob()
            {
                deltaTime = Time.fixedDeltaTime,
                externalAcceleration = gravity * simulation.gravityMultiplier,
                energyKept = 1.0f - simulation.energyLoss,

                positions = positions,
                prevPositions = prevPositions,
                massMultipliers = massMultipliers,

                isLoop = isLoop,
                substeps = simulation.substeps,
                solverIterations = simulation.solverIterations,
                stiffness = simulation.stiffness,
                desiredSpacing = _measurements.particleSpacing * simulation.lengthMultiplier,

                collisionsEnabled = collisions.enabled,
                radius = radius + collisions.collisionMargin,
                friction = collisions.friction,
                maxCollisionPlanesPerParticle = MaxCollisionPlanesPerParticle,
                collisionPlanesActive = collisionPlanesActive,
                collisionPlanes = collisionPlanes,

                particleTargets = particleTargets,
                particleTargetFeedbacks = particleTargetFeedbacks,
            }.Schedule();

            if (interpolation == RopeInterpolation.None)
            {
                simulationFrameHandle = new OutputVerticesJob()
                {
                    positions = positions,
                    bitangents = bitangents,
                    isLoop = isLoop,
                    radialVertices = radialVertices,
                    radius = radius,
                    cosLookup = cosLookup,
                    sinLookup = sinLookup,
                    vertices = vertices,
                    normals = normals,
                }.Schedule(simulate);
            }
            else
            {
                // OutputVerticesJob must happen after interpolation, and interpolation happens in Update(), not FixedUpdate()
                simulationFrameHandle = simulate;
            }

            JobHandle.ScheduleBatchedJobs();

            Profiler.EndSample();
        }

        protected void ScheduleInterpolation()
        {
            if (interpolation == RopeInterpolation.None)
            {
                return;
            }

            CompletePreviousSimulationFrame();

            Profiler.BeginSample(nameof(ScheduleInterpolation));

            computingSimulationFrame = true;

            var invDt = 1.0f / Time.fixedDeltaTime;

            var handle = new JobHandle();

            if (interpolation == RopeInterpolation.Interpolate)
            {
                handle = new InterpolatePositionsJob()
                {
                    positions = positions,
                    prevPositions = prevPositions,

                    invDeltaTime = invDt,
                    timeSinceFixedUpdate = timeSinceFixedUpdate,

                    interpolatedPositions = interpolatedPositions,
                }.Schedule();
            }
            else
            {
                handle = new ExtrapolatePositionsJob()
                {
                    positions = positions,
                    prevPositions = prevPositions,

                    invDeltaTime = invDt,
                    timeSinceFixedUpdate = timeSinceFixedUpdate,

                    interpolatedPositions = interpolatedPositions,
                }.Schedule();
            }

            simulationFrameHandle = new OutputVerticesJob()
            {
                positions = interpolatedPositions,
                bitangents = bitangents,
                isLoop = isLoop,
                radialVertices = radialVertices,
                radius = radius,
                cosLookup = cosLookup,
                sinLookup = sinLookup,
                vertices = vertices,
                normals = normals,
            }.Schedule(handle);

            JobHandle.ScheduleBatchedJobs();

            Profiler.EndSample();
        }

        protected void CompletePreviousSimulationFrame()
        {
            if (!computingSimulationFrame)
            {
                return;
            }

            Profiler.BeginSample(nameof(CompletePreviousSimulationFrame));

            simulationFrameHandle.Complete();
            computingSimulationFrame = false;

            Profiler.EndSample();
        }

        protected static void FillMeshFrames(ref NativeArray<float3> positions, ref NativeArray<float3> bitangents, Matrix4x4[] meshFrames, float spacing, bool isLoop, float rotationOffset, Vector3 scaleMultiplier, bool stretch)
        {
            var scale = scaleMultiplier * 0.5f * spacing;
            if (stretch)
            {
                scale.z = scaleMultiplier.z * 0.5f;
            }

            var currentRotation = 0.0f;
            for (var i = 0; i < positions.Length; i++) // use the positions array here and hope that the compiler optimizes away bounds checking...
            {
                var tangent = Vector3.zero;
                if (isLoop)
                {
                    tangent = positions[(i + 1) % positions.Length] - positions[i];
                }
                else
                {
                    tangent = i < positions.Length - 1
                        ? positions[i + 1] - positions[i]
                        : positions[i] - positions[i - 1];
                }
                var frameScale = stretch
                    ? new Vector3(scale.x, scale.y, scale.z * tangent.magnitude)
                    : scale;
                tangent.Normalize();

                var frameRotation = Quaternion.LookRotation(tangent, bitangents[i]) * Quaternion.Euler(0.0f, 0.0f, currentRotation);
                currentRotation += rotationOffset;

                customMeshFrames[i] = Matrix4x4.TRS(positions[i], frameRotation, frameScale);
            }
        }

        protected static Matrix4x4[] customMeshFrames;

        protected void SubmitToRenderer()
        {
            if (material == null)
            {
                return;
            }

            Profiler.BeginSample(nameof(SubmitToRenderer));

            if (customMesh.mesh == null)
            {
                // Default rope cylinder
                if (simulation.enabled)
                {
                    mesh.SetVertices(vertices);
                    mesh.SetNormals(normals);
                    mesh.RecalculateBounds();
                }

                Graphics.DrawMesh(mesh, Matrix4x4.identity, material, gameObject.layer, null, 0, null, shadowMode);
            }
            else
            {
                // Custom mesh at each simulation particle
                if (customMeshFrames == null || customMeshFrames.Length < positions.Length)
                {
                    customMeshFrames = new Matrix4x4[positions.Length];
                }

                if (interpolation == RopeInterpolation.None)
                {
                    FillMeshFrames(
                        ref positions,
                        ref bitangents,
                        customMeshFrames,
                        _measurements.particleSpacing,
                        isLoop,
                        customMesh.rotation,
                        customMesh.scale,
                        customMesh.stretch);
                }
                else
                {
                    FillMeshFrames(
                        ref interpolatedPositions,
                        ref bitangents,
                        customMeshFrames,
                        _measurements.particleSpacing,
                        isLoop,
                        customMesh.rotation,
                        customMesh.scale,
                        customMesh.stretch);
                }

                Graphics.DrawMeshInstanced(customMesh.mesh, 0, material, customMeshFrames, positions.Length, null, shadowMode, true, gameObject.layer);
            }

            Profiler.EndSample();
        }

        public void FixedUpdate()
        {
            timeSinceFixedUpdate = 0.0f;

            if (!initialized)
            {
                return;
            }
            if (!simulation.enabled)
            {
                simulationDisabledPrevFrame = true;
                return;
            }

            CompletePreviousSimulationFrame(); // fixed update might run several times per rendered frame

            if (simulationDisabledPrevFrame)
            {
                queuedRigidbodyConnections.Clear();
                liveRigidbodyConnections.Clear();
            }
            simulationDisabledPrevFrame = false;

            transform.position = positions[0];

            ApplyRigidbodyFeedback(); // from previous frame

            UpdateCollisionPlanes();

            PrepareRigidbodyConnections();

            ScheduleNextSimulationFrame();
        }

        public void LateUpdate()
        {
            timeSinceFixedUpdate += Time.deltaTime;

            if (!initialized)
            {
                return;
            }

            if (interpolation != RopeInterpolation.None)
            {
                ScheduleInterpolation();
            }

            CompletePreviousSimulationFrame();

            SubmitToRenderer();
        }

#if UNITY_EDITOR
        public void OnDrawGizmos()
        {
            if (Application.isPlaying || spawnPoints.Count < 2 || !enabled)
            {
                return;
            }

            ComputeRealCurve(Allocator.Temp, out Measurements measurements, out NativeArray<float3> points);

            Gizmos.color = Colors.ropeSegments;
            for (int i = 0; i < points.Length - 1; i++)
            {
                Gizmos.DrawLine(points[i], points[i + 1]);
            }
            if (isLoop && points.Length > 1)
            {
                Gizmos.DrawLine(points[points.Length - 1], points[0]);
            }

            if (UnityEditor.Selection.Contains(gameObject))
            {
                for (int i = 0; i < points.Length; i++)
                {
                    if (collisions.enabled && i % collisions.stride == 0)
                    {
                        Gizmos.color = Colors.collisionParticle;
                    }
                    else
                    {
                        Gizmos.color = Colors.simulationParticle;
                    }
                    Gizmos.DrawSphere(points[i], radius);
                }
            }

            points.Dispose();
        }

        public void OnDrawGizmosSelected()
        {
            if (!initialized)
            {
                return;
            }

            var bounds = currentBounds;
            Gizmos.color = Color.gray;
            Gizmos.DrawWireCube(bounds.center, bounds.size);
        }
#endif

        [BurstCompile]
        private struct SimulateJob : IJob
        {
            [ReadOnly] public float deltaTime;
            [ReadOnly] public float3 externalAcceleration;
            [ReadOnly] public float energyKept;

            // State
            public NativeArray<float3> positions;
            public NativeArray<float3> prevPositions;
            [ReadOnly] public NativeArray<float> massMultipliers;

            // Shape
            [ReadOnly] public bool isLoop;
            [ReadOnly] public int substeps;
            [ReadOnly] public int solverIterations;
            [ReadOnly] public float stiffness;
            [ReadOnly] public float desiredSpacing;

            // Collision handling
            [ReadOnly] public bool collisionsEnabled;
            [ReadOnly] public float radius;
            [ReadOnly] public float friction;
            [ReadOnly] public int maxCollisionPlanesPerParticle;
            [ReadOnly] public NativeArray<int> collisionPlanesActive;
            public NativeArray<CollisionPlane> collisionPlanes;

            // Rigidbody attachments
            [ReadOnly] public NativeArray<ParticleTarget> particleTargets;
            public NativeArray<float3> particleTargetFeedbacks;

            public void Execute()
            {
                // Prepare for simulation
                for (int i = 0; i < particleTargetFeedbacks.Length; i++)
                {
                    particleTargetFeedbacks[i] = float3.zero;
                }

                // Simulate
                float dt = deltaTime / substeps;
                float invDt = 1.0f / dt;
                bool forwardSolve = true;

                for (int substep = 0; substep < substeps; substep++)
                {
                    for (int i = 0; i < positions.Length; i++)
                    {
                        if (massMultipliers[i] == 0.0f)
                        {
                            prevPositions[i] = positions[i];
                            continue;
                        }

                        var pos = positions[i];
                        var prevPos = prevPositions[i];

                        var vel = (pos - prevPos) * invDt;
                        vel += externalAcceleration * dt;
                        vel *= energyKept;

                        prevPositions[i] = pos;
                        positions[i] += vel * dt;
                    }

                    for (int iter = 0; iter < solverIterations; iter++)
                    {
                        int loopCount = isLoop ? positions.Length : positions.Length - 1;

                        // Apply stick constraints
                        if (forwardSolve) // alternate solving forwards and backwards to balance out errors
                        {
                            for (int i = 0; i < loopCount; i++)
                            {
                                ApplyStickConstraint(i, (i + 1) % positions.Length);
                            }
                        }
                        else
                        {
                            for (int i = loopCount - 1; i >= 0; i--)
                            {
                                ApplyStickConstraint(i, (i + 1) % positions.Length);
                            }
                        }
                        forwardSolve = !forwardSolve;

                        // Apply collision constraints
                        if (collisionsEnabled)
                        {
                            for (int i = 0; i < positions.Length; i++)
                            {
                                for (int j = 0; j < collisionPlanesActive[i]; j++)
                                {
                                    int planeIndex = i * maxCollisionPlanesPerParticle + j;
                                    CollisionPlane plane = collisionPlanes[planeIndex];
                                    ApplyCollisionConstraint(i, ref plane);
                                    collisionPlanes[planeIndex] = plane;
                                }
                            }
                        }

                        // Apply rigidbody connections
                        for (int i = 0; i < particleTargets.Length; i++)
                        {
                            var target = particleTargets[i];
                            if (target.particleIndex == -1)
                            {
                                continue;
                            }

                            var delta = (target.position - positions[target.particleIndex]) * target.stiffness;
                            positions[target.particleIndex] += delta;
                            particleTargetFeedbacks[i] -= delta * massMultipliers[target.particleIndex];
                        }
                    }
                }
            }

            private void ApplyStickConstraint(int idx0, int idx1)
            {
                var delta = positions[idx0] - positions[idx1];
                var dist = math.length(delta);
                if (dist > 0.0f)
                {
                    delta /= dist;
                }
                else
                {
                    delta = 0.0f;
                }

                var correction = (dist - desiredSpacing) * stiffness;

                var w0 = massMultipliers[idx0];
                if (w0 > 0.0f)
                {
                    w0 = 1.0f / w0;
                }
                var w1 = massMultipliers[idx1];
                if (w1 > 0.0f)
                {
                    w1 = 1.0f / w1;
                }
                var invSumW = w0 + w1;
                if (invSumW > 0.0f)
                {
                    invSumW = 1.0f / invSumW;
                }

                positions[idx0] -= delta * (correction * w0 * invSumW);
                positions[idx1] += delta * (correction * w1 * invSumW);
            }

            private void ApplyCollisionConstraint(int idx, ref CollisionPlane plane)
            {
                float dist = math.dot(positions[idx] - plane.point, plane.normal);
                if (dist <= radius)
                {
                    float depth = radius - dist;
                    float3 correction = plane.normal * depth;
                    positions[idx] += correction;
                    plane.feedback -= correction * massMultipliers[idx];

                    // Friction
                    var delta = (positions[idx] - prevPositions[idx]) - plane.velocityChange;
                    var length = math.lengthsq(delta);
                    if (length > 0.0f)
                    {
                        length = math.sqrt(length);
                        delta /= length;
                    }
                    prevPositions[idx] += delta * math.min(depth * friction, length);
                }
            }
        }

        [BurstCompile]
        private struct InterpolatePositionsJob : IJob
        {
            [ReadOnly] public NativeArray<float3> positions;
            [ReadOnly] public NativeArray<float3> prevPositions;

            [ReadOnly] public float invDeltaTime;
            [ReadOnly] public float timeSinceFixedUpdate;

            [WriteOnly] public NativeArray<float3> interpolatedPositions;

            public void Execute()
            {
                var scalar = timeSinceFixedUpdate * invDeltaTime;

                for (int i = 0; i < interpolatedPositions.Length; i++)
                {
                    interpolatedPositions[i] = math.lerp(prevPositions[i], positions[i], scalar);
                }
            }
        }

        [BurstCompile]
        private struct ExtrapolatePositionsJob : IJob
        {
            [ReadOnly] public NativeArray<float3> positions;
            [ReadOnly] public NativeArray<float3> prevPositions;

            [ReadOnly] public float invDeltaTime;
            [ReadOnly] public float timeSinceFixedUpdate;

            [WriteOnly] public NativeArray<float3> interpolatedPositions;

            public void Execute()
            {
                for (int i = 0; i < interpolatedPositions.Length; i++)
                {
                    var vel = (positions[i] - prevPositions[i]) * invDeltaTime;

                    interpolatedPositions[i] = positions[i] + vel * timeSinceFixedUpdate;
                }
            }
        }

        [BurstCompile]
        private struct OutputVerticesJob : IJob
        {
            [ReadOnly] public NativeArray<float3> positions;

            public NativeArray<float3> bitangents;

            [ReadOnly] public bool isLoop;
            [ReadOnly] public int radialVertices;
            [ReadOnly] public float radius;
            [ReadOnly] public NativeArray<float3> cosLookup;
            [ReadOnly] public NativeArray<float3> sinLookup;

            [WriteOnly] public NativeArray<Vector3> vertices;
            [WriteOnly] public NativeArray<Vector3> normals;

            public void Execute()
            {
                var last = positions.Length - 1;

                // Diffuse bitangents
                var smoothedBitangents = new NativeArray<float3>(bitangents.Length, Allocator.Temp);

                smoothedBitangents[0] = bitangents[0] + bitangents[1];
                if (isLoop)
                {
                    smoothedBitangents[0] += bitangents[last];
                }
                for (int i = 1; i < bitangents.Length - 1; i++)
                {
                    smoothedBitangents[i] = bitangents[i - 1] + bitangents[i] + bitangents[i + 1];
                }
                smoothedBitangents[last] = bitangents[last - 1] + bitangents[last];
                if (isLoop)
                {
                    smoothedBitangents[last] += bitangents[0];
                }

                // Re-normalize bitangents
                for (int i = 0; i < bitangents.Length; i++)
                {
                    var tangent = positions[(i + 1) % positions.Length] - positions[i];
                    var normal = math.cross(tangent, smoothedBitangents[i]);

                    bitangents[i] = math.normalizesafe(math.cross(normal, tangent));
                }
                if (!isLoop)
                {
                    bitangents[last] = bitangents[last - 1];
                }

                // Set vertices
                for (int i = 0; i < positions.Length; i++)
                {
                    var tangent = float3.zero;
                    if (isLoop)
                    {
                        tangent = positions[(i + 1) % positions.Length] - positions[i];
                    }
                    else
                    {
                        tangent = i < last
                            ? positions[i + 1] - positions[i]
                            : positions[i] - positions[i - 1];
                    }
                    var bitangent = bitangents[i];
                    var normal = math.normalizesafe(math.cross(tangent, bitangent));

                    for (int j = 0; j < radialVertices; j++)
                    {
                        float3 extent = bitangent * cosLookup[j] + normal * sinLookup[j];
                        vertices[i * radialVertices + j] = positions[i] + extent * radius;
                        normals[i * radialVertices + j] = extent;
                    }
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Rope/Rope.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/Rope/RopeConnection.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3c7388c73173748148c4ba5f2ad6c713
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;
using Unity.Mathematics;

namespace RopeToolkit
{
    public enum RopeConnectionType : int
    {
        PinRopeToTransform = 0,
        PinTransformToRope = 1,
        PullRigidbodyToRope = 2,
        TwoWayCouplingBetweenRigidbodyAndRope = 3,
    }

    [RequireComponent(typeof(Rope))]
    public class RopeConnection : MonoBehaviour
    {
        protected static readonly Color[] colors = new Color[4]
        {
            new Color(0.69f, 0.0f, 1.0f), // purple
            new Color(1.0f, 0.0f, 0.0f), // red
            new Color(1.0f, 0.0f, 0.0f), // red
            new Color(1.0f, 1.0f, 0.0f), // yellow
        };

        [System.Serializable]
        public struct RigidbodySettings
        {
            [Tooltip("The rigidbody to connect to")]
            public Rigidbody body;

            [Tooltip("A measure of the stiffness of the connection. Lower values are usually more stable.")]
            [Range(0.0f, 1.0f)] public float stiffness;

            [Tooltip("The amount of the rigidbody velocity to remove when the impulse is from the rope is applied to the rigidbody")]
            [Range(0.0f, 1.0f)] public float damping;
        }

        [System.Serializable]
        public struct TransformSettings
        {
            [Tooltip("The transform to connect to")]
            public Transform transform;
        }

        [DisableInPlayMode] public RopeConnectionType type;
        [DisableInPlayMode, Range(0.0f, 1.0f)] public float ropeLocation;
        public bool autoFindRopeLocation = false;

        public RigidbodySettings rigidbodySettings = new RigidbodySettings()
        {
            stiffness = 0.1f,
            damping = 0.1f,
        };

        public TransformSettings transformSettings = new TransformSettings()
        {};

        [Tooltip("The point in local object space to connect to")]
        public float3 localConnectionPoint;

        protected Rope rope;
        protected int particleIndex;

        public Component connectedObject
        {
            get
            {
                switch (type)
                {
                    case RopeConnectionType.PinRopeToTransform:
                    case RopeConnectionType.PinTransformToRope: {
                        return transformSettings.transform;
                    }
                    case RopeConnectionType.PullRigidbodyToRope:
                    case RopeConnectionType.TwoWayCouplingBetweenRigidbodyAndRope: {
                        return rigidbodySettings.body;
                    }
                    default: {
                        return null;
                    }
                }
            }
        }

        public float3 connectionPoint
        {
            get
            {
                var obj = connectedObject;
                if (obj)
                {
                    return obj.transform.TransformPoint(localConnectionPoint);
                }
                else
                {
                    return float3.zero;
                }
            }
        }

        public void Initialize(bool forceReset)
        {
            if (rope && !forceReset)
            {
                return;
            }

            rope = GetComponent<Rope>();
            Debug.Assert(rope); // required component!

            if (autoFindRopeLocation)
            {
                rope.GetClosestParticle(connectionPoint, out particleIndex, out float distance);
                ropeLocation = rope.GetScalarDistanceAt(particleIndex);
            }
            else
            {
                var ropeDistance = ropeLocation * rope.measurements.realCurveLength;
                particleIndex = rope.GetParticleIndexAt(ropeDistance);
            }
        }

        public void OnRopeSplit(Rope.OnSplitParams p)
        {
            if (autoFindRopeLocation)
            {
                // There is no way to determine which side of the split this component was located, just remove it...
                Destroy(this);
            }
            else
            {
                var idx = p.preSplitMeasurements.GetParticleIndexAt(ropeLocation * p.preSplitMeasurements.realCurveLength);
                if (idx < p.minParticleIndex || idx > p.maxParticleIndex)
                {
                    Destroy(this);
                }
            }
        }

        public void OnDisable()
        {
            if (rope && type == RopeConnectionType.PinRopeToTransform)
            {
                rope.SetMassMultiplierAt(particleIndex, 1.0f);
            }
        }

        protected void EnforceConnection()
        {
            Initialize(false);

            if (!rope || !connectedObject)
            {
                return;
            }
            
            switch (type)
            {
                case RopeConnectionType.PinRopeToTransform:
                {
                    rope.SetMassMultiplierAt(particleIndex, 0.0f);
                    rope.SetPositionAt(particleIndex, connectionPoint);
                    break;
                }
                case RopeConnectionType.PinTransformToRope:
                {
                    var target = rope.GetPositionAt(particleIndex, true);
                    var offset = (float3)(transformSettings.transform.TransformPoint(localConnectionPoint) - transformSettings.transform.position);
                    transformSettings.transform.position = target - offset;
                    break;
                }
                case RopeConnectionType.PullRigidbodyToRope:
                {
                    var target = rope.GetPositionAt(particleIndex, false);
                    var current = connectionPoint;
                    var delta = target - current;
                    var dist = math.length(delta);
                    if (dist > 0.0f)
                    {
                        var normal = delta / dist;
                        var correctionVelocity = dist * rigidbodySettings.stiffness / Time.fixedDeltaTime;
                        rigidbodySettings.body.SetPointVelocityNow(current, normal, correctionVelocity, rigidbodySettings.damping);
                    }
                    break;
                }
                case RopeConnectionType.TwoWayCouplingBetweenRigidbodyAndRope:
                {
                    rope.RegisterRigidbodyConnection(
                        particleIndex,
                        rigidbodySettings.body,
                        rigidbodySettings.damping,
                        connectionPoint,
                        rigidbodySettings.stiffness);
                    break;
                }
            }
        }

        protected bool ShouldEnforceInFixedUpdate()
        {
            // Prefer FixedUpdate() whenever possible to avoid stalling while waiting for jobs to complete
            bool isPhysics =
                type != RopeConnectionType.PinRopeToTransform &&
                type != RopeConnectionType.PinTransformToRope;

            bool isInterpolating = rope && rope.interpolation != RopeInterpolation.None;

            return isPhysics || !isInterpolating;
        }

        public void Update()
        {
            if (!ShouldEnforceInFixedUpdate())
            {
                EnforceConnection();
            }
        }

        public void FixedUpdate()
        {
            if (ShouldEnforceInFixedUpdate())
            {
                EnforceConnection();
            }
        }

#if UNITY_EDITOR
        public void OnDrawGizmos()
        {
            if (Application.isPlaying)
            {
                return;
            }
            var rope = GetComponent<Rope>();
            if (!rope || rope.spawnPoints.Count < 2 || !connectedObject)
            {
                return;
            }

            var objPoint = connectionPoint;

            Gizmos.color = colors[(int)type];

            Gizmos.DrawWireCube(objPoint, Vector3.one * 0.05f);

            if (!autoFindRopeLocation)
            {
                var localToWorld = (float4x4)rope.transform.localToWorldMatrix;
                var ropeLength = rope.spawnPoints.GetLengthOfCurve(ref localToWorld);
                rope.spawnPoints.GetPointAlongCurve(ref localToWorld, ropeLength * ropeLocation, out float3 ropePoint);

                Gizmos.DrawWireCube(ropePoint, Vector3.one * 0.05f);
                Gizmos.DrawLine(ropePoint, objPoint);
            }
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/Rope/RopeConnection.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Bezier/CubicBezierCurve.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 72d7c273c1cdb4447ac76f4f8eaa0ba1
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace SplineMesh {
    /// <summary>
    /// Mathematical object for cubic Bzier curve definition.
    /// It is made of two spline nodes which hold the four needed control points : two positions and two directions
    /// It provides methods to get positions and tangent along the curve, specifying a distance or a ratio, plus the curve length.
    /// 
    /// Note that a time of 0.5 and half the total distance won't necessarily define the same curve point as the curve curvature is not linear.
    /// </summary>
    [Serializable]
    public class CubicBezierCurve {

        private const int STEP_COUNT = 30;
        private const float T_STEP = 1.0f / STEP_COUNT;

        private readonly List<CurveSample> samples = new List<CurveSample>(STEP_COUNT);

        public SplineNode n1, n2;

        /// <summary>
        /// Length of the curve in world unit.
        /// </summary>
        public float Length { get; private set; }

        /// <summary>
        /// This event is raised when of of the control points has moved.
        /// </summary>
        public UnityEvent Changed = new UnityEvent();

        /// <summary>
        /// Build a new cubic Bzier curve between two given spline node.
        /// </summary>
        /// <param name="n1"></param>
        /// <param name="n2"></param>
        public CubicBezierCurve(SplineNode n1, SplineNode n2) {
            this.n1 = n1;
            this.n2 = n2;
            n1.Changed += ComputeSamples;
            n2.Changed += ComputeSamples;
            ComputeSamples(null, null);
        }

        /// <summary>
        /// Change the start node of the curve.
        /// </summary>
        /// <param name="n1"></param>
        public void ConnectStart(SplineNode n1) {
            this.n1.Changed -= ComputeSamples;
            this.n1 = n1;
            n1.Changed += ComputeSamples;
            ComputeSamples(null, null);
        }

        /// <summary>
        /// Change the end node of the curve.
        /// </summary>
        /// <param name="n2"></param>
        public void ConnectEnd(SplineNode n2) {
            this.n2.Changed -= ComputeSamples;
            this.n2 = n2;
            n2.Changed += ComputeSamples;
            ComputeSamples(null, null);
        }

        /// <summary>
        /// Convinent method to get the third control point of the curve, as the direction of the end spline node indicates the starting tangent of the next curve.
        /// </summary>
        /// <returns></returns>
        public Vector3 GetInverseDirection() {
            return (2 * n2.Position) - n2.Direction;
        }

        /// <summary>
        /// Returns point on curve at given time. Time must be between 0 and 1.
        /// </summary>
        /// <param name="t"></param>
        /// <returns></returns>
        private Vector3 GetLocation(float t) {
            float omt = 1f - t;
            float omt2 = omt * omt;
            float t2 = t * t;
            return
                n1.Position * (omt2 * omt) +
                n1.Direction * (3f * omt2 * t) +
                GetInverseDirection() * (3f * omt * t2) +
                n2.Position * (t2 * t);
        }

        /// <summary>
        /// Returns tangent of curve at given time. Time must be between 0 and 1.
        /// </summary>
        /// <param name="t"></param>
        /// <returns></returns>
        private Vector3 GetTangent(float t) {
            float omt = 1f - t;
            float omt2 = omt * omt;
            float t2 = t * t;
            Vector3 tangent =
                n1.Position * (-omt2) +
                n1.Direction * (3 * omt2 - 2 * omt) +
                GetInverseDirection() * (-3 * t2 + 2 * t) +
                n2.Position * (t2);
            return tangent.normalized;
        }

        private Vector3 GetUp(float t) {
            return Vector3.Lerp(n1.Up, n2.Up, t);
        }

        private Vector2 GetScale(float t) {
            return Vector2.Lerp(n1.Scale, n2.Scale, t);
        }

        private float GetRoll(float t) {
            return Mathf.Lerp(n1.Roll, n2.Roll, t);
        }

        private void ComputeSamples(object sender, EventArgs e) {
            samples.Clear();
            Length = 0;
            Vector3 previousPosition = GetLocation(0);
            for (float t = 0; t < 1; t += T_STEP) {
                Vector3 position = GetLocation(t);
                Length += Vector3.Distance(previousPosition, position);
                previousPosition = position;
                samples.Add(CreateSample(Length, t));
            }
            Length += Vector3.Distance(previousPosition, GetLocation(1));
            samples.Add(CreateSample(Length, 1));

            if (Changed != null) Changed.Invoke();
        }

        private CurveSample CreateSample(float distance, float time) {
            return new CurveSample(
                GetLocation(time),
                GetTangent(time),
                GetUp(time),
                GetScale(time),
                GetRoll(time),
                distance,
                time,
                this);
        }

        /// <summary>
        /// Returns an interpolated sample of the curve, containing all curve data at this time.
        /// </summary>
        /// <param name="time"></param>
        /// <returns></returns>
        public CurveSample GetSample(float time) {
            AssertTimeInBounds(time);
            CurveSample previous = samples[0];
            CurveSample next = default(CurveSample);
            bool found = false;
            foreach (CurveSample cp in samples) {
                if (cp.timeInCurve >= time) {
                    next = cp;
                    found = true;
                    break;
                }
                previous = cp;
            }
            if (!found) throw new Exception("Can't find curve samples.");
            float t = next == previous ? 0 : (time - previous.timeInCurve) / (next.timeInCurve - previous.timeInCurve);

            return CurveSample.Lerp(previous, next, t);
        }

        /// <summary>
        /// Returns an interpolated sample of the curve, containing all curve data at this distance.
        /// </summary>
        /// <param name="d"></param>
        /// <returns></returns>
        public CurveSample GetSampleAtDistance(float d) {
            if (d < 0 || d > Length)
                throw new ArgumentException("Distance must be positive and less than curve length. Length = " + Length + ", given distance was " + d);

            CurveSample previous = samples[0];
            CurveSample next = default(CurveSample);
            bool found = false;
            foreach (CurveSample cp in samples) {
                if (cp.distanceInCurve >= d) {
                    next = cp;
                    found = true;
                    break;
                }
                previous = cp;
            }
            if (!found) throw new Exception("Can't find curve samples.");
            float t = next == previous ? 0 : (d - previous.distanceInCurve) / (next.distanceInCurve - previous.distanceInCurve);

            return CurveSample.Lerp(previous, next, t);
        }

        private static void AssertTimeInBounds(float time) {
            if (time < 0 || time > 1) throw new ArgumentException("Time must be between 0 and 1 (was " + time + ").");
        }

        public CurveSample GetProjectionSample(Vector3 pointToProject) {
            float minSqrDistance = float.PositiveInfinity;
            int closestIndex = -1;
            int i = 0;
            foreach (var sample in samples) {
                float sqrDistance = (sample.location - pointToProject).sqrMagnitude;
                if (sqrDistance < minSqrDistance) {
                    minSqrDistance = sqrDistance;
                    closestIndex = i;
                }
                i++;
            }
            CurveSample previous, next;
            if(closestIndex == 0) {
                previous = samples[closestIndex];
                next = samples[closestIndex + 1];
            } else if(closestIndex == samples.Count - 1) {
                previous = samples[closestIndex - 1];
                next = samples[closestIndex];
            } else {
                var toPreviousSample = (pointToProject - samples[closestIndex - 1].location).sqrMagnitude;
                var toNextSample = (pointToProject - samples[closestIndex + 1].location).sqrMagnitude;
                if (toPreviousSample < toNextSample) {
                    previous = samples[closestIndex - 1];
                    next = samples[closestIndex];
                } else {
                    previous = samples[closestIndex];
                    next = samples[closestIndex + 1];
                }
            }

            var onCurve = Vector3.Project(pointToProject - previous.location, next.location - previous.location) + previous.location;
            var rate = (onCurve - previous.location).sqrMagnitude / (next.location - previous.location).sqrMagnitude;
            rate = Mathf.Clamp(rate, 0, 1);
            var result = CurveSample.Lerp(previous, next, rate);
            return result;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Bezier/CubicBezierCurve.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Bezier/CurveSample.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 50dca9a395f88c54e8349ccff19f097b
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace SplineMesh {
    /// <summary>
    /// Imutable class containing all data about a point on a cubic bezier curve.
    /// </summary>
    public struct CurveSample
    {
        public readonly Vector3 location;
        public readonly Vector3 tangent;
        public readonly Vector3 up;
        public readonly Vector2 scale;
        public readonly float roll;
        public readonly float distanceInCurve;
        public readonly float timeInCurve;
        public readonly CubicBezierCurve curve;

        private Quaternion rotation;

        /// <summary>
        /// Rotation is a look-at quaternion calculated from the tangent, roll and up vector. Mixing non zero roll and custom up vector is not advised.
        /// </summary>
        public Quaternion Rotation {
            get {
                if (rotation == Quaternion.identity) {
                    var upVector = Vector3.Cross(tangent, Vector3.Cross(Quaternion.AngleAxis(roll, Vector3.forward) * up, tangent).normalized);
                    rotation = Quaternion.LookRotation(tangent, upVector);
                }
                return rotation;
            }
        }

        public CurveSample(Vector3 location, Vector3 tangent, Vector3 up, Vector2 scale, float roll, float distanceInCurve, float timeInCurve, CubicBezierCurve curve) {
            this.location = location;
            this.tangent = tangent;
            this.up = up;
            this.roll = roll;
            this.scale = scale;
            this.distanceInCurve = distanceInCurve;
            this.timeInCurve = timeInCurve;
            this.curve = curve;
            rotation = Quaternion.identity;
        }

        public override bool Equals(object obj) {
            if (obj == null || GetType() != obj.GetType()) {
                return false;
            }
            CurveSample other = (CurveSample)obj;
            return location == other.location &&
                tangent == other.tangent &&
                up == other.up &&
                scale == other.scale &&
                roll == other.roll &&
                distanceInCurve == other.distanceInCurve &&
                timeInCurve == other.timeInCurve;

        }

        public override int GetHashCode() {
            return base.GetHashCode();
        }

        public static bool operator ==(CurveSample cs1, CurveSample cs2) {
            return cs1.Equals(cs2);
        }

        public static bool operator !=(CurveSample cs1, CurveSample cs2) {
            return !cs1.Equals(cs2);
        }

        /// <summary>
        /// Linearly interpolates between two curve samples.
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="t"></param>
        /// <returns></returns>
        public static CurveSample Lerp(CurveSample a, CurveSample b, float t) {
            return new CurveSample(
                Vector3.Lerp(a.location, b.location, t),
                Vector3.Lerp(a.tangent, b.tangent, t).normalized,
                Vector3.Lerp(a.up, b.up, t),
                Vector2.Lerp(a.scale, b.scale, t),
                Mathf.Lerp(a.roll, b.roll, t),
                Mathf.Lerp(a.distanceInCurve, b.distanceInCurve, t),
                Mathf.Lerp(a.timeInCurve, b.timeInCurve, t),
                a.curve);
        }

        public MeshVertex GetBent(MeshVertex vert) {
            var res = new MeshVertex(vert.position, vert.normal, vert.uv);

            // application of scale
            res.position = Vector3.Scale(res.position, new Vector3(0, scale.y, scale.x));

            // application of roll
            res.position = Quaternion.AngleAxis(roll, Vector3.right) * res.position;
            res.normal = Quaternion.AngleAxis(roll, Vector3.right) * res.normal;

            // reset X value
            res.position.x = 0;

            // application of the rotation + location
            Quaternion q = Rotation * Quaternion.Euler(0, -90, 0);
            res.position = q * res.position + location;
            res.normal = q * res.normal;
            return res;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Bezier/CurveSample.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Bezier/Spline.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1a85c5879d519aa4ab2ebbf42591149a
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using UnityEngine;
using UnityEngine.Events;

namespace SplineMesh {
    /// <summary>
    /// A curved line made of oriented nodes.
    /// Each segment is a cubic Bzier curve connected to spline nodes.
    /// It provides methods to get positions and tangent along the spline, specifying a distance or a ratio, plus the curve length.
    /// The spline and the nodes raise events each time something is changed.
    /// </summary>
    [DisallowMultipleComponent]
    [ExecuteInEditMode]
    public class Spline : MonoBehaviour {
        /// <summary>
        /// The spline nodes.
        /// Warning, this collection shouldn't be changed manualy. Use specific methods to add and remove nodes.
        /// It is public only for the user to enter exact values of position and direction in the inspector (and serialization purposes).
        /// </summary>
        public List<SplineNode> nodes = new List<SplineNode>();

        /// <summary>
        /// The generated curves. Should not be changed in any way, use nodes instead.
        /// </summary>
        [HideInInspector]
        public List<CubicBezierCurve> curves = new List<CubicBezierCurve>();

        /// <summary>
        /// The spline length in world units.
        /// </summary>
        public float Length;

        [SerializeField]
        private bool isLoop;

        public bool IsLoop {
            get { return isLoop; }
            set {
                isLoop = value;
                updateLoopBinding();
            }
        }

        /// <summary>
        /// Event raised when the node collection changes
        /// </summary>
        public event ListChangeHandler<SplineNode> NodeListChanged;

        /// <summary>
        /// Event raised when one of the curve changes.
        /// </summary>
        [HideInInspector]
        public UnityEvent CurveChanged = new UnityEvent();

        /// <summary>
        /// Clear the nodes and curves, then add two default nodes for the reset spline to be visible in editor.
        /// </summary>
        private void Reset() {
            nodes.Clear();
            curves.Clear();
            AddNode(new SplineNode(new Vector3(5, 0, 0), new Vector3(5, 0, -3)));
            AddNode(new SplineNode(new Vector3(10, 0, 0), new Vector3(10, 0, 3)));
            RaiseNodeListChanged(new ListChangedEventArgs<SplineNode>() {
                type = ListChangeType.clear
            });
            UpdateAfterCurveChanged();
        }

        private void OnEnable() {
            RefreshCurves();
        }

        public ReadOnlyCollection<CubicBezierCurve> GetCurves() {
            return curves.AsReadOnly();
        }

        private void RaiseNodeListChanged(ListChangedEventArgs<SplineNode> args) {
            if (NodeListChanged != null)
                NodeListChanged.Invoke(this, args);
        }

        private void UpdateAfterCurveChanged() {
            Length = 0;
            foreach (var curve in curves) {
                Length += curve.Length;
            }
            CurveChanged.Invoke();
        }

        /// <summary>
        /// Returns an interpolated sample of the spline, containing all curve data at this time.
        /// Time must be between 0 and the number of nodes.
        /// </summary>
        /// <param name="t"></param>
        /// <returns></returns>
        public CurveSample GetSample(float t) {
            int index = GetNodeIndexForTime(t);
            return curves[index].GetSample(t - index);
        }

        /// <summary>
        /// Returns the curve at the given time.
        /// Time must be between 0 and the number of nodes.
        /// </summary>
        /// <param name="t"></param>
        /// <returns></returns>
        public CubicBezierCurve GetCurve(float t) {
            return curves[GetNodeIndexForTime(t)];
        }

        private int GetNodeIndexForTime(float t) {
            if (t < 0 || t > nodes.Count - 1) {
                throw new ArgumentException(string.Format("Time must be between 0 and last node index ({0}). Given time was {1}.", nodes.Count - 1, t));
            }
            int res = Mathf.FloorToInt(t);
            if (res == nodes.Count - 1)
                res--;
            return res;
        }
		
	/// <summary>
	/// Refreshes the spline's internal list of curves.
	// </summary>
	public void RefreshCurves() {
            curves.Clear();
            for (int i = 0; i < nodes.Count - 1; i++) {
                SplineNode n = nodes[i];
                SplineNode next = nodes[i + 1];

                CubicBezierCurve curve = new CubicBezierCurve(n, next);
                curve.Changed.AddListener(UpdateAfterCurveChanged);
                curves.Add(curve);
            }
            RaiseNodeListChanged(new ListChangedEventArgs<SplineNode>() {
                type = ListChangeType.clear
            });
            UpdateAfterCurveChanged();
        }

        /// <summary>
        /// Returns an interpolated sample of the spline, containing all curve data at this distance.
        /// Distance must be between 0 and the spline length.
        /// </summary>
        /// <param name="d"></param>
        /// <returns></returns>
        public CurveSample GetSampleAtDistance(float d) {
            if (d < 0 || d > Length)
                throw new ArgumentException(string.Format("Distance must be between 0 and spline length ({0}). Given distance was {1}.", Length, d));
            foreach (CubicBezierCurve curve in curves) {
                // test if distance is approximatly equals to curve length, because spline
                // length may be greater than cumulated curve length due to float precision
                if(d > curve.Length && d < curve.Length + 0.0001f) {
                    d = curve.Length;
                }
                if (d > curve.Length) {
                    d -= curve.Length;
                } else {
                    return curve.GetSampleAtDistance(d);
                }
            }
            throw new Exception("Something went wrong with GetSampleAtDistance.");
        }

        /// <summary>
        /// Adds a node at the end of the spline.
        /// </summary>
        /// <param name="node"></param>
        public void AddNode(SplineNode node) {
            nodes.Add(node);
            if (nodes.Count != 1) {
                SplineNode previousNode = nodes[nodes.IndexOf(node) - 1];
                CubicBezierCurve curve = new CubicBezierCurve(previousNode, node);
                curve.Changed.AddListener(UpdateAfterCurveChanged);
                curves.Add(curve);
            }
            RaiseNodeListChanged(new ListChangedEventArgs<SplineNode>() {
                type = ListChangeType.Add,
                newItems = new List<SplineNode>() { node }
            });

            UpdateAfterCurveChanged();
            updateLoopBinding();
        }

        /// <summary>
        /// Insert the given node in the spline at index. Index must be greater than 0 and less than node count.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="node"></param>
        public void InsertNode(int index, SplineNode node) {
            if (index == 0)
                throw new Exception("Can't insert a node at index 0");

            SplineNode previousNode = nodes[index - 1];
            SplineNode nextNode = nodes[index];

            nodes.Insert(index, node);

            curves[index - 1].ConnectEnd(node);

            CubicBezierCurve curve = new CubicBezierCurve(node, nextNode);
            curve.Changed.AddListener(UpdateAfterCurveChanged);
            curves.Insert(index, curve);
            RaiseNodeListChanged(new ListChangedEventArgs<SplineNode>() {
                type = ListChangeType.Insert,
                newItems = new List<SplineNode>() { node },
                insertIndex = index
            });
            UpdateAfterCurveChanged();
            updateLoopBinding();
        }

        /// <summary>
        /// Remove the given node from the spline. The given node must exist and the spline must have more than 2 nodes.
        /// </summary>
        /// <param name="node"></param>
        public void RemoveNode(SplineNode node) {
            int index = nodes.IndexOf(node);

            if (nodes.Count <= 2) {
                throw new Exception("Can't remove the node because a spline needs at least 2 nodes.");
            }

            CubicBezierCurve toRemove = index == nodes.Count - 1 ? curves[index - 1] : curves[index];
            if (index != 0 && index != nodes.Count - 1) {
                SplineNode nextNode = nodes[index + 1];
                curves[index - 1].ConnectEnd(nextNode);
            }

            nodes.RemoveAt(index);
            toRemove.Changed.RemoveListener(UpdateAfterCurveChanged);
            curves.Remove(toRemove);

            RaiseNodeListChanged(new ListChangedEventArgs<SplineNode>() {
                type = ListChangeType.Remove,
                removedItems = new List<SplineNode>() { node },
                removeIndex = index
            });
            UpdateAfterCurveChanged();
            updateLoopBinding();
        }

        SplineNode start, end;
        private void updateLoopBinding() {
            if(start != null) {
                start.Changed -= StartNodeChanged;
            }
            if(end != null) {
                end.Changed -= EndNodeChanged;
            }
            if (isLoop) {
                start = nodes[0];
                end = nodes[nodes.Count - 1];
                start.Changed += StartNodeChanged;
                end.Changed += EndNodeChanged;
                StartNodeChanged(null, null);
            } else {
                start = null;
                end = null;
            }
        }

        private void StartNodeChanged(object sender, EventArgs e) {
            end.Changed -= EndNodeChanged;
            end.Position = start.Position;
            end.Direction = start.Direction;
            end.Roll = start.Roll;
            end.Scale = start.Scale;
            end.Up = start.Up;
            end.Changed += EndNodeChanged;
        }

        private void EndNodeChanged(object sender, EventArgs e) {
            start.Changed -= StartNodeChanged;
            start.Position = end.Position;
            start.Direction = end.Direction;
            start.Roll = end.Roll;
            start.Scale = end.Scale;
            start.Up = end.Up;
            start.Changed += StartNodeChanged;
        }

        public CurveSample GetProjectionSample(Vector3 pointToProject) {
            CurveSample closest = default(CurveSample);
            float minSqrDistance = float.MaxValue;
            foreach (var curve in curves) {
                var projection = curve.GetProjectionSample(pointToProject);
                if (curve == curves[0]) {
                    closest = projection;
                    minSqrDistance = (projection.location - pointToProject).sqrMagnitude;
                    continue;
                }
                var sqrDist = (projection.location - pointToProject).sqrMagnitude;
                if (sqrDist < minSqrDistance) {
                    minSqrDistance = sqrDist;
                    closest = projection;
                }
            }
            return closest;
        }
    }

    public enum ListChangeType {
        Add,
        Insert,
        Remove,
        clear,
    }
    public class ListChangedEventArgs<T> : EventArgs {
        public ListChangeType type;
        public List<T> newItems;
        public List<T> removedItems;
        public int insertIndex, removeIndex;
    }
    public delegate void ListChangeHandler<T2>(object sender, ListChangedEventArgs<T2> args);

}
# --- end Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Bezier/Spline.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Bezier/SplineNode.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1fcdfb895c0d3cd409b1f79c2c9ff09b
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace SplineMesh {
    /// <summary>
    /// Spline node storing a position and a direction (tangent).
    /// Note : you shouldn't modify position and direction manualy but use dedicated methods instead, to insure event raising.
    /// </summary>
    [Serializable]
    public class SplineNode {

        /// <summary>
        /// Node position
        /// </summary>
        public Vector3 Position {
            get { return position; }
            set {
                if (position.Equals(value)) return;
                position.x = value.x;
                position.y = value.y;
                position.z = value.z;
                if(Changed != null) Changed(this, EventArgs.Empty);
            }
        }
        [SerializeField]
        private Vector3 position;

        /// <summary>
        /// Node direction
        /// </summary>
        public Vector3 Direction {
            get { return direction; }
            set {
                if (direction.Equals(value)) return;
                direction.x = value.x;
                direction.y = value.y;
                direction.z = value.z;
                if (Changed != null) Changed(this, EventArgs.Empty);
            }
        }
        [SerializeField]
        private Vector3 direction;

        /// <summary>
        /// Up vector to apply at this node.
        /// Usefull to specify the orientation when the tangent blend with the world UP (gimball lock)
        /// This value is not used on the spline itself but is commonly used on bended content.
        /// </summary>
        public Vector3 Up {
            get { return up; }
            set {
                if (up.Equals(value)) return;
                up.x = value.x;
                up.y = value.y;
                up.z = value.z;
                if (Changed != null) Changed(this, EventArgs.Empty);
            }
        }
        [SerializeField]
        private Vector3 up = Vector3.up;

        /// <summary>
        /// Scale to apply at this node.
        /// This value is not used on the spline itself but is commonly used on bended content.
        /// </summary>
        public Vector2 Scale {
            get { return scale; }
            set {
                if (scale.Equals(value)) return;
                scale.x = value.x;
                scale.y = value.y;
                if (Changed != null) Changed(this, EventArgs.Empty);
            }
        }
        [SerializeField]
        private Vector2 scale = Vector2.one;

        /// <summary>
        /// Roll to apply at this node.
        /// This value is not used on the spline itself but is commonly used on bended content.
        /// </summary>
        public float Roll {
            get { return roll; }
            set {
                if (roll == value) return;
                roll = value;
                if (Changed != null) Changed(this, EventArgs.Empty);
            }
        }
        [SerializeField]
        private float roll;

        public SplineNode(Vector3 position, Vector3 direction) {
            Position = position;
            Direction = direction;
        }

        /// <summary>
        /// Event raised when position, direction, scale or roll changes.
        /// </summary>
        [HideInInspector]
        public event EventHandler Changed;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Bezier/SplineNode.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Bezier/SplineSmoother.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c3c62baecdb58fe4583d8f8283102e76
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using UnityEngine;
using UnityEngine.Events;

namespace SplineMesh {
    [DisallowMultipleComponent]
    [ExecuteInEditMode]
    [RequireComponent(typeof(Spline))]
    public class SplineSmoother : MonoBehaviour {
        private Spline spline;
        private Spline Spline {
            get {
                if (spline == null) spline = GetComponent<Spline>();
                return spline;
            }
        }

        [Range(0, 1f)] public float curvature = 0.3f;

        private void OnValidate() {
            SmoothAll();
        }

        private void OnEnable() {
            Spline.NodeListChanged += Spline_NodeListChanged;
            foreach(var node in Spline.nodes) {
                node.Changed += OnNodeChanged;
            }
            SmoothAll();
        }

        private void OnDisable() {
            Spline.NodeListChanged -= Spline_NodeListChanged;
            foreach (var node in Spline.nodes) {
                node.Changed -= OnNodeChanged;
            }
        }

        private void Spline_NodeListChanged(object sender, ListChangedEventArgs<SplineNode> args) {
            if(args.newItems != null) {
                foreach (var node in args.newItems) {
                    node.Changed += OnNodeChanged;
                }
            }
            if(args.removedItems != null) {
                foreach (var node in args.removedItems) {
                    node.Changed -= OnNodeChanged;
                }
            }
        }

        private void OnNodeChanged(object sender, EventArgs e) {
            var node = (SplineNode)sender;
            SmoothNode(node);
            var index = Spline.nodes.IndexOf(node);
            if(index > 0) {
                SmoothNode(Spline.nodes[index - 1]);
            }
            if(index < Spline.nodes.Count - 1) {
                SmoothNode(Spline.nodes[index + 1]);

            }
        }

        private void SmoothNode(SplineNode node) {
            var index = Spline.nodes.IndexOf(node);
            var pos = node.Position;
            // For the direction, we need to compute a smooth vector.
            // Orientation is obtained by substracting the vectors to the previous and next way points,
            // which give an acceptable tangent in most situations.
            // Then we apply a part of the average magnitude of these two vectors, according to the smoothness we want.
            var dir = Vector3.zero;
            float averageMagnitude = 0;
            if (index != 0) {
                var previousPos = Spline.nodes[index - 1].Position;
                var toPrevious = pos - previousPos;
                averageMagnitude += toPrevious.magnitude;
                dir += toPrevious.normalized;
            }
            if (index != Spline.nodes.Count - 1) {
                var nextPos = Spline.nodes[index + 1].Position;
                var toNext = pos - nextPos;
                averageMagnitude += toNext.magnitude;
                dir -= toNext.normalized;
            }
            averageMagnitude *= 0.5f;
            // This constant should vary between 0 and 0.5, and allows to add more or less smoothness.
            dir = dir.normalized * averageMagnitude * curvature;

            // In SplineMesh, the node direction is not relative to the node position. 
            var controlPoint = dir + pos;

            // We only set one direction at each spline node because SplineMesh only support mirrored direction between curves.
            node.Direction = controlPoint;
        }


        private void SmoothAll() {
            foreach(var node in Spline.nodes) {
                SmoothNode(node);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Bezier/SplineSmoother.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Example/ExampleContortAlong.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3d306cefadf2ceb47a68968ad99b781f
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace SplineMesh {
    /// <summary>
    /// Example of component to show the deformation of a mesh in a changing
    /// interval in spline space.
    /// 
    /// This component is only for demo purpose and is not intended to be used as-is.
    /// </summary>
    [ExecuteInEditMode]
    [RequireComponent(typeof(Spline))]
    public class ExampleContortAlong : MonoBehaviour {
        private Spline spline;
        private float rate = 0;
        private MeshBender meshBender;

        [HideInInspector]
        public GameObject generated;

        public Mesh mesh;
        public Material material;
        public Vector3 rotation;
        public Vector3 scale;

        public float DurationInSecond;

        private void OnEnable() {
            rate = 0;
            Init();
#if UNITY_EDITOR
            EditorApplication.update += EditorUpdate;
#endif
        }

        void OnDisable() {
#if UNITY_EDITOR
            EditorApplication.update -= EditorUpdate;
#endif
        }

        private void OnValidate() {
            Init();
        }

        void EditorUpdate() {
            rate += Time.deltaTime / DurationInSecond;
            if (rate > 1) {
                rate --;
            }
            Contort();
        }

        private void Contort() {
            if (generated != null) {
                meshBender.SetInterval(spline, spline.Length * rate);
                meshBender.ComputeIfNeeded();
            }
        }

        private void Init() {
            string generatedName = "generated by " + GetType().Name;
            var generatedTranform = transform.Find(generatedName);
            generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject,
                typeof(MeshFilter),
                typeof(MeshRenderer),
                typeof(MeshBender));

            generated.GetComponent<MeshRenderer>().material = material;

            meshBender = generated.GetComponent<MeshBender>();
            spline = GetComponent<Spline>();

            meshBender.Source = SourceMesh.Build(mesh)
                .Rotate(Quaternion.Euler(rotation))
                .Scale(scale);
            meshBender.Mode = MeshBender.FillingMode.Once;
            meshBender.SetInterval(spline, 0);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Example/ExampleContortAlong.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Example/ExampleFollowSpline.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 371753988c008004ca1da9ce435ba75b
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace SplineMesh {
    /// <summary>
    /// Example of component to show that the spline is an independant mathematical component and can be used for other purposes than mesh deformation.
    /// 
    /// This component is only for demo purpose and is not intended to be used as-is.
    /// 
    /// We only move an object along the spline. Imagine a camera route, a ship patrol...
    /// </summary>
    [ExecuteInEditMode]
    [RequireComponent(typeof(Spline))]
    public class ExampleFollowSpline : MonoBehaviour {
        private GameObject generated;
        private Spline spline;
        private float rate = 0;

        public GameObject Follower;
        public float DurationInSecond;

        private void OnEnable() {
            rate = 0;
            string generatedName = "generated by " + GetType().Name;
            var generatedTranform = transform.Find(generatedName);
            generated = generatedTranform != null ? generatedTranform.gameObject : Instantiate(Follower, gameObject.transform);
            generated.name = generatedName;

            spline = GetComponent<Spline>(); 
#if UNITY_EDITOR
            EditorApplication.update += EditorUpdate;
#endif
        }

        void OnDisable() {
#if UNITY_EDITOR
            EditorApplication.update -= EditorUpdate;
#endif
        }

        void EditorUpdate() {
            rate += Time.deltaTime / DurationInSecond;
            if (rate > spline.nodes.Count - 1) {
                rate -= spline.nodes.Count - 1;
            }
            PlaceFollower();
        }

        private void PlaceFollower() {
            if (generated != null) {
                CurveSample sample = spline.GetSample(rate);
                generated.transform.localPosition = sample.location;
                generated.transform.localRotation = sample.Rotation;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Example/ExampleFollowSpline.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Example/ExampleGrowingRoot.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0509837adb1f3f6429965e5500c48b55
# ASMDEF: ldx.framework.runtime.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace SplineMesh {
    /// <summary>
    /// Example of component to show the deformation of the mesh on a changing
    /// interval and changing spline nodes.
    /// 
    /// In this example, as the MeshBender is working on spline space, it will update
    /// the mesh if one of the curve change. Each change make the MeshBender "dirty" and
    /// it will compute the mesh only once on it's next update call.
    /// 
    /// This component is only for demo purpose and is not intended to be used as-is.
    /// </summary>
    [ExecuteInEditMode]
    [RequireComponent(typeof(Spline))]
    public class ExampleGrowingRoot : MonoBehaviour {
        private GameObject generated;
        private Spline spline;
        private float rate = 0;
        private MeshBender meshBender;

        public Mesh mesh;
        public Material material;
        public Vector3 rotation;
        public Vector3 scale;

        public float startScale = 1;

        public float DurationInSecond;

        private void OnEnable() {
            rate = 0;
            Init();
#if UNITY_EDITOR
            EditorApplication.update += EditorUpdate;
#endif
        }

        void OnDisable() {
#if UNITY_EDITOR
            EditorApplication.update -= EditorUpdate;
#endif
        }

        private void OnValidate() {
            Init();
        }

        private void Update() {
            EditorUpdate();
        }

        void EditorUpdate() {
            rate += Time.deltaTime / DurationInSecond;
            if (rate > 1) {
                rate --;
            }
            Contort();
        }

        private void Contort() {
            float nodeDistance = 0;
            int i = 0;
            foreach (var n in spline.nodes) {
                float nodeDistanceRate = nodeDistance / spline.Length;
                float nodeScale = startScale * (rate - nodeDistanceRate);
                n.Scale = new Vector2(nodeScale, nodeScale);
                if (i < spline.curves.Count) {
                    nodeDistance += spline.curves[i++].Length;
                }
            }

            if (generated != null) {
                meshBender.SetInterval(spline, 0, spline.Length * rate);
                meshBender.ComputeIfNeeded();
            }
        }

        private void Init() {
            string generatedName = "generated by " + GetType().Name;
            var generatedTranform = transform.Find(generatedName);
            generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject,
                typeof(MeshFilter),
                typeof(MeshRenderer),
                typeof(MeshBender));

            generated.GetComponent<MeshRenderer>().material = material;

            meshBender = generated.GetComponent<MeshBender>();
            spline = GetComponent<Spline>();

            meshBender.Source = SourceMesh.Build(mesh)
                .Rotate(Quaternion.Euler(rotation))
                .Scale(scale);
            meshBender.Mode = MeshBender.FillingMode.StretchToInterval;
            meshBender.SetInterval(spline, 0, 0.01f);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Example/ExampleGrowingRoot.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Example/ExampleSower.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 67bc80d4c1c799346b57921fb3aaeeeb
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace SplineMesh {
    /// <summary>
    /// Example of component to places assets along a spline. This component can be used as-is but will most likely be a base for your own component.
    /// 
    /// In this example, the user gives the prefab to place, a spacing value between two placements, the prefab scale and an horizontal offset to the spline.
    /// These three last values have an additional range, allowing to add some randomness. for each placement, the computed value will be between value and value+range.
    /// 
    /// Prefabs are placed from the start of the spline at computed spacing, unitl there is no lentgh remaining. Prefabs are stored, destroyed
    /// and built again each time the spline or one of its curves change.
    /// 
    /// A random seed is used to obtain the same random numbers at each update. The user can specify the seed to test some other random number set.
    /// 
    /// Place prefab along a spline and deform it easily have a lot of usages if you have some imagination : 
    ///  - place trees along a road
    ///  - create a rocky bridge
    ///  - create a footstep track with decals
    ///  - create a path of firefly in the dark
    ///  - create a natural wall with overlapping rocks
    ///  - etc.
    /// </summary>
    [ExecuteInEditMode]
    [SelectionBase]
    [DisallowMultipleComponent]
    public class ExampleSower : MonoBehaviour {
        private GameObject generated;
        private Spline spline = null;
        private bool toUpdate = true;

        public GameObject prefab = null;
        public float scale = 1, scaleRange = 0;
        public float spacing = 1, spacingRange = 0;
        public float offset = 0, offsetRange = 0;
        public bool isRandomYaw = false;
        public int randomSeed = 0;

        private void OnEnable() {
            string generatedName = "generated by "+GetType().Name;
            var generatedTranform = transform.Find(generatedName);
            generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);

            spline = GetComponentInParent<Spline>();
            spline.NodeListChanged += (s, e) => {
                toUpdate = true;
                foreach (CubicBezierCurve curve in spline.GetCurves()) {
                    curve.Changed.AddListener(() => toUpdate = true);
                }
            };
            foreach (CubicBezierCurve curve in spline.GetCurves()) {
                curve.Changed.AddListener(() => toUpdate = true);
            }
        }

        private void OnValidate() {
            toUpdate = true;
        }

        private void Update() {
            if (toUpdate) {
                Sow();
                toUpdate = false;
            }
        }

        public void Sow() {
            UOUtility.DestroyChildren(generated);

            UnityEngine.Random.InitState(randomSeed);
            if (spacing + spacingRange <= 0 ||
                prefab == null)
                return;

            float distance = 0;
            while (distance <= spline.Length) {
                CurveSample sample = spline.GetSampleAtDistance(distance);

                GameObject go;
                go = Instantiate(prefab, generated.transform);
                go.transform.localRotation = Quaternion.identity;
                go.transform.localPosition = Vector3.zero;
                go.transform.localScale = Vector3.one;

                // move along spline, according to spacing + random
                go.transform.localPosition = sample.location;
                // apply scale + random
                float rangedScale = scale + UnityEngine.Random.Range(0, scaleRange);
                go.transform.localScale = new Vector3(rangedScale, rangedScale, rangedScale);
                // rotate with random yaw
                if (isRandomYaw) {
                    go.transform.Rotate(0, 0, UnityEngine.Random.Range(-180, 180));
                } else {
                    go.transform.rotation = sample.Rotation;
                }
                // move orthogonaly to the spline, according to offset + random
                var binormal = (Quaternion.LookRotation(sample.tangent, sample.up) * Vector3.right).normalized;
                var localOffset = offset + UnityEngine.Random.Range(0, offsetRange * Math.Sign(offset));
                localOffset *=  sample.scale.x;
                binormal *= localOffset;
                go.transform.position += binormal;

                distance += spacing + UnityEngine.Random.Range(0, spacingRange);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Example/ExampleSower.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Example/ExampleTentacle.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 24d1b6e1e070eb14fa89607942b123cf
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace SplineMesh {
    /// <summary>
    /// Example of component to bend a mesh along a spline with some interpolation of scales and rolls. This component can be used as-is but will most likely be a base for your own component.
    /// 
    /// For explanations of the base component, <see cref="ExamplePipe"/>
    /// 
    /// In this component, we have added properties to make scale and roll vary between spline start and end.
    /// Intermediate scale and roll values are calculated at each spline node accordingly to the distance, then given to the MeshBenders component.
    /// MeshBender applies scales and rolls values by interpollation if they differ from strat to end of the curve.
    /// 
    /// You can easily imagine a list of scales to apply to each node independantly to create your own variation.
    /// </summary>
    [DisallowMultipleComponent]
    public class ExampleTentacle : MonoBehaviour {
        private Spline spline { get => GetComponent<Spline>(); }

        public float startScale = 1, endScale = 1;
        public float startRoll = 0, endRoll = 0;

        private void OnValidate() {
            // apply scale and roll at each node
            float currentLength = 0;
            foreach (CubicBezierCurve curve in spline.GetCurves()) {
                float startRate = currentLength / spline.Length;
                currentLength += curve.Length;
                float endRate = currentLength / spline.Length;

                curve.n1.Scale = Vector2.one * (startScale + (endScale - startScale) * startRate);
                curve.n2.Scale = Vector2.one * (startScale + (endScale - startScale) * endRate);

                curve.n1.Roll = startRoll + (endRoll - startRoll) * startRate;
                curve.n2.Roll = startRoll + (endRoll - startRoll) * endRate;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Example/ExampleTentacle.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Example/ExampleTrack.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: da5789f52fd48f54fb21c95bd79108e0
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace SplineMesh {
    /// <summary>
    /// Example of component to bend many meshes along a spline. This component can be used as-is but will most likely be a base for your own component.
    /// 
    /// This is a more advanced and real-life SplineMesh component. Use it as a source of inspiration.
    /// 
    /// In this script, you will learn to : 
    ///  - preserve baked lightmap when entering playmode,
    ///  - better manage the generated content life cycle to avoid useless calculations
    ///  - create data class to produce richer content along your spline
    ///  
    /// This is the most complete Example provided in the asset. For further help, information and ideas, please visit
    /// the officiel thread on Unity forum.
    /// 
    /// And if you like SplineMesh, please review it on the asset store !
    /// 
    /// Now you should be able to bend the world to your will.
    /// 
    /// Have fun with SplineMesh !
    /// 
    /// </summary>
    [ExecuteInEditMode]
    [SelectionBase]
    [DisallowMultipleComponent]
    public class ExampleTrack : MonoBehaviour {
        private GameObject generated;
        private Spline spline = null;
        private bool toUpdate = false;

        /// <summary>
        /// A list of object that are storing data for each segment of the curve.
        /// </summary>
        public List<TrackSegment> segments = new List<TrackSegment>();

        /// <summary>
        /// If true, the generated content will be updated in play mode.
        /// If false, the content generated and saved to the scene will be used in playmode without modification.
        /// Usefull to preserve lightmaps baked for static objects.
        /// </summary>
        public bool updateInPlayMode;

        private void OnEnable() {
            string generatedName = "generated by " + GetType().Name;
            var generatedTranform = transform.Find(generatedName);
            generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);

            spline = GetComponentInParent<Spline>();

            // we listen changes in the spline's node list and we update the list of segment accordingly
            // this way, if we insert a node between two others, a segment will be inserted too and the data won't shift
            while (segments.Count < spline.nodes.Count) {
                segments.Add(new TrackSegment());
            }
            while (segments.Count > spline.nodes.Count) {
                segments.RemoveAt(segments.Count - 1);
            }
            spline.NodeListChanged += (s, e) => {
                switch (e.type) {
                    case ListChangeType.Add:
                        segments.Add(new TrackSegment());
                        break;
                    case ListChangeType.Remove:
                        segments.RemoveAt(e.removeIndex);
                        break;
                    case ListChangeType.Insert:
                        segments.Insert(e.insertIndex, new TrackSegment());
                        break;
                }
                toUpdate = true;
            };
            toUpdate = true;
        }

        private void OnValidate() {
            if (spline == null) return;
            toUpdate = true;
        }

        private void Update() {
            // we can prevent the generated content to be updated during playmode to preserve baked data saved in the scene
            if (!updateInPlayMode && Application.isPlaying) return;

            if (toUpdate) {
                toUpdate = false;
                CreateMeshes();
            }
        }

        public void CreateMeshes() {
            List<GameObject> used = new List<GameObject>();

            for (int i = 0; i < spline.GetCurves().Count; i++) {
                var curve = spline.GetCurves()[i];
                foreach (var tm in segments[i].transformedMeshes) {
                    if (tm.mesh == null) {
                        // if there is no mesh specified for this segment, we ignore it.
                        continue;
                    }

                    // we try to find a game object previously generated. this avoids destroying/creating
                    // game objects at each update, wich is faster.
                    var childName = "segment " + i + " mesh " + segments[i].transformedMeshes.IndexOf(tm);
                    var childTransform = generated.transform.Find(childName);
                    GameObject go;
                    if (childTransform == null) {
                        go = UOUtility.Create(childName,
                            generated,
                            typeof(MeshFilter),
                            typeof(MeshRenderer),
                            typeof(MeshBender),
                            typeof(MeshCollider));
                        go.isStatic = true;
                    } else {
                        go = childTransform.gameObject;
                    }
                    go.GetComponent<MeshRenderer>().material = tm.material;
                    go.GetComponent<MeshCollider>().material = tm.physicMaterial;

                    // we update the data in the bender. It will decide itself if the bending must be recalculated.
                    MeshBender mb = go.GetComponent<MeshBender>();
                    mb.Source = SourceMesh.Build(tm.mesh)
                        .Translate(tm.translation)
                        .Rotate(Quaternion.Euler(tm.rotation))
                        .Scale(tm.scale);
                    mb.SetInterval(curve);
                    mb.ComputeIfNeeded();
                    used.Add(go);
                }
            }

            // finally, we destroy the unused objects
            foreach (var go in generated.transform
                .Cast<Transform>()
                .Select(child => child.gameObject).Except(used)) {
                UOUtility.Destroy(go);
            }
        }
    }

    /// <summary>
    /// This class store any data associated with a spline segment.
    /// In this example, a list of meshes.
    /// It is intended to be edited in the inspector.
    /// </summary>
    [Serializable]
    public class TrackSegment {
        public List<TransformedMesh> transformedMeshes = new List<TransformedMesh>();
    }

    /// <summary>
    /// This class stores all needed data to represent a mesh in situation.
    /// It is intended to be edited in the inspector.
    /// </summary>
    [Serializable]
    public class TransformedMesh {
        public TransformedMesh() {
            scale = Vector3.one;
        }
        public Mesh mesh;
        public Material material;
        public PhysicsMaterial physicMaterial;
        public Vector3 translation;
        public Vector3 rotation;
        public Vector3 scale = Vector3.one;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Example/ExampleTrack.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Example/RopeBuilder.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 527bc1a47e91189469f521ea197a5f6c
# ASMDEF: ldx.framework.runtime.dll
# ---
using SplineMesh;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace SplineMesh {
    [ExecuteInEditMode]
    [RequireComponent(typeof(Spline))]
    public class RopeBuilder : MonoBehaviour {
        private bool toUpdate = false;
        private GameObject generated;
        private GameObject Generated {
            get {
                if (generated == null) {
                    string generatedName = "generated by " + GetType().Name;
                    var generatedTranform = transform.Find(generatedName);
                    generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);
                }
                return generated;
            }
        }

        private Spline spline;
        private GameObject firstSegment;

        [SerializeField]
        public List<GameObject> wayPoints = new List<GameObject>();

        public GameObject segmentPrefab;
        public int segmentCount;
        public float segmentSpacing;

        private void OnEnable() {
            spline = GetComponent<Spline>();
            toUpdate = true;
        }

        private void OnValidate() {
            toUpdate = true;
        }

        private void Update() {
            if (toUpdate) {
                toUpdate = false;
                Generate();
                UpdateSpline();
            }
            UpdateNodes();

            // balancing
            if (Application.isPlaying) {
                firstSegment.transform.localPosition = new Vector3(Mathf.Sin(Time.time) * 3, 0, 0);
            }
        }

        private void UpdateNodes() {
            int i = 0;
            foreach (GameObject wayPoint in wayPoints) {
                var node = spline.nodes[i++];
                if (Vector3.Distance(node.Position, transform.InverseTransformPoint(wayPoint.transform.position)) > 0.001f) {
                    node.Position = transform.InverseTransformPoint(wayPoint.transform.position);
                    node.Up = wayPoint.transform.up;
                }
            }
        }

        private void UpdateSpline() {
            foreach (var penisNode in wayPoints.ToList()) {
                if (penisNode == null) wayPoints.Remove(penisNode);
            }
            int nodeCount = wayPoints.Count;
            // adjust the number of nodes in the spline.
            while (spline.nodes.Count < nodeCount) {
                spline.AddNode(new SplineNode(Vector3.zero, Vector3.zero));
            }
            while (spline.nodes.Count > nodeCount && spline.nodes.Count > 2) {
                spline.RemoveNode(spline.nodes.Last());
            }
        }

        private void Generate() {
            UOUtility.DestroyChildren(Generated);
            wayPoints.Clear();

            float localSpacing = 0;
            Joint joint = null;
            for (int i = 0; i < segmentCount; i++) {
                var seg = UOUtility.Instantiate(segmentPrefab, Generated.transform);
                seg.transform.Translate(0, 0, localSpacing);

                var segRB = seg.GetComponent<Rigidbody>();
                // we fix the first segment so that the rope won't fall
                if (i == 0) {
                    firstSegment = seg;
                    segRB.constraints = RigidbodyConstraints.FreezePosition;
                }

                // we attach the rigidbody to the joint of the previous segment
                if (joint != null) {
                    joint.connectedBody = segRB;
                }
                joint = seg.GetComponent<Joint>();

                // we save segments as way points for the spline deformation.
                wayPoints.Add(seg);
                localSpacing += segmentSpacing;
            }
            UOUtility.Destroy(joint);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Example/RopeBuilder.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/MeshProcessing/ExtrusionSegment.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 67dc87f5a664ca14d9492006284bbca2
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace SplineMesh {
    [ExecuteInEditMode]
    [DisallowMultipleComponent]
    [RequireComponent(typeof(MeshFilter))]
    [RequireComponent(typeof(MeshRenderer))]
    public class ExtrusionSegment : MonoBehaviour {
        private bool isDirty = false;

        private MeshFilter mf;
        private Mesh result;

        private bool useSpline = false;
        private CubicBezierCurve curve;
        private Spline spline;
        private float intervalStart, intervalEnd;

        private List<Vertex> shapeVertices = new List<Vertex>();
        /// <summary>
        /// 
        /// </summary>
        public List<Vertex> ShapeVertices {
            get { return shapeVertices; }
            set {
                if (value == shapeVertices) return;
                SetDirty();
                shapeVertices = value;
            }
        }

        private float textureScale = 1;
        /// <summary>
        /// 
        /// </summary>
        public float TextureScale {
            get { return textureScale; }
            set {
                if (value == textureScale) return;
                SetDirty();
                textureScale = value;
            }
        }

        private float textureOffset = 0;
        /// <summary>
        /// 
        /// </summary>
        public float TextureOffset {
            get { return textureOffset; }
            set {
                if (value == textureOffset) return;
                SetDirty();
                textureOffset = value;
            }
        }

        private float sampleSpacing = 0.1f;
        /// <summary>
        /// 
        /// </summary>
        public float SampleSpacing {
            get { return sampleSpacing; }
            set {
                if (value == sampleSpacing) return;
                if (value <= 0) throw new ArgumentOutOfRangeException("SampleSpacing", "Must be greater than 0");
                SetDirty();
                sampleSpacing = value;
            }
        }

        private void OnEnable() {
            mf = GetComponent<MeshFilter>();
            if (mf.sharedMesh == null) {
                mf.sharedMesh = new Mesh();
            }
        }

        /// <summary>
        /// Set the cubic Bzier curve to use to bend the source mesh, and begin to listen to curve control points for changes.
        /// </summary>
        /// <param name="curve"></param>
        /// <param name="update">If let to true, update the resulting mesh immediatly.</param>
        public void SetInterval(CubicBezierCurve curve) {
            if (this.curve == curve) return;
            if (curve == null) throw new ArgumentNullException("curve");

            if (this.curve != null) {
                this.curve.Changed.RemoveListener(SetDirty);
            }
            this.curve = curve;
            spline = null;
            curve.Changed.AddListener(SetDirty);
            useSpline = false;
            SetDirty();
        }

        public void SetInterval(Spline spline, float intervalStart, float intervalEnd = 0) {
            if (this.spline == spline && this.intervalStart == intervalStart && this.intervalEnd == intervalEnd) return;
            if (spline == null) throw new ArgumentNullException("spline");
            if (intervalStart < 0 || intervalStart >= spline.Length) {
                throw new ArgumentOutOfRangeException("interval start must be 0 or greater and lesser than spline length (was " + intervalStart + ")");
            }
            if (intervalEnd != 0 && intervalEnd <= intervalStart || intervalEnd > spline.Length) {
                throw new ArgumentOutOfRangeException("interval end must be 0 or greater than interval start, and lesser than spline length (was " + intervalEnd + ")");
            }
            if (this.spline != null) {
                // unlistening previous spline
                this.spline.CurveChanged.RemoveListener(SetDirty);
            }
            this.spline = spline;
            // listening new spline
            spline.CurveChanged.AddListener(SetDirty);

            curve = null;
            this.intervalStart = intervalStart;
            this.intervalEnd = intervalEnd;
            useSpline = true;
            SetDirty();
        }

        private void SetDirty() {
            isDirty = true;
        }

        private void LateUpdate() {
            ComputeIfNeeded();
        }

        public void ComputeIfNeeded() {
            if (isDirty) {
                Compute();
                isDirty = false;
            }
        }

        private List<CurveSample> GetPath() {
            var path = new List<CurveSample>();
            if (useSpline) {
                // calculate path from spline interval
                float d = intervalStart;
                while (d < intervalEnd) {
                    path.Add(spline.GetSampleAtDistance(d));
                    d += sampleSpacing;
                }
                path.Add(spline.GetSampleAtDistance(intervalEnd));
            } else {
                // calculate path in a curve
                float d = 0;
                while (d < curve.Length) {
                    path.Add(curve.GetSampleAtDistance(d));
                    d += sampleSpacing;
                }
                path.Add(curve.GetSampleAtDistance(curve.Length));
            }
            return path;
        }

        public void Compute() {
            List<CurveSample> path = GetPath();

            int vertsInShape = shapeVertices.Count;
            int segmentCount = path.Count - 1;

            var triangleIndices = new List<int>(vertsInShape * 2 * segmentCount * 3);
            var bentVertices = new List<MeshVertex>(vertsInShape * 2 * segmentCount * 3);

            foreach (var sample in path) {
                foreach (Vertex v in shapeVertices) {
                    bentVertices.Add(sample.GetBent(new MeshVertex(
                        new Vector3(0, v.point.y, -v.point.x),
                        new Vector3(0, v.normal.y, -v.normal.x),
                        new Vector2(v.uCoord, textureScale * (sample.distanceInCurve + textureOffset)))));
                }
            }
            var index = 0;
            for (int i = 0; i < segmentCount; i++) {
                for (int j = 0; j < shapeVertices.Count; j++) {
                    int offset = j == shapeVertices.Count - 1 ? -(shapeVertices.Count - 1) : 1;
                    int a = index + shapeVertices.Count;
                    int b = index;
                    int c = index + offset;
                    int d = index + offset + shapeVertices.Count;
                    triangleIndices.Add(c);
                    triangleIndices.Add(b);
                    triangleIndices.Add(a);
                    triangleIndices.Add(a);
                    triangleIndices.Add(d);
                    triangleIndices.Add(c);
                    index++;
                }
            }

            MeshUtility.Update(mf.sharedMesh,
                mf.sharedMesh,
                triangleIndices,
                bentVertices.Select(b => b.position),
                bentVertices.Select(b => b.normal),
                bentVertices.Select(b => b.uv));
            var mc = GetComponent<MeshCollider>();
            if(mc != null) {
                mc.sharedMesh = mf.sharedMesh;
            }
        }

        [Serializable]
        public class Vertex {
            public Vector2 point;
            public Vector2 normal;
            public float uCoord;

            public Vertex(Vector2 point, Vector2 normal, float uCoord) {
                this.point = point;
                this.normal = normal;
                this.uCoord = uCoord;
            }
            public Vertex(Vertex other) {
                this.point = other.point;
                this.normal = other.normal;
                this.uCoord = other.uCoord;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/MeshProcessing/ExtrusionSegment.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/MeshProcessing/MeshBender.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f8cda9ed2ad6a8b4781166236afc26b3
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;
using UnityEditor;
using System;
using System.Collections.Generic;
using System.Linq;

namespace SplineMesh {
    /// <summary>
    /// A component that creates a deformed mesh from a given one along the given spline segment.
    /// The source mesh will always be bended along the X axis.
    /// It can work on a cubic bezier curve or on any interval of a given spline.
    /// On the given interval, the mesh can be place with original scale, stretched, or repeated.
    /// The resulting mesh is stored in a MeshFilter component and automaticaly updated on the next update if the spline segment change.
    /// </summary>
    [DisallowMultipleComponent]
    [RequireComponent(typeof(MeshFilter))]
    [ExecuteInEditMode]
    public class MeshBender : MonoBehaviour {
        private bool isDirty = false;
        private Mesh result;
        private bool useSpline;
        private Spline spline;
        private float intervalStart, intervalEnd;
        private CubicBezierCurve curve;
        private Dictionary<float, CurveSample> sampleCache = new Dictionary<float, CurveSample>();

        private SourceMesh source;
        /// <summary>
        /// The source mesh to bend.
        /// </summary>
        public SourceMesh Source {
            get { return source; }
            set {
                if (value == source) return;
                SetDirty();
                source = value;
            }
        }
        
        private FillingMode mode = FillingMode.StretchToInterval;
        /// <summary>
        /// The scaling mode along the spline
        /// </summary>
        public FillingMode Mode {
            get { return mode; }
            set {
                if (value == mode) return;
                SetDirty();
                mode = value;
            }
        }

        /// <summary>
        /// Sets a curve along which the mesh will be bent.
        /// The mesh will be updated if the curve changes.
        /// </summary>
        /// <param name="curve">The <see cref="CubicBezierCurve"/> to bend the source mesh along.</param>
        public void SetInterval(CubicBezierCurve curve) {
            if (this.curve == curve) return;
            if (curve == null) throw new ArgumentNullException("curve");
            if (this.curve != null) {
                this.curve.Changed.RemoveListener(SetDirty);
            }
            this.curve = curve;
            spline = null;
            curve.Changed.AddListener(SetDirty);
            useSpline = false;
            SetDirty();
        }

        /// <summary>
        /// Sets a spline's interval along which the mesh will be bent.
        /// If interval end is absent or set to 0, the interval goes from start to spline length.
        /// The mesh will be update if any of the curve changes on the spline, including curves
        /// outside the given interval.
        /// </summary>
        /// <param name="spline">The <see cref="SplineMesh"/> to bend the source mesh along.</param>
        /// <param name="intervalStart">Distance from the spline start to place the mesh minimum X.<param>
        /// <param name="intervalEnd">Distance from the spline start to stop deforming the source mesh.</param>
        public void SetInterval(Spline spline, float intervalStart, float intervalEnd = 0) {
            if (this.spline == spline && this.intervalStart == intervalStart && this.intervalEnd == intervalEnd) return;
            if (spline == null) throw new ArgumentNullException("spline");
            if (intervalStart < 0 || intervalStart >= spline.Length) {
                throw new ArgumentOutOfRangeException("interval start must be 0 or greater and lesser than spline length (was " + intervalStart + ")");
            }
            if (intervalEnd != 0 && intervalEnd <= intervalStart || intervalEnd > spline.Length) {
                throw new ArgumentOutOfRangeException("interval end must be 0 or greater than interval start, and lesser than spline length (was " + intervalEnd + ")");
            }
            if (this.spline != null) {
                // unlistening previous spline
                this.spline.CurveChanged.RemoveListener(SetDirty);
            }
            this.spline = spline;
            // listening new spline
            spline.CurveChanged.AddListener(SetDirty);

            curve = null;
            this.intervalStart = intervalStart;
            this.intervalEnd = intervalEnd;
            useSpline = true;
            SetDirty();
        }

        private void OnEnable() {
            if(GetComponent<MeshFilter>().sharedMesh != null) {
                result = GetComponent<MeshFilter>().sharedMesh;
            } else {
                GetComponent<MeshFilter>().sharedMesh = result = new Mesh();
                result.name = "Generated by " + GetType().Name;
            }
        }

        private void LateUpdate() {
            ComputeIfNeeded();
        }

        public void ComputeIfNeeded() {
            if (isDirty) {
                Compute();
            }
        }

        private void SetDirty() {
            isDirty = true;
        }

        /// <summary>
        /// Bend the mesh. This method may take time and should not be called more than necessary.
        /// Consider using <see cref="ComputeIfNeeded"/> for faster result.
        /// </summary>
        private  void Compute() {
            isDirty = false;
            switch (Mode) {
                case FillingMode.Once:
                    FillOnce();
                    break;
                case FillingMode.Repeat:
                    FillRepeat();
                    break;
                case FillingMode.StretchToInterval:
                    FillStretch();
                    break;
            }
        }

        private void OnDestroy() {
            if(curve != null) {
                curve.Changed.RemoveListener(Compute);
            }
        }

        /// <summary>
        /// The mode used by <see cref="MeshBender"/> to bend meshes on the interval.
        /// </summary>
        public enum FillingMode {
            /// <summary>
            /// In this mode, source mesh will be placed on the interval by preserving mesh scale.
            /// Vertices that are beyond interval end will be placed on the interval end.
            /// </summary>
            Once,
            /// <summary>
            /// In this mode, the mesh will be repeated to fill the interval, preserving
            /// mesh scale.
            /// This filling process will stop when the remaining space is not enough to
            /// place a whole mesh, leading to an empty interval.
            /// </summary>
            Repeat,
            /// <summary>
            /// In this mode, the mesh is deformed along the X axis to fill exactly the interval.
            /// </summary>
            StretchToInterval
        }

        private void FillOnce() {
            sampleCache.Clear();
            var bentVertices = new List<MeshVertex>(source.Vertices.Count);
            // for each mesh vertex, we found its projection on the curve
            foreach (var vert in source.Vertices) {
                float distance = vert.position.x - source.MinX;
                CurveSample sample;
                if (!sampleCache.TryGetValue(distance, out sample)) {
                    if (!useSpline) {
                        if (distance > curve.Length) distance = curve.Length;
                        sample = curve.GetSampleAtDistance(distance);
                    } else {
                        float distOnSpline = intervalStart + distance;
                        if (distOnSpline > spline.Length) {
                            if (spline.IsLoop) {
                                while (distOnSpline > spline.Length) {
                                    distOnSpline -= spline.Length;
                                }
                            } else {
                                distOnSpline = spline.Length;
                            }
                        }
                        sample = spline.GetSampleAtDistance(distOnSpline);
                    }
                    sampleCache[distance] = sample;
                }

                bentVertices.Add(sample.GetBent(vert));
            }

            MeshUtility.Update(result,
                source.Mesh,
                source.Triangles,
                bentVertices.Select(b => b.position),
                bentVertices.Select(b => b.normal));
        }

        private void FillRepeat() {
            float intervalLength = useSpline?
                (intervalEnd == 0 ? spline.Length : intervalEnd) - intervalStart :
                curve.Length;
            int repetitionCount = Mathf.FloorToInt(intervalLength / source.Length);


            // building triangles and UVs for the repeated mesh
            var triangles = new List<int>();
            var uv = new List<Vector2>();
            var uv2 = new List<Vector2>();
            var uv3 = new List<Vector2>();
            var uv4 = new List<Vector2>();
            var uv5 = new List<Vector2>();
            var uv6 = new List<Vector2>();
            var uv7 = new List<Vector2>();
            var uv8 = new List<Vector2>();
            for (int i = 0; i < repetitionCount; i++) {
                foreach (var index in source.Triangles) {
                    triangles.Add(index + source.Vertices.Count * i);
                }
                uv.AddRange(source.Mesh.uv);
                uv2.AddRange(source.Mesh.uv2);
                uv3.AddRange(source.Mesh.uv3);
                uv4.AddRange(source.Mesh.uv4);
#if UNITY_2018_2_OR_NEWER
                uv5.AddRange(source.Mesh.uv5);
                uv6.AddRange(source.Mesh.uv6);
                uv7.AddRange(source.Mesh.uv7);
                uv8.AddRange(source.Mesh.uv8);
#endif
            }

            // computing vertices and normals
            var bentVertices = new List<MeshVertex>(source.Vertices.Count);
            float offset = 0;
            for (int i = 0; i < repetitionCount; i++) {

                sampleCache.Clear();
                // for each mesh vertex, we found its projection on the curve
                foreach (var vert in source.Vertices) {
                    float distance = vert.position.x - source.MinX + offset;
                    CurveSample sample;
                    if (!sampleCache.TryGetValue(distance, out sample)) {
                        if (!useSpline) {
                            if (distance > curve.Length) continue;
                            sample = curve.GetSampleAtDistance(distance);
                        } else {
                            float distOnSpline = intervalStart + distance;
                            //if (true) { //spline.isLoop) {
                                while (distOnSpline > spline.Length) {
                                    distOnSpline -= spline.Length;
                                }
                            //} else if (distOnSpline > spline.Length) {
                            //    continue;
                            //}
                            sample = spline.GetSampleAtDistance(distOnSpline);
                        }
                        sampleCache[distance] = sample;
                    }
                    bentVertices.Add(sample.GetBent(vert));
                }
                offset += source.Length;
            }

            MeshUtility.Update(result,
                source.Mesh,
                triangles,
                bentVertices.Select(b => b.position),
                bentVertices.Select(b => b.normal),
                uv,
                uv2,
                uv3,
                uv4,
                uv5,
                uv6,
                uv7,
                uv8);
        }

        private void FillStretch() {
            var bentVertices = new List<MeshVertex>(source.Vertices.Count);
            sampleCache.Clear();
            // for each mesh vertex, we found its projection on the curve
            foreach (var vert in source.Vertices) {
                float distanceRate = source.Length == 0 ? 0 : Math.Abs(vert.position.x - source.MinX) / source.Length;
                CurveSample sample;
                if (!sampleCache.TryGetValue(distanceRate, out sample)) {
                    if (!useSpline) {
                        sample = curve.GetSampleAtDistance(curve.Length * distanceRate);
                    } else {
                        float intervalLength = intervalEnd == 0 ? spline.Length - intervalStart : intervalEnd - intervalStart;
                        float distOnSpline = intervalStart + intervalLength * distanceRate;
                        if(distOnSpline > spline.Length) {
                            distOnSpline = spline.Length;
                            Debug.Log("dist " + distOnSpline + " spline length " + spline.Length + " start " + intervalStart);
                        }

                        sample = spline.GetSampleAtDistance(distOnSpline);
                    }
                    sampleCache[distanceRate] = sample;
                }

                bentVertices.Add(sample.GetBent(vert));
            }

            MeshUtility.Update(result,
                source.Mesh,
                source.Triangles,
                bentVertices.Select(b => b.position),
                bentVertices.Select(b => b.normal));
            if (TryGetComponent(out MeshCollider collider)) {
                collider.sharedMesh = result;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/MeshProcessing/MeshBender.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/MeshProcessing/MeshVertex.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9956472d7384e9140aecfec0a88b1962
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;
using UnityEditor;
using System;

namespace SplineMesh {
    [Serializable]
    public class MeshVertex {
        public Vector3 position;
        public Vector3 normal;
        public Vector2 uv;

        public MeshVertex(Vector3 position, Vector3 normal, Vector2 uv) {
            this.position = position;
            this.normal = normal;
            this.uv = uv;
        }

        public MeshVertex(Vector3 position, Vector3 normal)
            : this(position, normal, Vector2.zero)
        {
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/MeshProcessing/MeshVertex.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/MeshProcessing/SourceMesh.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6809125401b4116468732e472cad438b
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System;

namespace SplineMesh {
    /// <summary>
    /// This class returns a transformed version of a given source mesh, plus others
    /// informations to help bending the mesh along a curve.
    /// It is imutable to ensure better performances.
    /// 
    /// To obtain an instance, call the static method <see cref="Build(Mesh)"/>.
    /// The building is made in a fluent way.
    /// </summary>
    public struct SourceMesh {
        private Vector3 translation;
        private Quaternion rotation;
        private Vector3 scale;

        internal Mesh Mesh { get; }

        private List<MeshVertex> vertices;
        internal List<MeshVertex> Vertices {
            get {
                if (vertices == null) BuildData();
                return vertices;
            }
        }

        private int[] triangles;
        internal int[] Triangles {
            get {
                if (vertices == null) BuildData();
                return triangles;
            }
        }

        private float minX;
        internal float MinX {
            get {
                if (vertices == null) BuildData();
                return minX;
            }
        }

        private float length;
        internal float Length {
            get {
                if (vertices == null) BuildData();
                return length;
            }
        }

        /// <summary>
        /// constructor is private to enable fluent builder pattern.
        /// Use <see cref="Build(Mesh)"/> to obtain an instance.
        /// </summary>
        /// <param name="mesh"></param>
        private SourceMesh(Mesh mesh) {
            Mesh = mesh;
            translation = default(Vector3);
            rotation = default(Quaternion);
            scale = default(Vector3);
            vertices = null;
            triangles = null;
            minX = 0;
            length = 0;
        }

        /// <summary>
        /// copy constructor
        /// </summary>
        /// <param name="other"></param>
        private SourceMesh(SourceMesh other) {
            Mesh = other.Mesh;
            translation = other.translation;
            rotation = other.rotation;
            scale = other.scale;
            vertices = null;
            triangles = null;
            minX = 0;
            length = 0;
        }

        public static SourceMesh Build(Mesh mesh) {
            return new SourceMesh(mesh);
        }

        public SourceMesh Translate(Vector3 translation) {
            var res = new SourceMesh(this) {
                translation = translation
            };
            return res;
        }

        public SourceMesh Translate(float x, float y, float z) {
            return Translate(new Vector3(x, y, z));
        }

        public SourceMesh Rotate(Quaternion rotation) {
            var res = new SourceMesh(this) {
                rotation = rotation
            };
            return res;
        }

        public SourceMesh Scale(Vector3 scale) {
            var res = new SourceMesh(this) {
                scale = scale
            };
            return res;
        }

        public SourceMesh Scale(float x, float y, float z) {
            return Scale(new Vector3(x, y, z));
        }

        private void BuildData() {
            // if the mesh is reversed by scale, we must change the culling of the faces by inversing all triangles.
            // the mesh is reverse only if the number of resersing axes is impair.
            bool reversed = scale.x < 0;
            if (scale.y < 0) reversed = !reversed;
            if (scale.z < 0) reversed = !reversed;
            triangles = reversed ? MeshUtility.GetReversedTriangles(Mesh) : Mesh.triangles;

            // we transform the source mesh vertices according to rotation/translation/scale
            int i = 0;
            vertices = new List<MeshVertex>(Mesh.vertexCount);
            foreach (Vector3 vert in Mesh.vertices) {
                var transformed = new MeshVertex(vert, Mesh.normals[i++]);
                //  application of rotation
                if (rotation != Quaternion.identity) {
                    transformed.position = rotation * transformed.position;
                    transformed.normal = rotation * transformed.normal;
                }
                if (scale != Vector3.one) {
                    transformed.position = Vector3.Scale(transformed.position, scale);
                    transformed.normal = Vector3.Scale(transformed.normal, scale);
                }
                if (translation != Vector3.zero) {
                    transformed.position += translation;
                }
                vertices.Add(transformed);
            }

            // find the bounds along x
            minX = float.MaxValue;
            float maxX = float.MinValue;
            foreach (var vert in vertices) {
                Vector3 p = vert.position;
                maxX = Math.Max(maxX, p.x);
                minX = Math.Min(minX, p.x);
            }
            length = Math.Abs(maxX - minX);
        }

        public override bool Equals(object obj) {
            if (obj == null || GetType() != obj.GetType()) {
                return false;
            }
            var other = (SourceMesh)obj;
            return Mesh == other.Mesh &&
                translation == other.translation &&
                rotation == other.rotation &&
                scale == other.scale;
        }

        public override int GetHashCode() {
            return base.GetHashCode();
        }

        public static bool operator ==(SourceMesh sm1, SourceMesh sm2) {
            return sm1.Equals(sm2);
        }
        public static bool operator !=(SourceMesh sm1, SourceMesh sm2) {
            return sm1.Equals(sm2);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/MeshProcessing/SourceMesh.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/MeshProcessing/SplineExtrusion.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8d1eb05ecfaa05444b40d40a2ea2268f
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace SplineMesh {
    /// <summary>
    /// Special component to extrude shape along a spline.
    /// 
    /// Note : This component is not lightweight and should be used as-is mostly for prototyping. It allows to quickly create meshes by
    /// drawing only the 2D shape to extrude along the spline. The result is not intended to be used in a production context and you will most likely
    /// create eventualy the mesh you need in a modeling tool to save performances and have better control.
    /// 
    /// The special editor of this component allow you to draw a 2D shape with vertices, normals and U texture coordinate. The V coordinate is set
    /// for the whole spline, by setting the number of times the texture must be repeated.
    /// 
    /// All faces of the resulting mesh are smoothed. If you want to obtain an edge without smoothing, you will have to overlap two vertices and set two normals.
    /// 
    /// You can expand the vertices list in the inspector to access data and enter precise values.
    /// 
    /// This component doesn't offer much control as Unity is not a modeling tool. That said, you should be able to create your own version easily.
    /// </summary>
    [ExecuteInEditMode]
    [RequireComponent(typeof(Spline))]
    public class SplineExtrusion : MonoBehaviour {
        private Spline spline;
        private bool toUpdate = true;
        private GameObject generated;

        public List<ExtrusionSegment.Vertex> shapeVertices = new List<ExtrusionSegment.Vertex>();
        public Material material;
        public float textureScale = 1;
        public float sampleSpacing = 0.1f;

        /// <summary>
        /// Clear shape vertices, then create three vertices with three normals for the extrusion to be visible
        /// </summary>
        private void Reset() {
            shapeVertices.Clear();
            shapeVertices.Add(new ExtrusionSegment.Vertex(new Vector2(0, 0.5f), new Vector2(0, 1), 0));
            shapeVertices.Add(new ExtrusionSegment.Vertex(new Vector2(1, -0.5f), new Vector2(1, -1), 0.33f));
            shapeVertices.Add(new ExtrusionSegment.Vertex(new Vector2(-1, -0.5f), new Vector2(-1, -1), 0.66f));
            toUpdate = true;
            OnEnable();
        }

        private void OnValidate() {
            toUpdate = true;
        }

        private void OnEnable() {
            string generatedName = "generated by " + GetType().Name;
            var generatedTranform = transform.Find(generatedName);
            generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);

            spline = GetComponentInParent<Spline>();
            spline.NodeListChanged += (s, e) => toUpdate = true;
        }

        private void Update() {
            if (toUpdate) {
                GenerateMesh();
                toUpdate = false;
            }
        }

        private void GenerateMesh() {
            UOUtility.DestroyChildren(generated);

            int i = 0;
            float textureOffset = 0.0f;
            foreach (CubicBezierCurve curve in spline.GetCurves()) {
                GameObject go = UOUtility.Create("segment " + i++,
                    generated,
                    typeof(MeshFilter),
                    typeof(MeshRenderer),
                    typeof(ExtrusionSegment),
                    typeof(MeshCollider));
                go.GetComponent<MeshRenderer>().material = material;
                ExtrusionSegment seg = go.GetComponent<ExtrusionSegment>();
                seg.ShapeVertices = shapeVertices;
                seg.TextureScale = textureScale;
                seg.TextureOffset = textureOffset;
                seg.SampleSpacing = sampleSpacing;
                seg.SetInterval(curve);

                textureOffset += curve.Length;
            }
        }

        public void SetToUpdate() {
            toUpdate = true;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/MeshProcessing/SplineExtrusion.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/MeshProcessing/SplineMeshTiling.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 174367e175762fb48ba55d6171e99990
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
#if UNITY_EDITOR

#endif

namespace SplineMesh {
    /// <summary>
    /// Deform a mesh and place it along a spline, given various parameters.
    /// 
    /// This class intend to cover the most common situations of mesh bending. It can be used as-is in your project,
    /// or can serve as a source of inspiration to write your own procedural generator.
    /// </summary>
    [ExecuteInEditMode]
    [SelectionBase]
    [DisallowMultipleComponent]
    public class SplineMeshTiling : MonoBehaviour {
        private GameObject generated;
        private Spline spline = null;
        private bool toUpdate = false;

        [Tooltip("Mesh to bend along the spline.")]
        public Mesh mesh;
        [Tooltip("Material to apply on the bent mesh.")]
        public Material material;
        [Tooltip("Physic material to apply on the bent mesh.")]
        public PhysicsMaterial physicMaterial;
        [Tooltip("Translation to apply on the mesh before bending it.")]
        public Vector3 translation;
        [Tooltip("Rotation to apply on the mesh before bending it.")]
        public Vector3 rotation;
        [Tooltip("Scale to apply on the mesh before bending it.")]
        public Vector3 scale = Vector3.one;

        [Tooltip("If true, a mesh collider will be generated.")]
        public bool generateCollider = true;

        [Tooltip("If true, the mesh will be bent on play mode. If false, the bent mesh will be kept from the editor mode, allowing lighting baking.")]
        public bool updateInPlayMode;

        [Tooltip("If true, a mesh will be placed on each curve of the spline. If false, a single mesh will be placed for the whole spline.")]
        public bool curveSpace = false;

        [Tooltip("The mode to use to fill the choosen interval with the bent mesh.")]
        public MeshBender.FillingMode mode = MeshBender.FillingMode.StretchToInterval;

        private void OnEnable() {
            // tip : if you name all generated content in the same way, you can easily find all of it
            // at once in the scene view, with a single search.
            string generatedName = "generated by " + GetType().Name;
            var generatedTranform = transform.Find(generatedName);
            generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);

            spline = GetComponentInParent<Spline>();
            spline.NodeListChanged += (s, e) => toUpdate = true;

            toUpdate = true;
        }

        private void OnValidate() {
            if (spline == null) return;
            toUpdate = true;
        }

        private void Update() {
            // we can prevent the generated content to be updated during playmode to preserve baked data saved in the scene
            if (!updateInPlayMode && Application.isPlaying) return;

            if (toUpdate) {
                toUpdate = false;
                CreateMeshes();
            }
        }

        public void CreateMeshes() {
#if UNITY_EDITOR
            // we don't update if we are in prefab mode
            if (UnityEditor.SceneManagement.PrefabStageUtility.GetCurrentPrefabStage() != null) return;
#endif
            var used = new List<GameObject>();

            if (curveSpace) {
                int i = 0;
                foreach (var curve in spline.curves) {
                    var go = FindOrCreate("segment " + i++ + " mesh");
                    go.GetComponent<MeshBender>().SetInterval(curve);
                    go.GetComponent<MeshCollider>().enabled = generateCollider;
                    used.Add(go);
                }
            } else {
                var go = FindOrCreate("segment 1 mesh");
                go.GetComponent<MeshBender>().SetInterval(spline, 0);
                go.GetComponent<MeshCollider>().enabled = generateCollider;
                used.Add(go);
            }

            // we destroy the unused objects. This is classic pooling to recycle game objects.
            foreach (var go in generated.transform
                .Cast<Transform>()
                .Select(child => child.gameObject).Except(used)) {
                UOUtility.Destroy(go);
            }
        }

        private GameObject FindOrCreate(string name) {
            var childTransform = generated.transform.Find(name);
            GameObject res;
            if (childTransform == null) {
                res = UOUtility.Create(name,
                    generated,
                    typeof(MeshFilter),
                    typeof(MeshRenderer),
                    typeof(MeshBender),
                    typeof(MeshCollider));
                res.isStatic = !updateInPlayMode;
            } else {
                res = childTransform.gameObject;
            }
            res.GetComponent<MeshRenderer>().material = material;
            res.GetComponent<MeshCollider>().material = physicMaterial;
            MeshBender mb = res.GetComponent<MeshBender>();
            mb.Source = SourceMesh.Build(mesh)
                .Translate(translation)
                .Rotate(Quaternion.Euler(rotation))
                .Scale(scale);
            mb.Mode = mode;
            return res;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/MeshProcessing/SplineMeshTiling.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Utils/CameraUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a781badaa77fcbd409622fbddeeda765
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace SplineMesh {
    public static class CameraUtility {
        public static bool IsOnScreen(Vector3 position) {
            Vector3 onScreen = Camera.current.WorldToViewportPoint(position);
            return onScreen.z > 0 && onScreen.x > 0 && onScreen.y > 0 && onScreen.x < 1 && onScreen.y < 1;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Utils/CameraUtility.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Utils/MeshUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c524c1f7e9141014aba14c56c6b1baad
# ASMDEF: ldx.framework.runtime.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace SplineMesh {
    public class MeshUtility {

        /// <summary>
        /// Returns a mesh with reserved triangles to turn back the face culling.
        /// This is usefull when a mesh needs to have a negative scale.
        /// </summary>
        /// <param name="mesh"></param>
        /// <returns></returns>
        public static int[] GetReversedTriangles(Mesh mesh) {
            var res = mesh.triangles.ToArray();
            var triangleCount = res.Length / 3;
            for (var i = 0; i < triangleCount; i++) {
                var tmp = res[i * 3];
                res[i * 3] = res[i * 3 + 1];
                res[i * 3 + 1] = tmp;
            }
            return res;
        }

        /// <summary>
        /// Returns a mesh similar to the given source plus given optionnal parameters.
        /// </summary>
        /// <param name="mesh"></param>
        /// <param name="source"></param>
        /// <param name="triangles"></param>
        /// <param name="vertices"></param>
        /// <param name="normals"></param>
        /// <param name="uv"></param>
        /// <param name="uv2"></param>
        /// <param name="uv3"></param>
        /// <param name="uv4"></param>
        /// <param name="uv5"></param>
        /// <param name="uv6"></param>
        /// <param name="uv7"></param>
        /// <param name="uv8"></param>
        public static void Update(Mesh mesh,
            Mesh source,
            IEnumerable<int> triangles = null,
            IEnumerable<Vector3> vertices = null,
            IEnumerable<Vector3> normals = null,
            IEnumerable<Vector2> uv = null,
            IEnumerable<Vector2> uv2 = null,
            IEnumerable<Vector2> uv3 = null,
            IEnumerable<Vector2> uv4 = null,
            IEnumerable<Vector2> uv5 = null,
            IEnumerable<Vector2> uv6 = null,
            IEnumerable<Vector2> uv7 = null,
            IEnumerable<Vector2> uv8 = null) {
            mesh.hideFlags = source.hideFlags;
#if UNITY_2017_3_OR_NEWER
            mesh.indexFormat = source.indexFormat;
#endif

            mesh.triangles = new int[0];
            mesh.vertices = vertices == null ? source.vertices : vertices.ToArray();
            mesh.normals = normals == null ? source.normals : normals.ToArray();
            mesh.uv = uv == null? source.uv : uv.ToArray();
            mesh.uv2 = uv2 == null ? source.uv2 : uv2.ToArray();
            mesh.uv3 = uv3 == null ? source.uv3 : uv3.ToArray();
            mesh.uv4 = uv4 == null ? source.uv4 : uv4.ToArray();
#if UNITY_2018_2_OR_NEWER
            mesh.uv5 = uv5 == null ? source.uv5 : uv5.ToArray();
            mesh.uv6 = uv6 == null ? source.uv6 : uv6.ToArray();
            mesh.uv7 = uv7 == null ? source.uv7 : uv7.ToArray();
            mesh.uv8 = uv8 == null ? source.uv8 : uv8.ToArray();
#endif
            mesh.triangles = triangles == null ? source.triangles : triangles.ToArray();
            mesh.RecalculateBounds();
            mesh.RecalculateTangents();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Utils/MeshUtility.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Utils/UOUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5a4e07385171f27439dd485c6211462f
# ASMDEF: ldx.framework.runtime.dll
# ---
using UnityEngine;
using UnityEditor;
using System.Linq;
using System;

namespace SplineMesh {
    public static class UOUtility {
        public static GameObject Create(string name, GameObject parent, params Type[] components) {
            var res = new GameObject(name, components);
            res.transform.parent = parent.transform;
            res.transform.localPosition = Vector3.zero;
            res.transform.localScale = Vector3.one;
            res.transform.localRotation = Quaternion.identity;
            return res;
        }

        public static GameObject Instantiate(GameObject prefab, Transform parent) {
            var res = UnityEngine.Object.Instantiate(prefab, parent);
            res.transform.localPosition = Vector3.zero;
            res.transform.localRotation = Quaternion.identity;
            res.transform.localScale = Vector3.one;
            return res;
        }

        public static void Destroy(GameObject go) {
            if (Application.isPlaying) {
                UnityEngine.Object.Destroy(go);
            } else {
                UnityEngine.Object.DestroyImmediate(go);
            }
        }

        public static void Destroy(Component comp) {
            if (Application.isPlaying) {
                UnityEngine.Object.Destroy(comp);
            } else {
                UnityEngine.Object.DestroyImmediate(comp);
            }
        }

        public static void DestroyChildren(GameObject go) {
            var childList = go.transform.Cast<Transform>().ToList();
            foreach (Transform childTransform in childList) {
                Destroy(childTransform.gameObject);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/SplineMesh/Scripts/Utils/UOUtility.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Arrays Pooling/ArrayPoolsProvider.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 63f40aa4b20670544b815cf3f0a5da3a
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using ToolBuddy.Pooling.Pools;

namespace ToolBuddy.Pooling
{
    /// <summary>
    /// Provides instances of <see cref="ArrayPool{T}"/>
    /// </summary>
    /// <remarks>Is thread safe</remarks>
    public class ArrayPoolsProvider
    {
        private static readonly Dictionary<Type, object> arrayPools = new Dictionary<Type, object>();
        private static readonly object lockObject = new object();

        /// <summary>
        /// Returns an instance of <see cref="ArrayPool{T}"/> if previously created, otherwise creates a new one.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        public static ArrayPool<T> GetPool<T>()
        {
            Type type = typeof(T);
            object pool;
            if (arrayPools.TryGetValue(type, out pool) == false)
            {
                lock (lockObject)
                {
                    if (arrayPools.TryGetValue(type, out pool) == false)
                        arrayPools[type] = pool = new ArrayPool<T>(1_000_000);
                }
            }

            return (ArrayPool<T>)pool;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Arrays Pooling/ArrayPoolsProvider.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Arrays Pooling/Collections/SubArray.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 40ccb37f4e1e70b42a936638fd73f551
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using ToolBuddy.Pooling.Pools;

namespace ToolBuddy.Pooling.Collections
{
    /// <summary>
    /// A struct that helps you use a part of an array.
    /// </summary>
    /// <remarks>Can be reused if you free it by calling <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/></remarks>
    /// <typeparam name="T"></typeparam>
#if CURVY_SANITY_CHECKS
    public struct SubArray<T>
    {

        private T[] array;

        /// <summary>
        /// The array where data is stored in
        /// </summary>
        public T[] Array
        {
            get
            {
                if (IsDisposed)
                    throw new InvalidOperationException("Trying to dispose a disposed SubArray");
                return array;
            }
            set => array = value;
        }

        public bool IsDisposed;
#else
public readonly struct SubArray<T>
    {
        /// <summary>
        /// The array where data is stored in
        /// </summary>
        public readonly T[] Array;
#endif
        /// <summary>
        /// The number of elements to be used in that array, counted from the start of the array
        /// </summary>
        public readonly int Count;

        /// <summary>
        /// Creates an instance that will use all the elements of the given array
        /// </summary>
        public SubArray(T[] array)
        {
#if CURVY_SANITY_CHECKS
            IsDisposed = false;
            this.array =
#else
            Array = 
#endif
                array != null ? array : throw new ArgumentNullException(nameof(array));
            Count = array.Length;
        }

        /// <summary>
        /// Creates an instance that will use the first "count" elements of the given array
        /// </summary>
        public SubArray(T[] array, int count)
        {
            if (array == null)
                throw new ArgumentNullException(nameof(array));
            if (count < 0)
                throw new ArgumentOutOfRangeException(nameof(count));
            if (count > array.Length)
                throw new ArgumentOutOfRangeException(nameof(count));

#if CURVY_SANITY_CHECKS
            IsDisposed = false;
            this.array =
#else
            Array =
#endif
                array;

            Count = count;
        }

        /// <summary>
        /// Returns a new array that which length is <see cref="Count"/> and contains the elements from <see cref="Array"/>
        /// </summary>
        public T[] CopyToArray(ArrayPool<T> arrayPool)
        {
            T[] result = arrayPool.AllocateExactSize(Count, false).Array;
            System.Array.Copy(Array, 0, result, 0, Count);
            return result;
        }

        public override int GetHashCode()
        {
            return Array != null ? Array.GetHashCode() ^ Count : 0;
        }

        public override bool Equals(object obj)
        {
            return obj is SubArray<T> subArray && Equals(subArray);
        }

        public bool Equals(SubArray<T> obj)
        {
            return obj.Array == Array && obj.Count == Count;
        }

        public static bool operator ==(SubArray<T> a, SubArray<T> b)
        {
            return a.Equals(b);
        }

        public static bool operator !=(SubArray<T> a, SubArray<T> b)
        {
            return !(a == b);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Arrays Pooling/Collections/SubArray.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Arrays Pooling/Collections/SubArrayList.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 47f615f5619283e4a9d614fd31165ac8
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using ToolBuddy.Pooling.Pools;

namespace ToolBuddy.Pooling.Collections
{
    /// <summary>
    /// A class that simulates very minimal features of a List, but using a <see cref="SubArray{T}"/> instead of an <see cref="System.Array"/> as a storage
    /// </summary>
    /// <seealso cref="SubArray{T}"/>
    public struct SubArrayList<T>
    {
        private readonly ArrayPool<T> typePool;
        private SubArray<T> subArray;

        /// <summary>
        /// The <see cref="System.Array"/> used by the underlying <see cref="SubArray{T}"/> for storage
        /// </summary>
        public T[] Array => subArray.Array;

        /// <summary>
        /// The number of elements occupied in the storage
        /// </summary>
        public int Count { get; private set; }

        /// <summary>
        /// Creates an instance
        /// </summary>
        /// <param name="initialCapacity">The initial capacity of the underlying storage</param>
        /// <param name="typePool"> A pool that will be used to, if needed, allocate a bigger array if elements </param>
        public SubArrayList(int initialCapacity, ArrayPool<T> typePool)
        {
            this.typePool = typePool;
            subArray = typePool.Allocate(initialCapacity, false);
            Count = 0;
        }

        /// <summary>
        /// Adds a new element to the array
        /// </summary>
        public void Add(T element)
        {
            if (Count == subArray.Count)
            {
                int newSize = subArray.Count == 0 ? 4 : subArray.Count * 2;
                typePool.Resize(ref subArray, newSize, false);
            }

            subArray.Array[Count] = element;
            Count++;
        }

        /// <summary>
        /// Returns a <see cref="SubArray{T}"/> instance that will have <see cref="Array"/> as an array (not a copy of it), and <see cref="Count"/> as its <see cref="SubArray{T}.Count"/>
        /// </summary>
        /// <returns></returns>
        public SubArray<T> ToSubArray()
        {
            return new SubArray<T>(subArray.Array, Count);
        }

        public bool Equals(SubArrayList<T> other)
        {
            return subArray.Equals(other.subArray) && Count == other.Count;
        }

        public override bool Equals(object obj)
        {
            return obj is SubArrayList<T> other && Equals(other);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                return (subArray.GetHashCode() * 397) ^ Count;
            }
        }

        public static bool operator ==(SubArrayList<T> a, SubArrayList<T> b)
        {
            return a.Equals(b);
        }

        public static bool operator !=(SubArrayList<T> a, SubArrayList<T> b)
        {
            return !(a == b);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Arrays Pooling/Collections/SubArrayList.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Arrays Pooling/Pools/ArrayPool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 265a80d77815ce84ca4914d0fe04201a
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Runtime.CompilerServices;
using ToolBuddy.Pooling.Collections;
using UnityEngine;
using Random = UnityEngine.Random;

namespace ToolBuddy.Pooling.Pools
{
    /// <summary>
    /// A pool of allowing the re-usage of previously allocated and discarded arrays.
    /// Helps reducing garbage collection.
    /// </summary>
    /// <remarks>Is thread safe</remarks>
    /// <seealso cref="SubArray{T}"/>
    public class ArrayPool<T>
    {

        private readonly SubArray<T> emptySubArray = new SubArray<T>(new T[0]);

        private readonly System.Random random = new System.Random();

        private const int keysInitialCapacity = 200;
        //Optim: inserting and removing elements from those arrays leads to array copies. That takes a lot of time. Enhance this if needed
        private int[] poolKeys = new int[keysInitialCapacity];
        private T[][] poolValues = new T[keysInitialCapacity][];
        private int arraysCount;

        private long elementsCount;
        private long elementsCapacity;

        /// <summary>
        /// The maximal number of elements that the pool will keep, after they have been freed, to be available for future usage.
        /// Once this limit is reached, every freed array will simply get ignored, allowing the garbage collector to collect it
        /// </summary>
        /// <remarks>This is not the maximal number of arrays, but the maximal sum of the arrays' lengths</remarks>
        public long ElementsCapacity
        {
            get => elementsCapacity;
            set
            {
                if (elementsCapacity != value)
                    lock (this)
                    {
                        elementsCapacity = value;
                        ApplyCapacity(elementsCapacity);
                    }
            }
        }

        /// <summary>
        /// Log in the console each time a new array is allocated in memory
        /// </summary>
        public bool LogAllocations { get; set; }

        /// <summary>
        /// Returns data about the pool's usage.
        /// </summary>
        /// <see cref="ArrayPoolUsageData"/>
        public ArrayPoolUsageData UsageData => new ArrayPoolUsageData(elementsCount, arraysCount, elementsCapacity);

        /// <summary>
        /// Creates a new pool
        /// </summary>
        /// <param name="elementsCapacity"><see cref="ElementsCapacity"/>
        /// </param>
        public ArrayPool(long elementsCapacity)
        {
            if (elementsCapacity < 0)
                throw new ArgumentOutOfRangeException(nameof(elementsCapacity), "Must be strictly positive.");

            this.elementsCapacity = elementsCapacity;
        }

        /// <summary>
        /// Allocates a new array if none available, or reuses an existing one otherwise
        /// </summary>
        /// <param name="minimalSize">The array's guaranteed minimal size</param>
        /// <param name="clearArray">Whether the returned array's elements will be guaranteed to be set to their default value</param>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]

        public SubArray<T> Allocate(int minimalSize, bool clearArray = true)
        {
            //OPTIM set all calls that don't need a cleared array to clearArray == false
            return Allocate(minimalSize, false, clearArray, out _);
        }

        /// <summary>
        /// Allocates a new array if none available, or reuses an existing one otherwise
        /// </summary>
        /// <param name="exactSize">The array's exact size</param>
        /// <param name="clearArray">Whether the returned array's elements will be guaranteed to be set to their default value</param>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public SubArray<T> AllocateExactSize(int exactSize, bool clearArray = true)
        {
            return Allocate(exactSize, true, clearArray, out _);
        }


        /// <summary>
        /// Returns an array to the pool, ready to be reused
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Free(SubArray<T> subArray)
        {
            Free(subArray.Array);
#if CURVY_SANITY_CHECKS
            subArray.IsDisposed = true;
#endif
        }

        /// <summary>
        /// Returns an array to the pool, ready to be reused
        /// </summary>
        public void Free(T[] array)
        {
            if (array.Length > elementsCapacity || array.Length == 0)
                return;

            lock (this)
            {
#if CURVY_SANITY_CHECKS
                for (var i = 0; i < arraysCount; i++)
                {
                    if (poolValues[i] == array)
                        throw new InvalidOperationException();
                }
#endif
                
                ApplyCapacity(elementsCapacity - array.Length);

                int indexToInsertInto;
                {
                    int index = BinarySearch(poolKeys, arraysCount, array.Length);
                    indexToInsertInto = index >= 0 ? index : ~index;
                }

                if (arraysCount == poolKeys.Length)
                {
                    //no overflow check. If you reach the point of overflowing, then you have way too much arrays
                    int newSize = 2 * (arraysCount + 1);
                    Array.Resize(ref poolValues, newSize);
                    Array.Resize(ref poolKeys, newSize);
                }

                if (indexToInsertInto < arraysCount)
                {
                    Array.Copy(poolKeys, indexToInsertInto, poolKeys, indexToInsertInto + 1, arraysCount - indexToInsertInto);
                    Array.Copy(poolValues, indexToInsertInto, poolValues, indexToInsertInto + 1, arraysCount - indexToInsertInto);
                }
                poolKeys[indexToInsertInto] = array.Length;
                poolValues[indexToInsertInto] = array;

                ++arraysCount;

                elementsCount += array.Length;
            }
        }

        /// <summary>
        /// Resizes the given array
        /// </summary>
        /// <param name="subArray"> The array to resize</param>
        /// <param name="newMinimalSize">The new size</param>
        /// <param name="clearNewSpace">When resizing and array to make it bigger, should the newly available space be cleared or not.</param>
        public void Resize(ref SubArray<T> subArray, int newMinimalSize, bool clearNewSpace = true)
        {
            //OPTIM set all calls that don't need a cleared new space to clearNewSpace == false
            if (subArray.Count == newMinimalSize)
                return;

            if (newMinimalSize < 0)
                throw new ArgumentOutOfRangeException(nameof(newMinimalSize), "Must be positive.");

            if (newMinimalSize == 0)
            {
                Free(subArray);
                subArray = emptySubArray;
            }
            else
            {
                int oldSize = subArray.Count;

                bool isArrayCleared;
                if (newMinimalSize > subArray.Array.Length)
                {
                    SubArray<T> destinationSubArray = Allocate(newMinimalSize, false, false, out isArrayCleared);
                    Array.Copy(
                        subArray.Array, 0,
                        destinationSubArray.Array, 0,
                        subArray.Count);
                    Free(subArray);
                    subArray = destinationSubArray;
                }
                else
                {
                    subArray = new SubArray<T>(subArray.Array, newMinimalSize);
                    isArrayCleared = false;
                }

                if (clearNewSpace && isArrayCleared == false && newMinimalSize > oldSize)
                    Array.Clear(subArray.Array, oldSize, newMinimalSize - oldSize);
            }
        }

        /// <summary>
        /// Resize an array to a new size and clears it. Similar to calling <see cref="Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> then calling <see cref="Allocate"/>, but done in a more optimized way
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ResizeAndClear(ref SubArray<T> subArray, int newMinimalSize)
        {
            if (subArray.Count == newMinimalSize)
            {
                Array.Clear(subArray.Array, 0, newMinimalSize);
                return;
            }

            if (newMinimalSize < 0)
                throw new ArgumentOutOfRangeException(nameof(newMinimalSize), "Must be positive.");

            if (newMinimalSize == 0)
            {
                Free(subArray);
                subArray = emptySubArray;
            }
            else
            {
                if (newMinimalSize > subArray.Array.Length)
                {
                    SubArray<T> destinationSubArray = Allocate(newMinimalSize, false, true, out _);
                    Free(subArray);
                    subArray = destinationSubArray;
                }
                else
                {
                    subArray = new SubArray<T>(subArray.Array, newMinimalSize);
                    Array.Clear(subArray.Array, 0, newMinimalSize);
                }
            }
        }

        /// <summary>
        /// Return a new <see cref="SubArray{T}"/> instance that will use a copy of the given input array
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public SubArray<T> Clone(T[] source)
        {
            SubArray<T> clone = Allocate(source.Length, false);
            Array.Copy(source, 0,
                clone.Array, 0, source.Length);

            return clone;
        }

        /// <summary>
        /// Return a new <see cref="SubArray{T}"/> instance that will use a copy of the given input array
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public SubArray<T> Clone(SubArray<T> source)
        {
            SubArray<T> clone = Allocate(source.Count, false);
            Array.Copy(source.Array, 0,
                clone.Array, 0, source.Count);

            return clone;
        }

        /// <summary>
        /// Allocates a new array if none available, or reuses an existing one otherwise
        /// </summary>
        /// <param name="size">The array's minimal or exact size, depending on <see cref="exactSize"/></param>
        /// <param name="exactSize">Whether the <see cref="size"/> parameter should be considered as an exact size or a minimal one</param>
        /// <param name="clearArray">Whether the returned array's elements will be guaranteed to be set to their default value</param>
        /// <param name="isArrayCleared">Whether the returned array is cleared. This is different from <see cref="clearArray"/> because even if <see cref="clearArray"/> is set to false, a newly created array will have its content cleared by definition</param>
        /// <returns></returns>
        private SubArray<T> Allocate(int size, bool exactSize, bool clearArray, out bool isArrayCleared)
        {

            if (size > elementsCapacity)
            {
                isArrayCleared = true;
                if (LogAllocations)
                    Debug.Log($"[ArrayPools] Type: {typeof(T).Name}. Allocated array size {size}. The requested size is bigger than the pool's capacity {elementsCapacity}");
                return new SubArray<T>(new T[size], size);
            }

            if (size == 0)
            {
                isArrayCleared = true;
                return emptySubArray;
            }

            if (size < 0)
                throw new ArgumentOutOfRangeException(nameof(size), "Must be positive.");

            lock (this)
            {
                int indexToRemoveFrom;
                {
                    int elementIndex = BinarySearch(poolKeys, arraysCount, size);

                    indexToRemoveFrom = elementIndex >= 0
                        ? elementIndex
                        : exactSize
                            ? arraysCount
                            : ~elementIndex;
                }

                T[] array;
                if (indexToRemoveFrom < arraysCount)
                {
                    array = RemoveElementAt(indexToRemoveFrom);
                    if (clearArray)
                        Array.Clear(array, 0, array.Length);
                    isArrayCleared = clearArray;
                }
                else
                {
                    if (LogAllocations)
                        Debug.Log($"[ArrayPools] Type: {typeof(T).Name}. Allocated array size {size}. The size of the biggest array available is {(arraysCount == 0 ? "None" : poolKeys[arraysCount - 1].ToString( ))}");
                    array = new T[size];
                    isArrayCleared = true;
                }

                return new SubArray<T>(array, size);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void ApplyCapacity(long capacity)
        {
            while (elementsCount > capacity)
                RemoveElementAt(random.Next(0, arraysCount));
        }

        private T[] RemoveElementAt(int elementIndex)
        {
            T[] array = poolValues[elementIndex];

            --arraysCount;
            if (elementIndex < arraysCount)
            {
                Array.Copy(poolKeys, elementIndex + 1, poolKeys, elementIndex, arraysCount - elementIndex);
                Array.Copy(poolValues, elementIndex + 1, poolValues, elementIndex, arraysCount - elementIndex);
            }
            elementsCount -= array.Length;
            return array;
        }

        /// <summary>
        /// <see cref="Array.BinarySearch(System.Array,int,int,object)"/>
        /// </summary>
        private static int BinarySearch(
            int[] array,
            int length,
            int value)
        {
            int num1 = 0;
            int num2 = length - 1;
            while (num1 <= num2)
            {
                int index1 = num1 + (num2 - num1 >> 1);
                int num3 = array[index1] - value;
                if (num3 == 0)
                    return index1;
                if (num3 < 0)
                    num1 = index1 + 1;
                else
                    num2 = index1 - 1;
            }
            return ~num1;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Arrays Pooling/Pools/ArrayPool.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Arrays Pooling/Pools/ArrayPoolUsageData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 496538c595f98984291012010b2f1e26
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

namespace ToolBuddy.Pooling.Pools
{
    /// <summary>
    /// Data about how full an <see cref="ArrayPool{T}"/> is
    /// </summary>
    public readonly struct ArrayPoolUsageData
    {
        /// <summary>
        /// The number of elements that the pool will keep, after they have been freed, to be available for future usage.
        /// </summary>
        /// <remarks>This is not the maximal number of arrays, but the maximal sum of the arrays' lengths</remarks>
        public long ElementsCount { get; }
        /// <summary>
        /// The number of arrays stored in the pool
        /// </summary>
        public int ArraysCount { get; }
        /// <summary>
        /// The maximal number of elements that the pool will keep, after they have been freed, to be available for future usage.
        /// Once this limit is reached, every freed array will simply get ignored, allowing the garbage collector to collect it
        /// </summary>
        /// <remarks>This is not the maximal number of arrays, but the maximal sum of the arrays' lengths</remarks>
        public long ElementsCapacity { get; }


        public ArrayPoolUsageData(long elementsCount, int arraysCount, long elementsCapacity)
        {
            ElementsCount = elementsCount;
            ArraysCount = arraysCount;
            ElementsCapacity = elementsCapacity;
        }

        public bool Equals(ArrayPoolUsageData other)
        {
            return ElementsCount == other.ElementsCount && ArraysCount == other.ArraysCount && ElementsCapacity == other.ElementsCapacity;
        }

        public override bool Equals(object obj)
        {
            return obj is ArrayPoolUsageData other && Equals(other);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                int hashCode = ElementsCount.GetHashCode();
                hashCode = (hashCode * 397) ^ ArraysCount;
                hashCode = (hashCode * 397) ^ ElementsCapacity.GetHashCode();
                return hashCode;
            }
        }

        public static bool operator ==(ArrayPoolUsageData a, ArrayPoolUsageData b)
        {
            return a.Equals(b);
        }

        public static bool operator !=(ArrayPoolUsageData a, ArrayPoolUsageData b)
        {
            return !(a == b);
        }

        public override string ToString()
        {
            return $"{nameof(ElementsCount)}: {ElementsCount}, {nameof(ArraysCount)}: {ArraysCount}, {nameof(ElementsCapacity)}: {ElementsCapacity}";
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Arrays Pooling/Pools/ArrayPoolUsageData.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/Base/ScalingModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 44a4898cf0e76b24ab93c0547cb50196
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Runtime.CompilerServices;
using FluffyUnderware.DevTools;
using ToolBuddy.Pooling.Collections;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    /// <summary>
    /// An enum indicating what type of scaling should be applied
    /// </summary>
    public enum ScaleMode
    {
        /// <summary>
        /// Simple uniform scaling
        /// </summary>
        Simple,
        /// <summary>
        /// More complex scaling parameters (scaling curves and whatnot)
        /// </summary>
        Advanced
    }

    /// <summary>
    /// A class used as a container of Scaling parameters found in <see cref="ScalingModule"/>
    /// </summary>
    public class ScaleParameters
    {
        /// <summary>
        /// <see cref="ScalingModule.ScaleMode"/>
        /// </summary>
        public readonly ScaleMode ScaleMode;
        /// <summary>
        /// <see cref="ScalingModule.ScaleReference"/>
        /// </summary>
        public readonly CGReferenceMode ScaleReference;
        /// <summary>
        /// <see cref="ScalingModule.ScaleUniform"/>
        /// </summary>
        public readonly bool ScaleUniform;
        /// <summary>
        /// <see cref="ScalingModule.ScaleOffset"/>
        /// </summary>
        public readonly float ScaleOffset;
        /// <summary>
        /// <see cref="ScalingModule.ScaleX;"/>
        /// </summary>
        public readonly float ScaleX;
        /// <summary>
        /// <see cref="ScalingModule.ScaleY"/>
        /// </summary>
        public readonly float ScaleY;
        /// <summary>
        /// <see cref="ScalingModule.ScaleMultiplierX"/>
        /// </summary>
        public readonly AnimationCurve ScaleMultiplierX;
        /// <summary>
        /// <see cref="ScalingModule.ScaleMultiplierY"/>
        /// </summary>
        public readonly AnimationCurve ScaleMultiplierY;

        public ScaleParameters(ScaleMode scaleMode, CGReferenceMode scaleReference, bool scaleUniform, float scaleOffset, float scaleX, float scaleY, AnimationCurve scaleMultiplierX, AnimationCurve scaleMultiplierY)
        {
            ScaleMode = scaleMode;
            ScaleReference = scaleReference;
            ScaleUniform = scaleUniform;
            ScaleOffset = scaleOffset;
            ScaleX = scaleX;
            ScaleY = scaleY;
            ScaleMultiplierX = scaleMultiplierX;
            ScaleMultiplierY = scaleMultiplierY;
        }
    }

    /// <summary>
    /// A base class for CG modules that wish to scale objects along a path or shape
    /// </summary>
    public abstract class ScalingModule : CGModule
    {
        #region ### Serialized Fields ###

        [Tab("Scale", Sort = 101)]
        [Label("Mode")]
        [SerializeField]
        [Tooltip("What type of scaling should be applied")]
        private ScaleMode m_ScaleMode = ScaleMode.Simple;

        [FieldCondition(nameof(m_ScaleMode), ScaleMode.Advanced)]
        [Label("Reference")]
        [SerializeField]
        [Tooltip(@"Determines on what range the scale is applied:
Self: the scale is applied over the Path's active range
Source: the scale is applied over the Path's total length")]
        private CGReferenceMode m_ScaleReference = CGReferenceMode.Self;

        [FieldCondition(nameof(m_ScaleMode), ScaleMode.Advanced)]
        [Label("Offset")]
        [SerializeField]
        [Tooltip("Scale is applied starting at this offset")]
        private float m_ScaleOffset;

        [SerializeField, Label("Uniform Scaling")]
        [Tooltip("If enabled, the same scale is applied to both X and Y axis of the cross section")]
        private bool m_ScaleUniform = true;

        [SerializeField]
        [Tooltip("The (base) value of the scaling along the cross section's X axis, and Y axis if Uniform Scaling is disabled")]
        private float m_ScaleX = 1;

        [SerializeField]
        [FieldCondition(nameof(m_ScaleMode), ScaleMode.Advanced)]
        [AnimationCurveEx("    Multiplier")]
        [Tooltip("Defines scale multiplier, depending on the Relative Distance (between 0 and 1) of a point on the path")]
        private AnimationCurve m_ScaleCurveX = AnimationCurve.Linear(0, 1, 1, 1);

        [SerializeField]
        [FieldCondition(nameof(m_ScaleUniform), false)]
        [Tooltip("The (base) value of the scaling along the cross section's Y axis")]
        private float m_ScaleY = 1;

        [SerializeField]
        [FieldCondition(nameof(m_ScaleUniform), false, false, ConditionalAttribute.OperatorEnum.AND, "m_ScaleMode", ScaleMode.Advanced, false)]
        [AnimationCurveEx("    Multiplier")]
        [Tooltip("Defines scale multiplier, depending on the Relative Distance (between 0 and 1) of a point on the path")]
        private AnimationCurve m_ScaleCurveY = AnimationCurve.Linear(0, 1, 1, 1);


        #endregion

        #region ### Public Properties ###

        /// <summary>
        /// <see cref="Modules.ScaleMode"/>
        /// </summary>
        public ScaleMode ScaleMode
        {
            get { return m_ScaleMode; }
            set
            {
                if (m_ScaleMode != value)
                    m_ScaleMode = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// Determines on what range the scale is applied:
        /// <see cref="CGReferenceMode.Self"/>: the scale is applied over the Path's active range
        /// <see cref="CGReferenceMode.Source"/>: the scale is applied over the Path's total length
        /// </summary>
        /// <remarks>Considered only when <see cref="ScaleMode"/> is set to <see cref="Modules.ScaleMode.Advanced"/> </remarks>
        public CGReferenceMode ScaleReference
        {
            get { return m_ScaleReference; }
            set
            {
                if (m_ScaleReference != value)
                    m_ScaleReference = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// If enabled, the same scale is applied to both X and Y axis of the cross section
        /// </summary>
        public bool ScaleUniform
        {
            get { return m_ScaleUniform; }
            set
            {
                if (m_ScaleUniform != value)
                    m_ScaleUniform = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// Scale is applied starting at this offset 
        /// </summary>
        /// <remarks>Considered only when <see cref="ScaleMode"/> is set to <see cref="Modules.ScaleMode.Advanced"/> </remarks>
        public float ScaleOffset
        {
            get { return m_ScaleOffset; }
            set
            {
                if (m_ScaleOffset != value)
                    m_ScaleOffset = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// The (base) value of the scaling along the cross section's X axis
        /// </summary>
        public float ScaleX
        {
            get { return m_ScaleX; }
            set
            {
                if (m_ScaleX != value)
                    m_ScaleX = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// Defines a scale multiplier relatively to the Relative Distance of a point on the path.
        /// </summary>
        /// <remarks>Considered only when <see cref="ScaleMode"/> is set to <see cref="Modules.ScaleMode.Advanced"/> </remarks>
        /// <remarks>You will need to set this module's Dirty to true yourself if you modify the AnimationCurve without setting a new one</remarks>
        public AnimationCurve ScaleMultiplierX
        {
            get { return m_ScaleCurveX; }
            set
            {
                if (m_ScaleCurveX != value)
                    m_ScaleCurveX = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// The (base) value of the scaling along the cross section's Y axis if <see cref="ScaleUniform"/> is set to false, otherwise the <see cref="ScaleX"/> value is used instead
        /// </summary>
        public float ScaleY
        {
            get { return m_ScaleY; }
            set
            {
                if (m_ScaleY != value)
                    m_ScaleY = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// Defines a scale multiplier relatively to the Relative Distance of a point on the path.
        /// </summary>
        /// <remarks>Considered only when <see cref="ScaleMode"/> is set to <see cref="Modules.ScaleMode.Advanced"/> </remarks>
        /// <remarks>You will need to set this module's Dirty to true yourself if you modify the AnimationCurve without setting a new one</remarks>
        public AnimationCurve ScaleMultiplierY
        {
            get { return m_ScaleCurveY; }
            set
            {
                if (m_ScaleCurveY != value)
                    m_ScaleCurveY = value;
                Dirty = true;
            }
        }

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            //TODO OPTIM each one of the following properties setting will set Dirty to true, and trigger a lot of work. You can avoid that by Dirty to true only once per OnValidate call
            ScaleMode = m_ScaleMode;
            ScaleReference = m_ScaleReference;
            ScaleUniform = m_ScaleUniform;
            ScaleOffset = m_ScaleOffset;
            ScaleX = m_ScaleX;
            ScaleY = m_ScaleY;
            ScaleMultiplierX = m_ScaleCurveX;
            ScaleMultiplierY = m_ScaleCurveY;
        }
#endif

        public override void Reset()
        {
            base.Reset();
            ScaleMode = ScaleMode.Simple;
            ScaleUniform = true;
            ScaleX = 1;
            ScaleY = 1;
            ScaleMultiplierX = AnimationCurve.Linear(0, 1, 1, 1);
            ScaleMultiplierY = AnimationCurve.Linear(0, 1, 1, 1);
            ScaleReference = CGReferenceMode.Self;
            ScaleOffset = 0;
        }


        /*! \endcond */
        #endregion

        #region ### Public Methods ###
        /// <summary>
        /// Gets the scale vector of a cross section at a specific position on a path
        /// </summary>
        /// <param name="relativeDistance">A value between 0 and 1 representing how far the point is on a pah.
        /// A value of 0 means the start of the path, and a value of 1 means the end of it. It is defined as: (the point's distance from the path's start) / (the total length of the path)</param>
        /// <returns> The X and Y value are the scale value along those axis</returns>
        public Vector2 GetScale(float relativeDistance)
        {
            return GetScale(relativeDistance, ScaleMode, ScaleOffset, ScaleUniform, ScaleX, ScaleMultiplierX, ScaleY, ScaleMultiplierY);
        }
        #endregion

        #region ### Protected ###

        /// <summary>
        /// Get the scale value along the x and y axis for a point on a path
        /// </summary>
        /// <param name="sampleIndex">the index of the point in the path's <see cref="CGShape.RelativeDistances"/> and <see cref="CGShape.SourceRelativeDistances"/></param>
        /// <param name="relativeDistances"><see cref="CGShape.RelativeDistances"/></param>
        /// <param name="sourceRelativeDistances"><see cref="CGShape.SourceRelativeDistances"/></param>
        /// <returns></returns>
        /// <exception cref="ArgumentOutOfRangeException">If <see cref="ScaleMode"/> has an invalid value</exception>
        protected Vector2 GetScale(int sampleIndex, SubArray<float> relativeDistances, SubArray<float> sourceRelativeDistances)
        {
            Vector2 result;

            switch (ScaleMode)
            {
                case ScaleMode.Advanced:
                    float relativeDistance = GetRelativeDistance(sampleIndex, ScaleReference, relativeDistances, sourceRelativeDistances);

                    result = GetAdvancedScale(relativeDistance, ScaleOffset, ScaleUniform, ScaleX, ScaleMultiplierX, ScaleY, ScaleMultiplierY);
                    break;
                case ScaleMode.Simple:
                    result = GetSimpleScale(ScaleUniform, ScaleX, ScaleY);
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            return result;
        }

        /// <summary>
        /// Get the scale value along the x and y axis for a point on a path
        /// </summary>
        /// <param name="relativeDistance">A value between 0 and 1 representing how far the point is on a pah.
        /// A value of 0 means the start of the path, and a value of 1 means the end of it. It is defined as: (the point's distance from the path's start) / (the total length of the path)</param>
        /// <param name="mode"><see cref="ScaleMode"/></param>
        /// <param name="offset"><see cref="ScaleOffset"/></param>
        /// <param name="isUniform"><see cref="ScaleUniform"/></param>
        /// <param name="scaleX"><see cref="ScaleX"/></param>
        /// <param name="scaleMultiplierX"><see cref="ScaleMultiplierX"/></param>
        /// <param name="scaleY"><see cref="ScaleY"/></param>
        /// <param name="scaleMultiplierY"><see cref="ScaleMultiplierY"/></param>
        /// <exception cref="ArgumentOutOfRangeException">If <paramref name="mode"/>
        ///     has an invalid value</exception>
        protected static Vector2 GetScale(float relativeDistance, ScaleMode mode, float offset, bool isUniform, float scaleX, AnimationCurve scaleMultiplierX, float scaleY, AnimationCurve scaleMultiplierY)
        {
            Vector2 result;

            switch (mode)
            {
                case ScaleMode.Advanced:
                    result = GetAdvancedScale(relativeDistance, offset, isUniform, scaleX, scaleMultiplierX, scaleY, scaleMultiplierY);
                    break;
                case ScaleMode.Simple:
                    result = GetSimpleScale(isUniform, scaleX, scaleY);
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            return result;
        }

        /// <summary>
        /// Get the relative distance of a sample point
        /// </summary>
        /// <param name="sampleIndex">the index of the sample point in the path's <see cref="CGShape.RelativeDistances"/> and <see cref="CGShape.SourceRelativeDistances"/></param>
        /// <param name="cgReferenceMode"><see cref="ScaleReference"/></param>
        /// <param name="relativeDistances"><see cref="CGShape.RelativeDistances"/></param>
        /// <param name="sourceRelativeDistances"><see cref="CGShape.SourceRelativeDistances"/></param>
        /// <returns></returns>
        /// <exception cref="ArgumentOutOfRangeException">If <paramref name="cgReferenceMode"/> has an invalid value</exception>
        protected static float GetRelativeDistance(int sampleIndex, CGReferenceMode cgReferenceMode, SubArray<float> relativeDistances, SubArray<float> sourceRelativeDistances)
        {
            float relativeDistance;
            {
                SubArray<float> scaleRelativeDistancesArray;
                switch (cgReferenceMode)
                {
                    case CGReferenceMode.Source:
                        scaleRelativeDistancesArray = sourceRelativeDistances;
                        break;
                    case CGReferenceMode.Self:
                        scaleRelativeDistancesArray = relativeDistances;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }

                relativeDistance = scaleRelativeDistancesArray.Array[sampleIndex];
            }
            return relativeDistance;
        }

        /// <summary>
        /// Get the scale value along the x and y axis for a point on a path
        /// </summary>
        /// <param name="relativeDistance">A value between 0 and 1 representing how far the point is on a pah.
        /// A value of 0 means the start of the path, and a value of 1 means the end of it. It is defined as: (the point's distance from the path's start) / (the total length of the path)</param>
        /// <param name="scaleOffset"><see cref="ScaleOffset"/></param>
        /// <param name="isUniform"><see cref="ScaleUniform"/></param>
        /// <param name="scaleX"><see cref="ScaleX"/></param>
        /// <param name="scaleMultiplierX"><see cref="ScaleMultiplierX"/></param>
        /// <param name="scaleY"><see cref="ScaleY"/></param>
        /// <param name="scaleMultiplierY"><see cref="ScaleMultiplierY"/></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected static Vector2 GetAdvancedScale(float relativeDistance, float scaleOffset, bool isUniform, float scaleX, AnimationCurve scaleMultiplierX, float scaleY, AnimationCurve scaleMultiplierY)
        {
            //Optim: avoid calling unnecessarily. This means that if the curve is a constant 1, there is no need to evaluate the curve. Use AnimationCurveExt.ValueIsOne to know if this condition is true.
            //Of course, calling ValueIsOne everytime will be not worth it. You will need to cache the value of ValueIsOne at every modification of the curves

            Vector2 result;
            float scaleFValue = DTMath.Repeat(relativeDistance - scaleOffset, 1);
            float x = scaleX * scaleMultiplierX.Evaluate(scaleFValue);

            result.x = x;
            result.y = isUniform ? x : scaleY * scaleMultiplierY.Evaluate(scaleFValue);
            return result;
        }

        /// <summary>
        /// Get the scale value along the x and y axis
        /// </summary>
        /// <param name="isUniform"><see cref="ScaleUniform"/></param>
        /// <param name="scaleX"><see cref="ScaleX"/></param>
        /// <param name="scaleY"><see cref="ScaleY"/></param>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected static Vector2 GetSimpleScale(bool isUniform, float scaleX, float scaleY)
        {
            Vector2 result;
            result.x = scaleX;
            result.y = isUniform ? scaleX : scaleY;
            return result;
        }
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/Base/ScalingModule.cs

