# CONSOLIDATED: Framework.Editor
# GENERATED: 2025-11-05 11:08:24
# PART: 1
# FILE COUNT (part): 323
# LINE ENDINGS: LF
# ENCODING: UTF-8 (no BOM)
# INDEX BEGIN
# SYSTEM: com_ldx_frameworkSystem (323 files)
#   Packages/com_ldx_framework/AddOns/Analytics/Editor/Scripts/Attributes/MetricConfigContainerDrawer.cs
#   Packages/com_ldx_framework/AddOns/Analytics/Editor/Scripts/Attributes/ObjectiveIDSelectionDrawer.cs
#   Packages/com_ldx_framework/AddOns/SeuratCapture/Editor/Scripts/CaptureHeadboxEditor.cs
#   Packages/com_ldx_framework/AddOns/SeuratCapture/Editor/Scripts/CaptureProgressWindow.cs
#   Packages/com_ldx_framework/AddOns/SeuratCapture/Editor/Scripts/HDRPCaptureProcess.cs
#   Packages/com_ldx_framework/Editor/AssetInfo.cs
#   Packages/com_ldx_framework/Editor/AssetProcessor.cs
#   Packages/com_ldx_framework/Editor/ProjectCurator.cs
#   Packages/com_ldx_framework/Editor/ProjectCuratorData.cs
#   Packages/com_ldx_framework/Editor/ProjectCuratorWindow.cs
#   Packages/com_ldx_framework/Editor/ProjectIcons.cs
#   Packages/com_ldx_framework/Editor/ProjectWindowOverlay.cs
#   Packages/com_ldx_framework/Editor/Scripts/Features/Animation/AnimationObjectDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Features/CheckLODSetupEditorFeature.cs
#   Packages/com_ldx_framework/Editor/Scripts/Features/EditorBuildMenu.cs
#   Packages/com_ldx_framework/Editor/Scripts/Features/Hierarchy/HierarchyStateSaverEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Features/Highlighting/HighlightingLayerSanitizationSavingAddOn.cs
#   Packages/com_ldx_framework/Editor/Scripts/Features/Interaction/TransformKinematicGrabbableEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Features/Machinery/MachineModuleContainerDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Features/Machinery/MachineryControlsWindow.cs
#   Packages/com_ldx_framework/Editor/Scripts/Features/Measurement/RulerEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Features/ProjectDefinesFeatures.cs
#   Packages/com_ldx_framework/Editor/Scripts/Features/Splines/SplineMasterControllerEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Features/Visual/MaterialConverter.cs
#   Packages/com_ldx_framework/Editor/Scripts/Features/Visual/Tweening/ObjectTweenerEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/AddOns/AddOnConfigsGlobalDataSanitization.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/AudioSystem/AudioEmitterEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/AudioSystem/AudioGlobalSettingsEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/AudioSystem/SceneAudioManagerEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Events/EditorEventTrackingContainer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Events/LdxEventNotifierEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Events/LiveEventTrackingWindow.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/InternalDebug/DebugFeaturesEditorWindow.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/BaseLocalizationDataEntry.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/LocalizationExportImportEditorFeatures.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/LocalizationKeyPropertyDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/LocalizationPreBuild.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/LocalizationTableButton.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/LocalizationTableContainer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/LocalizationWindowEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/LocalizedAudioClipDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/TextLocalizationDataEntry.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/BaseCreateNodeMenuWindow.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/BaseEdgeConnectorListener.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/BaseGraphView.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/BaseNode.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/DoubleClickSelection.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/GroupView.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/NodeGroup.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/PortView.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/SplitView.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/AddInteractionIDsOnSceneSaving.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/DialogsEditorFeatures.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/DialogueEditor/DialogueViewObjectiveRow.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/DialogueEditor/DialogueViewReactiveEntry.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/DialogueEditorWindow.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/EventDataContainerDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/HighlighterObjectInfoDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/ID/IDContainerExtensionsSceneSavingAddOn.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/IdentificationDataDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/IDInfoContainerDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/LdxIdSettingsEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/BaseObjectiveNode.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/DocumentationView.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/IDCreationPopup.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/InspectorView.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveConditionElement.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveDataSelectionWindow.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveDataView.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveEventMasterNode.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveEventNode.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveEventsGraphView.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveNode.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveSystemEditorWindow.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/OptionElement.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/SerializedObjectiveData.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/TriggerEventNode.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/Tracking/LdxTrackingManagerEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Player/PlayerRig/PlayerRigOverridesContainerDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Player/RandomizedStartPointControllerEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Player/StartPointEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Save/LdxSaveSystemEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioManagement/Data/PlayerRigDataEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioManagement/RuntimeScenarioLoaderEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioManagement/SingleScenarioPlayModeEditorFeature.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/BaseScenarioWindowTab.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/Helpers/NewScenarioEditorWindow.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/Helpers/ScenarioWindowHelper.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/Helpers/SceneSetupEditorFeatures.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/Helpers/SceneSetupObjectDefinition.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/ScenarioManagementEditorWindow.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/Tabs/ManageScenarioTab.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/Tabs/ScenarioSetupTab.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/Tabs/SceneSetupTab.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Scenes/CloneTemplatesToResourcesSavingAddOn.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Scenes/LogicalDoxFrameworkSceneMenu.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Scenes/RequireComponentInSceneSavingAddOn.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Scenes/SceneModelInfoViewer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Scenes/SceneSavingNotifier.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Scoring/ScenarioScoringDataEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Scoring/ScoreRuleDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/Sound/LdxSoundManagerExtensionEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/UI/AnchorControllerEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/UI/SegmentAnchorControllerEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/UI/UIAnchorEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/UI/UIAnchorGroupEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Systems/UI/UITweenedStatesEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Animation/DoTweenAnimationEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/AssetsCheckout/AssetCheckoutItem.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/AssetsCheckout/AssetCheckoutItemVisual.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/AssetsCheckout/AssetsCheckoutWindow.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/AssetsCheckout/ProjectNameData.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/GroupDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/HelpBoxDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/HelpUrlDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/HideDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/IDSelectionAllDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/IDSelectionDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/IDSelectionShowIfEventTypeDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/InheritedClassContainerDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/InheritedClassDropdownDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/NoteAttributeDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/ReadOnlyDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/RequireInterfaceDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/SerializableContainerDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/ShowIfDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/ShowWhenEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/SoundReferenceDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/AutoSave/AutoSave.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Bakery/BakeryPathOverride.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/DynamicMenuItem.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/ExportImportScene/ExportSceneWindow.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/ExportImportScene/ExportWindowController.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/ExportImportScene/ImportSceneWindow.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Extensions/RectExtension.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/FlyingCamera.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/FrameworkSync/FrameworkSyncerWindow.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/FrameworkSync/SyncHelper.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/FrameworkSync/UserActionsSectionsDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/DocumentationHelper.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/GitHelper.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/LdxEditorHelper.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/ModalEditorWindow.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/PackagesHelper.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/ProcessHelper.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/ScenarioEditorHelper.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/SystemExtensions.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Hierarchy/HierarchyEditorFeatures.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Hierarchy/HierarchyLockedAssetDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/LdxEditorUtilities.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/LdxProjectSettingsWindow.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/LdxProjectSettingsWindow.SettingsTab.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Logger/LogVerbositySettingArrayDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/NoteEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/PathFinding/GraphNodeEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/ScenarioScriptGenerator/ScenarioScriptGenerator.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/ScriptableSingletonEditorInitializer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Serializable/ListHashSetDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Serializable/SerializableDictionaryPropertyDrawer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Seurat/EnvironmentTransitionControllerEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Seurat/SeuratEnvironmentEditor.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/FilterVisualizer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/RolloffVisualizer.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/SelectableElement.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/SelectableFolder.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/SelectableSound.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/SoundBrowserContextMenu.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/SoundBrowserWindow.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/SoundPlayerEditorWindow.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/ConvertToStandardShader.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/CopyLightingSettingsWindow.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/EditorAssemblySanitizationTools.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/IDSelectionOperation.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/LdxSelectCommonMenu.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/MigrateSelectionOperation.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/SceneSelectionToolbarMenu.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/SelectObjectsWithMissingScripts.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/ToolNameButton.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/ToolNameChanger.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/GrabbingSocketingOperations.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/HighlightingOperations.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/MakeInteractableObjectOperation.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/MakePPEObjectOperation.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/MeshesCollidersOperations.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/ObjectivesOperations.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/RenderingShadersOperations.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/SetupInstallObjectFeatureOperation.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/SetupInteractableObjectOperation.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/SplineOperations.cs
#   Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/SetupWizardEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftAdditionalConfig.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftAtlasPreview.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftBuildGraphics.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftBuildLights.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftClearCache.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftClearMenu.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftClient.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftCreateMenu.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftDDS.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftDefine.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftDetectSettings.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftDirectLightInspector.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftErrorCodes.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftExtendLightmapParameters.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftFixResettingGlobalsOnSave.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftLightingDataGen.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftLightmappedPrefabInspector.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftLightmapsStorageInspector.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftLightMeshInspector.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftLMGroupInspector.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftLMGroupSelectorInspector.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftModelPostProcessor.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftPointLightInspector.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftRenderLightmap.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftRestorePaddingMenu.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftSavedPadding2.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftSavePadding.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftSaveSettingsMenu.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftSceneView.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftSectorInspector.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftSettingsProvider.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftShaderTweaks.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftSkyLightInspector.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftTextureProcessor.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftUpdater.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftUVGBufferGen.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftVolumeInspector.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/xatlas/xatlas.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/xatlas/xatlasEnable.cs
#   Packages/com_ldx_framework/Editor/Third Party/Bakery/shader/BakeryShaderGUI.cs
#   Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EdgeGUI.cs
#   Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EdgeTriggersTracker.cs
#   Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EditorZoomArea.cs
#   Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventCall.cs
#   Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventsGraph.cs
#   Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventsGraphGUI.cs
#   Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventsGraphWindow.cs
#   Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventsVisualizer.cs
#   Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/FindInGraphButton.cs
#   Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/NodeData.cs
#   Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/NodeGUI.cs
#   Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/PuppyEditor/EditorHelper.cs
#   Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/CallbackManager.cs
#   Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/ConditionWrapper.cs
#   Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/EditorLayoutDataBuilder.cs
#   Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/HeaderlessMaterialEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/InspectorLayoutController.cs
#   Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/InspectorLayoutGroup.cs
#   Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkedUpEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkedUpShaderGUI.cs
#   Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupAttributesPrefs.cs
#   Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupAttributesPrefsEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupEditorUtils.cs
#   Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupGUI.cs
#   Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupStyles.cs
#   Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MaterialPropertiesWrapper.cs
#   Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/PropertyLayoutData.cs
#   Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/SerializedDictionaryHandler.cs
#   Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/ShaderAttributesParser.cs
#   Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/TargetObjectWrapper.cs
#   Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/TogglableValueWrapper.cs
#   Packages/com_ldx_framework/Editor/Third Party/Rope/Core/DisableInPlayModePropertyDrawer.cs
#   Packages/com_ldx_framework/Editor/Third Party/Rope/Core/RopeEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/00_Main/ApplyTorqueOnKey.cs
#   Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/00_Main/RopeBridgePlank.cs
#   Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/00_Main/RopeMouseInteraction.cs
#   Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/00_Main/SoftBackdrop/SoftBackdrop.cs
#   Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/01_DynamicAttach/BackAndForthMovement.cs
#   Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/01_DynamicAttach/DynamicAttach.cs
#   Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/02_BoxingRing/Spawner.cs
#   Packages/com_ldx_framework/Editor/Third Party/SplineMesh/Editor/SplineEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/SplineMesh/Editor/SplineExtrusionEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Curvy Examples/Editor/E01_HeightMetadataEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/AboutWindow.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildRasterizedPathEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildShapeExtrusionEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildVolumeCapsEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildVolumeMeshEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildVolumeSpotsEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ConformPathEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/CreateGameObjectEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/CreateMeshEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/CreatePathLineRendererEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/DebugRasterizedPathEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/DebugVMeshEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/DebugVolumeEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/DeformMeshEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/GameObjectToMeshEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputGameObjectEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputMeshEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputSplinePathEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputSplineShapeEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputSpotsEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputTransformSpotsEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/MixShapesEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierMixPathsEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierPathRelativeTranslationEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierTRSMeshEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierTRSPathEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierTRSShapeEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierVariableMixShapesEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/NoteEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CanvasSelection.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CanvasState.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CanvasUI.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CGEditorUtility.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CGGraph.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CGModuleEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CGResourceEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CurvyGeneratorEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/MetaCGOptionsEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/CurvyControllerEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/MoveModeDrawer.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/OnPositionReachedSettingsDrawer.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/PathControllerEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/SplineControllerEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/VolumeControllerEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyConnectionEditor.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyEditorBase.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyEditorUtility.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyMenu.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyPositionModeDrawer.cs
#   Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyProject.cs
# INDEX END
#
# FILE: Packages/com_ldx_framework/AddOns/Analytics/Editor/Scripts/Attributes/MetricConfigContainerDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 252d02a5a12f4400bfb6a379c1630f46
# ASMDEF: ldx.analytics.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Ldx.Framework.AddOns.Analytics.Config;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.AddOns.Analytics.Attributes
{
    /// <summary>
    /// Drawer for the metric config container
    /// </summary>
    [CustomPropertyDrawer(typeof(MetricConfigContainerAttribute))]
    public class MetricConfigContainerDrawer : SerializableContainerDrawer
    {
        protected override void AddButtonPressed(SerializedProperty property, SerializedProperty arrayProperty)
        {
            GenericMenu menu = new GenericMenu();
            List<Type> subclassTypes = new List<Type>();
            foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                subclassTypes.AddRange(assembly.GetTypes()
                    .Where(t => t.IsSubclassOf(typeof(BaseMetricConfig)) && !t.IsAbstract));
            }

            subclassTypes.OrderBy(t => t.Name);
            foreach (Type t in subclassTypes)
            {
                menu.AddItem(new GUIContent(t.Name.Replace("Config","").SeparateWords()), 
                    false, ()=> HandleAddingAnalyticsTrackingData(property, arrayProperty, t));
                        
            }
            menu.ShowAsContext();
        }
        
        private void HandleAddingAnalyticsTrackingData(SerializedProperty property, SerializedProperty arrayProperty, Type t)
        {
            arrayProperty.arraySize++;
            arrayProperty.GetArrayElementAtIndex(arrayProperty.arraySize - 1).managedReferenceValue = Activator.CreateInstance(t);
            property.serializedObject.ApplyModifiedProperties();
        }

        protected override string GetElementName(SerializedProperty property)
        {
            string[] segments = property.type.Split(new[] {'<', '>'});
            if (segments.Length < 2)
            {
                return "";
            }
            return segments[1].Replace("Config", "").SeparateWords();
        }
    }
}
# --- end Packages/com_ldx_framework/AddOns/Analytics/Editor/Scripts/Attributes/MetricConfigContainerDrawer.cs

# FILE: Packages/com_ldx_framework/AddOns/Analytics/Editor/Scripts/Attributes/ObjectiveIDSelectionDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 12f04792018ace942a3cf917aff4d2c7
# ASMDEF: ldx.analytics.editor.dll
# ---
using System.Linq;
using System.Text.RegularExpressions;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Utilities.Attributes;
using UnityEditor;

namespace Ldx.Framework.AddOns.Analytics.Attributes
{
    /// <summary>
    /// Custom drawer that provides a dropdown of the ID selections tied
    /// to a specific scenario
    /// </summary>
    [CustomPropertyDrawer(typeof(ObjectiveIDSelectionAttribute))]
    public class ObjectiveIDSelectionDrawer : IDSelectionDrawer
    {
        private CompoundIDInfoContainer compoundIDInfoContainer;
        private string lastScenarioId;
        private ObjectiveIDSelectionAttribute Attribute => (ObjectiveIDSelectionAttribute)attribute;
        protected override string NoIdInfoContainerMessage => "ID Settings not retrieved - please set a valid Scenario ID";
        
        protected override CompoundIDInfoContainer GetCompoundIDInfoContainer(SerializedProperty property)
        {
            int scenarioIndex = GetArrayIndexFromPropertyPath(property.propertyPath);
            
            SerializedProperty scenarioAnalyticsListProperty = property.serializedObject.FindProperty("scenarioMetrics");
            if (scenarioAnalyticsListProperty == null)
            {
                return null;
            }
            SerializedProperty scenarioAnalyticsElementProperty = GetElementAtIndex(scenarioAnalyticsListProperty, scenarioIndex);

            if (scenarioAnalyticsElementProperty == null)
            {
                return null;
            }
            
            SerializedProperty scenarioIdProperty = scenarioAnalyticsElementProperty.FindPropertyRelative(Attribute.ScenarioIDFieldName);
            
            if (scenarioIdProperty == null)
            {
                return null;
            }

            string scenarioId = scenarioIdProperty.stringValue;

            if (scenarioId != lastScenarioId)
            {
                compoundIDInfoContainer = null;
            }
            
            if (compoundIDInfoContainer != null)
            {
                return compoundIDInfoContainer;
            }

            lastScenarioId = scenarioId;
            
            LdxIdSettings settings = LdxIdSettings
                .GetAllIDSettings()
                .FirstOrDefault(idSettings => idSettings.AssociatedScenarioID == scenarioId);
            
            if (settings == null)
            {
                return null;
            }

            compoundIDInfoContainer = LdxIdSettings.GetCompoundIDList(Attribute.idType, settings);
            return compoundIDInfoContainer;
        }
        
        private int GetArrayIndexFromPropertyPath(string propertyPath)
        {
            Regex regex = new Regex(@"\d+");
            Match match = regex.Match(propertyPath);
            if (match.Success) {
                int index;
                if (int.TryParse(match.Value, out index)) {
                    return index;
                }
            }
            return -1; // If no index is found
        }

        private SerializedProperty GetElementAtIndex(SerializedProperty listProperty, int index) {
            if (index >= 0 && index < listProperty.arraySize) {
                return listProperty.GetArrayElementAtIndex(index);
            }
            return null;
        }
    }
}
# --- end Packages/com_ldx_framework/AddOns/Analytics/Editor/Scripts/Attributes/ObjectiveIDSelectionDrawer.cs

# FILE: Packages/com_ldx_framework/AddOns/SeuratCapture/Editor/Scripts/CaptureHeadboxEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b1cf2f6c734afe1468b838d5fbddac4c
# ASMDEF: editor.seurat.capture.dll
# ---
/*
Copyright 2017 Google Inc. All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEditor;
using UnityEditor.SceneManagement;
using System.Collections.Generic;
using System.IO;
using Unity.EditorCoroutines.Editor;


// Reflects status updates back to CaptureWindow, and allows CaptureWindow to
// notify capture/baking tasks to cancel.
class EditorBakeStatus : CaptureStatus
{
	bool task_cancelled_ = false;
	CaptureWindow bake_gui_;

	public override void SendProgress(string message, float fraction_complete)
	{
		bake_gui_.SetProgressBar(message, fraction_complete);
	}

	public override bool TaskContinuing()
	{
		return !task_cancelled_;
	}

	public void SetGUI(CaptureWindow bake_gui)
	{
		bake_gui_ = bake_gui;
	}

	public void CancelTask()
	{
		Debug.Log("User canceled capture processing.");
		task_cancelled_ = true;
	}
}

// Provides an interactive modeless GUI during the capture and bake process.
class CaptureWindow : EditorWindow
{
	// Defines a state machine flow for the capture and bake process.
	enum BakeStage
	{
		kInitialization,
		kCapture,

		// This stage indicates the GUI is waiting for user to dismiss the window
		// by pressing a "Done" button.
		kWaitForDoneButton,
		kComplete,
	}

	const float kTimerInterval = 0.016f;
	const int kTimerExpirationsPerCapture = 4;

	float last_time_;
	float ui_timer_ = 0.25f;
	int capture_timer_;

	string progress_message_;

	float progress_complete_;

	// The headbox component receives notification that capture is complete to
	// update the Inspector GUI, e.g. unlock the Capture button.
	CaptureHeadbox capture_notification_component_;
	CaptureBuilder monitored_capture_;
	EditorBakeStatus capture_status_;

	BakeStage bake_stage_ = BakeStage.kInitialization;

	public void SetupStatus(EditorBakeStatus capture_status)
	{
		capture_status_ = capture_status;
		capture_status_.SetGUI(this);
	}

	public void SetupCaptureProcess(CaptureHeadbox capture_notification_component,
		CaptureBuilder capture)
	{
		capture_timer_ = kTimerExpirationsPerCapture;
		bake_stage_ = BakeStage.kCapture;
		last_time_ = Time.realtimeSinceStartup;
		capture_notification_component_ = capture_notification_component;
		monitored_capture_ = capture;
	}

	public void SetProgressBar(string message, float fraction_complete)
	{
		progress_message_ = message;
		progress_complete_ = fraction_complete;
	}

	public void OnGUI()
	{
		// Reserve layout space for the progress bar, equal to the space for a
		// textfield:
		Rect progress_rect = GUILayoutUtility.GetRect(18, 18, "TextField");
		EditorGUI.ProgressBar(progress_rect, progress_complete_, progress_message_);
		EditorGUILayout.Space();

		if (bake_stage_ != BakeStage.kWaitForDoneButton)
		{
			if (GUILayout.Button("Cancel"))
			{
				if (capture_status_ != null)
				{
					capture_status_.CancelTask();
				}
			}
		}

		if (bake_stage_ == BakeStage.kWaitForDoneButton)
		{
			if (GUILayout.Button("Done"))
			{
				bake_stage_ = BakeStage.kComplete;
			}
		}
	}

	private bool UpdateAndCheckUiTimerReady()
	{
		bool ui_timer_ready = false;
		float delta_time = Time.realtimeSinceStartup - last_time_;
		last_time_ = Time.realtimeSinceStartup;
		ui_timer_ -= delta_time;
		if (ui_timer_ <= 0.0f)
		{
			ui_timer_ready = true;
			// Prevent the timer from going infinitely negative due to large real time
			// intervals, e.g. from slow frame capture rendering.
			if (ui_timer_ <= -kTimerInterval)
			{
				ui_timer_ = 0.0f;
			}

			ui_timer_ += kTimerInterval;
		}

		return ui_timer_ready;
	}

	public void Update()
	{
		if (capture_status_ != null && capture_status_.TaskContinuing() && !UpdateAndCheckUiTimerReady())
		{
			return;
		}

		// Refresh the Editor GUI to finish the task.
		EditorUtility.SetDirty(capture_notification_component_);

		if (bake_stage_ == BakeStage.kCapture)
		{
			--capture_timer_;
			if (capture_timer_ == 0)
			{
				capture_timer_ = kTimerExpirationsPerCapture;

				monitored_capture_.RunCapture();

				if (monitored_capture_.IsCaptureComplete() &&
				    capture_status_.TaskContinuing())
				{
					monitored_capture_.EndCapture();
					monitored_capture_ = null;

					bake_stage_ = BakeStage.kWaitForDoneButton;
				}
			}

			if (capture_status_ != null && !capture_status_.TaskContinuing())
			{
				bake_stage_ = BakeStage.kComplete;
				if (monitored_capture_ != null)
				{
					monitored_capture_.EndCapture();
					monitored_capture_ = null;
				}
			}
		}

		// Repaint with updated progress the GUI on each wall-clock time tick.
		Repaint();
	}

	public bool IsComplete()
	{
		return bake_stage_ == BakeStage.kComplete;
	}
};


// Implements the Capture Headbox component Editor panel.
[CustomEditor(typeof(CaptureHeadbox))]
public class CaptureHeadboxEditor : Editor
{
	public static readonly string kSeuratCaptureDir = "SeuratCapture";

	SerializedProperty output_folder_;
	SerializedProperty size_;
	SerializedProperty samples_;
	SerializedProperty center_resolution_;
	SerializedProperty resolution_;
	SerializedProperty dynamic_range_;
	SerializedProperty last_output_dir_;

	EditorBakeStatus capture_status_;
	CaptureWindow bake_progress_window_;
	CaptureBuilder capture_builder_;

	void OnEnable()
	{
		output_folder_ = serializedObject.FindProperty("output_folder_");
		size_ = serializedObject.FindProperty("size_");
		samples_ = serializedObject.FindProperty("samples_per_face_");
		center_resolution_ = serializedObject.FindProperty("center_resolution_");
		resolution_ = serializedObject.FindProperty("resolution_");
		dynamic_range_ = serializedObject.FindProperty("dynamic_range_");
		last_output_dir_ = serializedObject.FindProperty("last_output_dir_");
	}

	public override void OnInspectorGUI()
	{
		serializedObject.Update();

		EditorGUILayout.PropertyField(output_folder_, new GUIContent(
			"Output Folder"));
		if (GUILayout.Button("Choose Output Folder"))
		{
			string path = EditorUtility.SaveFolderPanel(
				"Choose Capture Output Folder", output_folder_.stringValue, "");
			if (path.Length != 0)
			{
				output_folder_.stringValue = path;
			}
		}

		EditorGUILayout.PropertyField(size_, new GUIContent("Headbox Size"));
		EditorGUILayout.PropertyField(samples_, new GUIContent("Sample Count"));
		EditorGUILayout.PropertyField(center_resolution_, new GUIContent(
			"Center Capture Resolution"));
		EditorGUILayout.PropertyField(resolution_, new GUIContent(
			"Default Resolution"));
		EditorGUILayout.PropertyField(dynamic_range_, new GUIContent(
			"Dynamic Range"));

		EditorGUILayout.PropertyField(last_output_dir_, new GUIContent(
			"Last Output Folder"));

		if (capture_status_ != null)
		{
			GUI.enabled = false;
		}


		if (GUILayout.Button("Capture"))
		{
			EditorCoroutineUtility.StartCoroutineOwnerless(HDRPCaptureProcess.RunCaptureRoutine());
		}

		GUI.enabled = true;

		serializedObject.ApplyModifiedProperties();

		// Poll the bake status.
		if (bake_progress_window_ != null && bake_progress_window_.IsComplete())
		{
			bake_progress_window_.Close();
			bake_progress_window_ = null;
			capture_builder_ = null;
			capture_status_ = null;
		}
	}
}
# --- end Packages/com_ldx_framework/AddOns/SeuratCapture/Editor/Scripts/CaptureHeadboxEditor.cs

# FILE: Packages/com_ldx_framework/AddOns/SeuratCapture/Editor/Scripts/CaptureProgressWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: ddd02b7dcc2589a4c887c08fc031292a
# ASMDEF: editor.seurat.capture.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;

public class CaptureProgressWindow : EditorWindow
{
    private static float progress = 0.0f;
    private static bool isComplete = false;

    private void OnEnable()
    {
        SeuratCaptureController.OnProgressUpdated += UpdateProgress;
        SeuratCaptureController.OnProgressComplete += MarkComplete;
    }

    private void OnDisable()
    {
        SeuratCaptureController.OnProgressUpdated -= UpdateProgress;
        SeuratCaptureController.OnProgressComplete -= MarkComplete;
    }

    // Method to open the window
    public static void ShowWindow()
    {
        GetWindow<CaptureProgressWindow>("Capture Progress");
    }

    private void OnGUI()
    {
        GUILayout.Label("Progress", EditorStyles.boldLabel);

        // Display progress bar
        EditorGUI.ProgressBar(new Rect(3, 45, position.width - 6, 20), progress, isComplete ? "Complete!" : $"{progress * 100}%");

        // Update layout based on completion
        if (isComplete)
        {
            // Display Exit button in green
            GUI.backgroundColor = Color.green;
            if (GUILayout.Button("Exit"))
            {
                Close(); // Close the window
            }
        }
    }

    // Method to update the progress
    public static void UpdateProgress(float newProgress)
    {
        ShowWindow();
        progress = newProgress;
    }

    // Method to mark the process as complete
    public static void MarkComplete()
    {
        ShowWindow();
        isComplete = true;
    }
}
# --- end Packages/com_ldx_framework/AddOns/SeuratCapture/Editor/Scripts/CaptureProgressWindow.cs

# FILE: Packages/com_ldx_framework/AddOns/SeuratCapture/Editor/Scripts/HDRPCaptureProcess.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e855d8a3fac087c47bf6e70b73bc8b8c
# ASMDEF: editor.seurat.capture.dll
# ---
using UnityEditor;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.Rendering;
using System.IO;
using Unity.EditorCoroutines.Editor;
using Object = UnityEngine.Object;

public class HDRPCaptureProcess : Editor
{  
   //public static Dictionary<Material, Shader> shaderDictionary = new Dictionary<Material, Shader>();
   public static Dictionary<Material, Shader> shaderDictionary = new Dictionary<Material, Shader>();
   public static RenderPipelineAsset birpAsset;

   public static IEnumerator RunCaptureRoutine(string overrideOutputFolder = null)
   {
	   //Saves materials shaders.
	   Change2();

	   yield return EditorCoroutineUtility.StartCoroutineOwnerless(CaptureAllRoutine(overrideOutputFolder));

	   //Saves the render pipeline assets.
	   var GrapphicsAsset = GraphicsSettings.renderPipelineAsset;
	   var QualitysAsset = QualitySettings.renderPipeline;

	   //Sets the pipeline assets to none to use BIRP.
	   GraphicsSettings.renderPipelineAsset = birpAsset;
	   QualitySettings.renderPipeline = birpAsset;

	   //Sets the materials to BIRP friendly.
	   Change1();

	   yield return EditorCoroutineUtility.StartCoroutineOwnerless(CaptureAllRoutine(overrideOutputFolder));

	   //Switches back to HDRP
	   GraphicsSettings.renderPipelineAsset = GrapphicsAsset;
	   QualitySettings.renderPipeline = QualitysAsset;

	   //Reverts materials to HDRP friendly.
	   Change3();
   }

   private static IEnumerator CaptureAllRoutine(string overrideOutputFolder = null)
	{
		CaptureHeadbox[] headboxes = GameObject.FindObjectsOfType<CaptureHeadbox>();
		foreach (CaptureHeadbox headbox in headboxes)
		{
			CaptureProcess captureProcess = new CaptureProcess(headbox);
			yield return captureProcess.CaptureRoutine(overrideOutputFolder);
		}
	}

	
	//[MenuItem("Editor/Material/Change Shader to BIRP")]
    public static void Change1()
    {
       Shader newshader = Shader.Find( "Standard" );
       Shader newshaderGlass = Shader.Find( "Unlit/Transparent" );
       ChangeShaders(newshader, newshaderGlass);
    }
	
	//[MenuItem("Editor/Material/Save Material Shaders")]
    public static void Change2()
    {
	   shaderDictionary.Clear();
       SaveShaders();
    }
	
	//[MenuItem("Editor/Material/Revert to saved shaders")]
    public static void Change3()
    {
       RevertShaders();
    }
	
   
    static Object[] GetSelectedMaterials()
    {
        return Selection.GetFiltered(typeof(Material), SelectionMode.DeepAssets);
    }
 

	public static Material[] GetAllMaterials()
	{
		// Find all material assets in the project
		string[] materialPaths = AssetDatabase.FindAssets("t:Material");

		// Create an array to store the materials
		Material[] materials = new Material[materialPaths.Length];

		for (int i = 0; i < materialPaths.Length; i++)
		{
			// Convert the asset path to a relative path
			string relativePath = AssetDatabase.GUIDToAssetPath(materialPaths[i]);

			// Load the material asset
			materials[i] = AssetDatabase.LoadAssetAtPath<Material>(relativePath);
		}

		return materials;
	}
    
   public static void RevertShaders()
   {
      int counter = 0;
		Object[] materiales = GetAllMaterials();
		if (materiales.Length > 0)
		{
			foreach( Material mat in materiales )
			{      
				//Sets the shader to the one saved in the dictionary.
				mat.shader = (shaderDictionary[mat]);
				
				counter++;
			}
		}
      //EditorUtility.DisplayDialog( "Message", "materials reverted: " + counter, "OK" );	  
   }
  
   
   public static void SaveShaders ()
   {
		 Object[] materiales = GetAllMaterials();
		if (materiales.Length > 0)
		{
			foreach( Material mat in materiales )
			{
				//Saves the shader to a dictionary.
				shaderDictionary.Add (mat, mat.shader);
			}
			foreach( KeyValuePair<Material, Shader> shaderDictionary in shaderDictionary)
			{
				Debug.Log("Shaders: " + ("[Key: "+shaderDictionary.Key +", "+"Value: "+ shaderDictionary.Value +"]"));
			}
		}
   }
   
   public static void ChangeShaders(Shader newShader, Shader newShaderGlass)
   {
      int counter = 0;
		Object[] materiales = GetAllMaterials();
		if (materiales.Length > 0)
		{
			foreach( Material mat in materiales )
			{      

				string matName = mat.name.ToLower();
				
				if (matName.Contains("glass"))
				{
					//Sets the shader to birp transparent.
					mat.shader = newShaderGlass;
				}
				else{
					//Sets the shader to birp standard.
					mat.shader = newShader;
				}
						
				counter++;
			}
		}
      //EditorUtility.DisplayDialog( "Message", "materials changed: " + counter, "OK" );	  
   }
   
}

public class CaptureProcess
{
	private EditorBakeStatus capture_status_;
	private CaptureWindow bake_progress_window_;
	private CaptureBuilder capture_builder_;
	private CaptureHeadbox headbox;
	
	public CaptureProcess(CaptureHeadbox headbox)
	{
		this.headbox = headbox;
	}
	
	public IEnumerator CaptureRoutine(string overrideOutputFolder = null)
	{
		string capture_output_folder = overrideOutputFolder ?? headbox.output_folder_;
		if (capture_output_folder.Length <= 0)
		{
			capture_output_folder = FileUtil.GetUniqueTempPathInProject();
		}

		headbox.last_output_dir_ = capture_output_folder;
		Directory.CreateDirectory(capture_output_folder);

		capture_status_ = new EditorBakeStatus();
		capture_builder_ = new CaptureBuilder();

		// Kick off the interactive Editor bake window.
		bake_progress_window_ = (CaptureWindow)EditorWindow.GetWindow(typeof(CaptureWindow));
		bake_progress_window_.SetupStatus(capture_status_);

		capture_builder_.BeginCapture(headbox, capture_output_folder, 1, capture_status_);
		bake_progress_window_.SetupCaptureProcess(headbox, capture_builder_);
		yield return null;
		yield return new WaitUntil(() => capture_builder_.IsCaptureComplete());
	}
}
 
# --- end Packages/com_ldx_framework/AddOns/SeuratCapture/Editor/Scripts/HDRPCaptureProcess.cs

# FILE: Packages/com_ldx_framework/Editor/AssetInfo.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: feda615924c04084380362cd4283f37b
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace Ogxd.ProjectCurator
{
    public enum IncludedInBuild
    {
        Unknown = 0,
        // Not included in build
        NotIncludable = 1,
        NotIncluded = 2,
        // Included in build
        SceneInBuild = 10,
        RuntimeScript = 11,
        ResourceAsset = 12,
        Referenced = 13,
    }

    [Serializable]
    public class AssetInfo : ISerializationCallbackReceiver
    {

        [NonSerialized]
        public HashSet<string> referencers = new HashSet<string>();

        [NonSerialized]
        public HashSet<string> dependencies = new HashSet<string>();

        [SerializeField]
        public string[] _references;

        [SerializeField]
        public string[] _dependencies;

        public void OnBeforeSerialize()
        {
            _references = referencers.ToArray();
            _dependencies = dependencies.ToArray();
        }

        public void OnAfterDeserialize()
        {
            referencers = new HashSet<string>(_references ?? new string[0]);
            dependencies = new HashSet<string>(_dependencies ?? new string[0]);
        }

        [SerializeField]
        public string path;

        public AssetInfo(string path)
        {
            this.path = path;
        }

        public string[] GetDependencies()
        {
            return AssetDatabase.GetDependencies(path);
        }

        public void ClearIncludedStatus()
        {
            includedStatus = IncludedInBuild.Unknown;
        }

        [NonSerialized]
        private IncludedInBuild includedStatus;

        public IncludedInBuild IncludedStatus {
            get {
                if (includedStatus != IncludedInBuild.Unknown)
                    return includedStatus;
                // Avoid circular loops
                includedStatus = IncludedInBuild.NotIncluded;
                return includedStatus = CheckIncludedStatus();
            }
        }

        public bool IsIncludedInBuild => (int)IncludedStatus >= 10;

        private IncludedInBuild CheckIncludedStatus()
        {

            foreach (var referencer in referencers) {
                AssetInfo refInfo = ProjectCurator.GetAsset(referencer);
                if (refInfo.IsIncludedInBuild) {
                    return IncludedInBuild.Referenced;
                }
            }

            bool isInEditor = false;

            string[] directories = path.ToLower().Split('/');
            for (int i = 0; i < directories.Length - 1; i++) {
                switch (directories[i]) {
                    case "editor":
                        isInEditor = true;
                        break;
                    case "resources":
                        return IncludedInBuild.ResourceAsset;
                    case "plugins":
                        break;
                    default:
                        break;
                }
            }

            string extension = System.IO.Path.GetExtension(path);
            switch (extension) {
                case ".cs":
                    if (isInEditor) {
                        return IncludedInBuild.NotIncludable;
                    } else {
                        return IncludedInBuild.RuntimeScript;
                    }
                case ".unity":
                    if (EditorBuildSettings.scenes.Select(x => x.path).Contains(path))
                        return IncludedInBuild.SceneInBuild;
                    break;
                // Todo : Handle DLL
                // https://docs.unity3d.com/ScriptReference/Compilation.Assembly-compiledAssemblyReferences.html
                // CompilationPipeline
                // Assembly Definition
                default:
                    break;
            }

            return IncludedInBuild.NotIncluded;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/AssetInfo.cs

# FILE: Packages/com_ldx_framework/Editor/AssetProcessor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c4b63a90f3eef924da73a1c8f3869b75
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using System.Collections.Generic;
using System;

namespace Ogxd.ProjectCurator
{
    /// <summary>
    /// The purpose of this class is to try detecting asset changes to automatically update the ProjectCurator database.
    /// </summary>
    public class AssetProcessor : UnityEditor.AssetModificationProcessor
    {
        [InitializeOnLoadMethod]
        public static void Init()
        {
            EditorApplication.update += OnUpdate;
        }

        /// <summary>
        /// Some callbacks must be delayed on next frame
        /// </summary>
        private static void OnUpdate()
        {
            while (Actions.Count > 0) {
                Actions.Dequeue()?.Invoke();
            }
        }

        private static Queue<Action> Actions = new Queue<Action>();

        static string[] OnWillSaveAssets(string[] paths)
        {
            if (ProjectCuratorData.IsUpToDate) {
                Actions.Enqueue(() => {
                    foreach (string path in paths) {
                        ProjectCurator.RemoveAssetFromDatabase(path);
                        ProjectCurator.AddAssetToDatabase(path);
                    }
                    ProjectCurator.SaveDatabase();
                });
            }
            return paths;
        }

        static void OnWillCreateAsset(string assetName)
        {
            if (ProjectCuratorData.IsUpToDate) {
                Actions.Enqueue(() => {
                    ProjectCurator.AddAssetToDatabase(assetName);
                    ProjectCurator.SaveDatabase();
                });
            }
        }

        static AssetDeleteResult OnWillDeleteAsset(string assetName, RemoveAssetOptions removeAssetOptions)
        {
            if (ProjectCuratorData.IsUpToDate) {
                ProjectCurator.RemoveAssetFromDatabase(assetName);
                ProjectCurator.SaveDatabase();
            }
            return AssetDeleteResult.DidNotDelete;
        }

        static AssetMoveResult OnWillMoveAsset(string sourcePath, string destinationPath)
        {
            if (ProjectCuratorData.IsUpToDate) {
                Actions.Enqueue(() => {
                    ProjectCurator.RemoveAssetFromDatabase(sourcePath);
                    ProjectCurator.AddAssetToDatabase(destinationPath);
                    ProjectCurator.SaveDatabase();
                });
            }
            return AssetMoveResult.DidNotMove;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/AssetProcessor.cs

# FILE: Packages/com_ldx_framework/Editor/ProjectCurator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 5e857195681b8e347a54447908d14c05
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System;
using System.Linq;
using System.IO;

namespace Ogxd.ProjectCurator
{
    public static class ProjectCurator
    {
        [NonSerialized]
        private static Dictionary<string, AssetInfo> pathToAssetInfo;

        static ProjectCurator()
        {
            pathToAssetInfo = new Dictionary<string, AssetInfo>();
            var assetInfos = ProjectCuratorData.AssetInfos;
            for (int i = 0; i < assetInfos.Length; i++) {
                pathToAssetInfo.Add(assetInfos[i].path, assetInfos[i]);
            }
        }

        public static AssetInfo GetAsset(string path)
        {
            AssetInfo assetInfo = null;
            pathToAssetInfo.TryGetValue(path, out assetInfo);
            return assetInfo;
        }

        public static void AddAssetToDatabase(string path)
        {
            AssetInfo assetInfo;
            if (!pathToAssetInfo.TryGetValue(path, out assetInfo)) {
                pathToAssetInfo.Add(path, assetInfo = new AssetInfo(path));
            }

            var dependencies = assetInfo.GetDependencies();

            foreach (string dependency in dependencies) {
                if (dependency == assetInfo.path)
                    continue;
                if (pathToAssetInfo.TryGetValue(dependency, out AssetInfo depInfo)) {
                    assetInfo.dependencies.Add(dependency);
                    depInfo.referencers.Add(assetInfo.path);
                    // Included status may have changed and need to be recomputed
                    depInfo.ClearIncludedStatus();
                }
            }
        }

        public static void RemoveAssetFromDatabase(string asset)
        {
            if (pathToAssetInfo.TryGetValue(asset, out AssetInfo assetInfo)) {
                foreach (string referencer in assetInfo.referencers) {
                    if (pathToAssetInfo.TryGetValue(referencer, out AssetInfo referencerAssetInfo)) {
                        if (referencerAssetInfo.dependencies.Remove(asset)) {
                            referencerAssetInfo.ClearIncludedStatus();
                        } else {
                            // Non-Reciprocity Error
                            Debug.LogWarning($"Asset '{referencer}' that depends on '{asset}' doesn't have it as a dependency");
                        }
                    } else {
                        Debug.LogWarning($"Asset '{referencer}' that depends on '{asset}' is not present in the database");
                    }
                }
                foreach (string dependency in assetInfo.dependencies) {
                    if (pathToAssetInfo.TryGetValue(dependency, out AssetInfo dependencyAssetInfo)) {
                        if (dependencyAssetInfo.referencers.Remove(asset)) {
                            dependencyAssetInfo.ClearIncludedStatus();
                        } else {
                            // Non-Reciprocity Error
                            Debug.LogWarning($"Asset '{dependency}' that is referenced by '{asset}' doesn't have it as a referencer");
                        }
                    } else {
                        Debug.LogWarning($"Asset '{dependency}' that is referenced by '{asset}' is not present in the database");
                    }
                }
                pathToAssetInfo.Remove(asset);
            } else {
                Debug.LogWarning($"Asset '{asset}' is not present in the database");
            }
        }

        public static void ClearDatabase()
        {
            pathToAssetInfo.Clear();
        }

        public static void RebuildDatabase()
        {
            pathToAssetInfo = new Dictionary<string, AssetInfo>();

            var allAssetPaths = AssetDatabase.GetAllAssetPaths();

            // Ignore non-assets (package folder for instance) and directories
            allAssetPaths = allAssetPaths.Where(x => x.StartsWith("Assets/") && !Directory.Exists(x)).ToArray();

            EditorUtility.DisplayProgressBar("Building Dependency Database", "Gathering All Assets...", 0f);

            // Gather all assets
            for (int p = 0; p < allAssetPaths.Length; p++) {
                AssetInfo assetInfo = new AssetInfo(allAssetPaths[p]);
                pathToAssetInfo.Add(assetInfo.path, assetInfo);
            }

            // Find links between assets
            for (int p = 0; p < allAssetPaths.Length; p++) {
                if (p % 10 == 0) {
                    var cancel = EditorUtility.DisplayCancelableProgressBar("Building Dependency Database", allAssetPaths[p], (float)p / allAssetPaths.Length);
                    if (cancel) {
                        pathToAssetInfo = null;
                        break;
                    }
                }
                AddAssetToDatabase(allAssetPaths[p]);
            }

            EditorUtility.ClearProgressBar();

            ProjectCuratorData.IsUpToDate = true;

            SaveDatabase();
        }

        public static void SaveDatabase()
        {
            if (pathToAssetInfo == null)
                return;
            var assetInfos = new AssetInfo[pathToAssetInfo.Count];
            int i = 0;
            foreach (var pair in pathToAssetInfo) {
                assetInfos[i] = pair.Value;
                i++;
            }
            ProjectCuratorData.AssetInfos = assetInfos;
            ProjectCuratorData.Save();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/ProjectCurator.cs

# FILE: Packages/com_ldx_framework/Editor/ProjectCuratorData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6091e6efac22e1840bcc6e69ce9d2e96
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.IO;
using UnityEngine;

namespace Ogxd.ProjectCurator
{
    [Serializable]
    public class ProjectCuratorData
    {
        private const string JSON_PATH = "ProjectSettings/ProjectCuratorSettings.json";

        [SerializeField]
        private bool isUpToDate = false;
        public static bool IsUpToDate { get { return Instance.isUpToDate; } set { Instance.isUpToDate = value; } }

        [SerializeField]
        private AssetInfo[] assetInfos;
        public static AssetInfo[] AssetInfos {
            get => Instance.assetInfos ?? (Instance.assetInfos = new AssetInfo[0]);
            set => Instance.assetInfos = value;
        }

        private static ProjectCuratorData instance;
        public static ProjectCuratorData Instance {
            get {
                if (instance == null) {
                    if (File.Exists(JSON_PATH)) {
                        instance = JsonUtility.FromJson<ProjectCuratorData>(File.ReadAllText(JSON_PATH));
                    } else {
                        instance = new ProjectCuratorData();
                        File.WriteAllText(JSON_PATH, JsonUtility.ToJson(instance));
                    }
                }
                return instance;
            }
        }

        public static void Save()
        {
            File.WriteAllText(JSON_PATH, JsonUtility.ToJson(Instance));
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/ProjectCuratorData.cs

# FILE: Packages/com_ldx_framework/Editor/ProjectCuratorWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: daaefaf9cd698e04e8b67da00638832a
# ASMDEF: ldx.framework.editor.dll
# ---
using System.IO;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEngine;

namespace Ogxd.ProjectCurator
{
    public class ProjectCuratorWindow : EditorWindow, IHasCustomMenu
    {

        [MenuItem("Window/Project Curator")]
        static void Init()
        {
            GetWindow<ProjectCuratorWindow>("Project Curator");
        }

        public ProjectCuratorWindow()
        {
            Selection.selectionChanged += OnSelectionChanged;
        }

        private void OnSelectionChanged()
        {
            Repaint();
        }

        private Vector2 scroll;

        private bool dependenciesOpen = true;
        private bool referencesOpen = true;

        private static GUIStyle titleStyle;
        private static GUIStyle TitleStyle => titleStyle ?? (titleStyle = new GUIStyle(EditorStyles.label) { fontSize = 13 });

        private static GUIStyle itemStyle;
        private static GUIStyle ItemStyle => itemStyle ?? (itemStyle = new GUIStyle(EditorStyles.label) { margin = new RectOffset(32, 0, 0, 0) });

        private void OnGUI()
        {
            string selectedPath = AssetDatabase.GetAssetPath(UnityEditor.Selection.activeObject);
            if (string.IsNullOrEmpty(selectedPath))
                return;

            // Standard spacing to mimic Unity's Inspector header
            GUILayout.Space(2);

            Rect rect;

            GUILayout.BeginHorizontal("In BigTitle");
            GUILayout.Label(AssetDatabase.GetCachedIcon(selectedPath), GUILayout.Width(36), GUILayout.Height(36));
            GUILayout.BeginVertical();
            GUILayout.Label(Path.GetFileName(selectedPath), TitleStyle);
            // Display directory (without "Assets/" prefix)
            GUILayout.Label(Regex.Match(Path.GetDirectoryName(selectedPath), "(\\\\.*)$").Value);
            rect = GUILayoutUtility.GetLastRect();
            GUILayout.EndVertical();
            GUILayout.Space(44);
            GUILayout.EndHorizontal();

            if (Directory.Exists(selectedPath))
                return;

            AssetInfo selectedAssetInfo = ProjectCurator.GetAsset(selectedPath);
            if (selectedAssetInfo == null) {
                if (selectedPath.StartsWith("Assets"))
                {
                    bool rebuildClicked = HelpBoxWithButton(new GUIContent("You must rebuild database to obtain information on this asset", EditorGUIUtility.IconContent("console.warnicon").image), new GUIContent("Rebuild Database"));
                    if (rebuildClicked)
                    {
                        ProjectCurator.RebuildDatabase();
                    }
                } 
                else
                {
                    EditorGUILayout.HelpBox("Project Curator ignores assets that are not in the Asset folder.", MessageType.Warning);
                }

                return;
            }

            var content = new GUIContent(selectedAssetInfo.IsIncludedInBuild ? ProjectIcons.LinkBlue : ProjectIcons.LinkBlack, selectedAssetInfo.IncludedStatus.ToString());
            GUI.Label(new Rect(position.width - 20, rect.y + 1, 16, 16), content);

            scroll = GUILayout.BeginScrollView(scroll);

            dependenciesOpen = EditorGUILayout.Foldout(dependenciesOpen, $"Dependencies ({selectedAssetInfo.dependencies.Count})");
            if (dependenciesOpen) {
                foreach (var dependency in selectedAssetInfo.dependencies) {
                    if (GUILayout.Button(new GUIContent(Path.GetFileName(dependency), dependency), ItemStyle)) {
                        UnityEditor.Selection.activeObject = AssetDatabase.LoadAssetAtPath<UnityEngine.Object>(dependency);
                    }
                    rect = GUILayoutUtility.GetLastRect();
                    GUI.DrawTexture(new Rect(rect.x - 16, rect.y, rect.height, rect.height), AssetDatabase.GetCachedIcon(dependency));
                    AssetInfo depInfo = ProjectCurator.GetAsset(dependency);
                    content = new GUIContent(depInfo.IsIncludedInBuild ? ProjectIcons.LinkBlue : ProjectIcons.LinkBlack, depInfo.IncludedStatus.ToString());
                    GUI.Label(new Rect(rect.width + rect.x - 20, rect.y + 1, 16, 16), content);
                }
            }

            GUILayout.Space(6);

            referencesOpen = EditorGUILayout.Foldout(referencesOpen, $"Referencers ({selectedAssetInfo.referencers.Count})");
            if (referencesOpen) {
                foreach (var referencer in selectedAssetInfo.referencers) {
                    if (GUILayout.Button(new GUIContent(Path.GetFileName(referencer), referencer), ItemStyle)) {
                        UnityEditor.Selection.activeObject = AssetDatabase.LoadAssetAtPath<UnityEngine.Object>(referencer);
                    }
                    rect = GUILayoutUtility.GetLastRect();
                    GUI.DrawTexture(new Rect(rect.x - 16, rect.y, rect.height, rect.height), AssetDatabase.GetCachedIcon(referencer));
                    AssetInfo refInfo = ProjectCurator.GetAsset(referencer);
                    content = new GUIContent(refInfo.IsIncludedInBuild ? ProjectIcons.LinkBlue : ProjectIcons.LinkBlack, refInfo.IncludedStatus.ToString());
                    GUI.Label(new Rect(rect.width + rect.x - 20, rect.y + 1, 16, 16), content);
                }
            }

            GUILayout.Space(5);

            GUILayout.EndScrollView();

            if (!selectedAssetInfo.IsIncludedInBuild) {
                bool deleteClicked = HelpBoxWithButton(new GUIContent("This asset is not referenced and never used. Would you like to delete it ?", EditorGUIUtility.IconContent("console.warnicon").image), new GUIContent("Delete Asset"));
                if (deleteClicked) {
                    File.Delete(selectedPath);
                    AssetDatabase.Refresh();
                    ProjectCurator.RemoveAssetFromDatabase(selectedPath);
                }
            }
        }

        void IHasCustomMenu.AddItemsToMenu(GenericMenu menu)
        {
            menu.AddItem(new GUIContent("Rebuild Database"), false, ProjectCurator.RebuildDatabase);
            menu.AddItem(new GUIContent("Clear Database"), false, ProjectCurator.ClearDatabase);
            menu.AddItem(new GUIContent("Project Overlay"), ProjectWindowOverlay.Enabled, () => { ProjectWindowOverlay.Enabled = !ProjectWindowOverlay.Enabled; });
        }

        public bool HelpBoxWithButton(GUIContent messageContent, GUIContent buttonContent)
        {
            float buttonWidth = buttonContent.text.Length * 8;
            const float buttonSpacing = 5f;
            const float buttonHeight = 18f;

            // Reserve size of wrapped text
            Rect contentRect = GUILayoutUtility.GetRect(messageContent, EditorStyles.helpBox);
            // Reserve size of button
            GUILayoutUtility.GetRect(1, buttonHeight + buttonSpacing);

            // Render background box with text at full height
            contentRect.height += buttonHeight + buttonSpacing;
            GUI.Label(contentRect, messageContent, EditorStyles.helpBox);

            // Button (align lower right)
            Rect buttonRect = new Rect(contentRect.xMax - buttonWidth - 4f, contentRect.yMax - buttonHeight - 4f, buttonWidth, buttonHeight);
            return GUI.Button(buttonRect, buttonContent);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/ProjectCuratorWindow.cs

# FILE: Packages/com_ldx_framework/Editor/ProjectIcons.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 598e60079d3bbe646b1188bba2ff4937
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;

namespace Ogxd.ProjectCurator
{
    public static class ProjectIcons
    {
        private static Texture2D linkBlack;
        public static Texture2D LinkBlack => linkBlack ?? (linkBlack = Resources.Load<Texture2D>("link_black"));

        private static Texture2D linkWhite;
        public static Texture2D LinkWhite => linkWhite ?? (linkWhite = Resources.Load<Texture2D>("link_white"));

        private static Texture2D linkBlue;
        public static Texture2D LinkBlue => linkBlue ?? (linkBlue = Resources.Load<Texture2D>("link_blue"));
    }
}
# --- end Packages/com_ldx_framework/Editor/ProjectIcons.cs

# FILE: Packages/com_ldx_framework/Editor/ProjectWindowOverlay.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f7ab464361220a74c97482f4bd3d5dd2
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace Ogxd.ProjectCurator
{
    [InitializeOnLoad]
    public static partial class ProjectWindowOverlay
    {
        static ProjectWindowOverlay()
        {
            enabled = Enabled;
            EditorApplication.projectWindowItemOnGUI += ProjectWindowItemOnGUI;
        }

        private static void ProjectWindowItemOnGUI(string guid, Rect rect)
        {
            if (enabled) {
                AssetInfo assetInfo = ProjectCurator.GetAsset(AssetDatabase.GUIDToAssetPath(guid));
                if (assetInfo != null) {
                    var content = new GUIContent(assetInfo.IsIncludedInBuild ? ProjectIcons.LinkBlue : ProjectIcons.LinkBlack, assetInfo.IncludedStatus.ToString());
                    GUI.Label(new Rect(rect.width + rect.x - 20, rect.y + 1, 16, 16), content);
                } else {

                }
            }
        }

        private static bool enabled;

        public static bool Enabled {
            get {
                return enabled = EditorPrefs.GetBool("ProjectCurator_PWO");
            }
            set {
                EditorPrefs.SetBool("ProjectCurator_PWO", enabled = value);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/ProjectWindowOverlay.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Features/Animation/AnimationObjectDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d3629e741106480c805875074eff41b2
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Features.Animation
{
    [CustomEditor(typeof(AnimationObject))]
    public class AnimationObjectDrawer : Editor
    {
        private SerializedProperty sDialogId;
        private SerializedProperty sAnimator;
        private SerializedProperty sAction;
        private SerializedProperty sTrackingEvent;
        private SerializedProperty sAnimationTrigger;
        private AnimationObject animationObject;
        
        private void OnEnable()
        {
            sDialogId = serializedObject.FindProperty("dialogId");
            sAnimator = serializedObject.FindProperty("animator");
            sAction = serializedObject.FindProperty("action");
            sAnimationTrigger = serializedObject.FindProperty("animationTrigger");
            sTrackingEvent = serializedObject.FindProperty("onCompletionTrackingEvent");
            animationObject = (AnimationObject)target;
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(sDialogId);
            EditorGUILayout.PropertyField(sAnimator);
           
            EditorGUILayout.Separator();
            
            Animator animator = animationObject.Animator;
            if(animator == null)
            {
                EditorGUILayout.HelpBox("No Animator component found on this GameObject.", MessageType.Warning);
                serializedObject.ApplyModifiedProperties();
                return;
            }
            
            EditorGUILayout.BeginVertical(GUI.skin.box);
            DrawSectionField(sAction, "Action", true);
            EditorGUILayout.Separator();
            
            EditorGUI.indentLevel++;

            switch (animationObject.Action)
            {
                case AnimationObject.AnimationAction.SetTrigger:
                    // Get trigger parameters from the Animator
                    string[] triggers = GetTriggerParameters(animator);

                    if (triggers.Length < 1)
                    {
                        EditorGUILayout.PropertyField(sAnimationTrigger);
                    }
                    else
                    {
                        // Display the triggers as an enum popup
                        int selectedIndex = Mathf.Max(0, Array.IndexOf(triggers, sAnimationTrigger.stringValue));
                        selectedIndex = EditorGUILayout.Popup("Animation Trigger", selectedIndex, triggers);
                        sAnimationTrigger.stringValue = selectedIndex >= triggers.Length ? "" : triggers[selectedIndex];
                    }
                    
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
            EditorGUI.indentLevel--;
            EditorGUILayout.EndVertical();
            
            EditorGUILayout.Separator();
            
            EditorGUILayout.PropertyField(sTrackingEvent);

            serializedObject.ApplyModifiedProperties();
        }

        private string[] GetTriggerParameters(Animator animator)
        {
            AnimatorControllerParameter[] parameters = animator.parameters;
            List<string> triggers = new();
            foreach (AnimatorControllerParameter parameter in parameters)
            {
                if (parameter.type == AnimatorControllerParameterType.Trigger)
                {
                    triggers.Add(parameter.name);
                }
            }

            return triggers.ToArray();
        }
        
        private void DrawSectionField(SerializedProperty property, string label, bool active, string tooltip = "")
        {
            EditorGUILayout.PropertyField(property, new GUIContent(active ? label + " " : label, tooltip));
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Features/Animation/AnimationObjectDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Features/CheckLODSetupEditorFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 744ee78576264a45a9c16c9bbda38fd1
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Ldx.Framework.Features
{
    /// <summary>
    /// Lists incorrectly setup LODs in the scene, automated fix included
    /// </summary>
    public static class CheckLODSetupEditorFeature
    {
        [MenuItem("LogicalDox/Tools/Check LOD Setups")]
        public static void RunFeature()
        {
            List<LODGroup> incorrectLODs = new();
            HashSet<string> uniqueNamesSet = new();
            
            grabReferences();

            if (incorrectLODs.Count == 0)
            {
                EditorUtility.DisplayDialog("Message", "No faulty LOD setups found", "Ok");
                return;
            }
            
            Vector2 scrollPos = new();
            bool fixing = false;
            ModalEditorWindow modal = ModalEditorWindow.ShowModal("Incorrect LOD Setups", showModalWindow);
            modal.SetMinSize(300, 500);

            void grabReferences()
            {
                LODGroup[] lodGroups = Object.FindObjectsByType<LODGroup>(FindObjectsSortMode.None);
                foreach (LODGroup lodGroup in lodGroups)
                {
                    foreach (LOD lod in lodGroup.GetLODs())
                    {
                        for (int i = 0; i < lod.renderers.Length; i++)
                        {
                            Renderer r = lod.renderers[i];
                            if (r == null)
                            {
                                if (!incorrectLODs.Contains(lodGroup))
                                {
                                    incorrectLODs.Add(lodGroup);
                                }
                                break;
                            }
                        }

                        if (lod.renderers.Length == 0)
                        {
                            if (!incorrectLODs.Contains(lodGroup))
                            {
                                incorrectLODs.Add(lodGroup);
                            }
                            break;
                        }
                    }
                }
    
                uniqueNamesSet = new(incorrectLODs.Select(l => l.gameObject.name));
            }
            
            void showModalWindow()
            {
                if (!fixing && incorrectLODs.Count == 0)
                {
                    EditorGUILayout.LabelField("No LODs to list");
                    return;
                }
                if (fixing)
                {
                    EditorGUILayout.LabelField("Running LOD fix operation...");
                    GUI.enabled = false;
                }
                scrollPos = EditorGUILayout.BeginScrollView(scrollPos);
                using (new GUILayout.VerticalScope())
                {
                    if (GUILayout.Button("Run Fix Automation"))
                    {
                        fixLODsAsync().Forget();
                    }
                    
                    LdxEditorHelper.DrawTitle("Incorrect LOD setups");
                    EditorGUILayout.LabelField($"(Found objects count: {incorrectLODs.Count})", EditorStyles.helpBox);
                    
                    EditorGUILayout.Space(5);

                    LdxEditorHelper.DrawBoldLabel("Grouped by unique names:");
                    foreach (string n in uniqueNamesSet)
                    {
                        EditorGUILayout.LabelField($"- {n}");
                    }

                    EditorGUILayout.Space(5);

                    
                    LdxEditorHelper.DrawBoldLabel("Incorrect LOD Scene Objects:");
                    int counter = 0;
                    foreach (LODGroup lodGroup in incorrectLODs)
                    {
                        counter++;
                        if (GUILayout.Button($"{counter}. {lodGroup.name}", EditorStyles.linkLabel))
                        {
                            Selection.activeObject = lodGroup.gameObject;
                        }
                    }
                }
                EditorGUILayout.EndScrollView();
                GUI.enabled = true;
            }

            async UniTaskVoid fixLODsAsync()
            {
                fixing = true;
                float progress = 0.0f;
                float totalProgress = incorrectLODs.Count;
                int yieldCounter = 0;
                int numberOfObjectsToYield = 2;
    
                for (int i = incorrectLODs.Count - 1; i >= 0; i--)
                {
                    try
                    {
                        LODGroup group = incorrectLODs[i];
                        int j = ((int)totalProgress) - i;
                        progress = j / totalProgress;
                        string progressMsg = $"Processing {group.name}... {progress/totalProgress}";
                        List<LOD> lods = new();
                        Renderer[] childRenderers = group.GetComponentsInChildren<Renderer>();
                        float transitionHeight = 1f; // Start with 1 (100%) for the highest detail LOD
                        float transitionHeightStep = 1f / childRenderers.Length; // Evenly divide the transition height step by the number of LODs

                        foreach (Renderer r in childRenderers)
                        {
                            LOD lod = new()
                            {
                                renderers = new[] { r },
                                screenRelativeTransitionHeight = transitionHeight
                            };
                            lods.Add(lod);
                            transitionHeight -= transitionHeightStep; // Decrease the transition height for the next LOD level
                        }
                        group.SetLODs(lods.ToArray());
                        EditorUtility.DisplayProgressBar("Processing", progressMsg, progress);

                        EditorUtility.SetDirty(group);
                        incorrectLODs.RemoveAt(i);
            
                        yieldCounter += 1;
                        yieldCounter %= numberOfObjectsToYield;
                        if (yieldCounter == 0)
                        {
                            await UniTask.Yield();
                        }
                    }
                    catch (Exception e)
                    {
                        Debug.LogError(e);
                    }
                }
                
                EditorUtility.ClearProgressBar();
                
                grabReferences();
                fixing = false;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Features/CheckLODSetupEditorFeature.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Features/EditorBuildMenu.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 793f4423759d4307bd00ec47b38b4fdd
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using UnityEditor;
using UnityEditor.Build.Reporting;
using UnityEngine;

namespace Ldx.Framework.Features
{
    public static class EditorBuildMenu
    {
        [MenuItem("LogicalDox/Build/Internal Build", priority = 0)]
        public static void StartBuildInternal()
        {
            if (!EditorUtility.DisplayDialog("Warning", "This will start an internal build. Debug tools and other " +
                                                        "internal data could be included. Please make sure this isn't a client-facing build.",
                    "Continue", "Cancel"))
            {
                return;
            }
            ProjectDefinesFeatures.AddInternalBuildDefines();
            BuildForAndroid();
            ProjectDefinesFeatures.RemoveInternalBuildDefines();
        }

        [MenuItem("LogicalDox/Build/Client Build", priority = 0)]
        public static void StartBuildClient()
        {
            if (!EditorUtility.DisplayDialog("Warning", "This will start a client build without any debug tools or internal data",
                    "Continue", "Cancel"))
            {
                return;
            }
            ProjectDefinesFeatures.RemoveInternalBuildDefines();
            BuildForAndroid();
        }

        private static void BuildForAndroid()
        {
            if (!SwitchToAndroid())
            {
                return;
            }
            
            string buildPath = EditorUtility.SaveFilePanel("Save build to..", "", "", "apk");

            if (String.IsNullOrEmpty(buildPath))
            {
                return;
            }
            
            if (!EditorUtility.DisplayDialog("Warning",
                    "The build process will now start based on the settings you manually specified" +
                    " the project settings", "Continue", "Cancel"))
            {
                return;
            }

            
            string[] scenes = EditorBuildSettingsScene.GetActiveSceneList(EditorBuildSettings.scenes);

            // Set the build player options
            BuildPlayerOptions buildPlayerOptions = new BuildPlayerOptions
            {
                scenes = scenes,
                locationPathName = buildPath,
                target = BuildTarget.Android,
                options = BuildOptions.None
            };

            // Perform the build
            BuildReport report = BuildPipeline.BuildPlayer(buildPlayerOptions);
            BuildSummary summary = report.summary;

            if (summary.result == BuildResult.Succeeded)
            {
                Console.WriteLine("Build succeeded: " + summary.totalSize + " bytes");
            }

            if (summary.result == BuildResult.Failed)
            {
                Console.WriteLine("Build failed");
            }
        }

        private static bool SwitchToAndroid()
        {
            #if LDX_INTERNAL_DEBUG
            #endif
            // Check if the current build target is Android
            if (EditorUserBuildSettings.activeBuildTarget == BuildTarget.Android)
            {
                return true;
            }

            if (!EditorUtility.DisplayDialog("Warning", "Your current build target isn't Android. " +
                                                        "The process can switch to Android for you. This can take a few minutes."
                    , "Switch to Android", "Cancel"))
            {
                return false;
            }
            
            try
            {
                EditorUserBuildSettings.SwitchActiveBuildTarget(BuildTargetGroup.Android, BuildTarget.Android);
                return true;
            }
            catch (Exception e)
            {
                Debug.LogError(e);
                EditorUtility.DisplayDialog("Error", "Switching to Android failed. Please check the error logs.", "Ok"); 
                return false;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Features/EditorBuildMenu.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Features/Hierarchy/HierarchyStateSaverEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 418c18bf92954455b8861c3cdb10f9a6
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Linq;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Features.Hierarchy
{
    [CustomEditor(typeof(HierarchyStateSaver))]
    public class HierarchyStateSaverEditor : Editor
    {
        private HierarchyStateSaver Target => (HierarchyStateSaver)target;
        private string[] infoNamesArray;
        private int? currentInfoIndex;
        private HierarchyInfo info;
        
        private void OnEnable()
        {
            UpdateList();
        }

        public override void OnInspectorGUI()
        {
            DrawSelection();
            LdxEditorHelper.DrawHorizontalSeparator();
            EditorGUI.BeginChangeCheck();
            base.OnInspectorGUI();
            if (EditorGUI.EndChangeCheck())
            {
                UpdateList();
            }
        }

        private void DrawSelection()
        {
            if (currentInfoIndex == null || currentInfoIndex.Value > Target.HierarchyInfoList.Count-1)
            {
                return;
            }

            EditorGUI.BeginChangeCheck();
            currentInfoIndex = EditorGUILayout.Popup("Selection: ", currentInfoIndex.Value, infoNamesArray);
            if (EditorGUI.EndChangeCheck())
            {
                info = Target.HierarchyInfoList[currentInfoIndex.Value];
            }

            using (new EditorGUILayout.HorizontalScope())
            {
                if (GUILayout.Button("Apply Setup State"))
                {
                    Target.EDITOR_ApplyState(info);
                    EditorUtility.DisplayDialog("Message", "Applied setup state", "Ok");
                }
                GUILayout.FlexibleSpace();
            }
            
            using (new EditorGUILayout.HorizontalScope())
            {
                if (GUILayout.Button("Capture Setup State"))
                {
                    Target.EDITOR_CaptureState(info);
                    EditorUtility.SetDirty(Target);
                    EditorUtility.DisplayDialog("Message", "Captured setup state", "Ok");
                }
                GUILayout.FlexibleSpace();
            }
            
        }
        
        private void UpdateList()
        {
            infoNamesArray = Target.HierarchyInfoList.Select(h => h.Name).ToArray();
            if (infoNamesArray.Length == 0)
            {
                currentInfoIndex = null;
                info = null;
                return;
            }

            if (currentInfoIndex == null ||
                (currentInfoIndex != null && currentInfoIndex.Value > infoNamesArray.Length - 1))
            {
                currentInfoIndex = 0;
            }

            info = Target.HierarchyInfoList[currentInfoIndex.Value];
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Features/Hierarchy/HierarchyStateSaverEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Features/Highlighting/HighlightingLayerSanitizationSavingAddOn.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: ef3637851ee64c1b8277453286beb6b3
# ASMDEF: ldx.framework.editor.dll
# ---
using Ldx.Framework.Utilities.Attributes;

namespace Ldx.Framework.Features.Highlighting
{
    /// <summary>
    /// Runs on save scene to sanitize highlight layer
    /// </summary>
    [SceneSavingAddOn]
    public class HighlightingLayerSanitizationSavingAddOn
    {
        public static void SceneSaving()
        {
            return;
            HighlightingGlobalSettings.EDITOR_AutoSanitizeHighlightLayer();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Features/Highlighting/HighlightingLayerSanitizationSavingAddOn.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Features/Interaction/TransformKinematicGrabbableEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 74495271898b49958b01a7d457cc24e0
# ASMDEF: ldx.framework.editor.dll
# ---
/*using System;
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Features.Interaction
{
    [CustomEditor(typeof(TransformKinematicGrabbable))]
    public class TransformKinematicGrabbableEditor : Editor
    {
        private const float DEFAULT_PROGRESS_DURATION = 1.0f;

        private float? progressDuration;
        private bool isPlaying;
        private bool isPaused;
        private Dictionary<Transform, TransformValuesCache> transformToCacheDictionary = new();
        private TransformKinematicGrabbable Target => (TransformKinematicGrabbable)target;
        
        private void OnEnable()
        {
            if (progressDuration == null)
            {
                progressDuration = DEFAULT_PROGRESS_DURATION;
            }
            transformToCacheDictionary.Clear();
            foreach (TransformKinematicGrabbable.LerpTarget lTarget in Target.LerpTargets)
            {
                Transform t = lTarget.TargetTransform;
                if (transformToCacheDictionary.ContainsKey(t))
                {
                    continue;
                }
                transformToCacheDictionary.Add(t, new TransformValuesCache(position: t.localPosition, rotationEuler: t.localRotation.eulerAngles));
            }
        }

        private void OnDestroy()
        {
            StopTween();
        }

        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
            LdxEditorHelper.DrawHorizontalSeparator();
            LdxEditorHelper.DrawTitle("Simulation");
            DrawProgressDurationField();
            DrawPlayStopButtons();
            DrawProgressDisplay();
        }

        private void DrawProgressDurationField()
        {
            progressDuration = EditorGUILayout.FloatField("Simulation Duration:", progressDuration.Value);
        }
        
        private void DrawPlayStopButtons()
        {
            GUI.enabled = !isPlaying;
            if (GUILayout.Button("Play"))
            {
                PlayTween();
            }

            GUI.enabled = isPlaying;
            if (GUILayout.Button(isPaused? "Unpause" : "Pause"))
            {
                SetPaused(!isPaused);
            }
            
            if (GUILayout.Button("Stop"))
            {
                StopTween();
            }

            GUI.enabled = true;
        }

        private void DrawProgressDisplay()
        {
            if (!isPlaying)
            {
                return;
            }
            EditorGUILayout.LabelField($"Progress: {Target.Progress:0.000}");
        }

        private void PlayTween()
        {
            isPlaying = true;
            Target.Initialize();
            
            playTweenAsync().Forget();
            async UniTaskVoid playTweenAsync()
            {
                float timer = 0.0f;
                double lastTime = EditorApplication.timeSinceStartup;
                await UniTask.Yield();
                
                while (isPlaying)
                {
                    if (isPaused)
                    {
                        lastTime = EditorApplication.timeSinceStartup;
                        await UniTask.Yield();
                        continue;
                    }
                    double deltaTime = EditorApplication.timeSinceStartup - lastTime;
                    timer += (float)deltaTime;
                    if (timer >= progressDuration)
                    {
                        timer = 0.0f;
                    }

                    float t = Mathf.Lerp(0, 1, timer/progressDuration.Value);
                    Target.UpdateProgress(t);
                    lastTime = EditorApplication.timeSinceStartup;
                    await UniTask.Yield();
                }
            }
        }

        private void SetPaused(bool paused)
        {
            isPaused = paused;
        }
        
        private void StopTween()
        {
            isPlaying = false;
            isPaused = false;
            
            foreach (KeyValuePair<Transform, TransformValuesCache> entry in transformToCacheDictionary)
            {
                Transform t = entry.Key;
                TransformValuesCache cache = entry.Value;
                if (cache.Position != null) 
                    t.localPosition = cache.Position.Value;
                if (cache.RotationEuler != null) 
                    t.localRotation = Quaternion.Euler(cache.RotationEuler.Value);
            }
        }
    }
}*/
# --- end Packages/com_ldx_framework/Editor/Scripts/Features/Interaction/TransformKinematicGrabbableEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Features/Machinery/MachineModuleContainerDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: cb727176ff5248d89de22857af246fb7
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Features.Machinery
{
    [CustomPropertyDrawer(typeof(MachineModuleContainer), true)]
    public class MachineModuleContainerDrawer : PropertyDrawer
    {
        private const float SLIDER_SPACING = 5f;

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            EditorGUI.BeginProperty(position, label, property);

            SerializedProperty actionProp = property.FindPropertyRelative("action");

            float propertyHeight = EditorGUI.GetPropertyHeight(actionProp, true);
            Rect propertyRect = new Rect(position.x, position.y, position.width, propertyHeight);
            EditorGUI.PropertyField(propertyRect, actionProp, label, true);
        
            if (ShouldShowEditorSetupControl(actionProp))
            {
                MachineModuleBase module = actionProp.managedReferenceValue as MachineModuleBase;
                if (module == null) return;
            
                EditorGUI.BeginChangeCheck();

                Rect controlRect = new Rect(
                    position.x,
                    propertyRect.yMax + SLIDER_SPACING,
                    position.width,
                    EditorGUIUtility.singleLineHeight
                );
            
                controlRect = EditorGUI.IndentedRect(controlRect);
            
                float newValue;
                
                
                if (module is BoomExtendModule boomExtendModule)
                {
                    newValue = EditorGUI.Slider(controlRect, "Editor Setup Position", boomExtendModule.CurrentValue, 0f, 1f);
                }
                // DEFAULT: Use standard controls for all other modules
                else
                {
                    newValue = module.UseLimits ? 
                        EditorGUI.Slider(controlRect, "Editor Setup Position", module.CurrentValue, module.Limits.x, module.Limits.y) : 
                        EditorGUI.FloatField(controlRect, "Editor Setup Value", module.CurrentValue);
                }

                if (EditorGUI.EndChangeCheck())
                {
                    List<Object> undoObjects = new List<Object> { property.serializedObject.targetObject };
                    List<Transform> transformsToRecord = module.EDITOR_GetTransformsToRecordForUndo();
                    if (transformsToRecord != null)
                    {
                        foreach (var t in transformsToRecord)
                        {
                            if(t != null) undoObjects.Add(t);
                        }
                    }
                    Undo.RecordObjects(undoObjects.ToArray(), "Adjust Crane Part Position");
                    module.EDITOR_SetValueFromEditor(newValue);
                    EditorUtility.SetDirty(property.serializedObject.targetObject);
                }
            }

            EditorGUI.EndProperty();
        }

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            float height = EditorGUI.GetPropertyHeight(property.FindPropertyRelative("action"), label, true);

            if (ShouldShowEditorSetupControl(property.FindPropertyRelative("action")))
            {
                height += EditorGUIUtility.singleLineHeight + SLIDER_SPACING;
            }

            return height;
        }

        private bool ShouldShowEditorSetupControl(SerializedProperty actionProp)
        {
            if (actionProp.managedReferenceValue == null || Application.isPlaying)
            {
                return false;
            }

            SerializedProperty enabledProp = actionProp.FindPropertyRelative("enabled");
            if (enabledProp == null)
            {
                return false;
            }
        
            // The control should show as long as the module is enabled, regardless of limits.
            return enabledProp.boolValue;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Features/Machinery/MachineModuleContainerDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Features/Machinery/MachineryControlsWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7aa47bd3ea314b4fbc4a16563180a235
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Utilities.Serializable;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Features.Machinery
{
    public class MachineryControlsWindow : EditorWindow
    {
        private readonly List<BaseMachineryController> sceneControllers = new();
        private readonly Dictionary<BaseMachineryController, bool> controllerFoldoutStates = new();
        private List<IMachineryInputModule> genericInputModules = new();
        private Dictionary<IMachineryInputModule, bool> genericModuleFoldoutStates = new();
        private Vector2 scrollPosition;
        
        [MenuItem("Info/Ldx Machinery/Machinery Controls Display")]
        public static void ShowWindow()
        {
            MachineryControlsWindow window = GetWindow<MachineryControlsWindow>("Machinery Controls");
            window.Show();
        }

        private void OnEnable()
        {
            FindAllInputProviders();
            EditorApplication.update += OnEditorUpdate;
        }

        private void OnDisable()
        {
            EditorApplication.update -= OnEditorUpdate;
        }
        
        private void FindAllInputProviders()
        {
            sceneControllers.Clear();
            controllerFoldoutStates.Clear();
            
            BaseMachineryController[] foundControllers = FindObjectsByType<BaseMachineryController>(FindObjectsSortMode.None);
            sceneControllers.AddRange(foundControllers);
            sceneControllers.Sort((a, b) => String.Compare(a.gameObject.name, b.gameObject.name, StringComparison.Ordinal));
            
            foreach (BaseMachineryController controller in sceneControllers)
            {
                controllerFoldoutStates[controller] = true;
            }
            
            IEnumerable<IMachineryInputModule> allModules = FindObjectsByType<MonoBehaviour>(FindObjectsSortMode.None).OfType<IMachineryInputModule>();

            foreach (IMachineryInputModule module in allModules)
            {
                genericInputModules.Add(module);
            }
            
            genericInputModules.Sort((a, b) => string.Compare((a as MonoBehaviour)?.name, (b as MonoBehaviour)?.name, StringComparison.Ordinal));
            foreach (IMachineryInputModule module in genericInputModules)
            {
                genericModuleFoldoutStates[module] = true;
            }
            
            Repaint();
        }
        
        private void OnEditorUpdate()
        {
            if (Application.isPlaying)
            {
                Repaint();
            }
        }

        private void OnGUI()
        {
            EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
            GUILayout.Label("Machinery Keyboard Controls", EditorStyles.boldLabel);
            GUILayout.FlexibleSpace();
            if (GUILayout.Button("Refresh", EditorStyles.toolbarButton))
            {
                FindAllInputProviders();
            }
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.Space();

            if (sceneControllers == null || sceneControllers.Count == 0)
            {
                EditorGUILayout.HelpBox("No machinery found in the current scene. Add a 'BaseMachineryController' to a GameObject or click 'Refresh' to scan again.", MessageType.Info);
                return;
            }

            scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition, GUILayout.ExpandHeight(true));

            foreach (BaseMachineryController controller in sceneControllers)
            {
                if (controller == null) continue; // Skip if controller was destroyed
                
                bool currentState = controllerFoldoutStates.GetValueOrDefault(controller, true);
                controllerFoldoutStates[controller] = EditorGUILayout.Foldout(currentState, controller.gameObject.name, true, EditorStyles.foldoutHeader);

                if (controllerFoldoutStates[controller])
                {
                    EditorGUI.indentLevel++;
                    DrawControllerInputs(controller);
                    EditorGUI.indentLevel--;
                }
                EditorGUILayout.Space(5); 
            }
            
            if (genericInputModules.Count > 0)
            {
                EditorGUILayout.Space(10);
                GUILayout.Label("Other Input Modules", EditorStyles.boldLabel);

                foreach (IMachineryInputModule module in genericInputModules)
                {
                    MonoBehaviour mb = module as MonoBehaviour;
                    if (mb == null) continue;

                    bool currentState = genericModuleFoldoutStates.TryGetValue(module, out bool state) ? state : true;
                    genericModuleFoldoutStates[module] = EditorGUILayout.Foldout(currentState, $"{mb.gameObject.name} ({mb.GetType().Name})", true, EditorStyles.foldoutHeader);

                    if (genericModuleFoldoutStates[module])
                    {
                        EditorGUI.indentLevel++;
                        DrawGenericModuleInputs(module);
                        EditorGUI.indentLevel--;
                    }
                }
            }

            EditorGUILayout.EndScrollView();
        }
        
        private void DrawControllerInputs(BaseMachineryController controller)
        {
            // Try to get the keyboard module from the controller's input module
            if (controller.InputModule is not KeyboardMachineryInputModule keyboardModule)
            {
                EditorGUILayout.HelpBox("This controller does not have a configured 'KeyboardMachineryInputModule' accessible.", MessageType.Warning);
                return;
            }
            
            SerializableDictionary<OperationType, KeyboardMachineryInputModule.OperationInput> operationInputs = keyboardModule.OperationInputsMap;
            SerializableDictionary<OperationType, OperationInputDirection> debugInputs = keyboardModule.InputDebugsMap; // For highlighting

            if (operationInputs == null || operationInputs.Count == 0)
            {
                EditorGUILayout.HelpBox("No keyboard inputs configured in this module.", MessageType.Info);
                return;
            }
            
            foreach (KeyValuePair<OperationType, KeyboardMachineryInputModule.OperationInput> opEntry in operationInputs)
            {
                OperationType operationType = opEntry.Key;
                KeyboardMachineryInputModule.OperationInput inputConfig = opEntry.Value;

                EditorGUILayout.BeginVertical(EditorStyles.helpBox);
                EditorGUILayout.LabelField(operationType.ToString(), EditorStyles.boldLabel);

                if (inputConfig.inputDirectionMap is { Count: > 0 })
                {
                    EditorGUI.indentLevel++;
                    foreach (KeyValuePair<OperationInputDirection, KeyCode> directionEntry in inputConfig.inputDirectionMap)
                    {
                        OperationInputDirection dir = directionEntry.Key;
                        KeyCode key = directionEntry.Value;

                        bool isActive = false;
                        if (Application.isPlaying && debugInputs != null && debugInputs.TryGetValue(operationType, out OperationInputDirection activeDir))
                        {
                            isActive = activeDir == dir;
                        }
                        
                        string labelText = $"{dir}: [{key}]";
                        if (isActive)
                        {
                            GUIStyle activeStyle = new(EditorStyles.label)
                            {
                                normal = { textColor = Color.green },
                                fontStyle = FontStyle.Bold
                            };
                            EditorGUILayout.LabelField(labelText, activeStyle);
                        }
                        else
                        {
                            EditorGUILayout.LabelField(labelText);
                        }
                    }
                    EditorGUI.indentLevel--;
                }
                else
                {
                    EditorGUI.indentLevel++;
                    EditorGUILayout.LabelField("No keys configured.", EditorStyles.centeredGreyMiniLabel);
                    EditorGUI.indentLevel--;
                }
                EditorGUILayout.EndVertical();
            }
        }
        
        private void DrawGenericModuleInputs(IMachineryInputModule module)
        {
            List<(KeyCode key, string label)> inputs = module.GetInputs();

            if (inputs == null || inputs.Count == 0)
            {
                EditorGUILayout.HelpBox("This module has not defined any inputs.", MessageType.Info);
                return;
            }

            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            
            foreach ((KeyCode key, string label) input in inputs)
            {
                bool isActive = Application.isPlaying && Input.GetKey(input.key);
                
                string labelText = $"{input.label}: [{input.key}]";
                
                if (isActive)
                {
                    GUIStyle activeStyle = new GUIStyle(EditorStyles.label)
                    {
                        normal = { textColor = Color.green },
                        fontStyle = FontStyle.Bold
                    };
                    EditorGUILayout.LabelField(labelText, activeStyle);
                }
                else
                {
                    EditorGUILayout.LabelField(labelText);
                }
            }
            
            EditorGUILayout.EndVertical();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Features/Machinery/MachineryControlsWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Features/Measurement/RulerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 16136f155ea94baab5a469f767eb3329
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Features.Measurement
{
	using UnityEditor;
	using UnityEngine;

	[CustomEditor(typeof(RulerMaker))]
	public class RulerEditor : Editor
	{
		private SerializedProperty unitProp;
		private SerializedProperty numberOfMarksProp;
		private SerializedProperty smallMarksPerBigMarkProp;
		private SerializedProperty markSpacingProp;
		private SerializedProperty numberPrefabProp;
		private SerializedProperty transformsList;
		private SerializedProperty rulerMat;
		private SerializedProperty freezeBool;

		private void OnEnable()
		{
			unitProp = serializedObject.FindProperty("unit");
			numberOfMarksProp = serializedObject.FindProperty("numberOfMarks");
			smallMarksPerBigMarkProp = serializedObject.FindProperty("smallMarksPerBigMark");
			markSpacingProp = serializedObject.FindProperty("markSpacing");
			numberPrefabProp = serializedObject.FindProperty("numberPrefab");
			transformsList = serializedObject.FindProperty("RulerMarks");
			freezeBool = serializedObject.FindProperty("freezeRuler");
			rulerMat = serializedObject.FindProperty("rulerMaterial");
			
		}

		public override void OnInspectorGUI()
		{
			RulerMaker ruler = (RulerMaker)target;
			serializedObject.Update();
			EditorGUI.BeginChangeCheck();
			
			// Check if the Ruler component is part of a prefab instance
			PrefabInstanceStatus prefabInstanceStatus = PrefabUtility.GetPrefabInstanceStatus(ruler.gameObject);
			if (prefabInstanceStatus == PrefabInstanceStatus.Connected)
			{
				EditorGUILayout.HelpBox("Warning: If you don't unpack this prefab, creation functions will not work.", MessageType.Info);
			}

			EditorGUILayout.PropertyField(unitProp, new GUIContent("Measurement Unit"));
			EditorGUILayout.PropertyField(numberOfMarksProp, new GUIContent($"Total {unitProp.enumNames[unitProp.enumValueIndex]}"));
			EditorGUILayout.PropertyField(smallMarksPerBigMarkProp, new GUIContent("Small Marks Per Big Mark"));
			EditorGUILayout.PropertyField(markSpacingProp, new GUIContent("Mark Spacing"));
			EditorGUILayout.PropertyField(numberPrefabProp, new GUIContent("Number Prefab"));
			EditorGUILayout.PropertyField(transformsList, new GUIContent("Ruler Markings"));
			EditorGUILayout.PropertyField(rulerMat, new GUIContent("Ruler Material"));
			EditorGUILayout.PropertyField(freezeBool, new GUIContent("Freeze Ruler"));
			
			if (GUILayout.Button("Create 3D Ruler"))
				ruler.CreateCube();
			
			if (GUILayout.Button("Create Ruler Markings"))
				ruler.CreateRulerMarks();
			
			if (GUILayout.Button("Clear Ruler"))
				ruler.CleanHierarchy();
			
			if (EditorGUI.EndChangeCheck())
			{
				// Handle changes to the properties and update the ruler accordingly
				serializedObject.ApplyModifiedProperties();
				ruler.CreateRulerMarks();
			}
		}
	}

}
# --- end Packages/com_ldx_framework/Editor/Scripts/Features/Measurement/RulerEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Features/ProjectDefinesFeatures.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 9b3449160dbb4eae88ba44976b232f2d
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;

namespace Ldx.Framework.Features
{
    /// <summary>
    /// Features for setting up the project
    /// </summary>
    public static class ProjectDefinesFeatures
    {
        private enum TargetRenderPipeline
        {
            BuiltIn = 0,
            URP
        }
        
        private const string RENDER_URP_DEFINE = "LDX_RENDER_URP";
        private const string RENDER_BUILTIN_DEFINE = "LDX_RENDER_BUILTIN";
        private const string UNITASK_DOTWEEN_SUPPORT_DEFINE = "UNITASK_DOTWEEN_SUPPORT";
        private const string LDX_INTERNAL_DEBUG_DEFINE = "LDX_INTERNAL_DEBUG";

        /// <summary>
        /// Sets up the needed project defines
        /// </summary>
        [MenuItem("LogicalDox/Project Setup/Setup Project Defines")]
        public static void SetupProjectDefines()
        {
            // Get the project defines, gives us a string separated by a ;
            List<string> androidDefines = PlayerSettings.GetScriptingDefineSymbols(UnityEditor.Build.NamedBuildTarget.Android)
                .Split(';')
                .ToList();
            
            List<string> standaloneDefines = PlayerSettings.GetScriptingDefineSymbols(UnityEditor.Build.NamedBuildTarget.Standalone)
                .Split(';')
                .ToList();
           
            TargetRenderPipeline pipeline = ProjectUtilities.IsProjectUsingURP()
                ? TargetRenderPipeline.URP
                : TargetRenderPipeline.BuiltIn;
            
            string renderDefineStr =
                pipeline == TargetRenderPipeline.URP ? RENDER_URP_DEFINE : RENDER_BUILTIN_DEFINE;
            
            // Just to confirm we're adding the right render define
            if (!EditorUtility.DisplayDialog("Message",
                    $"Your detected rendering pipeline is: {pipeline.ToString()}\n\nContinue with the setup?",
                    "Yes",
                    "No"))
            {
                return;
            }
            
            // To avoid duplicates, we first remove any related define
            cleanDefinesList(androidDefines);
            cleanDefinesList(standaloneDefines);

            List<string> setupDefinesToAdd = new List<string>() { UNITASK_DOTWEEN_SUPPORT_DEFINE, renderDefineStr };
            
            addSetupDefines(androidDefines, setupDefinesToAdd);
            addSetupDefines(standaloneDefines, setupDefinesToAdd);
            
            standaloneDefines.Add(LDX_INTERNAL_DEBUG_DEFINE);
            
            applyListToProject(androidDefines, UnityEditor.Build.NamedBuildTarget.Android);
            applyListToProject(standaloneDefines, UnityEditor.Build.NamedBuildTarget.Standalone);

            string addedDefinesListStr = String.Join('\n', setupDefinesToAdd.Select(d => $"\t- {d}"));

            EditorUtility.DisplayDialog("Success",
                $"Process is complete.\nThe following defines were added:\n{addedDefinesListStr}",
                "Ok");

            void addSetupDefines(List<string> source, List<string> toAdd)
            {
                // List<T>.Union() would need to replace the reference, and I don't want to make source a ref
                toAdd.ForEach(source.Add);
            }

            void applyListToProject(List<string> list, UnityEditor.Build.NamedBuildTarget target)
            {
                string defines = String.Join(';', list);
                PlayerSettings.SetScriptingDefineSymbols(target, defines);
            }
            
            void cleanDefinesList(List<string> list)
            {
                list.Remove(RENDER_URP_DEFINE);
                list.Remove(RENDER_BUILTIN_DEFINE);
                list.Remove(UNITASK_DOTWEEN_SUPPORT_DEFINE);
            }
        }

        public static void AddInternalBuildDefines()
        {
            // Get the project defines, gives us a string separated by a ;
            List<string> androidDefines = PlayerSettings.GetScriptingDefineSymbols(UnityEditor.Build.NamedBuildTarget.Android)
                .Split(';')
                .ToList();

            if (androidDefines.Contains(LDX_INTERNAL_DEBUG_DEFINE))
            {
                return;
            }
            
            androidDefines.Add(LDX_INTERNAL_DEBUG_DEFINE);
            string definesString = String.Join(';', androidDefines);
            PlayerSettings.SetScriptingDefineSymbols(UnityEditor.Build.NamedBuildTarget.Android, definesString);
        }
        
        public static void RemoveInternalBuildDefines()
        {
            // Get the project defines, gives us a string separated by a ;
            List<string> androidDefines = PlayerSettings.GetScriptingDefineSymbols(UnityEditor.Build.NamedBuildTarget.Android)
                .Split(';')
                .ToList();

            if (!androidDefines.Contains(LDX_INTERNAL_DEBUG_DEFINE))
            {
                return;
            }
            
            androidDefines.Remove(LDX_INTERNAL_DEBUG_DEFINE);
            string definesString = String.Join(';', androidDefines);
            PlayerSettings.SetScriptingDefineSymbols(UnityEditor.Build.NamedBuildTarget.Android, definesString);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Features/ProjectDefinesFeatures.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Features/Splines/SplineMasterControllerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f994403eab02c394a8b44ef2701dd7cb
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

namespace Ldx.Framework.Features.Splines
{
    /// <summary>
    /// The editor script responsible for drawing the inspector attributes for the Spline Master Controller.
    /// </summary>
    [CustomEditor(typeof(SplineMasterController))]
    public class SplineMasterControllerEditor : Editor
    {
        private readonly Dictionary<SplineFeature.SplineFeatureType, bool> featureSelection = new();
        private bool showAddFeatureOptions;
        private readonly Dictionary<SplineFeature, bool> showSetupInstructions = new();

        static SplineMasterControllerEditor()
        {
            EditorApplication.playModeStateChanged += OnPlayModeStateChanged;
        }

        private static void OnPlayModeStateChanged(PlayModeStateChange state)
        {
            if (state == PlayModeStateChange.ExitingEditMode)
            {
                SplineMasterController controller = FindAnyObjectByType<SplineMasterController>();
                if (controller != null)
                {
                    string validationMessage = ValidateController(controller);
                    if (!string.IsNullOrEmpty(validationMessage))
                    {
                        EditorUtility.DisplayDialog("Play Mode Blocked", validationMessage, "OK");
                        EditorApplication.isPlaying = false;
                    }
                }
            }
        }

        private static string ValidateController(SplineMasterController controller)
        {
            if (controller.VisualsActive)
            {
                StaticVisualSplineFeature visualFeature 
                    = controller.splineFeatures.OfType<StaticVisualSplineFeature>().Single();
                if (visualFeature.GetVisualNodeTransforms().Length == 0 
                    || visualFeature.GetVisualNodeTransforms().Any(t => t == null))
                {
                    return $"The Game Object '{controller.gameObject.name}' has the Visuals feature active but not " +
                           "properly set up. Ensure there is at least 1 visual node and that all visual node " +
                           "transforms are assigned. Alternatively, you can remove this feature from the object.";
                }
            }

            if (controller.AnimationFeatureActive)
            {
                AnimationSplineFeature animationFeature 
                    = controller.splineFeatures.OfType<AnimationSplineFeature>().Single();
                if (animationFeature.GetAnimationNodeTransforms().Length == 0 
                    || animationFeature.GetAnimationNodeTransforms().Any(t => t == null))
                {
                    return $"The Game Object '{controller.gameObject.name}' has the Animation feature active but not " +
                           "properly set up. Ensure there is at least 1 animation node and that all animation node " +
                           "transforms are assigned. Alternatively, you can remove this feature from the object.";
                }
            }

            if (controller.GrabbingActive)
            {
                GrabbingSplineFeature grabbingFeature 
                    = controller.splineFeatures.OfType<GrabbingSplineFeature>().Single();
                if (grabbingFeature.GetGrabStartNodeTransform() == null 
                    || grabbingFeature.GetGrabPointNodeTransform() == null 
                    || grabbingFeature.GetGrabPointFinalTargetPosition() == null 
                    || grabbingFeature.GetGrabbable() == null)
                {
                    return $"The Game Object '{controller.gameObject.name}' has the Grabbing feature active but " +
                           "not properly set up. Ensure start point, grab point, target point, and grabbable are " +
                           "assigned. Alternatively, you can remove this feature from the object.";
                }
            }

            return null;
        }

        private void OnEnable()
        {
            featureSelection.Clear();
            foreach (SplineFeature.SplineFeatureType featureType in System.Enum.GetValues(typeof(SplineFeature.SplineFeatureType)))
            {
                featureSelection[featureType] = false;
            }
        }

        public override void OnInspectorGUI()
        {
            SplineMasterController controller = (SplineMasterController)target;
            serializedObject.Update();

            // Ensure feature status is verified on every draw
            controller.VerifyFeatureStatus();

            // Display serialized properties except the splineFeatures list
            DrawPropertiesExcluding(serializedObject, nameof(controller.splineFeatures));

            // Draw header
            EditorGUILayout.LabelField("Spline Features:", EditorStyles.boldLabel);

            // Check if there are any features left to add
            bool anyFeatureLeftToAdd = featureSelection.Keys.Any(feature => !IsFeatureActive(controller, feature));

            if (anyFeatureLeftToAdd)
            {
                // Horizontal layout for the plus button
                EditorGUILayout.BeginHorizontal();
                if (GUILayout.Button("+", GUILayout.ExpandWidth(false)))
                {
                    showAddFeatureOptions = !showAddFeatureOptions;
                }
                
                EditorGUILayout.EndHorizontal();

                if (showAddFeatureOptions)
                {
                    // Display checkboxes for selecting features to add
                    foreach (SplineFeature.SplineFeatureType feature in from feature in featureSelection.Keys.ToList() let isFeatureActive = IsFeatureActive(controller, feature) where !isFeatureActive select feature)
                    {
                        featureSelection[feature] = EditorGUILayout.ToggleLeft(FormatFeatureName(feature.ToString()), featureSelection[feature]);
                    }

                    // Centered button for adding selected features
                    EditorGUILayout.BeginHorizontal();
                    GUILayout.FlexibleSpace();
                    if (GUILayout.Button("Add Selected Features", GUILayout.ExpandWidth(false)))
                    {
                        foreach (SplineFeature.SplineFeatureType feature in featureSelection
                                     .Where(f => f.Value)
                                     .Select(f => f.Key))
                        {
                            controller.AddFeature(feature);
                            // Set default state of setup instructions to expanded
                            SplineFeature addedFeature = controller.splineFeatures.Last();
                            SetFoldoutState(addedFeature, true);
                        }

                        // Reset selections and hide the options
                        foreach (SplineFeature.SplineFeatureType key in featureSelection.Keys.ToList())
                        {
                            featureSelection[key] = false;
                        }

                        showAddFeatureOptions = false;

                        // Apply changes and mark object as dirty
                        serializedObject.ApplyModifiedProperties();
                        EditorUtility.SetDirty(controller);
                    }
                    
                    GUILayout.FlexibleSpace();
                    EditorGUILayout.EndHorizontal();
                }
            }

            // Draw a separator
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("", GUI.skin.horizontalSlider);

            // Display currently added features
            SerializedProperty featuresProperty = serializedObject.FindProperty("splineFeatures");
            if (featuresProperty is { isArray: true, arraySize: > 0 })
            {
                List<int> indicesToRemove = new();
                for (int i = 0; i < featuresProperty.arraySize; i++)
                {
                    SerializedProperty featureProperty = featuresProperty.GetArrayElementAtIndex(i);
                    if (featureProperty == null)
                    {
                        continue;
                    }
                    EditorGUILayout.BeginHorizontal();
                    string featureTypeName = featureProperty.managedReferenceFullTypename.Split('.').Last();
                    EditorGUILayout.LabelField(FormatFeatureName(featureTypeName));
                    if (GUILayout.Button("-", GUILayout.ExpandWidth(false)))
                    {
                        SplineFeature featureInstance = (SplineFeature)featureProperty.managedReferenceValue;
                        if (featureInstance != null)
                        {
                            controller.RemoveFeature(featureInstance);
                            indicesToRemove.Add(i);
                            serializedObject.ApplyModifiedProperties();
                            EditorUtility.SetDirty(controller);
                        }
                    }
                        
                    EditorGUILayout.EndHorizontal();

                    // Add setup instructions button and text
                    SplineFeature setupFeatureInstance = (SplineFeature)featureProperty.managedReferenceValue;
                    if (setupFeatureInstance != null)
                    {
                        if (!showSetupInstructions.ContainsKey(setupFeatureInstance))
                        {
                            showSetupInstructions[setupFeatureInstance] = GetFoldoutState(setupFeatureInstance);
                        }

                        bool foldoutState = EditorGUILayout.Foldout(showSetupInstructions[setupFeatureInstance], "Setup Instructions");
                        if (foldoutState != showSetupInstructions[setupFeatureInstance])
                        {
                            showSetupInstructions[setupFeatureInstance] = foldoutState;
                            SetFoldoutState(setupFeatureInstance, foldoutState);
                        }

                        if (showSetupInstructions[setupFeatureInstance])
                        {
                            EditorGUILayout.HelpBox(setupFeatureInstance.SetupInstructions, MessageType.Info);
                        }
                    }

                    // Draw the custom properties of each feature
                    DrawFeatureProperties(featureProperty);

                    // Add a separator line between features
                    EditorGUILayout.Space();
                    EditorGUILayout.LabelField("", GUI.skin.horizontalSlider);
                }

                // Remove elements after the iteration to avoid modifying the collection during iteration
                foreach (int index in indicesToRemove.OrderByDescending(i => i))
                {
                    featuresProperty.DeleteArrayElementAtIndex(index);
                }
            }
            else
            {
                EditorGUILayout.LabelField("No features added.");
            }

            // Save changes
            serializedObject.ApplyModifiedProperties();
        }

        private static bool IsFeatureActive(SplineMasterController controller, SplineFeature.SplineFeatureType featureType)
        {
            return featureType switch
            {
                SplineFeature.SplineFeatureType.StaticVisualSplineFeature => controller.VisualsActive,
                SplineFeature.SplineFeatureType.AnimationSplineFeature => controller.AnimationFeatureActive,
                SplineFeature.SplineFeatureType.GrabbingSplineFeature => controller.GrabbingActive,
                _ => false
            };
        }

        private static string FormatFeatureName(string featureName)
        {
            // Remove "SplineFeature" suffix
            if (featureName.EndsWith("SplineFeature"))
            {
                featureName = featureName.Substring(0, featureName.Length - "SplineFeature".Length);
            }

            // Add spaces before capital letters (except the first)
            for (int i = 1; i < featureName.Length; i++)
            {
                if (char.IsUpper(featureName[i]))
                {
                    featureName = featureName.Insert(i, " ");
                    i++; // Skip the next character to avoid infinite loop
                }
            }

            return featureName;
        }

        private static void DrawFeatureProperties(SerializedProperty featureProperty)
        {
            if (featureProperty == null)
            {
                return;
            }

            EditorGUI.indentLevel++;
            SerializedProperty prop = featureProperty.Copy();
            SerializedProperty endProp = prop.GetEndProperty();

            prop.NextVisible(true); // Move to the first property

            while (!SerializedProperty.EqualContents(prop, endProp))
            {
                // Skip drawing the SetupInstructions property
                if (prop.name == "setupInstructions")
                {
                    prop.NextVisible(false);
                    continue;
                }

                if (prop.isArray && prop.propertyType == SerializedPropertyType.Generic)
                {
                    EditorGUILayout.PropertyField(prop, true);
                    prop.NextVisible(false); // Move to the next property
                }
                else if (prop.propertyType != SerializedPropertyType.ArraySize)
                {
                    EditorGUILayout.PropertyField(prop, true);
                    prop.NextVisible(false); // Move to the next property
                }
            }

            EditorGUI.indentLevel--;
        }

        private void SetFoldoutState(SplineFeature feature, bool state)
        {
            EditorPrefs.SetBool(GetFoldoutKey(feature), state);
        }

        private bool GetFoldoutState(SplineFeature feature)
        {
            return EditorPrefs.GetBool(GetFoldoutKey(feature), true); // Default to true (expanded)
        }

        private string GetFoldoutKey(SplineFeature feature)
        {
            return $"{target.GetInstanceID()}_{feature.GetType().Name}_Foldout";
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Features/Splines/SplineMasterControllerEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Features/Visual/MaterialConverter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 30122f5beee34bd7a8b7e76d6058a9b7
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Features.Visual
{
    public static class MaterialConverter
    {
        [MenuItem("LogicalDox/Material/Convert to Fade Shader", true)]
        public static bool ValidateMaterialConversion()
        {
            return Selection.activeObject is Material;
        }

        [MenuItem("LogicalDox/Material/Convert to Fade Shader")]
        public static void ConvertToCustomShader()
        {
            Material selectedMaterial = Selection.activeObject as Material;
            if (selectedMaterial == null)
            {
                Debug.LogError("No material selected.");
                return;
            }
        
            if (selectedMaterial.shader.name != "Universal Render Pipeline/Lit")
            {
                Debug.LogError("Selected material is not using the URP/Lit shader.");
                return;
            }
        
            Shader customShader = Shader.Find("Shader Graphs/FadeShader");
            if (customShader == null)
            {
                Debug.LogError("Custom shader not found.");
                return;
            }

            Texture baseMap = selectedMaterial.HasProperty("_BaseMap") ? selectedMaterial.GetTexture("_BaseMap") : null;
            Color baseColor = selectedMaterial.HasProperty("_Color") ? selectedMaterial.GetColor("_Color") : Color.white;
            Texture metallicMap = selectedMaterial.HasProperty("_MetallicGlossMap") ? selectedMaterial.GetTexture("_MetallicGlossMap") : null;
            float smoothness = selectedMaterial.HasProperty("_Smoothness") ? selectedMaterial.GetFloat("_Smoothness") : 0f;
            Texture normalMap = selectedMaterial.HasProperty("_BumpMap") ? selectedMaterial.GetTexture("_BumpMap") : null;
            Texture occlusionMap = selectedMaterial.HasProperty("_OcclusionMap") ? selectedMaterial.GetTexture("_OcclusionMap") : null;
        
            selectedMaterial.shader = customShader;

            // Reassign the saved textures and parameters to the new shader
            if (selectedMaterial.HasProperty("_Base_Map"))
                selectedMaterial.SetTexture("_Base_Map", baseMap);
        
            if (selectedMaterial.HasProperty("_Color"))
                selectedMaterial.SetColor("_Color", baseColor);

            if (selectedMaterial.HasProperty("_Metallic_Map"))
                selectedMaterial.SetTexture("_Metallic_Map", metallicMap);

            if (selectedMaterial.HasProperty("_Smoothness"))
                selectedMaterial.SetFloat("_Smoothness", smoothness);

            if (selectedMaterial.HasProperty("_Normal_Map"))
                selectedMaterial.SetTexture("_Normal_Map", normalMap);

            if (selectedMaterial.HasProperty("_Occlusion_Map"))
                selectedMaterial.SetTexture("_Occlusion_Map", occlusionMap);

            // Set surface type to transparent and disable preserve specular light
            selectedMaterial.SetFloat("_Surface", 1); // 1 for transparent
            selectedMaterial.SetFloat("_BlendModePreserveSpecular", 0); // 0 to disable

            selectedMaterial.name += "_Fade";
            AssetDatabase.RenameAsset(AssetDatabase.GetAssetPath(selectedMaterial), $"{selectedMaterial.name}");
            AssetDatabase.SaveAssets();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Features/Visual/MaterialConverter.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Features/Visual/Tweening/ObjectTweenerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: ce31fb5241bc47a08a749d0f33cf0ba8
# ASMDEF: ldx.framework.editor.dll
# ---
using Cysharp.Threading.Tasks;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEditor.Callbacks;
using UnityEngine;

namespace Ldx.Framework.Features.Visual.Tweening
{
    /// <summary>
    /// Editor for object tweener, used for simulation
    /// </summary>
    [CustomEditor(typeof(ObjectTweener))]
    public class ObjectTweenerEditor : Editor
    {
        private bool isPlaying;
        private bool isPaused;
        private static ObjectTweenerEditor lastEditor;
        private int lastIndex;
        
        private int? CurrentIndex => Target.CurrentIndex;
        private ObjectTweener Target => (ObjectTweener)target;

        private void OnEnable()
        {
            lastEditor = this;
        }

        private void OnDestroy()
        {
            StopTween();
            if (lastEditor == this)
            {
                lastEditor = null;
            }
        }
        
        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
            LdxEditorHelper.DrawHorizontalSeparator();
            LdxEditorHelper.DrawTitle("Simulation");
            DrawPlayStopButtons();
            DrawStepProgress();
        }
        
        private void DrawPlayStopButtons()
        {
            GUI.enabled = !isPlaying;
            if (GUILayout.Button("Play"))
            {
                PlayTween();
            }

            GUI.enabled = isPlaying;
            if (GUILayout.Button(isPaused? "Unpause" : "Pause"))
            {
                SetPaused(!isPaused);
            }
            
            if (GUILayout.Button("Stop"))
            {
                StopTween();
            }

            GUI.enabled = true;
        }

        private void DrawStepProgress()
        {
            if (!isPlaying || CurrentIndex == null)
            {
                return;
            }

            EditorGUILayout.LabelField($"Step: {CurrentIndex.Value+1}/{lastIndex+1}");
            Repaint();
        }

        private void SetPaused(bool paused)
        {
            isPaused = paused;
        }
        
        private void PlayTween()
        {
            isPlaying = true;
            Target.Initialize();
            lastIndex = Target.LastIndex;
            double lastTime = EditorApplication.timeSinceStartup;
            
            playTweenAsync().Forget();
            
            async UniTaskVoid playTweenAsync()
            {
                await UniTask.Yield();
                Target.Play();
                while (isPlaying)
                {
                    if (isPaused)
                    {
                        lastTime = EditorApplication.timeSinceStartup;
                        await UniTask.Yield();
                        continue;
                    }
                    float deltaTime = (float) (EditorApplication.timeSinceStartup - lastTime);

                    Target.EDITOR_Update(deltaTime);
                    
                    lastTime = EditorApplication.timeSinceStartup;
                    
                    if (!Target.IsPlaying && !Target.Loop)
                    {
                        break;
                    }
                    await UniTask.Yield();
                }
                Target?.ResetAllTweens();
                StopTween();
            }
        }
        
        private void StopTween()
        {
            isPlaying = false;
            isPaused = false;

            if (Application.isPlaying)
            {
                return;
            }
            Target.Stop();
            Target.Terminate();
            Target.ResetAllTweens();
        }

        [DidReloadScripts]
        private static void HandleReloadScripts()
        {
            lastEditor?.StopTween();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Features/Visual/Tweening/ObjectTweenerEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/AddOns/AddOnConfigsGlobalDataSanitization.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 4caa75e97ccf41eb979aae09e7cd65ed
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Utilities.Attributes;

namespace Ldx.Framework.Systems.AddOns
{
    /// <summary>
    /// Scene saving script that sanitizes GlobalData by ensuring all the relevant AddOnConfig(s) are added
    /// </summary>
    [SceneSavingAddOn]
    public class AddOnConfigsGlobalDataSanitization
    {
        public static void SceneSaving()
        {
            Type addOnConfigBaseType = typeof(AddOnConfig);
            AddOnConfigsContainer addOnConfigsContainer = GlobalData.Instance.AddOnsConfigs;
            Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();

            List<Type> addonTypes = assemblies
                .SelectMany(assembly =>
                {
                    try
                    {
                        return assembly.GetTypes();
                    }
                    catch (ReflectionTypeLoadException e)
                    {
                        return e.Types.Where(t => t != null);
                    }
                })
                .Where(type => type != null && addOnConfigBaseType.IsAssignableFrom(type)
                                            && !type.IsAbstract && type != addOnConfigBaseType)
                .ToList();

            MethodInfo tryAddGenericMethod = typeof(AddOnConfigsContainer)
                .GetMethod(nameof(AddOnConfigsContainer.TryAdd), BindingFlags.Public | BindingFlags.Instance);

            foreach (Type type in addonTypes)
            {
                MethodInfo constructedMethod = tryAddGenericMethod.MakeGenericMethod(type);
                constructedMethod.Invoke(addOnConfigsContainer, null);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/AddOns/AddOnConfigsGlobalDataSanitization.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/AudioSystem/AudioEmitterEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b1890009cd7ff75419506869c76db2a5
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.AudioSystem
{
    [CustomEditor(typeof(AudioEmitter))]
    public class AudioEmitterEditor : Editor
    {
        // Get the strings of the fields in a way that updates it field names are changed:
        private static readonly string IsGrabbableString = 
            FormatToCamel(nameof(InteractionSoundsFeature.IsGrabbable));
        private static readonly string HandGrabbedSoundString =
            FormatToCamel(nameof(InteractionSoundsFeature.HandGrabbedSound));
        private static readonly string HandReleasedSoundString =
            FormatToCamel(nameof(InteractionSoundsFeature.HandReleasedSound));
        private static readonly string SocketedSoundString =
            FormatToCamel(nameof(InteractionSoundsFeature.SocketedSound));
        private static readonly string RemovedFromSocketSoundString = 
            FormatToCamel(nameof(InteractionSoundsFeature.RemovedFromSocketSound));
        private static readonly string ActivatedStartSoundString = 
            FormatToCamel(nameof(InteractionSoundsFeature.ActivatedStartSound));
        private static readonly string ActivatedLoopSoundString = 
            FormatToCamel(nameof(InteractionSoundsFeature.ActivatedLoopSound));
        private static readonly string ActivatedLoopStartOverlapTimeString = 
            FormatToCamel(nameof(InteractionSoundsFeature.ActivatedLoopStartOverlapTime));
        private static readonly string DeactivatedSoundString = 
            FormatToCamel(nameof(InteractionSoundsFeature.DeactivatedSound));
        private static readonly string PlacedSoundString = 
            FormatToCamel(nameof(InteractionSoundsFeature.PlacedSound));
        private static readonly string CustomInteractionSoundString = 
            FormatToCamel(nameof(InteractionSoundsFeature.CustomInteractionSound));
        private static readonly string PlacedSoundTriggerEventString = 
            FormatToCamel(nameof(InteractionSoundsFeature.PlacedSoundTriggerEvent));
        private static readonly string CustomInteractionSoundTriggerEventString = 
            FormatToCamel(nameof(InteractionSoundsFeature.CustomInteractionSoundTriggerEvent));
        private static readonly string PressedSoundString = 
            FormatToCamel(nameof(InteractionSoundsFeature.PressedSound));
        private static readonly string DroppedSoundString = 
            FormatToCamel(nameof(CollisionSoundsFeature.DroppedSound));
        private static readonly string GroundColliderString = 
            FormatToCamel(nameof(CollisionSoundsFeature.GroundCollider));
        private static readonly string PrimaryImpactSoundString = 
            FormatToCamel(nameof(CollisionSoundsFeature.PrimaryImpactSound));
        private static readonly string SecondaryImpactSoundString = 
            FormatToCamel(nameof(CollisionSoundsFeature.SecondaryImpactSound));
        
        // Static mappings of tooltips to display since the default property drawer tooltips get overridden.
        // These get displayed as a help icon beside the property label
        private static readonly Dictionary<string, string> TooltipByName = new()
        {
            { HandGrabbedSoundString, "Plays when object is grabbed by player" },
            { HandReleasedSoundString, "Plays when object released by player" },
            { SocketedSoundString, "Plays when object is placed into a socket" },
            { RemovedFromSocketSoundString, "Plays when object is removed from a socket" },
            { ActivatedStartSoundString, "Plays when held object is activated" },
            { ActivatedLoopSoundString, "Plays after the activated start sound for as long as it is activated" },
            { ActivatedLoopStartOverlapTimeString, "Amount before the end of the activated start sound that the " +
                                                   "loop sound will start"},
            { DeactivatedSoundString, "Plays when held object is deactivated" },
            { PlacedSoundString, "Plays when object is positioned or returned to start/table" },
            { CustomInteractionSoundString, "Plays when triggered by a predetermined event related to the object"},
            { PlacedSoundTriggerEventString, "Event that will trigger the object placed sound"},
            { CustomInteractionSoundTriggerEventString, "Event that will trigger the object custom interaction sound"},
            { PressedSoundString, "If object is a button or switch and the player presses/moves it, this sound" +
                                  " plays. Requires a trigger on the object." },
            { DroppedSoundString, "Plays when held object is dropped on the ground" },
            { GroundColliderString, "Triggers the dropped sound on collision instead of primary impact sound" },
            { PrimaryImpactSoundString, "Plays when held object collides with objects in the environment with " +
                                        "assigned collider"},
            { SecondaryImpactSoundString, "Only used if object has multiple materials to set the material type of" +
                                          " the other part for impacts(Not Yet Implemented)"}
        };
        
        // Default fields
        private AudioEmitter targetAudioEmitter;
        private SerializedProperty playOnEventProperty;
        private SerializedProperty soundReferenceProperty;
        private SerializedProperty playOnEnableProperty;
        private SerializedProperty playOnStartProperty;
        private SerializedProperty visualizeMinAndMaxDistancesProperty;

        // Fields Specific To Features
        private SerializedProperty featuresProperty;
        private bool showAddFeatureMenu;
        private readonly Dictionary<Type, bool> featureAddSelections = new();
        private readonly Dictionary<AudioEmitterFeature, bool> foldoutByFeature = new();

        private void OnEnable()
        {
            // Original properties
            targetAudioEmitter = (AudioEmitter)target;
            playOnEventProperty = serializedObject.FindProperty("playOnTrackingEvent");
            soundReferenceProperty = serializedObject.FindProperty("mainSoundReference");
            visualizeMinAndMaxDistancesProperty = serializedObject.FindProperty("visualizeMinAndMaxDistances");
            playOnEnableProperty = serializedObject.FindProperty("playOnEnable");
            playOnStartProperty = serializedObject.FindProperty("playOnStart");

            // New property for features
            featuresProperty = serializedObject.FindProperty("features");

            // Build a list of all AudioEmitterFeature subclasses
            featureAddSelections.Clear();
            Assembly featureAssembly = Assembly.GetAssembly(typeof(AudioEmitterFeature));
            Type[] allTypes = featureAssembly.GetTypes();
            for (int i = 0; i < allTypes.Length; i++)
            {
                Type t = allTypes[i];
                if (t.IsSubclassOf(typeof(AudioEmitterFeature)) && !t.IsAbstract)
                {
                    featureAddSelections[t] = false;
                }
            }

            // Refresh global settings table
            AudioGlobalSettings.EDITOR_UpdateSoundGUIDToPathTable();
        }

        private void OnDisable()
        {
            targetAudioEmitter.EDITOR_UnloadEditorCachedSound();
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            // Draw script reference
            GUI.enabled = false;
            EditorGUILayout.ObjectField("Script", MonoScript.FromMonoBehaviour(targetAudioEmitter),
                typeof(AudioEmitter), false);
            EditorGUILayout.Space(10);
            GUI.enabled = true;

            // Draw original fields
            EditorGUILayout.PropertyField(playOnEventProperty);
            EditorGUILayout.PropertyField(soundReferenceProperty);
            EditorGUILayout.PropertyField(playOnEnableProperty);
            EditorGUILayout.PropertyField(playOnStartProperty);

            // Warnings about missing clips or 2D
            Sound loadedSound = targetAudioEmitter.EDITOR_LoadEditorCachedSound();
            if (loadedSound != null)
            {
                if (!loadedSound.HasClips)
                {
                    ShowSoundWarning("has no AudioClips. It will not play back any sound.");
                }
                if (loadedSound.SpatialBlend <= 0.0f)
                {
                    ShowSoundWarning("is a 2D sound. It will not emit in 3D space.");
                }
            }

            // Visualize distances
            EditorGUILayout.PropertyField(visualizeMinAndMaxDistancesProperty);
            if (loadedSound != null && visualizeMinAndMaxDistancesProperty.boolValue)
            {
                EditorGUILayout.LabelField("Min Distance: " + loadedSound.MinDistance);
                EditorGUILayout.LabelField("Max Distance: " + loadedSound.MaxDistance);
            }

            // Spacer
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("", GUI.skin.horizontalSlider);
            
            SerializedProperty featuresProp = serializedObject.FindProperty("features");
            // Draw Grabbable only if active and grabbable
            bool showGrabbable = false;
            for (int i = 0; i < featuresProp.arraySize; i++)
            {
                SerializedProperty featureProp = featuresProp.GetArrayElementAtIndex(i);
                if (featureProp.managedReferenceValue is InteractionSoundsFeature interaction)
                {
                    if (interaction.IsGrabbable)
                    {
                        showGrabbable = true;
                        break;
                    }
                    else
                    {
                        Collider targetCollider = targetAudioEmitter.GetComponent<Collider>();
                        if (!targetCollider || !targetCollider.isTrigger)
                        {
                            ShowPressedSoundWarning(targetCollider.gameObject.name, interaction.PressedSound);
                        }
                    }
                }
            }
            
            if (showGrabbable)
            {
                SerializedProperty grabbableProp = serializedObject.FindProperty("grabbable");
                EditorGUILayout.PropertyField(grabbableProp);
                EditorGUILayout.Space();
                EditorGUILayout.LabelField("", GUI.skin.horizontalSlider);
            }

            // Draw features section
            DrawFeaturesSection();

            serializedObject.ApplyModifiedProperties();
        }

        private void ShowSoundWarning(string warningText)
        {
            bool hasPath = 
                AudioGlobalSettings.TryGetPathFromReference(soundReferenceProperty.stringValue, out string path);
            
            GUIStyle style = GUI.skin.label;
            style.wordWrap = true;
            style.richText = true;

            string text;
            if (hasPath)
            {
                text = $"<color=yellow><size=16><b>WARNING!</b></size></color>" +
                       $"<color=white><size=14> {path} {warningText}</size></color>";
            }
            else
            {
                text = $"<color=yellow><size=16><b>WARNING!</b></size></color>" +
                       $"<color=white><size=14> {warningText}</size></color>";
            }
            
            GUILayout.Label(text, style);
        }
        
        private void ShowPressedSoundWarning(string objName, string soundRef)
        {
            bool hasPath = 
                AudioGlobalSettings.TryGetPathFromReference(soundRef, out string path);
    
            GUIStyle style = GUI.skin.label;
            style.wordWrap = true;
            style.richText = true;
    
            string warningText;
            if (hasPath)
            {
                warningText = $"<color=yellow><size=16><b>WARNING!</b></size></color> <color=white><size=14>Sound" +
                              $" '{path}' is missing a trigger attached to the object '{objName}' and won't play the " +
                              $"pressed/switched sound.</size></color>";
            }
            else
            {
                warningText = $"<color=yellow><size=16><b>WARNING!</b></size></color> <color=white><size=14>" +
                              $"{objName} is missing a trigger and won't play the pressed/switched " +
                              $"sound.</size></color>";
            }
    
            GUILayout.Label(warningText, style);
        }

        private void DrawFeaturesSection()
        {
            EditorGUILayout.LabelField("Audio Emitter Features", EditorStyles.boldLabel);

            if (featuresProperty == null || !featuresProperty.isArray)
            {
                EditorGUILayout.HelpBox("Feature list not found on AudioEmitter.", MessageType.Info);
                return;
            }

            // Check if there's any unadded feature type
            bool anyLeftToAdd = featureAddSelections.Any(pair => !EmitterHasFeatureOfType(pair.Key));

            // (+) button if at least one new feature remains
            if (anyLeftToAdd)
            {
                if (GUILayout.Button("+", GUILayout.Width(30)))
                {
                    showAddFeatureMenu = !showAddFeatureMenu;
                }

                if (showAddFeatureMenu)
                {
                    // Show toggles for each missing feature type
                    List<Type> allFeatureTypes = new(featureAddSelections.Keys);
                    for (int i = 0; i < allFeatureTypes.Count; i++)
                    {
                        Type featureType = allFeatureTypes[i];

                        if (EmitterHasFeatureOfType(featureType))
                            continue;

                        bool currentValue = featureAddSelections[featureType];
                        string sanitizedName = FormatFeatureTypeName(featureType.Name);
                        bool newValue = EditorGUILayout.ToggleLeft(sanitizedName, currentValue);

                        if (newValue != currentValue)
                        {
                            featureAddSelections[featureType] = newValue;
                        }
                    }

                    if (GUILayout.Button("Add Selected Features"))
                    {
                        List<Type> allKeys = new(featureAddSelections.Keys);
                        for (int j = 0; j < allKeys.Count; j++)
                        {
                            Type key = allKeys[j];
                            if (featureAddSelections[key] && !EmitterHasFeatureOfType(key))
                            {
                                AddFeature(key);
                            }
                        }

                        // Reset selection and hide menu
                        for (int j = 0; j < allKeys.Count; j++)
                        {
                            featureAddSelections[allKeys[j]] = false;
                        }
                        showAddFeatureMenu = false;
                    }
                }
            }

            EditorGUILayout.Space();
            EditorGUILayout.LabelField("", GUI.skin.horizontalSlider);

            // List each existing feature
            for (int i = 0; i < featuresProperty.arraySize; i++)
            {
                SerializedProperty elementProp = featuresProperty.GetArrayElementAtIndex(i);

                AudioEmitterFeature featureObj = elementProp?.managedReferenceValue as AudioEmitterFeature;
                if (featureObj == null)
                {
                    continue;
                }

                foldoutByFeature.TryAdd(featureObj, true);

                // default expanded
                EditorGUILayout.BeginHorizontal();
                string headerLabel = FormatFeatureTypeName(featureObj.FeatureName);
                foldoutByFeature[featureObj] = EditorGUILayout.Foldout(foldoutByFeature[featureObj], headerLabel, true);

                if (GUILayout.Button("-", GUILayout.Width(30)))
                {
                    RemoveFeatureAtIndex(i);
                    break;
                }
                EditorGUILayout.EndHorizontal();

                // If user expands the foldout, draw properties
                if (foldoutByFeature[featureObj])
                {
                    EditorGUI.indentLevel++;

                    if (featureObj is InteractionSoundsFeature)
                    {
                        DrawInteractionSoundsFeature(elementProp);
                    }
                    else if (featureObj is CollisionSoundsFeature)
                    {
                        DrawCollisionSoundsFeature(elementProp);
                    }
                    else
                    {
                        // For other feature types, we do the old iteration, skipping "enabledFeature"
                        SerializedProperty childProp = elementProp.Copy();
                        SerializedProperty endProp = childProp.GetEndProperty();
                        bool enterChildren = childProp.NextVisible(true);
                        while (enterChildren && !SerializedProperty.EqualContents(childProp, endProp))
                        {
                            enterChildren = childProp.NextVisible(false);
                        }
                    }

                    EditorGUI.indentLevel--;
                }

                EditorGUILayout.Space();
                EditorGUILayout.LabelField("", GUI.skin.horizontalSlider);
            }
        }

        /// <summary>
        /// Custom drawer for an InteractionSoundsFeature:
        /// - We skip "enabledFeature"
        /// - We show "isGrabbable" and then, depending on that bool's value,
        ///   we display the relevant child fields via PropertyField.
        /// </summary>
        private void DrawInteractionSoundsFeature(SerializedProperty featureProp)
        {
            // We'll iterate sub-properties manually
            SerializedProperty copy = featureProp.Copy();
            SerializedProperty endProp = copy.GetEndProperty();

            SerializedProperty isGrabbableProp = null;

            List<SerializedProperty> grabbableProps = new ();
            List<SerializedProperty> ungrabbableProps = new ();

            bool enterChildren = copy.NextVisible(true);
            while (enterChildren && !SerializedProperty.EqualContents(copy, endProp))
            {
                if (copy.name == IsGrabbableString)
                {
                    isGrabbableProp = copy.Copy();
                }
                else if (copy.name == HandGrabbedSoundString ||
                         copy.name == HandReleasedSoundString ||
                         copy.name == SocketedSoundString ||
                         copy.name == RemovedFromSocketSoundString ||
                         copy.name == ActivatedStartSoundString ||
                         copy.name == ActivatedLoopSoundString ||
                         copy.name == ActivatedLoopStartOverlapTimeString ||
                         copy.name == DeactivatedSoundString ||
                         copy.name == PlacedSoundString ||
                         copy.name == CustomInteractionSoundString ||
                         copy.name == PlacedSoundTriggerEventString ||
                         copy.name == CustomInteractionSoundTriggerEventString)
                {
                    grabbableProps.Add(copy.Copy());
                }
                else if (copy.name == PressedSoundString)
                {
                    ungrabbableProps.Add(copy.Copy());
                }

                enterChildren = copy.NextVisible(false);
            }

            // 1) Draw isGrabbable
            if (isGrabbableProp != null)
            {
                EditorGUILayout.PropertyField(isGrabbableProp);
            }

            bool isGrabbableValue = isGrabbableProp is { boolValue: true };

            if (isGrabbableValue)
            {
                EditorGUILayout.LabelField("Grabbable Object Interaction Sounds", EditorStyles.boldLabel);

                DrawPropertiesWithTooltips(grabbableProps);
            }
            else
            {
                EditorGUILayout.LabelField("Ungrabbable Object Interaction Sounds", EditorStyles.boldLabel);

                DrawPropertiesWithTooltips(ungrabbableProps);
            }
        }

        private void DrawPropertiesWithTooltips(List<SerializedProperty> properties)
        {
            for (int i = 0; i < properties.Count; i++)
            {
                SerializedProperty p = properties[i];
                string tooltip = TooltipByName.GetValueOrDefault(p.name, "No info");

                float propHeight = EditorGUI.GetPropertyHeight(p, false);
                Rect fullRect = EditorGUILayout.GetControlRect(true, propHeight);

                GUIContent iconContent = EditorGUIUtility.IconContent("_Help");
                iconContent.tooltip = tooltip;

                Rect iconRect = new (fullRect.x, fullRect.y, 18, EditorGUIUtility.singleLineHeight);
                Rect propertyRect = new (fullRect.x + 20, fullRect.y, fullRect.width - 20, fullRect.height);

                GUI.Label(iconRect, iconContent);
                EditorGUI.PropertyField(propertyRect, p, new GUIContent(p.displayName), false);

                // After "Custom Interaction Sound", manually insert Header spacing
                if (p.name == CustomInteractionSoundString)
                {
                    EditorGUILayout.Space();
                    EditorGUILayout.LabelField("Events:", EditorStyles.boldLabel);
                }
            }
        }

        /// <summary>
        /// Custom drawer for a CollisionSoundsFeature:
        /// - We skip "enabledFeature"
        /// - Then we show "droppedSound", "primaryImpactSound", "secondaryImpactSound"
        /// </summary>
        private void DrawCollisionSoundsFeature(SerializedProperty featureProp)
        {
            SerializedProperty copy = featureProp.Copy();
            SerializedProperty endProp = copy.GetEndProperty();

            List<SerializedProperty> collisionProps = new ();

            bool enterChildren = copy.NextVisible(true);
            while (enterChildren && !SerializedProperty.EqualContents(copy, endProp))
            {
                if (copy.name == DroppedSoundString ||
                    copy.name == GroundColliderString ||
                    copy.name == PrimaryImpactSoundString ||
                    copy.name == SecondaryImpactSoundString)
                {
                    collisionProps.Add(copy.Copy());
                }

                enterChildren = copy.NextVisible(false);
            }

            EditorGUILayout.LabelField("Collision Sounds", EditorStyles.boldLabel);

            DrawPropertiesWithTooltips(collisionProps);
        }

        private bool EmitterHasFeatureOfType(Type t)
        {
            if (!featuresProperty.isArray)
            {
                return false;
            }

            int count = featuresProperty.arraySize;
            for (int i = 0; i < count; i++)
            {
                SerializedProperty elementProp = featuresProperty.GetArrayElementAtIndex(i);
                if (elementProp == null)
                {
                    continue;
                }

                if (elementProp.managedReferenceValue is AudioEmitterFeature featureObj && featureObj.GetType() == t)
                {
                    return true;
                }
            }
            return false;
        }

        private void AddFeature(Type featureType)
        {
            int newIndex = featuresProperty.arraySize;
            featuresProperty.InsertArrayElementAtIndex(newIndex);
            serializedObject.ApplyModifiedProperties();
            serializedObject.Update();

            SerializedProperty newElement = featuresProperty.GetArrayElementAtIndex(newIndex);

            object instance = Activator.CreateInstance(featureType);

            newElement.managedReferenceValue = instance;
            serializedObject.ApplyModifiedProperties();
            serializedObject.Update();

            if (instance is AudioEmitterFeature typedFeature)
            {
                PopulateFeatureDefaults(typedFeature);
            }

            serializedObject.ApplyModifiedProperties();
        }

        private void RemoveFeatureAtIndex(int i)
        {
            SerializedProperty elementProp = featuresProperty.GetArrayElementAtIndex(i);
            if (elementProp != null)
            {
                elementProp.managedReferenceValue = null;
            }
            featuresProperty.DeleteArrayElementAtIndex(i);
            serializedObject.ApplyModifiedProperties();
        }

        private void PopulateFeatureDefaults(AudioEmitterFeature feature)
        {
            if (feature is InteractionSoundsFeature interaction)
            {
                if (string.IsNullOrEmpty(interaction.HandGrabbedSound))
                {
                    interaction.HandGrabbedSound = AudioGlobalSettings.HandGrabbedSound;
                }
                if (string.IsNullOrEmpty(interaction.HandReleasedSound))
                {
                    interaction.HandReleasedSound = AudioGlobalSettings.HandReleasedSound;
                }
                if (string.IsNullOrEmpty(interaction.SocketedSound))
                {
                    interaction.SocketedSound = AudioGlobalSettings.SocketedSound;
                }
                if (string.IsNullOrEmpty(interaction.RemovedFromSocketSound))
                {
                    interaction.RemovedFromSocketSound = AudioGlobalSettings.RemovedFromSocketSound;
                }
                if (string.IsNullOrEmpty(interaction.ActivatedStartSound))
                {
                    interaction.ActivatedStartSound = AudioGlobalSettings.ActivatedStartSound;
                }
                if (string.IsNullOrEmpty(interaction.ActivatedLoopSound))
                {
                    interaction.ActivatedLoopSound = AudioGlobalSettings.ActivatedLoopSound;
                }
                interaction.ActivatedLoopStartOverlapTime = AudioGlobalSettings.ActivatedStartLoopOverlapTime;
                if (string.IsNullOrEmpty(interaction.DeactivatedSound))
                {
                    interaction.DeactivatedSound = AudioGlobalSettings.DeactivatedSound;
                }
                if (string.IsNullOrEmpty(interaction.PlacedSound))
                {
                    interaction.PlacedSound = AudioGlobalSettings.PlacedSound;
                }
                if (string.IsNullOrEmpty(interaction.CustomInteractionSound))
                {
                    interaction.CustomInteractionSound = AudioGlobalSettings.CustomInteractionSound;
                }
                if (string.IsNullOrEmpty(interaction.PlacedSoundTriggerEvent))
                {
                    interaction.PlacedSoundTriggerEvent = AudioGlobalSettings.PlacedSoundTriggerEvent;
                }
                if (string.IsNullOrEmpty(interaction.CustomInteractionSoundTriggerEvent))
                {
                    interaction.CustomInteractionSoundTriggerEvent = 
                        AudioGlobalSettings.CustomInteractionSoundTriggerEvent;
                }
                if (string.IsNullOrEmpty(interaction.PressedSound))
                {
                    interaction.PressedSound = AudioGlobalSettings.PressedSound;
                }
            }
        }

        private string FormatFeatureTypeName(string typeName)
        {
            // e.g. InteractionSoundsFeature => Interaction Sounds
            if (typeName.EndsWith("Feature"))
            {
                typeName = typeName.Substring(0, typeName.Length - "Feature".Length);
            }

            // Insert spaces before capitals
            for (int i = 1; i < typeName.Length; i++)
            {
                if (char.IsUpper(typeName[i]))
                {
                    typeName = typeName.Insert(i, " ");
                    i++;
                }
            }

            return typeName.Trim();
        }

        private static string FormatToCamel(string propertyName)
        {
            return char.ToLowerInvariant(propertyName[0])
                + propertyName[1..];
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/AudioSystem/AudioEmitterEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/AudioSystem/AudioGlobalSettingsEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f2b59c52b6f446849b077940a2b7f8e3
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.AudioSystem
{
    [CustomEditor(typeof(AudioGlobalSettings))]
    public class AudioGlobalSettingsEditor : Editor
    {
        public override void OnInspectorGUI()
        {
            DrawDefaultInspector();

            if (GUILayout.Button("Update Sound GUID Path Table"))
            {
                AudioGlobalSettings.EDITOR_UpdateSoundGUIDToPathTable();    
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/AudioSystem/AudioGlobalSettingsEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/AudioSystem/SceneAudioManagerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 189159ca6f9aa9e4cb6aa485cb71e5e9
# ASMDEF: ldx.framework.editor.dll
# ---
#if UNITY_EDITOR
using Autohand;
using Ldx.Framework.Systems.AudioSystem;
using UnityEditor;
using UnityEngine;

[CustomEditor(typeof(SceneAudioManager))]
public class SceneAudioManagerEditor : Editor
{
    private SerializedProperty managedSoundsProp;
    private int pendingRemoveSoundIndex = -1;
    private int pendingRemoveEventIndex = -1;
    private int currentSoundEventContext = -1;

    private static class Styles
    {
        public static readonly GUIStyle HeaderTitle;
        public static readonly GUIStyle SectionTitle;
        public static readonly GUIStyle SectionBox;
        public static readonly GUIStyle CardBox;
        public static readonly GUIStyle InlineTitle;
        public static readonly GUIStyle AddButton;
        public static readonly GUIStyle SmallButton;
        public static readonly GUIStyle CheckboxStyle;
        
        public static readonly GUIContent AddSound = new GUIContent("+ Add Sound", "Add a new managed sound entry");
        public static readonly GUIContent AddEvent = new GUIContent("+ Add Event-Triggered Sound", "Add a new tracking event sound mapping (Plays at target transform if set & 3D)");
        public static readonly GUIContent Up = new GUIContent("", "Move Up");
        public static readonly GUIContent Down = new GUIContent("", "Move Down");
        public static readonly GUIContent Remove = new GUIContent("", "Remove Managed Sound");
        public static readonly GUIContent RemoveEvent = new GUIContent("", "Remove Event Triggered Sound");
        public static readonly GUIContent AudioIcon;
        public static readonly GUIContent ExpandIcon = new GUIContent("", "Expand/Collapse");
        public static readonly GUIContent CollapseIcon = new GUIContent("", "Expand/Collapse");

        public static readonly Color HeaderBlue = new Color(0.125f, 0.34f, 0.90f, 1f);
        public static readonly Color Orange = new Color(1f, 0.55f, 0.0f, 1f);
        public static readonly Color HeaderBox = new Color(0.15f, 0.15f, 0.15f, 0.9f);
        public static readonly Color DarkBox = new Color(0.2f, 0.2f, 0.2f, 0.5f);
        public static readonly Color LightBox = new Color(0.3f, 0.3f, 0.3f, 0.3f);
        public static readonly Color CheckboxHighlight = new Color(0.3f, 0.7f, 1f, 0.3f);

        static Styles()
        {
            HeaderTitle = new GUIStyle(EditorStyles.boldLabel)
            {
                fontSize = 16,
                alignment = TextAnchor.MiddleLeft,
                normal = { textColor = Color.white }
            };

            SectionTitle = new GUIStyle(EditorStyles.boldLabel)
            {
                fontSize = 12,
                normal = { textColor = Color.white }
            };

            SectionBox = new GUIStyle("Box")
            {
                padding = new RectOffset(12, 12, 12, 12),
                margin = new RectOffset(0, 0, 4, 4)
            };

            CardBox = new GUIStyle("Box")
            {
                padding = new RectOffset(10, 10, 8, 8),
                margin = new RectOffset(0, 0, 4, 4)
            };

            InlineTitle = new GUIStyle(EditorStyles.label)
            {
                fontStyle = FontStyle.Bold,
                normal = { textColor = Orange }
            };

            AddButton = new GUIStyle(GUI.skin.button)
            {
                fontSize = 11,
                fontStyle = FontStyle.Bold,
                fixedHeight = 24,
                padding = new RectOffset(10, 10, 4, 4)
            };

            SmallButton = new GUIStyle(GUI.skin.button)
            {
                fontSize = 10,
                fixedWidth = 24,
                fixedHeight = 20,
                padding = new RectOffset(2, 2, 2, 2)
            };

            CheckboxStyle = new GUIStyle(EditorStyles.toggle)
            {
                fixedWidth = 20,
                fixedHeight = 20,
                normal = { background = CreateColoredTexture(CheckboxHighlight) },
                onNormal = { background = CreateColoredTexture(new Color(Orange.r, Orange.g, Orange.b, 0.4f)) }
            };

            AudioIcon = EditorGUIUtility.IconContent("AudioSource Icon");
        }

        private static Texture2D CreateColoredTexture(Color color)
        {
            Texture2D texture = new Texture2D(1, 1);
            texture.SetPixel(0, 0, color);
            texture.Apply();
            return texture;
        }
    }

    public override void OnInspectorGUI()
    {
        serializedObject.Update();

        if (managedSoundsProp == null)
        {
            managedSoundsProp = serializedObject.FindProperty("managedSounds");
        }

        DrawCustomHeader();
        DrawSoundsSection();

        // Handle deferred operations
        HandlePendingRemovals();
        
        serializedObject.ApplyModifiedProperties();
    }

    private void DrawCustomHeader()
    {
        Color originalColor = GUI.backgroundColor;
        GUI.backgroundColor = Styles.HeaderBox;
        
        Rect headerRect = GUILayoutUtility.GetRect(0, 40, GUILayout.ExpandWidth(true));
        EditorGUI.DrawRect(headerRect, Styles.HeaderBox);
        
        GUI.backgroundColor = originalColor;

        // Icon
        Rect iconRect = new Rect(headerRect.x + 12, headerRect.y + 10, 20, 20);
        if (Styles.AudioIcon?.image != null)
        {
            GUI.DrawTexture(iconRect, Styles.AudioIcon.image);
        }

        // Title with blue text
        Rect titleRect = new Rect(iconRect.xMax + 8, headerRect.y + 12, headerRect.width - 40, 20);
        GUIStyle blueHeaderStyle = new GUIStyle(Styles.HeaderTitle);
        blueHeaderStyle.normal.textColor = Styles.HeaderBlue;
        GUI.Label(titleRect, "Scene Audio Manager", blueHeaderStyle);
    }

    private void DrawSoundsSection()
    {
        Color originalColor = GUI.backgroundColor;
        GUI.backgroundColor = Styles.LightBox;
        
        EditorGUILayout.BeginVertical(Styles.SectionBox);
        GUI.backgroundColor = originalColor;

        // Empty state
        if (managedSoundsProp.arraySize == 0)
        {
            EditorGUILayout.BeginHorizontal();
            GUILayout.FlexibleSpace();
            if (GUILayout.Button(Styles.AddSound, Styles.AddButton, GUILayout.Width(150)))
            {
                AddNewSound();
            }
            GUILayout.FlexibleSpace();
            EditorGUILayout.EndHorizontal();
        }
        else
        {
            // Draw existing sounds
            for (int i = 0; i < managedSoundsProp.arraySize; i++)
            {
                if (pendingRemoveSoundIndex >= 0) break;
                DrawSoundEntry(managedSoundsProp.GetArrayElementAtIndex(i), i);
            }

            EditorGUILayout.Space(8);
            EditorGUILayout.BeginHorizontal();
            GUILayout.FlexibleSpace();
            if (GUILayout.Button(Styles.AddSound, Styles.AddButton, GUILayout.Width(150)))
            {
                AddNewSound();
            }
            GUILayout.FlexibleSpace();
            EditorGUILayout.EndHorizontal();
        }

        EditorGUILayout.EndVertical();
    }

    private void DrawSoundEntry(SerializedProperty soundProp, int index)
    {
        Color originalColor = GUI.backgroundColor;
        GUI.backgroundColor = Styles.DarkBox;
        
        EditorGUILayout.BeginVertical(Styles.CardBox);
        GUI.backgroundColor = originalColor;

        // Header row with orange accent
        DrawSoundHeaderRow(soundProp, index);

        // Expandable content
        if (soundProp.isExpanded)
        {
            EditorGUILayout.Space(4);
            DrawSoundContent(soundProp, index);
        }

        EditorGUILayout.EndVertical();
    }

    private void DrawSoundHeaderRow(SerializedProperty soundProp, int index)
    {
        EditorGUILayout.BeginHorizontal();
        
        // Orange accent and controls
        GUILayout.Space(2);
        
        Color prevColor = GUI.backgroundColor;
        GUI.backgroundColor = Styles.Orange;
        GUILayout.Box("", GUILayout.Width(4), GUILayout.Height(24));
        GUI.backgroundColor = prevColor;
        
        GUILayout.Space(4);

        // Up/Down arrows
        if (GUILayout.Button(Styles.Up, Styles.SmallButton) && index > 0)
        {
            managedSoundsProp.MoveArrayElement(index, index - 1);
        }
        
        if (GUILayout.Button(Styles.Down, Styles.SmallButton) && index < managedSoundsProp.arraySize - 1)
        {
            managedSoundsProp.MoveArrayElement(index, index + 1);
        }

        GUILayout.Space(4);

        // Expand/Collapse button
        GUIContent expandContent = soundProp.isExpanded ? Styles.CollapseIcon : Styles.ExpandIcon;
        Color prevTextColor = GUI.color;
        GUI.color = Styles.Orange;
        if (GUILayout.Button(expandContent, EditorStyles.label, GUILayout.Width(16)))
        {
            soundProp.isExpanded = !soundProp.isExpanded;
        }
        GUI.color = prevTextColor;

        // "Sound" label immediately followed by description field
        GUILayout.Label("Sound", Styles.InlineTitle, GUILayout.Width(45));

        // Description field directly after "Sound" label with no extra spacing
        SerializedProperty descProp = soundProp.FindPropertyRelative("description");
        EditorGUILayout.PropertyField(descProp, GUIContent.none);

        // Remove button
        if (GUILayout.Button(Styles.Remove, Styles.SmallButton))
        {
            pendingRemoveSoundIndex = index;
        }

        EditorGUILayout.EndHorizontal();
    }

    private void DrawSoundContent(SerializedProperty soundProp, int index)
    {
        SerializedProperty targetProp = soundProp.FindPropertyRelative("targetTransformFor3D");
        SerializedProperty playOnStartProp = soundProp.FindPropertyRelative("isAmbientSound");
        SerializedProperty startSoundProp = soundProp.FindPropertyRelative("ambientSound");

        // Basic settings section
        DrawSubSection("Basic Settings", () =>
        {
            // Draw target field with its natural label
            EditorGUILayout.PropertyField(targetProp);
            
            EditorGUILayout.Space(4);
            
            // Ambient sound checkbox with custom style
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("Is Ambient Sound", GUILayout.Width(120));
            
            // Draw checkbox with highlighting background
            Rect checkboxRect = GUILayoutUtility.GetRect(20, 20, GUILayout.Width(20));
            
            // Draw colored background for emphasis
            Color prevBgColor = GUI.backgroundColor;
            if (playOnStartProp.boolValue)
            {
                GUI.backgroundColor = Styles.Orange;
                EditorGUI.DrawRect(new Rect(checkboxRect.x - 2, checkboxRect.y - 2, checkboxRect.width + 4, checkboxRect.height + 4), 
                    new Color(Styles.Orange.r, Styles.Orange.g, Styles.Orange.b, 0.3f));
            }
            else
            {
                EditorGUI.DrawRect(new Rect(checkboxRect.x - 2, checkboxRect.y - 2, checkboxRect.width + 4, checkboxRect.height + 4), 
                    Styles.CheckboxHighlight);
            }
            
            // Draw the actual checkbox with custom style
            playOnStartProp.boolValue = EditorGUI.Toggle(checkboxRect, playOnStartProp.boolValue, Styles.CheckboxStyle);
            GUI.backgroundColor = prevBgColor;
            
            EditorGUILayout.EndHorizontal();
            
            if (playOnStartProp.boolValue)
            {
                EditorGUILayout.Space(4);
                
                // Highlight the ambient sound field with a colored box
                Color originalColor = GUI.backgroundColor;
                GUI.backgroundColor = new Color(Styles.Orange.r, Styles.Orange.g, Styles.Orange.b, 0.2f);
                
                EditorGUILayout.BeginVertical("Box");
                GUI.backgroundColor = originalColor;
                
                EditorGUILayout.PropertyField(startSoundProp);
                
                EditorGUILayout.EndVertical();
            }
        });

        // Auto-detect components and show relevant sections
        Transform target = targetProp.objectReferenceValue as Transform;
        if (target != null)
        {
            Grabbable grabbable = target.GetComponent<Grabbable>();
            if (grabbable != null)
            {
                DrawGrabReleaseSection(soundProp);
            }

            PlacePoint placePoint = target.GetComponent<PlacePoint>();
            if (placePoint != null)
            {
                DrawPlaceRemoveSection(soundProp);
            }
        }

        // Event-triggered sounds section
        DrawEventTriggeredSoundsSection(soundProp, index);
    }

    private void DrawSubSection(string title, System.Action content)
    {
        Color originalColor = GUI.backgroundColor;
        GUI.backgroundColor = Styles.DarkBox;
        
        EditorGUILayout.BeginVertical(Styles.CardBox);
        GUI.backgroundColor = originalColor;

        if (!string.IsNullOrEmpty(title))
        {
            EditorGUILayout.LabelField(title, Styles.SectionTitle);
            EditorGUILayout.Space(4);
        }

        content?.Invoke();

        EditorGUILayout.EndVertical();
    }

    private void DrawGrabReleaseSection(SerializedProperty soundProp)
    {
        SerializedProperty onGrabProp = soundProp.FindPropertyRelative("onGrab");
        SerializedProperty onReleaseProp = soundProp.FindPropertyRelative("onRelease");

        DrawSubSection("Grab / Release", () =>
        {
            EditorGUILayout.PropertyField(onGrabProp);
            
            EditorGUILayout.Space(4);
            EditorGUILayout.PropertyField(onReleaseProp);
        });
    }

    private void DrawPlaceRemoveSection(SerializedProperty soundProp)
    {
        SerializedProperty onPlaceProp = soundProp.FindPropertyRelative("onPlace");
        SerializedProperty onRemoveProp = soundProp.FindPropertyRelative("onRemove");

        DrawSubSection("Place / Remove", () =>
        {
            EditorGUILayout.PropertyField(onPlaceProp);
            
            EditorGUILayout.Space(4);
            EditorGUILayout.PropertyField(onRemoveProp);
        });
    }

    private void DrawEventTriggeredSoundsSection(SerializedProperty soundProp, int soundIndex)
    {
        SerializedProperty eventSoundsProp = soundProp.FindPropertyRelative("eventSounds");

        DrawSubSection("Event-Triggered Sounds", () =>
        {
            if (eventSoundsProp.arraySize == 0)
            {
                EditorGUILayout.BeginHorizontal();
                GUILayout.FlexibleSpace();
                if (GUILayout.Button(Styles.AddEvent, Styles.AddButton, GUILayout.Width(220)))
                {
                    eventSoundsProp.InsertArrayElementAtIndex(0);
                }
                GUILayout.FlexibleSpace();
                EditorGUILayout.EndHorizontal();
            }
            else
            {
                for (int i = 0; i < eventSoundsProp.arraySize; i++)
                {
                    if (pendingRemoveEventIndex >= 0 && currentSoundEventContext == soundIndex) break;
                    DrawEventEntry(eventSoundsProp, i, soundIndex);
                }

                EditorGUILayout.Space(6);
                EditorGUILayout.BeginHorizontal();
                GUILayout.FlexibleSpace();
                if (GUILayout.Button(Styles.AddEvent, Styles.AddButton, GUILayout.Width(220)))
                {
                    eventSoundsProp.InsertArrayElementAtIndex(eventSoundsProp.arraySize);
                }
                GUILayout.FlexibleSpace();
                EditorGUILayout.EndHorizontal();
            }
        });
    }

    private void DrawEventEntry(SerializedProperty eventArrayProp, int eventIndex, int soundIndex)
    {
        SerializedProperty eventProp = eventArrayProp.GetArrayElementAtIndex(eventIndex);
        
        Color originalColor = GUI.backgroundColor;
        GUI.backgroundColor = Color.black * 0.3f;
        
        EditorGUILayout.BeginVertical(Styles.CardBox);
        GUI.backgroundColor = originalColor;

        // Event header with controls
        EditorGUILayout.BeginHorizontal();

        // Up/Down buttons
        if (GUILayout.Button(Styles.Up, Styles.SmallButton, GUILayout.Width(24)))
        {
            if (eventIndex > 0)
            {
                eventArrayProp.MoveArrayElement(eventIndex, eventIndex - 1);
            }
        }
        if (GUILayout.Button(Styles.Down, Styles.SmallButton, GUILayout.Width(24)))
        {
            if (eventIndex < eventArrayProp.arraySize - 1)
            {
                eventArrayProp.MoveArrayElement(eventIndex, eventIndex + 1);
            }
        }

        EditorGUILayout.LabelField("Event Mapping", Styles.InlineTitle, GUILayout.ExpandWidth(true));

        if (GUILayout.Button(Styles.RemoveEvent, Styles.SmallButton, GUILayout.Width(28)))
        {
            pendingRemoveEventIndex = eventIndex;
            currentSoundEventContext = soundIndex;
        }

        EditorGUILayout.EndHorizontal();

        EditorGUILayout.Space(4);

        // Event fields
        SerializedProperty eventIdProp = eventProp.FindPropertyRelative("trackingEventId");
        SerializedProperty soundRefProp = eventProp.FindPropertyRelative("soundReference");

        EditorGUILayout.PropertyField(eventIdProp);
        
        EditorGUILayout.Space(4);
        EditorGUILayout.PropertyField(soundRefProp);

        EditorGUILayout.EndVertical();
    }

    private void AddNewSound()
    {
        int index = managedSoundsProp.arraySize;
        managedSoundsProp.arraySize++;
        SerializedProperty newSound = managedSoundsProp.GetArrayElementAtIndex(index);
        
        // Clear the description field so it starts empty
        SerializedProperty descProp = newSound.FindPropertyRelative("description");
        if (descProp != null)
        {
            descProp.stringValue = "Description (optional)";
        }
        
        // Expand by default
        newSound.isExpanded = true;
        
        // Apply changes immediately
        serializedObject.ApplyModifiedProperties();
    }

    private void HandlePendingRemovals()
    {
        if (pendingRemoveSoundIndex >= 0)
        {
            if (pendingRemoveSoundIndex < managedSoundsProp.arraySize)
            {
                managedSoundsProp.DeleteArrayElementAtIndex(pendingRemoveSoundIndex);
                serializedObject.ApplyModifiedProperties();
            }
            pendingRemoveSoundIndex = -1;
        }

        if (pendingRemoveEventIndex >= 0 && currentSoundEventContext >= 0)
        {
            if (currentSoundEventContext < managedSoundsProp.arraySize)
            {
                SerializedProperty soundProp = managedSoundsProp.GetArrayElementAtIndex(currentSoundEventContext);
                SerializedProperty eventsProp = soundProp.FindPropertyRelative("eventSounds");
                
                if (pendingRemoveEventIndex < eventsProp.arraySize)
                {
                    eventsProp.DeleteArrayElementAtIndex(pendingRemoveEventIndex);
                    serializedObject.ApplyModifiedProperties();
                }
            }
            
            pendingRemoveEventIndex = -1;
            currentSoundEventContext = -1;
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/AudioSystem/SceneAudioManagerEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Events/EditorEventTrackingContainer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 53d876fb4f5a4b2eba7ccfdb5eeef028
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections;
using System.Collections.Generic;
using Ldx.Framework.Utilities.Extensions;
using Newtonsoft.Json;
using UnityEditor;

namespace Ldx.Framework.Systems.Events
{
    /// <summary>
    /// A container for the logs from Live Event Tracking window,
    /// simply just adds functionality to save the logs in EditorPref so
    /// it persists when the static domain refreshes on entering play mode
    /// </summary>
    public class EditorEventTrackingContainer : IEnumerable<string>
    {
        private const string KEY_CACHED_LOG = "EVENT_TRACKING_CACHED_LOG";

        private List<string> eventLog = new();

        public string this[int i] => eventLog[i];
        public int Count => eventLog.Count;

        private string KeyCachedLog => $"{PathUtilities.GetProjectDirectoryName()}_{KEY_CACHED_LOG}";

        public void Reload()
        {
            string json = EditorPrefs.GetString(KeyCachedLog, "[]");
            eventLog = JsonConvert.DeserializeObject<List<string>>(json);
        }
        
        public void Add(string logEntry)
        {
            eventLog.Add(logEntry);
            UpdateCache();
        }

        public void Clear()
        {
            eventLog.Clear();
            UpdateCache();
        }

        private void UpdateCache()
        {
            string json = JsonConvert.SerializeObject(eventLog);
            EditorPrefs.SetString(KeyCachedLog, json);
        }
        
        public IEnumerator<string> GetEnumerator()
        {
            return eventLog.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Events/EditorEventTrackingContainer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Events/LdxEventNotifierEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 65d78397ee6d48a989d3b9d40877ca9a
# ASMDEF: ldx.framework.editor.dll
# ---
using Ldx.Framework.Systems.Objectives.Tracking;
using UnityEditor;

namespace Ldx.Framework.Systems.Events
{
    [CustomEditor(typeof(TrackingEventNotifier), editorForChildClasses: true)]
    public class LdxEventNotifierEditor : UnityEditor.Editor
    {
        private TrackingEventNotifier Target => (TrackingEventNotifier)target;
        
        private void OnEnable()
        {
            if (LdxTrackingManager.Instance != null && !LdxTrackingManager.Instance.Contains(Target))
            {
                LdxTrackingManager.Instance.AddTracker(Target);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Events/LdxEventNotifierEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Events/LiveEventTrackingWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 24a478aaacd5d394397908848840313a
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using Ldx.Framework.Utilities.Attributes;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.Events
{
    public class LiveEventTrackingWindow : EditorWindow
    {
        private const string FIRE_EVENT_FAIL = "Event ID cannot be empty.";
        private const string FIRE_EVENT_RUNTIME_ONLY = "Events can only be fired during runtime.";
        private const string FIRE_EVENT_SUCCESS = "Event '{0}' fired successfully.";
        private const string FIRE_EVENT_MANUAL_PREFIX = " (source: manual)";
        private const string EVENT_DESCRIPTION_NOT_FOUND = "Description not found";
        
        // EditorPref Keys
        private const string KEY_CLEAR_ON_PLAY = "EVENT_TRACKING_CLEAR_ON_PLAY";
        
        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]
        [SerializeField] private string selectedEvent;
        
        private static bool manualEventTriggered;
        private static EditorEventTrackingContainer eventLogContainer = new();
        private static bool isApplicationRunning;
        
        private Vector2 scrollPosition;
        private string fireEventMessage = FIRE_EVENT_FAIL;
        private bool clearOnPlay;

        private static string KeyClearOnPlay => $"{PathUtilities.GetProjectDirectoryName()}_{KEY_CLEAR_ON_PLAY}";
        
        private static LiveEventTrackingWindow WindowInstance { get; set; }

        private static bool ClearOnPlayStore
        {
            get => EditorPrefs.GetBool(KeyClearOnPlay, true);
            set => EditorPrefs.SetBool(KeyClearOnPlay, value);
        }
        
        [RuntimeInitializeOnLoadMethod]
        private static void InitOnLoad()
        {
            SubscribeAsync().Forget();
            
            isApplicationRunning = true;
                
            if (ClearOnPlayStore)
            {
                eventLogContainer.Clear();
            }
            else
            {
                eventLogContainer.Reload();
            }
            
            EditorApplication.playModeStateChanged -= OnPlayModeChanged;
            EditorApplication.playModeStateChanged += OnPlayModeChanged;

            // When quitting the editor, clear the cache
            EditorApplication.quitting -= handleEditorQuitting;
            EditorApplication.quitting += handleEditorQuitting;
            
            void handleEditorQuitting()
            {
                EditorApplication.quitting -= handleEditorQuitting;
                eventLogContainer.Clear();
            }
        }
        
        private void OnEnable()
        {
            WindowInstance = this;
            clearOnPlay = ClearOnPlayStore;
        }

        private void OnDisable()
        {
            WindowInstance = null;
        }

        [MenuItem("LogicalDox/Live Event Tracking")]
        public static void ShowWindow()
        {
            GetWindow<LiveEventTrackingWindow>("Live Event Tracking");
        }
        
        private static async UniTaskVoid SubscribeAsync()
        {
            await UniTask.WaitUntil(() => LdxTrackingManager.IsValid);

            LdxTrackingManager.Instance.OnTrackingEvent += LogEvent;
        }

        private static void OnPlayModeChanged(PlayModeStateChange state)
        {
            if (state == PlayModeStateChange.ExitingPlayMode)
            {
                // Surprisingly, it's valid here
                if (LdxTrackingManager.IsValid)
                {
                    LdxTrackingManager.Instance.OnTrackingEvent -= LogEvent;
                }
                
                isApplicationRunning = false;
                EditorApplication.playModeStateChanged -= OnPlayModeChanged;
            }
        }

        private void OnGUI()
        {
            GUILayout.Space(10);
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("Live Event Tracking", EditorStyles.boldLabel);
            GUILayout.FlexibleSpace();
            EditorGUI.BeginChangeCheck();
            clearOnPlay = EditorGUILayout.Toggle("Clear on Play", clearOnPlay);
            if (EditorGUI.EndChangeCheck())
            {
                ClearOnPlayStore = clearOnPlay;
            }
            EditorGUILayout.EndHorizontal();
            GUILayout.Space(10);
            EditorGUILayout.LabelField("Event Log", EditorStyles.largeLabel);

            scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition, GUILayout.Height(200));
            
            // Display the newest log at the top and make the newest log larger
            for (int i = eventLogContainer.Count - 1; i >= 0; i--)
            {
                string log = eventLogContainer[i];
                GUIStyle style = new GUIStyle(EditorStyles.label) { richText = true };
                style.fontSize = i == eventLogContainer.Count - 1 ? 14 : 12; // Larger font for the latest log
                EditorGUILayout.LabelField(log, style);
            }
            
            EditorGUILayout.EndScrollView();
            GUILayout.Space(20);
            EditorGUILayout.LabelField("Fire Event", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(new SerializedObject(this).FindProperty("selectedEvent"), new GUIContent("Event ID"));
            EditorGUILayout.BeginHorizontal();
            
            if (GUILayout.Button("Fire Event", GUILayout.Width(100)))
            {
                FireEvent();
            }

            if (GUILayout.Button("Clear Log", GUILayout.Width(100)))
            {
                eventLogContainer.Clear();
            }
            
            if (GUILayout.Button("Refresh", GUILayout.Width(100)))
            {
                RefreshWindow();
            }

            EditorGUILayout.EndHorizontal();
            EditorGUILayout.HelpBox(fireEventMessage, MessageType.Info);
        }

        private void RefreshWindow()
        {
            Close();
            ShowWindow();
        }

        private void FireEvent()
        {
            if (string.IsNullOrEmpty(selectedEvent))
            {
                fireEventMessage = FIRE_EVENT_FAIL;
                return;
            }

            if (!isApplicationRunning)
            {
                fireEventMessage = FIRE_EVENT_RUNTIME_ONLY;
                return;
            }

            manualEventTriggered = true;
            LdxTrackingManager.Instance.BroadcastTrackingEvent(selectedEvent);
            fireEventMessage = string.Format(FIRE_EVENT_SUCCESS, selectedEvent);
            LogEventManual(selectedEvent);
        }
        
        private static void LogEvent(string eventId)
        {
            if (!isApplicationRunning || manualEventTriggered)
            {
                manualEventTriggered = false; // Reset the flag
                return;
            }

            string description = GetEventDescription(eventId);
            string logEntry = $"<color=green>{DateTime.Now:HH:mm:ss} - Event Fired: {description} ({eventId})</color>";
            eventLogContainer.Add(logEntry);

            if (WindowInstance != null)
            {
                WindowInstance.Repaint();
            }
        }

        private void LogEventManual(string eventId)
        {
            string description = GetEventDescription(eventId);
            string logEntry = $"<color=cyan>{DateTime.Now:HH:mm:ss} - Event Fired: {description} ({eventId}){FIRE_EVENT_MANUAL_PREFIX}</color>";
            eventLogContainer.Add(logEntry);
            Repaint();
        }

        private static string GetEventDescription(string eventId)
        {
            if (LdxIdSettings.TryGetIDDescription(eventId, LdxIdSettings.IdType.TrackingEvent, out string description))
            {
                return description;
            }

            return EVENT_DESCRIPTION_NOT_FOUND;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Events/LiveEventTrackingWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/InternalDebug/DebugFeaturesEditorWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c0614ce25d744bdab409d70d01125c5c
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Linq;
using Ldx.Framework.Systems.InternalDebug.DebugFeatures;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.InternalDebug
{
    public class DebugFeaturesEditorWindow : EditorWindow
    {
        private Vector2 scrollPosition;
        private string feedbackMessage = "";
        private double feedbackClearTime;
        
        [MenuItem("LogicalDox/Internal Debug")]
        public static void ShowWindow()
        {
            GetWindow<DebugFeaturesEditorWindow>("Internal Debug");
        }
        
        private void OnEnable()
        {
            EditorApplication.playModeStateChanged += OnPlayModeStateChanged;
            DebugToolController.OnFeedbackReceived += HandleFeedbackReceived;
        }
        
        private void OnDisable()
        {
            EditorApplication.playModeStateChanged -= OnPlayModeStateChanged;
            DebugToolController.OnFeedbackReceived -= HandleFeedbackReceived;
        }
        
        private void HandleFeedbackReceived(string message)
        {
            feedbackMessage = message;
            feedbackClearTime = EditorApplication.timeSinceStartup + 3.0;
            Repaint(); 
        }
        
        private void OnPlayModeStateChanged(PlayModeStateChange state)
        {
            if (state == PlayModeStateChange.ExitingPlayMode)
            {
                feedbackMessage = "";
            }
            Repaint();
        }
        
        private void OnGUI()
        {
            EditorGUILayout.LabelField("LDX Debug Features", EditorStyles.boldLabel);
            
            if (!EditorApplication.isPlaying)
            {
                EditorGUILayout.HelpBox("Enter Play Mode to connect to the DebugToolController and use debug features.", MessageType.Info);
                if (GUILayout.Button("Enter Play Mode"))
                {
                    EditorApplication.EnterPlaymode();
                }

                return;
            }
            
            DebugToolController controller = DebugToolController.Instance;
            if (controller == null)
            {
                EditorGUILayout.HelpBox("Waiting for DebugToolController instance to be initialized...", MessageType.Warning);
                return; // Stop drawing until the controller is ready
            }
            
            scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);
            
            foreach (DebugFeature feature in controller.DebugFeatures.OrderBy(f => f.DisplayName))
            {
                if (DrawCustomUIForFeature(feature))
                {
                    continue;
                }
                
                if (feature.HasButton)
                {
                    DrawFeatureButton(feature);
                }
            }

            EditorGUILayout.EndScrollView();
            
            EditorGUILayout.Space();
            
            if (!string.IsNullOrEmpty(feedbackMessage))
            {
                EditorGUILayout.HelpBox(feedbackMessage, MessageType.None);
                if (EditorApplication.timeSinceStartup > feedbackClearTime)
                {
                    feedbackMessage = "";
                    Repaint();
                }
            }
        }
        
        private void DrawFeatureButton(DebugFeature feature)
        {
            EditorGUILayout.BeginHorizontal();
            EditorGUI.BeginDisabledGroup(!feature.IsAvailable);
            
            string buttonText = feature.IsActive ? $"* {feature.DisplayName}" : feature.DisplayName;
            
            if (GUILayout.Button(buttonText, GUILayout.Height(25)))
            {
                feature.PerformAction();
            }
            EditorGUI.EndDisabledGroup();
            
            if(feature.KeyCode.HasValue)
            {
                EditorGUILayout.LabelField($"[{feature.KeyCode.Value}]", GUILayout.Width(40));
            }
            
            EditorGUILayout.EndHorizontal();
        }
        
        private bool DrawCustomUIForFeature(DebugFeature feature)
        {
            if (feature is NameSelectionDebugFeature nameFeature)
            {
                EditorGUILayout.LabelField(nameFeature.DisplayName, EditorStyles.boldLabel);
                EditorGUILayout.Space();
                return true;
            }

            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/InternalDebug/DebugFeaturesEditorWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/BaseLocalizationDataEntry.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a00c209360234f079dae3f112a2f117d
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using Systems.Settings;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.Localization
{
    public abstract class BaseLocalizationDataEntry<T> : VisualElement
    {
        private const string DELETE_ENTRY_BUTTON_NAME = "delete-entry";
        private const string HORIZONTAL_GROUP = "horizontal-group";

        private LocalizationTableData<T> tableData = new LocalizationTableData<T>();
        protected LocalizationEntry<T> localizationEntry;
        private VisualElement horizontalGroup;
        private TextField keyField;
        private VisualElement lockIcon;
        private Button deleteEntryButton;
        private Action callbackOnDelete;

        public virtual void DisplayEntry(LocalizationTableData<T> localizationTableData, LocalizationEntry<T> entry, Action deleteCallback)
        {
            tableData = localizationTableData;
            localizationEntry = entry;

            horizontalGroup = this.Q<VisualElement>(HORIZONTAL_GROUP);
            
            keyField = SpawnTextField();
            keyField.RegisterValueChangedCallback(HandleKeyValueChanged);
            
            lockIcon = keyField.Q<VisualElement>("lock-icon");
            HandleEditIDChanged();

            deleteEntryButton = this.Q<Button>(DELETE_ENTRY_BUTTON_NAME);

            if (deleteEntryButton != null)
            {
                deleteEntryButton.clicked += HandleDeleteEntryButtonPressed;
            }
            
            keyField.value = localizationEntry.key;
            callbackOnDelete = deleteCallback;

            LocalizationWindowEditor.OnEditIDChanged += HandleEditIDChanged;
        }
        
        protected TextField SpawnTextField()
        {
            VisualElement valueText = EditorGlobalSettings.LocalizationValueTextXml.Instantiate();
            horizontalGroup.Add(valueText);
            TextField textField = valueText.Q<TextField>();
            
            // Set flex properties
            valueText.style.flexGrow = 1;
            valueText.style.flexShrink = 1;
            valueText.style.flexBasis = 0;
            return textField;
        }

        private void HandleEditIDChanged()
        {
            keyField.isReadOnly = !LocalizationWindowEditor.AllowIDEdit;
            keyField.style.opacity = LocalizationWindowEditor.AllowIDEdit ? 1 : 0.6f;
            lockIcon.style.display = LocalizationWindowEditor.AllowIDEdit ? DisplayStyle.None : DisplayStyle.Flex;
        }

        private void HandleKeyValueChanged(ChangeEvent<string> valueChange)
        {
            tableData.EDITOR_ReplaceKey(valueChange.previousValue, valueChange.newValue);
            UpdateValues();
        }
        
        private void HandleDeleteEntryButtonPressed()
        {
            tableData.EDITOR_Remove(localizationEntry);
            callbackOnDelete?.Invoke();
        }
        
        protected virtual void UpdateValues()
        {
            UpdateTextFieldText(keyField, keyField.value);
        }

        protected void UpdateTextFieldText(TextField textField, string value)
        {
            textField.value = value;
            UpdateBorderWidth(textField, string.IsNullOrEmpty(value));
        }
        
        private void UpdateBorderWidth(VisualElement field, bool empty)
        {
            float width = empty ? 1 : 0;
            field.style.borderBottomWidth = width;
            field.style.borderLeftWidth = width;
            field.style.borderRightWidth = width;
            field.style.borderTopWidth = width;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/BaseLocalizationDataEntry.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/LocalizationExportImportEditorFeatures.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 3a4c9167eef745078999e671e873e133
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using ClosedXML.Excel;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.Localization
{
    /// <summary>
    /// Editor features for exporting and importing localization tables
    /// </summary>
    public class LocalizationExportImportEditorFeatures
    {
        private const double MAX_COLUMN_WIDTH = 100;
        private const double ID_COLUMN_WIDTH = 10;
        private const string FILE_NAME = "{0}_Localization";

        /// <summary>
        /// Exports localization tables to an excel file
        /// </summary>
        [MenuItem("LogicalDox/Localization/Export \u2215 Import/Export")]
        public static void ExportLocalizationExcel()
        {
            string projectName = Application.productName.Replace(" ", "").ToLowerCaseUnderlineFormat();
            string fileName = string.Format(FILE_NAME, projectName) + ".xlsx";

            string path = EditorUtility.SaveFilePanel(
                "Save Excel File",
                "",
                fileName,
                "xlsx");

            if (string.IsNullOrEmpty(path))
            {
                Debug.Log("Save operation cancelled or path is invalid.");
                return;
            }

            using (XLWorkbook workbook = new XLWorkbook())
            {
                foreach (LocalizationTable localizationTable in LocalizationGlobalSettings.LocalizationTables)
                {
                    IXLWorksheet worksheet = workbook.Worksheets.Add(localizationTable.TableName);

                    int currentColumn = 1;
                    List<IXLCell> headerCells = new();
                    IXLCell idHeaderCell = worksheet.Cell(1, currentColumn++);
                    idHeaderCell.Value = "ID";
                    headerCells.Add(idHeaderCell);

                    try
                    {
                        foreach (Language language in localizationTable.TextLocalizationData.LocalizationEntries[0]
                                     .languageValueSet.Keys)
                        {
                            if (!localizationTable.TextLocalizationData
                                    .LocalizationEntries.Any(e => e.languageValueSet[language]
                                        .Length > 0))
                            {
                                continue;
                            }

                            IXLCell langCell = worksheet.Cell(1, currentColumn++);
                            langCell.Value = language.ToString();
                            headerCells.Add(langCell);
                        }
                    }
                    catch (Exception e)
                    {
                        Debug.LogError(e);
                    }
               

                    foreach (IXLCell c in headerCells)
                    {
                        c.Style.Font.Bold = true;
                        c.Style.Fill.BackgroundColor = XLColor.FromHtml("#E4DFEC");
                        c.Style.Protection.SetLocked(true);
                        c.Style.Alignment.Horizontal = XLAlignmentHorizontalValues.Center;
                    }

                    int currentRow = 2;
                    foreach (LocalizationEntry<string> localizationEntry in localizationTable.TextLocalizationData
                                 .LocalizationEntries)
                    {
                        currentColumn = 1;

                        IXLCell idCell = worksheet.Cell(currentRow, currentColumn++);
                        idCell.Value = localizationEntry.key;
                        idCell.Style.Protection.SetLocked(true);
                        idCell.Style.Fill.BackgroundColor = XLColor.FromHtml("#D9D9D9");
                        idCell.Style.Font.FontColor = XLColor.FromHtml("#595959");
                        idCell.Style.Alignment.Vertical = XLAlignmentVerticalValues.Top;
                        idCell.Style.Alignment.Horizontal = XLAlignmentHorizontalValues.Left;

                        foreach (string languageValue in localizationEntry.languageValueSet.Values)
                        {
                            IXLCell valueCell = worksheet.Cell(currentRow, currentColumn++);
                            valueCell.Value = languageValue;
                            valueCell.Style.Protection.SetLocked(false);
                            valueCell.Style.Alignment.WrapText = true; // Enable text wrapping
                            valueCell.Style.Alignment.Vertical = XLAlignmentVerticalValues.Top;
                            valueCell.Style.Alignment.Horizontal = XLAlignmentHorizontalValues.Left;
                        }

                        currentRow++;
                    }

                    worksheet.Columns().AdjustToContents();
                    int i = 0;
                    foreach (IXLColumn column in worksheet.Columns())
                    {
                        if (i == 0)
                        {
                            column.Width = ID_COLUMN_WIDTH;
                        }
                        else
                        {
                            if (column.Width > MAX_COLUMN_WIDTH)
                            {
                                column.Width = MAX_COLUMN_WIDTH;
                            }
                        }

                        i++;
                    }

                    IXLSheetProtection protection = worksheet.Protect();

                    protection.AllowedElements = XLSheetProtectionElements.FormatCells |
                                                 XLSheetProtectionElements.FormatColumns |
                                                 XLSheetProtectionElements.FormatRows |
                                                 XLSheetProtectionElements.SelectUnlockedCells |
                                                 XLSheetProtectionElements.SelectLockedCells |
                                                 XLSheetProtectionElements.Sort;
                }

                workbook.SaveAs(path);
            }

            AssetDatabase.Refresh();

            string message = "Localization sheet exported successfully.";
            EditorUtility.DisplayDialog("Message", message, "Ok");
            Debug.Log(message);
        }

        /// <summary>
        /// Imports localization tables from an excel file
        /// </summary>
        [MenuItem("LogicalDox/Localization/Export \u2215 Import/Import")]
        public static void ImportLocalizationExcel()
        {
            string path = EditorUtility.OpenFilePanel("Open Excel File", "", "xlsx");
            if (string.IsNullOrEmpty(path))
            {
                Debug.Log("Operation cancelled or path is invalid.");
                return;
            }

            HashSet<LocalizationTable> modifiedTables = new();
            using (XLWorkbook workbook = new XLWorkbook(path))
            {
                foreach (IXLWorksheet worksheet in workbook.Worksheets)
                {
                    LocalizationTable currentTable = LocalizationUtilities.EDITOR_GetOrCreateNewTable(worksheet.Name);

                    IXLRow headerRow = worksheet.Row(1);
                    List<Language> fileLanguages = new List<Language>();

                    for (int col = 2; col <= headerRow.LastCellUsed().Address.ColumnNumber; col++)
                    {
                        string languageName = headerRow.Cell(col).GetString();
                        Language language;
                        if (Enum.TryParse(languageName, out language))
                        {
                            fileLanguages.Add(language);
                        }
                    }

                    for (int row = 2; row <= worksheet.LastRowUsed().RowNumber(); row++)
                    {
                        IXLRow dataRow = worksheet.Row(row);
                        string key = dataRow.Cell(1).GetString();
                        List<(Language, string)> entries = new List<(Language, string)>();

                        int columnIndex = 2;
                        foreach (Language language in fileLanguages)
                        {
                            string value = dataRow.Cell(columnIndex++).GetString();
                            entries.Add((language, value));
                        }

                        currentTable.EDITOR_UpdateEntry(key, entries, false);
                    }

                    modifiedTables.Add(currentTable);
                }
            }
            
            // Set all dirty then save manually
            foreach (LocalizationTable table in modifiedTables)
            {
                EditorUtility.SetDirty(table);
            }

            AssetDatabase.SaveAssets();
            
            string message = "Localization sheet imported successfully";
            EditorUtility.DisplayDialog("Message", message, "Ok");
            Debug.Log(message);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/LocalizationExportImportEditorFeatures.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/LocalizationKeyPropertyDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c474aa2bd49d4166b9edd51ad17ced21
# ASMDEF: ldx.framework.editor.dll
# ---
using Systems.Settings;
using UnityEditor;
using UnityEngine;
using Utilities.Extentions;

namespace Ldx.Framework.Systems.Localization
{
    [CustomPropertyDrawer(typeof(LocalizationKeyAttribute))]
    public class LocalizationKeyPropertyDrawer : PropertyDrawer
    {
        private const float BUTTON_WIDTH = 24;
        private const float HEADER_OFFSET = 8;
        private const float HEADER_CONTENT_OFFSET_MULTIPLIER = 0.25f;
        private const float TOGGLE_WIDTH = 120;

        private static readonly GUIContent CopyTextContent = new GUIContent("Copy text");
        private static readonly GUIContent CopyIDContent = new GUIContent("Copy text");
        private static readonly string[] PanelStateLabel = new string[] { "(Click to collapse)", "(Click to expand)" };
        
        private string englishValue;
        private string textValue;
        private bool foldoutOpen;
        private bool expanded;
        private float totalHeight;
        private bool idUnlocked;

        private bool HasEnglishValue => !string.IsNullOrEmpty(englishValue);
        
        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            return base.GetPropertyHeight(property, label) + totalHeight;
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            if (Selection.objects.Length > 1)
            {
                EditorGUI.LabelField(position,  "Not available when selecting multiple objects", EditorStyles.helpBox);
                return;
            }
            
            if (fieldInfo.FieldType != typeof(string))
            {
                totalHeight = position.height;
                EditorGUI.PropertyField(position, property, label);
                return;
            }
            
            if (Event.current.type == EventType.MouseDown && Event.current.button == 1 && position.Contains(Event.current.mousePosition))
            {
                GenericMenu menu = new GenericMenu();
                menu.AddItem(CopyTextContent, false, HandleCopyTextClicked);
                
                if (HasEnglishValue)
                {
                    menu.AddItem(CopyIDContent, false, HandleCopyIDClicked);
                }
                else
                {
                    menu.AddDisabledItem(CopyIDContent);
                }

                menu.ShowAsContext();
                Event.current.Use();
            }

            totalHeight = 0;
            EditorGUI.BeginProperty(position, label, property);
            
            float singleLineHeight = EditorGUIUtility.singleLineHeight;
            float textAreaHeight = EditorGUIUtility.singleLineHeight * 3;

            if (!LocalizationModel.UseLocalization || !LocalizationUtilities.EDITOR_TryGetLocalizationValue(property.stringValue, Language.English,
                    out englishValue))
            {
                englishValue = string.Empty;
            }
            
            Rect headerRect = new Rect(position.x - HEADER_OFFSET, position.y, position.width + HEADER_OFFSET * 2, singleLineHeight * 1.5f);
            totalHeight += headerRect.height;

            RectExtension.DrawRectWithBorder(headerRect, EditorGlobalSettings.LocalizationHeaderColor, 
                EditorGlobalSettings.LocalizationHeaderBorderColor, 0.6f);
            
            Rect labelRect = new Rect(
                position.x, 
                position.y + singleLineHeight * HEADER_CONTENT_OFFSET_MULTIPLIER,
                position.width,
                singleLineHeight);

            EditorGUI.LabelField(labelRect, label);
            
            GUIStyle textButtonStyle = new GUIStyle(GUI.skin.label)
            {
                fontStyle = FontStyle.Italic,
                alignment = TextAnchor.MiddleRight
            };
            
            GUIStyle areaTextStyle = new GUIStyle(EditorStyles.textArea)
            {
                wordWrap = true
            };

            if (LocalizationModel.UseLocalization)
            {
                Rect toggleRect = new Rect(
                    position.x + position.width - BUTTON_WIDTH - TOGGLE_WIDTH, 
                    position.y + singleLineHeight * HEADER_CONTENT_OFFSET_MULTIPLIER,
                    TOGGLE_WIDTH,
                    singleLineHeight);
            
                if (GUI.Button(toggleRect, expanded ? PanelStateLabel[0] : PanelStateLabel[1], textButtonStyle))
                {
                    expanded = !expanded;
                }
            
                Rect localizationStatusRect = new Rect(
                    position.x + position.width - BUTTON_WIDTH, 
                    position.y + singleLineHeight * HEADER_CONTENT_OFFSET_MULTIPLIER, 
                    BUTTON_WIDTH, 
                    singleLineHeight);
            
                GUI.DrawTexture(localizationStatusRect, HasEnglishValue ? 
                        EditorGlobalSettings.LocalizationEntrySavedTexture : EditorGlobalSettings.LocalizationEntryNotSavedTexture,
                    ScaleMode.ScaleToFit);
            }
            else
            {
                expanded = false;
            }
            
            Rect propertyRect = new Rect(
                position.x, 
                position.y + singleLineHeight * 2,
                position.width,
                textAreaHeight);
            totalHeight += propertyRect.height;
            
            if(HasEnglishValue)
            {
                EditorGUI.BeginChangeCheck();
                string newEnglishValue = EditorGUI.TextArea(propertyRect, englishValue, areaTextStyle);
                if (EditorGUI.EndChangeCheck())
                {
                    LocalizationUtilities.EDITOR_TryUpdateLocalizationEntry(property.stringValue,
                        newEnglishValue, Language.English);
                }
            }
            else
            {
                property.stringValue = EditorGUI.TextArea(propertyRect, property.stringValue, areaTextStyle);
            }

            if (expanded)
            {
                EditorGUI.BeginDisabledGroup(!idUnlocked);
                Rect expandRect = new Rect(
                    position.x, 
                    position.y + singleLineHeight * 6,
                    position.width - BUTTON_WIDTH,
                    singleLineHeight);
                float yPosition = expandRect.y;
                totalHeight += expandRect.height + singleLineHeight;
                property.stringValue = EditorGUI.TextField(expandRect,"ID", property.stringValue);
                EditorGUI.EndDisabledGroup();
                
                Rect keyUnlockButton = new Rect(
                    position.x + position.width - BUTTON_WIDTH, 
                    position.y + singleLineHeight * 6,
                    BUTTON_WIDTH,
                    singleLineHeight);

                if (GUI.Button(keyUnlockButton, idUnlocked ? 
                        EditorGlobalSettings.LocalizationKeyUnlockedTexture : EditorGlobalSettings.LocalizationKeyLockedTexture))
                {
                    idUnlocked = !idUnlocked;
                }

                expandRect.width += BUTTON_WIDTH;

                foreach (Language language in LocalizationGlobalSettings.LanguagesToInclude)
                {
                    if (language is Language.English)
                    {
                        continue;
                    }
                    
                    yPosition += expandRect.height;
                    expandRect.y = yPosition;
                    expandRect.height = singleLineHeight;
                    totalHeight += expandRect.height;
                    EditorGUI.LabelField(expandRect, language.ToString());
                    
                    yPosition += expandRect.height;
                    expandRect.y = yPosition;
                    expandRect.height = textAreaHeight;
                    totalHeight += expandRect.height;

                    LocalizationUtilities.EDITOR_TryGetLocalizationValue(property.stringValue, language,
                        out string languageValue);
                    string languageText = EditorGUI.TextArea(expandRect, languageValue, areaTextStyle);
                    if (languageText != null && !languageValue.Equals(languageText))
                    {
                        LocalizationUtilities.EDITOR_TryUpdateLocalizationEntry(property.stringValue, languageText,
                            language);
                    }
                }
            }
            
            EditorGUI.EndProperty();
            textValue = property.stringValue;
        }

        private void HandleCopyTextClicked()
        {
            GUIUtility.systemCopyBuffer = HasEnglishValue ? englishValue : textValue;
        }

        private void HandleCopyIDClicked()
        {
            GUIUtility.systemCopyBuffer = textValue;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/LocalizationKeyPropertyDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/LocalizationPreBuild.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f1d4335fc3c644b1a63ffaa482dddac0
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor.Build;
using UnityEditor.Build.Reporting;

namespace Ldx.Framework.Systems.Localization
{
    /// <summary>
    /// Prebuild script for regenerating localization data before building
    /// </summary>
    public class LocalizationPreBuild : IPreprocessBuildWithReport
    {
        public int callbackOrder => 0;
        
        public void OnPreprocessBuild(BuildReport report)
        {
            if (!LocalizationModel.UseLocalization)
            {
                return;
            }
            LocalizationModel.EDITOR_RegenerateLocalizationData();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/LocalizationPreBuild.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/LocalizationTableButton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d96ca8651d2b41e69c93f1d9323c48a9
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.Localization
{
    [UxmlElement]
    public partial class LocalizationTableButton : VisualElement
    {
        private const string TABLE_BUTTON_NAME = "table-button-{0}";
        private const string SELECT_BUTTON_NAME = "table-select";
        private const string DELETE_BUTTON_NAME = "table-delete";
    
        public static event Action<LocalizationTableButton> OnAnyLocalizationTableSelected;
        public static event Action<LocalizationTableButton> OnAnyLocalizationDeletePressed;

        private Button selectButton;
        private Button deleteButton;

        public LocalizationTable LocalizationTable { get; private set; }
        
        public void SetupTableButton(VisualElement root, LocalizationTable table)
        {
            LocalizationTable = table;
        
            root.name = string.Format(TABLE_BUTTON_NAME, LocalizationTable.TableName);
        
            selectButton = root.Q<Button>(SELECT_BUTTON_NAME);
            UpdateButtonTitle();
            selectButton.clickable.clicked += HandleTableButtonPressed;
        
            deleteButton = root.Q<Button>(DELETE_BUTTON_NAME);
            deleteButton.clickable.clicked += HandleTableButtonDeletePressed;
        }
        
        public void OnDestroy()
        {
            selectButton.clickable.clicked -= HandleTableButtonPressed;
            deleteButton.clickable.clicked -= HandleTableButtonDeletePressed;
        }

        public void UpdateButtonTitle()
        {
            selectButton.text = LocalizationTable.TableName;
        }
    
        private void HandleTableButtonPressed()
        {
            OnAnyLocalizationTableSelected?.Invoke(this);
        }
    
        private void HandleTableButtonDeletePressed()
        {
            OnAnyLocalizationDeletePressed?.Invoke(this);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/LocalizationTableButton.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/LocalizationTableContainer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f92b187d8f774b4c920c6838dff295f0
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Systems.Settings;
using UnityEditor.UIElements;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.Localization
{
    [UxmlElement]
    public partial class LocalizationTableContainer : VisualElement
    {
        private const string TABLE_NAME_FIELD = "table-name-field";
        private const string TABLE_HEADER = "table-header";
        private const string SCROLL_VIEW = "scroll-view";
        private const string NEW_ENTRY_BTN = "btn-new-entry";
        private const string SEARCH_TOOL = "tabSearchTool";
        
        public static event Action<LocalizationTableContainer, string> OnTableNameValueChanged;
        
        private TextField tableNameTextField;
        private ScrollView tabScrollView;
        private VisualElement entryButtonElement;
        private ToolbarSearchField toolbarSearchField;
        private string lastSearchText;

        private List<TextLocalizationDataEntry> localizationDataEntries = new List<TextLocalizationDataEntry>();

        public LocalizationTable LocalizationTable { get; private set; }

        public void InitializeContainer()
        {
            tableNameTextField = this.Q<TextField>(TABLE_NAME_FIELD);
            tableNameTextField.RegisterValueChangedCallback(HandleTableNameValueChanged);

            tabScrollView = this.Q<ScrollView>(SCROLL_VIEW);

            toolbarSearchField = this.Q<ToolbarSearchField>(SEARCH_TOOL);
            toolbarSearchField.RegisterValueChangedCallback(evt =>
            {
                FilterEntries(evt.newValue);
            });

            Toolbar header = this.Q<Toolbar>(TABLE_HEADER);
            AddHeaderLabel(header, "Key");
            foreach (Language language in LocalizationGlobalSettings.LanguagesToInclude)
            {
                AddHeaderLabel(header, language.ToString());
            }
        }

        private void AddHeaderLabel(Toolbar header, string labelText)
        {
            VisualElement labelElement = EditorGlobalSettings.TableHeaderLabelXml.Instantiate();
            header.Add(labelElement);
            Label label = labelElement.Q<Label>();
            label.text = labelText;
                
            // Set the flex-grow property to allow the label to expand
            labelElement.style.flexGrow = 1;
            labelElement.style.flexShrink = 1;
            labelElement.style.flexBasis = 0;
        }
        
        public void DisplayLocalizationTable(LocalizationTable table)
        {
            LocalizationTable = table;
            UpdateTableNameField();
            tabScrollView.Clear();
            entryButtonElement = null;
            DisplayTable(table);
            FilterEntries(lastSearchText);
        }

        private void DisplayTable(LocalizationTable table)
        {
            localizationDataEntries.Clear();
            foreach (LocalizationEntry<string> entry in table.TextLocalizationData.LocalizationEntries)
            {
                CreateEntryElement(table.TextLocalizationData, entry);
            }

            AddButton();
        }

        private void AddButton()
        {
            if (entryButtonElement != null)
            {
                tabScrollView.Remove(entryButtonElement);
                entryButtonElement = null;
            }
            entryButtonElement = EditorGlobalSettings.AddNewEntryButtonXml.Instantiate();
            tabScrollView.Add(entryButtonElement);
            Button newEntryButton = this.Q<Button>(NEW_ENTRY_BTN);
            newEntryButton.clicked -= HandleNewEntryButtonClicked;
            newEntryButton.clicked += HandleNewEntryButtonClicked;
        }
        
        private void HandleNewEntryButtonClicked()
        {
            var newEntry = LocalizationTable.TextLocalizationData.EDITOR_AddNewEntry();
            LocalizationTable.EDITOR_SetDirtyAndSave();
            
            CreateEntryElement(LocalizationTable.TextLocalizationData, newEntry);
            AddButton();
        }

        private void CreateEntryElement(LocalizationTableData<string> data, LocalizationEntry<string> entry)
        {
            VisualElement ve = EditorGlobalSettings.TextDataEntryXml.Instantiate();
            tabScrollView.Add(ve);
            TextLocalizationDataEntry textEntry = ve.Q<TextLocalizationDataEntry>();
            textEntry.DisplayEntry(data, entry, () => HandleEntryDataDeleted(ve));
            localizationDataEntries.Add(textEntry);
        }
        
        private void HandleEntryDataDeleted(VisualElement ve)
        {
            if (ve == null)
            {
                return;
            }
            
            tabScrollView.Remove(ve);
        }
        
        private void HandleTableNameValueChanged(ChangeEvent<string> value)
        {
            OnTableNameValueChanged?.Invoke(this, value.newValue);
        }

        public void UpdateTableNameField()
        {
            tableNameTextField.SetValueWithoutNotify(LocalizationTable.TableName);
        }

        #region Filter

        private void FilterEntries(string searchText)
        {
            lastSearchText = searchText;
            
            foreach (TextLocalizationDataEntry entryElement in localizationDataEntries)
            {
                bool display = false;
                
                LocalizationEntry<string> stringEntry = entryElement.Entry;
                if (string.IsNullOrEmpty(searchText) ||
                    stringEntry.key.Contains(searchText, StringComparison.OrdinalIgnoreCase) ||
                    (stringEntry.languageValueSet != null && stringEntry.languageValueSet.Any(x => x.Value != null &&
                        x.Value.Contains(searchText, StringComparison.OrdinalIgnoreCase))))
                {
                    display = true;
                }

                entryElement.SetVisible(display);
            }

            AddButton(); // Re-add the new entry button at the end
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/LocalizationTableContainer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/LocalizationWindowEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 37348a3cc0b71c944b2aeb496cce8d34
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Text;
using Ldx.Framework.Utilities.Helpers;
using Systems.Settings;
using UnityEditor;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.Localization
{
    public class LocalizationWindowEditor : EditorWindow
    {
        public static event Action OnEditIDChanged;
        
        private const string TABLE_BUTTONS_ROOT = "table-buttons-root";
        private const string NEW_TABLE_BUTTON = "create-new-table-button";
        private const string REGENERATE_DATA_BUTTON = "btn-regenerate-data";
        
        private const string DELETE_QUESTION_TEXT = "You are planning to delete {0} localization table. Are you sure?";
        private const string DELETE_QUESTION_YES = "Yes, and I know how to use git.";
        private const string DELETE_QUESTION_NO = "No, I don't know what I'm doing.";
        
        public static bool AllowIDEdit;
        
        readonly private Dictionary<LocalizationTable, LocalizationTableButton> localizationTableButtons = 
            new Dictionary<LocalizationTable, LocalizationTableButton>();

        private VisualElement localizationTableButtonsRoot;
        private LocalizationTableContainer tableContainer;
        private Toolbar inspectorToolbar;
        
        [MenuItem("LogicalDox/Localization/Localization Window")]
        public static void OpenLocalizationWindow()
        {
            LocalizationWindowEditor wnd = GetWindow<LocalizationWindowEditor>();
            wnd.titleContent = new GUIContent("Localization");
            AllowIDEdit = false;
        }

        private void OnDisable()
        {
            foreach (LocalizationTable table in LocalizationGlobalSettings.LocalizationTables)
            {
                if (table == null)
                {
                    continue;
                }
                
                table.EDITOR_SetDirtyAndSave();
            }
            
            RegenerateData();
            OnEditIDChanged = null;
        }

        public void CreateGUI()
        {
            // Each editor window contains a root VisualElement object
            VisualElement root = rootVisualElement;
        
            // Import UXML
            VisualTreeAsset visualTree = EditorGlobalSettings.LocalizationWindowXml;
            visualTree.CloneTree(root);
        
            // A stylesheet can be added to a VisualElement.
            // The style will be applied to the VisualElement and all of its children.
            StyleSheet styleSheet = EditorGlobalSettings.LocalizationWindowStyle;
            root.styleSheets.Add(styleSheet);
        
            localizationTableButtonsRoot = root.Q<VisualElement>(TABLE_BUTTONS_ROOT);
            
            LoadTables();

            Button newTableButton = root.Q<Button>(NEW_TABLE_BUTTON);
            newTableButton.clickable.clicked += HandleCreateNewTableButtonPressed;

            tableContainer = root.Q<LocalizationTableContainer>();
            tableContainer.InitializeContainer();
            tableContainer.SetEnabled(false);

            inspectorToolbar = root.Q<Toolbar>();
            InitializeFileMenu();

            Button regenerateButton = root.Q<Button>(REGENERATE_DATA_BUTTON);
            regenerateButton.clickable.clicked += HandleRegenerateDataButtonPressed;

            SubscribeToEvents();
        }

        private void LoadTables()
        {
            IEnumerable<LocalizationTable> tables = LocalizationGlobalSettings.LocalizationTables;
                
            localizationTableButtons.Clear();
        
            foreach (LocalizationTable table in tables)
            {
                AddTableButton(table);
            }
        }
        
        /// <summary>
        /// Initializes the File menu in the toolbar.
        /// </summary>
        private void InitializeFileMenu()
        {
            ToolbarMenu toolbarMenu = new() { text = "Editor" };
            toolbarMenu.menu.AppendAction("Allow ID edit", (a) => HandleEditIDToggle(), 
                (a) => AllowIDEdit ? DropdownMenuAction.Status.Checked : DropdownMenuAction.Status.Normal);
            toolbarMenu.menu.AppendAction("Copy missing localization", HandleCopyMissingPressed);

            inspectorToolbar.Add(toolbarMenu);
        }

        private void OnDestroy()
        {
            RegenerateData();
            UnsubscribeFromEvents();
        }

        private void AddTableButton(LocalizationTable table)
        {
            VisualElement tableButton = EditorGlobalSettings.LocalizationTableButton.Instantiate();
            localizationTableButtonsRoot.Add(tableButton);
            LocalizationTableButton button = tableButton.Q<LocalizationTableButton>();
            button.SetupTableButton(button, table);
            localizationTableButtons.Add(table, button);
        }

        private void HandleCreateNewTableButtonPressed()
        {
            AddTableButton(LocalizationUtilities.EDITOR_CreateNewTable());
        }

        private void SubscribeToEvents()
        {
            LocalizationTableButton.OnAnyLocalizationTableSelected += HandleAnyLocalizationTableSelected;
            LocalizationTableButton.OnAnyLocalizationDeletePressed += HandleAnyLocalizationDeletePressed;
            LocalizationTableContainer.OnTableNameValueChanged += HandleTableNameValueChanged;
        }

        private void UnsubscribeFromEvents()
        {
            LocalizationTableButton.OnAnyLocalizationTableSelected -= HandleAnyLocalizationTableSelected;
            LocalizationTableButton.OnAnyLocalizationDeletePressed -= HandleAnyLocalizationDeletePressed;
            LocalizationTableContainer.OnTableNameValueChanged -= HandleTableNameValueChanged;
        }
        
        private void HandleAnyLocalizationTableSelected(LocalizationTableButton table)
        {
            tableContainer.SetEnabled(true);
            tableContainer.DisplayLocalizationTable(table.LocalizationTable);
        }
    
        private void HandleAnyLocalizationDeletePressed(LocalizationTableButton table)
        {
            if (EditorUtility.DisplayDialog("Table deletion", 
                    string.Format(DELETE_QUESTION_TEXT, table.LocalizationTable.TableName), 
                    DELETE_QUESTION_YES, 
                    DELETE_QUESTION_NO))
            {
                RemoveTable(table);
            }
        }
        
        private void HandleTableNameValueChanged(LocalizationTableContainer container, string newTableName)
        {
            LocalizationTable table = container.LocalizationTable;
            table.EDITOR_SetTableName(newTableName);
            
            if (localizationTableButtons.TryGetValue(table,
                    out LocalizationTableButton tableButton))
            {
                tableButton.UpdateButtonTitle();
            }
            
            container.UpdateTableNameField();
        }

        private void RemoveTable(LocalizationTableButton table)
        {
            LocalizationGlobalSettings.EDITOR_RemoveTable(table.LocalizationTable);
            table.OnDestroy();
            table.RemoveFromHierarchy();
            localizationTableButtons.Remove(table.LocalizationTable);
        }
        
        private void HandleRegenerateDataButtonPressed()
        {
            RegenerateData();
        }

        private static void RegenerateData()
        {
            LocalizationModel.EDITOR_RegenerateLocalizationData();
        }

        private void HandleEditIDToggle()
        {
            AllowIDEdit = !AllowIDEdit;
            OnEditIDChanged?.Invoke();
        }
        
        private void HandleCopyMissingPressed(DropdownMenuAction dropdownMenuAction)
        {
            StringBuilder output = new StringBuilder();
            output.AppendLine("Missing localization:");
            HashSet<string> engValues = new HashSet<string>();

            foreach (LocalizationTable table in LocalizationGlobalSettings.LocalizationTables)
            {
                foreach (LocalizationEntry<string> localizationEntry in table.TextLocalizationData.LocalizationEntries)
                {
                    foreach (Language language in LocalizationGlobalSettings.LanguagesToInclude)
                    {
                        if (language == Language.English)
                        {
                            continue;
                        }

                        string value = localizationEntry.GetLanguageValue(language);
                        if (string.IsNullOrEmpty(value))
                        {
                            engValues.Add(localizationEntry.GetLanguageValue(Language.English));
                            break;
                        }
                    }
                }
            }

            foreach (string missingTranslation in engValues)
            {
                output.AppendLine(missingTranslation);
            }

            string outputString = output.ToString();
            outputString.CopyToClipboard();
            Debug.Log(outputString);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/LocalizationWindowEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/LocalizedAudioClipDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 053f9dfd4e7d47e98dca0e832054712e
# ASMDEF: ldx.framework.editor.dll
# ---
using Systems.Sound;
using UnityEditor;
using UnityEngine;

namespace Systems.Localization
{
    [CustomPropertyDrawer(typeof(LocalizedAudioClip))]
    public class LocalizedAudioClipDrawer : PropertyDrawer
    {
         public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            // Using BeginProperty / EndProperty on the parent property means that
            // prefab override logic works on the entire property.
            EditorGUI.BeginProperty(position, label, property);

            // Draw label
            position = EditorGUI.PrefixLabel(position, GUIUtility.GetControlID(FocusType.Passive), label);

            // Don't make child fields be indented
            int indent = EditorGUI.indentLevel;
            EditorGUI.indentLevel = 0;
            
            // Get the language and audioClips properties
            SerializedProperty languageProperty = property.FindPropertyRelative("language");
            SerializedProperty audioClipsProperty = property.FindPropertyRelative("audioClips");

            // Calculate rects for the language dropdown and audio clips list
            // Draw the language dropdown
            Rect languageRect = new Rect(position.x, position.y, position.width, EditorGUIUtility.singleLineHeight);
            EditorGUI.PropertyField(languageRect, languageProperty, GUIContent.none);
            
            // Adjust Y position for the audio clips list
            position.y += EditorGUIUtility.singleLineHeight;

            // Draw each AudioClip individually
            for (int i = 0; i < audioClipsProperty.arraySize; i++)
            {
                // AudioClip field
                Rect audioClipRect = new Rect(position.x, position.y, position.width - 20, EditorGUIUtility.singleLineHeight);
                EditorGUI.PropertyField(audioClipRect, audioClipsProperty.GetArrayElementAtIndex(i), GUIContent.none);

                // "-" button for removing an element
                Rect removeButtonRect = new Rect(position.x + position.width - 20, position.y, 20, EditorGUIUtility.singleLineHeight);
                if (GUI.Button(removeButtonRect, "-"))
                {
                    audioClipsProperty.DeleteArrayElementAtIndex(i);
                }

                position.y += EditorGUIUtility.singleLineHeight;
            }
            
            // "+" button for adding a new element, aligned to the right
            Rect addButtonRect = new Rect(position.x + position.width - 40, position.y, 40, EditorGUIUtility.singleLineHeight);
            if (GUI.Button(addButtonRect, "+"))
            {
                audioClipsProperty.InsertArrayElementAtIndex(audioClipsProperty.arraySize);
            }

            // Set indent back to what it was
            EditorGUI.indentLevel = indent;

            EditorGUI.EndProperty();
        }
        
         public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
         {
             SerializedProperty audioClipsProperty = property.FindPropertyRelative("audioClips");

             // Height for the language field and one extra line for the "+" button
             float totalHeight = EditorGUIUtility.singleLineHeight * 2;

             // Additional height for each AudioClip
             totalHeight += audioClipsProperty.arraySize * EditorGUIUtility.singleLineHeight;

             return totalHeight;
         }

    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/LocalizedAudioClipDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/TextLocalizationDataEntry.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 770cd950b8b4484898eeac00490569d9
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.Localization
{
    [UxmlElement]
    public partial class TextLocalizationDataEntry : BaseLocalizationDataEntry<string>
    {
        public LocalizationEntry<string> Entry { get; private set; }
        readonly private Dictionary<Language, TextField> languageTextFieldSet = new Dictionary<Language, TextField>();

        public override void DisplayEntry(LocalizationTableData<string> localizationTableData, LocalizationEntry<string> entry, Action deleteCallback)
        {
            Entry = entry;
            base.DisplayEntry(localizationTableData, entry, deleteCallback);

            foreach (Language language in LocalizationGlobalSettings.LanguagesToInclude)
            {
                TextField textField = SpawnTextField();
                languageTextFieldSet.Add(language, textField);
                textField.RegisterValueChangedCallback(evt =>
                {
                    HandleLanguageValueChanged(evt, textField, language);
                });
            }

            UpdateValues();
        }

        protected override void UpdateValues()
        {
            base.UpdateValues();
            
            foreach ((Language language, TextField textField) in languageTextFieldSet)
            {
                string value = localizationEntry.GetLanguageValue(language);
                UpdateTextFieldText(textField, value);
            }
        }

        private void HandleLanguageValueChanged(ChangeEvent<string> changeEvent, TextField valueText, Language language)
        {
            localizationEntry.ChangeLanguageValue(language, changeEvent.newValue);
            UpdateValues();
        }

        public void SetVisible(bool setVisible)
        {
            style.display = setVisible ? DisplayStyle.Flex : DisplayStyle.None;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Localization/TextLocalizationDataEntry.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/BaseCreateNodeMenuWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7d6c123efea44a16bb6ad9790a24d854
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEngine;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.NodeGraph
{
    /// <summary>
    /// A base class for creating a custom node menu window in the graph view, enabling node creation via the search window.
    /// </summary>
    public class BaseCreateNodeMenuWindow : ScriptableObject, ISearchWindowProvider
    {
        #region Fields

        private BaseNode owner;
        private BaseGraphView graphView;
        private EditorWindow window;
        private PortView inputPortView;
        private PortView outputPortView;
        private Texture2D icon;
    
        #endregion

        #region Initialization and Destruction

        /// <summary>
        /// Initializes the create node menu window with the graph view, editor window, and optional edge filter for node creation context.
        /// </summary>
        /// <param name="graphView">The graph view in which nodes will be created.</param>
        /// <param name="window">The editor window hosting the graph view.</param>
        /// <param name="edgeFilter">Optional edge to filter possible node connections.</param>
        public void Initialize(BaseGraphView graphView, EditorWindow window, Edge edgeFilter = null)
        {
            this.graphView = graphView;
            this.window = window;
            inputPortView = edgeFilter?.input as PortView;
            outputPortView = edgeFilter?.output as PortView;

            DetermineOwnerNode();

            CreateTransparentIcon();
        }

        /// <summary>
        /// Cleans up resources when the scriptable object is destroyed.
        /// </summary>
        private void OnDestroy()
        {
            if (icon != null)
            {
                DestroyImmediate(icon);
                icon = null;
            }
        }

        #endregion

        #region Search Tree Construction

        /// <summary>
        /// Constructs the search tree used by the search window to display node creation options.
        /// </summary>
        /// <param name="context">The context for the search window.</param>
        /// <returns>A list of search tree entries representing node creation options.</returns>
        public List<SearchTreeEntry> CreateSearchTree(SearchWindowContext context)
        {
            List<SearchTreeEntry> tree = new()
            {
                new SearchTreeGroupEntry(new GUIContent(owner.GetTreeTitleByPort(inputPortView ?? outputPortView))),
            };

            CreateStandardNodeMenu(tree);

            return tree;
        }

        /// <summary>
        /// Creates the standard node menu items based on the owner's port.
        /// </summary>
        /// <param name="tree">The search tree entries list to populate with node menu items.</param>
        private void CreateStandardNodeMenu(List<SearchTreeEntry> tree)
        {
            HashSet<string> titlePaths = new();
            Dictionary<string, BaseNode.NodeParam> nodeEntries = owner.GetNodeDescriptionsByPort(inputPortView ?? outputPortView)?.nodePerMenuTitle;
        
            if (nodeEntries != null)
            {
                foreach (KeyValuePair<string, BaseNode.NodeParam> nodeMenuItem in nodeEntries)
                {
                    AddNodeMenuItem(tree, nodeMenuItem, titlePaths);
                }
            }
        }

        #endregion

        #region Node Creation

        /// <summary>
        /// Handles the selection of a node type from the search window, triggering the creation of the node in the graph view.
        /// </summary>
        /// <param name="searchTreeEntry">The search tree entry selected by the user.</param>
        /// <param name="context">The context for the search window.</param>
        /// <returns>True if the node was successfully created; otherwise, false.</returns>
        public bool OnSelectEntry(SearchTreeEntry searchTreeEntry, SearchWindowContext context)
        {
            VisualElement windowRoot = window.rootVisualElement;
            Vector2 windowMousePosition = windowRoot.ChangeCoordinatesTo(windowRoot.parent, context.screenMousePosition - window.position.position);
            Vector2 graphMousePosition = graphView.contentViewContainer.WorldToLocal(windowMousePosition);

            if (searchTreeEntry.userData is BaseNode.NodeParam nodeParam)
            {
                graphView.CreateNodeWithParam(owner, inputPortView ?? outputPortView, nodeParam, searchTreeEntry.content.text, graphMousePosition);
                return true;
            }
        
            return false;
        }

        #endregion

        #region Helper Methods

        /// <summary>
        /// Determines the owner node based on the input or output port view.
        /// </summary>
        private void DetermineOwnerNode()
        {
            owner = inputPortView?.node as BaseNode ?? outputPortView?.node as BaseNode;
        }

        /// <summary>
        /// Creates a transparent icon used to indent items in the search window.
        /// </summary>
        private void CreateTransparentIcon()
        {
            if (icon == null)
                icon = new Texture2D(1, 1);
            icon.SetPixel(0, 0, new Color(0, 0, 0, 0));
            icon.Apply();
        }

        /// <summary>
        /// Adds a node menu item to the search tree.
        /// </summary>
        /// <param name="tree">The tree to which the item will be added.</param>
        /// <param name="nodeMenuItem">The node menu item to add.</param>
        /// <param name="titlePaths">A set of title paths to ensure unique entries.</param>
        private void AddNodeMenuItem(List<SearchTreeEntry> tree, KeyValuePair<string, BaseNode.NodeParam> nodeMenuItem, HashSet<string> titlePaths)
        {
            string nodePath = nodeMenuItem.Key;
            string nodeName = nodePath;
            int level = 0;
            string[] parts = nodePath.Split('/');

            if (parts.Length > 1)
            {
                nodeName = parts[^1];
                string fullTitleAsPath = "";
                
                for (int i = 0; i < parts.Length - 1; i++)
                {
                    string title = parts[i];
                    fullTitleAsPath += title;
                    level = i + 1;
                    
                    if (!titlePaths.Contains(fullTitleAsPath))
                    {
                        tree.Add(new SearchTreeGroupEntry(new GUIContent(title)) { level = level });
                        titlePaths.Add(fullTitleAsPath);
                    }
                }
            }
            
            tree.Add(new SearchTreeEntry(new GUIContent(nodeName, icon))
            {
                level = level + 1,
                userData = nodeMenuItem.Value
            });
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/BaseCreateNodeMenuWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/BaseEdgeConnectorListener.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 310d8e1255f64e478873ef44efe22a5b
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEngine;

namespace Ldx.Framework.Systems.NodeGraph
{
    /// <summary>
    /// Base class for implementing custom edge connection handling in a graph view.
    /// </summary>
    public class BaseEdgeConnectorListener : IEdgeConnectorListener
    {
        private static BaseCreateNodeMenuWindow EdgeNodeBaseCreateMenuWindow;
    
        private readonly BaseGraphView graphView;

        /// <summary>
        /// Initializes a new instance of the BaseEdgeConnectorListener class.
        /// </summary>
        /// <param name="graphView">The graph view this listener is associated with.</param>
        public BaseEdgeConnectorListener(BaseGraphView graphView)
        {
            this.graphView = graphView;
        }

        #region IEdgeConnectorListener Implementation

        /// <summary>
        /// Called when an edge is dropped outside of a port, typically used to show a node creation menu.
        /// </summary>
        /// <param name="edge">The edge that was dropped.</param>
        /// <param name="position">The position where the edge was dropped.</param>
        public virtual void OnDropOutsidePort(Edge edge, Vector2 position)
        {
            // When one of the ports is null, the edge was created and dropped outside of a port.
            if (edge.input == null || edge.output == null)
                ShowNodeCreationMenuFromEdge(edge, position);
        }

        /// <summary>
        /// Called when an edge is successfully connected between two ports.
        /// </summary>
        /// <param name="graphView">The graph view where the drop occurred.</param>
        /// <param name="edge">The edge that was connected.</param>
        public virtual void OnDrop(GraphView graphView, Edge edge) { }

        #endregion

        #region Protected Methods

        /// <summary>
        /// Shows a node creation menu at the specified position when an edge is dropped outside a port.
        /// </summary>
        /// <param name="edgeView">The edge view associated with the dropped edge.</param>
        /// <param name="position">The position where the menu should be shown.</param>
        protected virtual void ShowNodeCreationMenuFromEdge(Edge edgeView, Vector2 position)
        {
            if (EdgeNodeBaseCreateMenuWindow == null)
                EdgeNodeBaseCreateMenuWindow = ScriptableObject.CreateInstance<BaseCreateNodeMenuWindow>();

            EdgeNodeBaseCreateMenuWindow.Initialize(graphView, EditorWindow.focusedWindow, edgeView);
            SearchWindow.Open(new SearchWindowContext(position + EditorWindow.focusedWindow.position.position), EdgeNodeBaseCreateMenuWindow);
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/BaseEdgeConnectorListener.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/BaseGraphView.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 2c91eacb50f1403f9ba91ba6163c6e5c
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Systems.Settings;
using UnityEditor.Experimental.GraphView;
using UnityEngine;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.NodeGraph
{
    /// <summary>
    /// Abstract class representing the base functionality of a graph view.
    /// </summary>
    public abstract class BaseGraphView : GraphView, IDisposable
    {
        #region Fields

        protected readonly List<Edge> graphEdges = new();
        protected readonly List<GroupView> groupViews = new();

        #endregion

        #region Properties

        public bool IsActive => style.display == DisplayStyle.Flex;
        protected virtual bool CanBeRefreshedOnShow => true;
        protected virtual bool ResetViewOnClear => true;
        protected BaseNode SelectedNode { get; set; }

        #endregion

        #region Constructor

        /// <summary>
        /// Initializes a new instance of the BaseGraphView class.
        /// </summary>
        protected BaseGraphView()
        {
            Insert(0, new GridBackground());

            this.AddManipulator(new ContentZoomer());
            this.AddManipulator(new ContentDragger());
            this.AddManipulator(new DoubleClickSelection());
            this.AddManipulator(new SelectionDragger());
            this.AddManipulator(new ContextualMenuManipulator(BuildContextMenu));
        
            styleSheets.Add(EditorGlobalSettings.ObjectiveWindowStyle);
            deleteSelection = DeleteSelection;
        }
        
        public virtual void Dispose() { }

        #endregion

        #region Context Menu and Selection

        /// <summary>
        /// Deletes the currently selected elements from the graph view.
        /// </summary>
        /// <param name="operationName">The name of the operation triggering the deletion. Used for undo/redo stack.</param>
        /// <param name="askUser">Delegate to ask the user for confirmation before deletion, if necessary.</param>
        protected virtual void DeleteSelection(string operationName, AskUser askUser) { }

        /// <summary>
        /// Builds the context menu for the graph view. This method can be overridden to add custom menu items.
        /// </summary>
        /// <param name="evt">The event data for the context menu population.</param>
        protected virtual void BuildContextMenu(ContextualMenuPopulateEvent evt) { }
        
        
        /// <summary>
        /// Performs an operation on a node in response to a specific interaction, such as a double-click.
        /// This method is intended to be overridden to implement custom behavior for selecting or interacting
        /// with a node more deeply than the default selection mechanism.
        /// </summary>
        /// <param name="deepSelectNode">The node to be deeply selected or interacted with.</param>
        public virtual void DeepSelectNode(BaseNode deepSelectNode) { }
        
        #endregion

        #region Visibility Management

        /// <summary>
        /// Makes the graph view visible and refreshes its content.
        /// </summary>
        public void Show()
        {
            Refresh();
            style.display = DisplayStyle.Flex;
        }

        /// <summary>
        /// Hides the graph view.
        /// </summary>
        public void Hide() 
        {
            style.display = DisplayStyle.None;
        }

        /// <summary>
        /// Refreshes the graph view by clearing and repopulating it if applicable.
        /// </summary>
        public void Refresh()
        {
            if (!CanBeRefreshedOnShow)
            {
                return;
            }
        
            ClearView();
            RepopulateView();
        }

        /// <summary>
        /// Method to repopulate the graph view.
        /// Implementations should use this method to add nodes, edges, and other graph elements back into the view.
        /// </summary>
        protected abstract void RepopulateView();

        #endregion
    
        #region View Reset and Clear

        /// <summary>
        /// Clears the view of all elements and optionally resets it.
        /// </summary>
        /// <param name="forceReset">Forces the view to reset even if not typically required.</param>
        public void ClearView(bool forceReset = false) 
        {
            DeleteElements(graphElements.ToList());
            if (forceReset || ResetViewOnClear)
            {
                ResetView();
            }
        }
    
        /// <summary>
        /// Clears all edges and groups from the graph view.
        /// This method removes these elements from the visual interface and clears the lists that contain them.
        /// </summary>
        private void ClearEdgesAndGroups()
        {
            foreach (Edge edge in graphEdges.Where(edge => edge != null))
            {
                RemoveElement(edge);
            }
        
            graphEdges.Clear();

            foreach (GroupView group in groupViews.Where(group => group != null))
            {
                RemoveElement(group);
            }
        
            groupViews.Clear();
        }

        /// <summary>
        /// Resets the view to its initial state.
        /// </summary>
        private void ResetView()
        {
            float graphViewWidth = resolvedStyle.width;
            float graphViewHeight = resolvedStyle.height;
            Vector2 newCenterPosition = new(graphViewWidth / 2, graphViewHeight / 3);
            newCenterPosition.y -= contentViewContainer.resolvedStyle.height / 2;
            contentViewContainer.style.left = newCenterPosition.x;
            contentViewContainer.style.top = newCenterPosition.y;
            MarkDirtyRepaint();
        }
    
        #endregion

        #region Node Management

        /// <summary>
        /// Creates a node of the specified type at a given position.
        /// </summary>
        /// <param name="owner">The owner of the node to be created.</param>
        /// <param name="from">The port view from which the node is created.</param>
        /// <param name="nodeParam">The parameters of node to create.</param>
        /// <param name="entryName">The name of the entry for the node.</param>
        /// <param name="pos">The position where the node should be placed.</param>
        /// <returns>The created node.</returns>
        public abstract BaseNode CreateNodeWithParam(BaseNode owner, PortView from, BaseNode.NodeParam nodeParam, string entryName, Vector2 pos);

        /// <summary>
        /// Connects nodes and creates groups as needed.
        /// </summary>
        protected virtual void ConnectNodesAndCreateGroups()
        {
            ClearEdgesAndGroups();
        }

        #endregion

        #region Group Management

        /// <summary>
        /// Creates and initializes a group view for a given node group.
        /// </summary>
        /// <param name="group">The node group for which to create a view.</param>
        /// <returns>The created GroupView.</returns>
        protected GroupView CreateGroupView(NodeGroup group)
        {
            GroupView groupView = new();
            groupView.Initialize(this, group);
            groupViews.Add(groupView);
            AddElement(groupView);
            return groupView;
        }

        #endregion
    
        #region Helpers

        /// <summary>
        /// Sets the position of a node in the graph.
        /// </summary>
        /// <param name="node">The node to position.</param>
        /// <param name="pos">The position to set the node to.</param>
        protected void SetNodePosition(BaseNode node, Vector2 pos)
        {
            if (node.SavedNodePosition != Rect.zero)
            {
                node.SetPosition(node.SavedNodePosition);
                return;
            }
        
            node.SetPosition(new Rect(pos.x, pos.y, node.Width, node.Height));
        }
    
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/BaseGraphView.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/BaseNode.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c559e94b4bdb4532b688483b688b448e
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using Systems.Settings;
using UnityEditor.Experimental.GraphView;
using UnityEngine;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.NodeGraph
{
    /// <summary>
    /// Abstract class for a base node in a graph view.
    /// </summary>
    public abstract class BaseNode : Node
    {
        #region Const

        private const string TOP_PORT_CONTAINER_NAME = "TopPortContainer";
        private const string BOTTOM_PORT_CONTAINER_NAME = "BottomPortContainer";
        private const string EXTENSION_CLASS = "extension";
        private const string MENU_ACTION_DELETE = "Delete";
        private const string MENU_ACTION_DUPLICATE = "Duplicate";
        private const string CREATE_NODE = "Create Node";

        #endregion
        
        #region Events

        public static Action<BaseNode> OnAnyNodeSelected;

        #endregion

        #region Fields

        private VisualElement topPortContainer;
        private VisualElement bottomPortContainer;
        protected BaseGraphView graphView;
        
        public class NodeParam
        {
            public Type Type { get; set; }
            public string ID { get; }

            public NodeParam(Type type)
            {
                Type = type;
            }
            
            public NodeParam(Type type, string id)
            {
                Type = type;
                ID = id;
            }
        }
        
        public class NodeDescriptions
        {
            public string title;
            public Dictionary<string, NodeParam> nodePerMenuTitle;

            public NodeDescriptions(string treeTitle)
            {
                title = treeTitle;
                nodePerMenuTitle = new Dictionary<string, NodeParam>();
            }
        }

        public Dictionary<PortView, NodeDescriptions> portNodeDescriptionsMap =
            new Dictionary<PortView, NodeDescriptions>();
        
        protected readonly Dictionary<Direction, List<Port>> ports = new Dictionary<Direction, List<Port>>()
        {
            { Direction.Input, new List<Port>() },
            { Direction.Output, new List<Port>() },
        };

        #endregion

        #region Properties

        public int Width => (int)resolvedStyle.width;
        public int Height => (int)resolvedStyle.height;
        public virtual bool IsDeletable => true;
        protected virtual bool IsDuplicatable => true;
        public abstract Rect SavedNodePosition { get; }
        protected virtual StyleSheet NodeStyleSheet => EditorGlobalSettings.BaseNodeStyle;
        public override bool IsGroupable() => false;

        #endregion

        #region Initialization

        /// <summary>
        /// Initializes the node with necessary settings.
        /// </summary>
        /// <param name="graphView">The graph view this node belongs to.</param>
        /// <param name="nodeName">The name of the node.</param>
        /// <param name="nodeID">The unique identifier for the node.</param>
        public virtual void Initialize(BaseGraphView graphView, string nodeName, string nodeID)
        {
            this.graphView = graphView;
            title = nodeName;
            viewDataKey = nodeID;

            styleSheets.Add(NodeStyleSheet);

            InitializeView();
            InitializePorts();
            InitializeDataBinding();
            InitializeContextMenu();

            RefreshExpandedState();
            RefreshPorts();
        }

        /// <summary>
        /// Initializes the main view of the node.
        /// </summary>
        protected virtual void InitializeView()
        {
            topPortContainer = new VisualElement { name = TOP_PORT_CONTAINER_NAME };
            Insert(0, topPortContainer);

            bottomPortContainer = new VisualElement { name = BOTTOM_PORT_CONTAINER_NAME};
            Add(bottomPortContainer);

            extensionContainer.AddToClassList(EXTENSION_CLASS);
        }

        /// <summary>
        /// Initializes ports for the node. Override in derived classes to add specific ports.
        /// </summary>
        protected virtual void InitializePorts() { }

        /// <summary>
        /// Initializes data binding for the node. Override to bind properties to UI elements.
        /// </summary>
        protected virtual void InitializeDataBinding() { }

        /// <summary>
        /// Initializes the context menu for the node.
        /// </summary>
        private void InitializeContextMenu()
        {
            this.AddManipulator(new ContextualMenuManipulator(BuildContextMenu));
        }

        #endregion

        #region Interactions

        /// <summary>
        /// Called when the node is selected. Invokes the OnAnyNodeSelected action.
        /// </summary>
        public override void OnSelected()
        {
            base.OnSelected();
            OnAnyNodeSelected?.Invoke(this);
        }

        #endregion

        #region Ports

        /// <summary>
        /// Creates and adds a port to the node.
        /// </summary>
        /// <param name="direction">The direction of the port (Input or Output).</param>
        /// <param name="portName">The name of the port.</param>
        /// <param name="isVertical">Indicates if the port should be vertical.</param>
        /// <param name="portType">The type of the port.</param>
        /// <param name="listener">The listener for the port's connector events.</param>
        /// <returns>The created PortView.</returns>
        protected PortView CreateAndAddPort(Direction direction,
            string portName = "",
            bool isVertical = false,
            string portType = "Default",
            BaseEdgeConnectorListener listener = null)
        {
            PortView port = PortView.CreatePortView(direction, Port.Capacity.Multi, portName, isVertical, portType,
                listener ?? new BaseEdgeConnectorListener(graphView));

            switch (direction)
            {
                case Direction.Input:
                    if (isVertical)
                    {
                        topPortContainer.Add(port);
                    }
                    else
                    {
                        inputContainer.Add(port);
                    }

                    break;
                case Direction.Output:
                    if (isVertical)
                    {
                        bottomPortContainer.Add(port);
                    }
                    else
                    {
                        outputContainer.Add(port);
                    }

                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(direction), direction, null);
            }

            ports[direction].Add(port);
            return port;
        }

        /// <summary>
        /// Attempts to connect a port to another port.
        /// </summary>
        /// <param name="direction">The direction of the port attempting to connect.</param>
        /// <param name="connectTo">The port to connect to.</param>
        /// <param name="index">The index of the port in its direction list.</param>
        /// <param name="edge">The resulting edge if connection is successful.</param>
        /// <returns>True if the connection was successful; otherwise, false.</returns>
        public bool TryConnectToPort(Direction direction, Port connectTo, int index, out Edge edge)
        {
            edge = null;
            if (TryGetPort(direction, index, out Port port))
            {
                edge = port.ConnectTo(connectTo);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Tries to get a port by its direction and index.
        /// </summary>
        /// <param name="direction">The direction of the port.</param>
        /// <param name="index">The index of the port in its list.</param>
        /// <param name="port">The found port if successful.</param>
        /// <returns>True if the port was found; otherwise, false.</returns>
        public bool TryGetPort(Direction direction, int index, out Port port)
        {
            port = null;

            if (ports.TryGetValue(direction, out List<Port> dirPorts))
            {
                int clampedIndex = Mathf.Clamp(index, 0, dirPorts.Count - 1);
                port = dirPorts[clampedIndex];
                return true;
            }

            return false;
        }

        #endregion
        
        #region Node Descriptions Management
        
        /// <summary>
        /// Retrieves node descriptions for a given port.
        /// </summary>
        /// <param name="portView">The port for which to retrieve node descriptions.</param>
        /// <returns>The NodeDescriptions associated with the given port, or null if none found.</returns>
        public NodeDescriptions GetNodeDescriptionsByPort(PortView portView)
        {
            return portNodeDescriptionsMap.GetValueOrDefault(portView);
        }

        /// <summary>
        /// Gets the title for the node creation menu based on the port.
        /// </summary>
        /// <param name="portView">The port for which to get the title.</param>
        /// <returns>The title for the node creation menu.</returns>
        public string GetTreeTitleByPort(PortView portView)
        {
            if (portNodeDescriptionsMap.TryGetValue(portView, out NodeDescriptions nodeDescriptions))
            {
                return nodeDescriptions.title;
            }

            return CREATE_NODE;
        }
        
        #endregion

        #region Context Menu

        /// <summary>
        /// Builds the context menu for the node, allowing for actions such as delete and duplicate.
        /// </summary>
        /// <param name="evt">The event data for the context menu population.</param>
        private void BuildContextMenu(ContextualMenuPopulateEvent evt)
        {
            // Clear the default items
            evt.menu.MenuItems().Clear();

            evt.menu.AppendAction(MENU_ACTION_DELETE, _ => DeleteNode(),
                IsDeletable ? DropdownMenuAction.Status.Normal : DropdownMenuAction.Status.Disabled);
            evt.menu.AppendSeparator();
            evt.menu.AppendAction(MENU_ACTION_DUPLICATE, _ => DuplicateNode(), DropdownMenuAction.Status.Normal);
            //TODO: disabled for now, later should be "IsDuplicatable ? DropdownMenuAction.Status.Normal : DropdownMenuAction.Status.Disabled"
            evt.menu.AppendSeparator();

            AddCustomContextMenuItems(evt);

            // Prevent the menu from showing default items.
            evt.StopImmediatePropagation();
        }

        /// <summary>
        /// Adds custom items to the node's context menu. Override to add specific items.
        /// </summary>
        /// <param name="evt">The event data for the context menu population.</param>
        protected virtual void AddCustomContextMenuItems(ContextualMenuPopulateEvent evt) { }

        /// <summary>
        /// Deletes the node from the graph. Must be implemented by derived classes.
        /// </summary>
        protected abstract void DeleteNode();

        /// <summary>
        /// Duplicates the node in the graph. Must be implemented by derived classes.
        /// </summary>
        protected abstract void DuplicateNode();

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/BaseNode.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/DoubleClickSelection.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c6258c3ff5ab45078547d005817ac247
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.NodeGraph
{
    public class DoubleClickSelection : MouseManipulator 
    {
        private const double DOUBLE_CLICK_DURATION = 0.3;
    
        private double time = EditorApplication.timeSinceStartup;

        public DoubleClickSelection()
        {
            activators.Add(new ManipulatorActivationFilter { button = MouseButton.LeftMouse });
        }
    
        #region Callback Registration

        /// <summary>
        /// Registers callback on the target element to handle mouse down events.
        /// </summary>
        protected override void RegisterCallbacksOnTarget()
        {
            target.RegisterCallback<MouseDownEvent>(OnMouseDown);
        }

        /// <summary>
        /// Unregisters callback from the target element to stop handling mouse down events.
        /// </summary>
        protected override void UnregisterCallbacksFromTarget()
        {
            target.UnregisterCallback<MouseDownEvent>(OnMouseDown);
        }

        #endregion

        #region Event Handlers

        /// <summary>
        /// Handles the mouse down event to detect double-clicks.
        /// </summary>
        /// <param name="evt">The MouseDownEvent event data.</param>
        private void OnMouseDown(MouseDownEvent evt)
        {
            if (target is not BaseGraphView graphView)
                return;

            double duration = EditorApplication.timeSinceStartup - time;
            if (duration < DOUBLE_CLICK_DURATION)
            {
                SelectNode(graphView, evt);
            }

            time = EditorApplication.timeSinceStartup;
        }

        #endregion

        #region Node Selection

        /// <summary>
        /// Selects a node in the graph view based on a double-click event.
        /// </summary>
        /// <param name="graphView">The graph view containing the node.</param>
        /// <param name="evt">The MouseDownEvent triggering the selection.</param>
        private void SelectNode(BaseGraphView graphView, MouseDownEvent evt)
        {
            if (!CanStopManipulation(evt))
                return;

            if (evt.target is not BaseNode clickedElement)
            {
                VisualElement ve = evt.target as VisualElement;
                clickedElement = ve.GetFirstAncestorOfType<BaseNode>(); 
                if (clickedElement == null)
                    return;
            }
            
            graphView.DeepSelectNode(clickedElement);
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/DoubleClickSelection.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/GroupView.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: ee01021712c74109b413af0fbe9b6c5f
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using Systems.Settings;
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.NodeGraph
{
    /// <summary>
    /// Visual representation of a group of nodes in the node graph, allowing for collective manipulation and customization.
    /// </summary>
    public class GroupView : Group
    {
#pragma warning disable CS0067
        public static event Action<GroupView> OnAnyGroupPropertyFieldChanged;
#pragma warning restore CS0067

        private const int HEADER_MARGIN_TOP = 10;
        private const int HEADER_MARGIN_BOTTOM = 30;
        private const int HEADER_MARGIN_SIDES = 20;
        
        public BaseGraphView owner;
        private NodeGroup nodeGroup;
        
        public string OwnerID => nodeGroup.OwnerID;
        
        #region Initialization

        /// <summary>
        /// Creates a new instance of <see cref="GroupView"/> and initializes its styling.
        /// </summary>
        public GroupView()
        {
            styleSheets.Add(EditorGlobalSettings.GroupViewStyle);
        }
        
        /// <summary>
        /// Initializes the group view with a specified graph view and node group.
        /// </summary>
        /// <param name="graphView">The graph view that owns this group.</param>
        /// <param name="block">The node group data associated with this group.</param>
        public void Initialize(BaseGraphView graphView, NodeGroup block)
        {
            nodeGroup = block;
            owner = graphView;

            title = block.Title;
			
            this.AddManipulator(new ContextualMenuManipulator(BuildContextualMenu));

            headerContainer.style.marginRight = HEADER_MARGIN_SIDES;
            headerContainer.style.marginLeft = HEADER_MARGIN_SIDES;
            headerContainer.style.marginTop = HEADER_MARGIN_TOP;
            headerContainer.style.marginBottom = HEADER_MARGIN_BOTTOM;

            if (block.SerializedProperties != null)
            {
                foreach (SerializedProperty property in block.SerializedProperties)
                {
                    PropertyField field = new(property) { name = "" };
                    field.BindProperty(property);
                    headerContainer.Add(field);
                }
            }
     
            UpdateGroupColor(nodeGroup.Color);
            InitializeInnerNodes();
        }
        
        /// <summary>
        /// Initializes inner nodes contained within this group, based on their IDs stored in the node group data.
        /// </summary>
        private void InitializeInnerNodes()
        {
            foreach (string nodeID in nodeGroup.InnerNodeIDs)
            {
                Node nodeView = owner.GetNodeByGuid(nodeID);
                if (nodeView == null)
                {
                    Debug.LogWarning("Node GUID not found: " + nodeID);
                    continue;
                }

                AddElement(nodeView);
            }
        }
        
        #endregion

        #region Contextual Menu

        /// <summary>
        /// Builds the contextual menu for this group, adding custom actions defined in the node group.
        /// </summary>
        /// <param name="evt">Event data for the contextual menu.</param>
        private void BuildContextualMenu(ContextualMenuPopulateEvent evt)
        {
            evt.menu.MenuItems().Clear();
            Vector2 mousePosition = Event.current.mousePosition;
            
            foreach (ContextualMenuAction action in nodeGroup.MenuActions)
            {
                evt.menu.AppendAction(action.Title, _ => action.Callback(this, mousePosition));
            }

            evt.StopImmediatePropagation();
        }

        #endregion
        
        #region Node Management

        /// <summary>
        /// Called when new elements are added to the group.
        /// This method updates the group's internal list of node IDs to include those of the newly added elements.
        /// </summary>
        /// <param name="elements">The collection of graph elements being added to the group.</param>
        protected override void OnElementsAdded(IEnumerable<GraphElement> elements)
        {
            foreach (GraphElement element in elements)
            {
                // Adding an element that is not a node currently supported
                if (element is not BaseNode node)
                    continue;

                nodeGroup.InnerNodeIDs.Add(node.viewDataKey);
            }
            
            base.OnElementsAdded(elements);
        }

        /// <summary>
        /// Called when elements are removed from the group.
        /// This method updates the group's internal list of node IDs to exclude those of the removed elements.
        /// </summary>
        /// <param name="elements">The collection of graph elements being removed from the group.</param>
        protected override void OnElementsRemoved(IEnumerable<GraphElement> elements)
        {
            // Only remove the nodes when the group exists in the hierarchy
            if (parent != null)
            {
                foreach (GraphElement element in elements)
                {
                    if (element is not BaseNode node)
                        continue;

                    nodeGroup.InnerNodeIDs.Remove(node.viewDataKey);
                }
            }
            
            base.OnElementsRemoved(elements);
        }
        
        #endregion
        
        #region Helper Methods

        /// <summary>
        /// Updates the visual color of the group.
        /// </summary>
        /// <param name="newColor">The new color to apply to the group.</param>
        private void UpdateGroupColor(Color newColor)
        {
            nodeGroup.Color = newColor;
            style.backgroundColor = newColor;
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/GroupView.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/NodeGroup.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 49c444f4d9114387a479909930b01e11
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.NodeGraph
{
    /// <summary>
    /// Defines an action for contextual menus within the objective system window, allowing for custom actions on group views.
    /// </summary>
    public struct ContextualMenuAction
    {
        public string Title { get; }
        public Action<GroupView, Vector2> Callback { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ContextualMenuAction"/> struct.
        /// </summary>
        /// <param name="title">The title of the action as displayed in the contextual menu.</param>
        /// <param name="callback">The callback action to execute.</param>
        public ContextualMenuAction(string title, Action<GroupView, Vector2> callback)
        {
            Title = title;
            Callback = callback;
        }
    }
    
    /// <summary>
    /// Represents a group of nodes within a graph, allowing for organizational structuring and collective interaction.
    /// </summary>
    [Serializable]
    public class NodeGroup
    {
        #region Fields
        
        public string OwnerID { get; }
        public string Title { get; }
        public Color Color { get; set; }
        public SerializedProperty[] SerializedProperties { get; }
        public ContextualMenuAction[] MenuActions { get; }
        public HashSet<string> InnerNodeIDs { get; } = new();

        #endregion
        
        #region Constructors

        /// <summary>
        /// Default constructor for serialization loading.
        /// </summary>
        public NodeGroup() { }

        /// <summary>
        /// Initializes a new instance of the NodeGroup class with a specified title and owner ID.
        /// </summary>
        /// <param name="title">The title of the node group.</param>
        /// <param name="ownerID">The ID of the group's owner.</param>
        /// <param name="serializedProperties">Array of serialized properties associated with the group.</param>
        /// <param name="menuActions">Contextual menu actions available for the group.</param>
        public NodeGroup(string title, string ownerID, SerializedProperty[] serializedProperties = null, ContextualMenuAction[] menuActions = null)
        {
            Title = title;
            OwnerID = ownerID;
            Color = new Color(0, 0, 0, 0.3f);
            SerializedProperties = serializedProperties;
            MenuActions = menuActions;
        }

        #endregion
        
        #region Methods

        /// <summary>
        /// Adds a node's ID to the group.
        /// </summary>
        /// <param name="id">The GUID of the node to add.</param>
        public void Add(string id)
        {
            InnerNodeIDs.Add(id);
        }
    
        /// <summary>
        /// Removes a node's ID from the group.
        /// </summary>
        /// <param name="id">The GUID of the node to remove.</param>
        public void Remove(string id)
        {
            InnerNodeIDs.Remove(id);
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/NodeGroup.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/PortView.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d6f86f4d47b54f9cbca539aafd5e6e5d
# ASMDEF: ldx.framework.editor.dll
# ---
using Systems.Settings;
using UnityEditor.Experimental.GraphView;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.NodeGraph
{
    /// <summary>
    /// Represents a custom port view for nodes within a graph.
    /// </summary>
    public class PortView : Port
    {
        #region Const

        private const string PORT_TYPE_CLASS = "Port_{0}";
        private const string PORT_VERTICAL_CLASS = "Vertical";
        private const string PORT_DEFAULT_TYPE = "Default";
        private const string CONNECTOR_ELEMENT_NAME = "connector";
        private const string CAP_ELEMENT_NAME = "cap";
        private const string TYPE_ELEMENT_NAME = "type";
        private const int PORT_SIZE = 8;

        #endregion
        
        #region Constructor

        /// <summary>
        /// Initializes a new instance of the PortView class.
        /// </summary>
        /// <param name="direction">The direction of the port (input or output).</param>
        /// <param name="capacity">The capacity of the port (single or multiple connections).</param>
        /// <param name="portName">The name of the port.</param>
        /// <param name="isVertical">Indicates if the port is vertical.</param>
        /// <param name="portType">The type of the port for styling purposes.</param>
        public PortView(Direction direction, Capacity capacity, string portName = "", bool isVertical = false, string portType = PORT_DEFAULT_TYPE) 
            : base(isVertical ? Orientation.Vertical : Orientation.Horizontal, direction, capacity, typeof(bool))
        {
            this.portName = portName;
            styleSheets.Add(EditorGlobalSettings.PortViewStyle);

            if (EditorGlobalSettings.PortViewTypesStyle != null)
            {
                styleSheets.Add(EditorGlobalSettings.PortViewTypesStyle);
            }
        
            visualClass = string.Format(PORT_TYPE_CLASS, portType);
            if (isVertical)
            {
                AddToClassList(PORT_VERTICAL_CLASS);
            }

            UpdatePortSize();
        }

        #endregion
    
        #region Public Methods

        /// <summary>
        /// Updates the visual size of the port based on predefined settings.
        /// </summary>
        private void UpdatePortSize()
        {
            VisualElement connector = this.Q(CONNECTOR_ELEMENT_NAME);
            VisualElement cap = connector.Q(CAP_ELEMENT_NAME);
            connector.style.width = PORT_SIZE;
            connector.style.height = PORT_SIZE;
            cap.style.width = PORT_SIZE - 4;
            cap.style.height = PORT_SIZE - 4;
        }

        /// <summary>
        /// Static factory method to create and initialize a new PortView.
        /// </summary>
        /// <param name="direction">The direction of the port (input or output).</param>
        /// <param name="capacity">The capacity of the port (single or multiple connections).</param>
        /// <param name="portName">The name of the port.</param>
        /// <param name="isVertical">Indicates if the port is vertical.</param>
        /// <param name="portType">The type of the port for styling purposes.</param>
        /// <param name="edgeConnectorListener">The listener for edge connection events.</param>
        /// <returns>A new instance of PortView configured with the specified parameters.</returns>
        public static PortView CreatePortView(Direction direction, Capacity capacity, string portName = "", 
            bool isVertical = false, string portType = PORT_DEFAULT_TYPE, BaseEdgeConnectorListener edgeConnectorListener = null)
        {
            PortView pv = new(direction, capacity, portName, isVertical, portType)
            {
                m_EdgeConnector = new EdgeConnector<Edge>(edgeConnectorListener)
            };
            pv.AddManipulator(pv.m_EdgeConnector);

            // Force picking in the port label to enlarge the edge creation zone
            VisualElement portLabel = pv.Q(TYPE_ELEMENT_NAME);
            if (portLabel != null)
            {
                portLabel.pickingMode = PickingMode.Position;
                portLabel.style.flexGrow = 1;
            }

            if (isVertical)
            {
                // Hide label when the port is vertical
                portLabel.style.display = DisplayStyle.None;
                // Fixup picking mode for vertical top ports
                pv.Q(CONNECTOR_ELEMENT_NAME).pickingMode = PickingMode.Position;
            }
        
            return pv;
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/PortView.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/SplitView.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: ee7cefc9a34c423e9f3e87e101c24229
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.NodeGraph
{
    [UxmlElement]
    public partial class SplitView : TwoPaneSplitView { }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/NodeGraph/SplitView.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/AddInteractionIDsOnSceneSaving.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 4fa551706e2144ceb1ef4b8a985ca5bf
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using System.Linq;
using Autohand;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Ldx.Framework.Systems.Objectives
{
    /// <summary>
    /// Editor feature to execute on saving
    /// Finds new grabbables/sockets, adds InteractableID to them
    /// </summary>
    [SceneSavingAddOn]
    public static class AddInteractionIDsOnSceneSaving
    {
        private const string KEY_WINDOW_ON_SAVE_ENABLED = "INTERACTABLE_ID_WINDOW_ON_SAVE_ENABLED";
        private const string WINDOW_TITLE = "Add Interactable IDs"; 
        private const int WIDTH = 600;
        private const int BASE_HEIGHT = 300;
        
        private static string KeyWindowOnSaveEnabled => $"{PathUtilities.GetProjectDirectoryName()}_{KEY_WINDOW_ON_SAVE_ENABLED}";
        private static bool IsWindowOnSaveEnabled => EditorPrefs.GetBool(KeyWindowOnSaveEnabled, true);
        private static InteractableIDEditorConfig editorConfig;

        private class EntryInfo
        {
            public EntryInfo(MonoBehaviour o)
            {
                Object = o;
                Name = SanitizeName(Object.name);
            }

            private static string[] substringsToRemove = new[] { "Prefab", "Pref", "_", "Prop" };

            public MonoBehaviour Object { get;}
            public string Name { get; set; }
            public bool IsGlobal { get; set; }

            private static string SanitizeName(string name)
            {
                foreach (string toRemove in substringsToRemove)
                {
                    name = name.Replace(toRemove, "");
                }

                name = name.Trim();
                return name.SeparateWords();
            }
        }
        
        public static void SceneSaving()
        {
            if (!IsWindowOnSaveEnabled)
            {
                return;
            }
            editorConfig = Object.FindAnyObjectByType<InteractableIDEditorConfig>();
            if (editorConfig == null)
            {
                editorConfig = new GameObject(nameof(InteractableIDEditorConfig)).AddComponent<InteractableIDEditorConfig>();
                editorConfig.gameObject.hideFlags = HideFlags.HideInHierarchy | HideFlags.DontSaveInBuild;
                EditorUtility.SetDirty(editorConfig.gameObject);
            }
            
            editorConfig.Sanitize();
            
            TryAddNewInteractableIDs(editorConfig.AlreadyProcessed);
        }

        private static void TryAddNewInteractableIDs(List<MonoBehaviour> objectsToFilter = null)
        {
            List<EntryInfo> infoList = GetInteractableIDsWindowEntries(objectsToFilter);
            
            if (infoList.Count < 1)
            {
                return;
            }

            DrawAddInteractableIDsWindow(infoList);
        }

        private static List<EntryInfo> GetInteractableIDsWindowEntries(List<MonoBehaviour> objectsToFilter = null)
        {
            List<MonoBehaviour> foundObjects = new();
            foundObjects.AddRange(Object.FindObjectsByType<GrabbableBase>(FindObjectsInactive.Include, FindObjectsSortMode.None)
                .Where(o => o.GetComponent<InteractableID>() == null));
            foundObjects.AddRange(Object.FindObjectsByType<PlacePoint>(FindObjectsInactive.Include, FindObjectsSortMode.None)
                .Where(o => o.GetComponent<InteractableID>() == null));

            if (objectsToFilter != null)
            {
                foundObjects = foundObjects.Where(o => !objectsToFilter.Contains(o)).ToList();
                if (editorConfig != null)
                {
                    editorConfig.AlreadyProcessed.AddRange(foundObjects);
                    EditorUtility.SetDirty(editorConfig);
                }
            }

            return foundObjects.Select(o => new EntryInfo(o)).ToList();
        }

        private static void SetShowWindowOnSave(bool show)
        {
            EditorPrefs.SetBool(KeyWindowOnSaveEnabled, show);
        }

        private static void DrawAddInteractableIDsWindow(List<EntryInfo> infoList)
        {
            Vector2 scrollPos = new();
            int height = BASE_HEIGHT;
            int lineHeight = (int)EditorGUIUtility.singleLineHeight;
            height += Mathf.Min(infoList.Count, 8) * lineHeight;

            float separatorHeight = lineHeight * (infoList.Count + 1.5f);

            bool isWindowOnSaveEnabled = IsWindowOnSaveEnabled;

            ModalEditorWindow window = null;
            window = ModalEditorWindow.ShowModal(WINDOW_TITLE, windowDrawer);
            window.SetMinSize(WIDTH, height);
            window.OnModalClosed += handleWindowClosed;

            void windowDrawer()
            {
                using (new EditorGUILayout.VerticalScope())
                {
                    EditorGUILayout.LabelField("Detected new Grabbables/Sockets in the scene.");
                    EditorGUILayout.LabelField(
                        "Please enter descriptive names for their interactable IDs then hit Apply.");
                    LdxEditorHelper.DrawHelpBox(
                        "Note: Interactable IDs can be used in the objective system to easily detect events such as grabbing or socketing.");
                    LdxEditorHelper.DrawHorizontalSeparator();
                    EditorGUILayout.HelpBox(
                        "You can open this window manually by going to LogicalDox/Interaction/Add Interactable IDs",
                        MessageType.Info);
                    using (new EditorGUILayout.HorizontalScope())
                    {
                        EditorGUILayout.LabelField("Show window on scene saving?");
                        isWindowOnSaveEnabled =
                            EditorGUILayout.Toggle(isWindowOnSaveEnabled);
                        GUILayout.FlexibleSpace();
                    }

                    LdxEditorHelper.DrawHorizontalSeparator();
                    scrollPos = EditorGUILayout.BeginScrollView(scrollPos);
                    using (new EditorGUILayout.HorizontalScope())
                    {

                        // "Object" Column
                        using (new EditorGUILayout.VerticalScope(GUILayout.Width(WIDTH / 3.0f)))
                        {
                            LdxEditorHelper.DrawBoldLabel("Object");
                            foreach (EntryInfo entry in infoList)
                            {
                                if (GUILayout.Button(entry.Object.name, EditorStyles.linkLabel))
                                {
                                    Selection.activeObject = entry.Object;
                                }
                            }
                        }

                        DrawVerticalSeparator(separatorHeight);

                        // "Interaction ID" Column
                        using (new EditorGUILayout.VerticalScope(GUILayout.Width(WIDTH / 3.0f)))
                        {
                            LdxEditorHelper.DrawBoldLabel("Interaction ID");
                            foreach (EntryInfo entry in infoList)
                            {
                                entry.Name = EditorGUILayout.TextField(entry.Name);
                            }
                        }

                        DrawVerticalSeparator(separatorHeight);

                        // "Is Global?" Column
                        using (new EditorGUILayout.VerticalScope(GUILayout.Width(WIDTH / 3.0f)))
                        {
                            LdxEditorHelper.DrawBoldLabel("Is Global?");
                            foreach (EntryInfo entry in infoList)
                            {
                                entry.IsGlobal = EditorGUILayout.Toggle(entry.IsGlobal);
                            }
                        }
                    }

                    EditorGUILayout.EndScrollView();
                    LdxEditorHelper.DrawHorizontalSeparator();
                    using (new EditorGUILayout.HorizontalScope())
                    {
                        GUILayout.FlexibleSpace();
                        if (GUILayout.Button("Apply", GUILayout.MinWidth(100), GUILayout.MinHeight(lineHeight * 2)))
                        {
                            ApplyIDConfigurations(infoList);
                            window?.Close();
                        }

                        GUILayout.FlexibleSpace();
                    }

                }
            }

            void handleWindowClosed()
            {
                window.OnModalClosed -= handleWindowClosed;
                SetShowWindowOnSave(isWindowOnSaveEnabled);
            }
        }

        private static void ApplyIDConfigurations(List<EntryInfo> infoList)
        {
            foreach (EntryInfo entry in infoList)
            {
                InteractableID interactableId = entry.Object.GetOrAddComponent<InteractableID>();
                interactableId.EDITOR_SetupNewID(entry.Name, entry.IsGlobal);
            }
            
            EditorUtility.DisplayDialog("Message", "Interactable IDs successfully added", "Ok");
        }
        
        private static void DrawVerticalSeparator(float height)
        {
            GUILayout.Space(5);
            Rect rect = GUILayoutUtility.GetRect(1, height, GUILayout.Width(1));
            EditorGUI.DrawRect(rect, Color.gray);
            GUILayout.Space(5);
        }

        [MenuItem("LogicalDox/Interaction/Add Interactable IDs")]
        private static void AddInteractableIdsMenuItem()
        {
            DrawAddInteractableIDsWindow(GetInteractableIDsWindowEntries());
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/AddInteractionIDsOnSceneSaving.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/DialogsEditorFeatures.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d790d7cb5a3946d2baf10f6f486ab7ec
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using ClosedXML.Excel;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
    /// <summary>
    /// Contains functionality for processing dialogs in the editor
    /// </summary>
    public static class DialogsEditorFeatures
    {
        private const string DEFAULT_FILE_SUFFIX = "Dialogs.xlsx";

        /// <summary>
        /// Exports all dialogs from registered scenarios' objectives into an excel sheet
        /// </summary>
        public static void ExportAllDialogsToExcelSheet()
        {
            GlobalData.Instance.Initialize();
            List<ScenarioData> scenarioDataList = GlobalData.Instance.GetScenarioDataList();
            string projectNameFormatted = Application.productName.Replace(" ", "_");
            PerformExportDialogsForScenarios(projectNameFormatted, scenarioDataList.ToArray());
        }

        /// <summary>
        /// Exports dialogs from the current scenario into an excel sheet
        /// </summary>
        public static void ExportCurrentScenarioDialogsToExcelSheet()
        {
            ScenarioData scenarioData = ScenarioEditorHelper.GetScenarioData();
            if (scenarioData == null)
            {
                EditorUtility.DisplayDialog("Error", "Couldn't load ScenarioData for this scenario", "Ok");
                return;
            }

            string projectNameFormatted = Application.productName.Replace(" ", "_");
            string prefix = $"{projectNameFormatted}_{scenarioData.ScenarioName.RemoveSpecialCharacters()}";
            PerformExportDialogsForScenarios(prefix, scenarioData);
        }
        
        private static void PerformExportDialogsForScenarios(string filePrefix, params ScenarioData[] scenarioDataCollection)
        {
            if (LocalizationModel.UseLocalization)
            {
                EditorUtility.DisplayDialog("Message",
                    "Localization is enabled, please use the localization export functionality instead", "Ok");
                return;
            }
            
            string fileName = $"{filePrefix}_{DEFAULT_FILE_SUFFIX}";
            string path = EditorUtility.SaveFilePanel("Save Excel File", "", fileName, "xlsx");

            if (string.IsNullOrEmpty(path))
            {
                return;
            }

            try
            {
                using (XLWorkbook workbook = new XLWorkbook())
                {
                    foreach (ScenarioData scenarioData in scenarioDataCollection)
                    {
                        ObjectiveData objectiveData = scenarioData.EDITOR_GetObjectiveData();
                        string sheetName = scenarioData.ScenarioName.RemoveSpecialCharacters().SeparateWords();
                        IXLWorksheet worksheet = workbook.Worksheets.Add(sheetName);

                        int currentRow = 1;

                        foreach (Objective objective in objectiveData.Objectives)
                        {
                            IXLCell objectiveCell = worksheet.Cell(currentRow++, 1);
                            objectiveCell.Value = objective.Name;
                            objectiveCell.Style.Fill.BackgroundColor = XLColor.LightBlue;
                            objectiveCell.Style.Font.Bold = true;

                            List<string> dialogs = new List<string>();
                            AddDialogsToList(objective, dialogs);
                            foreach (SubObjective subObjective in objective.ChildObjectives)
                            {
                                AddDialogsToList(subObjective, dialogs);
                            }

                            foreach (string dialog in dialogs)
                            {
                                IXLCell dialogCell = worksheet.Cell(currentRow++, 1);
                                dialogCell.Value = dialog;
                                dialogCell.Style.Alignment.WrapText = true;
                            }

                            currentRow++;
                        }

                        worksheet.Columns().AdjustToContents();
                    }

                    workbook.SaveAs(path);
                }

                EditorUtility.DisplayDialog("Success", "Dialogs exported successfully", "Ok");
            }
            catch (Exception e)
            {
                EditorUtility.DisplayDialog("Error", $"The following error was encountered. \n\n{e}\n\nPlease inform Dev.", "Ok");
                Debug.LogError(e);
            }

        }

        private static void AddDialogsToList(BaseObjective objective, List<string> dialogsList)
        {
            foreach (ObjectiveEventData eventData in objective.EventDataContainer)
            {
                if (eventData is IDialogEventData dialogEventData)
                {
                    dialogsList.AddRange(dialogEventData.GetReactiveDialogData().Select(d => d.Text.Value));
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/DialogsEditorFeatures.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/DialogueEditor/DialogueViewObjectiveRow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 093284f11af143ada19490fea28f82c1
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.Localization;
using UnityEditor;
using UnityEngine;
using Debug = Ldx.Framework.Utilities.Logging.Debug;

namespace Ldx.Framework.Systems.Objectives.DialogueEditor
{
    /// <summary>
    /// Dedicated class for a dialogue editor objective row
    /// </summary>
    public class DialogueViewObjectiveRow
    {
        private const float TEXTAREA_HEIGHT_SCALE = 0.8f;
        
        public BaseObjective Objective { get; }
        public string DisplayName => Objective.Name;
        public List<ReactiveDialogData> DialogDataList { get; }
        public Dictionary<ReactiveDialogData, Dictionary<Language, DialogueViewReactiveEntry>> entriesMap;

        private static GUIStyle textAreaStyle;

        private static GUIStyle TextAreaStyle
        {
            get
            {
                if (textAreaStyle == null)
                {
                    textAreaStyle = new GUIStyle(EditorStyles.textArea);
                    textAreaStyle.wordWrap = true;
                    textAreaStyle.padding = new RectOffset(5, 5, 5, 5);
                }
                
                return textAreaStyle;
            }
        }
        
        public DialogueViewObjectiveRow(BaseObjective objective, List<Language> languages)
        {
            Objective = objective;

            DialogDataList = objective.EventDataContainer
                .OfType<IDialogEventData>()
                .SelectMany(dialogEventData => dialogEventData.GetReactiveDialogData())
                .ToList();

            entriesMap = DialogDataList.ToDictionary(
                dialogData => dialogData,
                dialogData => languages.ToDictionary(
                    language => language,
                    language => new DialogueViewReactiveEntry(dialogData, language)
                )
            );
        }

        public void DrawEntry(ReactiveDialogData dialogData, Language language, Rect rect)
        {
            if (!entriesMap.TryGetValue(dialogData, out Dictionary<Language, DialogueViewReactiveEntry> entryMap))
            {
                Debug.LogError($"Error drawing entry: {dialogData}\n\ncan't find ReactiveDialogData");
                return;
            }

            if (!entryMap.TryGetValue(language, out DialogueViewReactiveEntry reactiveEntry))
            {
                Debug.LogError($"Error drawing entry: {dialogData}\n\ncan't find corresponding entry for language: {language}");
                return;
            }

            float textAreaHeight = rect.height * TEXTAREA_HEIGHT_SCALE;
            DrawTextArea(new Rect(rect.x, rect.y, rect.width, textAreaHeight), reactiveEntry);
            DrawAudioClipField(new Rect(rect.x, rect.y + textAreaHeight, rect.width, rect.height - textAreaHeight), reactiveEntry);
        }
        
        private void DrawTextArea(Rect rect, DialogueViewReactiveEntry reactiveEntry)
        {
            GUI.enabled = !reactiveEntry.NoTextSource;
            reactiveEntry.Text.Value = EditorGUI.TextArea(rect, reactiveEntry.Text, TextAreaStyle);
            GUI.enabled = true;
        }
        
        private void DrawAudioClipField(Rect rect, DialogueViewReactiveEntry reactiveEntry)
        {
            if (reactiveEntry.CanHaveVO)
            {
                reactiveEntry.AudioClip.Value = (AudioClip)EditorGUI.ObjectField(rect, reactiveEntry.AudioClip, typeof(AudioClip), false);
            }
            else
            {
                GUI.enabled = false;
                EditorGUI.TextArea(rect, "Can't assign voice over");
                GUI.enabled = true;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/DialogueEditor/DialogueViewObjectiveRow.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/DialogueEditor/DialogueViewReactiveEntry.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 4edb2262bf8d4f1bb2e32b89a6fbe21c
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Utilities.Reactive;
using Systems.Sound;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.DialogueEditor
{
    /// <summary>
    /// Represents a reactive entry in the dialogue editor table
    /// Used to add more context to the ReactiveDialogData
    /// E.g. custom setter based on if localization is on or off
    /// </summary>
    public class DialogueViewReactiveEntry
    {
        public static event Action<DialogueViewReactiveEntry> OnAnyEntryPropertyChanged; 
        
        private readonly ReactiveDialogData dialogData;
        
        public Language? Language { get; }
        public ReactiveProperty<string> Text { get; set; }
        public ReactiveProperty<AudioClip> AudioClip { get; set; }
        private List<LocalizedAudioClip> LocalizedAudioClips { get; }
        public bool CanHaveVO => LocalizedAudioClips != null;

        public bool NoTextSource => dialogData.NoTextSource;

        public DialogueViewReactiveEntry(ReactiveDialogData dialogData, Language? language = null)
        {
            this.dialogData = dialogData;
            LocalizedAudioClips = dialogData.AudioClips;
            AudioClip = new ReactiveProperty<AudioClip>(
                getter: () => dialogData.GetAudioClip(language),
                setter: (c) =>
                {
                    dialogData.SetAudioClip(c, language);
                    OnAnyEntryPropertyChanged?.Invoke(this);
                });

            if (dialogData.NoTextSource)
            {
                Text = new(dialogData.Text);
                return;
            }
            
            if (LocalizationModel.UseLocalization && language != null)
            {
                Language = language;
                Text = new ReactiveProperty<string>(
                    getter: () => dialogData.GetLocalizedText(language.Value),
                    setter: t =>
                    {
                        dialogData.EDITOR_SetLocalizedText(t, language.Value);
                        OnAnyEntryPropertyChanged?.Invoke(this);
                    });
            }
            else
            {
                Text = new ReactiveProperty<string>(
                    getter: ()=>dialogData.Text,
                    setter: (t) =>
                    {
                        dialogData.Text.Value = t;
                        OnAnyEntryPropertyChanged?.Invoke(this);
                    });
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/DialogueEditor/DialogueViewReactiveEntry.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/DialogueEditorWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b77d0cb95cd848f58a80178d2dbbaad3
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Objectives.DialogueEditor;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Ldx.Framework.Systems.Objectives
{
    /// <summary>
    /// Allows manipulation of dialogue text and audio
    /// </summary>
    public class DialogueEditorWindow : EditorWindow
    {
        private const string MENU_TITLE = "Dialogue Editor";
        private const float MIN_ENTRY_WIDTH = 450;
        private const float ENTRY_HEIGHT = 120;
        private const float MIN_OBJECTIVE_COLUMN_WIDTH = 150;
        private const float HEADER_HEIGHT = 30f;
        private const float TOOLBAR_HEIGHT = 23f;
        private const float TOOLBAR_WIDTH = 75f;
        private const float PADDING = 10f;
        private const float TITLE_BG_OFFSET = 2f;

        private static readonly Color WINDOW_BG_COLOR = new Color(0.16f, 0.16f, 0.16f);
        private static readonly Color TOOLBAR_BG_COLOR = new Color(0.13f, 0.13f, 0.13f);
        private static readonly Color HEADER_BG_COLOR = new Color(0.19f, 0.19f, 0.19f);
        private static readonly Color OBJECTIVE_BG_COLOR = new Color(0.22f, 0.22f, 0.22f);
        private static readonly Color ENTRY_BG_COLOR_1 = new Color(0.27f, 0.27f, 0.27f);
        private static readonly Color ENTRY_BG_COLOR_2 = new Color(0.21f, 0.21f, 0.21f);
        private static readonly Color SEPARATOR_COLOR = new Color(0.3f, 0.3f, 0.4f, 0.7f);

        private static readonly Color TEXT_COLOR = new Color(0.8f, 0.8f, 0.8f);
        private static readonly Color TEXT_BG_COLOR = new Color(0.2f, 0.2f, 0.3f);

        private List<ScenarioData> scenarioDataList = new();

        private bool unsavedChanges;
        private Vector2 scrollPosition;
        private ObjectiveData objectiveData;
        private ScenarioData selectedScenarioData;
        private List<Language> languages;
        private List<DialogueViewObjectiveRow> rows = new();
        private float totalWidth;
        private float objectiveColumnWidth;
        private float languageColumnWidth;
        private bool isLoadingRows;
        
        private GUIStyle objectiveNameStyle;
        private GUIStyle titleScenarioNameStyle;
        private GUIStyle titleScenarioNameBGStyle;
        private GUIStyle headerStyle;

        private string CurrentScenarioName => GetScenarioName(selectedScenarioData);

        [MenuItem("LogicalDox/Objectives/Dialogue Editor", priority = 3)]
        public static void ShowWindow()
        {
            DialogueEditorWindow window = GetWindow<DialogueEditorWindow>();
            window.Show();
        }

        private void CreateGUI()
        {
            titleContent = new GUIContent(MENU_TITLE);
            GUI.backgroundColor = WINDOW_BG_COLOR;
            
            InitializeStyles();
            languages = LocalizationModel.UseLocalization
                ? LocalizationGlobalSettings.LanguagesToInclude
                : new List<Language> { Language.English };

            minSize = new Vector2(MIN_OBJECTIVE_COLUMN_WIDTH + (languages.Count * MIN_ENTRY_WIDTH), minSize.y);

            unsavedChanges = false;
            scenarioDataList = GlobalData.Instance.GetScenarioDataList();
            ScenarioData basicsTutorialData = GlobalData.Instance.BasicsTutorialData;
            if (basicsTutorialData != null && !scenarioDataList.Contains(basicsTutorialData))
            {
                scenarioDataList.Add(GlobalData.Instance.BasicsTutorialData);
            }
            
            ScenarioData scenarioData = ScenarioEditorHelper.GetScenarioData();
            if (scenarioData != null)
            {
                LoadScenarioObjectiveData(scenarioData, false);
            }

            EditorSceneManager.sceneSaved -= HandleSaved;
            EditorSceneManager.sceneSaved += HandleSaved;
            
            DialogueViewReactiveEntry.OnAnyEntryPropertyChanged -= HandleEntryPropertyChanged;
            DialogueViewReactiveEntry.OnAnyEntryPropertyChanged += HandleEntryPropertyChanged;
        }
        
        private void OnDestroy()
        {
            EditorSceneManager.sceneSaved -= HandleSaved;
            DialogueViewReactiveEntry.OnAnyEntryPropertyChanged -= HandleEntryPropertyChanged;
            CheckAndPromptSave();
        }

        private void LoadScenarioObjectiveData(ScenarioData scenarioData, bool refreshDelay = true)
        {
            CheckAndPromptSave();
            selectedScenarioData = scenarioData;
            objectiveData = scenarioData.EDITOR_GetObjectiveData();
            LoadRowsAsync(refreshDelay).Forget();
        }

        private async UniTaskVoid LoadRowsAsync(bool refreshDelay = true)
        {
            isLoadingRows = true;
            rows = new();
            // Have to do this weird hack because otherwise Unity keeps 
            // the focused text area if you switch
            if (refreshDelay)
            { 
                await UniTask.Delay(50);
            }

            foreach (Objective obj in objectiveData.Objectives)
            {
                DialogueViewObjectiveRow newRow = new DialogueViewObjectiveRow(obj, languages);
                if (newRow.DialogDataList.Count > 0)
                {
                    rows.Add(newRow);
                }
                foreach (SubObjective subObj in obj.ChildObjectives)
                {
                    DialogueViewObjectiveRow newSubObjRow = new DialogueViewObjectiveRow(subObj, languages);
                    if (newSubObjRow.DialogDataList.Count > 0)
                    {
                        rows.Add(newSubObjRow);
                    }
                }
            }
            isLoadingRows = false;
        }

        private void InitializeStyles()
        {
            objectiveNameStyle = new GUIStyle
            {
                alignment = TextAnchor.MiddleCenter,
                wordWrap = true,
                padding = new RectOffset((int)PADDING, (int)PADDING, (int)PADDING, (int)PADDING),
                normal = { textColor = TEXT_COLOR },
                fontStyle = FontStyle.Bold
            };

            headerStyle = new GUIStyle
            {
                alignment = TextAnchor.MiddleCenter,
                fontSize = 12,
                normal = { textColor = TEXT_COLOR },
                fontStyle = FontStyle.Bold
            };
            
            titleScenarioNameStyle = new GUIStyle
            {
                alignment = TextAnchor.MiddleCenter,
                fontSize = 12,
                normal = { textColor = TEXT_COLOR },
                fontStyle = FontStyle.Bold
            };
            
            titleScenarioNameBGStyle = new GUIStyle(titleScenarioNameStyle)
            {
                normal =
                {
                    textColor = TEXT_BG_COLOR
                }
            };
        }

        private void OnGUI()
        {
            CalculateColumnWidths();
            DrawTableHeaders();

            // Calculate total content height
            float totalContentHeight = 0;
            foreach (DialogueViewObjectiveRow row in rows)
            {
                totalContentHeight += row.DialogDataList.Count * ENTRY_HEIGHT;
            }

            // Calculate current view/scroll rect
            Rect viewRect = new Rect(0, 0, totalWidth, totalContentHeight);
            Rect scrollViewRect = new Rect(0, TOOLBAR_HEIGHT + HEADER_HEIGHT, position.width, position.height - HEADER_HEIGHT);
            
            // Begin scroll view
            scrollPosition = GUI.BeginScrollView(scrollViewRect, scrollPosition, viewRect);

            // Draw the rows
            DrawRows();
            
            // End scroll view
            GUI.EndScrollView();
            
            DrawToolbar();
        }

        private void DrawRows()
        {
            if (isLoadingRows)
            {
                EditorGUIUtility.keyboardControl = 0;
                Repaint();
                return;
            }

            float currentY = 0;
            
            for (int rowIndex = 0; rowIndex < rows.Count; rowIndex++)
            {
                DialogueViewObjectiveRow objectiveRow = rows[rowIndex];
                float rowTotalHeight = objectiveRow.DialogDataList.Count * ENTRY_HEIGHT;

                Rect objectiveRect = new Rect(0, currentY, objectiveColumnWidth, rowTotalHeight);
                EditorGUI.DrawRect(objectiveRect, OBJECTIVE_BG_COLOR);
                EditorGUI.LabelField(objectiveRect, objectiveRow.DisplayName, objectiveNameStyle);

                float entryX = objectiveColumnWidth;
                foreach (Language language in languages)
                {
                    float entryY = currentY;
                    for (int i = 0; i < objectiveRow.DialogDataList.Count; i++)
                    {
                        ReactiveDialogData dialogData = objectiveRow.DialogDataList[i];
                        Rect entryRect = new Rect(entryX, entryY, languageColumnWidth, ENTRY_HEIGHT);
                        EditorGUI.DrawRect(entryRect, i % 2 == 0? ENTRY_BG_COLOR_1 : ENTRY_BG_COLOR_2);

                        // Draw vertical separator
                        EditorGUI.DrawRect(new Rect(entryRect.x - 1, entryRect.y, 2, entryRect.height),
                            SEPARATOR_COLOR);

                        objectiveRow.DrawEntry(dialogData, language, ApplyRectPadding(entryRect, PADDING));

                        entryY += ENTRY_HEIGHT;
                    }

                    entryX += languageColumnWidth;
                }
                EditorGUI.DrawRect(new Rect(0, currentY - 1, totalWidth, 2), SEPARATOR_COLOR);
                currentY += rowTotalHeight;
            }
        }

        private void CalculateColumnWidths()
        {
            totalWidth = position.width;
            objectiveColumnWidth = Mathf.Max(MIN_OBJECTIVE_COLUMN_WIDTH, totalWidth * 0.2f);
            languageColumnWidth = (totalWidth - objectiveColumnWidth) / languages.Count;
        }

        private void DrawToolbar()
        {
            Rect toolbarRect = new Rect(0, 0, position.width, TOOLBAR_HEIGHT);
            EditorGUI.DrawRect(toolbarRect, TOOLBAR_BG_COLOR);
            if (GUI.Button(toolbarRect.Modify(width: TOOLBAR_WIDTH), "Scenario ", EditorStyles.toolbarDropDown))
            {
                GenericMenu menu = new GenericMenu();
                foreach (ScenarioData scenarioData in scenarioDataList)
                {
                    menu.AddItem(new GUIContent(GetScenarioName(scenarioData)),
                        selectedScenarioData == scenarioData, () => LoadScenarioObjectiveData(scenarioData));
                }

                menu.DropDown(new Rect(0, 20, 0, 0));
            }

            if (selectedScenarioData != null)
            {
                Rect textRect = toolbarRect.Modify(
                    y: -1f,
                    height: TOOLBAR_HEIGHT);

                // Draw the BG/shadow text
                EditorGUI.LabelField(
                    textRect.Modify(x: textRect.x + TITLE_BG_OFFSET, y: textRect.y + TITLE_BG_OFFSET),
                    new GUIContent(CurrentScenarioName),
                    titleScenarioNameBGStyle);
                
                // Foreground text
                EditorGUI.LabelField(
                    textRect,
                    new GUIContent(CurrentScenarioName),
                    titleScenarioNameStyle);
            }
        }

        private void DrawTableHeaders()
        {
            Rect headerRect = new Rect(0, TOOLBAR_HEIGHT, position.width, HEADER_HEIGHT+TOOLBAR_HEIGHT);
            EditorGUI.DrawRect(headerRect, HEADER_BG_COLOR);

            Rect objectiveHeaderRect = new Rect(0, TOOLBAR_HEIGHT, objectiveColumnWidth, HEADER_HEIGHT);
            EditorGUI.LabelField(objectiveHeaderRect, "Objective", headerStyle);

            float xOffset = objectiveColumnWidth;
            foreach (Language language in languages)
            {
                Rect languageHeaderRect = new Rect(xOffset, TOOLBAR_HEIGHT, languageColumnWidth, HEADER_HEIGHT);
                EditorGUI.LabelField(languageHeaderRect, language.ToString(), headerStyle);
                
                EditorGUI.DrawRect(new Rect(xOffset - 1, TOOLBAR_HEIGHT, 1, HEADER_HEIGHT), SEPARATOR_COLOR);
                
                xOffset += languageColumnWidth;
            }

            EditorGUI.DrawRect(new Rect(0, TOOLBAR_HEIGHT + HEADER_HEIGHT - 1, headerRect.width, 1), SEPARATOR_COLOR);
        }

        private Rect ApplyRectPadding(Rect rect, float padding)
        {
            return new Rect(
                rect.x + padding,
                rect.y + padding,
                rect.width - (padding * 2),
                rect.height - (padding * 2)
            );
        }
        
        private void HandleSaved(Scene scene)
        {
            unsavedChanges = false;
            titleContent = new GUIContent(MENU_TITLE);
        }

        private string GetScenarioName(ScenarioData scenarioData)
        {
            if (scenarioData == null)
            {
                return null;
            }

            if (LocalizationModel.UseLocalization)
            {
                return LocalizationModel.GetTextString(scenarioData.ScenarioName);
            }

            return scenarioData.ScenarioName;
        }
        
        private void HandleEntryPropertyChanged(DialogueViewReactiveEntry entry)
        {
            unsavedChanges = true;
            titleContent = new GUIContent($"{MENU_TITLE}*");
            if (objectiveData != null)
            {
                EditorUtility.SetDirty(objectiveData);
            }
            
            if (LocalizationModel.UseLocalization)
            {
                LocalizationTable table = LocalizationUtilities.GetLocalizationTableFromEntryKey(entry.Text);
                if (table == null)
                {
                    return;
                }
                EditorUtility.SetDirty(table);
            }
        }
        
        private void CheckAndPromptSave()
        {
            if (!unsavedChanges)
            {
                return;   
            }

            if (!EditorUtility.DisplayDialog("Message", "Detected unsaved changes. \n\nWould you like to save now?", "Yes",
                    "No"))
            {
                return;
            }
            
            AssetDatabase.Refresh();

            if (objectiveData != null)
            {
                AssetDatabase.SaveAssetIfDirty(objectiveData);
            }

            if (LocalizationModel.UseLocalization)
            {
                foreach (LocalizationTable table in LocalizationGlobalSettings.LocalizationTables)
                {
                    AssetDatabase.SaveAssetIfDirty(table);
                }
                
                LocalizationModel.EDITOR_RegenerateLocalizationData();
            }

            unsavedChanges = false;
            titleContent = new GUIContent(MENU_TITLE);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/DialogueEditorWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/EventDataContainerDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c6a965784c15438dad332056402d1517
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
    [CustomPropertyDrawer(typeof(EventDataContainer), true)]
    public class EventDataContainerDrawer : PropertyDrawer
    {
        private static GUIStyle CommentStyle;
        private static SerializedProperty CopiedProperty;
        
        readonly private List<int> removedIndexes = new List<int>();
        readonly private List<int> removedCommentsIndexes = new List<int>();
        
        private int? indexToPaste;
        private Dictionary<SerializedProperty, int> commentToOriginalIndexMap = new Dictionary<SerializedProperty, int>();
        private Dictionary<int, List<SerializedProperty>> commentMap = new Dictionary<int, List<SerializedProperty>>();
        
        public override void OnGUI(Rect position, SerializedProperty property,
            GUIContent label)
        {
            if (CommentStyle == null)
            {
                Texture2D texture = new Texture2D(2, 2);
                Color color = new Color(32f/255f, 36f / 255f, 36f / 255f);
                for (int y = 0; y < texture.height; y++)
                {
                    for (int x = 0; x < texture.width; x++)
                    {
                        texture.SetPixel(x,y, color);
                    }                    
                }
                texture.Apply(true);
                Color textColor = new Color(0.52f, 0.66f, 0.28f);
                CommentStyle = new GUIStyle(EditorStyles.textArea)
                {
                    normal =
                    {
                        background = texture,
                        textColor = textColor
                    },
                    active =
                    {
                        textColor = textColor
                    },
                    fontStyle = FontStyle.Italic
                };
            }
            SerializedProperty dataListProp = property.FindPropertyRelative("objectiveEventData");
            SerializedProperty commentListProp = property.FindPropertyRelative("comments");
            
            EditorGUI.BeginChangeCheck();
            commentToOriginalIndexMap = new Dictionary<SerializedProperty, int>();
            commentMap = new Dictionary<int, List<SerializedProperty>>();
            
            for (int i = 0; i < commentListProp.arraySize; i++)
            {
                SerializedProperty p = commentListProp.GetArrayElementAtIndex(i);
                int index = Mathf.Min(p.FindPropertyRelative("index").intValue, dataListProp.arraySize-1);
                SerializedProperty comment = p.FindPropertyRelative("comment");
                if (!commentMap.ContainsKey(index))
                {
                    commentMap.Add(index, new List<SerializedProperty>());
                }
                commentMap[index].Add(comment);
                commentToOriginalIndexMap.Add(comment, i);
            }
            
            EditorGUI.BeginProperty(position, new GUIContent(), property);
            using (new EditorGUILayout.VerticalScope())
            {
                EditorGUILayout.LabelField(new GUIContent("Event Data"));
                EditorGUI.indentLevel++;
                for (int i = 0; i < dataListProp.arraySize; i++)
                {
                    DrawComments(i, property, commentListProp);
                    // Draw event data
                    SerializedProperty p = dataListProp.GetArrayElementAtIndex(i);
                    p.isExpanded = true;
                    using (new EditorGUILayout.HorizontalScope())
                    {
                        if (GUILayout.Button(" - ", GUILayout.Width(20)))
                        {
                            removedIndexes.Add(i);
                        }

                        using (new EditorGUILayout.VerticalScope())
                        {
                            EditorGUILayout.LabelField(GetPropertyTypeName(p));
                            EditorGUI.indentLevel++;
                            SerializedProperty tP = p.FindPropertyRelative("triggerEventInfo");
                            if (tP != null)
                            {
                                DrawPropertyChildren(tP);
                            }
                            DrawPropertyChildren(p);
                            EditorGUI.indentLevel--;
                        }
                    }
                    CheckRightClick(property, p, GUILayoutUtility.GetLastRect(), i);

                    using (new EditorGUILayout.HorizontalScope())
                    {
                        GUILayout.FlexibleSpace();
                        if (GUILayout.Button(""))
                        {
                            if (i != 0)
                            {
                                dataListProp.MoveArrayElement(i, i - 1);
                            }
                        }

                        if (GUILayout.Button(""))
                        {
                            if (i != dataListProp.arraySize - 1)
                            {
                                dataListProp.MoveArrayElement(i, i + 1);
                            }
                        }
                    }
                    EditorGUILayout.LabelField("", GUI.skin.horizontalSlider);
                }

                for (int i = removedIndexes.Count - 1; i >= 0; i--)
                {
                    dataListProp.DeleteArrayElementAtIndex(removedIndexes[i]);
                }

                if (removedIndexes.Count > 0)
                {
                    dataListProp.serializedObject.ApplyModifiedProperties();
                    removedIndexes.Clear();
                }

                if (indexToPaste != null && CopiedProperty != null)
                {
                    dataListProp.InsertArrayElementAtIndex(indexToPaste.Value);
                    EditorUtility.CopySerializedManagedFieldsOnly(CopiedProperty, dataListProp.GetArrayElementAtIndex(indexToPaste.Value));
                    indexToPaste = null;
                    property.serializedObject.ApplyModifiedProperties();
                }
                EditorGUI.indentLevel--;
            }
            
            using (new EditorGUILayout.HorizontalScope())
            {
                GUILayout.Space(10);
                if (GUILayout.Button("+", GUILayout.Width(20)))
                {
                    GenericMenu menu = new GenericMenu();
                    List<Type> subclassTypes = new List<Type>();
                    foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
                    {
                        subclassTypes.AddRange(assembly.GetTypes()
                            .Where(t => t.IsSubclassOf(typeof(ObjectiveEventData)) && !t.IsAbstract));
                    }

                    subclassTypes.OrderBy(t => t.Name);
                    foreach (Type t in subclassTypes)
                    {
                        string suffixCategory = "";
                        if (!t.Assembly.FullName.Contains("ldx.framework"))
                        {
                            suffixCategory = "Project/";
                        }
                        string categoryStr = "";
                        ObjectiveCategoryAttribute catAttr = t.GetCustomAttribute<ObjectiveCategoryAttribute>();
                        if (catAttr != null)
                        {
                            string sanitizedCatName = catAttr.Category;
                            if (!catAttr.SlashesSeparateCategories)
                            {
                                sanitizedCatName = sanitizedCatName.Replace("/", " \u2044 ");
                            }
                            categoryStr = sanitizedCatName + "/";
                        }
                        menu.AddItem(new GUIContent(suffixCategory+categoryStr+t.Name.Replace("EventData","").SeparateWords()), false, ()=> HandleAddingEventData(property, t));
                        
                    }
                    menu.ShowAsContext();
                }
            }
            EditorGUI.EndProperty();
            
            if (EditorGUI.EndChangeCheck())
            {
                property.serializedObject.ApplyModifiedProperties();
            }
        }

        private void DrawPropertyChildren(SerializedProperty property)
        {
            SerializedProperty iterator = property.Copy();
            SerializedProperty endProperty = iterator.GetEndProperty();
        
            iterator.NextVisible(true);
            while (!SerializedProperty.EqualContents(iterator, endProperty))
            {
                EditorGUILayout.PropertyField(iterator, true);
                iterator.NextVisible(false);
            }
        }
        
        
        private void CheckRightClick(SerializedProperty objectProperty, SerializedProperty clickedProperty, Rect clickArea, int index)
        {
            Event current = Event.current;
 
            if(clickArea.Contains(current.mousePosition) &&  current.type == EventType.ContextClick)
            {
                GenericMenu menu = new GenericMenu();
                menu.AddItem(new GUIContent("Add Comment"), false, () => HandleAddingComment(objectProperty, index));
                //TODO: figure out later
                /*if (false) 
                {
                    menu.AddSeparator("");
                    menu.AddItem(new GUIContent("Copy"), false, () => copiedProperty = clickedProperty);
                    if (copiedProperty == null)
                    {
                        menu.AddDisabledItem(new GUIContent("Paste"));
                    }
                    else
                    {
                        menu.AddItem(new GUIContent("Paste"), false, () => indexToPaste = index);
                    }
                }*/

                menu.ShowAsContext();
                current.Use(); 
            }
        }
        
                
        private void HandleAddingComment(SerializedProperty property, int index)
        {
            SerializedProperty p = property.FindPropertyRelative("comments");
            p.arraySize++;
            SerializedProperty commentProperty = p.GetArrayElementAtIndex(p.arraySize - 1);
            commentProperty.FindPropertyRelative("index").intValue = index;
            commentProperty.FindPropertyRelative("comment").stringValue = "";
            p.serializedObject.ApplyModifiedProperties();
        }
        
        private void HandleAddingEventData(SerializedProperty property, Type t)
        {
            SerializedProperty p = property.FindPropertyRelative("objectiveEventData");
            p.arraySize++;
            p.GetArrayElementAtIndex(p.arraySize - 1).managedReferenceValue = Activator.CreateInstance(t);
            p.serializedObject.ApplyModifiedProperties();
        }

        private void DrawComments(int index, SerializedProperty property, SerializedProperty commentListProp)
        {
            //Draw comments first
            if (commentMap.TryGetValue(index, out List<SerializedProperty> comments))
            {
                foreach (SerializedProperty c in comments)
                {
                    using (new EditorGUILayout.HorizontalScope())
                    {
                        if (GUILayout.Button(" - ", CommentStyle,GUILayout.Width(20)))
                        {
                            removedCommentsIndexes.Add(commentToOriginalIndexMap[c]);
                        }
                        c.stringValue = GUILayout.TextArea(c.stringValue, CommentStyle);
                    }
                }
            }

            foreach (int removedIndex in removedCommentsIndexes)
            {
                commentListProp.DeleteArrayElementAtIndex(removedIndex);
            }
            removedCommentsIndexes.Clear();
        }

        private string GetPropertyTypeName(SerializedProperty property)
        {
            string[] segments = property.type.Split(new[] {'<', '>'});
            if (segments.Length < 2)
            {
                return "";
            }
            return segments[1].Replace("EventData", "").SeparateWords();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/EventDataContainerDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/HighlighterObjectInfoDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 63342c1da1ae4a8388b2438d031f9725
# ASMDEF: ldx.framework.editor.dll
# ---
using Systems.Objectives.EventData;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
    [CustomPropertyDrawer(typeof(HighlighterObjectInfo), true)]
    public class HighlighterObjectInfoDrawer : PropertyDrawer
    {
        private SerializedProperty sHighlighterID;
        private SerializedProperty sIsCorrect;
        private SerializedProperty sEventOnHighlight;
        private SerializedProperty sOverrideTooltip;
        private SerializedProperty sTooltipDescription;
        private SerializedProperty sUseQuestion;
        private SerializedProperty sQuestion;
        private SerializedProperty sUseExplanation;
        private SerializedProperty sExplanation;
        private SerializedProperty sPlaySound;
        private SerializedProperty sSoundRef;
        
        private void Initialize(SerializedProperty property)
        {
            sHighlighterID = property.FindPropertyRelative("highlighterID");
            sIsCorrect = property.FindPropertyRelative("isCorrect");
            sEventOnHighlight = property.FindPropertyRelative("eventOnHighlight");
            sOverrideTooltip = property.FindPropertyRelative("overrideTooltip");
            sTooltipDescription = property.FindPropertyRelative("tooltipDescription");
            sUseQuestion = property.FindPropertyRelative("useQuestion");
            sQuestion = property.FindPropertyRelative("question");
            sUseExplanation = property.FindPropertyRelative("useExplanation");
            sExplanation = property.FindPropertyRelative("explanation");
            sPlaySound = property.FindPropertyRelative("playSoundOnHighlight");
            sSoundRef = property.FindPropertyRelative("soundReference");
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            EditorGUI.BeginProperty(position, label, property);
            Initialize(property);

            if (property == null || sHighlighterID == null)
            {
                return;
            }
            
            EditorGUILayout.PropertyField(sIsCorrect);
            EditorGUILayout.PropertyField(sHighlighterID);
            EditorGUILayout.PropertyField(sEventOnHighlight);
            EditorGUILayout.Separator();
            
            EditorGUILayout.BeginVertical(GUI.skin.box);
            DrawSectionField(sOverrideTooltip, "Override tooltip", sOverrideTooltip.boolValue);
            if (sOverrideTooltip.boolValue)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(sTooltipDescription);
                EditorGUI.indentLevel--;
            }
            EditorGUILayout.EndVertical();
            
            EditorGUILayout.BeginVertical(GUI.skin.box);
            DrawSectionField(sUseQuestion, "Show dialog", sUseQuestion.boolValue, "The dialog that will be displayed on highlight");
            if (sUseQuestion.boolValue)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(sQuestion);
                EditorGUI.indentLevel--;
            }
            EditorGUILayout.EndVertical();
            
            EditorGUILayout.BeginVertical(GUI.skin.box);
            DrawSectionField(sUseExplanation, "Show explanation", sUseExplanation.boolValue);
            if (sUseExplanation.boolValue)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(sExplanation);
                EditorGUI.indentLevel--;
            }
            EditorGUILayout.EndVertical();
            
            EditorGUILayout.BeginVertical(GUI.skin.box);
            DrawSectionField(sPlaySound, "Play sound on highlight", sPlaySound.boolValue);
            if (sPlaySound.boolValue)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(sSoundRef);
                EditorGUI.indentLevel--;
            }
            EditorGUILayout.EndVertical();
            
            EditorGUI.EndProperty();
        }
        
        private void DrawSectionField(SerializedProperty property, string label, bool active, string tooltip = "")
        {
            EditorGUILayout.PropertyField(property, new GUIContent(active ? label + " " : label, tooltip));
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/HighlighterObjectInfoDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/ID/IDContainerExtensionsSceneSavingAddOn.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1a0ffa358657462ca5dfaa2c90cef557
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;

namespace Ldx.Framework.Systems.Objectives.ID
{
    /// <summary>
    /// Makes sure all id settings have all the defined extension containers
    /// </summary>
    [SceneSavingAddOn]
    public class IDContainerExtensionsSceneSavingAddOn
    {
        public static void SceneSaving()
        {
            List<ExtensionIDDefinition> definitions = LoadAllExtensionDefinitions();
            if (definitions.Count < 1)
            {
                return;
            }

            Dictionary<string, ExtensionIDDefinition> definitionIDsMap =
                new(definitions.ToDictionary(d => d.CustomID, d => d));
            
            List<LdxIdSettings> allIDSettings = LdxIdSettings.GetAllIDSettings();

            foreach (LdxIdSettings settings in allIDSettings)
            {
                bool changed = false;

                HashSet<string> settingsIDsSet = new HashSet<string>(settings.ExtensionIDContainers.Select(c => c.CustomID));
                HashSet<string> missingIDsSet = definitionIDsMap.Keys.Except(settingsIDsSet).ToHashSet();
                HashSet<string> extraIDsSet = settingsIDsSet.Except(definitionIDsMap.Keys).ToHashSet();

                // Both set match = we're good
                if (missingIDsSet.Count == 0 && extraIDsSet.Count == 0)
                {
                    continue;
                }

                // There are missing extension containers to add
                if (missingIDsSet.Count > 0)
                {
                    foreach (string id in missingIDsSet)
                    {
                        settings.ExtensionIDContainers.Add(new(definitionIDsMap[id]));
                    }
                    changed = true;
                }
                
                // There are extra extension containers to remove (because the definition was removed perhaps)
                if (extraIDsSet.Count > 0)
                {
                    foreach (string id in extraIDsSet)
                    {
                        settings.ExtensionIDContainers.RemoveAll(c => c.CustomID == id);
                    }
                    changed = true;
                }

                if (changed)
                {
                    EditorUtility.SetDirty(settings);
                }
            }
        }

        private static List<ExtensionIDDefinition> LoadAllExtensionDefinitions()
        {
            List<ExtensionIDDefinition> result = new List<ExtensionIDDefinition>();

            foreach (Assembly assembly in AssemblyUtilities.GetProjectAndFrameworkAssemblies())
            {
                Type baseType = typeof(ExtensionIDDefinition);

                IEnumerable<Type> types = assembly.GetTypes()
                    .Where(t => baseType.IsAssignableFrom(t) && !t.IsAbstract && t.IsClass &&
                                t.GetConstructor(Type.EmptyTypes) != null);

                foreach (Type type in types)
                {
                    try
                    {
                        ExtensionIDDefinition instance = (ExtensionIDDefinition)Activator.CreateInstance(type);
                        result.Add(instance);
                    }
                    catch (Exception ex)
                    {
                        UnityEngine.Debug.LogWarning($"Failed to create instance of {type.FullName}: {ex.Message}");
                    }
                }
            }

            return result;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/ID/IDContainerExtensionsSceneSavingAddOn.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/IdentificationDataDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 77f01b07ae9c48708d5db86757fec970
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using Systems.Objectives.EventData;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
    [CustomPropertyDrawer(typeof(IdentificationData), true)]
    public class IdentificationDataDrawer : PropertyDrawer
    {
        private SerializedProperty sHighlighterObjects;
        private SerializedProperty sLimitTriesAmount;
        private SerializedProperty sMaxTries;
        private SerializedProperty sHighlightCorrectOnFail;
        private SerializedProperty sPlayParticle;
        private SerializedProperty sParticleType;
        private SerializedProperty sCustomParticleType;
        private SerializedProperty sEventOnCorrectHighlight;
        private SerializedProperty sEventOnWrongHighlight;
        private SerializedProperty sEventOnFail;
        private SerializedProperty sEventOnAllCorrectHighlight;

        private void Initialize(SerializedProperty property)
        {
            sHighlighterObjects = property.FindPropertyRelative("highlighterObjects");
            sLimitTriesAmount = property.FindPropertyRelative("limitTriesAmount");
            sMaxTries = property.FindPropertyRelative("maxTries");
            sHighlightCorrectOnFail = property.FindPropertyRelative("highlightCorrectOnFail");
            sPlayParticle = property.FindPropertyRelative("playParticlesOnHighlight");
            sParticleType = property.FindPropertyRelative("particleType");
            sCustomParticleType = property.FindPropertyRelative("customParticleType");
            sEventOnCorrectHighlight = property.FindPropertyRelative("eventOnCorrect");
            sEventOnWrongHighlight = property.FindPropertyRelative("eventOnWrong");
            sEventOnFail = property.FindPropertyRelative("eventOnFail");
            sEventOnAllCorrectHighlight = property.FindPropertyRelative("eventOnAllCorrectHighlight");
        }
        
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            bool changed = false;
            EditorGUI.BeginChangeCheck();
            EditorGUI.BeginProperty(position, label, property);
            Initialize(property);
            
            if (sHighlighterObjects != null)
            {
                HashSet<string> allIds = new();
                HashSet<string> repeatedIDs = new();
                bool hasEmptyIDElements = false;
                CompoundIDInfoContainer idList = LdxIdSettings.GetCompoundIDList(LdxIdSettings.IdType.Dialog);

                EditorGUILayout.LabelField("Highlighter Objects", EditorStyles.boldLabel);
                
                EditorGUI.indentLevel++;
                for (int i = 0; i < sHighlighterObjects.arraySize; i++)
                {
                    SerializedProperty item = sHighlighterObjects.GetArrayElementAtIndex(i);
                    
                    EditorGUILayout.BeginHorizontal();
                    if (GUILayout.Button("-", GUILayout.Width(20), GUILayout.Height(EditorGUIUtility.singleLineHeight + 2 * EditorGUIUtility.standardVerticalSpacing)))
                    {
                        sHighlighterObjects.DeleteArrayElementAtIndex(i);
                        EditorGUILayout.EndHorizontal();
                        changed = true;
                        break;
                    }
                    
                    string highlighterID = item.FindPropertyRelative("highlighterID").stringValue;

                    if (string.IsNullOrEmpty(highlighterID))
                    {
                        hasEmptyIDElements = true;
                    }
                    else
                    {
                        if (!allIds.Add(highlighterID))
                        {
                            repeatedIDs.Add(idList.TryGetIDDescription(highlighterID, out string highlighterName)
                                ? highlighterName
                                : highlighterID);
                        }
                    }

                    EditorGUILayout.BeginVertical();
                    EditorGUILayout.PropertyField(item, new GUIContent($"Item {i}"), true); // Make sure to pass true to include children
                    EditorGUILayout.EndVertical();

                    EditorGUILayout.EndHorizontal();
                }
                
                EditorGUI.indentLevel--; 
                if (GUILayout.Button("+"))
                {
                    changed = true;
                    sHighlighterObjects.arraySize++;
                }
                
                sHighlighterObjects.serializedObject.ApplyModifiedProperties();
                
                // Draw warning box if necessary
                if (hasEmptyIDElements)
                {
                    EditorGUILayout.HelpBox("One or more items have an empty 'highlighterID'. Please provide a unique ID for each item.", MessageType.Warning);
                }
                if (repeatedIDs.Count > 0)
                {
                    EditorGUILayout.HelpBox($"The following IDs are repeated: {string.Join(", ", repeatedIDs)}. Each 'highlighterID' should be unique.", MessageType.Warning);
                }
            }
            
            EditorGUILayout.Separator();
            
            EditorGUILayout.BeginVertical(GUI.skin.box);
            DrawSectionField(sLimitTriesAmount, "Limit tries", "", sLimitTriesAmount.boolValue);
            if (sLimitTriesAmount.boolValue)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(sMaxTries);
                EditorGUILayout.PropertyField(sEventOnFail);
                EditorGUILayout.PropertyField(sHighlightCorrectOnFail);
                EditorGUI.indentLevel--;
            }
            EditorGUILayout.EndVertical();
            
            EditorGUILayout.BeginVertical(GUI.skin.box);
            DrawSectionField(sPlayParticle, "Play particles on highlight", "", sPlayParticle.boolValue);
            if (sPlayParticle.boolValue)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(sParticleType);
                if (sParticleType.enumValueIndex == 1)
                {
                    EditorGUILayout.PropertyField(sCustomParticleType);
                }
                EditorGUI.indentLevel--;
            }
            EditorGUILayout.EndVertical();
            
            EditorGUILayout.BeginVertical(GUI.skin.box);
            EditorGUILayout.LabelField("Events", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(sEventOnCorrectHighlight);
            EditorGUILayout.PropertyField(sEventOnWrongHighlight);
            EditorGUILayout.PropertyField(sEventOnAllCorrectHighlight);
            EditorGUI.indentLevel--;
            EditorGUILayout.EndVertical();
            
            EditorGUI.EndProperty();
            
            if (EditorGUI.EndChangeCheck() || changed)
            {
                property.serializedObject.ApplyModifiedProperties();
            }
        }
        
        private void DrawSectionField(SerializedProperty property, string label, string tooltip, bool active)
        {
            EditorGUILayout.PropertyField(property, new GUIContent(active ? label + " " : label, tooltip));
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/IdentificationDataDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/IDInfoContainerDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7fbf07b323104d4f8f21cf9fc2905c1b
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
    [CustomPropertyDrawer(typeof(IDInfoContainer))]
    public class IDInfoContainerDrawer : PropertyDrawer
    {
        public static Dictionary<string, SerializedProperty> IDToSerializedPropertyMap =
            new Dictionary<string, SerializedProperty>();
        public static SerializedProperty CurrentListProperty { get; private set; }

        private List<int> removedIndecies = new List<int>();
        private int? lastArraySize;
        private HashSet<SerializedProperty> selectedSet = new HashSet<SerializedProperty>();
        private GUIStyle selectedTextFieldStyle = null;

        public override void OnGUI(Rect position, SerializedProperty property,
            GUIContent label)
        {
            SerializedProperty infoListProp = property.FindPropertyRelative("infoList");
            if (lastArraySize == null)
            {
                lastArraySize = infoListProp.arraySize;
            }

            if (selectedTextFieldStyle == null)
            {
                selectedTextFieldStyle = new GUIStyle(EditorStyles.textField);
                var color = new Color(36f/255f, 150f / 255f, 50f / 255f);
                selectedTextFieldStyle.normal.textColor = color;
                selectedTextFieldStyle.active.textColor = color;
                selectedTextFieldStyle.focused.textColor = color;
                selectedTextFieldStyle.hover.textColor = color;
            }
            
            bool changed = false;
            EditorGUI.BeginChangeCheck();
            EditorGUI.BeginProperty(position, new GUIContent(), property);
            using (new EditorGUILayout.VerticalScope())
            {
                EditorGUILayout.LabelField(new GUIContent(property.displayName), EditorStyles.boldLabel);
                EditorGUI.indentLevel++;
                CurrentListProperty = infoListProp;
                for (int i = 0; i < infoListProp.arraySize; i++)
                {
                    SerializedProperty p = infoListProp.GetArrayElementAtIndex(i);
                    var id = p.FindPropertyRelative("id").stringValue;
                    if (!String.IsNullOrEmpty(id) && !IDToSerializedPropertyMap.ContainsKey(id))
                    {
                        IDToSerializedPropertyMap.Add(id, p);
                    }

                    using (new EditorGUILayout.HorizontalScope())
                    {
                        if (GUILayout.Button(" - ", GUILayout.Width(20)))
                        {
                            removedIndecies.Add(i);
                        }
                        
                        EditorGUILayout.LabelField($"ID Description ({p.FindPropertyRelative("id").stringValue?? " "})", GUILayout.MaxWidth(180));
                        DrawSelectionCheckbox(p);
                        GUILayout.FlexibleSpace();
                        if (GUILayout.Button(""))
                        {
                            if (i != 0)
                            {
                                infoListProp.MoveArrayElement(i, i - 1);
                            }
                        }

                        if (GUILayout.Button(""))
                        {
                            if (i < infoListProp.arraySize - 1)
                            {
                                infoListProp.MoveArrayElement(i, i + 1);
                            }
                        }
                    }
                    DrawItem(p);
                }

                for (int i = removedIndecies.Count - 1; i >= 0; i--)
                {
                    infoListProp.DeleteArrayElementAtIndex(removedIndecies[i]);
                }

                if (removedIndecies.Count > 0)
                {
                    infoListProp.serializedObject.ApplyModifiedProperties();
                    removedIndecies.Clear();
                }
                EditorGUI.indentLevel--;
            }
            
            using (new EditorGUILayout.HorizontalScope())
            {
                GUILayout.Space(10);
                if (GUILayout.Button("+", GUILayout.Width(20)))
                {
                    changed = true;
                    infoListProp.arraySize++;
                    var newElement = infoListProp.GetArrayElementAtIndex(infoListProp.arraySize - 1);
                    newElement.FindPropertyRelative("id").stringValue = StringUtilities.GenerateUniqueId();
                    newElement.FindPropertyRelative("description").stringValue = $"Item {infoListProp.arraySize}";
                }
            }

            if (lastArraySize.Value != infoListProp.arraySize)
            {
                EnsureIdIntegrity(infoListProp, ref changed);
            }

            lastArraySize = infoListProp.arraySize;
            
            if (EditorGUI.EndChangeCheck() || changed)
            {
                property.serializedObject.ApplyModifiedProperties();
            }
        }

        private void DrawSelectionCheckbox(SerializedProperty property)
        {
            var isSelectedProperty = property.FindPropertyRelative("isSelected");

            bool isSelected = isSelectedProperty.boolValue;
            bool wasSelected = isSelected;
            
            isSelectedProperty.boolValue = EditorGUILayout.Toggle(isSelected, GUILayout.MaxWidth(40));
        }

        private void DrawItem(SerializedProperty property)
        {
            SerializedProperty descProperty = property.FindPropertyRelative("description");
            bool isSelected = property.FindPropertyRelative("isSelected").boolValue;
            descProperty.stringValue = EditorGUILayout.TextField(descProperty.stringValue ?? "", isSelected? selectedTextFieldStyle : EditorStyles.textField);
        }
        
        private void EnsureIdIntegrity(SerializedProperty infoListProp, ref bool changed)
        {
            HashSet<string> idMap = new HashSet<string>();
            for (int i = 0; i < infoListProp.arraySize; i++)
            {
                SerializedProperty p = infoListProp.GetArrayElementAtIndex(i);
                SerializedProperty idProp = p.FindPropertyRelative("id");
                if (idMap.Contains(idProp.stringValue))
                {
                    changed = true;
                    idProp.stringValue = StringUtilities.GenerateUniqueId();
                }

                idMap.Add(idProp.stringValue);
            }
        }

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            return base.GetPropertyHeight(property, label);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/IDInfoContainerDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/LdxIdSettingsEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c36442d0df4745909bb0d4bc113ebb50
# ASMDEF: ldx.framework.editor.dll
# ---
#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.Objectives.Attributes;
using Ldx.Framework.Systems.Objectives.ID;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Tools;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives
{
    [CustomEditor(typeof(LdxIdSettings))]
    public class LdxIdSettingsEditor : Editor
    {
        public enum IDOperationType
        {
            None = 0,
            Migrate
        }

        private const int MIN_TAB_BTN_COUNT = 2;
        private const float MAX_TAB_BTN_WIDTH = 120;
        private event Action OnTabIndexChanged;

        private string[] tabNames;
        private List<IdTypeWrapper> availableIdTypes;
        private int tabIndex;
        private int operationIndex;
        private IDOperationType currentOperationType = IDOperationType.None;
        private string[] operations;
        private SerializedProperty extensionContainersProperty;
        private LdxIdSettings Target => (LdxIdSettings)target;
        private HashSet<IDInfo> selectedInfosSet = new HashSet<IDInfo>();
        private GUIStyle pressedStyle;
        private IDSelectionOperation SelectionOperation { get; set; } = null;

        private bool AnyInfoSelected => selectedInfosSet.Count > 0;

        private void OnEnable()
        {
            IDInfoContainerDrawer.IDToSerializedPropertyMap.Clear();
            operationIndex = 0;
            currentOperationType = IDOperationType.None;
            extensionContainersProperty = serializedObject.FindProperty("extensionIdContainers");
            HashSet<LdxIdSettings.IdType> redactedIdTypesSet = new() { LdxIdSettings.IdType.Extension };
            
            if (!Target.IsGlobal)
            {
                IEnumerable<LdxIdSettings.IdType> globalOnlyTypes = ReflectionHelpers
                    .GetAllEnumValuesWithAttribute<LdxIdSettings.IdType, GlobalOnlyAttribute>();
                redactedIdTypesSet.UnionWith(globalOnlyTypes);
            }

            availableIdTypes = getAvailableIdTypes();
            
            tabNames = availableIdTypes
                .Select(t => t.DisplayName).ToArray();
            
            operations = Enum.GetNames(typeof(IDOperationType)).Select(t => t.SeparateWords()).ToArray();
            OnTabIndexChanged += HandleTabIndexChanged;

            if (Target.EDITOR_LaunchIdTab != null)
            {
                SetTabIndexByType(Target.EDITOR_LaunchIdTab.Value);
                Target.EDITOR_LaunchIdTab = null;
            }

            List<IdTypeWrapper> getAvailableIdTypes()
            {
                List<IdTypeWrapper> result = new();
                Array array = Enum.GetValues(typeof(LdxIdSettings.IdType));
                
                foreach (LdxIdSettings.IdType idType in array)
                {
                    if (redactedIdTypesSet.Contains(idType))
                    {
                        continue;
                    }
                    result.Add(idType);
                }

                foreach (ExtensionIDInfoContainer containers in LdxIdSettings.GlobalInstance.ExtensionIDContainers)
                {
                    result.Add(containers.IdTypeWrapper);
                }

                return result;
            }
        }

        private void OnDisable()
        {
            SetSelectionForAllInTab(false);
            OnTabIndexChanged -= HandleTabIndexChanged;
        }

        private void HandleTabIndexChanged()
        {
            SetSelectionForAllInTab(false);
            selectedInfosSet.Clear();
            currentOperationType = IDOperationType.None;
            operationIndex = 0;
            SelectionOperation = null;
        }

        private void SetSelectionForAllInTab(bool active)
        {
            var list = LdxIdSettings.GetIDListForSettings(Target, TabIndexToIdType(tabIndex).Value);
            if (list == null)
            {
                Debug.LogError("Can't reset selection - ID ist is null");
                return;
            }

            foreach (var info in list)
            {
                if (!IDInfoContainerDrawer.IDToSerializedPropertyMap.TryGetValue(info.ID, out var property) ||
                    property == null)
                {
                    continue;
                }

                property.FindPropertyRelative("isSelected").boolValue = active;
                serializedObject.ApplyModifiedProperties();
            }
        }

        public override void OnInspectorGUI()
        {
            UpdateSelectedSet();
            using (new EditorGUILayout.VerticalScope())
            {
                DrawTabsToolbar();
                DrawInfo();
                DrawCurrentTab();
                DrawButtons();
                DrawOperationDropdown();
                DrawOperation();
            }
        }

        private void UpdateSelectedSet()
        {
            foreach (var info in LdxIdSettings.GetIDListForSettings(Target, TabIndexToIdType(tabIndex).Value))
            {
                if (info.IsSelected)
                {
                    if (!selectedInfosSet.Contains(info))
                    {
                        selectedInfosSet.Add(info);
                    }
                }
                else
                {
                    if (selectedInfosSet.Contains(info))
                    {
                        selectedInfosSet.Remove(info);
                    }
                }
            }
        }

        private IdTypeWrapper? TabIndexToIdType(int index)
        {
            if (availableIdTypes == null || index < 0 || index >= availableIdTypes.Count)
            {
                return null;
            }
            
            return availableIdTypes[index];
        }

        private void DrawTabsToolbar()
        {
            int index = tabIndex;
            int tabsPerRow = Mathf.Max(MIN_TAB_BTN_COUNT, Mathf.FloorToInt(EditorGUIUtility.currentViewWidth / MAX_TAB_BTN_WIDTH));
            
            if (pressedStyle == null)
            {
                pressedStyle = new GUIStyle(GUI.skin.button)
                {
                    fontStyle = FontStyle.Bold,
                    normal =
                    {
                        background = new Texture2D(1, 1)
                    }
                };

                // A trick to turn off style interactions
                pressedStyle.normal.background.SetPixel(0,0, Color.white);
                pressedStyle.normal.background.Apply();   
            }
            
            EditorGUI.BeginChangeCheck();
            for (int i = 0; i < tabNames.Length; i += tabsPerRow)
            {
                using (new EditorGUILayout.HorizontalScope())
                {
                    for (int j = 0; j < tabsPerRow; j++)
                    {
                        int tabI = i + j;
                        if (tabI >= tabNames.Length)
                        {
                            break;
                        }
                        string tab = tabNames[tabI];
                        bool selected = index == tabI;
                        if (selected)
                        {
                            GUILayout.Box(tab, pressedStyle, GUILayout.MaxWidth(MAX_TAB_BTN_WIDTH));
                        }
                        else if (GUILayout.Button(tab, GUILayout.MaxWidth(MAX_TAB_BTN_WIDTH)))
                        {
                            index = tabI;
                        }
                    }
                }
            }

            if (EditorGUI.EndChangeCheck())
            {
                SetTabIndex(index);
            }
        }

        private void SetTabIndex(int index)
        {
            tabIndex = index;
            OnTabIndexChanged?.Invoke();
        }

        private void SetTabIndexByType(IdTypeWrapper tabType)
        {
            for (int i = 0; i < availableIdTypes.Count; i++)
            {
                IdTypeWrapper idType = availableIdTypes[i];
                if (tabType.IDType == LdxIdSettings.IdType.Extension)
                {
                    if (idType.CustomID == tabType.CustomID)
                    {
                        SetTabIndex(i);
                        return;
                    }
                }

                if (idType.IDType == tabType.IDType)
                {
                    SetTabIndex(i);
                    return;
                }
            }
        }

        private void DrawInfo()
        {
            EditorGUILayout.LabelField("Add IDs here and set readable display descriptions for inspector use",
                EditorStyles.helpBox);
        }

        private void DrawCurrentTab()
        {
            using (new EditorGUILayout.HorizontalScope(GUILayout.MaxWidth(100)))
            {
                if (GUILayout.Button("Select All"))
                {
                    SetSelectionForAllInTab(true);
                }

                if (GUILayout.Button("Unselect All"))
                {
                    SetSelectionForAllInTab(false);
                }
            }

            IdTypeWrapper tabType = TabIndexToIdType(tabIndex).Value;
            switch (tabType.IDType)
            {
                case LdxIdSettings.IdType.TrackingEvent:
                    EditorGUILayout.PropertyField(serializedObject.FindProperty("trackingEventsIds"));
                    break;
                case LdxIdSettings.IdType.ObjectGroup:
                    EditorGUILayout.PropertyField(serializedObject.FindProperty("objectGroupIds"));
                    break;
                case LdxIdSettings.IdType.TrackingFeature:
                    EditorGUILayout.PropertyField(serializedObject.FindProperty("trackingFeatureIds"));
                    break;
                case LdxIdSettings.IdType.Key:
                    EditorGUILayout.PropertyField(serializedObject.FindProperty("keyIds"));
                    break;
                case LdxIdSettings.IdType.Transform:
                    EditorGUILayout.PropertyField(serializedObject.FindProperty("transformIds"));
                    break;
                case LdxIdSettings.IdType.Dialog:
                    EditorGUILayout.PropertyField(serializedObject.FindProperty("dialogIds"));
                    break;
                case LdxIdSettings.IdType.Socketable:
                    EditorGUILayout.PropertyField(serializedObject.FindProperty("socketableIds"));
                    break;
                case LdxIdSettings.IdType.Scenario:
                    EditorGUILayout.PropertyField(serializedObject.FindProperty("scenarioIds"));
                    break;
                case LdxIdSettings.IdType.Objective:
                    EditorGUILayout.PropertyField(serializedObject.FindProperty("objectiveIds"));
                    break;
                case LdxIdSettings.IdType.Interactable:
                    EditorGUILayout.PropertyField(serializedObject.FindProperty("interactableIds"));
                    break;
                case LdxIdSettings.IdType.Extension:
                    DrawExtensionTab(tabType);
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        private void DrawExtensionTab(IdTypeWrapper typeWrapper)
        {
            if (extensionContainersProperty != null && extensionContainersProperty.isArray)
            {
                for (int i = 0; i < extensionContainersProperty.arraySize; i++)
                {
                    SerializedProperty elementProperty = extensionContainersProperty.GetArrayElementAtIndex(i);

                    SerializedProperty customIdField = elementProperty.FindPropertyRelative("customId");

                    if (customIdField is { propertyType: SerializedPropertyType.String })
                    {
                        if (customIdField.stringValue == typeWrapper.CustomID)
                        {
                            SerializedProperty displayNameField = elementProperty.FindPropertyRelative("displayName");
                            string labelText = displayNameField != null && displayNameField.propertyType == SerializedPropertyType.String
                                ? displayNameField.stringValue
                                : $"Element {i}";
                        
                            EditorGUILayout.PropertyField(elementProperty, new GUIContent(labelText), true);
                            return;
                        }
                    }
                }
            }
            else
            {
                EditorGUILayout.HelpBox("The 'extensionList' field is missing or not a list.", MessageType.Warning);
            }
        }

        private void DrawButtons()
        {
            EditorGUILayout.LabelField("", GUI.skin.horizontalSlider);
            using (new EditorGUILayout.HorizontalScope())
            {
                if (GUILayout.Button("Save"))
                {
                    EditorUtility.SetDirty(Target);
                    AssetDatabase.SaveAssets();
                    AssetDatabase.Refresh();
                }

                GUILayout.FlexibleSpace();
            }
        }

        private void DrawOperationDropdown()
        {
            EditorGUILayout.LabelField("", GUI.skin.horizontalSlider);
            var instanceType = LdxIdSettings.GetInstanceType(Target);
            if (instanceType == LdxIdSettings.InstanceTypeResult.NotInSceneMode)
            {
                GUI.enabled = false;
                EditorGUILayout.LabelField("Operation:");
                EditorGUILayout.LabelField("Cannot perform operations, scenario not recognizable or not in scene mode",
                    EditorStyles.boldLabel);
                GUI.enabled = true;
                return;
            }

            if (instanceType == LdxIdSettings.InstanceTypeResult.Other)
            {
                GUI.enabled = false;
                EditorGUILayout.LabelField("Operation:");
                EditorGUILayout.LabelField(
                    "Can only perform operation on either global or related scenario ID settings",
                    EditorStyles.boldLabel);
                GUI.enabled = true;
                return;
            }

            GUI.enabled = AnyInfoSelected;
            int previousIndex = operationIndex;
            operationIndex = EditorGUILayout.Popup("Operation:", operationIndex, operations);
            if (!AnyInfoSelected)
            {
                operationIndex = 0;
            }
            currentOperationType = (IDOperationType)operationIndex;
            if (previousIndex != operationIndex)
            {
                switch (currentOperationType)
                {
                    case IDOperationType.None:
                        SelectionOperation = null;
                        break;
                    case IDOperationType.Migrate:
                        SelectionOperation = new MigrateSelectionOperation(selectedInfosSet, Target, serializedObject,
                            (LdxIdSettings.IdType)tabIndex);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }

                if (SelectionOperation != null)
                {
                    SelectionOperation.OnPerformedOperation += HandlePerformedOperation;
                }
            }

            GUI.enabled = true;
        }

        private void HandlePerformedOperation()
        {
            selectedInfosSet.Clear();
            operationIndex = 0;
            currentOperationType = IDOperationType.None;
            SelectionOperation.OnPerformedOperation -= HandlePerformedOperation;
            SelectionOperation = null;
            IDInfoContainerDrawer.IDToSerializedPropertyMap.Clear();
        }

        private void DrawOperation()
        {
            if (currentOperationType == IDOperationType.None || SelectionOperation == null)
            {
                return;
            }

            SelectionOperation.Draw();
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/LdxIdSettingsEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/BaseObjectiveNode.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 3a3ec5fce17640338dfc90ea75782db2
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.NodeGraph;
using Ldx.Framework.Utilities.Extensions;
using Systems.Settings;
using UnityEditor;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.Objectives.NodeGraph
{
    /// <summary>
    /// BaseObjectiveNode serves as an abstract base class for node types that represent objectives within a node-based graph editor.
    /// It provides functionality for displaying and editing objective-specific properties, options, and conditions through the inspector.
    /// </summary>
    public abstract class BaseObjectiveNode : BaseNode
    {
        private const string CONDITIONS_LABEL = "Conditions";
        private const string OPTIONS_LABEL = "Options";
        private const string MENU_ACTION_ADD_OPTION = "Add option/{0}";
        private const string MENU_ACTION_ADD_CONDITION = "Add condition/{0}";
    
        protected SerializedObjectiveData serializer;
        private SerializedProperty optionsProp;
        private VisualElement optionsContainer;
        private SerializedProperty conditionsProp;
        private VisualElement conditionsContainer;
    
        public BaseObjective BaseObjective { get; private set; }

        #region Initialization

        /// <summary>
        /// Initializes the objective node with graph view, objective data, and the specific base objective instance.
        /// Attaches necessary event listeners and setups UI elements for displaying objective details.
        /// </summary>
        /// <param name="graphView">Graph view that the node is part of.</param>
        /// <param name="objectiveData">Serialized data for objectives.</param>
        /// <param name="baseObjective">Base objective instance associated with this node.</param>
        public virtual void Initialize(BaseGraphView graphView,
            SerializedObjectiveData objectiveData,
            BaseObjective baseObjective)
        {
            if (BaseObjective != null)
            {
                BaseObjective.OnObjectiveConditionsChanged -= HandleObjectiveConditionsChanged;
            }
        
            serializer = objectiveData;
            BaseObjective = baseObjective;
        
            base.Initialize(graphView, baseObjective.Name, baseObjective.ID);
        
            ObjectiveSystemEditorWindow.OnConditionsVisibilityStateChanged += HandleConditionsVisibilityStateChanged;
            BaseObjective.OnObjectiveConditionsChanged += HandleObjectiveConditionsChanged;
        }

        #endregion

        #region Data Binding

        /// <summary>
        /// Sets up data binding for the node, initializing UI containers for options and conditions.
        /// </summary>
        protected override void InitializeDataBinding()
        {
            base.InitializeDataBinding();
            
            //Bind objective name property
            SerializedProperty nodeProp = serializer.FindObjective(serializer.Objectives, BaseObjective);
            SerializedProperty titleProp = nodeProp.FindPropertyRelative("name");
            Label titleLabel = this.Q<Label>("title-label");
            titleLabel.BindProperty(titleProp);
        
            // Options
            optionsContainer = new VisualElement();
            optionsProp = serializer.FindObjectiveOptions(serializer.Objectives, BaseObjective);
            ProcessOptions();

            // Conditions
            conditionsContainer = new VisualElement();
            conditionsProp = serializer.FindObjectiveConditions(serializer.Objectives, BaseObjective);
            ProcessConditions();

            extensionContainer.Add(optionsContainer);
            extensionContainer.Add(conditionsContainer);
        }

        #endregion
    
        #region Context Menu

        /// <summary>
        /// Adds custom context menu items for adding options and conditions to the objective.
        /// </summary>
        /// <param name="evt">The contextual menu populate event.</param>
        protected override void AddCustomContextMenuItems(ContextualMenuPopulateEvent evt)
        {
            base.AddCustomContextMenuItems(evt);
            AddOptionMenuItems(evt);
            AddConditionMenuItems(evt);
        }

        #endregion
    
        #region Options Processing

        /// <summary>
        /// Processes and displays objective options in the UI.
        /// </summary>
        private void ProcessOptions()
        {
            optionsContainer.Clear();
        
            optionsContainer.Add(new Label()
            {
                text = OPTIONS_LABEL,
                style =
                {
                    unityFontStyleAndWeight = FontStyle.Bold,
                    marginLeft = 5,
                    marginTop = 5,
                    marginRight = 5,
                },
            });
        
            if (optionsProp == null || optionsProp.arraySize < 1)
            {
                UpdateOptionsVisibility();
                return;
            }
        
            for (int i = 0; i < optionsProp.arraySize; i++)
            {
                AddNewOptionElement(i);
            }
        }

        /// <summary>
        /// Updates the visibility of the options container based on the number of options.
        /// </summary>
        private void UpdateOptionsVisibility()
        {
            optionsContainer.style.display = optionsProp.arraySize > 0 ? DisplayStyle.Flex : DisplayStyle.None;
        }
    
        /// <summary>
        /// Adds a new option element to the UI for a specific index.
        /// </summary>
        /// <param name="index">The index of the option in the serialized property array.</param>
        private void AddNewOptionElement(int index)
        {
            TemplateContainer element = EditorGlobalSettings.OptionElementXml.Instantiate();
            OptionElement optionElement = element.Q<OptionElement>();
            optionElement.InitializeOptionElement(optionsProp, index);
            optionElement.OnOptionElementDeleted += HandleOptionElementDeleted;
            optionsContainer.Add(element);
        }

        #endregion
    
        #region Conditions Processing

        /// <summary>
        /// Processes and displays objective conditions in the UI.
        /// </summary>
        private void ProcessConditions()
        {
            conditionsContainer.Clear();
        
            conditionsContainer.Add(new Label()
            {
                text = CONDITIONS_LABEL,
                style =
                {
                    unityFontStyleAndWeight = FontStyle.Bold,
                    marginLeft = 5,
                    marginTop = 5,
                    marginRight = 5,
                },
            });
        
            if (conditionsProp == null || conditionsProp.arraySize < 1)
            {
                UpdateConditionsVisibility();
                return;
            }

            for (int i = 0; i < conditionsProp.arraySize; i++)
            {
                AddNewConditionElement(i);
            }
        }

        #endregion
    
        #region Conditions
    
        /// <summary>
        /// Handles the event when the visibility state of conditions is changed.
        /// </summary>
        private void HandleConditionsVisibilityStateChanged()
        {
            UpdateConditionsVisibility();
        }

        private void UpdateConditionsVisibility()
        {
            if (conditionsContainer == null || conditionsProp == null)
            {
                return;
            }
            
            conditionsContainer.style.display = conditionsProp.arraySize > 0 && ObjectiveSystemEditorWindow.ConditionsVisibleOnNodes 
                ? DisplayStyle.Flex : DisplayStyle.None;
        }
    
        private void AddNewConditionElement(int index)
        {
            TemplateContainer element = EditorGlobalSettings.OptionElementXml.Instantiate();
            OptionElement optionElement = element.Q<OptionElement>();
            optionElement.InitializeOptionElement(conditionsProp, index);
            optionElement.OnOptionElementDeleted += HandleConditionElementDeleted;
            conditionsContainer.Add(element);
            UpdateConditionsVisibility();
        }
    
        #endregion
    
        #region Event Handlers

        /// <summary>
        /// Handles the addition of a new option through the context menu.
        /// </summary>
        /// <param name="optionType">The type of the option to add.</param>
        private void HandleNewOptionAddClicked(Type optionType)
        {
            BaseObjective.EDITOR_AddOption(optionType);
            optionsProp.serializedObject.ApplyModifiedProperties();
            optionsProp.serializedObject.Update();
            serializer.data.EDITOR_SetDirtyAndSave();
            AddNewOptionElement(BaseObjective.ObjectiveOptions.Count - 1);
            UpdateOptionsVisibility();
        }
    
        /// <summary>
        /// Handles the deletion of an option element from the UI.
        /// </summary>
        /// <param name="optionElement">The option element that was deleted.</param>
        /// <param name="index">The index of the deleted option.</param>
        private void HandleOptionElementDeleted(OptionElement optionElement, int index)
        {
            if (optionsProp != null && index >= 0 && index < optionsProp.arraySize)
            {
                optionsProp.DeleteArrayElementAtIndex(index);
                optionsProp.serializedObject.ApplyModifiedProperties();
                optionsProp.serializedObject.Update();
                serializer.data.EDITOR_SetDirtyAndSave();
                optionsContainer.Remove(optionElement.parent);
                optionElement.OnOptionElementDeleted -= HandleOptionElementDeleted;
            }

            UpdateOptionsVisibility();
        }

        /// <summary>
        /// Handles the addition of a new condition through the context menu.
        /// </summary>
        /// <param name="conditionType">The type of the condition to add.</param>
        private void HandleNewConditionAddClicked(Type conditionType)
        {
            BaseObjective.EDITOR_AddCondition(conditionType);
            serializer.data.EDITOR_SetDirtyAndSave();
        }
    
        /// <summary>
        /// Handles the deletion of a condition element from the UI.
        /// </summary>
        /// <param name="optionElement">The condition element that was deleted.</param>
        /// <param name="index">The index of the deleted condition.</param>
        private void HandleConditionElementDeleted(OptionElement optionElement, int index)
        {
            if (conditionsProp == null) return;
        
            BaseObjective.EDITOR_RemoveCondition(index);
            serializer.data.EDITOR_SetDirtyAndSave();
        }
    
        /// <summary>
        /// Handles changes to the objective conditions, updating the UI accordingly.
        /// </summary>
        /// <param name="obj">The objective that has changed.</param>
        private void HandleObjectiveConditionsChanged(BaseObjective obj)
        {
            conditionsProp.serializedObject.ApplyModifiedProperties();
            conditionsProp.serializedObject.Update();
            ProcessConditions();
        }

        #endregion
    
        #region Helper Methods

        /// <summary>
        /// Adds menu items for adding options to the objective.
        /// </summary>
        /// <param name="evt">The contextual menu populate event.</param>
        private void AddOptionMenuItems(ContextualMenuPopulateEvent evt)
        {
            // Get a list of all ObjectiveCondition types
            IEnumerable<Type> optionsTypes = AppDomain.CurrentDomain.GetAssemblies()
                .SelectMany(assembly => assembly.GetTypes())
                .Where(type => type.IsSubclassOf(typeof(ObjectiveOption)) && !type.IsAbstract);

            foreach (Type type in optionsTypes)
            {
                evt.menu.AppendAction(string.Format(MENU_ACTION_ADD_OPTION, 
                    type.Name.Replace("ObjectiveOption", "")
                        .Replace("Option", "").SeparateWords()),
                    _ => HandleNewOptionAddClicked(type));
            }
        
            evt.menu.AppendSeparator();
        }

        /// <summary>
        /// Adds menu items for adding conditions to the objective.
        /// </summary>
        /// <param name="evt">The contextual menu populate event.</param>
        private void AddConditionMenuItems(ContextualMenuPopulateEvent evt)
        {
            // Get a list of all ObjectiveCondition types
            IEnumerable<Type> conditionTypes = AppDomain.CurrentDomain.GetAssemblies()
                .SelectMany(assembly => assembly.GetTypes())
                .Where(type => type.IsSubclassOf(typeof(ObjectiveCondition)) && !type.IsAbstract);

            foreach (Type type in conditionTypes)
            {
                evt.menu.AppendAction(string.Format(MENU_ACTION_ADD_CONDITION, 
                    type.Name.Replace("Condition", "").SeparateWords()), _ => HandleNewConditionAddClicked(type));
            }
        
            evt.menu.AppendSeparator();
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/BaseObjectiveNode.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/DocumentationView.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b14210166c9b45b292f9b835c2a8af5f
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using BrewedInk.MarkdownSupport;
using Ldx.Framework.Systems.NodeGraph;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Helpers;
using Systems.Settings;
using UnityEditor;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.Objectives.NodeGraph
{
    [UxmlElement]
    public partial class DocumentationView : VisualElement, IDisposable
    {
        private ScrollView scrollView;
        private Label documentationText;
        private SplitView splitView;
        private Button openButton;
        private Button editButton;
        private Button saveButton;
        private Button cancelButton;
        private TextField documentationTextarea;
        private UMarkdownContext markdownContext;
        private VisualElement documentationSide;
        private VisualElement editModeBtnContainer;
        private string mainDocumentation;
        private bool isInEditMode;
        private ObjectiveEventNode currentNode;
        
        /// <summary>
        /// Initializes the view by querying its components and setting up event handlers.
        /// </summary>
        public void InitializeView(SplitView view, Button documentationButton)
        {
            splitView = view;
            documentationSide = view.Q<VisualElement>("documentation-side");
            scrollView = this.Q<ScrollView>("documentation-scroll");
            editButton = view.Q<Button>("edit-documentation-button");
            cancelButton = view.Q<Button>("cancel-documentation-button");
            saveButton = view.Q<Button>("save-documentation-button");
            editModeBtnContainer = view.Q<VisualElement>("edit-mode-button-container");
            documentationTextarea = view.Q<TextField>("documentation-textarea"); 
            
            documentationTextarea.style.display = DisplayStyle.None;
            
            openButton = documentationButton;
            
            ObjectiveEventNode.OnAnyObjectiveEventNodeSelected += HandleObjectiveEventNodeSelected;
            ObjectiveEventNode.OnAnyObjectiveEventNodeUnselected += HandleObjectiveEventNodeUnselected;

            markdownContext = UMarkdownContext.FromFile(EditorGlobalSettings.MarkdownConfigDataPath, false, UMarkdownConfigData.LoadProjectConfig());
            mainDocumentation = DocumentationHelper.GetMainDocumentation();
            //ShowDocumentation(mainDocumentation);

            style.display = DisplayStyle.None;
            
            documentationTextarea.verticalScrollerVisibility = ScrollerVisibility.AlwaysVisible;
           
            HideView();

            openButton.clicked += HandleOpenButtonClicked;
            editButton.clicked += HandleEditButtonClicked;
            saveButton.clicked += HandleSaveButtonClicked;
            cancelButton.clicked += HandleCancelButtonClicked;
        }
        
        private void ShowView()
        {
            documentationSide.style.display = DisplayStyle.Flex;
            SetEditMode(false, force: true);
        }

        private void HideView()
        {
            isInEditMode = false;

            documentationSide.style.display = DisplayStyle.None;
            documentationTextarea.value = "";
            scrollView.Clear();
            
            documentationTextarea.style.display = DisplayStyle.None;
            style.display = DisplayStyle.None;
            editButton.style.display = DisplayStyle.None;
            documentationTextarea.style.display = DisplayStyle.None;
            editModeBtnContainer.style.display = DisplayStyle.None;
        }

        public void Dispose()
        {
            if (editButton != null)
            {
                editButton.clicked -= HandleEditButtonClicked;
            }

            if (saveButton != null)
            {
                saveButton.clicked -= HandleSaveButtonClicked;
            }

            if (cancelButton != null)
            {
                cancelButton.clicked -= HandleCancelButtonClicked;
            }
            ObjectiveEventNode.OnAnyObjectiveEventNodeSelected -= HandleObjectiveEventNodeSelected;
            ObjectiveEventNode.OnAnyObjectiveEventNodeUnselected -= HandleObjectiveEventNodeUnselected;
        }

        private void HandleObjectiveEventNodeSelected(ObjectiveEventNode eventNode)
        {
            ShowView();
            currentNode = eventNode;
            currentNode.RetrieveDocumentation(eventNode.data);
            SetEditMode(false);
            style.display = DisplayStyle.Flex;
            ShowDocumentation(eventNode.DocumentationText);
        }
        
        private void HandleObjectiveEventNodeUnselected(ObjectiveEventNode node)
        {
            if (currentNode != node)
            {
                return;
            }
            HideView();
            currentNode = null;
        }
        
        private void HandleEditButtonClicked()
        {
            SetEditMode(true);
            string content = String.IsNullOrEmpty(currentNode.DocumentationText) ? "" : currentNode.DocumentationText;
            documentationTextarea.value = content;  
        }
        
        private void HandleSaveButtonClicked()
        {
            string path = DocumentationHelper.GetClassDocumentationPath(currentNode.data);
            
            if (!DocumentationHelper.WriteDocumentation(path, documentationTextarea.value, out string error))
            {
                EditorUtility.DisplayDialog("Error", error, "Ok");
                return;
            }
            currentNode.RetrieveDocumentation(currentNode.data);
            ShowDocumentation(currentNode.DocumentationText);
            SetEditMode(false);
            documentationTextarea.value = "";
        }

        private void HandleCancelButtonClicked()
        {
            SetEditMode(false);
            documentationTextarea.value = "";
        }

        private void SetEditMode(bool enabled, bool force = false)
        {
            if (isInEditMode == enabled && !force)
            {
                return;
            }
            
            isInEditMode = enabled;
            
            if (isInEditMode)
            {
                style.display = DisplayStyle.None;
                editButton.style.display = DisplayStyle.None;
                documentationTextarea.style.display = DisplayStyle.Flex;
                editModeBtnContainer.style.display = DisplayStyle.Flex;
            }
            else
            {
                style.display = DisplayStyle.Flex;
                editButton.style.display = DisplayStyle.Flex;
                
                documentationTextarea.style.display = DisplayStyle.None;
                editModeBtnContainer.style.display = DisplayStyle.None;
            }
        }

        private void ShowDocumentation(string loadedMarkdown)
        {
            scrollView.Clear();

            string className = currentNode.data.GetType().Name;
            string displayName = $"{className.Replace("EventData", "").SeparateWords()} (Block)";
            string headingInfo = $"# {displayName}\nClass: `{className}`\n\n";
            
            if (loadedMarkdown == null || String.IsNullOrEmpty(loadedMarkdown.Trim()))
            {
                string noMarkdownMessage = $"{headingInfo}*No description provided. Click edit to create one.*";
                displayMarkdown(noMarkdownMessage);
                return;
            }
            
            displayMarkdown($"{headingInfo}{loadedMarkdown}");

            void displayMarkdown(string markdown)
            {
                MarkdownVisualElement markdownElement = UMarkdown.Parse(
                    markdown, 
                    markdownContext);
            
                scrollView.Add(markdownElement);
            }
        }
        
        private void HandleOpenButtonClicked()
        {
            splitView.UnCollapse();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/DocumentationView.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/IDCreationPopup.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 58efebc6ba954589a7288ed669b6bc23
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.NodeGraph;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEngine;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.Objectives.NodeGraph
{
    /// <summary>
    /// A popup window for creating new IDs in the LDX framework
    /// </summary>
    public class IDCreationPopup : EditorWindow
    {
        private const float WINDOW_MIN_WIDTH = 300;
        private const float WINDOW_MIN_HEIGHT = 100;
        private const string POPUP_TITLE = "Create new {0} ID";
        private const string NEW_ELEMENT_NAME_LABEL = "New element name:";
        private const string CREATE_BUTTON_TEXT = "Create";
        private const string CANCEL_BUTTON_TEXT = "Cancel";
        private const string VALIDATION_DIALOG_TITLE = "Validation";
        private const string EVENT_NAME_REQUIRED_MESSAGE = "Please enter a name for the event.";
        private const string OK_TEXT = "Ok";
        private const string SIMILAR_NAME_EXISTS_MESSAGE = "Similar name exists, please reconsider. \n";
        private const string KNOW_WHAT_IM_DOING_BUTTON = "I know what I'm doing";
        private const string CANCEL_BUTTON = "Cancel";
        private const string GLOBAL_NAME = "Global";
        private const string SIMILAR_ELEMENT_TEXT = "{0} -> {1}";
    
        private static IDCreationPopup currentPopup;
        private static LdxIdSettings ldxIdSettings;
        private static LdxIdSettings.IdType idType;
        private static PortView portView;
        private static Vector2 nodePos;
        private static Action<LdxIdSettings, LdxIdSettings.IdType, PortView, string, Vector2> creationCallback;

        private TextField eventNameTextField;
        private Button createButton;
        private Button cancelButton;
    
        /// <summary>
        /// Opens the ID creation popup window, setting its initial properties and ensuring it gains focus if already open.
        /// </summary>
        /// <param name="typeResult">The instance type result to determine the settings context.</param>
        /// <param name="type">The type of ID to create.</param>
        /// <param name="from">The source port view initiating the creation.</param>
        /// <param name="pos">The position for the new node.</param>
        /// <param name="callback">The callback to execute upon creation.</param>
        public static void OpenPopup(LdxIdSettings.InstanceTypeResult typeResult, LdxIdSettings.IdType type, PortView from,
            Vector2 pos, Action<LdxIdSettings, LdxIdSettings.IdType, PortView, string, Vector2> callback)
        {
            if (currentPopup != null)
            {
                currentPopup.Focus();
            }
            else
            {
                currentPopup = CreateInstance<IDCreationPopup>();

                portView = from;
                creationCallback = callback;
                nodePos = pos;

                currentPopup.titleContent = new GUIContent(string.Format(POPUP_TITLE, typeResult.ToString().SeparateWords()));
                currentPopup.minSize = new Vector2(WINDOW_MIN_WIDTH, WINDOW_MIN_HEIGHT);
                currentPopup.maxSize = new Vector2(WINDOW_MIN_WIDTH, WINDOW_MIN_HEIGHT);

                idType = type;
                switch (typeResult)
                {
                    case LdxIdSettings.InstanceTypeResult.Global:
                        ldxIdSettings = LdxIdSettings.GlobalInstance;
                        break;
                    default:
                        ldxIdSettings = LdxIdSettings.GetScenarioIDSettings();
                        break;
                }
                currentPopup.ShowUtility();
                EditorApplication.update += KeepWindowOnTop;
            }
        }

        private void OnDestroy()
        {
            EditorApplication.update -= KeepWindowOnTop;
            currentPopup = null;
        }

        /// <summary>
        /// Initializes the UI elements of the popup window on enable.
        /// </summary>
        private void OnEnable()
        {
            EnumField idTypeField = new(nameof(idType).SeparateWords(), idType);
            idTypeField.Init(idType);
            idTypeField.RegisterValueChangedCallback(evt => idType = (LdxIdSettings.IdType)evt.newValue);
            rootVisualElement.Add(idTypeField);

            eventNameTextField = new TextField(NEW_ELEMENT_NAME_LABEL);
            rootVisualElement.Add(eventNameTextField);

            VisualElement buttonContainer = new()
            {
                style =
                {
                    flexDirection = FlexDirection.Row,
                    justifyContent = Justify.SpaceBetween
                }
            };
            rootVisualElement.Add(buttonContainer);

            createButton = new Button(CreateEvent)
            {
                text = CREATE_BUTTON_TEXT,
                style = { flexGrow = 1 }
            };
            buttonContainer.Add(createButton);

            cancelButton = new Button(Close)
            {
                text = CANCEL_BUTTON_TEXT,
                style = { flexGrow = 1 }
            };
            buttonContainer.Add(cancelButton);
        }
    
        /// <summary>
        /// Ensures the popup window remains focused during updates. (But it doesn't really work)
        /// </summary>
        private static void KeepWindowOnTop()
        {
            if (currentPopup != null && !currentPopup.hasFocus)
            {
                currentPopup.Focus(); // Bring the window to the front if it loses focus
            }
        }

        #region Event Creation
    
        /// <summary>
        /// Handles the creation of a new event, validating input and invoking the creation callback.
        /// </summary>
        private void CreateEvent()
        {
            string eventName = eventNameTextField.value;

            if (string.IsNullOrEmpty(eventName))
            {
                EditorUtility.DisplayDialog(VALIDATION_DIALOG_TITLE, EVENT_NAME_REQUIRED_MESSAGE, OK_TEXT);
                return;
            }

            if (IsSimilarNameExists(eventName, out List<string> similarList))
            {
                string warningMsg = similarList.Aggregate(SIMILAR_NAME_EXISTS_MESSAGE, (current, similar) => current + ("\n" + similar));

                if (!EditorUtility.DisplayDialog(VALIDATION_DIALOG_TITLE, warningMsg, KNOW_WHAT_IM_DOING_BUTTON, CANCEL_BUTTON))
                {
                    return;
                }
            }

            IDInfo newInfo = new(StringUtilities.GenerateUniqueId(), eventName);
            ldxIdSettings.EDITOR_AddIdInfo(newInfo, idType);
            creationCallback?.Invoke(ldxIdSettings, idType, portView, eventName, nodePos);
            Close();
        }
    
        /// <summary>
        /// Checks for existing IDs with similar names to avoid duplicates.
        /// </summary>
        /// <param name="newName">The new name to check for similarity.</param>
        /// <param name="similarList">Out parameter containing a list of similar names found.</param>
        /// <returns>True if similar names exist; otherwise, false.</returns>
        private bool IsSimilarNameExists(string newName, out List<string> similarList)
        {
            List<LdxIdSettings> allIdSettings = LdxIdSettings.GetAllIDSettings();
            similarList = new List<string>();

            foreach (LdxIdSettings setting in allIdSettings)
            {
                IDInfoContainer idInfoContainer = LdxIdSettings.GetIDListForSettings(setting, idType);

                foreach (IDInfo info in idInfoContainer)
                {
                    if (StringUtilities.IsSimilarName(newName, info.Description))
                    {
                        string path = setting.IsGlobal ? GLOBAL_NAME : 
                            string.IsNullOrEmpty(setting.AssociatedScenarioID) ? 
                                setting.name : GlobalData.Instance.GetScenarioData(setting.AssociatedScenarioID).ScenarioNameLocalized;
                        similarList.Add(string.Format(SIMILAR_ELEMENT_TEXT, path, info.Description));
                    }
                }
            }

            return similarList.Count > 0;
        }
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/IDCreationPopup.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/InspectorView.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 871a0ba460614624a8d2b8fa3f8dc45a
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using Systems.Settings;
using UnityEditor;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.Objectives.NodeGraph
{
    /// <summary>
    /// InspectorView is a custom VisualElement that serves as the inspector within a Objective Data node-based graph editor.
    /// It dynamically displays and binds serialized properties of the selected objective node.
    /// This class handles the visualization of node properties, including conditions, and provides functionality to add, remove,
    /// and edit these properties through a user interface.
    /// </summary>
    [UxmlElement]
    public partial class InspectorView : VisualElement
    {
        #region Constants

        private const string FIELDS_CONTAINER_NAME = "fields-container";
        private const string CONDITIONS_CONTAINER_NAME = "conditions-container";
        private const string CONDITION_LIST_NAME = "condition-list";
        private const string ADD_CONDITION_BUTTON_NAME = "add-condition-button";

        #endregion

        #region Fields

        private SerializedObjectiveData serializer;
        private ObjectiveNode objectiveNode;
        private VisualElement fieldsContainer;
        private VisualElement conditionsContainer;
        private VisualElement conditionList;
        private Button addConditionButton;
        private SerializedProperty conditionProp;

        #endregion

        #region Initialization

        /// <summary>
        /// Initializes the view by querying its components and setting up event handlers.
        /// </summary>
        public void InitializeView()
        {
            fieldsContainer = this.Q<VisualElement>(FIELDS_CONTAINER_NAME);
            conditionsContainer = this.Q<VisualElement>(CONDITIONS_CONTAINER_NAME);
            conditionsContainer.style.display = DisplayStyle.None;
            
            conditionList = this.Q<VisualElement>(CONDITION_LIST_NAME);
            
            addConditionButton = this.Q<Button>(ADD_CONDITION_BUTTON_NAME);
            addConditionButton.clicked += ShowAddConditionMenu;
            
            ObjectiveConditionElement.OnAnyObjectiveConditionDeleted += HandleAnyObjectiveConditionDeleted;
        }

        #endregion

        #region Update Selection

        /// <summary>
        /// Updates the inspector view based on the current selection in the editor.
        /// </summary>
        /// <param name="serializer">The serializer for the objective data.</param>
        /// <param name="objectiveNode">The selected objective node.</param>
        internal void UpdateSelection(SerializedObjectiveData serializer, ObjectiveNode objectiveNode)
        {
            if (objectiveNode == null)
            {
                ClearInspectorView();
                return;
            }

            if (this.objectiveNode != null)
            {
                this.objectiveNode.BaseObjective.OnObjectiveConditionsChanged -= HandleObjectiveConditionsChanged;
            }

            SerializedProperty objectiveProperty = serializer.FindObjective(serializer.Objectives, objectiveNode.BaseObjective);
            if (objectiveProperty == null)
            {
                ClearInspectorView();
                return;
            }

            this.serializer = serializer;
            this.objectiveNode = objectiveNode;
            this.objectiveNode.BaseObjective.OnObjectiveConditionsChanged += HandleObjectiveConditionsChanged;
        
            conditionsContainer.style.display = DisplayStyle.Flex;
            objectiveProperty.isExpanded = true;

            ClearInspectorView();
            ProcessObjectiveProperties(objectiveProperty);
        }
    
        /// <summary>
        /// Processes and creates fields for each property of the objective based on reflection.
        /// </summary>
        /// <param name="objectiveProperty">The serialized property of the objective.</param>
        private void ProcessObjectiveProperties(SerializedProperty objectiveProperty)
        {
            IEnumerable<FieldInfo> fields = typeof(BaseObjective).GetFields(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance)
                .Where(f => f.GetCustomAttributes(typeof(ObjectiveInspectorAttribute), false).Length > 0);

            foreach (FieldInfo field in fields)
            {
                SerializedProperty prop = objectiveProperty.FindPropertyRelative(field.Name);
                if (prop != null)
                {
                    if (field.Name.Equals(nameof(BaseObjective.Conditions), StringComparison.OrdinalIgnoreCase))
                    {
                        conditionProp = prop;
                        ProcessConditions();
                        continue;
                    }
                
                    AddPropertyField(prop);
                }
            }
        }
    
        /// <summary>
        /// Adds a property field to the inspector view for a given serialized property.
        /// </summary>
        /// <param name="property">The serialized property to create a field for.</param>
        private void AddPropertyField(SerializedProperty property)
        {
            PropertyField field = new(property);
            field.BindProperty(property);
            fieldsContainer.Add(field);
        }
    
        /// <summary>
        /// Processes and displays conditions within the inspector view.
        /// </summary>
        private void ProcessConditions()
        {
            conditionList.Clear();
            for (int i = 0; i < conditionProp.arraySize; i++)
            {
                AddNewConditionElement(i);
            }
        }

        #endregion
    
        #region Condition Handlers
    
        /// <summary>
        /// Adds a new condition element to the inspector view for a specific index.
        /// </summary>
        /// <param name="index">The index of the condition in the serialized property array.</param>
        private void AddNewConditionElement(int index)
        {
            TemplateContainer element = EditorGlobalSettings.ObjectiveConditionXml.Instantiate();
            ObjectiveConditionElement conditionElement = element.Q<ObjectiveConditionElement>();
            conditionElement.InitializeConditionElement(conditionProp, index);
            conditionList.Add(element);
        }

        /// <summary>
        /// Shows a menu for adding a new condition to the objective.
        /// </summary>
        private void ShowAddConditionMenu()
        {
            GenericMenu menu = new();

            IEnumerable<Type> conditionTypes = AppDomain.CurrentDomain.GetAssemblies()
                .SelectMany(assembly => assembly.GetTypes())
                .Where(type => type.IsSubclassOf(typeof(ObjectiveCondition)) && !type.IsAbstract);

            foreach (Type type in conditionTypes)
            {
                menu.AddItem(new GUIContent(type.Name.Replace("Condition", "").SeparateWords()), false, () => HandleNewConditionAddClicked(type));
            }

            menu.ShowAsContext();
        }

        /// <summary>
        /// Handles the event when a new condition is added via the add condition menu.
        /// </summary>
        /// <param name="conditionType">The type of the condition to add.</param>
        private void HandleNewConditionAddClicked(Type conditionType)
        {
            if (objectiveNode != null)
            {
                objectiveNode.BaseObjective.EDITOR_AddCondition(conditionType);
                serializer.data.EDITOR_SetDirtyAndSave();
            }
        }
    
        /// <summary>
        /// Handles the event when any objective condition is deleted.
        /// </summary>
        /// <param name="conditionElement">The condition element that was deleted.</param>
        /// <param name="index">The index of the deleted condition.</param>
        private void HandleAnyObjectiveConditionDeleted(ObjectiveConditionElement conditionElement, int index)
        {
            if (objectiveNode != null)
            {
                objectiveNode.BaseObjective.EDITOR_RemoveCondition(index);
                serializer.data.EDITOR_SetDirtyAndSave();
            }
        }
    
        /// <summary>
        /// Handles changes to the objective conditions, updating the inspector view accordingly.
        /// </summary>
        /// <param name="obj">The objective that has changed.</param>
        private void HandleObjectiveConditionsChanged(BaseObjective obj)
        {
            ProcessConditions();
        }
    
        #endregion

        #region Reset

        /// <summary>
        /// Clears the inspector view, removing all property fields and condition elements.
        /// </summary>
        private void ClearInspectorView()
        {
            fieldsContainer.Clear();
            conditionList.Clear();
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/InspectorView.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveConditionElement.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e46afa4214c64b898cdf8d4e8f8dbc30
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEditor.UIElements;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.Objectives.NodeGraph
{
    /// <summary>
    /// Represents a UI element for managing objective conditions in the editor.
    /// </summary>
    [UxmlElement]
    public partial class ObjectiveConditionElement : VisualElement
    {
        #region Constants
    
        private const string EXPAND_BUTTON = "expand-button";
        private const string DELETE_BUTTON = "delete-button";
        private const string LABEL = "label";
        private const string EXPAND_CONTAINER = "expand-container";
        private const string EXPAND_BUTTON_TEXT_EXPANDED = "";
        private const string EXPAND_BUTTON_TEXT_HIDDEN = "";
    
        #endregion

        public static event Action<ObjectiveConditionElement, int> OnAnyObjectiveConditionDeleted;
    
        private Button expandButton;
        private Button deleteButton;
        private Label conditionLabel;
        private VisualElement expandContainer;
    
        private SerializedProperty conditionProperty;
        private bool isExpanded;
        private int arrayIndex;

        #region Initialization
    
        /// <summary>
        /// Initializes the condition element with a serialized property and index.
        /// </summary>
        /// <param name="prop">The serialized property representing the condition.</param>
        /// <param name="index">The index of the condition in the serialized property array.</param>
        public void InitializeConditionElement(SerializedProperty prop, int index)
        {
            expandButton = this.Q<Button>(EXPAND_BUTTON);
            if (expandButton != null)
            {
                expandButton.clicked += HandleExpandButtonToggle;
            }
        
            deleteButton = this.Q<Button>(DELETE_BUTTON);

            if (deleteButton != null)
            {
                deleteButton.clicked += HandleDeleteButtonClicked;
            }

            conditionLabel = this.Q<Label>(LABEL);
        
            expandContainer = this.Q<VisualElement>(EXPAND_CONTAINER);
        
            arrayIndex = index;
            conditionProperty = prop.GetArrayElementAtIndex(index);
            string typeName = conditionProperty.managedReferenceFullTypename;
            string[] splitName = typeName.Split('.');
            conditionLabel.text = splitName[^1].Replace("Condition", "").SeparateWords();

            // Initialize child fields for expandContainer here
            foreach (SerializedProperty child in conditionProperty)
            {
                PropertyField field = new PropertyField(child) { name = $"{child.name}" };
                field.BindProperty(child);
                expandContainer.Add(field);
            }

            SetExpanded(true);
        }
    
        #endregion

        #region Event Handlers

        /// <summary>
        /// Toggles the expansion state of the condition element.
        /// </summary>
        private void HandleExpandButtonToggle()
        {
            SetExpanded(!isExpanded);
        }

        /// <summary>
        /// Sets the expansion state of the condition element and updates the UI accordingly.
        /// </summary>
        /// <param name="setExpanded">Whether the element should be expanded.</param>
        private void SetExpanded(bool setExpanded)
        {
            isExpanded = setExpanded;
            expandContainer.style.display = isExpanded ? DisplayStyle.Flex : DisplayStyle.None;
            expandButton.text = isExpanded ? EXPAND_BUTTON_TEXT_EXPANDED : EXPAND_BUTTON_TEXT_HIDDEN;
        }
    
        /// <summary>
        /// Handles the deletion of a condition element.
        /// </summary>
        private void HandleDeleteButtonClicked()
        {
            OnAnyObjectiveConditionDeleted?.Invoke(this, arrayIndex);
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveConditionElement.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveDataSelectionWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b35906b01f2647168b7b5e042e8eb563
# ASMDEF: ldx.framework.editor.dll
# ---
using Ldx.Framework.Systems.ScenarioManagement.Data;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.NodeGraph
{
    /// <summary>
    /// A custom editor window for selecting ObjectiveData assets. It lists all ObjectiveData assets found within the project,
    /// allowing the user to select one to open in the ObjectiveSystemEditorWindow. If an ObjectiveData asset is selected,
    /// this window is closed and the editor window for the selected ObjectiveData is opened.
    /// </summary>
    public class ObjectiveDataSelectionWindow : EditorWindow
    {
        #region Constants

        private const string WINDOW_TITLE = "Select Objective Data";
        private const string SELECT_OBJECTIVE_LABEL = "Select an Objective Data Asset";
        private const string NO_OBJECTIVE_DATA_FOUND_LABEL = "No ObjectiveData assets found.";
        private const string UNKNOWN_DATA_LABEL = "Unnamed ObjectiveData";
        private const int WINDOW_SIZE_WIDTH = 200;
        private const int WINDOW_SIZE_HEIGHT = 150;

        #endregion
        
        #region Editor Window

        /// <summary>
        /// Displays the ObjectiveData selection window.
        /// </summary>
        public static void ShowWindow()
        {
            ObjectiveDataSelectionWindow window = GetWindow<ObjectiveDataSelectionWindow>(WINDOW_TITLE);
            window.minSize = new Vector2(WINDOW_SIZE_WIDTH, WINDOW_SIZE_HEIGHT);
        }

        #endregion

        #region Unity Lifecycle

        /// <summary>
        /// Renders the GUI for the ObjectiveData selection window.
        /// </summary>
        private void OnGUI()
        {
            GUILayout.Label(SELECT_OBJECTIVE_LABEL, EditorStyles.boldLabel);

            RenderObjectiveDataButtons();
        }

        #endregion

        #region GUI Helpers

        /// <summary>
        /// Renders buttons for each ObjectiveData asset found in the project, using the asset's name for the button label.
        /// </summary>
        private void RenderObjectiveDataButtons()
        {
            foreach (ScenarioData scenarioData in GlobalData.Instance.GetScenarioDataList())
            {
                string displayName = scenarioData != null ? scenarioData.EDITOR_GetDisplayObjectiveDataName() : UNKNOWN_DATA_LABEL;
            
                if (GUILayout.Button(displayName, GUI.skin.button))
                {
                    ObjectiveData objectiveData = scenarioData.EDITOR_GetObjectiveData();
                    if (objectiveData != null)
                    {
                        objectiveData.DisplayName = displayName;
                        EditorUtility.SetDirty(objectiveData);
                        ObjectiveSystemEditorWindow.OpenWindow(objectiveData, scenarioData);
                    }
                    Close();
                }
            }
        }
        
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveDataSelectionWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveDataView.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d6523f0c54e545e69c0553dbc98f0e9b
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Systems.NodeGraph;
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEngine;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.Objectives.NodeGraph
{
    /// <summary>
    /// ObjectiveDataView provides a visual representation and editing capabilities for ObjectiveData within a graph view.
    /// It supports creating, connecting, and organizing Objective and SubObjective nodes, offering a dynamic and interactive
    /// environment for structuring objective-driven content.
    /// </summary>
    [UxmlElement]
    public partial class ObjectiveDataView : BaseGraphView
    {
        #region Const

        private const string CREATE_NEW_CHILD_OBJECTIVE = "Create new child objective";
        private const string CHANGE_GROUP_TO_SEQUENCE = "Change group to/Sequence";
        private const string CHANGE_GROUP_TO_PARALLEL = "Change group to/Parallel";
        private const string CREATE_NEW_OBJECTIVE = "Create new Objective";
        private const string CHILDREN_GROUP_NAME_FORMAT = "Children {0}";
        private const string OBJECTIVE_TYPE_PROP_NAME = "objectiveType";

        #endregion

        #region Events

        /// <summary>
        /// Event triggered when an ObjectiveNode is selected.
        /// </summary>
        public Action<ObjectiveNode> OnNodeSelected;

        /// <summary>
        /// Event triggered for a deeper selection within an ObjectiveNode.
        /// </summary>
        public Action<ObjectiveNode> OnNodeDeepSelected;

        #endregion

        #region Fields

        private SerializedObjectiveData serializer; 
        private readonly HashSet<ObjectiveNode> populatedBaseObjectiveNodes = new();
        private readonly ContextualMenuAction[] childrenGroupActions;

        #endregion

        #region Properties

        /// <summary>
        /// Determines if the view can be refreshed when shown.
        /// </summary>
        protected override bool CanBeRefreshedOnShow => serializer != null;

        /// <summary>
        /// Determines if the view should reset when cleared.
        /// </summary>
        protected override bool ResetViewOnClear => false;

        #endregion

        #region Constructor

        /// <summary>
        /// Initializes a new instance of the ObjectiveDataView, setting up event subscriptions and contextual actions.
        /// </summary>
        public ObjectiveDataView()
        {
            ObjectiveNode.OnAnyObjectiveNodeSelected += HandleAnyObjectiveNodeSelected;
            ObjectiveNode.OnAnyObjectiveNodeDeleted += HandleAnyObjectiveNodeDeleted;
            ObjectiveNode.OnAnyObjectiveMoveRequested += HandleAnyObjectiveMoveRequested;
            ObjectiveNode.OnAnyObjectiveOverrideStartRequested += HandleAnyObjectiveOverrideStartRequested;
            GroupView.OnAnyGroupPropertyFieldChanged += HandleAnyGroupPropertyFieldChanged;
            ObjectiveSystemEditorWindow.OnOverrideStartObjectiveChanged += HandleOverrideStartObjectiveChanged;
        
            childrenGroupActions = new[]
            {
                new ContextualMenuAction(CREATE_NEW_CHILD_OBJECTIVE, HandleNewChildCreationInGroupRequested),
                new ContextualMenuAction(CHANGE_GROUP_TO_SEQUENCE, HandleGroupTypeChangedToSequence),
                new ContextualMenuAction(CHANGE_GROUP_TO_PARALLEL, HandleGroupTypeChangedToParallel)
            };
        }

        public override void Dispose()
        {
            base.Dispose();
            ObjectiveNode.OnAnyObjectiveNodeSelected -= HandleAnyObjectiveNodeSelected;
            ObjectiveNode.OnAnyObjectiveNodeDeleted -= HandleAnyObjectiveNodeDeleted;
            ObjectiveNode.OnAnyObjectiveMoveRequested -= HandleAnyObjectiveMoveRequested;
            ObjectiveNode.OnAnyObjectiveOverrideStartRequested -= HandleAnyObjectiveOverrideStartRequested;
            GroupView.OnAnyGroupPropertyFieldChanged -= HandleAnyGroupPropertyFieldChanged;
            ObjectiveSystemEditorWindow.OnOverrideStartObjectiveChanged -= HandleOverrideStartObjectiveChanged;
        }

        #endregion

        #region Context Menu

        /// <summary>
        /// Builds the context menu for the graph view.
        /// </summary>
        /// <param name="evt">Event data for the context menu.</param>
        protected override void BuildContextMenu(ContextualMenuPopulateEvent evt)
        {
            base.BuildContextMenu(evt);
        
            evt.menu.MenuItems().Clear();
            Vector2 mousePosition = Event.current.mousePosition;
            evt.menu.AppendAction(CREATE_NEW_OBJECTIVE, _ => HandleNewObjectiveCreateClicked(mousePosition));
            evt.StopImmediatePropagation();
        }

        #endregion
    
        #region View Population

        /// <summary>
        /// Repopulates the view based on the current serialized data.
        /// </summary>
        protected override void RepopulateView()
        {
            PopulateView(serializer);
        }

        /// <summary>
        /// Populates the view with Objective and SubObjective nodes based on the given SerializedObjectiveData.
        /// </summary>
        /// <param name="objectiveData">Serialized data to populate the view from.</param>
        public void PopulateView(SerializedObjectiveData objectiveData)
        {
            serializer = objectiveData;

            foreach (Objective objective in serializer.data.Objectives)
            {
                CreateObjectiveNodeView(objective);
                foreach (SubObjective child in objective.ChildObjectives)
                {
                    CreateObjectiveNodeView(child);
                }
            }

            ConnectNodesAndCreateGroups();
        }

        /// <summary>
        /// Connects nodes and creates groups based on the relationships defined in the serialized data.
        /// </summary>
        protected override void ConnectNodesAndCreateGroups()
        {
            base.ConnectNodesAndCreateGroups();
        
            BaseObjective nextObjective = null;
        
            for (int i = 0; i < serializer.data.Objectives.Count; i++)
            {
                Objective currentObjective = serializer.data.Objectives[i];
                ObjectiveNode currentNode = FindNodeView(currentObjective);
            
                if (currentObjective.ChildObjectives.Count > 0)
                { 
                    SerializedProperty parentProp = serializer.FindObjective(serializer.Objectives, currentObjective);
                    SerializedProperty typeProp = parentProp.FindPropertyRelative(OBJECTIVE_TYPE_PROP_NAME);
                    NodeGroup childGroup = new(string.Format(CHILDREN_GROUP_NAME_FORMAT, currentObjective.Name), currentObjective.ID, new []{typeProp}, childrenGroupActions);
                    ObjectiveNode childNode = null;
                
                    switch (currentObjective.ObjectiveType)
                    {
                        case ObjectiveType.ParallelGroup:
                            foreach (SubObjective child in currentObjective.ChildObjectives)
                            {
                                setupChildNode(child, currentNode, childGroup, true);
                            }
                            break;
                        case ObjectiveType.InSequenceGroup:
                            ObjectiveNode prevNode = currentNode;
                            for (int j = 0; j < currentObjective.ChildObjectives.Count; j++)
                            {
                                SubObjective child = currentObjective.ChildObjectives[j];
                                childNode = setupChildNode(child, prevNode, childGroup, j == 0);
                                prevNode = childNode;
                            }
                            break;
                        default:
                            throw new ArgumentOutOfRangeException();
                    }
                
                    CreateGroupView(childGroup);
                }

                nextObjective = i + 1 < serializer.data.Objectives.Count ? serializer.data.Objectives[i + 1] : null;

                if (nextObjective != null)
                {
                    AddEdge(currentNode, nextObjective);
                }
            }
        
            ObjectiveNode setupChildNode(SubObjective child, ObjectiveNode nodeToEdgeWith, NodeGroup childGroup, bool connectThroughChildren)
            {
                ObjectiveNode node = FindNodeView(child);
                childGroup.Add(child.ID);
                AddEdge(nodeToEdgeWith, node, connectThroughChildren);
                return node;
            }

            UpdateOverrideStartVisibility();
        }
    
        /// <summary>
        /// Adds an edge between the specified node and the next objective.
        /// </summary>
        /// <param name="node">The starting node of the edge.</param>
        /// <param name="nextObjective">The objective to connect to.</param>
        /// <param name="child">Indicates if the connection is for a child node. Defaults to false.</param>
        private void AddEdge(ObjectiveNode node, BaseObjective nextObjective, bool child = false)
        {
            ObjectiveNode nextNode = FindNodeView(nextObjective);
            AddEdge(node, nextNode, child);
        }
    
        /// <summary>
        /// Adds an edge between two objective nodes.
        /// </summary>
        /// <param name="node">The starting node of the edge.</param>
        /// <param name="nextNode">The node to connect to.</param>
        /// <param name="child">Indicates if the connection is for a child node. Defaults to false.</param>
        private void AddEdge(ObjectiveNode node, ObjectiveNode nextNode, bool child = false)
        {
            if (node.TryGetPort(Direction.Output, child ? 1 : 0, out Port port) 
                && nextNode.TryConnectToPort(Direction.Input, port, 0, out Edge edge))
            {
                AddElement(edge);
                graphEdges.Add(edge);
            }
        }

        /// <summary>
        /// Creates a view for an Objective or SubObjective node.
        /// </summary>
        /// <param name="objective">The objective to create a node view for.</param>
        /// <param name="pos">Optional position to place the node at. Defaults to Vector2.zero if not specified.</param>
        /// <returns>The created ObjectiveNode view.</returns>
        private ObjectiveNode CreateObjectiveNodeView(BaseObjective objective, Vector2? pos = null) 
        {
            if (objective == null)
            {
                return null;
            }
        
            ObjectiveNode objectiveNode = Activator.CreateInstance(typeof(ObjectiveNode)) as ObjectiveNode;
            objectiveNode.Initialize(this, serializer, objective);
            SetNodePosition(objectiveNode, pos ?? Vector2.zero);
            AddElement(objectiveNode);
        
            populatedBaseObjectiveNodes.Add(objectiveNode);
            return objectiveNode;
        }

        /// <summary>
        /// Handles changes to any property field within a group view, updating the serializer and reconnecting nodes as necessary.
        /// </summary>
        /// <param name="groupView">The group view that had a property field change.</param>
        private void HandleAnyGroupPropertyFieldChanged(GroupView groupView)
        {
            if (groupView.Contains(groupView))
            {
                serializer.UpdateSerializedObject();
                ConnectNodesAndCreateGroups();
            }
        }
    
        #endregion
    
        #region Node Management
    
        /// <summary>
        /// Finds a node view for a given BaseObjective.
        /// </summary>
        /// <param name="baseObjective">BaseObjective to find the node view for.</param>
        /// <returns>The corresponding ObjectiveNode view if found.</returns>
        private ObjectiveNode FindNodeView(BaseObjective baseObjective) 
        {
            return GetNodeByGuid(baseObjective.ID) as ObjectiveNode;
        }
    
        /// <summary>
        /// Handles the event when any objective node is selected. Triggers the OnNodeSelected action if the view is active.
        /// </summary>
        /// <param name="objectiveNode">The objective node that was selected.</param>
        private void HandleAnyObjectiveNodeSelected(ObjectiveNode objectiveNode)
        {
            if (!IsActive)
            {
                return;
            }
        
            SelectedNode = objectiveNode;
            OnNodeSelected?.Invoke(objectiveNode);
        }
    
        /// <summary>
        /// Performs a deeper selection of the currently selected node, if any, triggering the OnNodeDeepSelected action.
        /// </summary>
        public override void DeepSelectNode(BaseNode deepSelectNode)
        {
            base.DeepSelectNode(deepSelectNode);
        
            if (SelectedNode == null)
            {
                return;
            }
            
            OnNodeDeepSelected?.Invoke(SelectedNode as ObjectiveNode);
        }
    
        /// <summary>
        /// Handles the deletion of any objective node by invoking the DeleteNode method on the node.
        /// </summary>
        /// <param name="obj">The objective node to be deleted.</param>
        private void HandleAnyObjectiveNodeDeleted(ObjectiveNode obj)
        {
            DeleteNode(obj);
        }
        
        private void HandleAnyObjectiveMoveRequested(ObjectiveNode obj)
        {
            serializer.serializedObject.ApplyModifiedProperties();
            serializer.UpdateSerializedObject();
            ConnectNodesAndCreateGroups();
        }

        /// <summary>
        /// Deletes a specific objective node and its children if applicable, updates the serializer, and reconnects the nodes.
        /// </summary>
        /// <param name="obj">The objective node to be deleted.</param>
        private void DeleteNode(ObjectiveNode obj)
        {
            if (!obj.isSubObjective)
            {
                // Check for children and delete their elements and only then delete the parent one
                if(obj.BaseObjective is Objective currentObjective)
                {
                    foreach (SubObjective subObjective in currentObjective.ChildObjectives)
                    {
                        ObjectiveNode childNode = FindNodeView(subObjective);

                        if (SelectedNode == childNode)
                        {
                            HandleAnyObjectiveNodeSelected(null);
                        }

                        RemoveElement(childNode);
                    }
                }
            }
        
            if (SelectedNode == obj)
            {
                HandleAnyObjectiveNodeSelected(null);
            }
       
            serializer.data.EDITOR_DeleteObjective(obj.BaseObjective);
            serializer.serializedObject.ApplyModifiedProperties();
            serializer.UpdateSerializedObject();
            RemoveElement(obj);
            ConnectNodesAndCreateGroups();
        }

        #endregion

        #region Override start objective
        
        private void HandleOverrideStartObjectiveChanged()
        {
            UpdateOverrideStartVisibility();
        }

        private void HandleAnyObjectiveOverrideStartRequested(ObjectiveNode node, int index)
        {
            serializer.data.ObjectivesStepOverrideIndex = index;
            serializer.serializedObject.ApplyModifiedProperties();
            serializer.UpdateSerializedObject();
            serializer.data.EDITOR_SetDirtyAndSave();
            UpdateOverrideStartVisibility();
        }

        private void UpdateOverrideStartVisibility()
        {
            foreach (ObjectiveNode objectiveNode in populatedBaseObjectiveNodes)
            {
                objectiveNode.UpdateOverrideStartIconVisibility();
            }
        }

        #endregion

        #region Creation

        /// <summary>
        /// Handles the click event for creating a new objective node at the mouse position.
        /// </summary>
        /// <param name="mousePosition">The position of the mouse at the time of the click, used to position the new objective node.</param>
        private void HandleNewObjectiveCreateClicked(Vector2 mousePosition)
        {
            AddNewObjective(-1, mousePosition);
        }

        /// <summary>
        /// Dynamically creates a node based on the specified type. Supports creating Objective or SubObjective nodes.
        /// </summary>
        /// <param name="owner">The node that is initiating the creation, used for context.</param>
        /// <param name="from">The port from which the creation is being initiated.</param>
        /// <param name="nodeType">The type of node to create (Objective or SubObjective).</param>
        /// <param name="entryName">The name of the entry for the node, if applicable.</param>
        /// <param name="pos">The position at which to create the node.</param>
        /// <returns>A new BaseNode instance of the specified type, or null if creation was not possible.</returns>
        public override BaseNode CreateNodeWithParam(BaseNode owner, PortView from, BaseNode.NodeParam nodeParam, string entryName, Vector2 pos)
        {
            if (owner is not ObjectiveNode objectiveNode)
            {
                return null;
            }

            Type nodeType = nodeParam.Type;
            
            if (nodeType == typeof(Objective) && objectiveNode.BaseObjective is Objective objective)
            {
                int index = serializer.data.EDITOR_GetObjectiveIndex(objective);

                if (from.direction == Direction.Output)
                {
                    index += 1;
                }

                AddNewObjective(index, pos);
                return null;
            }

            if (nodeType == typeof(SubObjective))
            {
                int index = 0;

                Objective parentObjective = null;
                if (objectiveNode.BaseObjective is Objective objParent)
                {
                    parentObjective = objParent;
                }
                else if(objectiveNode.BaseObjective is SubObjective children)
                {
                    parentObjective = serializer.data.EDITOR_FindParentOfSubObjective(children, out index);
                
                    if (from.direction == Direction.Output)
                    {
                        index += 1;
                    }
                }

                AddNewSubObjective(parentObjective, index, pos);
                return null;
            }
        
            return null;
        }

        /// <summary>
        /// Adds a new objective to the graph at the specified index and position.
        /// </summary>
        /// <param name="index">The index at which the new objective should be added. A value of -1 indicates adding at the end.</param>
        /// <param name="pos">The position at which to place the new objective node.</param>
        private void AddNewObjective(int index, Vector2 pos)
        {
            Objective newObjective = serializer.data.EDITOR_CreateNewObjective(index);
            serializer.UpdateSerializedObject();
            HandleAnyObjectiveNodeSelected(CreateObjectiveNodeView(newObjective, pos));
            ConnectNodesAndCreateGroups();
        }
    
        /// <summary>
        /// Adds a new sub-objective to the specified parent objective at the given index and position.
        /// </summary>
        /// <param name="objParent">The parent Objective to which the new SubObjective will be added.</param>
        /// <param name="index">The index at which the new SubObjective should be added within the parent's children. A value of -1 indicates adding at the end.</param>
        /// <param name="pos">The position at which to place the new sub-objective node.</param>
        private void AddNewSubObjective(Objective objParent, int index, Vector2 pos)
        {
            SubObjective newObjective = serializer.data.EDITOR_CreateNewSubObjective(objParent, index);
            serializer.UpdateSerializedObject();
            HandleAnyObjectiveNodeSelected(CreateObjectiveNodeView(newObjective, pos));
            ConnectNodesAndCreateGroups();
        }
    
        /// <summary>
        /// Handles the request to create a new child objective within a specified group, triggered from a contextual menu action.
        /// </summary>
        /// <param name="groupView">The group view within which the new child objective is to be created.</param>
        /// <param name="mousePos">The position at which to place the new child objective node, typically the mouse position.</param>
        private void HandleNewChildCreationInGroupRequested(GroupView groupView, Vector2 mousePos)
        {
            ObjectiveNode ownerNode = groupView.owner.GetNodeByGuid(groupView.OwnerID) as ObjectiveNode;

            if (ownerNode?.BaseObjective is not Objective objective)
            {
                return;
            }
        
            AddNewSubObjective(objective, -1, mousePos);
        }

        #endregion

        #region Callbacks

        /// <summary>
        /// Overrides the default delete selection process to handle the deletion of ObjectiveNodes specifically.
        /// </summary>
        /// <param name="operationName">The name of the operation triggering the deletion.</param>
        /// <param name="askUser">Determines if the user should be asked for confirmation before deletion.</param>
        protected override void DeleteSelection(string operationName, AskUser askUser)
        {
            base.DeleteSelection(operationName, askUser);
            if (SelectedNode is not ObjectiveNode objectiveNode)
            {
                return;
            }
        
            DeleteNode(objectiveNode);
        }
    
        /// <summary>
        /// Handles the action to change the group type of objectives to a sequential arrangement.
        /// </summary>
        /// <param name="groupView">The group view whose child objectives' arrangement type is to be changed.</param>
        /// <param name="mousePos">The mouse position at the time the action was triggered, not used in this method.</param>
        private void HandleGroupTypeChangedToSequence(GroupView groupView, Vector2 mousePos)
        {
            ChangeChildrenType(groupView, ObjectiveType.InSequenceGroup);
        }
    
        /// <summary>
        /// Handles the action to change the group type of objectives to a parallel arrangement.
        /// </summary>
        /// <param name="groupView">The group view whose child objectives' arrangement type is to be changed.</param>
        /// <param name="mousePos">The mouse position at the time the action was triggered, not used in this method.</param>
        private void HandleGroupTypeChangedToParallel(GroupView groupView, Vector2 mousePos)
        {
            ChangeChildrenType(groupView, ObjectiveType.ParallelGroup);
        }

        /// <summary>
        /// Changes the type of child objectives within a specified group to either parallel or sequential.
        /// </summary>
        /// <param name="groupView">The group view containing the objectives whose types are to be changed.</param>
        /// <param name="type">The new arrangement type for the child objectives (parallel or sequential).</param>
        private void ChangeChildrenType(GroupView groupView, ObjectiveType type)
        {
            ObjectiveNode ownerNode = groupView.owner.GetNodeByGuid(groupView.OwnerID) as ObjectiveNode;

            if (ownerNode?.BaseObjective is not Objective objective)
            {
                return;
            }
        
            objective.ObjectiveType = type;
            serializer.UpdateSerializedObject();
            ConnectNodesAndCreateGroups();
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveDataView.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveEventMasterNode.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a6503cac46754fabafc767275e24cd14
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using Ldx.Framework.Systems.NodeGraph;
using UnityEditor.Experimental.GraphView;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.NodeGraph
{
    /// <summary>
    /// Master node class for an objective in the deep view graph handling objective events
    /// </summary>
    public class ObjectiveEventMasterNode : BaseObjectiveNode
    {
        #region Constants
    
        private const string TRACKING_EVENT_PATH = "Tracking event/{0}/{1}";
        private const string DIALOG_EVENT = "Dialog Completed/{0}/{1}";
        private const string INTERACTION_EVENT = "Interaction/{0}/{1}";
        private const string GLOBAL_EVENT = "Global";
        private const string SCENARIO_EVENT = "Scenario";
        private const string CREATE_TRIGGER_TITLE = "Create trigger";
        private const string NEW_GLOBAL_EVENT_TITLE = "New global event";
        private const string NEW_SCENARIO_EVENT_TITLE = "New scenario event";
        private const string NEW_GLOBAL_DIALOG_TITLE = "New global dialog";
        private const string NEW_SCENARIO_DIALOG_TITLE = "New scenario dialog";
    
        #endregion

        public override Rect SavedNodePosition => BaseObjective.masterNodePosition;
        public PortView OutputPort { get; private set; }
        public override bool IsDeletable => false;
        protected override bool IsDuplicatable => false;

        #region Initialization and Setup
    
        /// <summary>
        /// Initializes ports for the node and rebuilds the node descriptions map.
        /// </summary>
        protected override void InitializePorts()
        { 
            base.InitializePorts();
        
            OutputPort = CreateAndAddPort(Direction.Output, "", true);
            RebuildNodeDescriptionsMap();
        }

        /// <summary>
        /// Rebuilds the descriptions map for node events.
        /// </summary>
        private void RebuildNodeDescriptionsMap()
        {
            portNodeDescriptionsMap.Clear();
        
            NodeDescriptions outputNodeDescriptions = new(CREATE_TRIGGER_TITLE);
            PopulateTrackingEventsDescriptions(ref outputNodeDescriptions);
            PopulateDialogEventsDescriptions(ref outputNodeDescriptions);
            PopulateInteractionEventsDescriptions(ref outputNodeDescriptions);
        
            portNodeDescriptionsMap.Add(OutputPort, outputNodeDescriptions);
        }
    
        #endregion
    
        #region Event Population Methods
 
        /// <summary>
        /// Populates tracking events descriptions.
        /// </summary>
        /// <param name="nodeDescriptions">Reference to the node descriptions container.</param>
        private void PopulateTrackingEventsDescriptions(ref NodeDescriptions nodeDescriptions)
        {
            CompoundIDInfoContainer list = LdxIdSettings.GetCompoundIDList(LdxIdSettings.IdType.TrackingEvent);
            IDInfoContainer globalList = list.GlobalContainer;
            IDInfoContainer localList = list.LocalContainer;
        
            nodeDescriptions.nodePerMenuTitle.Add(ObjectiveEventData.TriggerEventType.Begin.ToString(), 
                new(typeof(BaseTriggerEventNode)));
            nodeDescriptions.nodePerMenuTitle.Add(ObjectiveEventData.TriggerEventType.Complete.ToString(), 
                new(typeof(BaseTriggerEventNode)));

            nodeDescriptions.nodePerMenuTitle.Add(string.Format(TRACKING_EVENT_PATH, GLOBAL_EVENT, NEW_GLOBAL_EVENT_TITLE), 
                new(typeof(TriggerTrackingEventNode)));

            if (globalList != null)
            {
                foreach (IDInfo idInfo in globalList)
                {
                    nodeDescriptions.nodePerMenuTitle.Add(string.Format(TRACKING_EVENT_PATH, GLOBAL_EVENT, idInfo.Description), 
                        new NodeParam(typeof(TriggerTrackingEventNode), idInfo.ID));
                }
            }
        
            nodeDescriptions.nodePerMenuTitle.Add(string.Format(TRACKING_EVENT_PATH, SCENARIO_EVENT, NEW_SCENARIO_EVENT_TITLE), 
                new(typeof(TriggerTrackingEventNode)));

            if (localList != null)
            {
                foreach (IDInfo idInfo in localList)
                {
                    nodeDescriptions.nodePerMenuTitle.Add(string.Format(TRACKING_EVENT_PATH, SCENARIO_EVENT, idInfo.Description), 
                        new NodeParam(typeof(TriggerTrackingEventNode), idInfo.ID));
                }
            }
        }
    
        /// <summary>
        /// Populates dialog events descriptions.
        /// </summary>
        /// <param name="nodeDescriptions">Reference to the node descriptions container.</param>
        private void PopulateDialogEventsDescriptions(ref NodeDescriptions nodeDescriptions)
        {
            CompoundIDInfoContainer list = LdxIdSettings.GetCompoundIDList(LdxIdSettings.IdType.Dialog);
            IDInfoContainer globalList = list.GlobalContainer;
            IDInfoContainer localList = list.LocalContainer;

            nodeDescriptions.nodePerMenuTitle.Add(string.Format(DIALOG_EVENT, GLOBAL_EVENT, NEW_GLOBAL_DIALOG_TITLE), 
                new NodeParam(typeof(TriggerDialogEventNode)));

            if (globalList != null)
            {
                foreach (IDInfo idInfo in globalList)
                {
                    nodeDescriptions.nodePerMenuTitle.Add(string.Format(DIALOG_EVENT, GLOBAL_EVENT, idInfo.Description),
                        new NodeParam(typeof(TriggerDialogEventNode), idInfo.ID));
                }
            }

            nodeDescriptions.nodePerMenuTitle.Add(string.Format(DIALOG_EVENT, SCENARIO_EVENT, NEW_SCENARIO_DIALOG_TITLE), 
                new(typeof(TriggerDialogEventNode)));
        
            if (localList != null)
            {
                foreach (IDInfo idInfo in localList)
                {
                    nodeDescriptions.nodePerMenuTitle.Add(string.Format(DIALOG_EVENT, SCENARIO_EVENT, idInfo.Description),
                        new NodeParam(typeof(TriggerDialogEventNode), idInfo.ID));
                }
            }
        }
        
        /// <summary>
        /// Populates interaction events descriptions.
        /// </summary>
        /// <param name="nodeDescriptions">Reference to the node descriptions container.</param>
        private void PopulateInteractionEventsDescriptions(ref NodeDescriptions nodeDescriptions)
        {
            CompoundIDInfoContainer list = LdxIdSettings.GetCompoundIDList(LdxIdSettings.IdType.Interactable);
            IDInfoContainer globalList = list.GlobalContainer;
            IDInfoContainer localList = list.LocalContainer;

            Array interactionTypes = Enum.GetValues(typeof(ObjectiveEventData.InteractionEventType));
            foreach (ObjectiveEventData.InteractionEventType interactionType in interactionTypes)
            {
                if (localList != null)
                {
                    foreach (IDInfo idInfo in localList)
                    {
                        string nodeTitle = string.Format(INTERACTION_EVENT, interactionType.ToString(), idInfo.Description);
                        if (nodeDescriptions.nodePerMenuTitle.ContainsKey(nodeTitle))
                        {
                            continue;
                        }
                        
                        nodeDescriptions.nodePerMenuTitle.Add(
                            nodeTitle,
                            new InteractionTriggerEventNode.InteractionNodeParam(typeof(InteractionTriggerEventNode),
                                idInfo.ID,
                                interactionType));
                    }
                }
                
                if (globalList != null)
                {
                        foreach (IDInfo idInfo in globalList)
                        {
                            string nodeTitle = string.Format(INTERACTION_EVENT, interactionType.ToString(), $"{idInfo.Description} (Global)");
                            if (nodeDescriptions.nodePerMenuTitle.ContainsKey(nodeTitle))
                            {
                                continue;
                            }
                            
                            nodeDescriptions.nodePerMenuTitle.Add(
                                nodeTitle,
                                new InteractionTriggerEventNode.InteractionNodeParam(
                                    typeof(InteractionTriggerEventNode),
                                    idInfo.ID,
                                    interactionType));
                        }
                }
            }
        }
        
        #endregion
    
        #region Node Management
    
        /// <summary>
        /// Sets the position of the node.
        /// </summary>
        /// <param name="newPos">The new position for the node.</param>
        public override void SetPosition(Rect newPos)
        {
            base.SetPosition(newPos);
            BaseObjective.masterNodePosition = newPos;
        }
    
        /// <summary>
        /// Deletes the node. Implementation is empty as the node isn't deletable.
        /// </summary>
        protected override void DeleteNode()
        {
            // Isn't deletable
        }

        /// <summary>
        /// Duplicates the node. Implementation is empty as the node isn't duplicatable.
        /// </summary>
        protected override void DuplicateNode()
        {
            // Isn't duplicatable
        }
    
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveEventMasterNode.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveEventNode.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 5f26b1ec95ec4acbbed2496828a1a0df
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Ldx.Framework.Systems.NodeGraph;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;
using Ldx.Framework.Utilities.Helpers;

namespace Ldx.Framework.Systems.Objectives.NodeGraph
{
    /// <summary>
    /// Represents a node within the objective graph that handles the visualization and editing of objective event data.
    /// This node allows for the connection to specific event types such as tracking events or dialog events, 
    /// and supports custom interactions through its context menu.
    /// </summary>
    public class ObjectiveEventNode : BaseNode
    {
        public static event Action<ObjectiveEventNode> OnAnyObjectiveEventNodeDeleteClicked;
        public static event Action<ObjectiveEventNode> OnAnyObjectiveEventNodeSelected;
        public static event Action<ObjectiveEventNode> OnAnyObjectiveEventNodeUnselected; 
        public static event Action<ObjectiveEventNode, TriggerEventInfo> OnAnyObjectiveEventConnectToSelected;

        private const string EVENT_DATA_TITLE_REPLACE = "EventData";
        private const string REROUTE_TO_ACTION_TITLE = "Reroute to/{0}";
        private const string REROUTE_TO_TRACKING_EVENT_ACTION_TITLE = "Reroute to/Tracking Event/{0}/{1}";
        private const string REROUTE_TO_INTERACTION_EVENT_ACTION_TITLE = "Reroute to/Interaction/{0}/{1}";
        private const string REROUTE_TO_DIALOG_ACTION_TITLE = "Reroute to/Dialog/{0}/{1}";
        private const string GLOBAL_EVENT = "Global";
        private const string SCENARIO_EVENT = "Scenario";

        public ObjectiveEventData data;
        public TriggerEventNode eventNode;
        private SerializedObjectiveData serializer;
        private BaseObjective baseObjective;
        private string documentationTextText;

        protected override bool IsDuplicatable => false;
        public override Rect SavedNodePosition => data.eventNodePosition;
        public string DocumentationText => documentationTextText;

        #region Initialization
    
        /// <summary>
        /// Initializes the node with the provided graph view, objective data, base objective, event data, and the event node.
        /// </summary>
        /// <param name="graphView">The graph view where the node will be displayed.</param>
        /// <param name="objectiveData">Serialized data of the objective.</param>
        /// <param name="baseObjective">The base objective associated with this event.</param>
        /// <param name="data">The event data for this node.</param>
        /// <param name="eventNode">The event node related to this objective.</param>
        public void Initialize(BaseGraphView graphView,
            SerializedObjectiveData objectiveData,
            BaseObjective baseObjective,
            ObjectiveEventData data,
            TriggerEventNode eventNode)
        {
            serializer = objectiveData;
            this.baseObjective = baseObjective;
            this.data = data;
            this.eventNode = eventNode;

            RetrieveDocumentation(data);
        
            Initialize(graphView, data.GetType().Name.Replace(EVENT_DATA_TITLE_REPLACE, "").SeparateWords(),
                data.GetHashCode().ToString());
        }

        public void RetrieveDocumentation(ObjectiveEventData eventData)
        {
            if (!DocumentationHelper.TryGetClassDocumentation(eventData.GetType(), out documentationTextText))
            {
                documentationTextText = null;
            }
        }

        /// <summary>
        /// Initializes the view for the node, creating UI elements for each property marked with the NodeExposedParameter attribute.
        /// </summary>
        protected override void InitializeView()
        {
            base.InitializeView();
        
            // Reflection is used to find all fields marked with the custom attribute for exposure in the node UI.
            IEnumerable<FieldInfo> fields = GetAllFields(data.GetType());

            SerializedProperty eventDataProperty = serializer.FindObjectiveEvent(serializer.Objectives, baseObjective, data);
        
            // Iterate over each field and draw them using SerializedProperty
            foreach (FieldInfo field in fields)
            {
                AddPropertyField(eventDataProperty, field);
            }
        }
    
        /// <summary>
        /// Adds a property field to the node's UI for the specified serialized property.
        /// </summary>
        /// <param name="eventDataProperty">The serialized property related to the event data.</param>
        /// <param name="fieldInfo">The field information for the property to add.</param>
        private void AddPropertyField(SerializedProperty eventDataProperty, FieldInfo fieldInfo)
        {
            SerializedProperty fieldProperty = eventDataProperty.FindPropertyRelative(fieldInfo.Name);

            if (fieldProperty == null)
            {
                return;
            }
        
            PropertyField field = new(fieldProperty);
        
            // Applies specific styling based on attributes applied to the property fields.
            IEnumerable<SerializableContainerAttribute> attribute = fieldInfo.GetCustomAttributes<SerializableContainerAttribute>();
            if (attribute.Any())
            {
                // Shitty way to set width, class doesn't work somehow. 
                field.style.width = 800;
                field.style.marginRight = 30;
            }
            else
            {
                // Shitty way to set width, class doesn't work somehow. 
                field.style.width = Mathf.Max(Width, 600);
            }
        
            field.BindProperty(fieldProperty);
            extensionContainer.Add(field);
        }

        /// <summary>
        /// Initializes ports for the node, adding an input port.
        /// </summary>
        protected override void InitializePorts()
        {
            base.InitializePorts();
            CreateAndAddPort(Direction.Input, isVertical: true);
        }

        /// <summary>
        /// Adds custom context menu items to the node, including options for connecting to tracking and dialog events.
        /// </summary>
        /// <param name="evt">The contextual menu populate event.</param>
        protected override void AddCustomContextMenuItems(ContextualMenuPopulateEvent evt)
        {
            base.AddCustomContextMenuItems(evt);
            AddTrackingEventMenuItems(evt);
            AddDialogEventMenuItems(evt);
            AddInteractionEventMenuItems(evt);
        }

        /// <summary>
        /// Adds tracking event options to the node's context menu.
        /// </summary>
        /// <param name="evt">The contextual menu populate event.</param>
        private void AddTrackingEventMenuItems(ContextualMenuPopulateEvent evt)
        {
            evt.menu.AppendAction(string.Format(REROUTE_TO_ACTION_TITLE, ObjectiveEventData.TriggerEventType.Begin.ToString()), 
                _ => HandleConnectToSelected(ObjectiveEventData.TriggerEventType.Begin));
            evt.menu.AppendAction(string.Format(REROUTE_TO_ACTION_TITLE, ObjectiveEventData.TriggerEventType.Complete.ToString()), 
                _ => HandleConnectToSelected(ObjectiveEventData.TriggerEventType.Complete));
        
            CompoundIDInfoContainer list = LdxIdSettings.GetCompoundIDList(LdxIdSettings.IdType.TrackingEvent);
            IDInfoContainer globalList = list.GlobalContainer;
            IDInfoContainer localList = list.LocalContainer;

            if (globalList != null)
            {
                foreach (IDInfo idInfo in globalList)
                {
                    evt.menu.AppendAction(
                        string.Format(REROUTE_TO_TRACKING_EVENT_ACTION_TITLE, GLOBAL_EVENT, idInfo.Description),
                        _ => HandleConnectToSelected(ObjectiveEventData.TriggerEventType.TrackingEvent, idInfo.ID));
                }
            }

            if (localList != null)
            {
                foreach (IDInfo idInfo in localList)
                {
                    evt.menu.AppendAction(
                        string.Format(REROUTE_TO_TRACKING_EVENT_ACTION_TITLE, SCENARIO_EVENT, idInfo.Description),
                        _ => HandleConnectToSelected(ObjectiveEventData.TriggerEventType.TrackingEvent, idInfo.ID));
                }
            }
        }

        /// <summary>
        /// Adds dialog event options to the node's context menu.
        /// </summary>
        /// <param name="evt">The contextual menu populate event.</param>
        private void AddDialogEventMenuItems(ContextualMenuPopulateEvent evt)
        {
            CompoundIDInfoContainer listDialog = LdxIdSettings.GetCompoundIDList(LdxIdSettings.IdType.Dialog);
            IDInfoContainer globalListDialog = listDialog.GlobalContainer;
            IDInfoContainer localListDialog = listDialog.LocalContainer;

            if (globalListDialog != null)
            {
                foreach (IDInfo idInfo in globalListDialog)
                {
                    evt.menu.AppendAction(string.Format(REROUTE_TO_DIALOG_ACTION_TITLE, GLOBAL_EVENT, idInfo.Description),
                        _ => HandleConnectToSelected(ObjectiveEventData.TriggerEventType.DialogCompleted,
                            dialogId: idInfo.ID));
                }
            }

            if (localListDialog != null)
            {
                foreach (IDInfo idInfo in localListDialog)
                {
                    evt.menu.AppendAction(string.Format(REROUTE_TO_DIALOG_ACTION_TITLE, SCENARIO_EVENT, idInfo.Description),
                        _ => HandleConnectToSelected(ObjectiveEventData.TriggerEventType.DialogCompleted,
                            dialogId: idInfo.ID));
                }
            }
        }

        /// <summary>
        /// Adds interaction event options to the node's context menu.
        /// </summary>
        /// <param name="evt">The contextual menu populate event.</param>
        private void AddInteractionEventMenuItems(ContextualMenuPopulateEvent evt)
        {
            CompoundIDInfoContainer list = LdxIdSettings.GetCompoundIDList(LdxIdSettings.IdType.Interactable);
            IDInfoContainer globalList = list.GlobalContainer;
            IDInfoContainer localList = list.LocalContainer;

            Array interactionTypes = Enum.GetValues(typeof(ObjectiveEventData.InteractionEventType));

            if (localList != null)
            {
                foreach (ObjectiveEventData.InteractionEventType interactionType in interactionTypes)
                {
                    foreach (IDInfo idInfo in localList)
                    {
                        evt.menu.AppendAction(
                            string.Format(REROUTE_TO_INTERACTION_EVENT_ACTION_TITLE, 
                                interactionType.ToString(), idInfo.Description),
                            _ => HandleConnectToSelected(ObjectiveEventData.TriggerEventType.Interaction,
                                interactionEventType: interactionType, interactableId: idInfo.ID));
                    }
                }
            }
            
            if (globalList != null)
            {
                foreach (ObjectiveEventData.InteractionEventType interactionType in interactionTypes)
                {
                    foreach (IDInfo idInfo in globalList)
                    {
                        evt.menu.AppendAction(
                            string.Format(REROUTE_TO_INTERACTION_EVENT_ACTION_TITLE,
                             interactionType.ToString(), $"{idInfo.Description} (Global)"),
                            _ => HandleConnectToSelected(ObjectiveEventData.TriggerEventType.Interaction,
                                interactionEventType: interactionType, interactableId: idInfo.ID));
                    }
                }
            }
        }

        public override void OnSelected()
        {
            base.OnSelected();
            OnAnyObjectiveEventNodeSelected?.Invoke(this);
        }

        public override void OnUnselected()
        {
            base.OnUnselected();
            OnAnyObjectiveEventNodeUnselected?.Invoke(this);
        }

        /// <summary>
        /// Adds "Generate localization strings" menu item to the node's context menu if the data is inherited from ILocalizationDataHolder.
        /// </summary>
        /// <param name="evt">The contextual menu populate event.</param>
        private void AddLocalizationMenuItems(ContextualMenuPopulateEvent evt)
        {
            /*// Assuming 'data' represents the object you want to check for ILocalizationDataHolder implementation.
            // Replace 'data' with the actual reference to your target object.
            if (data is ILocalizationDataHolder)
            {
                evt.menu.AppendSeparator();
                evt.menu.AppendAction(GENERATE_LOCALIZATION_ACTION_TITLE, _ => HandleGenerateLocalizationStringsSelected());
            }*/
        }

        #endregion
    
        #region Node Actions
    
        /// <summary>
        /// Handles connection requests to selected trigger events from the context menu.
        /// </summary>
        /// <param name="eventType">The type of the trigger event.</param>
        /// <param name="trackingEventId">Optional ID for tracking events.</param>
        /// <param name="dialogId">Optional ID for dialog events.</param>
        private void HandleConnectToSelected(ObjectiveEventData.TriggerEventType eventType,
            string trackingEventId = "",
            string dialogId = "",
            ObjectiveEventData.InteractionEventType interactionEventType = default,
            string interactableId = "")
        {
            OnAnyObjectiveEventConnectToSelected?.Invoke(this, new TriggerEventInfo(eventType, trackingEventId, dialogId, interactionEventType: interactionEventType, interactableId: interactableId));
        }
    
        /// <summary>
        /// Deletes the current objective node and triggers any associated cleanup or events.
        /// </summary>
        protected override void DeleteNode()
        {
            OnAnyObjectiveEventNodeDeleteClicked?.Invoke(this);
        }
    
        /// <summary>
        /// Duplicates the node. Implementation is empty as the node isn't duplicatable.
        /// </summary>
        protected override void DuplicateNode()
        {
            // Isn't duplicatable
        }
    
        #endregion
        
        #region Selection and Position

        /// <summary>
        /// Sets the position of the node, updating both the visual and logical representation.
        /// </summary>
        /// <param name="newPos">The new position for the node.</param>
        public override void SetPosition(Rect newPos)
        {
            base.SetPosition(newPos);
            data.eventNodePosition = newPos;
        }
    
        #endregion

        #region Localization

        private void HandleGenerateLocalizationStringsSelected()
        {
            /*LocalizationGlobalSettings.EDITOR_ProcessLocalizationDataHolder(data as ILocalizationDataHolder, ObjectiveSystemEditorWindow.CurrentScenarioData.ScenarioNameLocalized);
            serializer.serializedObject.ApplyModifiedProperties();
            serializer.UpdateSerializedObject();
            serializer.data.EDITOR_SetDirtyAndSave();*/
        }

        #endregion

        #region Helpers

        /// <summary>
        /// Retrieves all fields from a given type and its base types that are marked with the <see cref="NodeExposedParameterAttribute"/>.
        /// This method traverses the class hierarchy from the base class up to the derived class, collecting fields that are decorated
        /// with the <see cref="NodeExposedParameterAttribute"/> attribute. Fields from all access levels (public, protected, and private)
        /// within the class hierarchy are considered, but only those fields declared directly within each type (not inherited fields).
        /// </summary>
        /// <param name="type">The type to inspect for fields. This includes the type itself and any base types in its hierarchy.</param>
        /// <returns>An <see cref="IEnumerable{FieldInfo}"/> containing all fields marked with the <see cref="NodeExposedParameterAttribute"/>
        /// from the specified type and its base types, ordered from the base class fields to the derived class fields.</returns>
        private static IEnumerable<FieldInfo> GetAllFields(Type type)
        {
            List<FieldInfo> fields = new List<FieldInfo>();
            Stack<Type> hierarchy = new Stack<Type>();

            // Build the hierarchy from the base class to the derived class
            for (Type currentType = type; currentType != null; currentType = currentType.BaseType)
            {
                hierarchy.Push(currentType);
            }

            // Traverse the hierarchy from base to derived
            while (hierarchy.Count > 0)
            {
                Type currentType = hierarchy.Pop();
                IEnumerable<FieldInfo> typeFields = currentType.GetFields(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)
                    .Where(isFieldValid);

                fields.AddRange(typeFields);
            }

            return fields;

            bool isFieldValid(FieldInfo f)
            {
                if (f.GetCustomAttribute(typeof(HideAttribute), true) != null)
                {
                    return false;
                }

                if (f.IsPrivate && f.GetCustomAttribute(typeof(SerializeField), true) == null)
                {
                    return false;
                }

                return true;
            }
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveEventNode.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveEventsGraphView.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 0d68cd312dd04cd297d583583fcb19f5
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.NodeGraph;
using UnityEditor.Experimental.GraphView;
using UnityEngine;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.Objectives.NodeGraph
{
    /// <summary>
    /// A specialized GraphView for displaying and editing objective events within a node-based editor.
    /// This view facilitates the creation, connection, and management of various event nodes tied to objectives,
    /// providing a visual interface for complex event-driven logic within objectives.
    /// </summary>
    [UxmlElement]
    public partial class ObjectiveEventsGraphView : BaseGraphView
    {
        private const string DELETE_GROUP_TITLE = "Delete group";
        private const string GLOBAL_TEXT = "global";
    
        private SerializedObjectiveData serializer;
        private BaseObjective currentObjective;
        private ObjectiveEventMasterNode masterNode;

        private readonly HashSet<TriggerEventNode> triggerEventNodes = new HashSet<TriggerEventNode>();
        private readonly Dictionary<TriggerEventNode, NodeGroup> triggerEventNodeGroupsMap = new Dictionary<TriggerEventNode, NodeGroup>();
        private readonly List<ObjectiveEventNode> objectiveEventNodes = new List<ObjectiveEventNode>();
        private readonly ContextualMenuAction[] triggerGroupActions;

        #region Initialization

        /// <summary>
        /// Initializes the Objective Events Graph View, setting up contextual menu actions and subscribing to necessary events.
        /// </summary>
        public ObjectiveEventsGraphView()
        {
            triggerGroupActions = new[]
            {
                new ContextualMenuAction(DELETE_GROUP_TITLE, HandleDeleteGroupClicked),
            };

            TriggerEventNode.OnAnyTriggerEventNodeDeleteClicked += HandleAnyTriggerEventNodeDeleteClicked;
            TriggerEventNode.OnAnyTriggerEventConvertSelected += HandleAnyTriggerEventConvertSelected;
            ObjectiveEventNode.OnAnyObjectiveEventNodeDeleteClicked += HandleAnyObjectiveEventNodeDeleteClicked;
            ObjectiveEventNode.OnAnyObjectiveEventConnectToSelected += HandleObjectiveEventConnectToSelected;
            BaseNode.OnAnyNodeSelected += HandleAnyNodeSelected;
        }

        public override void Dispose()
        {
            base.Dispose();
            TriggerEventNode.OnAnyTriggerEventNodeDeleteClicked -= HandleAnyTriggerEventNodeDeleteClicked;
            TriggerEventNode.OnAnyTriggerEventConvertSelected -= HandleAnyTriggerEventConvertSelected;
            ObjectiveEventNode.OnAnyObjectiveEventNodeDeleteClicked -= HandleAnyObjectiveEventNodeDeleteClicked;
            ObjectiveEventNode.OnAnyObjectiveEventConnectToSelected -= HandleObjectiveEventConnectToSelected;
            BaseNode.OnAnyNodeSelected -= HandleAnyNodeSelected;
        }

        /// <summary>
        /// Populates the graph view with nodes and connections based on the specified objective data and the current objective.
        /// </summary>
        /// <param name="objectiveData">The serialized data of the objective.</param>
        /// <param name="currentObjective">The current objective being edited.</param>
        public void PopulateView(SerializedObjectiveData objectiveData, BaseObjective currentObjective)
        {
            serializer = objectiveData;
            this.currentObjective = currentObjective;
            Show();
        }
    
        /// <summary>
        /// Repopulates the graph view, clearing existing nodes and connections and creating new ones based on current data.
        /// </summary>
        protected override void RepopulateView()
        {
            serializer.UpdateSerializedObject();

            triggerEventNodes.Clear();
            objectiveEventNodes.Clear();
        
            masterNode = Activator.CreateInstance(typeof(ObjectiveEventMasterNode)) as ObjectiveEventMasterNode;
            masterNode.Initialize(this, serializer, currentObjective);
            SetNodePosition(masterNode, Vector2.zero);
            AddElement(masterNode);
            SelectedNode = masterNode;
        
            foreach (ObjectiveEventData eventData in currentObjective.EventDataContainer)
            {
                CreateEventNodeView(eventData, Vector2.zero);
            }
        
            ConnectNodesAndCreateGroups();
        }

        /// <summary>
        /// Connects nodes and creates group views based on the current graph structure, organizing the visual representation.
        /// </summary>
        protected override void ConnectNodesAndCreateGroups()
        {
            base.ConnectNodesAndCreateGroups();
        
            triggerEventNodeGroupsMap.Clear();

            //Connecting each trigger event
            foreach (TriggerEventNode triggerEventNode in triggerEventNodes)
            {
                if (triggerEventNode.TryConnectToPort(Direction.Input, masterNode.OutputPort, 0, out Edge edge))
                {
                    AddElement(edge);
                    graphEdges.Add(edge);
                }
            
                NodeGroup nodeGroup = new NodeGroup($"On {triggerEventNode.triggerEventInfo.GetTriggerName()}", 
                    triggerEventNode.triggerEventInfo.GetHashCode().ToString(),
                    menuActions: triggerGroupActions);
                nodeGroup.Add(triggerEventNode.viewDataKey);
                triggerEventNodeGroupsMap.Add(triggerEventNode, nodeGroup);
            }
            
            //connecting each event data to trigger event
            foreach (ObjectiveEventNode eventNode in objectiveEventNodes)
            {
                if (eventNode.eventNode.TryGetPort(Direction.Output, 0, out Port port)
                    && eventNode.TryConnectToPort(Direction.Input, port, 0, out Edge edge))
                {
                    AddElement(edge);
                    graphEdges.Add(edge);
                }

                if (triggerEventNodeGroupsMap.TryGetValue(eventNode.eventNode, out NodeGroup nodeGroup))
                {
                    nodeGroup.Add(eventNode.viewDataKey);
                }
            }
        
            //creating groups
            foreach (NodeGroup nodeGroup in triggerEventNodeGroupsMap.Values)
            {
                CreateGroupView(nodeGroup);
            }
        }

        /// <summary>
        /// Creates a view for an event node based on the given objective event data.
        /// </summary>
        /// <param name="eventData">The objective event data to create a node view for.</param>
        /// <param name="pos">The position at which to place the node view.</param>
        private void CreateEventNodeView(ObjectiveEventData eventData, Vector2 pos) 
        {
            if (eventData == null)
            {
                return;
            }
        
            TriggerEventNode triggerEventNode = GetOrCreateTriggerEventNode(eventData.TriggerEventInfo, currentObjective.GetTriggerEventInfoNodePosition(eventData.TriggerEventInfo).position);
        
            ObjectiveEventNode eventNode = Activator.CreateInstance(typeof(ObjectiveEventNode)) as ObjectiveEventNode;
            eventNode.Initialize(this, serializer, currentObjective, eventData, triggerEventNode);
            SetNodePosition(eventNode, pos);
            objectiveEventNodes.Add(eventNode);
            AddElement(eventNode);
        }

        /// <summary>
        /// Retrieves or creates a new TriggerEventNode based on the given TriggerEventInfo.
        /// </summary>
        /// <param name="eventInfo">The event information to base the node on.</param>
        /// <param name="pos">The position at which to place the node.</param>
        /// <returns>The found or newly created TriggerEventNode.</returns>
        private TriggerEventNode GetOrCreateTriggerEventNode(TriggerEventInfo eventInfo, Vector2 pos)
        {
            foreach (TriggerEventNode eventNode in triggerEventNodes)
            {
                if (eventNode.triggerEventInfo.Equals(eventInfo))
                {
                    return eventNode;
                }
            }

            TriggerEventInfo copyEventInfo = new TriggerEventInfo(eventInfo);
            TriggerEventNode trigger = Activator.CreateInstance(typeof(TriggerEventNode)) as TriggerEventNode;
            trigger.Initialize(this, serializer, currentObjective, copyEventInfo);
            SetNodePosition(trigger, pos);
            triggerEventNodes.Add(trigger);
            AddElement(trigger);
            return trigger;
        }
    
        #endregion
    
        #region Event Handlers
        
        /// <summary>
        /// Handles the selection of a node within the graph, updating the currently selected node if it is part of the graph.
        /// </summary>
        /// <param name="node">The node that has been selected.</param>
        private void HandleAnyNodeSelected(BaseNode node)
        {
            if (!nodes.Contains(node))
            {
                return;
            }
            
            SelectedNode = node;
        }
    
        /// <summary>
        /// Handles the selection of a trigger event type, creating or updating a trigger event node based on the selected type.
        /// </summary>
        /// <param name="setting">The settings context from which the ID is selected.</param>
        /// <param name="idType">The type of the ID being selected.</param>
        /// <param name="from">The port view triggering the event.</param>
        /// <param name="triggerName">The name of the trigger event.</param>
        /// <param name="nodePos">The position to place the created or updated node.</param>
        private void HandleTriggerEvenTypeSelected(LdxIdSettings setting, LdxIdSettings.IdType idType, PortView from, 
            string triggerName, Vector2 nodePos)
        {
            string eventID = null;
            CompoundIDInfoContainer list = LdxIdSettings.GetCompoundIDList(idType, setting);
            foreach (IDInfo info in list)
            {
                if (info.Description == triggerName)
                {
                    eventID = info.ID;
                }
            }

            TriggerEventInfo triggerEventInfo;

            switch (idType)
            {
                case LdxIdSettings.IdType.TrackingEvent:
                    triggerEventInfo = new TriggerEventInfo(ObjectiveEventData.TriggerEventType.TrackingEvent, eventID);
                    break;
                case LdxIdSettings.IdType.Dialog:
                    triggerEventInfo = new TriggerEventInfo(ObjectiveEventData.TriggerEventType.DialogCompleted, dialogId:eventID);
                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(idType), idType, null);
            }
        
            TriggerEventNode eventNode = GetOrCreateTriggerEventNode(triggerEventInfo, nodePos);
            SetNodePosition(eventNode, nodePos);
        }
        
        /// <summary>
        /// Overrides the default delete selection process to handle the deletion of ObjectiveNodes specifically.
        /// </summary>
        /// <param name="operationName">The name of the operation triggering the deletion.</param>
        /// <param name="askUser">Determines if the user should be asked for confirmation before deletion.</param>
        protected override void DeleteSelection(string operationName, AskUser askUser)
        {
            base.DeleteSelection(operationName, askUser);
            if (!SelectedNode.IsDeletable)
            {
                return;
            }

            if (SelectedNode is TriggerEventNode triggerEventNode)
            {
                DeleteTriggerEventNode(triggerEventNode);
                return;
            }

            if (SelectedNode is ObjectiveEventNode eventNode)
            {
                HandleAnyObjectiveEventNodeDeleteClicked(eventNode);
            }
        }
    
        /// <summary>
        /// Handles the click event for deleting a group along with its associated trigger event node.
        /// </summary>
        /// <param name="groupView">The group view to be deleted.</param>
        /// <param name="pos">The position where the delete action was initiated.</param>
        private void HandleDeleteGroupClicked(GroupView groupView, Vector2 pos)
        {
            TriggerEventNode eventNode = null;
            foreach (TriggerEventNode node in triggerEventNodes)
            {
                if (groupView.OwnerID == node.viewDataKey)
                {
                    eventNode = node;
                    break;
                }
            }

            DeleteTriggerEventNode(eventNode, groupView);
        }
    
        /// <summary>
        /// Handles the event when any trigger event node's delete action is clicked, removing it from the graph.
        /// </summary>
        /// <param name="eventNode">The trigger event node that is being deleted.</param>
        private void HandleAnyTriggerEventNodeDeleteClicked(TriggerEventNode eventNode)
        {
            DeleteTriggerEventNode(eventNode);
        }
    
        /// <summary>
        /// Handles the conversion of a trigger event node to a selected trigger event type, updating the node and the underlying data.
        /// </summary>
        /// <param name="eventNode">The trigger event node to convert.</param>
        /// <param name="triggerInfo">The new trigger event information.</param>
        private void HandleAnyTriggerEventConvertSelected(TriggerEventNode eventNode, TriggerEventInfo triggerInfo)
        {
            foreach (ObjectiveEventData eventData in eventNode.baseObjective.EventDataContainer)
            {
                if (eventData.TriggerEventInfo.Equals(eventNode.triggerEventInfo))
                {
                    currentObjective.EDITOR_ChangeEventDataTrigger(eventData, triggerInfo);
                }
            }
        
            serializer.serializedObject.ApplyModifiedProperties();
            serializer.serializedObject.Update();
            serializer.data.EDITOR_SetDirtyAndSave();

            TriggerEventNode newTriggerEventNode =
                triggerEventNodes.FirstOrDefault(x => x != eventNode && x.triggerEventInfo.Equals(triggerInfo));

            List<ObjectiveEventNode> affectedNodes = objectiveEventNodes.Where(x => x.eventNode == eventNode).ToList();
        
            if (newTriggerEventNode == null)
            {
                Rect triggerPos = eventNode.SavedNodePosition;
                currentObjective.RemoveTriggerEventInfoPos(eventNode.triggerEventInfo);
                RemoveElement(eventNode);
                triggerEventNodes.Remove(eventNode);

                newTriggerEventNode = GetOrCreateTriggerEventNode(triggerInfo, triggerPos.position);
            }

            foreach (ObjectiveEventNode affectedNode in affectedNodes)
            {
                affectedNode.eventNode = newTriggerEventNode;
            }
        
            ConnectNodesAndCreateGroups();
        }

        /// <summary>
        /// Handles the connection of an objective event node to a selected trigger event, updating both the node and the underlying data.
        /// </summary>
        /// <param name="objectiveEventNode">The objective event node to connect.</param>
        /// <param name="triggerInfo">The trigger event information to connect to.</param>
        private void HandleObjectiveEventConnectToSelected(ObjectiveEventNode objectiveEventNode, TriggerEventInfo triggerInfo)
        {
            if (objectiveEventNode.eventNode.triggerEventInfo.Equals(triggerInfo))
            {
                return;
            }
        
            TriggerEventNode oldTriggerNode = objectiveEventNode.eventNode;
        
            currentObjective.EDITOR_ChangeEventDataTrigger(objectiveEventNode.data, triggerInfo);
            serializer.serializedObject.ApplyModifiedProperties();
            serializer.serializedObject.Update();
            serializer.data.EDITOR_SetDirtyAndSave();
        
            TriggerEventNode connectToEventNode = GetOrCreateTriggerEventNode(triggerInfo, 
                objectiveEventNode.SavedNodePosition.position + Vector2.down * 200);
            objectiveEventNode.eventNode = connectToEventNode;
        
            if (objectiveEventNodes.All(x => x.eventNode != oldTriggerNode))
            {
                currentObjective.RemoveTriggerEventInfoPos(oldTriggerNode.triggerEventInfo);
                RemoveElement(oldTriggerNode);
                triggerEventNodes.Remove(oldTriggerNode);
            }
        
            ConnectNodesAndCreateGroups();
        }
    
        /// <summary>
        /// Handles the deletion of an objective event node, removing it and its associated data from the current objective.
        /// </summary>
        /// <param name="objectiveEventNode">The objective event node to delete.</param>
        private void HandleAnyObjectiveEventNodeDeleteClicked(ObjectiveEventNode objectiveEventNode)
        {
            serializer.data.EDITOR_DeleteObjectiveEvent(currentObjective, objectiveEventNode.data);
            objectiveEventNodes.Remove(objectiveEventNode);
            RemoveElement(objectiveEventNode);
            serializer.serializedObject.ApplyModifiedProperties();
            serializer.UpdateSerializedObject();
            ConnectNodesAndCreateGroups();
        }

        #endregion
    
        #region Node Managment
    
        /// <summary>
        /// Creates a node based on the specified type, configuring it according to the provided parameters.
        /// This method specifically handles the creation of event nodes related to objectives,
        /// such as tracking and dialog events, and integrates them into the current objective's data.
        /// </summary>
        /// <param name="owner">The owner node from which the creation is initiated.</param>
        /// <param name="from">The port from which the node creation is triggered.</param>
        /// <param name="nodeType">The type of node to create.</param>
        /// <param name="entryName">The name or identifier related to the node being created.</param>
        /// <param name="pos">The position at which to place the newly created node.</param>
        /// <returns>The created BaseNode instance, or null if the operation did not result in a new node.</returns>
        public override BaseNode CreateNodeWithParam(BaseNode owner, PortView from, BaseNode.NodeParam nodeParam, string entryName, Vector2 pos)
        {
            Type nodeType = nodeParam.Type;
            if(nodeType.IsSubclassOf(typeof(ObjectiveEventData)))
            {
                if (owner is not TriggerEventNode triggerEventNode)
                {
                    return null;
                }

                TriggerEventInfo eventInfo = triggerEventNode.triggerEventInfo; 
                ObjectiveEventData eventData = currentObjective.EDITOR_AddNewEventData(nodeType, eventInfo);
                serializer.data.EDITOR_SetDirtyAndSave();
                serializer.UpdateSerializedObject();

                if (eventData != null)  
                {
                    CreateEventNodeView(eventData, pos);
                    ConnectNodesAndCreateGroups();
                }
           
                return null;
            }
        
            TriggerEventInfo triggerEventInfo = null;

            if (nodeType == typeof(BaseTriggerEventNode))
            {
                foreach (ObjectiveEventData.TriggerEventType type in Enum.GetValues(typeof(ObjectiveEventData.TriggerEventType)))
                {
                    if (String.Equals(type.ToString(), entryName, StringComparison.Ordinal))
                    {
                        triggerEventInfo = new TriggerEventInfo(type);
                        break;
                    }
                }
            }
            else if (nodeType == typeof(TriggerTrackingEventNode))
            {
                string eventID = nodeParam.ID;
                if (eventID == null)
                {
                    IDCreationPopup.OpenPopup(entryName.Contains(GLOBAL_TEXT) ? 
                            LdxIdSettings.InstanceTypeResult.Global : LdxIdSettings.InstanceTypeResult.CurrentScenario,
                        LdxIdSettings.IdType.TrackingEvent, from, pos, HandleTriggerEvenTypeSelected);
                    return null;
                }
            
                ObjectiveEventData existingData = currentObjective.EventDataContainer
                    .FirstOrDefault(e
                        => e.TriggerEventInfo.EventType == ObjectiveEventData.TriggerEventType.TrackingEvent 
                           && e.TriggerEventInfo.TriggerTrackingEvent == eventID);
               
                if (existingData != null)
                {
                    triggerEventInfo = new TriggerEventInfo(existingData.TriggerEventInfo);
                }
            
                triggerEventInfo ??= new TriggerEventInfo(ObjectiveEventData.TriggerEventType.TrackingEvent, eventID);
            }
            else if (nodeType == typeof(TriggerDialogEventNode))
            {
                string eventID = nodeParam.ID;
                
                if (eventID == null)
                {
                    IDCreationPopup.OpenPopup(entryName.Contains(GLOBAL_TEXT) ? 
                            LdxIdSettings.InstanceTypeResult.Global : LdxIdSettings.InstanceTypeResult.CurrentScenario,
                        LdxIdSettings.IdType.Dialog, from, pos, HandleTriggerEvenTypeSelected);
                    return null;
                }
              
                ObjectiveEventData existingData = currentObjective.EventDataContainer
                    .FirstOrDefault(e
                        => e.TriggerEventInfo.EventType == ObjectiveEventData.TriggerEventType.DialogCompleted 
                           && e.TriggerEventInfo.TriggerDialogId == eventID);
               
                if (existingData != null)
                {
                    triggerEventInfo = new TriggerEventInfo(existingData.TriggerEventInfo);
                }

                triggerEventInfo ??= new TriggerEventInfo(ObjectiveEventData.TriggerEventType.DialogCompleted, dialogId: eventID);
            }
            else if (nodeType == typeof(InteractionTriggerEventNode))
            {
                var param = nodeParam as InteractionTriggerEventNode.InteractionNodeParam;
                if (param == null)
                {
                    return null;
                }
                
                string eventID = param.ID;
                
                ObjectiveEventData existingData = currentObjective.EventDataContainer
                    .FirstOrDefault(e
                        => e.TriggerEventInfo.EventType == ObjectiveEventData.TriggerEventType.Interaction 
                           && e.TriggerEventInfo.TriggerInteractableID == param.ID
                           && e.TriggerEventInfo.InteractionEventType == param.InteractionEventType);
                
                if (existingData != null)
                {
                    triggerEventInfo = new TriggerEventInfo(existingData.TriggerEventInfo);
                }

                triggerEventInfo ??= new TriggerEventInfo(ObjectiveEventData.TriggerEventType.Interaction,
                    interactionEventType: param.InteractionEventType,
                    interactableId: eventID);
            }

            TriggerEventNode eventNode = GetOrCreateTriggerEventNode(triggerEventInfo, pos);
            ConnectNodesAndCreateGroups();
            return eventNode;
        }

        /// <summary>
        /// Deletes a specified trigger event node and its associated group view from the graph.
        /// This method takes care of removing the node and group view from the UI,
        /// as well as updating the underlying objective data to reflect this change.
        /// </summary>
        /// <param name="eventNode">The trigger event node to delete.</param>
        /// <param name="groupView">Optional. The group view associated with the event node. If null, it will be located and removed.</param>
        private void DeleteTriggerEventNode(TriggerEventNode eventNode, GroupView groupView = null)
        {
            if (eventNode == null) return;

            if (groupView == null)
            {
                foreach (GroupView view in groupViews.Where(view => view.OwnerID == eventNode.viewDataKey))
                {
                    groupView = view;
                    break;
                }
            }

            if (groupView != null)
            {
                RemoveElement(groupView);
            }
  
            for (int i = objectiveEventNodes.Count - 1; i >= 0; i--)
            {
                if (objectiveEventNodes[i].eventNode == eventNode)
                {
                    RemoveElement(objectiveEventNodes[i]);
                    objectiveEventNodes.RemoveAt(i);
                }
            }
  
            currentObjective.RemoveTriggerEventInfoPos(eventNode.triggerEventInfo);
            serializer.data.EDITOR_DeleteObjectiveEventDataByTrigger(currentObjective, eventNode.triggerEventInfo);
            
            RemoveElement(eventNode);
            triggerEventNodes.Remove(eventNode);
            
            serializer.serializedObject.ApplyModifiedProperties();
            serializer.UpdateSerializedObject();
            
            ConnectNodesAndCreateGroups();
        }
        
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveEventsGraphView.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveNode.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7e00c029b5f1414494aebf16dc872e07
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.NodeGraph;
using Systems.Settings;
using UnityEditor.Experimental.GraphView;
using UnityEngine;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.Objectives.NodeGraph
{
    /// <summary>
    /// Represents a node for objectives within the graph view, capable of being a main objective or a sub-objective.
    /// </summary>
    public class ObjectiveNode : BaseObjectiveNode
    {
        #region Constants
    
        private const string PORT_TYPE_OBJ = "Default";
        private const string PORT_TYPE_CHILDREN = "Children";
        private const string NODE_CHILD_OBJ_TITLE = "Child Objective";
        private const string NODE_OBJECTIVE_TITLE = "Objective";
        private const string MOVE_AFTER_PREFIX = "Move after";
        private const string MOVE_BEFORE_PREFIX = "Move before";
        private const string OVERRIDE_START_MENU = "Start from this objective";
        private const string CREATE_CHILD_OBJECTIVE = "Create Child Objective";
        private const string CREATE_OBJECTIVE = "Create Objective";
        private const string OBJECTIVE_START_ICON = "override-objective-start";
    
        #endregion
    
        #region Events
    
        public static Action<ObjectiveNode> OnAnyObjectiveNodeSelected;
        public static Action<ObjectiveNode> OnAnyObjectiveNodeDeleted;
        public static Action<ObjectiveNode> OnAnyObjectiveMoveRequested;
        public static Action<ObjectiveNode, int> OnAnyObjectiveOverrideStartRequested;
    
        #endregion
    
        public bool isSubObjective;
        public override Rect SavedNodePosition => BaseObjective.nodePosition;
        protected override StyleSheet NodeStyleSheet => EditorGlobalSettings.ObjectiveNodeStyle;
        private VisualElement overrideObjectiveStartIcon;
        
        #region Initialization
    
        /// <summary>
        /// Initializes the node with objective data and determines if it's a sub-objective.
        /// </summary>
        /// <param name="graphView">The graph view this node belongs to.</param>
        /// <param name="objectiveData">The serialized data of the objective.</param>
        /// <param name="baseObjective">The base objective associated with this node.</param>
        public override void Initialize(BaseGraphView graphView, SerializedObjectiveData objectiveData, BaseObjective baseObjective)
        {
            isSubObjective = baseObjective is SubObjective;
            base.Initialize(graphView, objectiveData, baseObjective);
        }

        protected override void InitializeView()
        {
            base.InitializeView();
            overrideObjectiveStartIcon = new VisualElement(){name = OBJECTIVE_START_ICON};
            StyleBackground newStyle = new(EditorGlobalSettings.OverrideObjectiveStartIcon);
            overrideObjectiveStartIcon.style.backgroundImage = newStyle;
            overrideObjectiveStartIcon.AddToClassList("override-objective-start");
            Add(overrideObjectiveStartIcon);
            UpdateOverrideStartIconVisibility();
        }

        /// <summary>
        /// Initializes the input and output ports for the node based on its type (main or sub-objective).
        /// </summary>
        protected override void InitializePorts()
        {
            base.InitializePorts();
            string portType = isSubObjective ? PORT_TYPE_CHILDREN : PORT_TYPE_OBJ;

            PortView inputPort = CreateAndAddPort(Direction.Input, isVertical: true, portType: portType);
            PortView outputPort = CreateAndAddPort(Direction.Output, isVertical: true, portType: portType);
        
            NodeDescriptions objectiveOutput = new(CREATE_OBJECTIVE)
            {
                nodePerMenuTitle = new Dictionary<string, NodeParam>()
                {
                    { NODE_OBJECTIVE_TITLE, new(typeof(Objective)) }
                }
            };
        
            NodeDescriptions subObjectiveOutput = new(CREATE_CHILD_OBJECTIVE)
            {
                nodePerMenuTitle = new Dictionary<string, NodeParam>()
                {
                    { NODE_CHILD_OBJ_TITLE, new(typeof(SubObjective)) }
                }
            };

            portNodeDescriptionsMap.Add(inputPort, isSubObjective ? subObjectiveOutput : objectiveOutput);
            portNodeDescriptionsMap.Add(outputPort, isSubObjective ? subObjectiveOutput : objectiveOutput);

            if (!isSubObjective)
            {
                PortView subObjectivePort = CreateAndAddPort(Direction.Output, isVertical: true, portType: PORT_TYPE_CHILDREN);
                portNodeDescriptionsMap.Add(subObjectivePort, subObjectiveOutput); 
            }
        }
    
        #endregion

        #region Context Menu
    
        protected override void AddCustomContextMenuItems(ContextualMenuPopulateEvent evt)
        {
            base.AddCustomContextMenuItems(evt);
      
            int objectivesCount = -1;
            int objectiveIndex = -1;

            if (isSubObjective)
            {
                // Finds the parent objective of a sub-objective and retrieves its index and total child objectives count.
                Objective parentObjective = serializer.data.EDITOR_FindParentOfSubObjective(BaseObjective as SubObjective, out objectiveIndex);
                objectivesCount = parentObjective.ChildObjectives.Count;
            }
            else
            { 
                // Retrieves the total main objectives count and the current objective's index for main objectives.
                objectivesCount = serializer.data.Objectives.Count;
                objectiveIndex = serializer.data.Objectives.IndexOf(BaseObjective as Objective);
                
                // Adds context menu actions for moving the objective to a previous or next index within its parent list.
                evt.menu.AppendAction(OVERRIDE_START_MENU, _ => HandleOverrideStartObjectiveSelected(this, objectiveIndex), 
                    serializer.data.EditorOverrideStartObjectiveStep ? DropdownMenuAction.Status.Normal : DropdownMenuAction.Status.Disabled);
                evt.menu.AppendSeparator();
            }
        
            // Determines the next and previous index positions for the current objective.
            int nextIndex = Mathf.Clamp(objectiveIndex + 1, 0, objectivesCount - 1);
            int prevIndex = Mathf.Clamp(objectiveIndex - 1, 0, objectivesCount - 1);

            // Adds context menu actions for moving the objective to a previous or next index within its parent list.
            evt.menu.AppendAction(MOVE_BEFORE_PREFIX, _ => MoveObjectiveToIndex(this, prevIndex), 
                prevIndex == objectiveIndex ? DropdownMenuAction.Status.Disabled : DropdownMenuAction.Status.Normal);
        
            evt.menu.AppendAction(MOVE_AFTER_PREFIX, _ => MoveObjectiveToIndex(this, nextIndex),
                nextIndex == objectiveIndex ? DropdownMenuAction.Status.Disabled : DropdownMenuAction.Status.Normal);
        }

        #endregion

        #region Node Actions
    
        /// <summary>
        /// Moves the objective node to a new index within its parent's child list.
        /// </summary>
        /// <param name="node">The node to move.</param>
        /// <param name="index">The new index for the node.</param>
        private void MoveObjectiveToIndex(ObjectiveNode node, int index)
        {
            serializer.data.EDITOR_MoveObjective(node.BaseObjective, index);
            OnAnyObjectiveMoveRequested?.Invoke(this);
        }
    
        /// <summary>
        /// Deletes the current objective node and triggers any associated cleanup or events.
        /// </summary>
        protected override void DeleteNode()
        {
            OnAnyObjectiveNodeDeleted?.Invoke(this);
        }

        /// <summary>
        /// Duplicates the current objective node, creating a copy with the same data and settings.
        /// </summary>
        protected override void DuplicateNode()
        {
            if (BaseObjective is Objective objective)
            {
                serializer.data.EDITOR_DuplicateObjective(objective);
                WaitAndRefreshAsync().Forget();
            }
            else if (BaseObjective is SubObjective subObjective)
            {
                Objective parent = null;
                foreach (Objective dataObjective in serializer.data.Objectives)
                {
                    if (dataObjective.ChildObjectives.Contains(subObjective))
                    {
                        parent = dataObjective;
                        break;
                    }
                }
                serializer.data.EDITOR_DuplicateObjective(parent, subObjective);
                WaitAndRefreshAsync().Forget();
            }
        }

        private async UniTask WaitAndRefreshAsync()
        {
            await UniTask.Delay(10);
            graphView.Refresh();
        }
        
        #endregion

        #region Override start actions

        private void HandleOverrideStartObjectiveSelected(ObjectiveNode node, int objectiveIndex)
        {
            OnAnyObjectiveOverrideStartRequested?.Invoke(this, objectiveIndex);
        }
        
        public void UpdateOverrideStartIconVisibility()
        {
            if (overrideObjectiveStartIcon == null)
            {
                return;
            }
            
            if (isSubObjective)
            {
                overrideObjectiveStartIcon.style.display = DisplayStyle.None;
                return;
            }
            
            int objectiveIndex = serializer.data.Objectives.IndexOf(BaseObjective as Objective);
            overrideObjectiveStartIcon.style.display = 
                serializer.data.EditorOverrideStartObjectiveStep && serializer.data.ObjectivesStepOverrideIndex == objectiveIndex
                    ? DisplayStyle.Flex
                    : DisplayStyle.None;
        }

        #endregion
    
        #region Selection and Position
    
        /// <summary>
        /// Handles the node's selection, triggering any specific logic or events needed.
        /// </summary>
        public override void OnSelected() 
        {
            base.OnSelected();
            OnAnyObjectiveNodeSelected?.Invoke(this);
        }

        /// <summary>
        /// Sets the position of the node, updating both the visual and logical representation.
        /// </summary>
        /// <param name="newPos">The new position for the node.</param>
        public override void SetPosition(Rect newPos)
        {
            base.SetPosition(newPos);
            BaseObjective.nodePosition = newPos;
        }
    
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveNode.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveSystemEditorWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7c7a65a503f5d8f49b29b13ebf5eddc0
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.NodeGraph;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Systems.Settings;
using UnityEditor;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.Objectives.NodeGraph
{
    /// <summary>
    /// ObjectiveSystemEditorWindow is a custom editor window for creating, viewing, and editing ObjectiveData assets within Unity.
    /// It provides a graphical interface to manage objectives and their properties, supporting operations like open, new, save, and refresh.
    /// The window facilitates the visualization and editing of objectives in a structured and user-friendly manner.
    /// </summary>
    public class ObjectiveSystemEditorWindow : EditorWindow
    {
        #region Constants
    
        private const string TOOLBAR_BREADCRUMBS = "toolbar-breadcrumbs";
        private const string TOOLBAR_OBJECTIVE_LABEL = "Objectives";
        private const string TOOLBAR_INSPECTOR = "inspector-toolbar";
        private const string TOOLBAR_OBJECTIVE_DATA_LABEL = "objective-system-name";
        private const string SHOW_CONDITIONS_ON_NODE_MENU = "Show Conditions on Node";
        private const string CONDITIONS_VISIBILITY_KEY = "ConditionsVisibility";

        private const string TOOLBAR_MENU_FILE = "File";
        private const string TOOLBAR_MENU_VIEW = "View";
        private const string TOOLBAR_MENU_TOOLS = "Tools";
        private const string TOOLBAR_OPEN = "Open";
        private const string TOOLBAR_NEW = "New";
        private const string TOOLBAR_REFRESH = "Refresh";
        private const string TOOLBAR_SAVE_AS = "Save as";
        private const string TOOLBAR_MENU_LOCALIZATION_PATH = "Localization/";
        private const string TOOLBAR_OVERRIDE_START_OBJECTIVE = "Runtime/Override start objective";
        private const string TOOLBAR_LOCALIZATION_ENABLED = "Localization/Enable Localization";
        private const string TOOLBAR_LOCALIZATION_REFRESH = "Localization/Refresh localization";
        private const string TOOLBAR_LOCALIZATION_OPEN = "Localization/Open Localization window";
        private const string TOOLBAR_LOCALIZATION_GENERATE = "Localization/Generate ID for texts";
        private const string TOOLBAR_DIALOGUE_EDITOR = "Dialogue/Dialogue Editor";
        private const string TOOLBAR_FILE_IMPORT_LOCALIZATION = "Import/All Localization..";
        private const string TOOLBAR_FILE_EXPORT_SCENARIO_DIALOGS = "Export/Scenario Dialogs..";
        private const string TOOLBAR_FILE_EXPORT_ALL_DIALOGS = "Export/All Dialogs in Project..";
        private const string TOOLBAR_FILE_EXPORT_LOCALIZATION = "Export/All Localization..";

        private const string SAVE_OBJECTIVE_DATA_TITLE = "Save ObjectiveData As";
        private const string NEW_OBJECTIVE_DATA_NAME = "NewObjectiveData";
        private const string ASSET_EXTENSION = "asset";
        private const string SAVE_OBJECTIVE_DATA_MESSAGE = "Please enter a file name to save the ObjectiveData asset to";
        private const string SELECT_OBJECTIVE_DATA_TITLE = "Select ObjectiveData Asset";
        private const string CREATE_NEW_OBJECTIVE_DATA_TITLE = "Create New ObjectiveData";
        private const string CREATE_NEW_OBJECTIVE_DATA_MESSAGE = "Please enter a file name:";
    
        #endregion

        #region Fields
    
        public static event Action OnConditionsVisibilityStateChanged;
        public static event Action OnOverrideStartObjectiveChanged;
        
        public static bool ConditionsVisibleOnNodes;
        public static ScenarioData CurrentScenarioData;

        private ObjectiveData data;
        private SerializedObjectiveData serializer;
        private ObjectiveDataView dataView;
        private ObjectiveEventsGraphView objectiveEventsGraphView;
        private ToolbarBreadcrumbs breadcrumbs;
        private InspectorView inspectorView;
        private Toolbar inspectorToolbar;
        private Label objectiveSystemNameLabel;
        private DocumentationView documentationView;
        private SplitView splitView;

        private string DataPath => EditorGlobalSettings.ObjectiveDataPath;
    
        #endregion

        #region Unity Editor Menu
        
        /// <summary>
        /// Opens the editor window. If current objective data exists in the scene, it opens the window with that data.
        /// Otherwise, it opens the ObjectiveDataSelectionWindow for selecting an objective data asset.
        /// </summary>
        [MenuItem("LogicalDox/Objectives Editor", priority = 0)]
        public static void OpenWindow()
        {
            ObjectiveData currentObjectiveData = GetCurrentSceneObjectiveData(out ScenarioData data);
            if (currentObjectiveData != null)
            {
                OpenWindow(currentObjectiveData, data);
            }
            else
            {
                ObjectiveDataSelectionWindow.ShowWindow();
            }
        }

        /// <summary>
        /// Opens the window with the specified ObjectiveData.
        /// </summary>
        /// <param name="objectiveData">Objective data to open the window with.</param>
        /// <param name="scenarioData">Associated scenario data</param>
        public static void OpenWindow(ObjectiveData objectiveData, ScenarioData scenarioData)
        {
            ObjectiveSystemEditorWindow wnd = GetWindow<ObjectiveSystemEditorWindow>("Objective editor", true);
            wnd.minSize = new Vector2(1200, 900);
            wnd.SelectObjectiveData(objectiveData, scenarioData);
        }

        private void OnDestroy() 
        {
            SaveObjectiveData();
            
            if (dataView != null)
            {
                dataView.OnNodeSelected -= HandleNodeSelectionChanged;
                dataView.OnNodeDeepSelected -= HandleNodeDeepSelected;
                dataView?.Dispose();
            }
            
            objectiveEventsGraphView?.Dispose();
            EditorApplication.playModeStateChanged -= OnPlayModeStateChanged;
        }

        /// <summary>
        /// Retrieves the current scene's ObjectiveData, if available.
        /// </summary>
        /// <returns>The current ObjectiveData associated with the scene, or null if not found.</returns>
        private static ObjectiveData GetCurrentSceneObjectiveData(out ScenarioData scenarioData)
        {
            scenarioData = FindFirstObjectByType<BaseScenario>()?.EDITOR_GetAssociatedScenarioData();
            if (scenarioData == null)
            {
                return null;
            }
            ObjectiveData foundObjectiveData = scenarioData.EDITOR_GetObjectiveData();
            return foundObjectiveData;
        }
        
        #endregion

        #region Initialization
        
        /// <summary>
        /// Initializes the GUI elements of the editor window on creation.
        /// </summary>
        private void CreateGUI()
        {
            VisualElement root = rootVisualElement;
            VisualTreeAsset visualTree = EditorGlobalSettings.ObjectiveWindowXml;
            visualTree.CloneTree(root);

            root.styleSheets.Add(EditorGlobalSettings.ObjectiveWindowStyle);
            InitializeViews(root);
            InitializeToolbar(root);
            SubscribeEvents();

            SelectObjectiveData(data, CurrentScenarioData);
        }

        private void OnPlayModeStateChanged(PlayModeStateChange mode)
        {
            if (mode == PlayModeStateChange.ExitingEditMode)
            {
                SaveObjectiveData();
            }
        }

        private void SaveObjectiveData()
        {
            if (data == null)
            {
                return;
            }
            
            serializer.UpdateSerializedObject();
            data.EDITOR_SetDirtyAndSave();
        }

        /// <summary>
        /// Initializes views within the editor window.
        /// </summary>
        /// <param name="root">Root visual element of the editor window.</param>
        private void InitializeViews(VisualElement root)
        {
            // Initialize views
            dataView = root.Q<ObjectiveDataView>();
            inspectorView = root.Q<InspectorView>();
            inspectorView.InitializeView();
            objectiveEventsGraphView = root.Q<ObjectiveEventsGraphView>();
            objectiveSystemNameLabel = root.Q<Label>(TOOLBAR_OBJECTIVE_DATA_LABEL);

            splitView = root.Q<SplitView>("graph-documentation-split");
            documentationView = root.Q<DocumentationView>();
            Button docButton = root.Q<Button>("documentation-btn");
            documentationView.InitializeView(splitView, docButton);
        }

        /// <summary>
        /// Initializes the toolbar and its menus.
        /// </summary>
        /// <param name="root">Root visual element of the editor window.</param>
        private void InitializeToolbar(VisualElement root)
        {
            // Initialize toolbar and menus
            inspectorToolbar = root.Q<Toolbar>(TOOLBAR_INSPECTOR);
            InitializeFileMenu();
            InitializeViewMenu();
            InitializeToolsMenu();

            breadcrumbs = root.Q<ToolbarBreadcrumbs>(TOOLBAR_BREADCRUMBS);
            breadcrumbs.PushItem(TOOLBAR_OBJECTIVE_LABEL, HandleRootBreadcrumbClicked);
        }

        /// <summary>
        /// Initializes the File menu in the toolbar.
        /// </summary>
        private void InitializeFileMenu()
        {
            ToolbarMenu fileViewMenu = new() { text = TOOLBAR_MENU_FILE };
            fileViewMenu.menu.AppendAction(TOOLBAR_REFRESH, (a) => HandleRefreshButtonClicked());
            fileViewMenu.menu.AppendSeparator();
            fileViewMenu.menu.AppendAction(TOOLBAR_OPEN, (a) => HandleOpenObjectiveSystemClicked());
            fileViewMenu.menu.AppendAction(TOOLBAR_NEW, (a) => HandleNewObjectiveSystemClicked());
            fileViewMenu.menu.AppendSeparator();
            fileViewMenu.menu.AppendAction(TOOLBAR_SAVE_AS, (a) => HandleSaveAsClicked());

            if (LocalizationModel.UseLocalization)
            {
                fileViewMenu.menu.AppendAction(TOOLBAR_FILE_IMPORT_LOCALIZATION, 
                    (a)=>LocalizationExportImportEditorFeatures.ImportLocalizationExcel());
                fileViewMenu.menu.AppendAction(TOOLBAR_FILE_EXPORT_LOCALIZATION, 
                    (a)=>LocalizationExportImportEditorFeatures.ExportLocalizationExcel());
            }
            else
            {
                fileViewMenu.menu.AppendAction(TOOLBAR_FILE_EXPORT_SCENARIO_DIALOGS, 
                    (a)=>DialogsEditorFeatures.ExportCurrentScenarioDialogsToExcelSheet());
                fileViewMenu.menu.AppendAction(TOOLBAR_FILE_EXPORT_ALL_DIALOGS, 
                    (a)=>DialogsEditorFeatures.ExportAllDialogsToExcelSheet());
            }
            
            inspectorToolbar.Add(fileViewMenu);
        }

        /// <summary>
        /// Initializes the View menu in the toolbar.
        /// </summary>
        private void InitializeViewMenu()
        {
            ToolbarMenu viewMenu = new() { text = TOOLBAR_MENU_VIEW };
            SyncConditionVisibilityState();
            viewMenu.menu.AppendAction(SHOW_CONDITIONS_ON_NODE_MENU, (a) => HandleToggleConditions(), 
                (a) => ConditionsVisibleOnNodes ? DropdownMenuAction.Status.Checked : DropdownMenuAction.Status.Normal);
            inspectorToolbar.Add(viewMenu);
        }

        private void InitializeToolsMenu()
        {
            ToolbarMenu toolsMenu = new() { text = TOOLBAR_MENU_TOOLS };
            
            // Runtime
            toolsMenu.menu.AppendAction(TOOLBAR_OVERRIDE_START_OBJECTIVE, (a) => HandleOverrideStartObjectiveToggle(),
                (a) => serializer.data.EditorOverrideStartObjectiveStep ? DropdownMenuAction.Status.Checked : DropdownMenuAction.Status.Normal);
            
            // Localization
            toolsMenu.menu.AppendAction(TOOLBAR_LOCALIZATION_ENABLED, (a) => HandleLocalizationEnableToggled(),
                (a) => LocalizationGlobalSettings.LocalizationEnabled ? DropdownMenuAction.Status.Checked : DropdownMenuAction.Status.Normal);
            toolsMenu.menu.AppendSeparator(TOOLBAR_MENU_LOCALIZATION_PATH);
            toolsMenu.menu.AppendAction(TOOLBAR_LOCALIZATION_REFRESH, (a) => HandleLocalizationRefreshClicked());
            toolsMenu.menu.AppendAction(TOOLBAR_LOCALIZATION_GENERATE, (a) => HandleGenerateLocalizationClicked());
            toolsMenu.menu.AppendSeparator(TOOLBAR_MENU_LOCALIZATION_PATH);
            toolsMenu.menu.AppendAction(TOOLBAR_LOCALIZATION_OPEN, (a) => HandleLocalizationWindowOpenClicked());

            // Dialogue
            toolsMenu.menu.AppendAction(TOOLBAR_DIALOGUE_EDITOR,
                (a)=>DialogueEditorWindow.ShowWindow());
            
            inspectorToolbar.Add(toolsMenu);
        }

        /// <summary>
        /// Subscribes to events necessary for the editor window functionality.
        /// </summary>
        private void SubscribeEvents()
        {
            dataView.OnNodeSelected += HandleNodeSelectionChanged;
            dataView.OnNodeDeepSelected += HandleNodeDeepSelected;
            EditorApplication.playModeStateChanged += OnPlayModeStateChanged;
        }
        
        #endregion

        #region File Menu Handlers
        
        /// <summary>
        /// Invokes a save file panel to let the user save the current ObjectiveData as a new asset.
        /// If a path is selected, a new ObjectiveData instance is created, saved, and selected.
        /// </summary>
        private void HandleSaveAsClicked()
        {
            string path = EditorUtility.SaveFilePanelInProject(SAVE_OBJECTIVE_DATA_TITLE, NEW_OBJECTIVE_DATA_NAME, 
                ASSET_EXTENSION, SAVE_OBJECTIVE_DATA_MESSAGE, DataPath);
            CreateAndSelectObjectiveData(path, data);
        }

        /// <summary>
        /// Opens a file panel allowing the user to select an existing ObjectiveData asset.
        /// If a valid asset is selected, it becomes the active selection.
        /// </summary>
        private void HandleOpenObjectiveSystemClicked()
        {
            string path = EditorUtility.OpenFilePanel(SELECT_OBJECTIVE_DATA_TITLE, DataPath, ASSET_EXTENSION);
            if (!string.IsNullOrEmpty(path) && path.StartsWith(Application.dataPath))
            {
                path = "Assets" + path[Application.dataPath.Length..];
                ObjectiveData objectiveData = AssetDatabase.LoadAssetAtPath<ObjectiveData>(path);
                if (objectiveData != null)
                {
                    SelectObjectiveData(objectiveData, null);
                }
                else
                {
                    Debug.LogError("Selected file is not a valid ObjectiveData asset.");
                }
            }
        }

        /// <summary>
        /// Invokes a save file panel to let the user create a new ObjectiveData asset.
        /// If a path is selected, a new ObjectiveData instance is created, saved, and selected.
        /// </summary>
        private void HandleNewObjectiveSystemClicked()
        {
            string path = EditorUtility.SaveFilePanelInProject(CREATE_NEW_OBJECTIVE_DATA_TITLE, 
                NEW_OBJECTIVE_DATA_NAME, ASSET_EXTENSION, 
                CREATE_NEW_OBJECTIVE_DATA_MESSAGE, DataPath);

            if (string.IsNullOrEmpty(path))
            {
                return;
            }

            CreateAndSelectObjectiveData(path);
        }
        
        /// <summary>
        /// Creates and selects a new ObjectiveData asset at the given path. If copying from an existing data,
        /// properties are duplicated. Any errors during creation or selection are logged.
        /// </summary>
        /// <param name="path">The asset path where the new ObjectiveData should be saved.</param>
        /// <param name="dataToCopyFrom">Optional: The ObjectiveData to copy properties from.</param>
        private void CreateAndSelectObjectiveData(string path, ObjectiveData dataToCopyFrom = null)
        {
            try
            {
                ObjectiveData newData = CreateInstance<ObjectiveData>();
                if (dataToCopyFrom != null)
                {
                    //TODO: copy
                }
                AssetDatabase.CreateAsset(newData, path);
                AssetDatabase.SaveAssets();
                SelectObjectiveData(newData, null);
                EditorGUIUtility.PingObject(newData);
            }
            catch (Exception e)
            {
                Debug.LogError($"Failed to create or select ObjectiveData: {e.Message}");
            }
        }
        
        #endregion

        #region Utility Methods

        /// <summary>
        /// Selects the specified ObjectiveData and updates the UI.
        /// </summary>
        /// <param name="objectiveData">The ObjectiveData to select.</param>
        /// <param name="scenarioData">Selected scenario data</param>
        private void SelectObjectiveData(ObjectiveData objectiveData, ScenarioData scenarioData)
        {
            if (objectiveData == null)
            {
                ClearSelection();
                return;
            }

            CurrentScenarioData = scenarioData;
            data = objectiveData;
            serializer = new SerializedObjectiveData(data);
            dataView.PopulateView(serializer);
            UpdateObjectiveSystemLabel();
            dataView.Show();
        }

        /// <summary>
        /// Clears the current selection and updates the UI.
        /// </summary>
        private void ClearSelection()
        {
            serializer = null;
            dataView.ClearView();
        }

        /// <summary>
        /// Updates the objective system label with the name of the currently selected ObjectiveData.
        /// </summary
        private void UpdateObjectiveSystemLabel()
        {
            objectiveSystemNameLabel.text = CurrentScenarioData == null ? "Unknown scenario" : CurrentScenarioData.ScenarioNameLocalized;
        }

        /// <summary>
        /// Synchronizes the visibility state of conditions on nodes with the stored preferences.
        /// </summary>
        private void SyncConditionVisibilityState()
        {
            ConditionsVisibleOnNodes = EditorPrefs.GetBool(CONDITIONS_VISIBILITY_KEY, false);
            OnConditionsVisibilityStateChanged?.Invoke();
        }
        
        #endregion

        #region Runtime

        private void HandleOverrideStartObjectiveToggle()
        {
            serializer.data.EditorOverrideStartObjectiveStep = !serializer.data.EditorOverrideStartObjectiveStep;
            OnOverrideStartObjectiveChanged?.Invoke();
        }

        #endregion

        #region Localization

        private void HandleLocalizationEnableToggled()
        {
            LocalizationGlobalSettings.EDITOR_EnableLocalization(!LocalizationGlobalSettings.LocalizationEnabled);
        }

        private void HandleLocalizationWindowOpenClicked()
        {
            LocalizationWindowEditor.OpenLocalizationWindow();
        }

        private void HandleLocalizationRefreshClicked()
        {
            LocalizationModel.EDITOR_RegenerateLocalizationData();
        }

        private void HandleGenerateLocalizationClicked()
        {
            LocalizationUtilities.GenerateIDsForScenarioObjective(data, CurrentScenarioData);
        }

        #endregion

        #region Event Handlers
        
        /// <summary>
        /// Handles selection changes for objective nodes.
        /// </summary>
        /// <param name="objectiveNode">The selected objective node.</param>
        private void HandleNodeSelectionChanged(ObjectiveNode objectiveNode)
        {
            inspectorView.UpdateSelection(serializer, objectiveNode);
        }

        /// <summary>
        /// Handles deep selection changes for objective nodes.
        /// </summary>
        /// <param name="objectiveNode">The deeply selected objective node.</param>
        private void HandleNodeDeepSelected(ObjectiveNode objectiveNode)
        {
            inspectorView.UpdateSelection(serializer, objectiveNode);
            dataView.Hide();
            objectiveEventsGraphView.PopulateView(serializer, objectiveNode.BaseObjective);
            PushEventsBreadcrumb(objectiveNode.BaseObjective.Name);
        }

        /// <summary>
        /// Handles the refresh action from the toolbar.
        /// </summary>
        private void HandleRefreshButtonClicked()
        {
            // Refreshes the current view based on what is active.
            if (dataView.IsActive)
            {
                dataView.Refresh();
            }
            else if (objectiveEventsGraphView.IsActive)
            {
                objectiveEventsGraphView.Refresh();
            }
        }

        /// <summary>
        /// Toggles the visibility of conditions on nodes.
        /// </summary>
        private void HandleToggleConditions()
        {
            ConditionsVisibleOnNodes = !ConditionsVisibleOnNodes;
            EditorPrefs.SetBool(CONDITIONS_VISIBILITY_KEY, ConditionsVisibleOnNodes);
            OnConditionsVisibilityStateChanged?.Invoke();
        }

        /// <summary>
        /// Responds to undo/redo actions.
        /// </summary>
        private void OnUndoRedo()
        {
            // Handles undo/redo operations.
            if (serializer != null)
            {
                dataView.PopulateView(serializer);
            }
        }
        
        #endregion

        #region Breadcrumbs Handlers
        
        /// <summary>
        /// Pushes a breadcrumb for event navigation.
        /// </summary>
        /// <param name="breadcrumbLabel">The label for the breadcrumb.</param>
        private void PushEventsBreadcrumb(string breadcrumbLabel)
        {
            breadcrumbs.PushItem(breadcrumbLabel, HandleRootBreadcrumbClicked);
        }
        
        /// <summary>
        /// Handles clicks on the root breadcrumb, returning to the main view.
        /// </summary>
        private void HandleRootBreadcrumbClicked()
        {
            // Returns to the root view from deeper navigation levels.
            while (breadcrumbs.childCount > 1)
            {
                breadcrumbs.PopItem();
            }

            objectiveEventsGraphView.Hide();
            dataView.Show();
        }
        
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/ObjectiveSystemEditorWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/OptionElement.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a9ca668a8a20469282c03070d1a169c1
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEditor.UIElements;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.Objectives.NodeGraph
{
    /// <summary>
    /// Represents a visual element in the UI for editing an option within a serialized property.
    /// This element includes functionality for deleting the option and dynamically displaying its properties.
    /// </summary>
    [UxmlElement]
    public partial class OptionElement : VisualElement
    {
        public event Action<OptionElement, int> OnOptionElementDeleted;
    
        private const string LABEL = "label";
        private const string DELETE_BUTTON = "delete-button";
        private const string FIELD_CONTAINER = "fields-container";
    
        private Button deleteButton;
        private Label label;
        private VisualElement container;
        private SerializedProperty optionProperty;
        private int arrayIndex;
    
        #region Initialization
    
        /// <summary>
        /// Initializes the option element with the provided serialized property and index.
        /// </summary>
        /// <param name="prop">The serialized property representing the option.</param>
        /// <param name="index">The index of the option in the serialized property array.</param>
        public void InitializeOptionElement(SerializedProperty prop, int index)
        {
            // Setup delete button
            deleteButton = this.Q<Button>(DELETE_BUTTON);
            if (deleteButton != null)
            {
                deleteButton.clicked += HandleDeleteButtonClicked;
            }

            // Setup label and container
            label = this.Q<Label>(LABEL);
            container = this.Q<VisualElement>(FIELD_CONTAINER);
        
            // Initialize properties
            arrayIndex = index;
            optionProperty = prop.GetArrayElementAtIndex(index);
            string typeName = optionProperty.managedReferenceFullTypename;
            string[] splitName = typeName.Split('.');
            string labelText = splitName[^1]
                .Replace("Option", "")
                .Replace("Condition", "")
                .SeparateWords();
            label.text = labelText;

            // Add child fields to the container
            foreach (SerializedProperty child in optionProperty)
            {
                PropertyField field = new(child) { name = $"{child.name}" };
                field.BindProperty(child);
                container.Add(field);
            }
        }
    
        #endregion

        #region Event Handlers

        /// <summary>
        /// Handles the delete button click event, invoking the <see cref="OnOptionElementDeleted"/> event.
        /// </summary>
        private void HandleDeleteButtonClicked()
        {
            OnOptionElementDeleted?.Invoke(this, arrayIndex);
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/OptionElement.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/SerializedObjectiveData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 9211c35c0cfa4cff8db17ee97006adca
# ASMDEF: ldx.framework.editor.dll
# ---
using Ldx.Framework.Systems.ScenarioManagement.Data;
using UnityEditor;

namespace Ldx.Framework.Systems.Objectives.NodeGraph
{
    /// <summary>
    /// Manages serialized data for objectives, providing utility functions to access and
    /// manipulate serialized properties within Unity's editor.
    /// </summary>
    public class SerializedObjectiveData 
    {
        private const string S_PROP_ID = "id";
        private const string S_PROP_OBJECTIVES = "objectives";
        private const string S_PROP_CHILD_OBJECTIVES = "childObjectives";
        private const string S_PROP_EVENT_DATA_CONTAINER = "eventDataContainer";
        private const string S_PROP_EVENT_ENUMERABLE = "objectiveEventData";
        private const string S_PROP_OBJECTIVE_OPTIONS = "objectiveOptions";
        private const string S_PROP_OBJECTIVE_CONDITIONS = "conditions";
    
        public SerializedObject serializedObject;
        public readonly ObjectiveData data;
    
        public SerializedProperty Objectives => serializedObject.FindProperty(S_PROP_OBJECTIVES);
    
        public SerializedObjectiveData(ObjectiveData data)
        {
            serializedObject = new SerializedObject(data);
            this.data = data;
        }

        /// <summary>
        /// Updates the internal state of the serialized object to match the current state of the data model.
        /// </summary>
        public void UpdateSerializedObject()
        {
            serializedObject = new SerializedObject(data);
        }
    
        /// <summary>
        /// Finds the serialized property for a specific objective.
        /// </summary>
        /// <param name="array">The serialized property array of objectives.</param>
        /// <param name="baseObjective">The objective to find.</param>
        /// <returns>The serialized property corresponding to the specified objective, or null if not found.</returns>
        public SerializedProperty FindObjective(SerializedProperty array, BaseObjective baseObjective)
        {
            for (int i = 0; i < array.arraySize; ++i)
            {
                SerializedProperty current = array.GetArrayElementAtIndex(i);
                if (current.FindPropertyRelative(S_PROP_ID).stringValue == baseObjective.ID)
                {
                    return current;
                }

                SerializedProperty childrenArray = current.FindPropertyRelative(S_PROP_CHILD_OBJECTIVES);
                SerializedProperty foundChild = FindInChildObjectives(childrenArray, baseObjective.ID);
                if (foundChild != null) return foundChild;
            }
            return null;
        }
    
        /// <summary>
        /// Finds the serialized property for a specific objective event.
        /// </summary>
        /// <param name="array">The serialized property array of objectives.</param>
        /// <param name="baseObjective">The base objective containing the event.</param>
        /// <param name="eventData">The event data to find.</param>
        /// <returns>The serialized property corresponding to the specified event data, or null if not found.</returns>
        public SerializedProperty FindObjectiveEvent(SerializedProperty array, BaseObjective baseObjective, ObjectiveEventData eventData)
        {
            SerializedProperty objectiveProperty = FindObjective(array, baseObjective);
            SerializedProperty eventContainerProperty = objectiveProperty?.FindPropertyRelative(S_PROP_EVENT_DATA_CONTAINER);
            return FindInEventEnumerable(eventContainerProperty, eventData.ID);
        }
    
        /// <summary>
        /// Finds the serialized property for objective options related to a specific objective.
        /// </summary>
        /// <param name="array">The serialized property array of objectives.</param>
        /// <param name="baseObjective">The objective to find options for.</param>
        /// <returns>The serialized property for the objective options, or null if not found.</returns>
        public SerializedProperty FindObjectiveOptions(SerializedProperty array, BaseObjective baseObjective)
        {
            SerializedProperty nodeProp = FindObjective(array, baseObjective);
            return nodeProp.FindPropertyRelative(S_PROP_OBJECTIVE_OPTIONS);
        }
    
        /// <summary>
        /// Finds the serialized property for objective conditions related to a specific objective.
        /// </summary>
        /// <param name="array">The serialized property array of objectives.</param>
        /// <param name="baseObjective">The objective to find conditions for.</param>
        /// <returns>The serialized property for the objective conditions, or null if not found.</returns>
        public SerializedProperty FindObjectiveConditions(SerializedProperty array, BaseObjective baseObjective)
        {
            SerializedProperty nodeProp = FindObjective(array, baseObjective);
            return nodeProp.FindPropertyRelative(S_PROP_OBJECTIVE_CONDITIONS);
        }
    
        #region Helper Methods
    
        /// <summary>
        /// Searches for an objective within the child objectives array by ID.
        /// </summary>
        /// <param name="childrenArray">The serialized property array of child objectives.</param>
        /// <param name="id">The ID of the objective to find.</param>
        /// <returns>The serialized property of the found child objective, or null if not found.</returns>
        private SerializedProperty FindInChildObjectives(SerializedProperty childrenArray, string id)
        {
            if (childrenArray == null) return null;

            for (int j = 0; j < childrenArray.arraySize; j++)
            {
                SerializedProperty subObjective = childrenArray.GetArrayElementAtIndex(j);
                if (subObjective.FindPropertyRelative(S_PROP_ID).stringValue == id)
                {
                    return subObjective;
                }
            }
            return null;
        }
    
        /// <summary>
        /// Searches for event data within the event enumerable property by event data ID.
        /// </summary>
        /// <param name="eventContainerProperty">The container property of the event data.</param>
        /// <param name="id">The ID of the event data to find.</param>
        /// <returns>The serialized property of the found event data, or null if not found.</returns>
        private SerializedProperty FindInEventEnumerable(SerializedProperty eventContainerProperty, string id)
        {
            if (eventContainerProperty == null) return null;

            SerializedProperty eventEnumerableProperty = eventContainerProperty.FindPropertyRelative(S_PROP_EVENT_ENUMERABLE);
            for (int j = 0; j < eventEnumerableProperty.arraySize; j++)
            {
                SerializedProperty eventDataProperty = eventEnumerableProperty.GetArrayElementAtIndex(j);
                if (eventDataProperty != null && eventDataProperty.FindPropertyRelative(S_PROP_ID).stringValue == id)
                {
                    return eventDataProperty;
                }
            }
            return null;
        }
    
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/SerializedObjectiveData.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/TriggerEventNode.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: ca7788f32a484f218ed53bfc47dda7f2
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Reflection;
using Ldx.Framework.Systems.NodeGraph;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor.Experimental.GraphView;
using UnityEngine;
using UnityEngine.UIElements;

namespace Ldx.Framework.Systems.Objectives.NodeGraph
{
    /// <summary>
    /// Serves as node specific class for trigger event nodes within the objective graph. 
    /// This class is intended for inheritance by more specific trigger event nodes 
    /// to allow for differentiation between various types of trigger events in the system.
    /// </summary>
    public class BaseTriggerEventNode : TriggerEventNode { }

    /// <summary>
    /// Represents a node specific to tracking events within the objective graph. 
    /// This node type facilitates the creation and management of tracking event triggers, 
    /// allowing users to define and configure tracking-related behaviors in their objectives.
    /// </summary>
    public class TriggerTrackingEventNode : TriggerEventNode { }

    /// <summary>
    /// Represents a node specific to dialog events within the objective graph. 
    /// This node type facilitates the creation and management of dialog event triggers, 
    /// allowing users to define and configure dialog-related behaviors in their objectives.
    /// </summary>
    public class TriggerDialogEventNode : TriggerEventNode { }

    /// <summary>
    /// Represents a node specific to interaction events within the objective graph. 
    /// </summary>
    public class InteractionTriggerEventNode : TriggerEventNode
    {
        public class InteractionNodeParam : NodeParam
        {
            public ObjectiveEventData.InteractionEventType InteractionEventType { get; }
            
            public InteractionNodeParam(Type type, string id, ObjectiveEventData.InteractionEventType interactionEventType) : base(type, id)
            {
                InteractionEventType = interactionEventType;
            }
        }
    }

    /// <summary>
    /// Represents a node in the graph that is responsible for handling trigger events.
    /// This node allows for converting between different types of trigger events and configuring them within the graph.
    /// It is not duplicatable, supporting specific custom actions through its context menu.
    /// </summary>
    public class TriggerEventNode : BaseNode
    {
        #region Events
    
        public static event Action<TriggerEventNode> OnAnyTriggerEventNodeDeleteClicked;
        public static event Action<TriggerEventNode, TriggerEventInfo> OnAnyTriggerEventConvertSelected;
    
        #endregion
    
        private const string CREATE_EVENT_TITLE = "Create event";
        private const string CONVERT_TO_ACTION_TITLE = "Convert to/{0}";
        private const string CONVERT_TO_TRACKING_EVENT_ACTION_TITLE = "Convert to/Tracking Event/{0}/{1}";
        private const string CONVERT_TO_DIALOG_ACTION_TITLE = "Convert to/Dialog/{0}/{1}";
        private const string GLOBAL_EVENT = "Global";
        private const string SCENARIO_EVENT = "Scenario";
    
        public SerializedObjectiveData serializer;
        public BaseObjective baseObjective;
        public TriggerEventInfo triggerEventInfo;

        protected override bool IsDuplicatable => false;
        public override Rect SavedNodePosition => baseObjective.GetTriggerEventInfoNodePosition(triggerEventInfo);

        #region Initialization
    
        /// <summary>
        /// Initializes the trigger event node with necessary data.
        /// </summary>
        /// <param name="graphView">The graph view to which this node belongs.</param>
        /// <param name="objectiveData">The serialized objective data associated with this node.</param>
        /// <param name="baseObjective">The base objective related to this trigger event.</param>
        /// <param name="info">The trigger event information for this node.</param>
        public void Initialize(BaseGraphView graphView, 
            SerializedObjectiveData objectiveData,
            BaseObjective baseObjective,
            TriggerEventInfo info)
        {
            serializer = objectiveData;
            this.baseObjective = baseObjective;
            triggerEventInfo = info;
            Initialize(graphView, triggerEventInfo.GetTriggerName(), info.GetHashCode().ToString());
        }

        /// <summary>
        /// Initializes the input and output ports for the node.
        /// </summary>
        protected override void InitializePorts()
        {
            base.InitializePorts();
            CreateAndAddPort(Direction.Input, isVertical: true);
            PortView outputPort = CreateAndAddPort(Direction.Output, isVertical: true);

            NodeDescriptions nodeDescriptions = new(CREATE_EVENT_TITLE);

            // Creating submenu for each port type
            foreach (Type eventType in GetDerivedObjectiveEventTypes())
            {
                bool hasCategory = TryGetObjectiveCategoryName(eventType, out string category);
                string menuItemName = "";
                if (hasCategory)
                {
                    menuItemName += $"{category}/";
                }
                menuItemName += eventType.Name.Replace("EventData", "").SeparateWords();
            
                nodeDescriptions.nodePerMenuTitle.Add(menuItemName, new(eventType));
            }
        
            portNodeDescriptionsMap.Add(outputPort, nodeDescriptions);
        }
    
        #endregion
    
        #region Custom Context Menu
    
        /// <summary>
        /// Adds custom context menu items to the node, including options for converting to tracking and dialog events.
        /// </summary>
        /// <param name="evt">The contextual menu populate event.</param>
        protected override void AddCustomContextMenuItems(ContextualMenuPopulateEvent evt)
        {
            base.AddCustomContextMenuItems(evt);
            AddTrackingEventMenuItems(evt);
            AddDialogEventMenuItems(evt);
        }

        /// <summary>
        /// Adds tracking event options to the node's context menu.
        /// </summary>
        /// <param name="evt">The contextual menu populate event.</param>
        private void AddTrackingEventMenuItems(ContextualMenuPopulateEvent evt)
        {
            evt.menu.AppendAction(string.Format(CONVERT_TO_ACTION_TITLE, ObjectiveEventData.TriggerEventType.Begin.ToString()), _ => HandleConvertSelected(ObjectiveEventData.TriggerEventType.Begin));
            evt.menu.AppendAction(string.Format(CONVERT_TO_ACTION_TITLE, ObjectiveEventData.TriggerEventType.Complete.ToString()), _ => HandleConvertSelected(ObjectiveEventData.TriggerEventType.Complete));
        
            CompoundIDInfoContainer list = LdxIdSettings.GetCompoundIDList(LdxIdSettings.IdType.TrackingEvent);
            IDInfoContainer globalList = list.GlobalContainer;
            IDInfoContainer localList = list.LocalContainer;

            if (globalList != null)
            {
                foreach (IDInfo idInfo in globalList)
                {
                    evt.menu.AppendAction(
                        string.Format(CONVERT_TO_TRACKING_EVENT_ACTION_TITLE, GLOBAL_EVENT, idInfo.Description),
                        _ => HandleConvertSelected(ObjectiveEventData.TriggerEventType.TrackingEvent, idInfo.ID));
                }
            }

            if (localList != null)
            {
                foreach (IDInfo idInfo in localList)
                {
                    evt.menu.AppendAction(
                        string.Format(CONVERT_TO_TRACKING_EVENT_ACTION_TITLE, SCENARIO_EVENT, idInfo.Description),
                        _ => HandleConvertSelected(ObjectiveEventData.TriggerEventType.TrackingEvent, idInfo.ID));
                }
            }
        }

        /// <summary>
        /// Adds dialog event options to the node's context menu.
        /// </summary>
        /// <param name="evt">The contextual menu populate event.</param>
        private void AddDialogEventMenuItems(ContextualMenuPopulateEvent evt)
        {
            CompoundIDInfoContainer listDialog = LdxIdSettings.GetCompoundIDList(LdxIdSettings.IdType.Dialog);
            IDInfoContainer globalListDialog = listDialog.GlobalContainer;
            IDInfoContainer localListDialog = listDialog.LocalContainer;

            if (globalListDialog != null)
            {
                foreach (IDInfo idInfo in globalListDialog)
                {
                    evt.menu.AppendAction(string.Format(CONVERT_TO_DIALOG_ACTION_TITLE, GLOBAL_EVENT, idInfo.Description),
                        _ => HandleConvertSelected(ObjectiveEventData.TriggerEventType.DialogCompleted,
                            dialogId: idInfo.ID));
                }
            }

            if (localListDialog != null)
            {
                foreach (IDInfo idInfo in localListDialog)
                {
                    evt.menu.AppendAction(string.Format(CONVERT_TO_DIALOG_ACTION_TITLE, SCENARIO_EVENT, idInfo.Description),
                        _ => HandleConvertSelected(ObjectiveEventData.TriggerEventType.DialogCompleted,
                            dialogId: idInfo.ID));
                }
            }
        }
    
        #endregion

        #region Node Actions

        /// <summary>
        /// Handles the conversion of the current node to a selected trigger event type,
        /// invoking the appropriate event to notify other components of the conversion.
        /// </summary>
        /// <param name="eventType">The trigger event type to convert to.</param>
        /// <param name="trackingEventId">Optional. The ID of the tracking event, if applicable.</param>
        /// <param name="dialogId">Optional. The ID of the dialog event, if applicable.</param>
        private void HandleConvertSelected(ObjectiveEventData.TriggerEventType eventType,
            string trackingEventId = "",
            string dialogId = "")
        {
            OnAnyTriggerEventConvertSelected?.Invoke(this, new TriggerEventInfo(eventType, trackingEventId, dialogId));
        }

        /// <summary>
        /// Invokes the deletion event when the node is deleted.
        /// </summary>
        protected override void DeleteNode()
        {
            OnAnyTriggerEventNodeDeleteClicked?.Invoke(this);
        }

        /// <summary>
        /// The node is not duplicatable; thus, this method is intentionally left empty.
        /// </summary>
        protected override void DuplicateNode()
        {
            // Cannot be duplicated
        }
    
        #endregion
    
        #region Utility Methods

        /// <summary>
        /// Retrieves a collection of types derived from <see cref="ObjectiveEventData"/> found across all loaded assemblies.
        /// </summary>
        /// <returns>A collection of <see cref="Type"/> objects representing all derived objective event data types.</returns>
        private IEnumerable<Type> GetDerivedObjectiveEventTypes()
        {
            List<Type> derivedTypes = new();
            foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                foreach (Type type in assembly.GetTypes())
                {
                    if (type.IsSubclassOf(typeof(ObjectiveEventData)) && 
                        !type.IsAbstract &&
                        type.GetCustomAttribute<ObsoleteAttribute>() == null)
                    {
                        derivedTypes.Add(type);
                    }
                }
            }
            return derivedTypes;
        }

        /// <summary>
        /// Attempts to retrieve the category name for a given objective event type using the <see cref="ObjectiveCategoryAttribute"/>.
        /// </summary>
        /// <param name="eventType">The event type for which to retrieve the category name.</param>
        /// <param name="category">The category name, if found.</param>
        /// <returns>True if the category name is found; otherwise, false.</returns>
        private bool TryGetObjectiveCategoryName(Type eventType, out string category)
        {
            // Check if the type is a subclass of ObjectiveEventData and has the ObjectiveCategoryAttribute
            ObjectiveCategoryAttribute attribute = eventType.GetCustomAttribute<ObjectiveCategoryAttribute>();
            category = null;
            if (attribute != null)
            {
                // Return the name of the category
                category = attribute.Category;
                return true;
            }

            return false;
        }
    
        #endregion

        #region Positioning
    
        /// <summary>
        /// Sets the new position of the node within the graph.
        /// </summary>
        /// <param name="newPos">The new position to set.</param>
        public override void SetPosition(Rect newPos)
        {
            base.SetPosition(newPos);
            baseObjective.SetTriggerEventInfoNodePosition(triggerEventInfo, newPos);
        }
    
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/NodeGraph/TriggerEventNode.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/Tracking/LdxTrackingManagerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6e9854d8ca054b0e9d98723b76708169
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.Objectives.Tracking
{
    [CustomEditor(typeof(LdxTrackingManager))]
    public class LdxTrackingManagerEditor : Editor
    {
        // TODO: do this better, a lot of copy/paste here
        private bool isNotifiersExpanded;
        private bool isUnityEventsExpanded;
        private bool isObjectGroupExpanded;
        
        private Dictionary<IDInfo, List<TrackingEventNotifier>> infoToNotifiersMap = new();
        
        private Dictionary<IDInfo, List<LdxTrackingUnityEventListener>> infoToUnityEventListenersMap = new();

        private Dictionary<IDInfo, List<LdxObjectGroup>> infoToObjectGroupMap = new();
        
        private LdxTrackingManager Target => (LdxTrackingManager)target;

        private void OnEnable()
        {
            Target.EDITOR_OnEnable();
            EditorUtility.SetDirty(Target);
            if (LdxIdSettings.GlobalInstance == null)
            {
                return;
            }

            CompoundIDInfoContainer idInfoContainer = LdxIdSettings.GetCompoundIDList(LdxIdSettings.IdType.TrackingEvent);
            Dictionary<string, IDInfo> idToInfoMap = idInfoContainer.ToDictionary(l => l.ID, l => l);
            infoToNotifiersMap = idInfoContainer.ToDictionary(l => l, l => new List<TrackingEventNotifier>());
            foreach (TrackingEventNotifier n in Target.Notifiers)
            {
                if (!idToInfoMap.TryGetValue(n.EventToBroadcastID, out IDInfo info))
                {
                    continue;
                }

                infoToNotifiersMap[info].Add(n);
            }
            
            infoToUnityEventListenersMap = idInfoContainer.ToDictionary(l => l, l => new List<LdxTrackingUnityEventListener>());
            LdxTrackingUnityEventListener[] uEvents = FindObjectsByType<LdxTrackingUnityEventListener>(FindObjectsInactive.Include, FindObjectsSortMode.None);
            foreach (LdxTrackingUnityEventListener u in uEvents)
            {
                IDInfo info = idInfoContainer.FirstOrDefault(i => i.ID == u.TargetEvent);
                if (info == null || !infoToUnityEventListenersMap.ContainsKey(info))
                {
                    continue;
                }

                infoToUnityEventListenersMap[info].Add(u);
            }

            CompoundIDInfoContainer groupIdInfoContainer = LdxIdSettings.GetCompoundIDList(LdxIdSettings.IdType.ObjectGroup);

            infoToObjectGroupMap = groupIdInfoContainer.ToDictionary(o => o, o => new List<LdxObjectGroup>());
            LdxObjectGroup[] groups = FindObjectsByType<LdxObjectGroup>(FindObjectsInactive.Include, FindObjectsSortMode.None);
            foreach (LdxObjectGroup g in groups)
            {
                IDInfo info = groupIdInfoContainer.FirstOrDefault(i => i.ID == g.ObjectGroup);
                if (info == null || !infoToObjectGroupMap.ContainsKey(info))
                {
                    continue;
                }
                infoToObjectGroupMap[info].Add(g);
            }
        }

        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
            DrawEventNotifierInfo();
            DrawUnityEventListenersInfo();
            DrawObjectGroupsInfo();
        }

        private void DrawEventNotifierInfo()
        {
            if (infoToNotifiersMap.Count < 1)
            {
                return;
            }

            using (new EditorGUILayout.VerticalScope())
            {
                isNotifiersExpanded = EditorGUILayout.Foldout(isNotifiersExpanded, "Events and Corresponding Notifiers");
                if (!isNotifiersExpanded)
                {
                    return;
                }
                foreach (KeyValuePair<IDInfo, List<TrackingEventNotifier>> pair in infoToNotifiersMap)
                {
                    if (pair.Value.Count == 0)
                    {
                        continue;
                    }

                    EditorGUILayout.LabelField("", GUI.skin.horizontalSlider);
                    EditorGUILayout.LabelField(pair.Key.Description, EditorStyles.boldLabel);
                    using (new EditorGUILayout.HorizontalScope())
                    {
                        foreach (TrackingEventNotifier n in pair.Value)
                        {
                            if (GUILayout.Button($"{n.name}, ", EditorStyles.linkLabel))
                            {
                                Selection.activeObject = n;
                            }
                        }
                    }
                }
            }
        }

        private void DrawUnityEventListenersInfo()
        {
            if (infoToUnityEventListenersMap.Count < 1)
            {
                return;
            }

            using (new EditorGUILayout.VerticalScope())
            {
                isUnityEventsExpanded = EditorGUILayout.Foldout(isUnityEventsExpanded, "Unity Event Listener");
                if (!isUnityEventsExpanded)
                {
                    return;
                }

                foreach (KeyValuePair<IDInfo, List<LdxTrackingUnityEventListener>> pair in infoToUnityEventListenersMap)
                {
                    if (pair.Value.Count == 0)
                    {
                        continue;
                    }

                    EditorGUILayout.LabelField("", GUI.skin.horizontalSlider);
                    EditorGUILayout.LabelField(pair.Key.Description, EditorStyles.boldLabel);
                    using (new EditorGUILayout.HorizontalScope())
                    {
                        foreach (LdxTrackingUnityEventListener n in pair.Value)
                        {
                            if (GUILayout.Button($"{n.name}, ", EditorStyles.linkLabel))
                            {
                                Selection.activeObject = n;
                            }
                        }
                    }
                }
            }
        }
        
        private void DrawObjectGroupsInfo()
        {
            if (infoToObjectGroupMap.Count < 1)
            {
                return;
            }

            using (new EditorGUILayout.VerticalScope())
            {
                isObjectGroupExpanded = EditorGUILayout.Foldout(isObjectGroupExpanded, "Object Groups");
                if (!isObjectGroupExpanded)
                {
                    return;
                }

                foreach (KeyValuePair<IDInfo, List<LdxObjectGroup>> pair in infoToObjectGroupMap)
                {
                    if (pair.Value.Count == 0)
                    {
                        continue;
                    }

                    EditorGUILayout.LabelField("", GUI.skin.horizontalSlider);
                    EditorGUILayout.LabelField(pair.Key.Description, EditorStyles.boldLabel);
                    using (new EditorGUILayout.HorizontalScope())
                    {
                        foreach (LdxObjectGroup n in pair.Value)
                        {
                            if (GUILayout.Button($"{n.name}, ", EditorStyles.linkLabel))
                            {
                                Selection.activeObject = n;
                            }
                        }
                    }
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Objectives/Tracking/LdxTrackingManagerEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Player/PlayerRig/PlayerRigOverridesContainerDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a8a25f64a37840679b08a769cd207040
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.Player.PlayerRig
{
    /// <summary>
    /// Drawer for a player rig overrides container
    /// </summary>
    [CustomPropertyDrawer(typeof(PlayerRigOverridesContainer), true)]
    public class PlayerRigOverridesContainerDrawer : PropertyDrawer
    {
        private List<int> removedIndecies = new List<int>();
        private HashSet<string> typeNamesSet = new HashSet<string>();
            
        public override void OnGUI(Rect position, SerializedProperty property,
            GUIContent label)
        {
            typeNamesSet.Clear();
            SerializedProperty dataListProp = property.FindPropertyRelative("overrides");
            EditorGUI.BeginChangeCheck();
            EditorGUI.BeginProperty(position, new GUIContent(), property);
            using (new EditorGUILayout.VerticalScope())
            {
                EditorGUILayout.LabelField(new GUIContent("Player Rig Overrides"));
                EditorGUI.indentLevel++;
                for (int i = 0; i < dataListProp.arraySize; i++)
                {
                    SerializedProperty p = dataListProp.GetArrayElementAtIndex(i);
                    typeNamesSet.Add(p.managedReferenceFullTypename.Split('.').Last());
                    p.isExpanded = true;
                    using (new EditorGUILayout.HorizontalScope())
                    {
                        if (GUILayout.Button(" - ", GUILayout.Width(20)))
                        {
                            removedIndecies.Add(i);
                        }

                        EditorGUILayout.PropertyField(p, new GUIContent(GetPropertyTypeName(p)), true);
                    }
                }
            }

            for (int i = removedIndecies.Count - 1; i >= 0; i--)
            {
                dataListProp.DeleteArrayElementAtIndex(removedIndecies[i]);
            }

            if (removedIndecies.Count > 0)
            {
                dataListProp.serializedObject.ApplyModifiedProperties();
                removedIndecies.Clear();
            } 
            
            EditorGUI.indentLevel--;
            
            using (new EditorGUILayout.HorizontalScope())
            {
                GUILayout.Space(10);
                if (GUILayout.Button("+", GUILayout.Width(20)))
                {
                    GenericMenu menu = new GenericMenu();
                    var subclassTypes = Assembly
                        .GetAssembly(typeof(PlayerRigOverride))
                        .GetTypes()
                        .Where(t => !typeNamesSet.Contains(t.Name) && t.IsSubclassOf(typeof(PlayerRigOverride)) && !t.IsAbstract);
                    foreach (var t in subclassTypes)
                    {
                        menu.AddItem(new GUIContent(t.Name.Replace("RigOverride", "")
                            .SeparateWords()), false, () => HandleAddingOverride(property, t));
                    }

                    menu.ShowAsContext();
                }
            }

            EditorGUI.EndProperty();
            if (EditorGUI.EndChangeCheck())
            {
                property.serializedObject.ApplyModifiedProperties();
            }
        }

        private void HandleAddingOverride(SerializedProperty property, Type t)
        {
            SerializedProperty p = property.FindPropertyRelative("overrides");
            p.arraySize++;
            p.GetArrayElementAtIndex(p.arraySize - 1).managedReferenceValue = Activator.CreateInstance(t);
            p.serializedObject.ApplyModifiedProperties();

        }

        private string GetPropertyTypeName(SerializedProperty property)
        {
            string[] segments = property.type.Split(new[] { '<', '>' });
            if (segments.Length < 2)
            {
                return "";
            }

            return segments[1].Replace("RigOverride", "").SeparateWords();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Player/PlayerRig/PlayerRigOverridesContainerDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Player/RandomizedStartPointControllerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c8541eb3bf724ec3bf2eaa04416e6ef3
# ASMDEF: ldx.framework.editor.dll
# ---
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.Player
{
    [CustomEditor(typeof(RandomizedStartPointController))]
    public class RandomizedStartPointControllerEditor : Editor
    {
        private RandomizedStartPointController Target => (RandomizedStartPointController)target;
        
        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
            DrawAddButton();
        }

        private void DrawAddButton()
        {
            LdxEditorHelper.DrawHorizontalSeparator();
            if (GUILayout.Button("Add Point"))
            {
                Target.EDITOR_AddPoint();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Player/RandomizedStartPointControllerEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Player/StartPointEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e6ee3b60d0a74d0c9334acfa2e8a278e
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.Player
{
    /// <summary>
    /// Inspector editor for PlayerStartPoint
    /// Mostly used to draw the camera preview
    /// </summary>
    [CustomEditor(typeof(BaseStartPointMarker), editorForChildClasses: true)]
    public class StartPointEditor : Editor
    {
        private const float PREVIEW_SCALE_FACTOR = 0.33f;
        private const int PREVIEW_BORDER_SIZE = 10;
        private static GUIStyle previewStyle;
        private static GUIStyle messageStyle;

        private BaseStartPointMarker Target => (BaseStartPointMarker)target;
        private UnityEngine.Camera PreviewCamera { get; set; }

        private static GUIStyle PreviewStyle
        {
            get
            {
                if (previewStyle == null)
                {
                    previewStyle = new GUIStyle(GUI.skin.box);
                    previewStyle.border = new RectOffset(PREVIEW_BORDER_SIZE, PREVIEW_BORDER_SIZE, PREVIEW_BORDER_SIZE, PREVIEW_BORDER_SIZE);
                    Texture2D txt = new Texture2D(1, 1);
                    Color c = new Color(0.7f, 0.5f, 0.8f, 0.2f);
                    txt.SetPixel(0,0, c);
                    txt.Apply();
                    previewStyle.normal.background = txt;
                }

                return previewStyle;
            }
        }

        private static GUIStyle MessageStyle
        {
            get
            {
                if (messageStyle == null)
                {
                    messageStyle = new GUIStyle(EditorStyles.helpBox);
                    messageStyle.normal.textColor = Color.red;
                    messageStyle.hover.textColor = Color.red;
                    messageStyle.active.textColor = Color.red;
                }

                return messageStyle;
            }
        }
        
        private void OnEnable()
        {
            PreviewCamera = Target.EDITOR_GetPreviewCamera();
            PreviewCamera.forceIntoRenderTexture = true;
        }
        
        private void OnDisable()
        {
            if (PreviewCamera == null)
            {
                return;
            }
            
            PreviewCamera.targetTexture.Release();
            DestroyImmediate(PreviewCamera.gameObject);
        }
        
        private void OnSceneGUI()
        {
            SceneView sv = SceneView.currentDrawingSceneView;
            if (sv == null) return; // Ensure we have a valid SceneView

            Vector2 svSize = new Vector2(sv.position.width, sv.position.height);

            int width = (int)(svSize.x * PREVIEW_SCALE_FACTOR);
            if (PreviewCamera.targetTexture == null) return;

            // Calculate the height of the preview maintaining the aspect ratio
            int imageHeight = (int)(width * (PreviewCamera.targetTexture.height / (float)PreviewCamera.targetTexture.width));

            // Adjust the position to ensure it's within the visible area of the SceneView
            // Subtracting the width and height of the preview from the SceneView size to position it in the bottom-right corner
            Rect previewRect = new Rect(svSize.x - width - PREVIEW_BORDER_SIZE, // Add a border size offset
                svSize.y - imageHeight - PREVIEW_BORDER_SIZE, // Add a border size offset
                width, 
                imageHeight);

            // Draw the preview area
            GUILayout.BeginArea(previewRect);
            GUILayout.Box(PreviewCamera.targetTexture, PreviewStyle, GUILayout.Width(width), GUILayout.Height(imageHeight));
            GUILayout.EndArea();
            if (Target.DrawnOverMessage != null)
            {
                GUI.Label(previewRect, Target.DrawnOverMessage, MessageStyle);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Player/StartPointEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Save/LdxSaveSystemEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 2acc2afa7b3c84944926bfa59bf454b1
# ASMDEF: ldx.framework.editor.dll
# ---
#if UNITY_EDITOR

using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.Save
{
    [CustomEditor(typeof(LdxSaveSystem))]
    public class LdxSaveSystemEditor : Editor
    {
        public override void OnInspectorGUI()
        {
            DrawDefaultInspector();

            GUI.backgroundColor = Color.green;
            int buttonWidth = 250;

            GUILayout.BeginHorizontal();

            GUILayout.Space(20);
            GUILayout.Space(Screen.width / 2 - buttonWidth / 2);

            LdxSaveSystem saveSystem = (LdxSaveSystem)target;

            if (GUILayout.Button("Reset progress", GUILayout.Width(buttonWidth)) && Application.isPlaying)
            {
                saveSystem.ResetSceneData();
            }
            GUILayout.EndHorizontal();
        }
    }
}

#endif
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Save/LdxSaveSystemEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioManagement/Data/PlayerRigDataEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 42ed4f3fefff477cb53411bd9ad0e0ba
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace  Ldx.Framework.Systems.ScenarioManagement.Data
{
    [CustomEditor(typeof(PlayerRigData))]
    public class PlayerRigDataEditor : Editor
    {
        public override void OnInspectorGUI()
        {
            SerializedProperty overridesProp = serializedObject.FindProperty("overrides");
            EditorGUILayout.PropertyField(overridesProp, new GUIContent(""), true);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioManagement/Data/PlayerRigDataEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioManagement/RuntimeScenarioLoaderEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7327435c6187466b91df6df1e1fc3395
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections;
using System.Collections.Generic;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Unity.EditorCoroutines.Editor;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.ScenarioManagement
{
    public class RuntimeScenarioLoaderEditor : EditorWindow
    {
        private int loadAmount = 5;
        private float realTimeSecondsWait = 5;
        private int loadingsLeft = 5;
        private EditorCoroutine loadingRoutine;
        
        [MenuItem("LogicalDox/Scenario/Scenario Loader (Runtime)")]
        public static void ShowWindow()
        {
            GetWindow<RuntimeScenarioLoaderEditor>("Scenario Loader");
        }
        
        [MenuItem("LogicalDox/Scenario/Scenario Loader (Runtime)", isValidateFunction:true)]
        public static bool IsEnabled()
        {
            return Application.isPlaying;
        }
        
        private void OnGUI()
        {
            if (GlobalData.Instance == null)
            {
                GUILayout.Label("No global data found.");
                return;
            }

            bool isPlaying = EditorApplication.isPlaying;
            
            if (!isPlaying)
            {
                EditorGUILayout.HelpBox("Start the game to load scenarios.", MessageType.Info);
                GUI.enabled = false;
            }

            foreach (ScenarioData scenario in GlobalData.Instance.GetScenarioDataList())
            {
                if (GUILayout.Button(scenario.ScenarioNameLocalized))
                {
                    ScenarioManager.Instance.LoadScenario(scenario.ID);
                }
            }
            
            GUILayout.Label("Scenario loading testing");
            EditorGUILayout.HelpBox("This section will load random scenario X times.", MessageType.Info);

            loadAmount = EditorGUILayout.IntField("Load amount", loadAmount);
            realTimeSecondsWait = EditorGUILayout.FloatField("Real time seconds wait after load", realTimeSecondsWait);
            
            GUILayout.BeginHorizontal();
            
            GUI.enabled = isPlaying && loadingRoutine == null;
            if (GUILayout.Button("Start loading routine"))
            {
                loadingRoutine = EditorCoroutineUtility.StartCoroutineOwnerless(LoadingRoutine());
            }
            
            GUI.enabled = isPlaying && loadingRoutine != null;
            if (GUILayout.Button("Stop loading routine"))
            {
                EditorCoroutineUtility.StopCoroutine(loadingRoutine);
                loadingRoutine = null;
            }
            
            GUILayout.EndHorizontal();

            if (loadingRoutine != null)
            {
                GUILayout.Label($"Loading Routine in action. {loadingsLeft} loadings left");
            }

            GUI.enabled = true; // Re-enable GUI for any future controls
        }

        private IEnumerator LoadingRoutine()
        {
            loadingsLeft = loadAmount;
            List<ScenarioData> datas = GlobalData.Instance.GetScenarioDataList();
            ScenarioData prevScenario = null;
            bool isLoading;

            ScenarioManager.OnLoadingFinished -= handleScenarioLoadingFinished;
            ScenarioManager.OnLoadingFinished += handleScenarioLoadingFinished;
            
            while (loadingsLeft > 0)
            {
                ScenarioData scenario = null;
                while (scenario == null)
                {
                    scenario = datas[Random.Range(0, datas.Count)];
                    if (prevScenario != null && scenario == prevScenario)
                    {
                        scenario = null;
                    }
                }
                
                ScenarioManager.Instance.LoadScenario(scenario.ID);
                isLoading = true;

                prevScenario = scenario;
                yield return new WaitUntil(() => isLoading == false);
                yield return new WaitForSecondsRealtime(realTimeSecondsWait);
                loadingsLeft--;
            }
            
            void handleScenarioLoadingFinished(ScenarioManager scenarioManager)
            {
                isLoading = false;
            }
            
            ScenarioManager.OnLoadingFinished -= handleScenarioLoadingFinished;
            loadingRoutine = null;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioManagement/RuntimeScenarioLoaderEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioManagement/SingleScenarioPlayModeEditorFeature.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c8fad4b6998848b38a919b0b85794b4e
# ASMDEF: ldx.framework.editor.dll
# ---
#if UNITY_EDITOR
using System;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using UnityEditor;
using UnityEditor.SceneManagement;
using Object = UnityEngine.Object;

namespace Ldx.Framework.Systems.ScenarioManagement
{
    /// <summary>
    /// Editor feature for when PlayMode is entered and a single
    /// scenario is being tested
    /// Loads the bootstrapper to have the setup and loads associated scenario data
    /// </summary>
    public class SingleScenarioPlayModeEditorFeature
    {
        private const string KEY_CUSTOM_LOADING_MODE = "SCENARIO_LOADING_CUSTOM_LOADING_MODE";
        private const string KEY_SCENARIO_DATA_TYPE = "SCENARIO_LOADING_DATA_TYPE";
        private const string KEY_SCENARIO_SCENE_NAME = "SCENARIO_LOADING_SCENE_NAME";

        private static bool IsCustomLoadingMode
        {
            get => EditorPrefs.GetBool(KEY_CUSTOM_LOADING_MODE, false);
            set => EditorPrefs.SetBool(KEY_CUSTOM_LOADING_MODE, value);
        }

        private static ScenarioDataType ScenarioDataType
        {
            get => (ScenarioDataType)EditorPrefs.GetInt(KEY_SCENARIO_DATA_TYPE, 0);
            set => EditorPrefs.SetInt(KEY_SCENARIO_DATA_TYPE, (int)value);
        }

        private static string ScenarioSceneName
        {
            get => EditorPrefs.GetString(KEY_SCENARIO_SCENE_NAME, null);
            set => EditorPrefs.SetString(KEY_SCENARIO_SCENE_NAME, value);
        }
        
        [InitializeOnLoadMethod]
        private static void Initialize()
        {
            EditorApplication.playModeStateChanged -= handlePlayModeStateChanged;
            EditorApplication.playModeStateChanged += handlePlayModeStateChanged;
            
            void handlePlayModeStateChanged(PlayModeStateChange state)
            {
                if (state == PlayModeStateChange.ExitingEditMode)
                {
                    IsCustomLoadingMode = false;
                    BaseScenario scenarioInstance = Object.FindAnyObjectByType<BaseScenario>();
                    if (scenarioInstance == null)
                    {
                        return;
                    }

                    IsCustomLoadingMode = true;
                    
                    SceneAsset bootstrapper =
                        AssetDatabase.LoadAssetAtPath<SceneAsset>(GlobalData.Instance.BootstrapperScene.ScenePath);
                    EditorSceneManager.playModeStartScene = bootstrapper;

                    ScenarioSceneName = null;
                    
                    switch (scenarioInstance)
                    {
                        case Scenario:
                            ScenarioDataType = ScenarioDataType.Scenario;
                            ScenarioSceneName = scenarioInstance.gameObject.scene.name;
                            break;
                        case LobbyScenario:
                            ScenarioDataType = ScenarioDataType.Lobby;
                            break;
                        case TutorialScenario:
                            ScenarioDataType = ScenarioDataType.Tutorial;
                            break;
                        default:
                            throw new ArgumentOutOfRangeException(nameof(scenarioInstance));
                    }
                }
                else if (state == PlayModeStateChange.ExitingPlayMode)
                {
                    EditorSceneManager.playModeStartScene = null;
                }
            }
        }

        // Placing this logic here because it reliably runs before anything else
        [UnityEngine.RuntimeInitializeOnLoadMethod]
        private static void RuntimeInitialize()
        {
            if (!IsCustomLoadingMode)
            {
                return;
            }
            ScenarioManager.IsCustomLoadingMode = true;

            LoadScenarioScenesAsync().Forget();
        }
        
        private static async UniTaskVoid LoadScenarioScenesAsync()
        {
            await UniTask.WaitUntil(() => ScenarioManager.Instance != null);
            
            GlobalData.Instance.Initialize();
            
            switch (ScenarioDataType)
            {
                case ScenarioDataType.Scenario:
                case ScenarioDataType.Cutscene:
                    ScenarioData scenarioData =
                        GlobalData.Instance.GetScenarioDataBySceneName(ScenarioSceneName);
                    ScenarioManager.Instance.LoadScenario(scenarioData).Forget();
                    break;
                case ScenarioDataType.Lobby:
                    ScenarioManager.Instance.LoadLobby();
                    break;
                case ScenarioDataType.Tutorial:
                    ScenarioManager.Instance.LoadBasicsTutorial();
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioManagement/SingleScenarioPlayModeEditorFeature.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/BaseScenarioWindowTab.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: dbfbb8fbc93647659500f6cbc6b931f3
# ASMDEF: ldx.framework.editor.dll
# ---
using System;

namespace Ldx.Framework.Systems.ScenarioWindow
{
    /// <summary>
    /// Base class for a tab in the scenario management window
    /// </summary>
    public abstract class BaseScenarioWindowTab
    {
        public enum ScenarioTabTypes
        {
            ManageScenario = 0,
            ScenarioSetup = 1,
            SceneSetup = 2,
        }
        
        public static event Action<BaseScenarioWindowTab, ScenarioTabTypes?> OnSetupRefreshed; 
     
        public abstract string Name { get; }
        public abstract int Priority { get; }
        public abstract ScenarioTabTypes TabType { get; }

        public virtual void Initialize()
        {
        }

        public virtual void DrawTab()
        {
        }

        public virtual bool IsEnabled() => true;

        protected void BroadcastSetupRefreshed(ScenarioTabTypes? toWindowType = null)
        {
            OnSetupRefreshed?.Invoke(this, toWindowType);   
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/BaseScenarioWindowTab.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/Helpers/NewScenarioEditorWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7964d47c3b2f45979ef10bf67398ab89
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Systems.SceneManagement;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Ldx.Framework.Systems.ScenarioWindow.Helpers
{
    /// <summary>
    /// Small window for creating a new scenario
    /// </summary>
    public class NewScenarioEditorWindow : EditorWindow
    {
        public static event Action<bool> OnSetupFinished;

        private bool finishedSetup;
        
        private string ID { get; set; } = "";
        private string Name { get; set; } = "";
        private string Description { get; set; } = "";

        private SceneReference ScenarioScene { get; set; } = null;
        private List<SceneReference> AdditionalScenes { get; set; } = new();
        private ScenarioDataType ScenarioType { get; set; }
        private bool ShouldCreateScenarioSceneObject { get; set; } = true;
        private bool LinkScenesAutomatically { get; set; } = true;
        
        public static void ShowWindow()
        {
            var window = GetWindow<NewScenarioEditorWindow>();
            window.titleContent = new GUIContent("Create New Scenario");
            window.Show();
        }

        private void OnEnable()
        {
            InitializeScenes();
        }

        private void OnDestroy()
        {
            OnSetupFinished?.Invoke(finishedSetup);
        }

        private void InitializeScenes()
        {
            ScenarioScene = new();
            AdditionalScenes.Clear();

            Scene activeScene = SceneManager.GetActiveScene();
            ScenarioScene.ScenePath = activeScene.path;

            for (int i = 0; i < SceneManager.sceneCount; i++)
            {
                Scene scene = SceneManager.GetSceneAt(i);
                if (!scene.isLoaded || scene == activeScene)
                {
                    continue;
                }

                SceneReference sceneReference = new SceneReference();
                sceneReference.ScenePath = scene.path;
                AdditionalScenes.Add(sceneReference);
            }
        }

        private void OnGUI()
        {
            using (new EditorGUILayout.VerticalScope())
            {
                DrawFields();
                DrawSceneSetupSection();
                DrawScenes();
                DrawButtons();
            }
        }
        
        private void DrawFields()
        {
            LdxEditorHelper.DrawHorizontalSeparator();
            LdxEditorHelper.DrawTitle("Info");
            using (new EditorGUILayout.HorizontalScope())
            {
                EditorGUILayout.LabelField($"ID: ");
                EditorGUILayout.LabelField(ID);
            }

            EditorGUI.BeginChangeCheck();
            Name = EditorGUILayout.TextField("Name: ", Name);
            if (EditorGUI.EndChangeCheck())
            {
                ID = Name.ToUpperCamelCaseDashFormat();
            }
            
            Description = EditorGUILayout.TextField("Description: ", Description);
            ScenarioType = (ScenarioDataType) EditorGUILayout.EnumPopup(new GUIContent("Type: "), ScenarioType);
        }

        private void DrawSceneSetupSection()
        {
            LdxEditorHelper.DrawHorizontalSeparator();
            LdxEditorHelper.DrawTitle("Scene Setup");
            using (new EditorGUILayout.HorizontalScope())
            {
                EditorGUILayout.LabelField("Create Scenario Scene Object");
                ShouldCreateScenarioSceneObject =
                    EditorGUILayout.Toggle(ShouldCreateScenarioSceneObject);
                GUILayout.FlexibleSpace();
            }
        }
        
        private void DrawScenes()
        {
            LdxEditorHelper.DrawHorizontalSeparator();
            LdxEditorHelper.DrawTitle("Scenes");
            
            using (new EditorGUILayout.HorizontalScope())
            {
                LdxEditorHelper.DrawBoldLabel("Link Scenes Automatically");
                LinkScenesAutomatically = EditorGUILayout.Toggle(LinkScenesAutomatically);
                GUILayout.FlexibleSpace();
            }
            
            GUI.enabled = LinkScenesAutomatically;
            using (new EditorGUILayout.HorizontalScope())
            {
                LdxEditorHelper.DrawBoldLabel($"Scenario Scene:");
                EditorGUILayout.LabelField(ScenarioScene.GetSceneName(), LdxEditorHelper.GreenLabelStyle);
                GUILayout.FlexibleSpace();
            }
           
            LdxEditorHelper.DrawBoldLabel("Environment / Additional Scenes:");
            foreach (SceneReference scene in AdditionalScenes)
            {
                if (scene == null)
                {
                    continue;
                }
                EditorGUILayout.LabelField($"\t-{scene.GetSceneName()}", LdxEditorHelper.GreenLabelStyle);
            }
            GUI.enabled = true;
        }
        
        private void DrawButtons()
        {
            LdxEditorHelper.DrawHorizontalSeparator();
            using (new EditorGUILayout.HorizontalScope())
            {
                GUILayout.FlexibleSpace();
                if (GUILayout.Button("Create Scenario"))
                {
                    CreateScenarioAsync().Forget();
                }

                GUILayout.FlexibleSpace();
            }
        }

        private async UniTask CreateScenarioAsync()
        {
            if (ScenarioData.EDITOR_TryCreateNewScenario(ID, Name, Description, out ScenarioData data,
                    out string errorMessage))
            {
                if (LinkScenesAutomatically)
                {
                    LinkScenesToScenarioData(data);
                }

                GlobalData.Instance.EDITOR_AddScenarioToGlobalData(data);
                data.Type = ScenarioType;
                ShowDialogMessage("Success", $"Created scenario \"{Name}\" successfully!\n" +
                                             $"(Assets\\Resources\\Data\\Scenarios\\{ID}\\)");
                Selection.activeObject = data;

                finishedSetup = true;

                if (ShouldCreateScenarioSceneObject)
                {
                   finishedSetup = await SetupScenarioObjectAsync();
                }
                Close();
                return;
            }
            ShowDialogMessage("Error", errorMessage);
        }

        private async UniTask<bool> SetupScenarioObjectAsync()
        {
            bool result = false;
            bool stepFinished = false;
            SceneSetupEditorFeatures.OnScenarioObjectSetupComplete += handleScenarioObjectSetupComplete;

            switch (ScenarioType)
            {
                case ScenarioDataType.Scenario:
                    SceneSetupEditorFeatures.SetupScenarioSceneFeature();
                    break;
                case ScenarioDataType.Lobby:
                    SceneSetupEditorFeatures.SetupLobbySceneFeature();
                    break;
                case ScenarioDataType.Tutorial:
                    SceneSetupEditorFeatures.SetupTutorialSceneFeature();
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
            
            await UniTask.WaitUntil(() => stepFinished);

            return result;
            
            void handleScenarioObjectSetupComplete(bool success)
            {
                SceneSetupEditorFeatures.OnScenarioObjectSetupComplete -= handleScenarioObjectSetupComplete;
                stepFinished = true;
                result = success;
            }
        }

        private void ShowDialogMessage(string windowTitle, string message)
        {
            EditorUtility.DisplayDialog(windowTitle, message, "Ok");
        }

        private void LinkScenesToScenarioData(ScenarioData scenarioData)
        {
            scenarioData.SceneReference = ScenarioScene;
            scenarioData.AdditionalScenes = AdditionalScenes;
            EditorUtility.SetDirty(scenarioData);
            AssetDatabase.SaveAssetIfDirty(scenarioData);
            
            List<string> scenePaths = AdditionalScenes.Select(s => s.ScenePath).ToList();
            scenePaths.Add(ScenarioScene.ScenePath);
            
            scenePaths.ForEach(TryAddSceneToBuildSettings);
        }

        private static void TryAddSceneToBuildSettings(string scenePath)
        {
            if (String.IsNullOrEmpty(scenePath))
            {
                Debug.LogError("Scene path is invalid. Cannot add to build settings.");
                return;
            }

            EditorBuildSettingsScene[] buildScenes = EditorBuildSettings.scenes;

            foreach (EditorBuildSettingsScene scene in buildScenes)
            {
                if (scene.path == scenePath)
                {
                    return;
                }
            }

            EditorBuildSettingsScene[] newBuildScenes = new EditorBuildSettingsScene[buildScenes.Length + 1];
            Array.Copy(buildScenes, newBuildScenes, buildScenes.Length);

            EditorBuildSettingsScene newScene = new EditorBuildSettingsScene(scenePath, true);
            newBuildScenes[^1] = newScene;

            EditorBuildSettings.scenes = newBuildScenes;
            Debug.Log($"Added {scenePath} to build settings.");
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/Helpers/NewScenarioEditorWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/Helpers/ScenarioWindowHelper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f33afb0b25c54bc98ba4c2b822cabd13
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Systems.SceneManagement;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor.SceneManagement;
using UnityEngine.SceneManagement;

namespace Ldx.Framework.Systems.ScenarioWindow.Helpers
{
    /// <summary>
    /// Helper methods for some of the operations required by the
    /// scenario management window
    /// </summary>
    public static class ScenarioWindowHelper
    {
        /// <summary>
        /// Load the scenario's additional scenes
        /// </summary>
        public static void LoadScenarioAdditionalScenesFeature()
        {
            ScenarioData scenarioData = ScenarioEditorHelper.GetScenarioData();
            if (scenarioData == null)
            {
                return;
            }

            foreach (SceneReference s in scenarioData.AdditionalScenes)
            {
                if (s == null)
                {
                    continue;
                }

                string sceneName = s.GetSceneName();
                string scenePath = s.ScenePath;
                Scene scene = SceneManager.GetSceneByName(sceneName);
                if (scene.isLoaded)
                {
                    continue;
                }

                if (String.IsNullOrEmpty(scenePath))
                {
                    continue;
                }
                
                EditorSceneManager.OpenScene(scenePath, OpenSceneMode.Additive);
            }
        }
        
        /// <summary>
        /// Unload the scenario's additional scenes
        /// </summary>
        public static void UnloadScenarioAdditionalScenesFeature()
        {
            ScenarioData scenarioData = ScenarioEditorHelper.GetScenarioData();
            if (scenarioData == null)
            {
                return;
            }

            foreach (SceneReference s in scenarioData.AdditionalScenes)
            {
                if (s == null)
                {
                    continue;
                }

                string sceneName = s.GetSceneName();

                Scene scene = SceneManager.GetSceneByName(sceneName);
                if (!scene.isLoaded)
                {
                    continue;
                }

                EditorSceneManager.CloseScene(scene, true);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/Helpers/ScenarioWindowHelper.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/Helpers/SceneSetupEditorFeatures.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a1b5390205ea43a898c1d0bb80f30571
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Systems.SceneManagement;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEngine;
using UnityEngine.SceneManagement;
using Object = UnityEngine.Object;

namespace Ldx.Framework.Systems.ScenarioWindow
{
    /// <summary>
    /// Features related to scene setup for the scenario management window 
    /// </summary>
    public static class SceneSetupEditorFeatures
    {
        public static event Action<bool> OnScenarioObjectSetupComplete; 
        
        private const string SCENARIO_PARENT_OBJECT_NAME = "---Scenario Setup---";
        private const string LOBBY_PARENT_OBJECT_NAME = "---Lobby Setup---";
        private const string TUTORIAL_PARENT_OBJECT_NAME = "---Tutorial Scenario Setup---";
        
        public static void SetupScenarioSceneFeature()
        {
            SetupSceneSelectionWindow(SetupScenarioSceneProcess);
        }
        
        public static void SetupLobbySceneFeature()
        {
            SetupSceneSelectionWindow(SetupLobbySceneProcess);
        }
        
        public static void SetupTutorialSceneFeature()
        {
            SetupSceneSelectionWindow(SetupTutorialSceneProcess);
        }

        public static void CreateCustomStartPointFeature()
        {
            CustomStartPoint point = Object.FindAnyObjectByType<CustomStartPoint>();
            if (point != null)
            {
                Selection.activeObject = point;
                EditorUtility.DisplayDialog("Warning", "Custom start point already exists", "Ok");
                return;
            }

            point = new GameObject("*CUSTOM START POINT").AddComponent<CustomStartPoint>();
            PlayerStartPoint playerStartPoint = Object.FindAnyObjectByType<PlayerStartPoint>();
            if (playerStartPoint != null)
            {
                point.transform.position = playerStartPoint.transform.position;
                point.transform.rotation = playerStartPoint.transform.rotation;
            }
            Selection.activeObject = point;
            EditorUtility.SetDirty(point);
            EditorUtility.DisplayDialog("Message", "Custom start point created", "Ok");
        }
        
        private static void SetupSceneSelectionWindow(Action processCallback)
        {
            List<Scene> loadedScenes = SceneUtilities.GetAllLoadedScenes();
            // Single scene, no need to select
            if (loadedScenes.Count == 1)
            {
                processCallback?.Invoke();
                OnScenarioObjectSetupComplete?.Invoke(true);
                return;
            }
            
            // More than one scene, initialize and show selection modal
            ModalEditorWindow modal = null;
            int selectedIndex = 0;
            GUIContent[] displayedOptions = loadedScenes.Select(s => new GUIContent(s.name)).ToArray();
            modal = ModalEditorWindow.ShowModal("Select Scene", sceneSelectDrawCallback);
            modal.SetSize(400,200);
            modal.OnModalClosed += handleModalClosed;
            
            void sceneSelectDrawCallback()
            {
                using (new GUILayout.VerticalScope(GUILayout.Height(500)))
                {
                    LdxEditorHelper.DrawTitle("Select Scene");
                    EditorGUILayout.Space(5);
                    LdxEditorHelper.DrawHorizontalSeparator();
                    EditorGUILayout.LabelField("You have multiple scenes loaded");
                    EditorGUILayout.LabelField("Please select the scene to apply the setup to");
                    LdxEditorHelper.DrawHorizontalSeparator();
                    EditorGUILayout.Space(5);
                    selectedIndex = EditorGUILayout.Popup(new GUIContent("Scene:"), selectedIndex, displayedOptions);
                    if (GUILayout.Button("Apply"))
                    {
                        modal.OnModalClosed -= handleModalClosed;
                        string sceneName = displayedOptions[selectedIndex].text;
                        if (!SceneManager.GetSceneByName(sceneName).isLoaded)
                        {
                            EditorUtility.DisplayDialog("Action Invalid", "Scene was unloaded", "Ok");
                            return;
                        }

                        SceneManager.SetActiveScene(SceneManager.GetSceneByName(sceneName));
                        processCallback?.Invoke();
                        OnScenarioObjectSetupComplete?.Invoke(true);
                        modal?.Close();
                    }
                }
            }

            void handleModalClosed()
            {
                modal.OnModalClosed -= handleModalClosed;
                OnScenarioObjectSetupComplete?.Invoke(false);
            }
        }
        
        private static void SetupScenarioSceneProcess()
        {
            if (!ValidateActiveScene())
            {
                return;
            }
            GameObject parent = CreateOrGetParentObject(SCENARIO_PARENT_OBJECT_NAME);
            Scenario scenario = CreateOrGetScenarioObject();
            PlayerStartPoint point = CreateOrGetPlayerStartPoint();
            scenario.transform.SetParent(parent.transform);
            point.transform.SetParent(parent.transform);
            scenario.transform.SetSiblingIndex(0);
            Selection.activeObject = scenario.gameObject;
            // Otherwise for some reason, Unity doesn't register this
            // as a change worth saving, even if you hit save
            EditorUtility.SetDirty(parent);
            string sceneName = SceneManager.GetActiveScene().name;
            EditorUtility.DisplayDialog("Success", $"Scenario setup complete at scene '{sceneName}'", "Ok");
        }
        
        private static void SetupTutorialSceneProcess()
        {
            if (!ValidateActiveScene())
            {
                return;
            }
            GameObject parent = CreateOrGetParentObject(TUTORIAL_PARENT_OBJECT_NAME);
            TutorialScenario scenario = CreateOrGetTutorialScenarioObject();
            PlayerStartPoint point = CreateOrGetPlayerStartPoint();
            scenario.transform.SetParent(parent.transform);
            point.transform.SetParent(parent.transform);
            scenario.transform.SetSiblingIndex(0);
            Selection.activeObject = scenario.gameObject;
            // Otherwise for some reason, Unity doesn't register this
            // as a change worth saving, even if you hit save
            EditorUtility.SetDirty(parent);
            string sceneName = SceneManager.GetActiveScene().name;
            EditorUtility.DisplayDialog("Success", $"Tutorial Scenario setup complete at scene '{sceneName}'", "Ok");
        }

        private static void SetupLobbySceneProcess()
        {
            if (!ValidateActiveScene())
            {
                return;
            }
            GameObject parent = CreateOrGetParentObject(LOBBY_PARENT_OBJECT_NAME);
            LobbyScenario lobby = CreateOrGetLobbyObject();
            PlayerStartPoint point = CreateOrGetPlayerStartPoint();
            lobby.transform.SetParent(parent.transform);
            point.transform.SetParent(parent.transform);
            lobby.transform.SetSiblingIndex(0);
            Selection.activeObject = lobby.gameObject;
            EditorUtility.SetDirty(parent);
            string sceneName = SceneManager.GetActiveScene().name;
            EditorUtility.DisplayDialog("Success", $"Lobby scene setup complete at scene '{sceneName}'", "Ok");
        }

        private static bool ValidateActiveScene()
        {
            if (GlobalData.Instance == null)
            {
                // Skip if no global data. Advance at your own discretion. Each for their own. 
                return true;
            }
            SceneReference bScene = GlobalData.Instance.BootstrapperScene;
            if (bScene != null && SceneManager.GetActiveScene().name == bScene.GetSceneName())
            {
                EditorUtility.DisplayDialog("Error", "Can't setup scenario in the bootstrapper scene", "Ok");
                return false;
            }

            return true;
        }

        private static GameObject CreateOrGetParentObject(string name)
        { 
            GameObject obj = GameObject.Find(name);
            if (obj != null)
            {
                if (obj.scene.name == SceneManager.GetActiveScene().name)
                {
                    return obj;
                }
            }

            return new GameObject(name);
        }

        private static Scenario CreateOrGetScenarioObject()
        {
            Scenario scenario = Object.FindFirstObjectByType<Scenario>();
            if (scenario != null)
            {
                if (scenario.gameObject.scene.name == SceneManager.GetActiveScene().name)
                {
                    return scenario;
                }
            }

            GameObject gameObject = new(nameof(Scenario));
            scenario = gameObject.AddComponent<Scenario>();
            return scenario;
        }
        
        private static TutorialScenario CreateOrGetTutorialScenarioObject()
        {
            TutorialScenario scenario = Object.FindFirstObjectByType<TutorialScenario>();
            if (scenario != null)
            {
                if (scenario.gameObject.scene.name == SceneManager.GetActiveScene().name)
                {
                    return scenario;
                }
            }

            GameObject gameObject = new(nameof(TutorialScenario));
            scenario = gameObject.AddComponent<TutorialScenario>();
            return scenario;
        }
        
        private static LobbyScenario CreateOrGetLobbyObject()
        {
            LobbyScenario lobby = Object.FindFirstObjectByType<LobbyScenario>();
            if (lobby != null)
            {
                if (lobby.gameObject.scene.name == SceneManager.GetActiveScene().name)
                {
                    return lobby;
                }
            }

            GameObject gameObject = new GameObject(nameof(LobbyScenario));
            lobby = gameObject.AddComponent<LobbyScenario>();
            return lobby;
        }
        
        private static PlayerStartPoint CreateOrGetPlayerStartPoint()
        {
            PlayerStartPoint point = Object.FindFirstObjectByType<PlayerStartPoint>();
            if (point != null)
            {
                if (point.gameObject.scene.name == SceneManager.GetActiveScene().name)
                {
                    return point;
                }
            }

            GameObject gameObject = new(nameof(PlayerStartPoint));
            point = gameObject.AddComponent<PlayerStartPoint>();
            return point;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/Helpers/SceneSetupEditorFeatures.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/Helpers/SceneSetupObjectDefinition.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 3033848148834f41875ef9a2f7d0b4a4
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using Ldx.Framework.Utilities.Attributes;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Ldx.Framework.Systems.ScenarioWindow
{
    /// <summary>
    /// Definition object used by the SceneSetupTab
    /// Contains information about a single framework component used
    /// for scene setup
    /// </summary>
    public class SceneSetupObjectDefinition
    {
        public Type Type { get; }
        public SceneSetupLinkAttribute Attribute { get; }
        public MonoBehaviour SceneReference { get; set; }
        public bool InScene => SceneReference != null;
        public SceneSetupLinkGroup Group => Attribute.Group;
        public bool IsSelected { get; set; }
        
        public SceneSetupObjectDefinition(Type type, SceneSetupLinkAttribute attribute)
        {
            Type = type;
            Attribute = attribute;
            IsSelected = attribute.Group == SceneSetupLinkGroup.Essential;
            
            SceneReference = Object.FindAnyObjectByType(Type) as MonoBehaviour;
        }

        public void InstantiateInScene(GameObject[] setupPrefabs, Transform parent)
        {
            if (InScene)
            {
                SceneReference.transform.SetParent(parent);
                return;
            }
            
            GameObject matchingPrefab = null;

            foreach (GameObject prefab in setupPrefabs)
            {
                if (prefab.GetComponent(Type) != null)
                {
                    matchingPrefab = prefab;
                    break;
                }
            }

            if (matchingPrefab == null)
            {
                Debug.LogError($"No prefab found in Resources/SceneSetupPrefabs that contains a component of type {Type.Name}");
                return;
            }

            GameObject instantiatedObject = Object.Instantiate(matchingPrefab, parent);
        
            instantiatedObject.name = matchingPrefab.name;
        
            SceneReference = instantiatedObject.GetComponent(Type) as MonoBehaviour;

            if (SceneReference == null)
            {
                Debug.LogError($"Instantiated prefab {matchingPrefab.name} does not have a {Type.Name} component.");
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/Helpers/SceneSetupObjectDefinition.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/ScenarioManagementEditorWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b078ad81585e4984a33dcaeddff0a7d7
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Reflection;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;
using UnityEngine.SceneManagement;
using Color = UnityEngine.Color;
using Random = UnityEngine.Random;

namespace Ldx.Framework.Systems.ScenarioWindow
{
    /// <summary>
    /// Scenario management window used to allow for managing and setting up scenarios
    /// from a single window
    /// </summary>
    public class ScenarioManagementEditorWindow : EditorWindow
    {
        private const int MIN_W = 800;
        private const int MIN_H = 600;
        private const int TABS_WIDTH = 150;
        private const int TABS_BTN_HEIGHT = 70;
        private const int CONTENT_MARGIN = 5;
        private const int TIP_PROBABILITY_DENOMINATOR = 3;

        private int selectedTabIndex = 0;
        private List<BaseScenarioWindowTab> tabs = new();
        private string[] tabTitles;
        private static bool shouldShowTip;
        
        private GUIStyle tabStyle, selectedTabStyle, titleStyle;
        // Texture references sometimes get lost when refreshing
        // Have to store them as fields so they don't go out of scope
        private Texture2D normalTabBG, hoverTabBG, selectedTabBG;
        private Vector2 scrollPos;

        [MenuItem("LogicalDox/Scenario/Scenario Management", priority = -1)]
        public static void ShowWindow()
        {
            GetWindow<ScenarioManagementEditorWindow>("Scenario Management");
            int showTipRandomNumber = Random.Range(0, TIP_PROBABILITY_DENOMINATOR);
            shouldShowTip = showTipRandomNumber == 1;
        }

        private void OnEnable()
        {
            minSize = new Vector2(MIN_W, MIN_H);
            BaseScenarioWindowTab.OnSetupRefreshed -= HandleSetupRefreshed;
            BaseScenarioWindowTab.OnSetupRefreshed += HandleSetupRefreshed;
            EditorSceneManager.activeSceneChangedInEditMode -= OnActiveSceneChanged;
            EditorSceneManager.activeSceneChangedInEditMode += OnActiveSceneChanged;
        }

        private void OnDisable()
        {
            BaseScenarioWindowTab.OnSetupRefreshed -= HandleSetupRefreshed;
            EditorSceneManager.activeSceneChangedInEditMode -= OnActiveSceneChanged;
        }
        
        private void CreateGUI()
        {
           Refresh();
        }

        private void Refresh()
        {
            InitializeStyles();
            Initialize();
        }
        
        private void Initialize(int startupTabIndex = 0)
        {
            wantsMouseMove = true;
            tabs = GetAllScenarioTabs();
            tabs.Sort((a,b)=> a.Priority.CompareTo(b.Priority));
            selectedTabIndex = startupTabIndex;
            bool foundFirstTab = startupTabIndex != 0;
            
            for (int i = 0; i < tabs.Count; i++)
            {
                tabs[i].Initialize();
                
                if (!foundFirstTab)
                {
                    if (tabs[i].IsEnabled())
                    {
                        selectedTabIndex = i;
                        foundFirstTab = true;
                    }
                }
            }

            if (!tabs[selectedTabIndex].IsEnabled())
            {
                selectedTabIndex = tabs.FindIndex(t => t.IsEnabled());
            }
        }
        
        private void OnActiveSceneChanged(Scene scene1, Scene scene2)
        {
            Refresh();   
        }
        
        private void HandleSetupRefreshed(BaseScenarioWindowTab tab, BaseScenarioWindowTab.ScenarioTabTypes? toTabType)
        {
            if (toTabType != null)
            {
                int index = tabs.FindIndex((t) => t.TabType == toTabType);
                if (index >= 0)
                {
                    selectedTabIndex = index;
                }
            }
            Initialize(selectedTabIndex);
        }

        private void OnGUI()
        {
            Rect tabAreaRect = new Rect(0, 0, TABS_WIDTH, position.height);
            EditorGUI.DrawRect(tabAreaRect, Colors.FromRGBA(44,44,44));
            
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.BeginVertical(GUILayout.Width(TABS_WIDTH));

            for (int i = 0; i < tabs.Count; i++)
            {
                GUI.enabled = tabs[i].IsEnabled();

                if (GUILayout.Button(tabs[i].Name, selectedTabIndex == i? selectedTabStyle : tabStyle, GUILayout.Height(TABS_BTN_HEIGHT)))
                {
                    selectedTabIndex = i;
                }
            }

            GUI.enabled = true;

            EditorGUILayout.EndVertical();
            
            // Margin
            EditorGUILayout.BeginVertical(GUILayout.Width(CONTENT_MARGIN));
            EditorGUILayout.Space();
            EditorGUILayout.EndVertical();
            
            EditorGUILayout.BeginVertical();
            if (shouldShowTip)
            {
                EditorGUILayout.HelpBox("You can open this window by using the shortcut CTRL + Q", MessageType.Info);
            }
            EditorGUILayout.LabelField(tabs[selectedTabIndex].Name, titleStyle);
            EditorGUILayout.Space(EditorGUIUtility.singleLineHeight);
            if (tabs[selectedTabIndex].IsEnabled())
            {
                using (var scrollView = new EditorGUILayout.ScrollViewScope(scrollPos))
                {
                    scrollPos = scrollView.scrollPosition;
                    tabs[selectedTabIndex].DrawTab();
                }
            }
            else
            {
                GUILayout.Label("This tab is disabled.");
            }
            EditorGUILayout.EndVertical();
            
            // Margin
            EditorGUILayout.BeginVertical(GUILayout.Width(CONTENT_MARGIN));
            EditorGUILayout.Space();
            EditorGUILayout.EndVertical();

            EditorGUILayout.EndHorizontal();
            
            if (Event.current.type == EventType.MouseMove)
            {
                Repaint();
            }
        }

        public static List<BaseScenarioWindowTab> GetAllScenarioTabs()
        {
            List<BaseScenarioWindowTab> scenarioTabs = new List<BaseScenarioWindowTab>();
            Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();

            foreach (Assembly assembly in assemblies)
            {
                Type[] types = assembly.GetTypes();

                foreach (Type type in types)
                {
                    if (type.IsSubclassOf(typeof(BaseScenarioWindowTab)) && !type.IsAbstract)
                    {
                        BaseScenarioWindowTab instance = (BaseScenarioWindowTab)Activator.CreateInstance(type);
                        scenarioTabs.Add(instance);
                    }
                }
            }

            return scenarioTabs;
        }

        
        private void InitializeStyles()
        {
            tabStyle = new GUIStyle();
            tabStyle.normal.textColor = Color.white;
            tabStyle.hover.textColor = Color.white;
            tabStyle.fontStyle = FontStyle.Bold;
                 
            normalTabBG = LdxEditorHelper.CreateOutlineTexture(Color.clear, 
                Colors.FromRGBA(25, 25, 25),
                TABS_WIDTH,
                TABS_BTN_HEIGHT);
            
            hoverTabBG =
                LdxEditorHelper.CreateOutlineTexture(Colors.FromRGBA(54, 156, 148, 0.5f), 
                    Colors.FromRGBA(25, 25, 25),
                    TABS_WIDTH,
                    TABS_BTN_HEIGHT);
            
            tabStyle.alignment = TextAnchor.MiddleCenter;
            tabStyle.normal.background = normalTabBG;
            tabStyle.normal.scaledBackgrounds = new[]{normalTabBG};
            tabStyle.hover.background = hoverTabBG;
            tabStyle.hover.scaledBackgrounds = new[]{hoverTabBG};
            
            selectedTabStyle = new GUIStyle(tabStyle);
            selectedTabBG =
                LdxEditorHelper.CreateOutlineTexture(Colors.FromRGBA(54, 156, 148), 
                    Colors.FromRGBA(25, 25, 25),
                    TABS_WIDTH,
                    TABS_BTN_HEIGHT);
            selectedTabStyle.normal.background = selectedTabBG;
            selectedTabStyle.normal.scaledBackgrounds = new[] { selectedTabBG };
            selectedTabStyle.hover.background = selectedTabBG;
            selectedTabStyle.hover.scaledBackgrounds = new[] { selectedTabBG };

            titleStyle = new GUIStyle();
            titleStyle.normal.textColor = Color.white;
            titleStyle.fontStyle = FontStyle.Bold;
            titleStyle.alignment = TextAnchor.UpperCenter;
            titleStyle.fontSize = 22;
            
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/ScenarioManagementEditorWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/Tabs/ManageScenarioTab.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7d985906c76c414bb032df065a234e2c
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using System.IO;
using Ldx.Framework.Systems.Localization;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Systems.ScenarioWindow.Helpers;
using Ldx.Framework.Systems.SceneManagement;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Ldx.Framework.Systems.ScenarioWindow.Tabs
{
    /// <summary>
    /// Tab for managing a scenario in the scenario management window
    /// </summary>
    public class ManageScenarioTab : BaseScenarioWindowTab
    {
        private enum AdditionalScenesState
        {
            NoneAssigned = 0,
            Loaded,
            NotLoaded
        }

        private const int SELECT_BTN_W = 160;
        
        private ScenarioData scenarioData;
        private List<ScriptableObject> selectableObjects = new();
        private AdditionalScenesState? additionalScenesState;
        private CustomStartPoint customStartPoint;
        private bool isAddedToGlobalData;
        private int scenarioIndex;

        private List<ScenarioData> scenarioDataList;
        private GUIStyle textAreaStyle;
        private GUIStyle wrappableHelpBoxStyle;
        
        public override string Name => "Manage Scenario";
        public override int Priority => 1;
        public override ScenarioTabTypes TabType => ScenarioTabTypes.ManageScenario;
        private int ScenarioCount => scenarioDataList.Count;
        private int Order => scenarioIndex + 1;
        private string LocalizedDescription => LocalizationModel.UseLocalization
            ? LocalizationModel.GetTextString(scenarioData.Description, Language.English)
            : 
            scenarioData.Description;
        
        public override void Initialize()
        {
            base.Initialize();
            scenarioData = ScenarioEditorHelper.GetScenarioData();
            if (scenarioData == null)
            {
                return;
            }
            
            scenarioIndex = GlobalData.Instance.GetScenarioDataIndex(scenarioData);
            scenarioDataList = GlobalData.Instance.GetScenarioDataList();
            additionalScenesState = GetAdditionalScenesState();
            isAddedToGlobalData = GetAddedToGlobalData();
            customStartPoint = Object.FindAnyObjectByType<CustomStartPoint>();
            RefreshSelectableObjects();
        }

        private void Refresh()
        {
            BroadcastSetupRefreshed();
        }
        
        public override void DrawTab()
        {
            DrawInfoSection();
            LdxEditorHelper.DrawHorizontalSeparator();
            DrawSelectButtons();
            LdxEditorHelper.DrawHorizontalSeparator();
            DrawAdditionalScenesSection();
            LdxEditorHelper.DrawHorizontalSeparator();
            DrawGlobalDataSection();
            LdxEditorHelper.DrawHorizontalSeparator();
            DrawCustomStartPointSection();
        }

        private void DrawInfoSection()
        {
            GUI.enabled = false;
            EditorGUILayout.TextField("Name: ", scenarioData.ScenarioNameLocalized, GUILayout.Width(454));
            
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("Description: ", GUILayout.Width(350), GUILayout.Width(150));

            // This is truly the dumbest piece of editor code I had to ever
            // write due to Unity's editor race conditions
            if (GUI.skin != null)
            {
                if (textAreaStyle == null)
                {
                    textAreaStyle = new GUIStyle(GUI.skin.textArea);
                    textAreaStyle.wordWrap = true;
                }
                EditorGUILayout.TextArea(LocalizedDescription,textAreaStyle,GUILayout.Width(300), GUILayout.Height(EditorGUIUtility.singleLineHeight*4));
            }
            EditorGUILayout.EndHorizontal();
            
            GUI.enabled = true;
            EditorGUILayout.LabelField($"Type: {scenarioData.Type}");
        }
        
        private void DrawSelectButtons()
        {
            LdxEditorHelper.DrawTitle("Select");
            int n = 0;
            
            // GlobalData
            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button(nameof(GlobalData).SeparateWords(), GUILayout.Width(SELECT_BTN_W * 0.5f)))
            {
                Selection.activeObject = GlobalData.Instance;
            }
            GUILayout.FlexibleSpace();
            EditorGUILayout.EndHorizontal();
            
            // ScenarioData
            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button(scenarioData.GetType().Name.SeparateWords(), GUILayout.Width(SELECT_BTN_W * 0.75f)))
            {
                Selection.activeObject = scenarioData;
            }
            GUILayout.FlexibleSpace();
            EditorGUILayout.EndHorizontal();
            
            // Other data files
            while (n < selectableObjects.Count)
            {
                EditorGUILayout.BeginHorizontal();
                // Draw in a grid, 3 at a time
                for (int i = 0; i < 3; i++)
                {
                    if (n >= selectableObjects.Count)
                    {
                        break;
                    }

                    ScriptableObject o = selectableObjects[n];
                    if (GUILayout.Button(o.GetType().Name.SeparateWords(), GUILayout.Width(SELECT_BTN_W)))
                    {
                        Selection.activeObject = o;
                    }
                    n++;
                }   
                GUILayout.FlexibleSpace();
                EditorGUILayout.EndHorizontal();
            }
        }

        private void DrawAdditionalScenesSection()
        {
            LdxEditorHelper.DrawTitle("Scenario Scenes");
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("Environment scenes: ", GUILayout.Width(125));
            string text = additionalScenesState.ToString().SeparateWords();
            GUIStyle textStyle = additionalScenesState == AdditionalScenesState.Loaded
                ? LdxEditorHelper.GreenLabelStyle
                : LdxEditorHelper.RedLabelStyle;
            
            if (additionalScenesState == AdditionalScenesState.NoneAssigned)
            {
                EditorGUILayout.LabelField("No additional scenes assigned ");
            }
            else
            {
                EditorGUILayout.LabelField(text, textStyle);
            }
            
            GUILayout.FlexibleSpace();
            EditorGUILayout.EndHorizontal();
            if (additionalScenesState == AdditionalScenesState.NoneAssigned)
            {
                return;
            }

            if (additionalScenesState == AdditionalScenesState.Loaded)
            {
                if (GUILayout.Button("Unload additional scenes", GUILayout.Width(200)))
                {
                    ScenarioWindowHelper.UnloadScenarioAdditionalScenesFeature();
                    Refresh();
                }
            }
            else if (additionalScenesState == AdditionalScenesState.NotLoaded)
            {
                if (GUILayout.Button("Load additional scenes", GUILayout.Width(200)))
                {
                    ScenarioWindowHelper.LoadScenarioAdditionalScenesFeature();
                    Refresh();
                }
            }
        }

        private void DrawGlobalDataSection()
        {
            LdxEditorHelper.DrawTitle("Global Data");
            string label = isAddedToGlobalData ? $"Scenario added in GlobalData" : "Scenario not added to GlobalData";
            GUIStyle style = isAddedToGlobalData ? LdxEditorHelper.GreenLabelStyle : LdxEditorHelper.RedLabelStyle;
            
            EditorGUILayout.LabelField(label, style);
            
            string btnText = isAddedToGlobalData ? "Remove from GlobalData" : "Add to GlobalData";
            if (isAddedToGlobalData)
            {
                if (GUILayout.Button(btnText, GUILayout.Width(200)))
                {
                    GlobalData.Instance.EDITOR_RemoveScenarioFromGlobalData(scenarioData);
                    Refresh();
                }
            }
            else
            {
                if (GUILayout.Button(btnText, GUILayout.Width(200)))
                {
                    GlobalData.Instance.EDITOR_AddScenarioToGlobalData(scenarioData);
                    Refresh();
                }   
                return;
            }

            EditorGUILayout.Space(10);
       
            EditorGUILayout.LabelField($"Scenario Order: #{Order}", EditorStyles.boldLabel);

            for (int i = 0; i < scenarioDataList.Count; i++)
            {
                ScenarioData current = scenarioDataList[i];
                string sName = $"{i+1}. {scenarioDataList[i].ScenarioName}";

                if (current == scenarioData)
                {
                    EditorGUILayout.LabelField(sName, LdxEditorHelper.GreenLabelStyle);
                }
                else
                {
                    EditorGUILayout.LabelField(sName);
                }
            }

            EditorGUILayout.BeginHorizontal(); 
            if (orderButton("\u2191", scenarioIndex > 0))
            {
                GlobalData.Instance.EDITOR_ChangeScenarioIndex(scenarioData, scenarioIndex - 1);
                Refresh();
            }

            if (orderButton("\u2193", scenarioIndex < ScenarioCount - 1))
            {
                GlobalData.Instance.EDITOR_ChangeScenarioIndex(scenarioData, scenarioIndex + 1);
                Refresh();
            }

            EditorGUILayout.EndHorizontal();
            
            bool orderButton(string orderLabel, bool enable)
            {
                GUI.enabled = enable;
                bool result = GUILayout.Button(orderLabel, GUILayout.Width(50));
                GUI.enabled = true;
                return result;
            }
        }

        private void DrawCustomStartPointSection()
        {
            if (GUI.skin == null)
            {
                return;
            }
            
            if (wrappableHelpBoxStyle == null)
            {
                wrappableHelpBoxStyle = new GUIStyle(EditorStyles.helpBox);
                wrappableHelpBoxStyle.wordWrap = true;
            }
            LdxEditorHelper.DrawTitle("Custom Start Point");
            EditorGUILayout.LabelField("[Applies in editor only]\n" +
                                       "Custom start points allow you to start scenario testing from a point you specify\n" +
                                       "Point will be used in the editor's single scenario testing mode as long as it's set to active",
                                       wrappableHelpBoxStyle);

            bool pointInScene = customStartPoint != null;

            if (!pointInScene)
            {
                if (GUILayout.Button("Create Custom Start Point", GUILayout.Width(300)))
                {
                    SceneSetupEditorFeatures.CreateCustomStartPointFeature();
                    BroadcastSetupRefreshed();
                }
            }
            else
            {
                LdxEditorHelper.DrawBoldLabel("Custom Start Point:");

                EditorGUI.BeginChangeCheck();
                customStartPoint.Active = EditorGUILayout.Toggle("Active: ", customStartPoint.Active);
                if (EditorGUI.EndChangeCheck())
                {
                    EditorUtility.SetDirty(customStartPoint);
                }
                
                if (GUILayout.Button("Select", GUILayout.Width(100)))
                {
                    Selection.activeObject = customStartPoint;
                }

                if (GUILayout.Button("Remove", GUILayout.Width(100)))
                {
                    Object.DestroyImmediate(customStartPoint.gameObject);
                    BroadcastSetupRefreshed();
                }
            }
            
            EditorGUILayout.Space(20);
        }

        private AdditionalScenesState? GetAdditionalScenesState()
        {
            List<SceneReference> scenarioScenes = new() {scenarioData.SceneReference};
            scenarioScenes.AddRange(scenarioData.AdditionalScenes);
            if (scenarioScenes.Count == 1)
            {
                return AdditionalScenesState.NoneAssigned;
            }

            for (int i = scenarioScenes.Count - 1; i >= 0; i--)
            {
                if (SceneManager.GetSceneByName(scenarioScenes[i].GetSceneName()).isLoaded)
                {
                    scenarioScenes.RemoveAt(i);
                }
            }

            return scenarioScenes.Count == 0
                ? AdditionalScenesState.Loaded
                : AdditionalScenesState.NotLoaded;
        }

        private bool GetAddedToGlobalData()
        {
            return GlobalData.Instance.GetScenarioDataList().Contains(scenarioData);
        }

        private void RefreshSelectableObjects()
        {
            selectableObjects.Clear();
            
            string scenarioDataPath = AssetDatabase.GetAssetPath(scenarioData);
            if (string.IsNullOrEmpty(scenarioDataPath))
            {
                Debug.LogWarning("ScenarioData asset path is null or empty.");
                return;
            }

            string directoryPath = Path.GetDirectoryName(scenarioDataPath);
            if (string.IsNullOrEmpty(directoryPath))
            {
                Debug.LogWarning("Directory path is null or empty.");
                return;
            }

            string[] guids = AssetDatabase.FindAssets("t:ScriptableObject", new[] { directoryPath });

            foreach (string guid in guids)
            {
                ScriptableObject obj = AssetDatabase.LoadAssetAtPath<ScriptableObject>(AssetDatabase.GUIDToAssetPath(guid));
        
                if (obj != null && obj != scenarioData)
                {
                    selectableObjects.Add(obj);
                }
            }
        }

        public override bool IsEnabled()
        {
            return scenarioData != null;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/Tabs/ManageScenarioTab.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/Tabs/ScenarioSetupTab.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e45679668e6043bdb1cbe1b95a714857
# ASMDEF: ldx.framework.editor.dll
# ---
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Systems.ScenarioWindow.Helpers;
using Ldx.Framework.Utilities.Helpers;
using UnityEngine;

namespace Ldx.Framework.Systems.ScenarioWindow.Tabs
{
    /// <summary>
    /// Tab for setting up a scenario in the scenario management window
    /// </summary>
    public class ScenarioSetupTab : BaseScenarioWindowTab
    {
        public override string Name => "Scenario Setup";
        public override int Priority => 2;
        public override ScenarioTabTypes TabType => ScenarioTabTypes.ScenarioSetup;

        private BaseScenario scenarioInstance;
        private ScenarioData scenarioData;

        private bool SceneSetupExists => scenarioInstance != null;
        private bool ScenarioDataExists => scenarioData != null;

        public override void Initialize()
        {
            base.Initialize();
            scenarioInstance = ScenarioEditorHelper.GetScenarioInstance();
            if (scenarioInstance == null)
            {
                return;
            }
            scenarioData = ScenarioEditorHelper.GetScenarioData(scenarioInstance);
        }

        public override bool IsEnabled()
        {
            return scenarioData ==  null;
        }

        public override void DrawTab()
        {
            base.DrawTab();
            LdxEditorHelper.DrawBoldLabel("* No scenario data found");
            if (GUILayout.Button("Create New Scenario Data"))
            {
                NewScenarioEditorWindow.OnSetupFinished += handleSetupFinished;
                NewScenarioEditorWindow.ShowWindow();
            }

            void handleSetupFinished(bool result)
            {
                NewScenarioEditorWindow.OnSetupFinished -= handleSetupFinished;
                if (result)
                {
                    BroadcastSetupRefreshed(ScenarioTabTypes.SceneSetup);
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/Tabs/ScenarioSetupTab.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/Tabs/SceneSetupTab.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 08304a01984b4a58b34e3aa7c2d092fc
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Ldx.Framework.Systems.ScenarioWindow.Tabs
{
    /// <summary>
    /// Tab for setting up a scenario scene in the scenario management window
    /// </summary>
    public class SceneSetupTab : BaseScenarioWindowTab
    {
        private const string FRAMEWORK_COMPONENTS_PARENT_NAME = "---Framework Components---";
        
        public override string Name => "Scene Setup";
        public override int Priority => 3;
        public override ScenarioTabTypes TabType => ScenarioTabTypes.SceneSetup;

        private BaseScenario baseScenarioRef;
        private ScenarioData scenarioData;
        private GameObject[] setupPrefabs;
        private List<SceneSetupObjectDefinition> setupObjectDefinitions;

        public override void Initialize()
        {
            base.Initialize();
            baseScenarioRef = Object.FindAnyObjectByType<BaseScenario>();
            scenarioData = ScenarioEditorHelper.GetScenarioData();
            setupPrefabs = Resources.LoadAll<GameObject>("SceneSetupPrefabs");
            setupObjectDefinitions = GetAllSetupObjectDefinitions();
            // Sort definitions based on group
            setupObjectDefinitions.Sort((def1, def2) => def1.Group.CompareTo(def2.Group));
        }

        public override bool IsEnabled() => scenarioData != null;

        public override void DrawTab()
        {
            DrawScenarioObjectSetup();
            DrawFrameworkComponentsSetup();
        }

        private void DrawScenarioObjectSetup()
        {
            LdxEditorHelper.DrawTitle("Scene Scenario Object");
            if (baseScenarioRef != null)
            {
                EditorGUILayout.LabelField("*Scenario object is setup in scene", LdxEditorHelper.GreenLabelStyle);
                return;
            }
            EditorGUILayout.LabelField("*Scenario object not setup in scene", LdxEditorHelper.RedLabelStyle);

            if (GUILayout.Button("Setup Scenario Object", GUILayout.Width(400)))
            {
                SetupScenarioObject();
            }
        }

        private void DrawFrameworkComponentsSetup()
        {
            LdxEditorHelper.DrawHorizontalSeparator();
            LdxEditorHelper.DrawTitle("Framework Components");

            foreach (SceneSetupObjectDefinition definition in setupObjectDefinitions)
            {
                using (new EditorGUILayout.HorizontalScope())
                {
                    GUIStyle style = definition.InScene
                        ? LdxEditorHelper.GreenLabelStyle
                        : LdxEditorHelper.RedLabelStyle;
                    EditorGUILayout.LabelField(definition.InScene ? "" : "", style,GUILayout.Width(30));
          
                    EditorGUILayout.LabelField(definition.Type.Name, style);
                    if (!definition.InScene)
                    {
                        definition.IsSelected = EditorGUILayout.Toggle(definition.IsSelected);
                    }
                    GUILayout.FlexibleSpace();
                }
            }

            if (GUILayout.Button("Apply Framework Components Setup", GUILayout.Width(400)))
            {
                AddFrameworkComponents();
            }
        }

        private void AddFrameworkComponents()
        {
            Transform parent = GetOrCreatePrefabsParent().transform;
            foreach (SceneSetupObjectDefinition definition in setupObjectDefinitions)
            {
                definition.InstantiateInScene(setupPrefabs, parent);
            }
            
            BroadcastSetupRefreshed();
        }
        
        private void SetupScenarioObject()
        {
            SceneSetupEditorFeatures.OnScenarioObjectSetupComplete += handleScenarioObjectSetupComplete;

            switch (scenarioData.Type)
            {
                case ScenarioDataType.Scenario:
                    SceneSetupEditorFeatures.SetupScenarioSceneFeature();
                    break;
                case ScenarioDataType.Lobby:
                    SceneSetupEditorFeatures.SetupLobbySceneFeature();
                    break;
                case ScenarioDataType.Tutorial:
                    SceneSetupEditorFeatures.SetupTutorialSceneFeature();
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
            
            void handleScenarioObjectSetupComplete(bool success)
            {
                SceneSetupEditorFeatures.OnScenarioObjectSetupComplete -= handleScenarioObjectSetupComplete;

                if (success)
                {
                    BroadcastSetupRefreshed();
                }
            }
        }

        private List<SceneSetupObjectDefinition> GetAllSetupObjectDefinitions()
        {
            List<SceneSetupObjectDefinition> result = new();
            
            Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();

            foreach (var assembly in assemblies)
            {
                Type[] types;
                try
                {
                    types = assembly.GetTypes();
                }
                catch (ReflectionTypeLoadException ex)
                {
                    types = ex.Types.Where(t => t != null).ToArray();
                }

                foreach (Type type in types)
                {
                    var attribute = type.GetCustomAttribute(typeof(SceneSetupLinkAttribute));
                    if (attribute != null)
                    {
                        SceneSetupObjectDefinition definition = new(type, attribute as SceneSetupLinkAttribute);
                        result.Add(definition);
                    }
                }
            }

            return result;
        }

        private GameObject GetOrCreatePrefabsParent()
        {
            GameObject obj = GameObject.Find(FRAMEWORK_COMPONENTS_PARENT_NAME);
            if (obj == null)
            {
                obj = new GameObject(FRAMEWORK_COMPONENTS_PARENT_NAME);
            }
            obj.transform.SetSiblingIndex(2);
            return obj;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/ScenarioWindow/Tabs/SceneSetupTab.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Scenes/CloneTemplatesToResourcesSavingAddOn.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: ef030822d1a04257a1082f265b525885
# ASMDEF: ldx.framework.editor.dll
# ---
using System.IO;
using Ldx.Framework.Utilities.Attributes;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.Scenes
{
    /// <summary>
    /// Clones Editor/Templates from the framework to the project's Resources folder
    /// </summary>
    [SceneSavingAddOn]
    public static class CloneTemplatesToResourcesSavingAddOn
    {
        private const string SOURCE_PATH = "Packages/com_ldx_framework/Editor/Templates/";
        private const string TARGET_PATH = "Assets/Resources/";

        public static void SceneSaving()
        {
            // Convert the sourcePath to an absolute path
            string absoluteSourcePath = Path.GetFullPath(SOURCE_PATH);

            // Check if the source directory exists
            if (!Directory.Exists(absoluteSourcePath))
            {
                Debug.LogError("Source directory does not exist: " + absoluteSourcePath);
                return;
            }

            // Iterate through all files in the source directory
            foreach (string sourceFile in Directory.GetFiles(absoluteSourcePath, "*", SearchOption.AllDirectories))
            {
                if (sourceFile.EndsWith(".meta"))
                {
                    // Skip .meta files
                    continue;
                }

                string relativePath = sourceFile.Substring(absoluteSourcePath.Length)
                    .TrimStart(Path.DirectorySeparatorChar);
                string targetFile = Path.Combine(TARGET_PATH, relativePath);

                string directoryName = Path.GetDirectoryName(targetFile);
                if (!Directory.Exists(directoryName))
                {
                    // Create directory if it doesn't exist
                    Directory.CreateDirectory(directoryName);
                }

                foreach (string dirPath in Directory.GetDirectories(absoluteSourcePath, "*", SearchOption.AllDirectories))
                {
                    string relativeDirPath = dirPath.Substring(absoluteSourcePath.Length).TrimStart(Path.DirectorySeparatorChar);
                    string targetDirPath = Path.Combine(TARGET_PATH, relativeDirPath);

                    if (!Directory.Exists(targetDirPath))
                    {
                        Debug.Log($"Created directory: {targetDirPath}");
                        Directory.CreateDirectory(targetDirPath);
                    }
                }
                
                if (!File.Exists(targetFile))
                {
                    // Copy the file if it doesn't exist in the target directory
                    File.Copy(sourceFile, targetFile);
                    Debug.Log("Copied file: " + sourceFile + " to " + targetFile);
                }
            }
            AssetDatabase.Refresh();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Scenes/CloneTemplatesToResourcesSavingAddOn.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Scenes/LogicalDoxFrameworkSceneMenu.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d169575eefabe5345b2a187d67ec9fb1
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using UnityEngine;
#if UNITY_EDITOR

namespace Ldx.Framework.Systems.Scenes
{
    /// <summary>
    /// This is the scene menu that allows us to easily create a new scene with all of the supporting scenes and prefabs in place.
    /// What happens is the player simply needs to name the scene, confirm the path location, and the prefabs/scenes will be created in the appropriate places.
    /// </summary>
    public class LogicalDoxFrameworkSceneMenu : EditorWindow
    {
        public string SceneName = "WorldName";
        public string path = "Assets/_Scenes";

        [MenuItem("LogicalDox/Create New Scene")]
        public static void ShowWindow()
        {
            GetWindow<LogicalDoxFrameworkSceneMenu>("LogicalDox Scene Menu");
        }


        private void OnGUI()
        {
            GUILayout.Label("Welcome to the Scene Menu.", EditorStyles.boldLabel);
            GUILayout.Space(10);
            GUILayout.Label($"All scenes will be saved to {path}", EditorStyles.helpBox);
            GUILayout.Space(10);
            SceneName = EditorGUILayout.TextField("Scene Name: ", SceneName);
            path = EditorGUILayout.TextField("Scene File Path: ", path);
            GUILayout.Space(10);
            GUILayout.Label($"Output will create an interactable scene, as well as a sound scene with this name. For example, scene_interactable_(name), scene_sound_(name)", EditorStyles.helpBox);
            GUILayout.Space(10);
            GUILayout.Label($"When wanting to run a full scene, You will launch bootstrap (all required things that dont change), the environment, and interactable, and sound.", EditorStyles.helpBox);

            //Allow player to select the "Base" version of global attributes, prefab for sound
            //However, they should already be picked.
            //A new prefab variant should be created based on the name as well.

            var oldScene = AssetDatabase.LoadAssetAtPath<SceneAsset>(path);

            EditorGUI.BeginChangeCheck();
            var environmentScene = EditorGUILayout.ObjectField("Environment Scene", oldScene, typeof(SceneAsset), false) as SceneAsset;

            if (EditorGUI.EndChangeCheck())
            {
                var newPath = AssetDatabase.GetAssetPath(environmentScene);
                //var scenePathProperty = path;
                //scenePathProperty.stringValue = newPath;
            }

            if (GUILayout.Button("Create Scene"))
            {
                Debug.Log($"Scene create button was pressed. Creating a scene based on {environmentScene} named {SceneName}");

                //Create scene
            }
        }

        static void CopyAndRename(string pathFrom, string pathTo, string renameTo)
        {
            //Setup is "sourcepath/YourFileOrFolder", and "destpath/YourFileOrFolder;
            //This can be used to create folders, as well as actual files.
            //Best practice is to have a "Base" Folder (DO NOT TOUCH), which contains All necessary files
            //THEN have a "Variant" folder, which is the one that will be copied, so that all necessary prefabs are variants.
            FileUtil.CopyFileOrDirectory(pathFrom, pathTo);
        }

    }
}
#endif
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Scenes/LogicalDoxFrameworkSceneMenu.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Scenes/RequireComponentInSceneSavingAddOn.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f4833ace423e48e4b98eb49fbee29b27
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Reflection;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Systems.Scenes
{
    /// <summary>
    /// Scene saving add-on that processes RequireComponentInSceneAttribute
    /// </summary>
    [SceneSavingAddOn]
    public static class RequireComponentInSceneSavingAddOn
    {
        public static void SceneSaving()
        {
            // On scene saving, find all the unique types in the scene, check if they have
            // the attribute. If so, process it.
            HashSet<Type> uniqueTypesSet = ReflectionHelpers.GetUniqueTypesInScene();
            foreach (Type t in uniqueTypesSet)
            {
                RequireComponentInSceneAttribute attribute = t.GetCustomAttribute<RequireComponentInSceneAttribute>();
                if (attribute == null)
                {
                    continue;
                }

                if (uniqueTypesSet.Contains(attribute.Type))
                {
                    continue;
                }

                GameObject newObject = new GameObject(attribute.Type.Name);
                newObject.AddComponent(attribute.Type);
                uniqueTypesSet.Add(attribute.Type);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Scenes/RequireComponentInSceneSavingAddOn.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Scenes/SceneModelInfoViewer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d46d02a651324b2792498004b940b7e3
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.Scenes
{
    public class SceneModelInfoViewer : EditorWindow
    {
        private class MeshInfo
        {
            public string Name { get; }
            public GameObject GameObject { get; }
            public bool IsHidden { get; }
            public int Count { get; }

            public MeshInfo(string name, GameObject gameObject, bool isHidden, int count)
            {
                Name = name;
                GameObject = gameObject;
                IsHidden = isHidden;
                Count = count;
            }
        }
        
        private Vector2 scrollPos;
        private List<MeshFilter> meshesInScene;
        private int totalTriangles = 0;
        private bool displayInactiveObjects;
        private GUIStyle hiddenStyle;

        private List<MeshInfo> infoList = new();
        private HashSet<Mesh> visitedMeshes = new();
        
        [MenuItem("Window/Scene Model Info Viewer")]
        private static void ShowWindow()
        {
            SceneModelInfoViewer window = GetWindow<SceneModelInfoViewer>();
            window.titleContent = new GUIContent("Scene Model Info Viewer");
            window.maxSize = new Vector2(800, 600);
            window.Show();
        }

        private void OnEnable()
        {
            ReprocessReferencesAndData();
            hiddenStyle = new GUIStyle(EditorStyles.linkLabel)
            {
                normal =
                {
                    textColor = new Color(0.9f, 0.2f, 0.3f)
                }
            };
        }
        
        private void ReprocessReferencesAndData()
        {
            infoList.Clear();
            visitedMeshes.Clear();
            meshesInScene = FindObjectsByType<MeshFilter>(FindObjectsInactive.Include, FindObjectsSortMode.None).Where(m => m.sharedMesh != null).ToList();
            meshesInScene.Sort(new MeshTrianglesComparer());
            totalTriangles = 0;
            foreach (MeshFilter m in meshesInScene)
            {
                Mesh mesh = m.sharedMesh;
                if (!visitedMeshes.Add(mesh))
                {
                    continue;
                }
                
                int count = m.sharedMesh.triangles.Length / 3;
                GameObject gameObject = m.gameObject;
                
                infoList.Add(new MeshInfo(m.name, gameObject, !gameObject.activeInHierarchy, count));
                totalTriangles += count;
            }   
        }

        private void OnGUI()
        {
            DrawInfoTable();
        }

        private void DrawInfoTable()
        {
            using (new EditorGUILayout.VerticalScope())
            {
                EditorGUILayout.Space(5);
                bool lastDisplayInactiveObjects = displayInactiveObjects;
                if (GUILayout.Button("Update", GUILayout.Width(200)))
                {
                    ReprocessReferencesAndData();
                }
                displayInactiveObjects = EditorGUILayout.Toggle("Display inactive objects?", displayInactiveObjects);
                if (displayInactiveObjects != lastDisplayInactiveObjects)
                {
                    ReprocessReferencesAndData();
                }
                EditorGUILayout.LabelField($"Total Triangles: {totalTriangles}");
                EditorGUILayout.Space(5);
                using (new EditorGUILayout.HorizontalScope())
                {
                    EditorGUILayout.LabelField("Mesh filters => triangles count", EditorStyles.boldLabel);
                }
                
                using (EditorGUILayout.ScrollViewScope scrollView = new(scrollPos))
                {
                    scrollPos = scrollView.scrollPosition;
                    foreach (MeshInfo m in infoList)
                    {
                        using (new EditorGUILayout.HorizontalScope())
                        {
                            if (GUILayout.Button($"{(m.IsHidden?"(HIDDEN) ":"")}{m.Name}, ", m.IsHidden? hiddenStyle : EditorStyles.linkLabel))
                            {
                                Selection.activeObject = m.GameObject;
                            }

                            EditorGUILayout.LabelField(m.Count.ToString());
                        }
                    }
                }
            }
        }
    }

    public class MeshTrianglesComparer : IComparer<MeshFilter>
    {
        public int Compare(MeshFilter m1, MeshFilter m2)
        {
            return m2.sharedMesh.triangles.Length.CompareTo(m1.sharedMesh.triangles.Length);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Scenes/SceneModelInfoViewer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Scenes/SceneSavingNotifier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 2aa0d9f213294ebb8f31d64cf29e80d6
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Reflection;
using Ldx.Framework.Utilities;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEngine;
using UnityEngine.SceneManagement;
using Object = UnityEngine.Object;

namespace Ldx.Framework.Systems.Scenes
{
    public class SceneSavingNotifier : UnityEditor.AssetModificationProcessor
    {
        private const double TIME_TO_WAIT_BETWEEN_SAVING = 3f;
        private const string SCENE_SAVING_ADD_ON_METHOD_NAME = "SceneSaving";

        private static double lastSavingTime;
        
        [InitializeOnLoadMethod]
        private static void InitializeOnLoad()
        {
            // After editor finishes initialization
            EditorApplication.delayCall += initializeAfterDelayCall;
            
            SceneManager.sceneLoaded -= handleSceneLoaded;
            SceneManager.sceneLoaded += handleSceneLoaded;
            
            void initializeAfterDelayCall()
            {
                try
                {
                    EditorApplication.delayCall -= initializeAfterDelayCall;

                    if (EditorApplication.isPlayingOrWillChangePlaymode)
                    {
                        return;
                    }
                    
                    RunSceneSavingFeatures(false);
                }
                catch (Exception e)
                {
                    Debug.LogError($"Handled exception: {e}");
                }
            }
            
            void handleSceneLoaded(Scene scene, LoadSceneMode mode)
            {
                RunSceneSavingFeatures(Application.isPlaying);
            }
        }

        private static void RunSceneSavingFeatures(bool isEnteringPlayMode)
        {
            // In prefab edit mode, return
            if (PrefabHelper.IsInPrefabStaging())
            {
                return;
            }

            if (EditorApplication.timeSinceStartup - lastSavingTime < TIME_TO_WAIT_BETWEEN_SAVING)
            {
                return;
            }
            lastSavingTime = EditorApplication.timeSinceStartup;

            ExecuteSceneSavingAddOns(isEnteringPlayMode);
            int trackedCount = 0;
            bool foundReferenceBank = false;
            MonoBehaviour[] monoBehaviours = Object.FindObjectsByType<MonoBehaviour>(FindObjectsInactive.Include, FindObjectsSortMode.None);
            foreach (MonoBehaviour s in monoBehaviours)
            {
                if (s.GetType().GetCustomAttribute<TrackedReferenceAttribute>() != null)
                {
                    trackedCount++;
                }

                if (s is ReferenceBank)
                {
                    foundReferenceBank = true;
                }

                if (!(s is ISaveSceneListener listener))
                {
                    continue;
                }

                listener.OnSceneSaving();
            }
            
            ISaveSceneListener.OnSceneSavingEvent?.Invoke();

            if (foundReferenceBank)
            {
                return;
            }

            if (trackedCount < 1)
            {
                return;
            }

            ReferenceBank bank = ReferenceBank.Instance;
            if (bank == null)
            {
                return;
            }
            bank.OnSceneSaving();
        }

        private static void ExecuteSceneSavingAddOns(bool isEnteringPlayMode)
        {
            List<Type> types = ReflectionHelpers.FindClassesWithAttribute<SceneSavingAddOnAttribute>();
            foreach (Type t in types)
            {
                SceneSavingAddOnAttribute attribute = t.GetCustomAttribute<SceneSavingAddOnAttribute>();
                if (isEnteringPlayMode && !attribute.ExecutesOnEnteringPlayMode)
                {
                    continue;
                }

                t.TryInvokeStaticMethod(SCENE_SAVING_ADD_ON_METHOD_NAME);
            }
        }

        private static string[] OnWillSaveAssets(string[] paths)
        {
            RunSceneSavingFeatures(false);
            return paths;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Scenes/SceneSavingNotifier.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Scoring/ScenarioScoringDataEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7ca6749388224aea9ad4c58769d3dfa9
# ASMDEF: ldx.framework.editor.dll
# ---
using Ldx.Framework.Scripts.Systems.Scoring;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.Scoring
{
    [CustomEditor(typeof(ScoringData))]
    public class ScenarioScoringDataEditor : Editor
    {
        private SerializedProperty scoringModeProp;
        private SerializedProperty startScoreProp;
        private SerializedProperty minScoreProp;
        private SerializedProperty maxScoreProp;
        private SerializedProperty passingScoringSystemModeProp;
        private SerializedProperty passingThresholdProp;
        private SerializedProperty immediateFailOnMinScoreProp;
        private SerializedProperty scoreRulesProperty;

        private void OnEnable()
        {
            scoringModeProp = serializedObject.FindProperty("scoringSystemMode");
            startScoreProp = serializedObject.FindProperty("startScore");
            minScoreProp = serializedObject.FindProperty("minScore");
            maxScoreProp = serializedObject.FindProperty("maxScore");
            passingScoringSystemModeProp = serializedObject.FindProperty("passingScoringSystemMode");
            passingThresholdProp = serializedObject.FindProperty("passingThreshold");
            immediateFailOnMinScoreProp = serializedObject.FindProperty("immediateFailOnMinScore");
            scoreRulesProperty = serializedObject.FindProperty("scoreRules");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.LabelField("Core Scoring Setup", EditorStyles.boldLabel);
            EditorGUI.indentLevel++; 
            EditorGUILayout.PropertyField(scoringModeProp, new GUIContent("Scoring Mode"));
            EditorGUILayout.PropertyField(startScoreProp, new GUIContent("Start Score"));
            EditorGUILayout.PropertyField(minScoreProp, new GUIContent("Min Score"));
            EditorGUILayout.PropertyField(maxScoreProp, new GUIContent("Max Score"));
            EditorGUI.indentLevel--;

            EditorGUILayout.Space(10);

            EditorGUILayout.LabelField("Passing Conditions", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(passingScoringSystemModeProp, new GUIContent("Passing Mode"));
            ScoringData.ScoringSystemMode currentPassingScoringMode = (ScoringData.ScoringSystemMode)passingScoringSystemModeProp.enumValueIndex;
            if (currentPassingScoringMode == ScoringData.ScoringSystemMode.Percentage)
            {
                float currentPercentage = passingThresholdProp.floatValue * 100f;
                EditorGUI.BeginChangeCheck();
                float newPercentage = EditorGUILayout.Slider(new GUIContent("Passing Threshold (%)"), currentPercentage, 0f, 100f);
                if (EditorGUI.EndChangeCheck())
                {
                    passingThresholdProp.floatValue = newPercentage / 100f;
                }
                passingThresholdProp.floatValue = Mathf.Clamp01(passingThresholdProp.floatValue);
            }
            else 
            {
                float currentMinScore = minScoreProp.floatValue;
                float currentMaxScore = maxScoreProp.floatValue;

                if (currentMaxScore < currentMinScore) 
                { 
                    EditorGUILayout.HelpBox("Max Score cannot be less than Min Score for Absolute Points Threshold Slider.", MessageType.Warning);
                    EditorGUILayout.PropertyField(passingThresholdProp, new GUIContent("Passing Threshold (Points)"));
                } 
                else 
                {
                    EditorGUI.BeginChangeCheck();
                    float newAbsolutePoints = EditorGUILayout.Slider(
                        new GUIContent("Passing Threshold (Points)"),
                        passingThresholdProp.floatValue,
                        currentMinScore,
                        currentMaxScore
                    );
                    if (EditorGUI.EndChangeCheck())
                    {
                        passingThresholdProp.floatValue = newAbsolutePoints;
                    }
                }
             
                passingThresholdProp.floatValue = Mathf.Clamp(passingThresholdProp.floatValue, currentMinScore, currentMaxScore);
            }
            
            EditorGUILayout.PropertyField(immediateFailOnMinScoreProp, new GUIContent("Immediate Fail On Min Score"));
            EditorGUI.indentLevel--;
        
            EditorGUILayout.Space(10);
            EditorGUILayout.PropertyField(scoreRulesProperty, new GUIContent("Rules"));
            
            serializedObject.ApplyModifiedProperties();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Scoring/ScenarioScoringDataEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Scoring/ScoreRuleDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 22af7dcbdc0440d0a0871ce4b3d44910
# ASMDEF: ldx.framework.editor.dll
# ---
using Ldx.Framework.Scripts.Systems.Scoring;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.Scoring
{
    [CustomPropertyDrawer(typeof(ScoringData.ScoreRule))]
    public class ScoreRuleDrawer : PropertyDrawer
    {
        private const float PADDING = 5f;
        private const float SPACING = 4f;
        private const float HEADER_HEIGHT = 22f;
        private const float MULTI_TRIGGER_BUTTON_SIZE = 20f;
        private const string POINTS_VALUE_LABEL = "{0} ({1})";
        
        private static float MaxButtonWidth;
        private static bool StylesInitialized;

        private static void Initialize()
        {
            if (StylesInitialized) return;

            GUIStyle buttonStyle = EditorStyles.miniButton;
            float taskWidth = buttonStyle.CalcSize(new GUIContent("TASK")).x;
            float mistakeWidth = buttonStyle.CalcSize(new GUIContent("MISTAKE")).x;
            float criticalWidth = buttonStyle.CalcSize(new GUIContent("CRITICAL")).x;
            MaxButtonWidth = Mathf.Max(taskWidth, mistakeWidth, criticalWidth) + 8;

            StylesInitialized = true;
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            Initialize();

            EditorGUI.BeginProperty(position, label, property);
            
            SerializedProperty eventNameProp = property.FindPropertyRelative("eventName");
            SerializedProperty trackingEventProp = property.FindPropertyRelative("trackingEvent");
            SerializedProperty eventTypeProp = property.FindPropertyRelative("eventType");
            SerializedProperty pointsValueProp = property.FindPropertyRelative("pointsValue");
            SerializedProperty allowMultipleTriggersProp = property.FindPropertyRelative("allowMultipleTriggers");

            ScoringData parentData = property.serializedObject.targetObject as ScoringData;
            ScoringData.ScoringSystemMode scoringModeType = parentData?.ScoringMode ?? ScoringData.ScoringSystemMode.AbsolutePoints; // Get the new global value
            ScoringData.ScoreRule.EventType currentEventType = (ScoringData.ScoreRule.EventType)eventTypeProp.enumValueIndex;
            
            Color originalBgColor = GUI.backgroundColor;
            if (currentEventType == ScoringData.ScoreRule.EventType.CriticalMistake)
            {
                GUI.backgroundColor = new Color(1f, 0.6f, 0.6f, 1f);
            }
            GUI.Box(position, GUIContent.none, EditorStyles.helpBox);
            GUI.backgroundColor = originalBgColor;

            Rect contentRect = new(position.x + PADDING, position.y + PADDING, position.width - PADDING * 2, position.height - PADDING * 2);
            Rect currentRect = new(contentRect.x, contentRect.y, contentRect.width, 0);
            
            Rect headerRect = new(currentRect.x, currentRect.y, currentRect.width, HEADER_HEIGHT);
            
            GUIContent mainButtonContent;
            Color buttonTintColor;

            switch (currentEventType)
            {
                case ScoringData.ScoreRule.EventType.Mistake:
                    mainButtonContent = new GUIContent("MISTAKE", "A non-critical error. Click to change type.");
                    buttonTintColor = new Color(1f, 0.9f, 0.4f, 1f);
                    break;
                case ScoringData.ScoreRule.EventType.CriticalMistake:
                    mainButtonContent = new GUIContent("CRITICAL", "A critical, scenario-failing error. Click to change type.");
                    buttonTintColor = new Color(1f, 0.6f, 0.6f, 1f);
                    break;
                default: // ScorableTask
                    mainButtonContent = new GUIContent("TASK", "A scorable task. Click to change type.");
                    buttonTintColor = new Color(0.6f, 1f, 0.6f, 1f);
                    break;
            }
            
            Rect mainButtonRect = new(headerRect.x, headerRect.y + (headerRect.height - EditorGUIUtility.singleLineHeight) / 2f, MaxButtonWidth, EditorGUIUtility.singleLineHeight);
            
            Color originalGUIColor = GUI.color;
            GUI.color = buttonTintColor;

            if (GUI.Button(mainButtonRect, mainButtonContent, EditorStyles.miniButton))
            {
                eventTypeProp.enumValueIndex = (eventTypeProp.enumValueIndex + 1) % 3;
            }
            GUI.color = originalGUIColor;
            
            float eventNameRightBound = headerRect.xMax;
            
            if (currentEventType != ScoringData.ScoreRule.EventType.CriticalMistake)
            {
                Rect multiTriggerButtonRect = new(headerRect.xMax - MULTI_TRIGGER_BUTTON_SIZE, headerRect.y + (headerRect.height - MULTI_TRIGGER_BUTTON_SIZE) / 2f, MULTI_TRIGGER_BUTTON_SIZE, MULTI_TRIGGER_BUTTON_SIZE);
                eventNameRightBound = multiTriggerButtonRect.x - SPACING; // Adjust the bound for the event name

                bool isMultiTrigger = allowMultipleTriggersProp.boolValue;
                GUIContent multiTriggerIcon = isMultiTrigger
                    ? EditorGUIUtility.IconContent("d_preAudioLoopOn", "Multi-Trigger: ON. Can be triggered multiple times. Click to disable.")
                    : EditorGUIUtility.IconContent("d_preAudioLoopOff", "Multi-Trigger: OFF. Processed only once. Click to enable.");

                if (isMultiTrigger) GUI.color = new Color(0.3f, 1f, 0.3f, 1f);

                if (GUI.Button(multiTriggerButtonRect, multiTriggerIcon, GUIStyle.none))
                {
                    allowMultipleTriggersProp.boolValue = !isMultiTrigger;
                }
                GUI.color = originalGUIColor;
            }
            
            Rect eventNameRect = new(mainButtonRect.xMax + SPACING,
                                         headerRect.y + (headerRect.height - EditorGUIUtility.singleLineHeight) / 2f,
                                         eventNameRightBound - (mainButtonRect.xMax + SPACING),
                                         EditorGUIUtility.singleLineHeight);
            
            EditorGUI.PropertyField(eventNameRect, eventNameProp, GUIContent.none);
            currentRect.y += HEADER_HEIGHT + SPACING;
            
            float trackingEventHeight = EditorGUI.GetPropertyHeight(trackingEventProp, true);
            Rect trackingEventRect = new(currentRect.x, currentRect.y, currentRect.width, trackingEventHeight);
            EditorGUI.PropertyField(trackingEventRect, trackingEventProp);
            currentRect.y += trackingEventHeight + SPACING;
            
            if (currentEventType != ScoringData.ScoreRule.EventType.CriticalMistake)
            {
                GUIContent pointsLabel = GetPointsValueLabel(scoringModeType, currentEventType);
                Rect pointsLineRect = new(currentRect.x, currentRect.y, currentRect.width, EditorGUIUtility.singleLineHeight);
               
                if (scoringModeType == ScoringData.ScoringSystemMode.Percentage)
                {
                    float currentPercentage = pointsValueProp.floatValue * 100f;
                    EditorGUI.BeginChangeCheck();
                    float newPercentage = EditorGUI.Slider(pointsLineRect, pointsLabel, currentPercentage, 0f, 100f);
                    if (EditorGUI.EndChangeCheck())
                    {
                        pointsValueProp.floatValue = newPercentage / 100f;
                    }
                }
                else 
                {
                    EditorGUI.PropertyField(pointsLineRect, pointsValueProp, pointsLabel);
                }
            }
            
            if (currentEventType == ScoringData.ScoreRule.EventType.CriticalMistake)
            {
                Rect helpBoxRect = new(contentRect.x, currentRect.y, contentRect.width, EditorGUIUtility.singleLineHeight * 2);
                EditorGUI.HelpBox(helpBoxRect, "Triggering this event will result in an immediate scenario failure.", MessageType.Warning);
            }

            EditorGUI.EndProperty();
        }

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            float totalHeight = PADDING * 2;
            totalHeight += HEADER_HEIGHT + SPACING;

            SerializedProperty trackingEventProp = property.FindPropertyRelative("trackingEvent");
            totalHeight += EditorGUI.GetPropertyHeight(trackingEventProp, true) + SPACING;
            
            SerializedProperty eventTypeProp = property.FindPropertyRelative("eventType");
            ScoringData.ScoreRule.EventType currentEventType = (ScoringData.ScoreRule.EventType)eventTypeProp.enumValueIndex;
            
            if (currentEventType != ScoringData.ScoreRule.EventType.CriticalMistake)
            {
                totalHeight += EditorGUIUtility.singleLineHeight + SPACING; // Points line
            }
            
            if (currentEventType == ScoringData.ScoreRule.EventType.CriticalMistake)
            {
                totalHeight += (EditorGUIUtility.singleLineHeight * 2) + SPACING; // Warning box
            }
            
            return totalHeight;
        }
        
        private GUIContent GetPointsValueLabel(ScoringData.ScoringSystemMode mode, ScoringData.ScoreRule.EventType type)
        {
            string  baseLabelText = string.Format(POINTS_VALUE_LABEL, 
                type == ScoringData.ScoreRule.EventType.ScorableTask ? "Points to Award" : "Points to Deduct",
                mode == ScoringData.ScoringSystemMode.Percentage ? "%" : "Pts");
            string tooltipText = (type == ScoringData.ScoreRule.EventType.ScorableTask) 
                ? "Points awarded for completing this task." 
                : "Points lost if this error occurs.";
            
            return new GUIContent(baseLabelText, tooltipText);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Scoring/ScoreRuleDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/Sound/LdxSoundManagerExtensionEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f3675fe435f2c5f47b34761c4953bf45
# ASMDEF: ldx.framework.editor.dll
# ---
#if UNITY_EDITOR
using Ldx.Framework.Systems.AudioSystem;
using UnityEditor;

namespace Ldx.Framework.Systems.Sound
{
    [CustomEditor(typeof(LdxSoundManagerExtension))]
    public class LdxSoundManagerExtensionEditor : UnityEditor.Editor
    {
        bool useList;
        LdxSoundManagerExtension extension;

        private void OnEnable()
        {
            extension = (LdxSoundManagerExtension)target;
            //useList = extension.useList;
        }

        public override void OnInspectorGUI()
        {
            DrawDefaultInspector();

            extension = (LdxSoundManagerExtension)target;
            EditorGUILayout.LabelField("Add to Collision");

            if (useList)
            {
                //  EditorGUILayout.Prop
            }
        }

    }
}
#endif
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/Sound/LdxSoundManagerExtensionEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/UI/AnchorControllerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: dd3a6acf6adc44399b5128c29717d52e
# ASMDEF: ldx.framework.editor.dll
# ---
using Ldx.Framework.UI.Dialog;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.UI
{
    [CustomEditor(typeof(UIAnchorController))]
    public class AnchorControllerEditor : UnityEditor.Editor
    {
        private UIAnchorController Target => (UIAnchorController)target;
        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
            if (Target.CurrentAnchorType == UIAnchorController.AnchorType.AnchorPoint)
            {
                DrawAddAnchorButton();
            }
            else if(Target.CurrentAnchorType == UIAnchorController.AnchorType.AnchorGroup)
            {
                DrawAddAnchorGroupButton();
            }
        }

        private void DrawAddAnchorGroupButton()
        {
            if (GUILayout.Button("Add Anchor group"))
            {
                Target.EDITOR_AddAnchorGroup();
            }
        }
        
        private void DrawAddAnchorButton()
        {
            if (GUILayout.Button("Add Anchor"))
            {
                Target.EDITOR_AddAnchor();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/UI/AnchorControllerEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/UI/SegmentAnchorControllerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d9d02f1725214dea8c95ea873889f066
# ASMDEF: ldx.framework.editor.dll
# ---
using Ldx.Framework.Systems.UI;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.UI
{
    [CustomEditor(typeof(SegmentAnchorController))]
    public class SegmentAnchorControllerEditor : Editor
    {
        private SegmentAnchorController Target => (SegmentAnchorController)target;

        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
            if (GUILayout.Button("Add Anchor"))
            {
                Target.EDITOR_AddAnchor();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/UI/SegmentAnchorControllerEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/UI/UIAnchorEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 4ee6cb1c98bc4e6dae4697b783ac6908
# ASMDEF: ldx.framework.editor.dll
# ---
using Ldx.Framework.UI.Dialog;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.UI
{
    [CustomEditor(typeof(UIAnchor))]
    public class UIAnchorEditor : UnityEditor.Editor
    {
        private UIAnchor Target => (UIAnchor)target;
        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
            if (GUILayout.Button("Add Anchor"))
            {
                Target.GetComponentInParent<IAnchorParent>().EDITOR_AddAnchor();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/UI/UIAnchorEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/UI/UIAnchorGroupEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 672c54c946f9cf64ca4d52920414c6bc
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections;
using System.Collections.Generic;
using Ldx.Framework.UI.Dialog;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.UI
{
    [CustomEditor(typeof(UIAnchorGroup))]
    public class UIAnchorGroupEditor : UnityEditor.Editor
    {
        private UIAnchorGroup Target => (UIAnchorGroup)target;
        
        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
            if (GUILayout.Button("Add Anchor"))
            {
                Target.EDITOR_AddAnchor();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/UI/UIAnchorGroupEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Systems/UI/UITweenedStatesEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7e63780018c4a4d4292b17762d706de8
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using UnityEditor;
using UnityEditorInternal;
using UnityEngine;

namespace Ldx.Framework.Systems.UI
{
    [CustomEditor(typeof(UITweenedStates))]
    public class UITweenedStatesEditor : Editor
    {
        private const float VSpacing = 2f;

        private static float Line => EditorGUIUtility.singleLineHeight;
        
        private ReorderableList list;
        private readonly List<bool> foldouts = new List<bool>();

        private void OnEnable()
        {
            list = new ReorderableList(serializedObject,
                serializedObject.FindProperty("targets"),
                true, true, true, true)
            {
                drawHeaderCallback = rect => {
                    EditorGUI.LabelField(rect, "Tween Targets");
                }
            };

            list.elementHeightCallback = index =>
            {
                SerializedProperty element = list.serializedProperty.GetArrayElementAtIndex(index);
                float height = EditorGUIUtility.singleLineHeight * 6;
                if (foldouts.Count <= index) foldouts.Add(false);
                if (!foldouts[index]) return EditorGUIUtility.singleLineHeight + 6;
                return GetElementHeight(element);
            };

            list.drawElementCallback = (rect, index, active, focused) =>
            {
                SerializedProperty element = list.serializedProperty.GetArrayElementAtIndex(index);
                if (foldouts.Count <= index) foldouts.Add(false);

                Rect foldoutRect = new Rect(rect.x + 20, rect.y, rect.width, EditorGUIUtility.singleLineHeight);
                Object targetObject = element.FindPropertyRelative("targetObject").objectReferenceValue;
                foldouts[index] = EditorGUI.Foldout(foldoutRect, foldouts[index], targetObject == null ? $"Target {index + 1}" : targetObject.name, true);

                if (!foldouts[index]) return;

                EditorGUI.indentLevel++;
                float y = foldoutRect.y + EditorGUIUtility.singleLineHeight + 4;

                EditorGUI.PropertyField(new Rect(rect.x, y, rect.width, EditorGUIUtility.singleLineHeight),
                    element.FindPropertyRelative("targetObject"));
                y += EditorGUIUtility.singleLineHeight + 6;

                EditorGUI.LabelField(new Rect(rect.x, y, rect.width, EditorGUIUtility.singleLineHeight), "Tween Properties");
                y += EditorGUIUtility.singleLineHeight + 2;

                DrawToggleWithFields(
                    ref y,
                    rect,
                    element,
                    "usePosition",
                    new GUIContent("Position"),
                    new[] { "onlyUseZAxis", "hoverPosition", "clickedPosition" },
                    new[] { new GUIContent("Only Use Z Axis"), new GUIContent("Hover Position"), new GUIContent("Clicked Position") }
                );

                DrawToggleWithFields(
                    ref y,
                    rect,
                    element,
                    "useScale",
                    new GUIContent("Scale"),
                    new[] { "hoverScale", "clickedScale" },
                    new[] { new GUIContent("Hover Scale"), new GUIContent("Clicked Scale") }
                );
                
                DrawToggleWithFields(
                    ref y,
                    rect,
                    element,
                    "useColor",
                    new GUIContent("Color"),
                    new[] { "hoverColor", "clickedColor" },
                    new[] { new GUIContent("Hover Color"), new GUIContent("Clicked Color") }
                );


                y += 4;

                EditorGUI.PropertyField(new Rect(rect.x + 10, y, rect.width - 10, EditorGUIUtility.singleLineHeight),
                    element.FindPropertyRelative("duration"));
                y += EditorGUIUtility.singleLineHeight + 2;

                EditorGUI.PropertyField(new Rect(rect.x + 10, y, rect.width - 10, EditorGUIUtility.singleLineHeight),
                    element.FindPropertyRelative("delay"));
                y += EditorGUIUtility.singleLineHeight + 2;

                EditorGUI.PropertyField(new Rect(rect.x + 10, y, rect.width - 10, EditorGUIUtility.singleLineHeight),
                    element.FindPropertyRelative("ease"));

                EditorGUI.indentLevel--;
            };
        }

        private void DrawToggleWithField(ref float y, Rect rect, SerializedProperty element, string toggleName, string valueName, GUIContent label)
        {
            SerializedProperty toggleProp = element.FindPropertyRelative(toggleName);
            SerializedProperty valueProp = element.FindPropertyRelative(valueName);

            float lineHeight = EditorGUIUtility.singleLineHeight;
            float toggleWidth = 35f;
            float labelWidth = 70f;
            float spacing = 4f;

            Rect toggleRect = new Rect(rect.x + 10, y, toggleWidth, lineHeight);
            Rect labelRect = new Rect(toggleRect.xMax + spacing, y, labelWidth, lineHeight);
            Rect fieldRect = new Rect(labelRect.xMax + spacing, y, rect.width - toggleWidth - labelWidth - 40, lineHeight);

            EditorGUI.BeginChangeCheck();
            bool toggled = EditorGUI.Toggle(toggleRect, toggleProp.boolValue);
            if (EditorGUI.EndChangeCheck()) toggleProp.boolValue = toggled;

            EditorGUI.LabelField(labelRect, label);

            if (toggleProp.boolValue)
            {
                if (valueProp.propertyType == SerializedPropertyType.Vector3)
                    valueProp.vector3Value = EditorGUI.Vector3Field(fieldRect, GUIContent.none, valueProp.vector3Value);
                else if (valueProp.propertyType == SerializedPropertyType.Color)
                    valueProp.colorValue = EditorGUI.ColorField(fieldRect, GUIContent.none, valueProp.colorValue);
            }

            y += lineHeight + spacing;
        }
        
        private void DrawToggleWithFields(
            ref float y,
            Rect rect,
            SerializedProperty element,
            string toggleName,
            GUIContent toggleLabel,
            string[] valueNames,
            GUIContent[] valueLabels)
        {
            const float vSpacing = 4f;
            float line = EditorGUIUtility.singleLineHeight;

            SerializedProperty toggleProp = element.FindPropertyRelative(toggleName);

            Rect toggleRect = new Rect(rect.x, y, rect.width, line);
            toggleProp.boolValue = EditorGUI.ToggleLeft(toggleRect, toggleLabel, toggleProp.boolValue);
            y += line + vSpacing;

            if (!toggleProp.boolValue)
                return;

            EditorGUI.indentLevel++;
            for (int i = 0; i < valueNames.Length; i++)
            {
                SerializedProperty prop = element.FindPropertyRelative(valueNames[i]);
                if (prop != null)
                {
                    float h = EditorGUI.GetPropertyHeight(prop, true);
                    Rect fieldRect = new Rect(rect.x, y, rect.width, h);
                    GUIContent label = (valueLabels != null && i < valueLabels.Length) ? valueLabels[i] : GUIContent.none;
                    EditorGUI.PropertyField(fieldRect, prop, label, true);
                    y += h + vSpacing;
                }
                else
                {
                    Rect warnRect = new Rect(rect.x, y, rect.width, line);
                    EditorGUI.HelpBox(warnRect, $"Missing property: {valueNames[i]}", MessageType.Warning);
                    y += line + vSpacing;
                }
            }
            EditorGUI.indentLevel--;
        }
        
        // Height for a single toggle that may reveal multiple stacked fields
        private static float GetToggleWithFieldsHeight(SerializedProperty element, string toggleName, params string[] valueNames)
        {
            float h = Line + VSpacing; // the toggle row itself

            var toggleProp = element.FindPropertyRelative(toggleName);
            if (toggleProp != null && toggleProp.boolValue)
            {
                foreach (var name in valueNames)
                {
                    var p = element.FindPropertyRelative(name);
                    h += EditorGUI.GetPropertyHeight(p ?? element, true) + VSpacing; // reserve space for each field
                }
            }
            return h;
        }

        // Total height for the whole element you draw (header + three toggle groups)
        public static float GetElementHeight(SerializedProperty element)
        {
            float h = 0f;

            // Header
            h += Line + VSpacing;

            // Position (hover/clicked)
            h += GetToggleWithFieldsHeight(element, "usePosition", "hoverPosition", "clickedPosition");

            // Scale (hover/clicked)
            h += GetToggleWithFieldsHeight(element, "useScale", "hoverScale", "clickedScale");

            // Color (hover/clicked)
            h += GetToggleWithFieldsHeight(element, "useColor", "hoverColor", "clickedColor");

            // Bottom padding
            h += 120f;

            return h;
        }



        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            list.DoLayoutList();
            serializedObject.ApplyModifiedProperties();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Systems/UI/UITweenedStatesEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Animation/DoTweenAnimationEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d8f4fb7e4a684a09992a999efa4d41db
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Cysharp.Threading.Tasks;
using DG.DOTweenEditor;
using DG.Tweening;
using FluffyUnderware.DevTools.Extensions;
using Ldx.Framework.Utilities.Animation;
using Ldx.Framework.Utilities.Extensions;
using Systems.Settings;
using UnityEditor;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;
using Sequence = DG.Tweening.Sequence;

namespace Scripts.Utilities.Animation
{
    [CustomEditor(typeof(DoTweenAnimation))]
    public class DoTweenAnimationEditor : Editor
    {
        private Toggle playOnEnableToggle;
        private Toggle loopToggle;
        private Button playStopButton;
        private VisualElement playStopButtonIcon;
        private Button addBehaviourButton;
        private VisualElement loopContent;
        private VisualElement tweensContainer;
        private Sequence editorSequence;
        private VisualElement root;

        private DoTweenAnimation Target => (DoTweenAnimation)target;
        
        private bool IsPlaying => Application.isPlaying ?
                Target.IsPlaying : editorSequence?.IsPlaying() == true || DOTweenEditorPreview.isPreviewing;
        
        public override VisualElement CreateInspectorGUI()
        {
            root = EditorGlobalSettings.DotweenAnimationXml.CloneTree();
            root.Bind(serializedObject);
            
            AssignAnimationID();
            AssignPlayButton();
            AssignPlayOnEnableButton();
            AddLoopingSection();
            DrawDoTweenBehaviourContainer();
            AssignAddBehaviourButton();
            DrawTriggerEvents();
            DrawCompletedTrackingEventSection();
            
            root.styleSheets.Add(EditorGlobalSettings.DotweenAnimationStyle);
            return root;
        }
        
        private void AssignAnimationID()
        {
            TextField textField = root.Q<TextField>("id");
            textField.BindProperty(serializedObject.FindProperty("id"));
        }

        /// <summary>
        /// Assigns the play/stop button functionality and visual updates.
        /// </summary>
        private void AssignPlayButton()
        {
            playStopButton = root.Q<Button>("play-stop-button");
            playStopButton.clicked -= HandlePlayStopButtonClicked;
            playStopButton.clicked += HandlePlayStopButtonClicked;
            playStopButtonIcon = playStopButton.Q<VisualElement>("play-stop-button-icon");
            UpdatePlayStopButtonVisuals(IsPlaying);
        }

        /// <summary>
        /// Handles the play/stop button click event, toggling the tween animation state.
        /// </summary>
        private void HandlePlayStopButtonClicked()
        {
            bool isPlaying = IsPlaying;
            if (isPlaying)
            {
                StopTween();
            }
            else
            {
                PlayTween();
            }
        }

        /// <summary>
        /// Updates the visuals of the play/stop button based on whether the tween is playing.
        /// </summary>
        /// <param name="isPlaying">Indicates whether the tween is currently playing.</param>
        private void UpdatePlayStopButtonVisuals(bool isPlaying)
        {
            playStopButton.ToggleClass("play-button", !isPlaying);
            playStopButton.ToggleClass("stop-button", isPlaying);
            playStopButtonIcon.ToggleClass("play-button-icon", !isPlaying);
            playStopButtonIcon.ToggleClass("stop-button-icon", isPlaying);
            serializedObject.ApplyModifiedProperties();
        }
        
        /// <summary>
        /// Assigns the play on enable toggle button to the respective serialized property.
        /// </summary>
        private void AssignPlayOnEnableButton()
        {
            SerializedProperty playOnEnableProp = serializedObject.FindProperty("playOnEnable");
            playOnEnableToggle = root.Q<Toggle>("on-enable-toggle");
            playOnEnableToggle.BindProperty(playOnEnableProp);
        }
        
        /// <summary>
        /// Adds the looping section UI, handling toggle and visibility of loop properties.
        /// </summary>
        private void AddLoopingSection()
        {
            SerializedProperty loopProp = serializedObject.FindProperty("loop");
            SerializedProperty loopCountProp = serializedObject.FindProperty("loopCount");
            SerializedProperty loopTypeProp = serializedObject.FindProperty("loopType");

            VisualElement container = root.Q<VisualElement>("loop-group");
            loopToggle = container.Q<Toggle>("loop-toggle");
            loopToggle.BindProperty(loopProp);
            loopToggle.RegisterValueChangedCallback(_ => UpdateLoopContentVisibility());

            loopContent = root.Q<VisualElement>("loop-content");

            PropertyField loopCountField = new(loopCountProp);
            PropertyField loopTypeField = new(loopTypeProp);
            loopContent.Add(loopCountField);
            loopContent.Add(loopTypeField);
            UpdateLoopContentVisibility();
        }
        
        /// <summary>
        /// Updates the visibility of the loop content based on the loop toggle state.
        /// </summary>
        private void UpdateLoopContentVisibility()
        {
            loopContent.ToggleClass("hidden", !loopToggle.value);
            Repaint();
        }

        /// <summary>
        /// Assigns the button functionality for adding new tween behaviours.
        /// </summary>
        private void AssignAddBehaviourButton()
        {
            addBehaviourButton = root.Q<Button>("add-tween-button");
            addBehaviourButton.clicked -= ShowAddBehaviourMenu;
            addBehaviourButton.clicked += ShowAddBehaviourMenu;
        }

        /// <summary>
        /// Draws the DoTween behaviours container, showing a list of behaviours added to the animation.
        /// </summary>
        private void DrawDoTweenBehaviourContainer()
        {
            tweensContainer = root.Q<VisualElement>("tweens-container");
            tweensContainer.Clear();

            SerializedProperty behavioursProp = serializedObject.FindProperty("tweenBehaviourContainer").FindPropertyRelative("behaviours");
            
            ListView listView = new()
            {
                itemsSource = new List<int>(Enumerable.Range(0, behavioursProp.arraySize)),
                makeItem = () => new VisualElement(),
                bindItem = (element, index) =>
                {
                    element.Clear();
                    SerializedProperty behaviourProp = behavioursProp.GetArrayElementAtIndex(index);
                    VisualElement behaviourElement = CreateBehaviourElement(behaviourProp, index);
                    element.Add(behaviourElement);
                },
                selectionType = SelectionType.None,
                reorderable = true,
                virtualizationMethod = CollectionVirtualizationMethod.DynamicHeight,
                style =
                {
                    flexGrow = 1.0f
                }
            };

            listView.itemIndexChanged += MoveBehaviour;
            tweensContainer.Add(listView);
        }
        
        /// <summary>
        /// Creates a VisualElement representing a tween behaviour, with its properties and actions.
        /// </summary>
        /// <param name="behaviourProp">The SerializedProperty representing the behaviour.</param>
        /// <param name="index">The index of the behaviour in the list.</param>
        /// <returns>A VisualElement for the behaviour.</returns>
        private VisualElement CreateBehaviourElement(SerializedProperty behaviourProp, int index)
        {
            VisualElement behaviourElement = EditorGlobalSettings.DotweenTweenElementXml.CloneTree();
            
            AssignIconClassAndCategory(behaviourElement, behaviourProp);
            AddBehaviourActions(behaviourElement, behaviourProp, index);
            
            behaviourElement.styleSheets.Add(EditorGlobalSettings.DotweenTweenElementStyle);
            behaviourElement.Bind(behaviourProp.serializedObject);
            return behaviourElement;
        }
        
        /// <summary>
        /// Moves a behaviour in the list when its index is changed.
        /// </summary>
        /// <param name="oldIndex">The original index of the behaviour.</param>
        /// <param name="newIndex">The new index of the behaviour.</param>
        private void MoveBehaviour(int oldIndex, int newIndex)
        {
            serializedObject.Update();

            SerializedProperty behavioursProp = serializedObject.FindProperty("tweenBehaviourContainer").FindPropertyRelative("behaviours");
            if (newIndex > oldIndex)
            {
                newIndex--;
            }
            behavioursProp.MoveArrayElement(oldIndex, newIndex);

            serializedObject.ApplyModifiedProperties();
            
            DrawDoTweenBehaviourContainer();
            root.Bind(serializedObject);
        }

        /// <summary>
        /// Assigns an icon and category label to a behaviour element based on its type.
        /// </summary>
        /// <param name="behaviourElement">The VisualElement representing the behaviour.</param>
        /// <param name="behaviourProp">The SerializedProperty of the behaviour.</param>
        private void AssignIconClassAndCategory(VisualElement behaviourElement, SerializedProperty behaviourProp)
        {
            VisualElement icon = behaviourElement.Q<VisualElement>("tween-icon");
            Label categoryLabel = behaviourElement.Q<Label>("tween-category");
            
            SerializedProperty categoryProp = behaviourProp.FindPropertyRelative("Category");

            if (categoryProp == null)
            {
                // Try getting the property directly in case it's in the base class
                categoryProp = behaviourProp.serializedObject.FindProperty("Category");
            }

            if (categoryProp != null)
            {
                DoTweenBaseBehaviour.BehaviourCategory category = (DoTweenBaseBehaviour.BehaviourCategory)categoryProp.enumValueIndex;
            
                switch (category)
                {
                    case DoTweenBaseBehaviour.BehaviourCategory.Transform:
                        icon.AddToClassList("category-transform");
                        break;
                    case DoTweenBaseBehaviour.BehaviourCategory.Graphic:
                        icon.AddToClassList("category-graphic");
                        break;
                    case DoTweenBaseBehaviour.BehaviourCategory.RectTransform:
                        icon.AddToClassList("category-rect-transform");
                        break;
                    case DoTweenBaseBehaviour.BehaviourCategory.LineRenderer:
                        icon.AddToClassList("category-line-renderer");
                        break;
                    case DoTweenBaseBehaviour.BehaviourCategory.CanvasGroup:
                        icon.AddToClassList("category-canvas-group");
                        break;
                    default:
                        Debug.LogWarning("");
                        break;
                }
                
                categoryLabel.text = category.ToString();

            }
         
            Label nameLabel = behaviourElement.Q<Label>("tween-label");
            nameLabel.text = GetBehaviourName(behaviourProp);
        }
        
        /// <summary>
        /// Adds the actions (delete, expand, etc.) and properties to the behaviour element.
        /// </summary>
        /// <param name="behaviourElement">The VisualElement for the behaviour.</param>
        /// <param name="behaviourProp">The SerializedProperty for the behaviour.</param>
        /// <param name="index">The index of the behaviour in the list.</param>
        private void AddBehaviourActions(VisualElement behaviourElement, SerializedProperty behaviourProp, int index)
        {
            Button deleteButton = behaviourElement.Q<Button>("delete-button");
            deleteButton.clicked += () => RemoveBehaviour(behaviourProp, index);
            Button expandButton = behaviourElement.Q<Button>("expand-button");
            VisualElement content = behaviourElement.Q<VisualElement>("tween-content");

            expandButton.clicked += () => ToggleExpandButton(content, expandButton, content.ClassListContains("hidden"));
            ToggleExpandButton(content, expandButton, true);

            AddBaseBehaviourProperties(behaviourProp, content);
            AddSerializedProperties(behaviourProp, content);
        }

        /// <summary>
        /// Toggles the expand/collapse state of a behaviour element.
        /// </summary>
        /// <param name="container">The container element holding the expandable content.</param>
        /// <param name="button">The button that toggles the expand/collapse state.</param>
        /// <param name="isExpanded">Indicates whether the element should start expanded.</param>
        private void ToggleExpandButton(VisualElement container, Button button, bool isExpanded = false)
        {
            container.ToggleClass("hidden", !isExpanded);
            button.ToggleClass("expand-button-closed", !isExpanded);
            button.ToggleClass("expand-button-opened", isExpanded);
        }

        /// <summary>
        /// Binds the base behaviour properties (action, delay, duration, etc.) to the UI.
        /// </summary>
        /// <param name="behaviourProp">The SerializedProperty for the behaviour.</param>
        /// <param name="container">The container element holding the properties.</param>
        private void AddBaseBehaviourProperties(SerializedProperty behaviourProp, VisualElement container)
        {
            EnumField actionEnum = container.Q<EnumField>("action-enum");
            actionEnum.BindProperty(behaviourProp.FindPropertyRelative("action"));

            FloatField delayFloat = container.Q<FloatField>("delay-float");
            delayFloat.BindProperty(behaviourProp.FindPropertyRelative("delay"));
    
            FloatField durationFloat = container.Q<FloatField>("duration-float");
            durationFloat.BindProperty(behaviourProp.FindPropertyRelative("duration"));
    
            EnumField easeEnum = container.Q<EnumField>("ease-enum");
            easeEnum.BindProperty(behaviourProp.FindPropertyRelative("ease"));
        }
        
        /// <summary>
        /// Adds all other serialized properties for a behaviour to the container UI.
        /// </summary>
        /// <param name="behaviourProp">The SerializedProperty for the behaviour.</param>
        /// <param name="container">The container element holding the properties.</param>
        private void AddSerializedProperties(SerializedProperty behaviourProp, VisualElement container)
        {
            HashSet<string> displayedProperties = new HashSet<string>();
            SerializedProperty iterator = behaviourProp.Copy();
            SerializedProperty endProperty = iterator.GetEndProperty();

            while (iterator.NextVisible(true) && !SerializedProperty.EqualContents(iterator, endProperty))
            {
                if (IsRelevantProperty(iterator, displayedProperties))
                {
                    PropertyField field = new PropertyField(iterator);
                    container.Add(field);
                    displayedProperties.Add(iterator.propertyPath); // Store the full property path
                }
            }
        }
        
        /// <summary>
        /// Determines if a serialized property is relevant for display.
        /// </summary>
        /// <param name="iterator">The property iterator.</param>
        /// <param name="displayedProperties">The set of properties already displayed.</param>
        /// <returns>True if the property should be displayed, false otherwise.</returns>
        private bool IsRelevantProperty(SerializedProperty iterator, HashSet<string> displayedProperties)
        {
            System.Reflection.FieldInfo field = iterator.serializedObject.targetObject.GetType().GetField(iterator.name, System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic);
            if (field != null && Attribute.IsDefined(field, typeof(HideInInspector)))
            {
                return false;
            }

            return iterator.name !=  "m_Script" && !displayedProperties.Any(dp => iterator.propertyPath.StartsWith(dp + "."));
        }

        private string GetBehaviourName(SerializedProperty behaviourProp)
        {
            string fullName = behaviourProp.managedReferenceFullTypename;
            string[] nameParts = fullName.Split('.');
            string className = nameParts[nameParts.Length - 1];
            return className.Replace("DoTween", "").Replace("Behaviour", "").SeparateWords();
        }
        
        /// <summary>
        /// Removes a behaviour from the list and updates the UI.
        /// </summary>
        /// <param name="behaviourProp">The SerializedProperty representing the behaviour.</param>
        /// <param name="index">The index of the behaviour in the list.</param>
        private void RemoveBehaviour(SerializedProperty behaviourProp, int index)
        {
            serializedObject.Update();

            SerializedProperty behavioursProp = serializedObject.FindProperty("tweenBehaviourContainer").FindPropertyRelative("behaviours");

            behavioursProp.DeleteArrayElementAtIndex(index);
            // Handle potential null entries
            if (index < behavioursProp.arraySize && behavioursProp.GetArrayElementAtIndex(index).managedReferenceValue == null)
            {
                behavioursProp.DeleteArrayElementAtIndex(index);
            }
            
            serializedObject.ApplyModifiedProperties();
            serializedObject.Update();
            
            DrawDoTweenBehaviourContainer();
            root.Bind(serializedObject);
            Repaint();
        }
        
        /// <summary>
        /// Draws trigger events lists
        /// </summary>
        private void DrawTriggerEvents()
        {
            SerializedProperty playAnimationTriggerEvents = serializedObject.FindProperty("playAnimationTriggerEvents");
            SerializedProperty stopAnimationTriggerEvents = serializedObject.FindProperty("stopAnimationTriggerEvents");

            VisualElement container = root.Q<VisualElement>("events-content");
            
            PropertyField playTriggerEvents = new(playAnimationTriggerEvents);
            PropertyField stopTriggerEvents = new(stopAnimationTriggerEvents);
            container.Add(playTriggerEvents);
            container.Add(stopTriggerEvents);
        }

        private void DrawCompletedTrackingEventSection()
        {
            SerializedProperty onAnimationCompleteEvent = serializedObject.FindProperty("completedTrackingEventId");

            VisualElement triggerBox = root.Q<VisualElement>("completion-content");
            
            PropertyField onCompleteEvent = new(onAnimationCompleteEvent);

            triggerBox.Add(onCompleteEvent);
        }
        
        /// <summary>
        /// Plays the tween animation either in play mode or in the editor.
        /// </summary>
        private void PlayTween()
        {
            if (Application.isPlaying)
            {
                Target.Play(true);
            }
            else
            {
                PlayTweenEditorAsync().Forget();
            }
            
            UpdatePlayStopButtonVisuals(true);
        }

        /// <summary>
        /// Plays the tween animation in the editor asynchronously.
        /// </summary>
        private async UniTask PlayTweenEditorAsync()
        {
            editorSequence = Target.CreateSequence();
            DOTweenEditorPreview.PrepareTweenForPreview(editorSequence);
            DOTweenEditorPreview.Start();
            await UniTask.Delay(editorSequence.Duration().ToMilliseconds());
            StopTween();
        }

        /// <summary>
        /// Stops the tween animation, resetting its state.
        /// </summary>
        private void StopTween()
        {
            if (Application.isPlaying)
            {
                Target.Stop();
            }
            else
            {
                DOTweenEditorPreview.Stop(true);
                Target.Behaviours.ForEach(b => b.ResetState());
            }
            
            UpdatePlayStopButtonVisuals(false);
        }

        /// <summary>
        /// Shows the add behaviour context menu, allowing the user to add new tween behaviours.
        /// </summary>
        private void ShowAddBehaviourMenu()
        {
            GenericMenu menu = new GenericMenu();
            List<Type> behaviourTypes = AppDomain.CurrentDomain.GetAssemblies()
                .SelectMany(a => a.GetTypes())
                .Where(t => typeof(DoTweenBaseBehaviour).IsAssignableFrom(t) && !t.IsAbstract)
                .OrderBy(t => t.Name)
                .ToList();

            foreach (Type behaviourType in behaviourTypes)
            {
                string menuPath = GetBehaviourMenuPath(behaviourType);
                menu.AddItem(new GUIContent(menuPath), false, () => AddNewBehaviour(behaviourType));
            }

            menu.ShowAsContext();
        }

        /// <summary>
        /// Gets the menu path for a behaviour type to be displayed in the context menu.
        /// </summary>
        /// <param name="behaviourType">The type of the behaviour.</param>
        /// <returns>The formatted menu path.</returns>
        private string GetBehaviourMenuPath(Type behaviourType) => behaviourType.Name.Replace("DoTween", "").Replace("Behaviour", "").SeparateWords();

        /// <summary>
        /// Adds a new tween behaviour of the specified type to the list.
        /// </summary>
        /// <param name="behaviourType">The type of behaviour to add.</param>
        private void AddNewBehaviour(Type behaviourType)
        {
            SerializedProperty behavioursProp = serializedObject.FindProperty("tweenBehaviourContainer").FindPropertyRelative("behaviours");
            int index = behavioursProp.arraySize;
            behavioursProp.InsertArrayElementAtIndex(index);
            SerializedProperty newBehaviourProp = behavioursProp.GetArrayElementAtIndex(index);
            newBehaviourProp.managedReferenceValue = Activator.CreateInstance(behaviourType);
            serializedObject.ApplyModifiedProperties();
            serializedObject.Update();
            DrawDoTweenBehaviourContainer();
            root.Bind(serializedObject);
            Repaint();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Animation/DoTweenAnimationEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/AssetsCheckout/AssetCheckoutItem.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 939b2c9e219a456d9340398f6c777872
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Ldx.Framework.Utilities.Hierarchy;
using Newtonsoft.Json;
using UnityEngine;

namespace Ldx.Framework.Utilities.AssetsCheckout
{
    public enum AssetCheckoutType
    {
        Scene,
        Prefab
    }

    public enum AssetCheckoutStatus
    {
        Locked,
        Unlocked
    }
    
    public class AssetCheckoutItem
    {
        public string AssetName { get; }
        public string Type { get; }
        public string IsLocked { get; set; }
        public string ReservedBy { get; set; }
        public string Branch { get; set; }

        public AssetCheckoutItem(string assetName, string type, string isLocked, string reservedBy, string branch)
        {
            AssetName = assetName;
            Type = type;
            IsLocked = isLocked;
            ReservedBy = reservedBy;
            Branch = branch;
        }

        public AssetCheckoutStatus GetStatus()
        {
            return IsLocked == "true" ? AssetCheckoutStatus.Locked : AssetCheckoutStatus.Unlocked;
        }
    }
    
    public class AssetsCheckoutUpdate
    {
        public string ProjectName { get; set; }
        public List<AssetCheckoutItem> Assets { get; set; }

        public AssetsCheckoutUpdate(string projectName, List<AssetCheckoutItem> assets)
        {
            ProjectName = projectName;
            Assets = assets;
        }
    }

    /// <summary>
    /// Stores a cache of the last results from the Asset Checkout window
    /// </summary>
    public static class AssetCheckoutCache
    {
        private static char S => Path.DirectorySeparatorChar;
        private static string AssetCheckoutCachePath =>
            Application.dataPath + S + "Resources" + S + "Local";

        private static string AssetCheckoutCacheFilePath =>
            AssetCheckoutCachePath + S + "asset_checkout_cache.json";

        private static List<AssetCheckoutItem> current; 

        public static Dictionary<string, AssetCheckoutItem> AssetNameToData = new();

        public static void Save(List<AssetCheckoutItem> items)
        {
            current = items;
            AssetNameToData = current.ToDictionary(a => a.AssetName, a => a);
            string json = JsonConvert.SerializeObject(items);
            if (!Directory.Exists(AssetCheckoutCachePath))
            {
                Directory.CreateDirectory(AssetCheckoutCachePath);
            }

            File.WriteAllText(AssetCheckoutCacheFilePath, json);
            HierarchyLockedAssetDrawer.Refresh();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/AssetsCheckout/AssetCheckoutItem.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/AssetsCheckout/AssetCheckoutItemVisual.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7ccd7788e6344d118fd7688718427028
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Linq;
using UnityEngine;
using UnityEngine.UIElements;


namespace Ldx.Framework.Utilities.AssetsCheckout
{
    public class AssetCheckoutItemVisual
    {
        public event Action<AssetCheckoutItemVisual, AssetCheckoutStatus> OnStatusChanged;
        public event Action<AssetCheckoutItemVisual> OnAssetDeleted;

        public AssetCheckoutItem CheckoutItem { get; }
        public VisualElement AssetCheckoutVisualElement { get; }

        private Label assetName;
        private Label assetOwner;
        private Label assetBranch;
        private Label assetType;
        private DropdownField assetStatus;
        private Button deleteAssetButton;

        private Color lockedColor = new(0.5490196f, 0, 0, 1);
        private Color unlockedColor = new(0, 0.5490196f, 0, 1);

        public AssetCheckoutItemVisual(AssetCheckoutItem assetCheckoutItem, VisualTreeAsset template)
        {
            CheckoutItem = assetCheckoutItem;

            TemplateContainer assetItemContainer = template.Instantiate();
            AssetCheckoutVisualElement = assetItemContainer.Q<VisualElement>("AssetCheckoutVisualElement");

            assetName = assetItemContainer.Q<Label>("AssetName");
            assetName.text = assetCheckoutItem.AssetName;
            
            assetOwner = assetItemContainer.Q<Label>("AssetOwner");
            assetOwner.text = assetCheckoutItem.ReservedBy;
            
            assetBranch = assetItemContainer.Q<Label>("AssetBranch");
            assetBranch.text = assetCheckoutItem.Branch;
            
            assetType = assetItemContainer.Q<Label>("AssetType");
            assetType.text = ((AssetCheckoutType)Int16.Parse(assetCheckoutItem.Type)).ToString();
            
            assetStatus = assetItemContainer.Q<DropdownField>("AssetStatus");
            assetStatus.choices.Clear();
            foreach (string enumName in Enum.GetNames(typeof(AssetCheckoutStatus)))
            {
                assetStatus.choices.Add(enumName);
            }
            assetStatus.index = (int)assetCheckoutItem.GetStatus();
            assetStatus.RegisterValueChangedCallback(OnValueChanged);
            ChangeDropdownBackgroundColor(assetStatus, CheckoutItem.GetStatus() == AssetCheckoutStatus.Locked ? lockedColor : unlockedColor);

            deleteAssetButton = assetItemContainer.Q<Button>("DeleteAssetButton");
            deleteAssetButton.clicked += HandleDeleteAssetButton;
        }

        public void ChangeAssetOwnerField(string reservedBy)
        {
            assetOwner.text = reservedBy;
        }
        
        public void ChangeAssetBranchField(string branch)
        {
            assetBranch.text = branch;
        }
        
        private void HandleDeleteAssetButton()
        {
            OnAssetDeleted?.Invoke(this);
        }

        private void OnValueChanged(ChangeEvent<string> evt)
        {
            string selectedValue = evt.newValue;
            
            if (Enum.TryParse(selectedValue, out AssetCheckoutStatus enumValue))
            {
                ChangeDropdownBackgroundColor(assetStatus, enumValue == AssetCheckoutStatus.Locked? lockedColor : unlockedColor);
                OnStatusChanged?.Invoke(this, enumValue);
            }
        }
        
        private void ChangeDropdownBackgroundColor(DropdownField dropdownField, Color color)
        {
            VisualElement inputField = dropdownField.Q(className: "unity-base-popup-field__input");

            if (inputField != null)
            {
                inputField.style.backgroundColor = new StyleColor(color);
            }
            else
            {
                UnityEngine.Debug.LogError("Input field not found!");
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/AssetsCheckout/AssetCheckoutItemVisual.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/AssetsCheckout/AssetsCheckoutWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b5be1f7e3e51494294b7d493955c4161
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Helpers;
using Ldx.Framework.Utilities.WebConnection;
using Newtonsoft.Json;
using UnityEditor;
using UnityEngine;
using UnityEngine.UIElements;
using Debug = UnityEngine.Debug;

namespace Ldx.Framework.Utilities.AssetsCheckout
{
    public class AssetsCheckoutWindow : EditorWindow
    {
        private const string WINDOW_TITLE = "Assets Checkout";
        private const string AWS_TOKEN = "AftFIb4VJAYF6wPGdmwboKcCV7ogjPCCg6CHFz2M47Sk2K4lt60GZBe7uFLL7IXW";
        private static readonly string UXML_PATH = string.Format("Packages{0}com_ldx_framework{0}Editor{0}Assets{0}CustomEditors{0}AssetsCheckout{0}AssetsCheckout.uxml", Path.DirectorySeparatorChar);
        private static readonly string ASSET_CHECKOUT_ITEM_TEMPLATE_UXML_PATH = string.Format("Packages{0}com_ldx_framework{0}Editor{0}Assets{0}CustomEditors{0}AssetsCheckout{0}AssetItem.uxml", Path.DirectorySeparatorChar);
        private static readonly string USS_PATH = string.Format("Packages{0}com_ldx_framework{0}Editor{0}Assets{0}CustomEditors{0}AssetsCheckout{0}AssetsCheckout.uss", Path.DirectorySeparatorChar);
        private const float MIN_TIME_TO_REFRESH_SECONDS = 30;
        private const string PROJECT_FILENAME = "asset-checkout-id.json";
        private const string KEY_ENABLE_AUTO_DOCKING = "ASSET_CHECKOUT_ENABLE_AUTO_DOCKING";
        private const float MIN_W = 800;
        private const float MIN_H = 480;
        
        private char Separator => Path.DirectorySeparatorChar;
        private string ProjectRootFullPath => Application.dataPath.Replace($"/Assets", $"")
            .Replace('\\', Separator).Replace('/', Separator);

        private static double lastRefreshTime;
        private static bool autoDockingEnabled;
        
        private ProjectNameData currentProjectName;
        private VisualTreeAsset checkoutItemTemplateVisualTree;
        
        private VisualElement container;
        private VisualElement assetsArea;
        private Label assetsStatusLabel;
        private TextField addAssetTextField;
        private DropdownField addAssetDropdown;
        private Button addAssetButton;

        private VisualElement projectNameArea;
        private TextField projectNameTextField;
        private Button projectNameButton;

        private VisualElement confirmationArea;
        private Label confirmationText;
        private Button confirm;
        private Button reject;

        private AssetCheckoutItemVisual itemToDelete;

        private Dictionary<AssetCheckoutItem, AssetCheckoutItemVisual> assetsDictionary = new();

        private readonly string loadingAssetsText = "Loading assets...";
        private readonly string noAssetsFoundText = "No assets found.";
        
        [InitializeOnLoadMethod]
        public static void InitializeOnLoad()
        {
            if (Application.isPlaying)
            {
                return;
            }

            EditorApplication.delayCall += handleLoaded;
            
            void handleLoaded()
            {
                EditorApplication.delayCall -= handleLoaded;
                autoDockingEnabled = EditorPrefs.GetBool(KEY_ENABLE_AUTO_DOCKING, true);

                if (!autoDockingEnabled)
                {
                    return;
                }
                Type inspectorWindowType = Type.GetType("UnityEditor.ProjectBrowser,UnityEditor");

                
                AssetsCheckoutWindow window = GetWindow<AssetsCheckoutWindow>(WINDOW_TITLE, false, inspectorWindowType);
                window.minSize = new Vector2(MIN_W, MIN_H);
                refreshAfterASecondAsync(window).Forget();
            }

            async UniTaskVoid refreshAfterASecondAsync(AssetsCheckoutWindow window)
            {
                await UniTask.Delay(1000);
                window.Initialize();
            }
        }
        
        [MenuItem("LogicalDox/Assets Checkout")]
        private static void ShowWindow()
        {
            AssetsCheckoutWindow window = GetWindow<AssetsCheckoutWindow>();
            window.titleContent = new GUIContent(WINDOW_TITLE);
            window.minSize = new Vector2(MIN_W, MIN_H);
            window.Show();
            window.Initialize();
        }

        [MenuItem("LogicalDox/Editor/Asset Checkout")]
        private static void ShowAssetCheckoutSettings()
        {
            // Just draw a modal window with a bool to enable/disable
            ModalEditorWindow modal = ModalEditorWindow.ShowModal("Asset Checkout Settings", drawCallback);
            modal.SetSize(400, 80);
            
            void drawCallback()
            {
                LdxEditorHelper.DrawTitle("Asset Checkout Settings");
                EditorGUI.BeginChangeCheck();
                autoDockingEnabled = EditorGUILayout.Toggle("Auto Docking Enabled", autoDockingEnabled);
                if (EditorGUI.EndChangeCheck())
                {
                    EditorPrefs.SetBool(KEY_ENABLE_AUTO_DOCKING, autoDockingEnabled);   
                }
            }
        }
        
        private void OnFocus()
        {
            double timeNow = EditorApplication.timeSinceStartup;

            if (timeNow - lastRefreshTime > MIN_TIME_TO_REFRESH_SECONDS)
            {
                LoadAssetsFromServer();
            }
        }

        private void Initialize()
        {
            InitializeVisual();
            CreateProjectIfNotExist();
            LoadAssetsFromServer();
        }

        private void OnDestroy()
        {
            addAssetButton.clicked -= HandleAddAssetButton;
            foreach (AssetCheckoutItemVisual asset in assetsDictionary.Values)
            {
                asset.OnStatusChanged -= HandleItemStatusChanged;
                asset.OnAssetDeleted -= HandleAssetDeleted;
            }
        }

        private void InitializeVisual()
        {
            // Main Visual Tree & Styles Setup
            container = rootVisualElement;
            if (container.childCount > 0)
            {
                return;
            }
            
            VisualTreeAsset visualTree = AssetDatabase.LoadAssetAtPath<VisualTreeAsset>(UXML_PATH);
            checkoutItemTemplateVisualTree = AssetDatabase.LoadAssetAtPath<VisualTreeAsset>(ASSET_CHECKOUT_ITEM_TEMPLATE_UXML_PATH);
            visualTree.CloneTree(container);
            StyleSheet styleSheet = AssetDatabase.LoadAssetAtPath<StyleSheet>(USS_PATH);
            container.styleSheets.Add(styleSheet);

            //Assets area initialize
            assetsArea = container.Q("AssetsArea");
            assetsArea.style.display = DisplayStyle.None;
            assetsStatusLabel = container.Q<Label>("NoAssetsLabel");
            assetsStatusLabel.style.display = DisplayStyle.Flex;
            assetsStatusLabel.text = loadingAssetsText;

            //Add new asset initialize
            addAssetTextField = container.Q<TextField>("AddAssetTextField");
            
            addAssetDropdown = container.Q<DropdownField>("AddAssetDropdown");
            addAssetDropdown.choices.Clear();
            foreach (string enumName in Enum.GetNames(typeof(AssetCheckoutType)))
            {
                addAssetDropdown.choices.Add(enumName);
            }
            addAssetDropdown.index = 0;
            
            addAssetButton = container.Q<Button>("AddAssetButton");
            addAssetButton.clicked += HandleAddAssetButton;

            confirmationArea = container.Q("ConfirmationArea");
            confirmationText = container.Q<Label>("ConfirmationText");
            confirm = container.Q<Button>("Confirm");
            confirm.clicked += HandleConfirmed;
            reject = container.Q<Button>("Reject");
            reject.clicked += HandleRejected;
        }

        private void CreateProjectIfNotExist()
        {
            string filePath = $@"{ProjectRootFullPath}{Path.DirectorySeparatorChar}{PROJECT_FILENAME}";
            string projectName = Application.productName.Replace(" ", "").ToLowerCaseUnderlineFormat()+StringUtilities.GenerateUniqueId();
            string jsonData = JsonConvert.SerializeObject(new ProjectNameData(projectName));
            
            if (!File.Exists(filePath))
            {
                File.WriteAllText(filePath, jsonData);

                Action<string> onSuccess = response => { Debug.Log("Response: " + response); };
                WebRequests.PostJson("https://ldgo1dgg1j.execute-api.ca-central-1.amazonaws.com/internal/create-project",
                    jsonData,
                    (string error) => { Debug.LogError($"Error: " + error); },
                    onSuccess,
                    AWS_TOKEN);
            }
        }
        
        private void LoadAssetsFromServer()
        {
            lastRefreshTime = EditorApplication.timeSinceStartup;
            string filePath = $@"{ProjectRootFullPath}{Path.DirectorySeparatorChar}{PROJECT_FILENAME}";
            currentProjectName = JsonConvert.DeserializeObject<ProjectNameData>(File.ReadAllText(filePath));
            if (assetsArea != null)
            {
                assetsArea.Clear();
            }

            if (assetsDictionary != null)
            {
                assetsDictionary.Clear();
            }
            
            WebRequests.Get($"https://ldgo1dgg1j.execute-api.ca-central-1.amazonaws.com/internal/get?ProjectName={currentProjectName.ProjectName}",
                (string error) =>
                {
                    Debug.LogError("Error: " + error);
                },
                (string response) =>
                {
                    List<AssetCheckoutItem> assets = JsonConvert.DeserializeObject<List<AssetCheckoutItem>>(response);
                    AssetCheckoutCache.Save(assets);
                    showAssets(assets);
                },
                token: AWS_TOKEN);

            void showAssets(List<AssetCheckoutItem> assets)
            {
                foreach (AssetCheckoutItem asset in assets)
                {
                    AssetCheckoutItemVisual itemVisual =
                        new AssetCheckoutItemVisual(asset, checkoutItemTemplateVisualTree);
                    assetsArea.Add(itemVisual.AssetCheckoutVisualElement);
                    assetsDictionary.Add(asset, itemVisual);
                    itemVisual.OnStatusChanged += HandleItemStatusChanged;
                    itemVisual.OnAssetDeleted += HandleAssetDeleted;
                }

                if (assetsDictionary.Count > 0)
                {
                    assetsStatusLabel.style.display = DisplayStyle.None;
                    assetsArea.style.display = DisplayStyle.Flex;
                }
                else
                {
                    assetsStatusLabel.text = noAssetsFoundText;
                }
            }
        }

        private void UpdateRemoteAssets()
        {
            List<AssetCheckoutItem> assetItems = assetsDictionary.Keys.ToList();
            HashSet<string> assetNamesSet = new();
            foreach (AssetCheckoutItem item in assetItems)
            {
                if (assetNamesSet.Contains(item.AssetName))
                {
                    assetsDictionary.Remove(item);
                    continue;
                }

                assetNamesSet.Add(item.AssetName);
            }

            List<AssetCheckoutItem> items = new List<AssetCheckoutItem>(assetsDictionary.Keys);
            AssetCheckoutCache.Save(items);
            AssetsCheckoutUpdate assetsUpdate = new AssetsCheckoutUpdate(currentProjectName.ProjectName, items);
            string jsonData = JsonConvert.SerializeObject(assetsUpdate);
            
            WebRequests.PostJson("https://ldgo1dgg1j.execute-api.ca-central-1.amazonaws.com/internal/update-list",
                jsonData,
                (string error) => { UnityEngine.Debug.LogError($"Error: " + error); },
                (string response) => {  },
                token: AWS_TOKEN);
        }
        
        private void HandleAddAssetButton()
        {
            bool assetDuplicate = AssetDuplicateCheck(addAssetTextField.text);
            if (assetDuplicate)
            {
                ShowAssetAlreadyExistsMessage(addAssetTextField.text);
            }
            if (string.IsNullOrWhiteSpace(addAssetTextField.text) || assetDuplicate)
            {
                return;
            }

            AssetCheckoutItem checkoutItem = new AssetCheckoutItem(addAssetTextField.value, addAssetDropdown.index.ToString(), false.ToString(),"-", "-");
            AssetCheckoutItemVisual itemVisual = 
                new AssetCheckoutItemVisual(checkoutItem, checkoutItemTemplateVisualTree);
            assetsArea.Add(itemVisual.AssetCheckoutVisualElement);
            if (assetsDictionary.Count == 0)
            {
                assetsStatusLabel.style.display = DisplayStyle.None;
                assetsArea.style.display = DisplayStyle.Flex;
            }
            assetsDictionary.Add(checkoutItem, itemVisual);
            addAssetTextField.value = String.Empty;
            UpdateRemoteAssets();
            itemVisual.OnStatusChanged += HandleItemStatusChanged;
            itemVisual.OnAssetDeleted += HandleAssetDeleted;
        }

        private void ShowAssetAlreadyExistsMessage(string assetName)
        {
            StyleEnum<DisplayStyle> previousRejectStyle = reject.style.display;
            string previousConfirmText = confirm.text;
            
            confirmationArea.style.display = DisplayStyle.Flex;
            reject.style.display = DisplayStyle.None;
            confirmationText.text = $"An asset with the name <color=orange>{assetName}</color> already exists";
            confirm.clicked -= HandleConfirmed;
            confirm.clicked += handleOkPressed;
            confirm.text = "Ok";

            void handleOkPressed()
            {
                confirm.clicked -= handleOkPressed;
                confirm.clicked += HandleConfirmed;
                reject.style.display = previousRejectStyle;
                confirm.text = previousConfirmText;
                confirmationArea.style.display = DisplayStyle.None;
            }
        }
        
        private void HandleAssetDeleted(AssetCheckoutItemVisual itemVisual)
        {
            itemToDelete = itemVisual;
            confirmationArea.style.display = DisplayStyle.Flex;
            confirmationText.text = $"Do you want to delete the <color=orange>{itemToDelete.CheckoutItem.AssetName}</color> asset?";
        }

        private void HandleItemStatusChanged(AssetCheckoutItemVisual itemVisual, AssetCheckoutStatus itemStatus)
        {
            itemVisual.CheckoutItem.IsLocked = itemStatus == AssetCheckoutStatus.Locked ? "true" : "false";
            itemVisual.CheckoutItem.Branch = itemStatus == AssetCheckoutStatus.Locked ? GetGitBranch() : "-";
            itemVisual.ChangeAssetBranchField(itemVisual.CheckoutItem.Branch);
            itemVisual.CheckoutItem.ReservedBy = itemStatus == AssetCheckoutStatus.Locked ? GetGitUserName() : "-";
            itemVisual.ChangeAssetOwnerField(itemVisual.CheckoutItem.ReservedBy);
            UpdateRemoteAssets();
        }
        
        private void HandleRejected()
        {
            confirmationArea.style.display = DisplayStyle.None;
        }

        private void HandleConfirmed()
        {
            itemToDelete.AssetCheckoutVisualElement.RemoveFromHierarchy();
            if (assetsDictionary.ContainsKey(itemToDelete.CheckoutItem))
            {
                assetsDictionary.Remove(itemToDelete.CheckoutItem);
            }
            if (assetsDictionary.Count == 0)
            {
                assetsStatusLabel.style.display = DisplayStyle.Flex;
                assetsArea.style.display = DisplayStyle.None;
                assetsStatusLabel.text = noAssetsFoundText;
            }
            UpdateRemoteAssets();
            
            confirmationArea.style.display = DisplayStyle.None;
        }
        
        private bool AssetDuplicateCheck(string assetName)
        {
            foreach (AssetCheckoutItem checkoutItem in assetsDictionary.Keys)
            {
                if (checkoutItem.AssetName == assetName)
                    return true;
            }
            
            return false;
        }
        
        private string GetGitBranch()
        {
            // Set the Git executable path (modify this based on your Git installation path)
            string gitExecutable = "git";

            // Set the path to the Git repository (modify this based on your project structure)
            string gitRepositoryPath = Application.dataPath.Replace("/Assets", "");

            // Set up the process info
            ProcessStartInfo startInfo = new ProcessStartInfo
            {
                FileName = gitExecutable,
                Arguments = "rev-parse --abbrev-ref HEAD",
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true,
                WorkingDirectory = gitRepositoryPath
            };

            // Start the process
            Process process = new Process { StartInfo = startInfo };
            process.Start();

            // Read the result
            string result = process.StandardOutput.ReadToEnd().Trim();

            // Wait for the process to exit
            process.WaitForExit();

            return result;
        }
        
        private string GetGitUserName()
        {
            // Set the Git executable path (modify this based on your Git installation path)
            string gitExecutable = "git";

            // Set the path to the Git repository (modify this based on your project structure)
            string gitRepositoryPath = Application.dataPath.Replace("/Assets", "");

            // Set up the process info
            ProcessStartInfo startInfo = new ProcessStartInfo
            {
                FileName = gitExecutable,
                Arguments = "config user.name",
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true,
                WorkingDirectory = gitRepositoryPath
            };

            // Start the process
            Process process = new Process { StartInfo = startInfo };
            process.Start();

            // Read the result
            string result = process.StandardOutput.ReadToEnd().Trim();

            // Wait for the process to exit
            process.WaitForExit();

            return result;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/AssetsCheckout/AssetsCheckoutWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/AssetsCheckout/ProjectNameData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 8804c033723048f18c6b49fd6cddd95b
# ASMDEF: ldx.framework.editor.dll
# ---
namespace Ldx.Framework.Utilities.AssetsCheckout
{
    public class ProjectNameData
    {
        public string ProjectName { get; }

        public ProjectNameData(string projectName)
        {
            ProjectName = projectName;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/AssetsCheckout/ProjectNameData.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/GroupDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 58aa272720bb494ca58f03b501be8ca1
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEditor;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Ldx.Framework.Utilities.Attributes
{
    [CustomPropertyDrawer(typeof(GroupAttribute))]
    public class GroupDrawer : PropertyDrawer
    {
        private static readonly GUIStyle BoldFoldout = new(EditorStyles.foldout) { fontStyle = FontStyle.Bold };
        
        /// <summary>
        /// Static dictionary to store the foldout state for each group per inspected object.
        /// Key: Unique identifier for the group instance (object instance ID + group name)
        /// Value: Is the foldout open?
        /// </summary>
        private static Dictionary<string, bool> groupFoldoutStates = new();

        /// <summary>
        /// Static dictionary to cache reflection results for finding the first property in a group.
        /// Key: Type of the containing object
        /// Value: Dictionary where Key is GroupName, Value is the name of the first field in that group.
        /// </summary>
        private static Dictionary<Type, Dictionary<string, string>> firstPropertyInGroupCache = new();

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            GUIContent propertyLabel = new GUIContent(label);
            GroupAttribute groupAttribute = (GroupAttribute)attribute;
            string groupKey = GetGroupKey(property.serializedObject.targetObject, groupAttribute.GroupName);
        
            groupFoldoutStates.TryAdd(groupKey, false);

            // Default to closed
            bool isFirstInGroup = IsFirstPropertyInGroup(property, groupAttribute.GroupName);
            float headerHeight = isFirstInGroup ? EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing : 0f;

            // --- Draw Header (if this is the first property in the group) ---
            if (isFirstInGroup)
            {
                Rect foldoutRect = new Rect(position.x, position.y, position.width, EditorGUIUtility.singleLineHeight);
                EditorGUI.BeginChangeCheck();
            
                bool newState = EditorGUI.Foldout(foldoutRect, groupFoldoutStates[groupKey], groupAttribute.GroupName, true, BoldFoldout);
                if (EditorGUI.EndChangeCheck())
                {
                    groupFoldoutStates[groupKey] = newState;
                }
            }

            // --- Draw Property (if foldout is open) ---
            if (groupFoldoutStates[groupKey])
            {
                // Calculate position for the property field
                Rect propertyRect = new Rect(
                    position.x,
                    position.y + headerHeight, // Start below header if header was drawn
                    position.width,
                    EditorGUI.GetPropertyHeight(property, label, true) // Get actual height needed for this property
                );

                EditorGUI.BeginProperty(propertyRect,propertyLabel, property);
                // Indent the property field slightly
                EditorGUI.indentLevel++;
                EditorGUI.PropertyField(propertyRect, property, propertyLabel, true);
                EditorGUI.indentLevel--;
                EditorGUI.EndProperty();
            }
        }

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            GroupAttribute groupAttribute = (GroupAttribute)attribute;
            string groupKey = GetGroupKey(property.serializedObject.targetObject, groupAttribute.GroupName);
        
            groupFoldoutStates.TryAdd(groupKey, false);

            bool isFirstInGroup = IsFirstPropertyInGroup(property, groupAttribute.GroupName);
            float headerHeight = isFirstInGroup ? EditorGUIUtility.singleLineHeight : 0f;
            float propertyHeight = groupFoldoutStates[groupKey] ? EditorGUI.GetPropertyHeight(property, label, true) : 0f;

            return headerHeight + propertyHeight;
        }

        /// <summary>
        /// Generates a unique key for storing the foldout state.
        /// </summary>
        private string GetGroupKey(Object targetObject, string groupName)
        {
            return targetObject.GetInstanceID() + "_" + groupName;
        }

        /// <summary>
        /// Checks if the current property is the first one encountered with its specific GroupAttribute name
        /// for the inspected target object type. Uses reflection and caches the result.
        /// </summary>
        private bool IsFirstPropertyInGroup(SerializedProperty property, string groupName)
        {
            Type targetType = property.serializedObject.targetObject.GetType();

            if (!firstPropertyInGroupCache.ContainsKey(targetType))
            {
                CacheFirstPropertyNames(targetType);
            }

            if (firstPropertyInGroupCache.TryGetValue(targetType, out Dictionary<string, string> groupMap))
            {
                if (groupMap.TryGetValue(groupName, out string firstFieldName))
                {
                    return firstFieldName == property.name;
                }
            }

            // Should ideally not happen if caching is correct, but default to true if lookup fails
            Debug.LogWarning($"GroupDrawer: Could not determine first property for group '{groupName}' on type '{targetType.Name}'. Property: '{property.name}'");
            return true;
        }

        /// <summary>
        /// Uses reflection to find the first field declared for each group name on a given type
        /// and stores it in the cache.
        /// </summary>
        private static void CacheFirstPropertyNames(Type type)
        {
            Dictionary<string, string> groupMap = new();
            FieldInfo[] fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

            foreach (FieldInfo field in fields)
            {
                GroupAttribute groupAttr = Attribute.GetCustomAttribute(field, typeof(GroupAttribute)) as GroupAttribute;
                if (groupAttr != null)
                {
                    // If this group name hasn't been seen yet for this type, record this field as the first.
                    if (!groupMap.ContainsKey(groupAttr.GroupName))
                    {
                        groupMap.Add(groupAttr.GroupName, field.Name);
                    }
                }
            }
            firstPropertyInGroupCache[type] = groupMap;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/GroupDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/HelpBoxDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6701c0ddd70a463c9f70b1f39c97302b
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    [CustomPropertyDrawer(typeof(HelpBoxAttribute))]
    public class HelpBoxDrawer : PropertyDrawer
    {
        private HelpBoxAttribute Attribute => attribute as HelpBoxAttribute;

        private float Padding = (EditorGUIUtility.singleLineHeight/2.0f);
        private float PaddingStep => Padding / 2.0f;
        
        public override void OnGUI(Rect position, SerializedProperty property,
            GUIContent label)
        {
            float height = EditorStyles.helpBox.CalcHeight(new GUIContent(Attribute.Text), position.width);
            Rect helpPos = new Rect(position.x + 10f, position.y + PaddingStep, position.width, height);
            EditorGUI.HelpBox(helpPos, Attribute.Text, MessageType.Info);
            var offset = helpPos.height + Padding;
            position.y += offset;
            position.height -= offset;
            EditorGUI.PropertyField(position, property, label);
        }

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            float propertyHeight = EditorGUI.GetPropertyHeight(property, label, true);
            float height = EditorStyles.helpBox.CalcHeight(new GUIContent(Attribute.Text), EditorGUIUtility.currentViewWidth);
            return propertyHeight + height + Padding;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/HelpBoxDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/HelpUrlDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 457b9ac97bfc40eabed488748cac30aa
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    /// <summary>
    /// Custom Editor for MonoBehaviour scripts with a HelpURLAttribute.
    /// Displays a HelpBox in the Inspector to inform users about associated documentation.
    /// </summary>
    [CustomEditor(typeof(MonoBehaviour), true)]
    public class HelpUrlDrawer : UnityEditor.Editor
    {
        public override void OnInspectorGUI()
        {
            Type type = target.GetType();
            
            HelpURLAttribute helpUrlAttribute = (HelpURLAttribute)Attribute.GetCustomAttribute(type, typeof(HelpURLAttribute));
            if (helpUrlAttribute != null)
            {
                EditorGUILayout.Space(5);
                EditorGUILayout.HelpBox(
                    "This script has associated documentation. Click the '?' button at the top-right corner to open it.",
                    MessageType.Info
                );
                
                Rect helpBoxRect = GUILayoutUtility.GetLastRect();
                DrawOutline(helpBoxRect, new Color(1f, 1f, 0.5f, 0.6f), 2f);
                EditorGUILayout.Space(5);
            }
            
            base.OnInspectorGUI();
        }
        
        private void DrawOutline(Rect rect, Color color, float thickness)
        {
            EditorGUI.DrawRect(new Rect(rect.x, rect.y - thickness, rect.width, thickness), color);
            EditorGUI.DrawRect(new Rect(rect.x, rect.y + rect.height, rect.width, thickness), color);
            EditorGUI.DrawRect(new Rect(rect.x - thickness, rect.y - thickness, thickness, rect.height + (2 * thickness)), color);
            EditorGUI.DrawRect(new Rect(rect.x + rect.width, rect.y - thickness, thickness, rect.height + (2 * thickness)), color);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/HelpUrlDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/HideDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7968f73269dc4137acbe96784491e6ce
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    [CustomPropertyDrawer(typeof(HideAttribute))]
    public class HideDrawer : PropertyDrawer
    {
        public override void OnGUI(Rect position, SerializedProperty property,
            GUIContent label)
        {
        }

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            return 0;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/HideDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/IDSelectionAllDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 0ee6984f1b8745efafa0404f2dd4c0a2
# ASMDEF: ldx.framework.editor.dll
# ---
using Ldx.Framework.Systems.Objectives;
using UnityEditor;

namespace Ldx.Framework.Utilities.Attributes
{
    [CustomPropertyDrawer(typeof(IDSelectionAllAttribute))]
    public class IDSelectionAllDrawer : IDSelectionDrawer
    {
        protected override CompoundIDInfoContainer GetCompoundIDInfoContainer(SerializedProperty property)
        {
            return LdxIdSettings.GetCompoundIDListAllScenarios((attribute as IDSelectionAttribute).idType);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/IDSelectionAllDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/IDSelectionDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d807916e1cbe46dbb2ee8cd003d03a95
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.ID;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    [CustomPropertyDrawer(typeof(IDSelectionAttribute))]
    public class IDSelectionDrawer : PropertyDrawer
    {
        private const string GLOBAL_OPTION = "----GLOBAL----";
        private const string GLOBAL_SUFFIX = " (global)";
        private const float ADDING_MODE_MARGIN = 5;
        private int index;
        private bool isMissing;
        private List<string> namesList;
        private List<string> idList;
        private Dictionary<string, string> nameToIdMap = new Dictionary<string, string>();
        private string[] displayNames;
        private IdTypeWrapper? idType;
        
        // Adding mode field
        private bool isAddingMode;
        private string newIdName;
        private bool isNewIdGlobal;
        private bool justAddedNewId;
        private string lastAddedIdName;
        
        private static GUIStyle highlightedButtonStyle;
        private static GUIStyle rightAlignedLabelStyle;

        private IDSelectionAttribute Attribute => (IDSelectionAttribute)attribute;

        protected virtual string NoIdInfoContainerMessage => "ID info can't be retrieved";
        
        public override void OnGUI(Rect position, SerializedProperty property,
            GUIContent label)
        {
            if (Selection.objects.Length > 1)
            {
                EditorGUI.LabelField(position,  "ID dropdown not available when selecting multiple objects", EditorStyles.helpBox);
                return;
            }

            Rect originalPosition = position;
            
            if (highlightedButtonStyle == null)
            {
                highlightedButtonStyle = GetHighlightedButtonStyle();
            }
            
            if (idType == null)
            {
               IDSelectionAttribute idSelectionAttribute = attribute as IDSelectionAttribute;
               if (idSelectionAttribute != null)
               {
                   idType = idSelectionAttribute.idType;
               }
            }
            CompoundIDInfoContainer list = GetCompoundIDInfoContainer(property);
            if (list == null)
            {
                EditorGUI.LabelField(position, NoIdInfoContainerMessage);
                return;
            }
            if (list.LocalContainer == null)
            {
                position.height /= 2.0f;
                EditorGUI.LabelField(position, "No scenario IDs created, using only global IDs (Missing scenario or stand-in setup?)", EditorStyles.helpBox);
                position.y += position.height;
            }
            idList = list.Select(l => l.ID).ToList();
            namesList = list.Select(l => l.Description).ToList();
            if (idList.Count > 0 && namesList.Count > 0 && list.GlobalIDStartIndex > 0)
            {
                namesList.Insert(list.GlobalIDStartIndex, GLOBAL_OPTION);
                idList.Insert(list.GlobalIDStartIndex,  "");
            }
            
            idList.Insert(0, "");
            namesList.Insert(0, "None");
            nameToIdMap = new Dictionary<string, string>();
            for (int i = 0; i < idList.Count; i++)
            {
                string globalSuffix = i > list.GlobalIDStartIndex + 1 ? GLOBAL_SUFFIX : ""; // to make distinct key
                namesList[i] += globalSuffix;
                try
                {
                    nameToIdMap.Add(namesList[i], idList[i]);    
                }
                catch (Exception e)
                {
                    Debug.LogError($"ID Selection error - duplicate name found ({namesList[i]}): {e}");
                }
            }

            displayNames = namesList.ToArray();

            if (idList.Count == 0)
            {
                GUI.enabled = false;
                EditorGUI.LabelField(position,
                    $"{property.displayName}: No IDs available. Please see Window/ID Settings.");
                GUI.enabled = true;
                return;
            }
            bool changed = false;
            GUI.enabled = !isAddingMode;
            EditorGUI.BeginChangeCheck();
            index = 0;
            if (!String.IsNullOrEmpty(property.stringValue))
            {
                index = idList.IndexOf(property.stringValue);
                if (index < 0)
                {
                    EditorGUI.LabelField(new Rect(position.x, position.y, position.width / 2.0f, position.height),
                        property.displayName);
                    
                    if (PrefabHelper.IsInPrefabStaging())
                    {
                        GUI.Label(new Rect(position.x + (position.width / 2.0f), position.y, position.width / 2.0f,
                            position.height), $"ID {property.stringValue} not found, possibly due to being in prefab mode");    
                    }
                    else
                    {
                        if (GUI.Button(new Rect(position.x + (position.width / 2.0f), position.y, position.width / 2.0f,
                                    position.height),
                                $"ID {property.stringValue} not found. Click to reset."))
                        {
                            property.stringValue = "";
                        }
                    }

                    return;
                }
            }

            if (index >= idList.Count)
            {
                index = 0;
            }

            int lastIndex = index;
            if (justAddedNewId)
            {
                int foundIndex = namesList.FindIndex(0, 
                    n => n.Replace(GLOBAL_SUFFIX, "") == lastAddedIdName);
                if (foundIndex >= 0)
                {
                    index = foundIndex;
                }

                justAddedNewId = false;
            }
            float buttonWidth = 30; 
            float lineHeight = EditorGUIUtility.singleLineHeight;
            float dropdownWidth = position.width - 3 * buttonWidth; // Width of the dropdown adjusted for two buttons
            Rect dropdownPosition = new Rect(position.x, position.y, dropdownWidth, lineHeight);
            index = EditorGUI.Popup(dropdownPosition, property.displayName, index, displayNames);
            if (index == namesList.IndexOf(GLOBAL_OPTION))
            {
                index = Mathf.Max(0, lastIndex);
            }
            property.stringValue = nameToIdMap[displayNames[index]];

            Rect gButtonPosition = new Rect(position.x + dropdownWidth, position.y, buttonWidth, lineHeight);
            if (GUI.Button(gButtonPosition, "G"))
            {
                LdxIdSettings.HighlightGlobalIDsFile(idType);
            }

            Rect sButtonPosition = new Rect(position.x + dropdownWidth + buttonWidth, position.y, buttonWidth, lineHeight);
            if (GUI.Button(sButtonPosition, "S"))
            {
                LdxIdSettings.HighlightScenarioIDsFile(idType);
            }
            
            GUI.enabled = true;

            Rect addButtonPosition = new Rect(position.x + dropdownWidth + buttonWidth * 2, position.y, buttonWidth, lineHeight);
            if (GUI.Button(addButtonPosition, isAddingMode ? "\u2715" : "+", isAddingMode ? highlightedButtonStyle : GUI.skin.button))
            {
                isAddingMode = !isAddingMode;
                isNewIdGlobal = false;
            }
            
            if (index == namesList.IndexOf(GLOBAL_OPTION))
            {
                index = Mathf.Max(0, index);
            }

            property.stringValue = nameToIdMap[displayNames[index]];

            if (isAddingMode)
            {
                DrawAddingMode(originalPosition, property, label);   
            }

            if (EditorGUI.EndChangeCheck() || changed)
            {
                property.serializedObject.ApplyModifiedProperties();
            }
        }

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            float height = base.GetPropertyHeight(property, label);
            CompoundIDInfoContainer list = LdxIdSettings.GetCompoundIDList((attribute as IDSelectionAttribute).idType);
            if (list.LocalContainer == null)
            {
                height += EditorGUIUtility.singleLineHeight;
            }

            if (isAddingMode)
            {
                height += EditorGUIUtility.singleLineHeight;
                height += ADDING_MODE_MARGIN;
            }
            
            return height;
        }

        protected virtual CompoundIDInfoContainer GetCompoundIDInfoContainer(SerializedProperty property)
        {
            return LdxIdSettings.GetCompoundIDList((attribute as IDSelectionAttribute).idType);
        }
        
        private void DrawAddingMode(Rect position, SerializedProperty property, GUIContent label)
        {
            float lh = EditorGUIUtility.singleLineHeight;
            position.y += ADDING_MODE_MARGIN;
            position.height -= ADDING_MODE_MARGIN;
            position = new Rect(position.x, position.y + lh, position.width, position.height - lh);

            float labelWidth = position.width * 0.39f;
            Rect labelRect = new Rect(position.x, position.y, labelWidth, position.height);
            position.x += labelWidth;
            position.width -= labelWidth;
            float buttonWidth = 30;
            float textfieldWidth = position.width - buttonWidth * 3;

            if (rightAlignedLabelStyle == null)
            {
                rightAlignedLabelStyle = new GUIStyle(GUI.skin.label);
                rightAlignedLabelStyle.alignment = TextAnchor.MiddleRight;
            }
            
            EditorGUI.LabelField(labelRect, $"New ID ({(isNewIdGlobal? "Global" : "Scenario")}):", rightAlignedLabelStyle);
            
            newIdName = EditorGUI.TextField(new Rect(position.x, position.y, textfieldWidth, position.height), newIdName);
            
            Rect sButtonPosition = new Rect(position.x + textfieldWidth, position.y, buttonWidth, lh);
            if (GUI.Button(sButtonPosition, isNewIdGlobal ? "G" : "S"))
            {
                isNewIdGlobal = !isNewIdGlobal;
            }

            GUI.enabled = !String.IsNullOrEmpty(newIdName);
            
            Rect addButtonPosition = new Rect(position.x + textfieldWidth + buttonWidth, position.y, buttonWidth * 2, lh);
            if (GUI.Button(addButtonPosition, "Add"))
            {
                addNewId();
                isAddingMode = false;
                justAddedNewId = true;
                lastAddedIdName = newIdName;
                newIdName = "";
            }
            
            GUI.enabled = true;

            void addNewId()
            {
                IDInfo idInfo = new IDInfo(StringUtilities.GenerateUniqueId(), newIdName);
                LdxIdSettings settings =
                    isNewIdGlobal ? LdxIdSettings.GlobalInstance : LdxIdSettings.GetScenarioIDSettings();
                settings.EDITOR_AddIdInfo(idInfo, Attribute.idType);
            }
        }

        private GUIStyle GetHighlightedButtonStyle()
        {
            GUIStyle style = new GUIStyle(GUI.skin.button);
            Color blueColor = new Color(0.290f, 0.376f, 0.502f);
            Texture2D blueTexture = TextureUtilities.CreateRoundedTexture(30, (int)EditorGUIUtility.singleLineHeight, 4, blueColor);
            style.normal.background = blueTexture;
            style.normal.scaledBackgrounds = new[] { blueTexture };
            style.normal.textColor = Color.white;
            style.alignment = TextAnchor.LowerCenter;
            style.contentOffset = new Vector2(0, 2);
            return style;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/IDSelectionDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/IDSelectionShowIfEventTypeDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: af18c8baba2b4b7387767c5469a92f62
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Systems.Objectives;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    [CustomPropertyDrawer(typeof(IDSelectionShowIfEventTypeAttribute))]
    public class IDSelectionShowIfEventTypeDrawer : IDSelectionDrawer
    {
        private const string FIELD_NAME = "eventType";

        private List<ObjectiveEventData.TriggerEventType> enumValuesList = null;
        
        public override void OnGUI(Rect position, SerializedProperty property,
            GUIContent label)
        {
            if (!IsCorrectEventType(property))
            {
                return;
            }

            base.OnGUI(position, property, label);
        }

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            return IsCorrectEventType(property)? base.GetPropertyHeight(property, label) : 0;
        }

        private bool IsCorrectEventType(SerializedProperty property)
        {
            if (enumValuesList == null)
            {
                Array enumValues = Enum.GetValues(typeof(ObjectiveEventData.TriggerEventType));
                enumValuesList = new List<ObjectiveEventData.TriggerEventType>((ObjectiveEventData.TriggerEventType[])enumValues);
            }
            
            string path = property.propertyPath;
            path = path.Replace(property.name, FIELD_NAME);
            
            SerializedProperty eventTypeProperty = property.serializedObject.FindProperty(path);
            
            if (eventTypeProperty == null)
            {
                return false;
            }
            
            ObjectiveEventData.TriggerEventType currentTriggerType = enumValuesList[eventTypeProperty.enumValueIndex];
            ObjectiveEventData.TriggerEventType? filterType =  (attribute as IDSelectionShowIfEventTypeAttribute)?.TriggerFilterType;
            
            if (filterType != null && currentTriggerType == filterType)
            {
                return true;
            }
            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/IDSelectionShowIfEventTypeDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/InheritedClassContainerDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 04f4d09b4ab54ed5b15b4c3c9f55b2bd
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    [CustomPropertyDrawer(typeof(InheritedClassContainerAttribute))]
    public class InheritedClassContainerDrawer : SerializableContainerDrawer
    {
        private InheritedClassContainerAttribute Attribute =>
            (InheritedClassContainerAttribute) attribute;
        
        protected override void AddButtonPressed(SerializedProperty property, SerializedProperty arrayProperty)
        {
            GenericMenu menu = new GenericMenu();
            List<Type> subclassTypes = new List<Type>();
            
            // Hashset for checking later if the condition applies that the type isn't already added
            HashSet<string> existingTypeNamesSet = new HashSet<string>();
            // We don't want to fill this hashset to save tiny tiny performance when the flag is off
            if (Attribute.UniqueItemsOnly)
            {
                // Funny enough, if you have a [SerializeReference] field, this is the only way to get the instance type
                // We're extracting it from the string managedReference<typeName>
                string pattern = "<([^>]*)>";
                Regex regex = new Regex(pattern);

                foreach (SerializedProperty p in arrayProperty)
                {
                    Match match = regex.Match(p.type);
                    if (!match.Success)
                    {
                        continue;
                    }

                    existingTypeNamesSet.Add(match.Groups[1].Value);
                }
            }
            
            foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                subclassTypes.AddRange(assembly.GetTypes()
                    .Where(t => t.IsSubclassOf(Attribute.Type) 
                                && !t.IsAbstract 
                                && passesOptionalUniqueCheck(t)));
            }

            subclassTypes = subclassTypes.OrderBy(t => t.Name).ToList();
            
            foreach (Type t in subclassTypes)
            {
                string tName = t.Name;
                if (Attribute.SuffixToRemove != null)
                {
                    tName = tName.Replace(Attribute.SuffixToRemove, "");
                }
                menu.AddItem(new GUIContent(tName.SeparateWords()), 
                    false, ()=> HandleAddingNew(property, arrayProperty, t));
                        
            }
            menu.ShowAsContext();

            // For checking if a certain type is already added if UniqueItemsOnly = true
            bool passesOptionalUniqueCheck(Type type)
            {
                if (!Attribute.UniqueItemsOnly)
                { 
                    return true;
                }

                string name = type.Name;
                return !existingTypeNamesSet.Contains(name);
            }
        }

        private void HandleAddingNew(SerializedProperty property, SerializedProperty arrayProperty, Type t)
        {
            arrayProperty.arraySize++;
            arrayProperty.GetArrayElementAtIndex(arrayProperty.arraySize - 1).managedReferenceValue = Activator.CreateInstance(t);
            property.serializedObject.ApplyModifiedProperties();
        }
        
        protected override string GetElementName(SerializedProperty property)
        {
            string[] segments = property.type.Split(new[] {'<', '>'});
            if (segments.Length < 2)
            {
                return "";
            }

            string name = segments[1];
            if (Attribute.SuffixToRemove != null)
            {
                name = name.Replace(Attribute.SuffixToRemove, "");
            }

            name = name.SeparateWords();
            if (Attribute.ItemTitle != null)
            {
                name = $"{name} ({Attribute.ItemTitle})";
            }
            return name;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/InheritedClassContainerDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/InheritedClassDropdownDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 4756cef727d64208b561047ce1b18e68
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    [CustomPropertyDrawer(typeof(InheritedClassDropdownAttribute))]
    public class InheritedClassDropdownDrawer : PropertyDrawer
    {
        private static Dictionary<string, List<Type>> cachedTypesPerBaseType = new();
        private static Dictionary<string, string[]> cachedDisplayNamesPerBaseType = new();
        
        private InheritedClassDropdownAttribute Attribute => attribute as InheritedClassDropdownAttribute;

        private bool EnsureCacheInitialized(Type baseType, out List<Type> types, out string[] displayNames)
        {
            types = null;
            displayNames = null;

            if (baseType == null) return false;
            string baseTypeFullName = baseType.FullName;

            if (cachedTypesPerBaseType.TryGetValue(baseTypeFullName, out types) &&
                cachedDisplayNamesPerBaseType.TryGetValue(baseTypeFullName, out displayNames))
            {
                return true; // Already cached
            }

            types = new List<Type>();
            List<string> displayNameList = new();

            // Add a "(None)" option at the beginning
            types.Add(null); // Represents a null reference
            displayNameList.Add("(None)");

            // Find all non-abstract, non-generic subclasses of the baseType
            foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                foreach (Type type in assembly.GetTypes())
                {
                    if (type.IsSubclassOf(baseType) && !type.IsAbstract && !type.IsGenericType)
                    {
                        types.Add(type);
                        string name = type.Name;
                        if (!string.IsNullOrEmpty(Attribute.TypeSuffixToExclude))
                        {
                            name = name.Replace(Attribute.TypeSuffixToExclude, "");
                        }
                        // displayNameList.Add(name.SeparateWords()); // If you have this extension
                        displayNameList.Add(FormatDisplayName(name)); // Using a simple formatter instead
                    }
                }
            }

            // Sort alphabetically by display name for better UX, keeping (None) at top
            // This is a bit more complex because types list needs to be sorted along
            var sortedPairs = displayNameList.Zip(types, (d, t) => new { DisplayName = d, Type = t })
                .Skip(1) // Skip (None) for sorting
                .OrderBy(pair => pair.DisplayName)
                .ToList();

            types.Clear();
            displayNameList.Clear();
            types.Add(null); // Add (None) back
            displayNameList.Add("(None)");

            foreach (var pair in sortedPairs)
            {
                types.Add(pair.Type);
                displayNameList.Add(pair.DisplayName);
            }
            
            displayNames = displayNameList.ToArray();

            cachedTypesPerBaseType[baseTypeFullName] = types;
            cachedDisplayNamesPerBaseType[baseTypeFullName] = displayNames;
            return true;
        }
        
        private string FormatDisplayName(string name)
        {
            if (string.IsNullOrEmpty(name)) return "";
            // Add spaces before uppercase letters (except the first one)
            return System.Text.RegularExpressions.Regex.Replace(name, "([A-Z])", " $1").TrimStart();
        }

        public override void OnGUI(Rect position, SerializedProperty property,
            GUIContent label)
        {
            EditorGUI.BeginProperty(position, label, property);

            Type baseType = Attribute?.BaseType;
            if (!EnsureCacheInitialized(baseType, out List<Type> currentTypes, out string[] currentDisplayNames))
            {
                EditorGUI.LabelField(position, label.text, "InheritedClassDropdown: BaseType invalid or not found.");
                EditorGUI.EndProperty();
                return;
            }
            
            int currentIndexBasedOnValue = 0; // Default to "(None)"
            object currentInstance = property.managedReferenceValue;

            if (currentInstance != null)
            {
                for (int i = 0; i < currentTypes.Count; i++) // Iterate through all cached types
                {
                    if (currentTypes[i] != null && currentTypes[i] == currentInstance.GetType())
                    {
                        currentIndexBasedOnValue = i;
                        break;
                    }
                }
            }
            
            Rect popupRect = position;
            popupRect.height = EditorGUIUtility.singleLineHeight;

            EditorGUI.BeginChangeCheck();
            // Draw the popup using the index derived from the property's current value
            int userSelectedIndex = EditorGUI.Popup(popupRect, property.displayName, currentIndexBasedOnValue, currentDisplayNames);

            if (EditorGUI.EndChangeCheck()) // User explicitly changed the selection in the dropdown
            {
                Type selectedType = currentTypes[userSelectedIndex];
                if (selectedType == null) // User selected "(None)"
                {
                    if (property.managedReferenceValue != null) // Only change if it's not already null
                    {
                        property.managedReferenceValue = null;
                    }
                }
                else // User selected a concrete type
                {
                    // Create a new instance only if the type is different or if it was null
                    if (property.managedReferenceValue == null || property.managedReferenceValue.GetType() != selectedType)
                    {
                        try
                        {
                            property.managedReferenceValue = Activator.CreateInstance(selectedType);
                        }
                        catch (Exception ex)
                        {
                            Debug.LogError($"Error creating instance of {selectedType.FullName}: {ex.Message}");
                            // Optionally revert to null or previous state if creation fails
                            property.managedReferenceValue = null;
                        }
                    }
                }
                // No explicit ApplyModifiedProperties here. EndProperty and Unity's serialization handles it.
                // GUI.changed = true; // Let Unity know something changed to ensure save prompt if needed.
            }
            
            // Draw child properties of the managed reference if an instance exists
            if (property.managedReferenceValue != null)
            {
                EditorGUI.indentLevel++;
                SerializedProperty fieldProperty = property.Copy(); // Get a fresh iterator starting at the main property
                bool enterChildren = true;
                int baseDepth = fieldProperty.depth; // Depth of the SerializeReference field itself

                Rect childPosition = position;
                // Start drawing children below the dropdown
                childPosition.y += EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing;

                // Iterate over visible children of the managed reference property
                while (fieldProperty.NextVisible(enterChildren) && fieldProperty.depth > baseDepth)
                {
                    enterChildren = false; // Only enter the first level of children this way
                    childPosition.height = EditorGUI.GetPropertyHeight(fieldProperty, true);
                    EditorGUI.PropertyField(childPosition, fieldProperty, true);
                    childPosition.y += childPosition.height + EditorGUIUtility.standardVerticalSpacing;
                }
                EditorGUI.indentLevel--;
            }

            EditorGUI.EndProperty();
        }
        
        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            float totalHeight = EditorGUIUtility.singleLineHeight; // For the dropdown itself

            // Initialize cache if needed, as this can be called before OnGUI
            Type baseType = Attribute?.BaseType;
            EnsureCacheInitialized(baseType, out _, out _);

            if (property.managedReferenceValue != null)
            {
                SerializedProperty fieldProperty = property.Copy();
                bool enterChildren = true;
                int baseDepth = fieldProperty.depth;

                while (fieldProperty.NextVisible(enterChildren) && fieldProperty.depth > baseDepth)
                {
                    enterChildren = false;
                    totalHeight += EditorGUI.GetPropertyHeight(fieldProperty, true) + EditorGUIUtility.standardVerticalSpacing;
                }
            }
            return totalHeight;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/InheritedClassDropdownDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/NoteAttributeDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 861e3b9745d48534b99e526efed537c6
# ASMDEF: ldx.framework.editor.dll
# ---
#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    [CustomPropertyDrawer(typeof(NoteAttribute))]
    public class NoteAttributeDrawer : PropertyDrawer
    {
        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            NoteAttribute note = (NoteAttribute)attribute;
            GUIStyle style = EditorStyles.helpBox;
            GUIContent content = new GUIContent(note.Message);
            float width = EditorGUIUtility.currentViewWidth - 40f;
            return style.CalcHeight(content, width) + 4f;
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            NoteAttribute note = (NoteAttribute)attribute;
            MessageType mt = note.Type == NoteAttribute.NoteType.Warning ? MessageType.Warning
                : note.Type == NoteAttribute.NoteType.Error   ? MessageType.Error
                : MessageType.Info;
            EditorGUI.HelpBox(position, note.Message, mt);
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/NoteAttributeDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/ReadOnlyDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 538cca6a45be46569958c204127133b2
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    [CustomPropertyDrawer(typeof(ReadOnlyAttribute))]
    public class ReadOnlyDrawer : PropertyDrawer
    {
        public override float GetPropertyHeight(SerializedProperty property,
            GUIContent label)
        {
            return EditorGUI.GetPropertyHeight(property, label, true);
        }

        public override void OnGUI(Rect position,
            SerializedProperty property,
            GUIContent label)
        {
            GUI.enabled = false;
            EditorGUI.PropertyField(position, property, label, true);
            GUI.enabled = true;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/ReadOnlyDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/RequireInterfaceDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a33c400c8427416dad4d7841588f799b
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Linq;
using UnityEngine;
using UnityEditor;

namespace Ldx.Framework.Utilities.Attributes
{
    /// <summary>
    /// Drawer for the RequireInterface attribute.
    /// </summary>
    [CustomPropertyDrawer(typeof(RequireInterfaceAttribute))]
    public class RequireInterfaceDrawer : PropertyDrawer
    {
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            if (property.propertyType == SerializedPropertyType.ObjectReference)
            {
                RequireInterfaceAttribute requiredAttribute = attribute as RequireInterfaceAttribute;
                EditorGUI.BeginProperty(position, label, property);
                // First, we get the field this way for it to work
                MonoBehaviour field = EditorGUI.ObjectField(position, label, property.objectReferenceValue,
                    typeof(MonoBehaviour), true) as MonoBehaviour;
                MonoBehaviour interfaceObject = null;
                
                // We got the object, now we need to find all components to look for one that implements interface
                if (field != null)
                {
                    interfaceObject = field.GetComponents<MonoBehaviour>()
                        .FirstOrDefault(m => requiredAttribute.RequiredType.IsAssignableFrom(m.GetType()));
                }

                // None found
                if (interfaceObject == null)
                {
                    property.objectReferenceValue = null;
                }
                // One found, and it's not equal to the current value
                else if (interfaceObject != property.objectReferenceValue 
                    && requiredAttribute.RequiredType.IsAssignableFrom(interfaceObject.GetType()))
                {
                    property.objectReferenceValue = interfaceObject;
                }
                EditorGUI.EndProperty();
            }
            else
            {
                Color previousColor = GUI.color;
                GUI.color = Color.red;
                // Display label with error message.
                EditorGUI.LabelField(position, label, new GUIContent("Property is not a reference type"));
                // Revert color change.
                GUI.color = previousColor;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/RequireInterfaceDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/SerializableContainerDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 91106d48392843e290132bccec25dd4a
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    [CustomPropertyDrawer(typeof(SerializableContainerAttribute))]
    public class SerializableContainerDrawer : PropertyDrawer
    {
        private List<int> removedIndecies = new List<int>();
        private int? lastArraySize;

        private SerializableContainerAttribute Attribute => attribute as SerializableContainerAttribute;
        
        public override void OnGUI(Rect position, SerializedProperty property,
            GUIContent label)
        {
            float x = position.x;
            float y = position.y;
            float w = position.width;
            float h = position.height;

            SerializedProperty arrayProperty = GetArrayProperty(property);
            string arrayName = Attribute.FieldName ?? arrayProperty.displayName;
            if (Attribute.MaxItems != null)
            {
                arrayName += $" (Max: {Attribute.MaxItems.Value})";
            }
            if (lastArraySize == null)
            {
                lastArraySize = arrayProperty.arraySize;
            }

            bool changed = false;
            EditorGUI.BeginChangeCheck();
            EditorGUI.BeginProperty(position, new GUIContent(), arrayProperty);
            float singleLineHeight = EditorGUIUtility.singleLineHeight;
            EditorGUI.LabelField(new Rect(x, y, w, singleLineHeight),
                new GUIContent(arrayName), EditorStyles.boldLabel);
            y += singleLineHeight;
            h -= singleLineHeight;
            x += singleLineHeight;
            EditorGUI.indentLevel++;
            for (int i = 0; i < arrayProperty.arraySize; i++)
            {
                if (Attribute.MaxItems != null && i >= Attribute.MaxItems)
                {
                    removedIndecies.Add(i);
                }
                SerializedProperty p = arrayProperty.GetArrayElementAtIndex(i);
                float height = EditorGUI.GetPropertyHeight(p, true);

                if (Attribute.DrawAddRemoveButtons)
                {
                    if (GUI.Button(new Rect(x, y, singleLineHeight, singleLineHeight), " - "))
                    {
                        removedIndecies.Add(i);
                    }   
                }

                int displayedNumber = Attribute.StartCountingFrom1 ? i + 1 : i;
                EditorGUI.PropertyField(new Rect(x + singleLineHeight, y, w - singleLineHeight, height), p, 
                    includeChildren: true,
                    label: new GUIContent(Attribute.ItemName != null? $"{Attribute.ItemName} {displayedNumber}": GetElementName(p)));
                y += height;
                y += singleLineHeight * 0.5f;
            }

            for (int i = removedIndecies.Count - 1; i >= 0; i--)
            {
                arrayProperty.DeleteArrayElementAtIndex(removedIndecies[i]);
            }

            if (removedIndecies.Count > 0)
            {
                arrayProperty.serializedObject.ApplyModifiedProperties();
                removedIndecies.Clear();
            }

            EditorGUI.indentLevel--;

            if (Attribute.DrawAddRemoveButtons)
            {
                if (GUI.Button(new Rect(x, y, singleLineHeight, singleLineHeight), "+"))
                {
                    changed = true;
                    AddButtonPressed(property, arrayProperty);
                }   
            }

            lastArraySize = arrayProperty.arraySize;

            if (EditorGUI.EndChangeCheck() || changed)
            {
                property.serializedObject.ApplyModifiedProperties();
            }
        }

        protected virtual string GetElementName(SerializedProperty property)
        {
            return property.displayName;
        }
        
        protected virtual void AddButtonPressed(SerializedProperty property, SerializedProperty arrayProperty)
        {
            arrayProperty.arraySize++;
        }
        
        private SerializedProperty GetArrayProperty(SerializedProperty property)
        {
            foreach (SerializedProperty p in property)
            {
                if (p.isArray)
                {
                    return p;
                }
            }

            return null;
        }

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            float height = 0;
            height += EditorGUIUtility.singleLineHeight;
            var arrayProperty = GetArrayProperty(property);
            foreach (SerializedProperty p in arrayProperty)
            {
                height += EditorGUI.GetPropertyHeight(p, true);
                height += EditorGUIUtility.singleLineHeight * 0.5f; // margin
            }

            if (Attribute.DrawAddRemoveButtons)
            {
                height += EditorGUIUtility.singleLineHeight;
            }
            return height;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/SerializableContainerDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/ShowIfDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: ad530ac31a834d3381794ed29cb84761
# ASMDEF: ldx.framework.editor.dll
# ---
// Credits: https://gist.github.com/Mikilo/8cb969a50a1eac87c9500d4f9f181324

using System;
using System.Collections;
using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Ldx.Framework.Utilities.Attributes
{
	[CustomPropertyDrawer(typeof(ShowIfAttribute))]
	public class ShowIfDrawer : PropertyDrawer
	{
		private ConditionalRenderer renderer;

		public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
		{
			if (this.renderer == null)
				this.renderer = new ConditionalRenderer("ShowIf", this, base.GetPropertyHeight, true);

			return this.renderer.GetPropertyHeight(property, label);
		}

		public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
		{
			this.renderer.OnGUI(position, property, label);
		}
	}


	public class ConditionalRenderer
	{
		private const float EmptyHeight = -2F;

		private string name;
		private Func<SerializedProperty, GUIContent, float> getPropertyHeight;
		private PropertyDrawer drawer;
		private bool normalBooleanValue;

		private string errorAttribute = null;
		private FieldInfo conditionField;
		private string fieldName;
		private Op @operator;
		private MultiOp multiOperator;
		private object[] values;

		private object lastValue;
		private string lastValueStringified;
		private string[] targetValueStringified;
		private Decimal[] targetValueDecimaled;

		private bool conditionResult;
		private bool invalidHeight = true;
		private float cachedHeight;

		private Func<SerializedProperty, GUIContent, float> PropertyHeight;

		public ConditionalRenderer(string name, PropertyDrawer drawer,
			Func<SerializedProperty, GUIContent, float> getPropertyHeight, bool normalBooleanValue)
		{
			this.name = name;
			this.drawer = drawer;
			this.getPropertyHeight = getPropertyHeight;
			this.normalBooleanValue = normalBooleanValue;
		}

		public float GetPropertyHeight(SerializedProperty property, GUIContent label)
		{
			if (this.fieldName == null)
				this.InitializeDrawer(property);

			if (this.errorAttribute != null)
				return 16F;
			if (this.conditionField == null)
				return this.getPropertyHeight(property, label);

			return this.PropertyHeight(property, label);
		}

		public void OnGUI(Rect position, SerializedProperty property, GUIContent label)
		{
			if (this.errorAttribute != null)
			{
				Color restore = GUI.contentColor;
				GUI.contentColor = Color.black;
				EditorGUI.LabelField(position, label.text, this.errorAttribute);
				GUI.contentColor = restore;
			}
			else if (this.conditionField == null || this.conditionResult == this.normalBooleanValue)
			{
				EditorGUI.BeginChangeCheck();
				EditorGUI.PropertyField(position, property, label, property.isExpanded);
				if (EditorGUI.EndChangeCheck() == true)
					this.invalidHeight = true;
			}
		}

		private void InitializeDrawer(SerializedProperty property)
		{
			ShowIfAttribute showIfAttr = (this.drawer.attribute as ShowIfAttribute);

			if (showIfAttr != null)
			{
				this.fieldName = showIfAttr.fieldName;
				this.@operator = showIfAttr.@operator;
				this.multiOperator = showIfAttr.multiOperator;
				this.values = showIfAttr.values;
			}

			this.conditionField = this.drawer.fieldInfo.DeclaringType.GetField(this.fieldName,
				BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
			if (this.conditionField == null)
			{
				this.errorAttribute = this.name + " is requiring field \"" + this.fieldName + "\".";
				return;
			}
			else if (this.@operator != Op.None)
			{
				if (this.values[0] == null)
				{
					this.targetValueStringified = new string[] {string.Empty};
					this.PropertyHeight = this.GetHeightAllOpsString;

					if (this.@operator != Op.Equals &&
					    this.@operator != Op.Diff)
					{
						this.errorAttribute = this.name + " is requiring a null value whereas its operator is \"" +
						                      this.@operator + "\" which is impossible.";
					}
				}
				else if (this.values[0] is Boolean)
				{
					this.targetValueStringified = new string[] {this.values[0].ToString()};
					this.PropertyHeight = this.GetHeightAllOpsString;

					if (this.@operator != Op.Equals &&
					    this.@operator != Op.Diff)
					{
						this.errorAttribute = this.name + " is requiring a boolean whereas its operator is \"" +
						                      this.@operator + "\" which is impossible.";
					}
				}
				else if (this.values[0] is Int32 ||
				         this.values[0] is Single ||
				         this.values[0] is Enum ||
				         this.values[0] is Double ||
				         this.values[0] is Decimal ||
				         this.values[0] is Int16 ||
				         this.values[0] is Int64 ||
				         this.values[0] is UInt16 ||
				         this.values[0] is UInt32 ||
				         this.values[0] is UInt64 ||
				         this.values[0] is Byte ||
				         this.values[0] is SByte)
				{
					this.targetValueDecimaled = new Decimal[] {Convert.ToDecimal(this.values[0])};
					this.PropertyHeight = this.GetHeightAllOpsScalar;
				}
				else
				{
					this.targetValueStringified = new string[] {this.values[0].ToString()};
					this.PropertyHeight = this.GetHeightAllOpsString;
				}
			}
			else if (this.multiOperator != MultiOp.None)
			{
				if (this.CheckUseOfNonScalarValue() == true)
				{
					this.targetValueStringified = new string[this.values.Length];
					for (int i = 0; i < this.values.Length; i++)
					{
						if (this.values[i] != null)
							this.targetValueStringified[i] = this.values[i].ToString();
						else
							this.targetValueStringified[i] = string.Empty;
					}

					this.PropertyHeight = this.GetHeightMultiOpsString;
				}
				else
				{
					this.targetValueDecimaled = new Decimal[this.values.Length];
					for (int i = 0; i < this.values.Length; i++)
						this.targetValueDecimaled[i] = Convert.ToDecimal(this.values[i]);

					this.PropertyHeight = this.GetHeightMultiOpsScalar;
				}
			}

			SerializedProperty targetProperty =
				property.serializedObject.FindProperty(property.propertyPath.Replace(property.name, this.fieldName));
			// Force the next update.
			object newValue = GetValue(targetProperty, this.fieldName);

			if (this.lastValue == newValue)
				this.lastValue = true;
		}

		private bool CheckUseOfNonScalarValue()
		{
			for (int i = 0; i < this.values.Length; i++)
			{
				if (this.values[i] == null ||
				    this.values[i] is String ||
				    this.values[i] is Boolean)
				{
					return true;
				}
			}

			return false;
		}

		private float GetHeightAllOpsString(SerializedProperty property, GUIContent label)
		{
			object newValue;
			
			if (property.propertyType == SerializedPropertyType.String)
			{
				newValue = property.stringValue;
			}
			else
			{
				newValue = this.conditionField.GetValue(property.serializedObject.targetObject);
			}

			if (this.lastValue != newValue)
			{
				this.lastValue = newValue;

				if (this.lastValue != null &&
				    // Unity Object is not referenced as real null, it is fake. Don't trust them.
				    (typeof(Object).IsAssignableFrom(this.lastValue.GetType()) == false ||
				     ((this.lastValue as Object).ToString() != "null")))
				{
					this.lastValueStringified = this.lastValue.ToString();
				}
				else
					this.lastValueStringified = string.Empty;

				if (this.@operator == Op.Equals)
					this.conditionResult = this.lastValueStringified.Equals(this.targetValueStringified[0]);
				else if (this.@operator == Op.Diff)
					this.conditionResult = this.lastValueStringified.Equals(this.targetValueStringified[0]) == false;
				else if (this.@operator == Op.Sup)
					this.conditionResult = this.lastValueStringified.CompareTo(this.targetValueStringified[0]) > 0;
				else if (this.@operator == Op.Inf)
					this.conditionResult = this.lastValueStringified.CompareTo(this.targetValueStringified[0]) < 0;
				else if (this.@operator == Op.SupEquals)
					this.conditionResult = this.lastValueStringified.CompareTo(this.targetValueStringified[0]) >= 0;
				else if (this.@operator == Op.InfEquals)
					this.conditionResult = this.lastValueStringified.CompareTo(this.targetValueStringified[0]) <= 0;
			}

			return this.CalculateHeight(property, label);
		}

		private float GetHeightAllOpsScalar(SerializedProperty property, GUIContent label)
		{
			object newValue = this.conditionField.GetValue(property.serializedObject.targetObject);

			if (newValue.Equals(this.lastValue) == false)
			{
				this.lastValue = newValue;

				try
				{
					Decimal value = Convert.ToDecimal(newValue);

					if (this.@operator == Op.Equals)
						this.conditionResult = value == this.targetValueDecimaled[0];
					else if (this.@operator == Op.Diff)
						this.conditionResult = value != this.targetValueDecimaled[0];
					else if (this.@operator == Op.Sup)
						this.conditionResult = value > this.targetValueDecimaled[0];
					else if (this.@operator == Op.Inf)
						this.conditionResult = value < this.targetValueDecimaled[0];
					else if (this.@operator == Op.SupEquals)
						this.conditionResult = value >= this.targetValueDecimaled[0];
					else if (this.@operator == Op.InfEquals)
						this.conditionResult = value <= this.targetValueDecimaled[0];
				}
				catch
				{
				}
			}

			return this.CalculateHeight(property, label);
		}

		private float GetHeightMultiOpsString(SerializedProperty property, GUIContent label)
		{
			object newValue = this.conditionField.GetValue(property.serializedObject.targetObject);

			if (this.lastValue != newValue)
			{
				this.lastValue = newValue;

				if (this.lastValue != null &&
				    // Unity Object is not referenced as real null, it is fake. Don't trust them.
				    (typeof(Object).IsAssignableFrom(this.lastValue.GetType()) == false ||
				     ((this.lastValue as Object).ToString() != "null")))
				{
					this.lastValueStringified = this.lastValue.ToString();
				}
				else
					this.lastValueStringified = string.Empty;

				if (this.multiOperator == MultiOp.Equals)
				{
					this.conditionResult = !this.normalBooleanValue;

					for (int i = 0; i < this.targetValueStringified.Length; i++)
					{
						if (this.lastValueStringified.Equals(this.targetValueStringified[i]) == true)
						{
							this.conditionResult = this.normalBooleanValue;
							break;
						}
					}
				}
				else if (this.multiOperator == MultiOp.Diff)
				{
					int i = 0;

					this.conditionResult = this.normalBooleanValue;

					for (; i < this.targetValueStringified.Length; i++)
					{
						if (this.lastValueStringified.Equals(this.targetValueStringified[i]) == true)
						{
							this.conditionResult = !this.normalBooleanValue;
							break;
						}
					}
				}
			}

			return this.CalculateHeight(property, label);
		}

		public object GetParent(SerializedProperty prop)
		{
			var path = prop.propertyPath.Replace(".Array.data[", "[");
			object obj = prop.serializedObject.targetObject;
			var elements = path.Split('.');
			foreach(var element in elements.Take(elements.Length-1))
			{
				if(element.Contains("["))
				{
					var elementName = element.Substring(0, element.IndexOf("["));
					var index = Convert.ToInt32(element.Substring(element.IndexOf("[")).Replace("[","").Replace("]",""));
					obj = GetValue(obj, elementName, index);
				}
				else
				{
					obj = GetValue(obj, element);
				}
			}
			return obj;
		}
 
		public object GetValue(object source, string name)
		{
			if(source == null)
				return null;
			var type = source.GetType();
			var f = type.GetField(name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance);
			if(f == null)
			{
				var p = type.GetProperty(name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
				if(p == null)
					return null;
				return p.GetValue(source, null);
			}
			return f.GetValue(source);
		}
 
		public object GetValue(object source, string name, int index)
		{
			var enumerable = GetValue(source, name) as IEnumerable;
			var enm = enumerable.GetEnumerator();
			while(index-- >= 0)
				enm.MoveNext();
			return enm.Current;
		}
		private float GetHeightMultiOpsScalar(SerializedProperty property, GUIContent label)
		{
			object newValue = this.conditionField.GetValue(property.serializedObject.targetObject);

			if (newValue.Equals(this.lastValue) == false)
			{
				this.lastValue = newValue;

				try
				{
					Decimal value = Convert.ToDecimal(newValue);

					if (this.multiOperator == MultiOp.Equals)
					{
						this.conditionResult = !this.normalBooleanValue;

						for (int i = 0; i < this.targetValueDecimaled.Length; i++)
						{
							if (value == this.targetValueDecimaled[i])
							{
								this.conditionResult = this.normalBooleanValue;
								break;
							}
						}
					}
					else if (this.multiOperator == MultiOp.Diff)
					{
						int i = 0;

						this.conditionResult = this.normalBooleanValue;

						for (; i < this.targetValueDecimaled.Length; i++)
						{
							if (value == this.targetValueDecimaled[i])
							{
								this.conditionResult = !this.normalBooleanValue;
								break;
							}
						}
					}
				}
				catch
				{
				}
			}

			return this.CalculateHeight(property, label);
		}

		private float CalculateHeight(SerializedProperty property, GUIContent label)
		{
			if (this.conditionResult == this.normalBooleanValue)
			{
				if (this.invalidHeight == true)
				{
					this.invalidHeight = false;
					this.cachedHeight = EditorGUI.GetPropertyHeight(property, label, property.isExpanded);
				}

				return this.cachedHeight;
			}

			return ConditionalRenderer.EmptyHeight;
		}
	}
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/ShowIfDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/ShowWhenEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 3c1789e3f7062304c846bcd97b87f3d2
# ASMDEF: ldx.framework.editor.dll
# ---
// PUT IN EDITOR FOLDER

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    [CustomPropertyDrawer(typeof(ShowWhenAttribute))]
    public class ShowWhenDrawer : PropertyDrawer
    {
        private bool showField = true;

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            ShowWhenAttribute attribute = (ShowWhenAttribute)this.attribute;
            SerializedProperty conditionField = property.serializedObject.FindProperty(attribute.conditionFieldName);

            // We check that exist a Field with the parameter name
            if (conditionField == null)
            {
                ShowError(position, label, "Error getting the condition Field. Check the name.");
                return;
            }

            switch (conditionField.propertyType)
            {
                case SerializedPropertyType.Boolean:
                    try
                    {
                        bool comparationValue = attribute.comparationValue == null || (bool)attribute.comparationValue;
                        showField = conditionField.boolValue == comparationValue;
                    }
                    catch
                    {
                        ShowError(position, label, "Invalid comparation Value Type");
                        return;
                    }
                    break;
                case SerializedPropertyType.Enum:
                    object paramEnum = attribute.comparationValue;
                    object[] paramEnumArray = attribute.comparationValueArray;

                    if (paramEnum == null && paramEnumArray == null)
                    {
                        ShowError(position, label, "The comparation enum value is null");
                        return;
                    }
                    else if (IsEnum(paramEnum))
                    {
                        if (!CheckSameEnumType(new[] { paramEnum.GetType() }, property.serializedObject.targetObject.GetType(), conditionField.propertyPath))
                        {
                            ShowError(position, label, "Enum Types doesn't match");
                            return;
                        }
                        else
                        {
                            string enumValue = Enum.GetValues(paramEnum.GetType()).GetValue(conditionField.enumValueIndex).ToString();
                            if (paramEnum.ToString() != enumValue)
                                showField = false;
                            else
                                showField = true;
                        }
                    }
                    else if (IsEnum(paramEnumArray))
                    {
                        if (!CheckSameEnumType(paramEnumArray.Select(x => x.GetType()), property.serializedObject.targetObject.GetType(), conditionField.propertyPath))
                        {
                            ShowError(position, label, "Enum Types doesn't match");
                            return;
                        }
                        else
                        {
                            string enumValue = Enum.GetValues(paramEnumArray[0].GetType()).GetValue(conditionField.enumValueIndex).ToString();
                            if (paramEnumArray.All(x => x.ToString() != enumValue))
                                showField = false;
                            else
                                showField = true;
                        }
                    }
                    else
                    {
                        ShowError(position, label, "The comparation enum value is not an enum");
                        return;
                    }
                    break;
                case SerializedPropertyType.Integer:
                case SerializedPropertyType.Float:
                    string stringValue;
                    bool error = false;

                    float conditionValue = 0;
                    if (conditionField.propertyType == SerializedPropertyType.Integer)
                        conditionValue = conditionField.intValue;
                    else if (conditionField.propertyType == SerializedPropertyType.Float)
                        conditionValue = conditionField.floatValue;

                    try
                    {
                        stringValue = (string)attribute.comparationValue;
                    }
                    catch
                    {
                        ShowError(position, label, "Invalid comparation Value Type");
                        return;
                    }

                    if (stringValue.StartsWith("=="))
                    {
                        float? value = GetValue(stringValue, "==");
                        if (value == null)
                            error = true;
                        else
                            showField = conditionValue == value;
                    }
                    else if (stringValue.StartsWith("!="))
                    {
                        float? value = GetValue(stringValue, "!=");
                        if (value == null)
                            error = true;
                        else
                            showField = conditionValue != value;
                    }
                    else if (stringValue.StartsWith("<="))
                    {
                        float? value = GetValue(stringValue, "<=");
                        if (value == null)
                            error = true;
                        else
                            showField = conditionValue <= value;
                    }
                    else if (stringValue.StartsWith(">="))
                    {
                        float? value = GetValue(stringValue, ">=");
                        if (value == null)
                            error = true;
                        else
                            showField = conditionValue >= value;
                    }
                    else if (stringValue.StartsWith("<"))
                    {
                        float? value = GetValue(stringValue, "<");
                        if (value == null)
                            error = true;
                        else
                            showField = conditionValue < value;
                    }
                    else if (stringValue.StartsWith(">"))
                    {
                        float? value = GetValue(stringValue, ">");
                        if (value == null)
                            error = true;
                        else
                            showField = conditionValue > value;
                    }

                    if (error)
                    {
                        ShowError(position, label, "Invalid comparation instruction for Int or float value");
                        return;
                    }
                    break;
                default:
                    ShowError(position, label, "This type has not supported.");
                    return;
            }

            if (showField)
                EditorGUI.PropertyField(position, property, true);
        }

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            if (showField)
                return EditorGUI.GetPropertyHeight(property);
            else
                return -EditorGUIUtility.standardVerticalSpacing;
        }

        /// <summary>
        /// Return if the object is enum and not null
        /// </summary>
        private static bool IsEnum(object obj)
        {
            return obj != null && obj.GetType().IsEnum;
        }

        /// <summary>
        /// Return if all the objects are enums and not null
        /// </summary>
        private static bool IsEnum(object[] obj)
        {
            return obj != null && obj.All(o => o.GetType().IsEnum);
        }

        /// <summary>
        /// Check if the field with name "fieldName" has the same class as the "checkTypes" classes through reflection
        /// </summary>
        private static bool CheckSameEnumType(IEnumerable<Type> checkTypes, Type classType, string fieldName)
        {
            FieldInfo memberInfo;
            string[] fields = fieldName.Split('.');
            if (fields.Length > 1)
            {
                memberInfo = classType.GetField(fields[0]);
                for (int i = 1; i < fields.Length; i++)
                {
                    memberInfo = memberInfo.FieldType.GetField(fields[i]);
                }
            }
            else
                memberInfo = classType.GetField(fieldName);

            if (memberInfo != null)
                return checkTypes.All(x => x == memberInfo.FieldType);

            return false;
        }

        private void ShowError(Rect position, GUIContent label, string errorText)
        {
            EditorGUI.LabelField(position, label, new GUIContent(errorText));
            showField = true;
        }

        /// <summary>
        /// Return the float value in the content string removing the remove string
        /// </summary>
        private static float? GetValue(string content, string remove)
        {
            string removed = content.Replace(remove, "");
            try
            {
                return float.Parse(removed);
            }
            catch
            {
                return null;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/ShowWhenEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/SoundReferenceDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 42ca308ef302a6e46a0e4786ca33b565
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.SoundBrowser;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Attributes
{
    /// <summary>
    /// Custom sound ID selection drawer for any sound reference string.
    /// </summary>
    [CustomPropertyDrawer(typeof(SoundReferenceAttribute))]
    public class SoundReferenceDrawer : PropertyDrawer
    {
        private const string BROWSE_TOOLTIP = "Open in Sound Browser";
        private const string PLAY_TOOLTIP = "Open Sound Player/Editor";
        private const string REFRESH_TOOLTIP = "Refresh Sound Browser Tables";
        
        private static readonly GUIContent BrowseButtonContent = EditorGUIUtility.IconContent("d_Profiler.FileAccess");
        private static readonly GUIContent PlayButtonContent = EditorGUIUtility.IconContent("d_PlayButton");
        private static readonly GUIContent RefreshButtonContent = EditorGUIUtility.IconContent("d_Refresh");
        
        private int index;
        private List<string> soundGUIDs;
        private List<string> soundPaths;

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            // Copy paths list so as not to modify the serialized one
            AudioGlobalSettings.EDITOR_GetParallelGUIDAndPathLists(out soundGUIDs, out soundPaths);

            soundGUIDs.Insert(0, "");
            soundPaths.Insert(0, "None");
            
            EditorGUI.BeginChangeCheck();
            index = 0;
            if (!String.IsNullOrEmpty(property.stringValue))
            {
                index = soundGUIDs.IndexOf(property.stringValue);
                if (index < 0)
                {
                    EditorGUI.LabelField(new Rect(position.x, position.y, position.width / 2.0f, position.height),
                        property.displayName);
                    
                    if (PrefabHelper.IsInPrefabStaging())
                    {
                        GUI.Label(GetGUIDNotFoundRect(position),
                            $"Sound GUID not found, possibly due to being in prefab mode");
                    }
                    else if (GUI.Button(GetGUIDNotFoundRect(position), $"Sound GUID not found. Click to reset."))
                    {
                        property.stringValue = string.Empty;
                    }

                    return;
                }
            }
            
            if (soundGUIDs.Count == 0)
            {
                EditorGUI.LabelField(position, "No Sounds found", EditorStyles.helpBox);
                position.y += position.height;
                return;
            }

            if (index >= soundGUIDs.Count)
            {
                index = 0;
            }

            float buttonWidth = 25;
            float playButtonWidth = 25;
            float browseButtonWidth = 25;
            float dropdownWidth = position.width - buttonWidth - playButtonWidth - browseButtonWidth;
            Rect dropdownPosition = new (position.x, position.y, dropdownWidth, position.height);
            index = EditorGUI.Popup(dropdownPosition, property.displayName, index, soundPaths.ToArray());
            property.stringValue = soundGUIDs[index];

            Rect refreshButtonPosition = new (position.x + dropdownWidth, position.y, buttonWidth, position.height);
            Rect playButtonPosition = new(position.x + dropdownWidth + buttonWidth, position.y, playButtonWidth,
                position.height);
            Rect browseButtonPosition = new(position.x + dropdownWidth + buttonWidth + playButtonWidth, position.y,
                browseButtonWidth, position.height);
            
            RefreshButtonContent.tooltip = REFRESH_TOOLTIP;
            if (GUI.Button(refreshButtonPosition, RefreshButtonContent))
            {
                AudioGlobalSettings.EDITOR_UpdateSoundGUIDToPathTable();
            }
            
            PlayButtonContent.tooltip = PLAY_TOOLTIP;
            if (GUI.Button(playButtonPosition, PlayButtonContent))
            {
                OpenSoundPlayer(property.stringValue);
            }
            
            BrowseButtonContent.tooltip = BROWSE_TOOLTIP;
            if (GUI.Button(browseButtonPosition, BrowseButtonContent))
            {
                OpenSoundBrowser(property.stringValue);
            }

            property.stringValue = soundGUIDs[index];

            if (EditorGUI.EndChangeCheck())
            {
                property.serializedObject.ApplyModifiedProperties();
            }
        }

        private Rect GetGUIDNotFoundRect(Rect position)
        {
            return new Rect(position.x + (position.width / 2.0f), position.y, position.width / 2.0f, position.height);
        }
        
        /// <summary>
        /// Opens the Sound Browser window and tries to select the sound with the specified GUID
        /// </summary>
        private void OpenSoundBrowser(string soundGUID)
        {
            if (string.IsNullOrEmpty(soundGUID))
                return;
                
            SoundBrowserWindow window = EditorWindow.GetWindow<SoundBrowserWindow>();
            
            if (AudioGlobalSettings.TryGetPathFromReference(soundGUID, out string path))
            {
                window.SelectSound(path);
            }
        }

        /// <summary>
        /// Opens the Sound Player window and loads the sound with the specified GUID
        /// </summary>
        private void OpenSoundPlayer(string soundGUID)
        {
            if (string.IsNullOrEmpty(soundGUID))
                return;
            
            Sound sound = Audio.LoadSound(soundGUID);
            if (sound)
            {
                SoundPlayerEditorWindow.SetSound(sound);
            }
            else
            {
                Debug.LogError($"Could not load sound with GUID: {soundGUID}");
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Attributes/SoundReferenceDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/AutoSave/AutoSave.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6df37d5beedfc0f42b7fb4884ef6fd4f
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine.SceneManagement;

namespace Ldx.Framework.Utilities.AutoSave
{
    [InitializeOnLoad]
    public class AutoSave
    {
        private const string AUTO_SAVE_KEY = "AutoSceneSaveEnabled";
        private const float SAVE_INTERVAL = 180; // Save Every 3 Minutes
        private static double lastSaveTime;

        static AutoSave()
        {
            lastSaveTime = EditorApplication.timeSinceStartup;
            EditorApplication.update += Update;
        }

        private static void Update()
        {
            if (!IsAutoSaveEnabled())
                return;

            if (EditorApplication.isPlaying || EditorApplication.isPlayingOrWillChangePlaymode)
                return;

            if (EditorApplication.timeSinceStartup - lastSaveTime > SAVE_INTERVAL)
            {
                SaveMainScene();
                lastSaveTime = EditorApplication.timeSinceStartup;
            }
        }

        [MenuItem("LogicalDox/Auto Scene Save/Enable Auto Scene Save")]
        private static void EnableAutoSave()
        {
            EditorPrefs.SetBool(AUTO_SAVE_KEY, true);
            Debug.Log("Auto Scene Save Enabled");
        }

        [MenuItem("LogicalDox/Auto Scene Save/Disable Auto Scene Save")]
        private static void DisableAutoSave()
        {
            EditorPrefs.SetBool(AUTO_SAVE_KEY, false);
            Debug.Log("Auto Scene Save Disabled");
        }

        [MenuItem("LogicalDox/Auto Scene Save/Enable Auto Scene Save", true)]
        private static bool ValidateEnableAutoSave()
        {
            return !IsAutoSaveEnabled();
        }

        [MenuItem("LogicalDox/Auto Scene Save/Disable Auto Scene Save", true)]
        private static bool ValidateDisableAutoSave()
        {
            return IsAutoSaveEnabled();
        }

        private static bool IsAutoSaveEnabled()
        {
            return EditorPrefs.GetBool(AUTO_SAVE_KEY, false);
        }

        private static void SaveMainScene()
        {
            Scene mainScene = SceneManager.GetActiveScene();
            if (mainScene.isDirty)
            {
                // Save the main scene
                EditorSceneManager.SaveScene(mainScene);
                Debug.Log("Main scene saved at " + System.DateTime.Now);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/AutoSave/AutoSave.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Bakery/BakeryPathOverride.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b16aab028e8c47dead7db7d83901f24e
# ASMDEF: ldx.framework.editor.dll
# ---
using System.IO;
using UnityEditor;
using UnityEngine;
using Debug = Ldx.Framework.Utilities.Logging.Debug;

namespace Ldx.Framework.Utilities.Bakery
{
    [InitializeOnLoad]
    public class BakeryPathOverride
    {
        private const string PROJECT_STORAGE_PATH = "Assets/Settings";
        
        static BakeryPathOverride()
        {
            Debug.Log("Applying Bakery Path Override...");
            
            ftLightmaps._bakeryRuntimePath = PROJECT_STORAGE_PATH + "/";
            
            if (!Directory.Exists(PROJECT_STORAGE_PATH))
            {
                Directory.CreateDirectory(PROJECT_STORAGE_PATH);
            }
            
            string globalStoragePath = Path.Combine(PROJECT_STORAGE_PATH, "ftGlobalStorage.asset");
            if (!File.Exists(globalStoragePath))
            {
                ftGlobalStorage gStorage = ScriptableObject.CreateInstance<ftGlobalStorage>();
                AssetDatabase.CreateAsset(gStorage, globalStoragePath);
                AssetDatabase.SaveAssets();
                Debug.Log("Created new ftGlobalStorage.asset at: " + globalStoragePath);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Bakery/BakeryPathOverride.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/DynamicMenuItem.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: ae8244fecf4741fcb16e22530fb84fa3
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Reflection;

namespace Ldx.Framework.Utilities
{
    public static class DynamicMenuItem
    {
        private static Type menuType;

        private static Type MenuType
        {
            get
            {
                if (menuType == null)
                { 
                    menuType = Type.GetType("UnityEditor.Menu, UnityEditor");
                }
                return menuType;
            }
        }
        
        public static void AddMenuItem(string name, string shortcut, bool @checked, int priority, 
            Action execute, Func<bool> validate)
        {
            MethodInfo method = MenuType.GetMethod("AddMenuItem", BindingFlags.Static | BindingFlags.NonPublic);
            method?.Invoke(null, new object[] { name, shortcut, @checked, priority, execute, validate });
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/DynamicMenuItem.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/ExportImportScene/ExportSceneWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c96f0cd0bcfe4ea1b65192e9e4dd6679
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Ldx.Framework.Utilities.ExportImportScene
{
    public class ExportSceneWindow : EditorWindow
    {
        // Scene Selection
        private List<Scene> loadedScenes;
        private string[] sceneNames;
        private int sceneIndex;
        
        // Export Path
        private string exportPath;
        private bool exportPathValid;

        // Directory name
        private string directoryName = "";

        private bool CanExport => exportPathValid && !String.IsNullOrEmpty(directoryName);
        
        private ExportWindowController controller;
        private static GUIStyle outputLabelStyle;
        
        [MenuItem("LogicalDox/Export \u2215 Import Scene Package/Export", priority = 0)]
        private static void ShowWindow()
        {
            ExportSceneWindow window = GetWindow<ExportSceneWindow>();
            window.titleContent = new GUIContent("Export Scene Package");
            window.Show();
        }

        private void OnEnable()
        {
            controller = new ExportWindowController();
            loadedScenes = SceneUtilities.GetAllLoadedScenes();
            sceneNames = loadedScenes.Select(s => s.name).ToArray();
            sceneIndex = Mathf.Max(0, sceneNames.Length - 1);
        }

        private void OnGUI()
        {
            LdxEditorHelper.DrawTitle("Export Scene");
            DrawSceneSelection();
            DrawExportPathSelection();
            DrawParentDirectoryName();
            DrawExportButton();
        }
        
        private void DrawSceneSelection()
        {
            sceneIndex = EditorGUILayout.Popup("Scene:", sceneIndex, sceneNames);
        }

        private void DrawExportPathSelection()
        {
            LdxEditorHelper.DrawHorizontalSeparator();
            LdxEditorHelper.DrawBoldLabel("Export Path");
            using (new EditorGUILayout.HorizontalScope())
            {
                if (GUILayout.Button("Browse", GUILayout.Width(100)))
                {
                    exportPath = EditorUtility.OpenFolderPanel("Export Path", "", "");
                }

                bool isPathSelected = !String.IsNullOrEmpty(exportPath);
                if (!isPathSelected)
                {
                    exportPathValid = false;
                }
                EditorGUILayout.LabelField(isPathSelected? exportPath : "No path selected");
            }
            
            if (!String.IsNullOrEmpty(exportPath))
            {
                exportPathValid = ExportWindowController.VerifyPathNotInProject(exportPath);
                if (!exportPathValid)
                {
                    EditorGUILayout.LabelField("Export path can't be within this project", LdxEditorHelper.RedLabelStyle);
                }
            }
        }

        private void DrawParentDirectoryName()
        {
            if (outputLabelStyle == null)
            {
                outputLabelStyle = new GUIStyle(EditorStyles.boldLabel);
                outputLabelStyle.alignment = TextAnchor.MiddleLeft;
                outputLabelStyle.richText = true;
                outputLabelStyle.fontStyle = FontStyle.Italic;
            }
            
            LdxEditorHelper.DrawHorizontalSeparator();
            EditorGUILayout.LabelField("When importing, this will correspond with the parent directory under Assets/Art/", EditorStyles.helpBox);
            EditorGUILayout.LabelField("Please make sure no special characters or spaces are included", EditorStyles.helpBox);

            string previousName = directoryName;
            
            directoryName = EditorGUILayout.TextField("Package/Scene Name: ", directoryName);
            EditorGUILayout.LabelField($"Import path: Assets/Art/<b>{directoryName}</b>", outputLabelStyle);
            if (directoryName != previousName)
            {
                directoryName = SanitizeDirectoryName(directoryName);
            }
        }

        private void DrawExportButton()
        {
            LdxEditorHelper.DrawHorizontalSeparator();
            GUI.enabled = CanExport;

            if (GUILayout.Button("Export"))
            {
                if (controller.ExportScene(sceneNames[sceneIndex], exportPath, directoryName))
                {
                    string packagePath = $"{exportPath}/{directoryName}.{ExportWindowController.PACKAGE_EXTENSION}";
                    EditorUtility.DisplayDialog("Success", $"Package exported successfully at path \n\n{packagePath}", "Ok");
                    PathUtilities.OpenInFileBrowser(packagePath);
                    exportPath = "";
                    directoryName = "";
                }
            }
            
            GUI.enabled = true;
        }

        private static string SanitizeDirectoryName(string str)
        {
            str = str.Replace(' ', '_');
            return str.RemoveSpecialCharacters();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/ExportImportScene/ExportSceneWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/ExportImportScene/ExportWindowController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 9f8b7d4a0f364d538a285c5386afb2bb
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Cysharp.Threading.Tasks;
using FluffyUnderware.DevTools.Extensions;
using Ldx.Framework.Utilities.Editor;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;
using UnityEngine.SceneManagement;
using Object = UnityEngine.Object;

namespace Ldx.Framework.Utilities.ExportImportScene
{
    public class ExportWindowController
    {
        private enum PathType
        {
            Models,
            Prefabs,
            Textures,
            Materials,
            Shaders
        }

        public const string PACKAGE_EXTENSION = "ldxpckg";
        private const string EXPORT_WORKING_DIRECTORY = "Export_Temp";

        // Scene
        private string sceneName;
        private Scene workingScene;

        // Export Path
        private string exportPath;
        private string directoryName;
        private string workingScenePath;

        private Dictionary<PathType, HashSet<string>> pathMap = new();
        private HashSet<Object> checkedPrefabsSet = new();
        private HashSet<string> processedGUIDSet = new();
        private List<string> initialScenePaths = new();

        public bool ExportScene(string sceneName, string exportPath, string directoryName)
        {
            this.sceneName = sceneName;
            this.exportPath = exportPath;
            this.directoryName = directoryName;

            checkedPrefabsSet.Clear();
            processedGUIDSet.Clear();
            initialScenePaths.Clear();
            
            pathMap.Clear();
            foreach (PathType t in Enum.GetValues(typeof(PathType)))
            {
                pathMap.Add(t, new HashSet<string>());
            }

            if (!LdxEditorUtilities.CheckAndAskToSaveUnsavedScenes())
            {
                return false;
            }

            if (!SaveSceneCopyAndOpen(out workingScene))
            {
                return false;
            }

            ProcessSceneObjects();
            ExportAssetsWithMetaFiles();
            CreatePackage();
            ReopenStartScenes();
            return true;
        }

        private bool SaveSceneCopyAndOpen(out Scene outputScene)
        {
            Scene originScene = SceneManager.GetSceneByName(sceneName);
            outputScene = originScene;
            string folderPath = $"Assets/{EXPORT_WORKING_DIRECTORY}";
            workingScenePath = $"{folderPath}/{sceneName}.unity";
            
            if (!AssetDatabase.IsValidFolder(folderPath))
            {
                AssetDatabase.CreateFolder("Assets", EXPORT_WORKING_DIRECTORY);
            }

            if (!EditorSceneManager.SaveScene(originScene, workingScenePath))
            {
                return false;
            }

            if (File.Exists(PathUtilities.AssetsRelativePathToAbsolutePath(workingScenePath)))
            {
                outputScene = EditorSceneManager.OpenScene(workingScenePath, OpenSceneMode.Single);
                return true;
            }

            return false;
        }

        private void ProcessSceneObjects()
        {
            List<GameObject> objects = Object.FindObjectsByType<Transform>(FindObjectsInactive.Include, FindObjectsSortMode.None).Select((t) => t.gameObject).ToList();

            foreach (GameObject o in objects)
            {
                o.GetComponents<MonoBehaviour>().ForEach(Object.DestroyImmediate);
                processPrefabOrModel(o);
                processMeshes(o);
                processMaterials(o);
            }

            return;
            
            void processPrefabOrModel(GameObject o)
            {
                if (!IsValidPrefabObject(o, checkedPrefabsSet))
                {
                    return;
                }

                Object source = PrefabUtility.GetCorrespondingObjectFromSource(o);

                if (!checkedPrefabsSet.Add(source))
                {
                    return;
                }

                bool isModel = IsModelPrefab(o);
                
                string path = AssetDatabase.GetAssetPath(source);
                if (string.IsNullOrEmpty(path))
                {
                    return;
                }

                AddPath(isModel ? PathType.Models : PathType.Prefabs, path);
                
                Object rootPrefab = PrefabUtility.GetCorrespondingObjectFromOriginalSource(o);
                if (rootPrefab == null)
                {
                    return;
                }
                string sourcePath = AssetDatabase.GetAssetPath(rootPrefab);
                checkedPrefabsSet.Add(rootPrefab);
                AddPath(isModel ? PathType.Models : PathType.Prefabs, sourcePath);
            }

            void processMeshes(GameObject o)
            {
                MeshFilter[] meshFilters = o.GetComponents<MeshFilter>();
                if (meshFilters.Length == 0)
                {
                    return;
                }

                foreach (MeshFilter filter in meshFilters)
                {
                    if (filter.sharedMesh == null)
                    {
                        continue;
                    }

                    string path = AssetDatabase.GetAssetPath(filter.sharedMesh);
                    if (string.IsNullOrEmpty(path) || pathMap[PathType.Models].Contains(path))
                    {
                        continue;
                    }

                    AddPath(PathType.Models, path);
                }
            }

            void processMaterials(GameObject o)
            {
                MeshRenderer[] renderers = o.GetComponents<MeshRenderer>();

                foreach (MeshRenderer r in renderers)
                {
                    HashSet<Material> materialsSet = new(r.sharedMaterials);
                    if (r.sharedMaterial != null)
                    {
                        materialsSet.Add(r.sharedMaterial);
                    }

                    foreach (Material m in materialsSet)
                    {
                        if (m == null)
                        {
                            continue;
                        }

                        string materialPath = AssetDatabase.GetAssetPath(m);
                        string shaderPath = AssetDatabase.GetAssetPath(m.shader);
                        if (!string.IsNullOrEmpty(materialPath))
                        {
                            AddPath(PathType.Materials, materialPath);
                        }

                        if (!string.IsNullOrEmpty(shaderPath))
                        {
                            AddPath(PathType.Shaders, shaderPath);
                        }
                        
                        GetAllTexturesForMaterial(m).ForEach((t) =>
                        {
                            string texturePath = AssetDatabase.GetAssetPath(t);
                            if (!string.IsNullOrEmpty(texturePath))
                            {
                                AddPath(PathType.Textures, texturePath);
                            }
                        });
                    }
                }
            }
        }

        private void ExportAssetsWithMetaFiles()
        {
            string outputPath = $"{exportPath}/{directoryName}";
            if (!Directory.Exists(outputPath))
            {
                Directory.CreateDirectory(outputPath);
            }
            foreach (PathType type in pathMap.Keys)
            {
                string typeOutputDirectory = outputPath + "/" + type + "/";
                foreach (string sourcePath in pathMap[type])
                {
                    try
                    {
                        if (!Directory.Exists(typeOutputDirectory))
                        {
                            Directory.CreateDirectory(typeOutputDirectory);
                        }
                        string sourceMetaPath = sourcePath + ".meta";
                    
                        string destinationPath = typeOutputDirectory + Path.GetFileName(sourcePath);
                        string destinationMetaPath = destinationPath + ".meta";
                    
                        File.Copy(sourcePath, destinationPath);
                        File.Copy(sourceMetaPath, destinationMetaPath);
                    }
                    catch (Exception e)
                    {
                        Debug.LogError(e);
                    }
                }
            }

            try
            {
                string destinationScenePath = $"{outputPath}/{Path.GetFileName(workingScenePath)}";
                string destinationSceneMetaPath = destinationScenePath + ".meta";
                File.Copy(workingScenePath, destinationScenePath);
                File.Copy(workingScenePath+".meta", destinationSceneMetaPath);
                Directory.Delete( $"Assets/{EXPORT_WORKING_DIRECTORY}", true);
            }
            catch (Exception e)
            {
                Debug.LogError(e);
            }
        }

        private void CreatePackage()
        {
            string directoryPath = $"{exportPath}/{directoryName}";
            string packagePath = $"{exportPath}/{directoryName}.{PACKAGE_EXTENSION}";
            try
            {
                File.WriteAllText($"{directoryPath}/GUID.info", string.Join("\n", processedGUIDSet));
                Unity.SharpZipLib.Utils.ZipUtility.CompressFolderToZip(packagePath, null, directoryPath);
                Directory.Delete(directoryPath, true);
            }
            catch (Exception e)
            {
                Debug.LogError(e);
            }
        }

        private void ReopenStartScenes()
        {
            for (int i = 0; i < initialScenePaths.Count; i++)
            {
                string path = initialScenePaths[i];
                EditorSceneManager.OpenScene(path, i == 0 ? OpenSceneMode.Single : OpenSceneMode.Additive);
            }
        }
        
        private void AddPath(PathType type, string path)
        {
            if (path.Contains("LdxFramework"))
            {
                return;
            }

            string guid = AssetDatabase.AssetPathToGUID(path);

            if (string.IsNullOrEmpty(guid) || processedGUIDSet.Contains(guid))
            {
                return;
            }

            pathMap[type].Add(PathUtilities.AssetsRelativePathToAbsolutePath(path));
            processedGUIDSet.Add(guid);

        }

        public static bool VerifyPathNotInProject(string path)
        {
            string projectPath = Application.dataPath.Replace("/Assets", "");
            return !path.Contains(projectPath);
        }

        private static bool IsValidPrefabObject(GameObject gameObject, HashSet<Object> checkedPrefabs)
        {
            PrefabInstanceStatus status = PrefabUtility.GetPrefabInstanceStatus(gameObject);
            return status != PrefabInstanceStatus.NotAPrefab;
        }

        private static bool IsModelPrefab(GameObject gameObject)
        {
            return PrefabUtility.GetPrefabAssetType(gameObject) == PrefabAssetType.Model;
        }

        private static List<Texture> GetAllTexturesForMaterial(Material material)
        {
            List<Texture> textures = new();
            string[] texturePropertyNames = material.GetTexturePropertyNames();
            for (int i = 0; i < texturePropertyNames.Length; i++)
            {
                Texture texture = material.GetTexture(texturePropertyNames[i]);
                if (texture != null)
                {
                    textures.Add(texture);
                }
            }

            return textures;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/ExportImportScene/ExportWindowController.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/ExportImportScene/ImportSceneWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 2ca5cda9ef5846cc9d3099781564ffae
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Ldx.Framework.Utilities.ExportImportScene
{
    public class ImportSceneWindow : EditorWindow
    {
        private const string DISCARD_BIN_DIR_NAME = "ImportDiscardBin";
        
        private string importPath = "";
        private bool importPathValid;

        [MenuItem("LogicalDox/Export \u2215 Import Scene Package/Import", priority = 0)]
        private static void ShowWindow()
        {
            ImportSceneWindow window = GetWindow<ImportSceneWindow>();
            window.titleContent = new GUIContent("Import Scene Package");
            window.Show();
        }

        [MenuItem("LogicalDox/Export \u2215 Import Scene Package/Open Import Discard Bin", priority = 1)]
        private static void OpenDiscardBinMenuItem()
        {
            OpenDiscardBinInFileBrowser();
        }

        private void OnGUI()
        {
            DrawImportPathSelection();
            DrawImportButton();
        }
        
        private void DrawImportPathSelection()
        {
            LdxEditorHelper.DrawHorizontalSeparator();
            LdxEditorHelper.DrawBoldLabel("Select Package to Import");
            using (new EditorGUILayout.HorizontalScope())
            {
                if (GUILayout.Button("Browse", GUILayout.Width(100)))
                {
                    importPath = EditorUtility.OpenFilePanel("Import Path", "", ExportWindowController.PACKAGE_EXTENSION);
                    if (!importPath.EndsWith(ExportWindowController.PACKAGE_EXTENSION))
                    {
                        importPath = "";
                    }
                }

                importPathValid = !String.IsNullOrEmpty(importPath);
              
                EditorGUILayout.LabelField(importPathValid? importPath : "No package selected");
            }
        }

        private void DrawImportButton()
        {
            GUI.enabled = importPathValid;
            LdxEditorHelper.DrawHorizontalSeparator();
            if (GUILayout.Button("Import", GUILayout.Width(100)))
            {
                if (ProcessImportingPackage(out string destinationPath, out List<string> discardedAssetNames))
                {
                    EditorUtility.DisplayDialog("Success", $"Package imported successfully at path \n\n{destinationPath}", "Ok");
                    if (discardedAssetNames.Count > 0)
                    {
                        ShowDiscardBinWarning(discardedAssetNames);
                    }
                }
                else
                {
                    EditorUtility.DisplayDialog("Error", $"Failed to import package", "Ok");
                }

                importPath = "";
            }

            GUI.enabled = true;
        }


        private bool ProcessImportingPackage(out string destinationPath, out List<string> discardedAssetNames)
        {
            destinationPath = null;
            discardedAssetNames = new();
            string packageName = Path.GetFileName(importPath).Split('.')[0];
            string tempDirectory = Application.dataPath.Replace("/Assets", $"/Temp/{packageName}");
            Unity.SharpZipLib.Utils.ZipUtility.UncompressFromZip(importPath, null, tempDirectory);
            string guidInfoPath = tempDirectory + "/GUID.info";
            string guids = File.ReadAllText(guidInfoPath);

            if (String.IsNullOrEmpty(guids))
            {
                return false;
            }
            
            // Remove duplicate assets
            // We assume that if an asset already exists, the new imported version is the updated version
            AssetDatabase.Refresh();
            MoveDuplicateAssetsToBin(guids.Split('\n'), discardedAssetNames);
            if (discardedAssetNames.Count > 0)
            {
                AssetDatabase.Refresh();
            }
            File.Delete(guidInfoPath);

            string artPath = Application.dataPath + "/Art";
            if (!Directory.Exists(artPath))
            {
                Directory.CreateDirectory(artPath);
            }
            destinationPath = artPath + $"/{packageName}";
            
            Directory.Move(tempDirectory, destinationPath);
            AssetDatabase.Refresh();
            tryFocusOnImportedSceneFile(destinationPath);
            return true;

            void tryFocusOnImportedSceneFile(string importPath)
            {
                string searchPath = PathUtilities.AssetAbsolutePathToRelativePath(importPath);
                string[] guids = AssetDatabase.FindAssets("t:Scene", new[] { searchPath });
                string scenePath = guids
                    .Select(guid => AssetDatabase.GUIDToAssetPath(guid))
                    .FirstOrDefault();
                
                if (string.IsNullOrEmpty(scenePath))
                {
                    return;
                }
                EditorUtility.FocusProjectWindow();
                Object scene = AssetDatabase.LoadAssetAtPath<Object>(scenePath);
                Selection.activeObject = scene;
            }
        }

        private void MoveDuplicateAssetsToBin(string[] guids, List<string> discardedAssetNames)
        {
            string discardDirectory = Application.dataPath.Replace("Assets", DISCARD_BIN_DIR_NAME);
            foreach (string guid in guids)
            {
                if (DoesAssetExist(guid, out string path))
                {
                    moveToDiscardBin(path);
                }
            }

            void moveToDiscardBin(string sourcePath)
            {
                if (!Directory.Exists(discardDirectory))
                {
                    Directory.CreateDirectory(discardDirectory);
                }

                try
                {
                    sourcePath = PathUtilities.AssetsRelativePathToAbsolutePath(sourcePath);
                    string fileName = Path.GetFileName(sourcePath);
                    string destination = Path.Combine(discardDirectory, fileName);
                    File.Move(sourcePath, destination);
                    // Move meta files as well
                    File.Move(sourcePath+".meta", destination + ".meta");
                    string assetName = fileName;
                    if (assetName.Contains('.'))
                    {
                        assetName = assetName.Split('.')[0];
                    }
                    discardedAssetNames.Add(assetName);
                }
                catch (Exception e)
                {
                    Debug.LogError(e);
                }
            }
        }

        private void ShowDiscardBinWarning(List<string> discardedAssetNames)
        {
            string namesList = String.Join("\n-", discardedAssetNames);
            if (!EditorUtility.DisplayDialog("Message",
                    $"The following assets had duplicate IDs and were moved to the Import discard bin\n\n-{namesList}", "Ok", "Open Discard Bin"))
            {
                OpenDiscardBinInFileBrowser();
            }   
        }

        private static void OpenDiscardBinInFileBrowser()
        {
            string discardDirectory = Application.dataPath.Replace("Assets", DISCARD_BIN_DIR_NAME);
            if (!Directory.Exists(discardDirectory))
            {
                Directory.CreateDirectory(discardDirectory);
            }
            PathUtilities.OpenInFileBrowser(discardDirectory);
        }

        private bool DoesAssetExist(string guid, out string path)
        {
            path = AssetDatabase.GUIDToAssetPath(guid);
            if (!String.IsNullOrEmpty(path))
            {
                // If directory, ignore
                string fullPath = PathUtilities.AssetsRelativePathToAbsolutePath(path);
                if (Directory.Exists(fullPath))
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/ExportImportScene/ImportSceneWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Extensions/RectExtension.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 041c6e84567f4315a49e20ebff022980
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace Utilities.Extentions
{
    public static class RectExtension
    {
        public static void DrawRectWithBorder(Rect rect, Color fillColor, Color borderColor, float borderWidth)
        {
            EditorGUI.DrawRect(rect, fillColor);
            EditorGUI.DrawRect(new Rect(rect.x, rect.y, rect.width, borderWidth), borderColor);
            EditorGUI.DrawRect(new Rect(rect.x, rect.y + rect.height - borderWidth, rect.width, borderWidth), borderColor);
            EditorGUI.DrawRect(new Rect(rect.x, rect.y, borderWidth, rect.height), borderColor);
            EditorGUI.DrawRect(new Rect(rect.x + rect.width - borderWidth, rect.y, borderWidth, rect.height), borderColor);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Extensions/RectExtension.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/FlyingCamera.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 2d0e2eade1a5d2549ae1bdbd1573da55
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities
{
    public class FlyingCameraController : MonoBehaviour
    {
        public float movementSpeed = 10f;
        public float rotationSpeed = 100f;

        private float rotationX;
        private float rotationY;

        private void Update()
        {
            // Capture user input for movement
            float moveHorizontal = Input.GetAxis("Horizontal");
            float moveVertical = Input.GetAxis("Vertical");
            float moveUpDown = Input.GetAxis("UpDown");

            // Calculate the movement vector
            Vector3 movement = new Vector3(moveHorizontal, moveUpDown, moveVertical) * movementSpeed * Time.deltaTime;

            // Apply the movement to the camera's position
            transform.Translate(movement);

            // Capture user input for rotation
            float rotateHorizontal = Input.GetAxis("Mouse X");
            float rotateVertical = Input.GetAxis("Mouse Y");

            // Calculate the rotation angles
            rotationX += rotateVertical * rotationSpeed * Time.deltaTime;
            rotationY += rotateHorizontal * rotationSpeed * Time.deltaTime;

            // Apply the rotation to the camera's Euler angles
            transform.rotation = Quaternion.Euler(-rotationX, rotationY, 0f);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/FlyingCamera.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/FrameworkSync/FrameworkSyncerWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 66a5f7e760014d5b8e012eecca9be048
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections;
using System.IO;
using System.Threading.Tasks;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Utilities.Helpers;
using Unity.EditorCoroutines.Editor;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.FrameworkSync
{
    /// <summary>
    /// Window for syncing the framework version branch
    /// </summary>
    public class FrameworkSyncerWindow : EditorWindow
    {
        private enum State
        {
            Initializing = 0,
            Updating,
            UserActions,
        }

        // Session key consts
        private const string SESSION_INITIALIZED_KEY = "FRAMEWORK_SYNCER_INIT_KEY";
        private const string SESSION_PACKAGE_UPDATED_KEY = "FRAMEWORK_SYNCER_PACKAGE_UPDATED_KEY";

        // Package strings consts
        private const string PACKAGE_NAME = "com_ldx_framework";
        private const string PACKAGE_LOCAL_PATH = "Modules/LdxFramework";
        private const string FRAMEWORK_VERSION_PROJECT_FILENAME = "framework.version";
        
        // HEAD check consts
        private const string KEY_LAST_FRAMEWORK_BRANCH = "FS_LAST_FRAMEWORK_BRANCH";
        private const int SLEEP_SECONDS_TO_CHECK_SUBMODULE_BRANCH = 5;
        private const string HEAD = "HEAD";
        
        // Window size consts
        private const float MIN_W = 600f;
        private const float MIN_H = 600f;

        private static double branchCheckTimer = 0.0f;
        private static double lastEditorTime;
        private static string recordedFrameworkBranch;
        private static bool checkingFrameworkBranch;
        
        private static char Separator => Path.DirectorySeparatorChar;
        private static string PackageLocalPath => PACKAGE_LOCAL_PATH.Replace('/', Separator);

        private static string PackageFullPath => (Application.dataPath.Replace($"/Assets", $"/") + PackageLocalPath)
            .Replace('\\', Separator).Replace('/', Separator);

        private string ProjectRootFullPath => Application.dataPath.Replace($"/Assets", $"")
            .Replace('\\', Separator).Replace('/', Separator);
        private State CurrentState { get; set; } = State.Initializing;

        private string Errors { get; set; } = "";
        private string CurrentPackageVersion { get; set; } = "";
        private string CurrentProjectFrameworkVersion { get; set; } = "";
        private string CurrentPackageBranch { get; set; } = "";
        private UserActionsSectionsDrawer UserActionsSectionsDrawer { get; } = new UserActionsSectionsDrawer();
        private bool WasPackageUpdated => SessionState.GetBool(SESSION_PACKAGE_UPDATED_KEY, false);
        private bool ProjectHasFrameworkVersion => !String.IsNullOrEmpty(CurrentProjectFrameworkVersion);

        // This is called when the editor is initializing
        [InitializeOnLoadMethod]
        private static void InitializeOnLoadEditor()
        {
            checkingFrameworkBranch = false;
            lastEditorTime = EditorApplication.timeSinceStartup;
            recordedFrameworkBranch = EditorPrefs.GetString(KEY_LAST_FRAMEWORK_BRANCH, null);
            EditorApplication.update -= EditorUpdate;
            EditorApplication.update += EditorUpdate;
            // To make sure this runs automatically only once per session
            if (SessionState.GetBool(SESSION_INITIALIZED_KEY, false))
            {
                return;
            }

            SessionState.SetBool(SESSION_INITIALIZED_KEY, true);

            // Wait until editor is fully loaded, open the window
            EditorCoroutineUtility.StartCoroutineOwnerless(waitUntilEditorIsLoadedThenOpenWindowAsync());

            IEnumerator waitUntilEditorIsLoadedThenOpenWindowAsync()
            {
                yield return LdxEditorHelper.WaitUntilEditorIsLoadedAsync();
                OpenWindow();
            }
        }

        private static void EditorUpdate()
        {
            double now = EditorApplication.timeSinceStartup;
            branchCheckTimer += Mathf.Abs((float)(now - lastEditorTime));

            if (branchCheckTimer >= SLEEP_SECONDS_TO_CHECK_SUBMODULE_BRANCH)
            {
                branchCheckTimer = 0;
                FrameworkHeadCheckAsync().Forget();
            }
            
            lastEditorTime = now;
        }
        
        private static async UniTaskVoid FrameworkHeadCheckAsync()
        {
            // To ensure it doesn't happen twice in a row
            if (checkingFrameworkBranch)
            {
                return;
            }
            checkingFrameworkBranch = true;
            await checkAsync();
            checkingFrameworkBranch = false;
            
            async UniTask checkAsync()
            {
                string branchName = GitHelper.GetBranchName(PackageFullPath);
                if (branchName.Contains(HEAD))
                {
                    if (recordedFrameworkBranch != null)
                    {
                        await SyncHelper.CheckoutSubmoduleBranchAsync(PackageFullPath, recordedFrameworkBranch);
                    }
                    return;
                }

                if (branchName == recordedFrameworkBranch)
                {
                    return;
                }
                recordedFrameworkBranch = branchName;
                EditorPrefs.SetString(KEY_LAST_FRAMEWORK_BRANCH, branchName);
            }
        }

        [MenuItem("LogicalDox/Framework Syncer", priority = 0)]
        private static FrameworkSyncerWindow OpenWindow()
        {
            // Get existing open window or if none, make a new one:
            FrameworkSyncerWindow window =
                (FrameworkSyncerWindow)GetWindow(typeof(FrameworkSyncerWindow), false, "Framework Syncer");
            window.Show();
            return window;
        }

        private void OnEnable()
        {
            UserActionsSectionsDrawer.OnCheckoutVersionBranchPressed -= HandleCheckoutVersionBranchPressed;
            UserActionsSectionsDrawer.OnCheckoutVersionBranchPressed += HandleCheckoutVersionBranchPressed;
            UserActionsSectionsDrawer.OnSaveFrameworkVersionPressed -= HandleSaveFrameworkVersionPressed;
            UserActionsSectionsDrawer.OnSaveFrameworkVersionPressed += HandleSaveFrameworkVersionPressed;
            UserActionsSectionsDrawer.OnChangePackageVersionPressed -= HandleChangePackageVersionPressed;
            UserActionsSectionsDrawer.OnChangePackageVersionPressed += HandleChangePackageVersionPressed;
        }

        private async void InitializeAsync()
        {
            // Set window's min size
            minSize = new Vector2(MIN_W, MIN_H);
            // Runs if package wasn't updated yet
            if (!WasPackageUpdated)
            {
                // Set status to updating
                CurrentState = State.Updating;
                // Give it a second to draw the label 
                await Task.Delay(1000);
                // Pull latest changes in current branch
                ProcessResult result = await SyncHelper.PullLatestSubmoduleAsync(PackageFullPath);
                if (result.ExitCode != 0)
                {
                    Errors = result.Errors;
                    return;
                }

                // Mark package as updated
                SessionState.SetBool(SESSION_PACKAGE_UPDATED_KEY, true);
            }

            // Fetch package version and branch name, update them
            UpdatePackageAndBranchInfoAsync().Forget();
            // Display options state
            CurrentState = State.UserActions;
        }

        private void OnFocus()
        {
            UpdatePackageAndBranchInfoAsync().Forget();
        }

        private void OnGUI()
        {
            DrawHeader();
            switch (CurrentState)
            {
                case State.Initializing:
                    // We need this to suppress the error that results from us not drawing anything
                    EditorGUILayout.LabelField("Initializing..");
                    InitializeAsync();
                    break;
                case State.Updating:
                    DrawUpdatingState();
                    break;
                case State.UserActions:
                    DrawUserActionsState();
                    break;
            }

            DrawFooter();
        }

        private void DrawHeader()
        {
            LdxEditorHelper.DrawTitle("Framework Syncer");
            LdxEditorHelper.DrawSmallText("For syncing the framework's version branch with the project's");
            LdxEditorHelper.DrawHorizontalSeparator();
        }

        private void DrawFooter()
        {
            LdxEditorHelper.DrawHorizontalSeparator();
            //Draw errors in the footer if any
            if (String.IsNullOrEmpty(Errors))
            {
                return;
            }

            EditorGUILayout.LabelField(Errors, SyncHelper.RedTextStyle);
        }

        private void DrawUpdatingState()
        {
            EditorGUILayout.LabelField("Updating package...");
        }

        private void DrawUserActionsState()
        {
            if (ProjectHasFrameworkVersion)
            {
                UserActionsSectionsDrawer.DrawBranchSyncingSection(CurrentPackageBranch, CurrentProjectFrameworkVersion);
            }
            UserActionsSectionsDrawer.DrawFrameworkVersionUpdaterSection(CurrentProjectFrameworkVersion, CurrentPackageVersion);
        }

        private async UniTaskVoid SyncBranchThenUpdateInfoAsync()
        {
            UserActionsSectionsDrawer.CanCheckoutVersionBranch = false;
            await UpdatePackageAndBranchInfoAsync();
            await SyncHelper.CheckoutSubmoduleBranchAsync(PackageFullPath, $"ver/{CurrentPackageVersion}");
            await UpdatePackageAndBranchInfoAsync();
            UserActionsSectionsDrawer.CanCheckoutVersionBranch = true;
        }

        private void SaveFrameworkVersionThenUpdateInfo()
        {
            UserActionsSectionsDrawer.CanSaveFrameworkVersionPressed = false;
            SyncHelper.WriteFrameworkVersionToFileInProject(ProjectRootFullPath, FRAMEWORK_VERSION_PROJECT_FILENAME, GitHelper.GetBranchName(PackageFullPath).Replace("ver/",""));
            UpdatePackageAndBranchInfoAsync().Forget();
            UserActionsSectionsDrawer.CanSaveFrameworkVersionPressed = true;
        }

        private void HandleChangePackageVersionPressed()
        {
            updateAsync().Forget();
            
            async UniTaskVoid updateAsync()
            {
                await PackagesHelper.UpdatePackageVersionAsync(PackageFullPath, CurrentProjectFrameworkVersion);
                await UpdatePackageAndBranchInfoAsync();
            }
        }
        
        private void HandleSaveFrameworkVersionPressed()
        {
            SaveFrameworkVersionThenUpdateInfo();
        }

        private void HandleCheckoutVersionBranchPressed()
        {
            SyncBranchThenUpdateInfoAsync().Forget();
        }

        private async UniTask UpdatePackageAndBranchInfoAsync()
        {
            CurrentPackageVersion = await PackagesHelper.GetPackageVersionAsync(PACKAGE_NAME);
            CurrentProjectFrameworkVersion = PackagesHelper.GetFrameworkVersionRecordedInProject(ProjectRootFullPath,
                    FRAMEWORK_VERSION_PROJECT_FILENAME);
            CurrentPackageBranch = GitHelper.GetBranchName(PackageFullPath);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/FrameworkSync/FrameworkSyncerWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/FrameworkSync/SyncHelper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 65038df05efc4a6f8144e5382b63eece
# ASMDEF: ldx.framework.editor.dll
# ---
using System.IO;
using System.Threading.Tasks;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.FrameworkSync
{
    /// <summary>
    /// Helper for framework sync
    /// Just contains operational code to make the framework sync window easier to read
    /// </summary>
    public static class SyncHelper
    {
        private static GUIStyle greenTextStyle;
        private static GUIStyle redTextStyle;

        public static GUIStyle GreenTextStyle
        {
            get
            {
                if (greenTextStyle != null)
                {
                    return greenTextStyle;
                }
                greenTextStyle = new GUIStyle(EditorStyles.label)
                {
                    normal =
                    {
                        textColor = new Color(0, 0.7f, 0.0f)
                    }
                };
                greenTextStyle.fontStyle = FontStyle.Bold;
                return greenTextStyle;
            }
        }

        public static GUIStyle RedTextStyle
        {
            get
            {
                if (redTextStyle != null)
                {
                    return redTextStyle;
                }
                redTextStyle = new GUIStyle(EditorStyles.label)
                {
                    normal =
                    {
                        textColor = new Color(0.9f, 0.1f, 0.2f),
                    }
                };
                redTextStyle.fontStyle = FontStyle.Bold;
                return redTextStyle;
            }
        }
        
        /// <summary>
        /// Async method for pulling latest commit in the submodule
        /// </summary>
        public static async Task<ProcessResult> PullLatestSubmoduleAsync(string submodulePath)
        {
            return await GitHelper.RunAsync($"pull", submodulePath);
        }

        /// <summary>
        /// Async method for checking out submodule branch
        /// </summary>
        public static async UniTask CheckoutSubmoduleBranchAsync(string submodulePath, string branch)
        {
            await GitHelper.RunAsync($"git stash", submodulePath);
            await GitHelper.RunAsync($"checkout -f {branch}", submodulePath);
            await GitHelper.RunAsync($"git stash pop", submodulePath);
        }

        /// <summary>
        /// Writes the current loaded package version as the associated framework version in the project
        /// </summary>
        public static void WriteFrameworkVersionToFileInProject(string rootPath, string filename, string version)
        {
            File.WriteAllText (@$"{rootPath}{Path.DirectorySeparatorChar}{filename}", version);
        }

        /// <summary>
        /// Given a branch name and a version number, checks if the current branch is at the base version
        /// </summary>
        public static bool DoesBranchAndVersionMatch(string branch, string version)
        {
            return branch.Contains(version) && branch.Contains("ver");
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/FrameworkSync/SyncHelper.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/FrameworkSync/UserActionsSectionsDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: ba9768fcfc1d4bcfb8d300ab3483d44c
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.FrameworkSync
{
    /// <summary>
    /// Here to contain the logic for drawing each user action section, to allow for extensibility
    /// without complicated architecture without making the framework syncer class messy 
    /// </summary>
    public class UserActionsSectionsDrawer
    {
        public event Action OnCheckoutVersionBranchPressed;
        public event Action OnSaveFrameworkVersionPressed;
        public event Action OnChangePackageVersionPressed;

        public bool CanCheckoutVersionBranch { get; set; } = true;
        public bool CanSaveFrameworkVersionPressed { get; set; } = true;
        
        /// <summary>
        /// Draws the section where the user is prompted to sync to the version branch if they'd like
        /// </summary>
        public void DrawBranchSyncingSection(string currentPackageBranch, string currentFrameworkVersion)
        {
             // Does the version match the branch name?
            bool versionMatchesBranch =
                SyncHelper.DoesBranchAndVersionMatch(currentPackageBranch, currentFrameworkVersion);
            // Vertical scope
            using (new EditorGUILayout.VerticalScope())
            {
                // Centre the title
                using (new EditorGUILayout.HorizontalScope())
                {
                    GUILayout.FlexibleSpace();
                    LdxEditorHelper.DrawBoldLabel("Branch Syncing");
                    GUILayout.FlexibleSpace();
                }
                // Display package version
                using (new EditorGUILayout.HorizontalScope())
                {
                    EditorGUILayout.LabelField("Project framework version: ");
                    EditorGUILayout.LabelField(currentFrameworkVersion, SyncHelper.GreenTextStyle);
                    GUILayout.FlexibleSpace();
                }

                // Display branch name
                using (new EditorGUILayout.HorizontalScope())
                {
                    EditorGUILayout.LabelField("Current branch: ");
                    EditorGUILayout.LabelField(currentPackageBranch, versionMatchesBranch? SyncHelper.GreenTextStyle : SyncHelper.RedTextStyle);
                    GUILayout.FlexibleSpace();
                }

                // In case we're not on the base version version
                if (!versionMatchesBranch)
                {
                    EditorGUILayout.Space(10);
                    EditorGUILayout.LabelField($"You're currently on a different branch than the main package version branch.", SyncHelper.RedTextStyle);
                    EditorGUILayout.LabelField($"Would you like to try to sync the package by checking out branch ver/{currentFrameworkVersion}?", SyncHelper.RedTextStyle);
                    EditorGUILayout.Space(10);
                    LdxEditorHelper.DrawHelpBox("Note: If you're currently in a feature branch that was branched off this version, you can disregard this message.");
                    using (new EditorGUILayout.HorizontalScope())
                    {
                        // When clicked, checks out the version branch and updates the values
                        GUI.enabled = CanCheckoutVersionBranch;
                        if (GUILayout.Button($"Checkout branch: ver/{currentFrameworkVersion}"))
                        {
                            OnCheckoutVersionBranchPressed?.Invoke();
                        }
                        GUI.enabled = true;
                        GUILayout.FlexibleSpace();
                    }
                }
                LdxEditorHelper.DrawHorizontalSeparator();
            }
        }

        /// <summary>
        /// Draws the section that prompts the user to associate the current loaded
        /// package version with the project
        /// </summary>
        public void DrawFrameworkVersionUpdaterSection(string currentSavedFrameworkVersion, string currentUsedPackageVersion)
        {
            bool hasSavedVersion = !String.IsNullOrEmpty(currentSavedFrameworkVersion);
            using (new EditorGUILayout.VerticalScope())
            {
                using (new EditorGUILayout.HorizontalScope())
                {
                    GUILayout.FlexibleSpace();
                    LdxEditorHelper.DrawBoldLabel("Framework Version Updater");
                    GUILayout.FlexibleSpace();
                }
                
                if (hasSavedVersion)
                {
                    using (new EditorGUILayout.HorizontalScope())
                    {
                        EditorGUILayout.LabelField("Saved framework version in project: ");
                        EditorGUILayout.LabelField(currentSavedFrameworkVersion, SyncHelper.GreenTextStyle);
                        GUILayout.FlexibleSpace();
                    }
                }
                else
                {
                    EditorGUILayout.LabelField("This branch of the project doesn't have an associated framework version", SyncHelper.RedTextStyle);
                }
                
                // Display package version
                using (new EditorGUILayout.HorizontalScope())
                {
                    EditorGUILayout.LabelField("package.json version: ");
                    EditorGUILayout.LabelField(currentUsedPackageVersion, SyncHelper.GreenTextStyle);
                    if (currentSavedFrameworkVersion != currentUsedPackageVersion && currentSavedFrameworkVersion.Length > 1)
                    {
                        if (GUILayout.Button($"(Change to {currentSavedFrameworkVersion})"))
                        {
                            OnChangePackageVersionPressed?.Invoke();
                        }
                    }
                    GUILayout.FlexibleSpace();
                }

                if (currentSavedFrameworkVersion == currentUsedPackageVersion)
                {
                    return;
                }
                
                using (new EditorGUILayout.HorizontalScope())
                {
                    // When clicked, saves the loaded framework version from the package to a file in the project
                    GUI.enabled = CanSaveFrameworkVersionPressed;
                    if (GUILayout.Button($"Save framework version {currentUsedPackageVersion} in project"))
                    {
                        OnSaveFrameworkVersionPressed?.Invoke();
                    }
                    GUI.enabled = true;
                    GUILayout.FlexibleSpace();
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/FrameworkSync/UserActionsSectionsDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/DocumentationHelper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d5c1e718dc724c028e6930dc9064ac75
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.IO;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Utilities.Attributes;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Helpers
{
    public static class DocumentationHelper
    {
        private const string DOCUMENTATION_PATH = "Modules/LdxFramework/Editor/Documentation/EventData";
        private const string DOCUMENTATION_MAIN_NAME = "ObjectiveEventDataDocumentation";
        
        public static bool TryGetClassDocumentation(Type type, out string documentationMd)
        {
            documentationMd = string.Empty;

            // Check if the class has the Documentation attribute
            bool isEventData = type.IsSubclassOf(typeof(ObjectiveEventData));
            if (!isEventData)
            {
                return false;
            }

            return TryGetDocumentationByName(type.Name, out documentationMd);
        }

        public static bool WriteDocumentation(string path, string content, out string error)
        {
            error = null;
            try
            {
                int fileNameStartIndex = path.LastIndexOfAny(new []{'\\', '/'});
                string directoryPath = path.Substring(0, fileNameStartIndex);
                if (!Directory.Exists(directoryPath))
                {
                    Directory.CreateDirectory(directoryPath);
                }
                File.WriteAllText(path, content);
                return true;
            }
            catch (Exception ex)
            {
                error = $"Error writing file: {ex.Message}";
                return false;
            }
        }
        
        public static string GetMainDocumentation()
        {
            TryGetDocumentationByName(DOCUMENTATION_MAIN_NAME, out string documentation);
            return documentation;
        }

        public static string GetClassDocumentationPath<T>(T type)
        {
            string assetsPath = Application.dataPath;
            string rootPath = Directory.GetParent(assetsPath)?.FullName;
            string fullDocumentationPath = Path.Combine(rootPath, DOCUMENTATION_PATH);
            return Path.Combine(fullDocumentationPath, $"{type.GetType().Name}.md");
        }
        
        public static bool TryGetDocumentationByName(string documentationName, out string documentation)
        {
            documentation = string.Empty;
            
            string assetsPath = Application.dataPath;
            string rootPath = Directory.GetParent(assetsPath)?.FullName;
            string fullDocumentationPath = Path.Combine(rootPath, DOCUMENTATION_PATH);
            // Construct the path to the documentation file
            string filePath = Path.Combine(fullDocumentationPath, $"{documentationName}.md");

            // Check if the documentation file exists
            if (File.Exists(filePath))
            {
                documentation = File.ReadAllText(filePath);
                return true;
            }

            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/DocumentationHelper.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/GitHelper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 8ab42e09853c428ca48cad57ef9664c6
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Cysharp.Threading.Tasks;
using UnityEditor;
using UnityEngine;
using Debug = System.Diagnostics.Debug;

namespace Ldx.Framework.Utilities.Helpers
{
    /// <summary>
    /// Handler for git exceptions
    /// </summary>
    public class GitException : InvalidOperationException
    {
        public GitException(int exitCode, string errors) : base(errors) =>
            this.ExitCode = exitCode;

        /// <summary>
        /// The exit code returned when running the Git command.
        /// </summary>
        public readonly int ExitCode;
    }
    
    /// <summary>
    /// Class that makes it easier to communicate with git
    /// </summary>
    public static class GitHelper
    {
        public enum QueryLocation
        {
            Project = 0,
            Framework
        }
        
        /// <summary>
        /// The currently active branch.
        /// </summary>
        public static string Branch => Run(@"rev-parse --abbrev-ref HEAD");

        /// <summary>
        /// Returns a listing of all uncommitted or untracked (added) files.
        /// </summary>
        public static string Status => Run(@"status --porcelain");

        public static string ProjectPath => Application.dataPath.Replace("/Assets", "");
        public static string FrameworkPath => Application.dataPath.Replace("Assets", "") + "Modules/LdxFramework";

        /// <summary>
        /// Returns true if the submodule currently has any uncommitted changes
        /// </summary>
        public static bool SubmoduleHasChanges()
        {
            string result = Run(@"submodule foreach git status --porcelain");
            return result.Split('\n').Length > 1;
        }

        public static bool VerifyRemoteBranchExists(string name, QueryLocation location)
        {
            string path = location == QueryLocation.Project ? ProjectPath : FrameworkPath;
            return Run($"ls-remote --heads origin {name}", path).Trim().Length > 0;
        }

        public static bool CheckHasUnpushedCommits(QueryLocation location)
        {
            string path = location == QueryLocation.Project ? ProjectPath : FrameworkPath;
            string branchName = GetBranchName(path);
            return Run($"log origin/{branchName}..HEAD", path).Trim().Length > 0;
        }
        
        /// <summary>
        /// Returns true if found .prefab, .unity, or .cs changes that are uncommited
        /// </summary>
        public static bool CheckUncommitedScenePrefabOrScriptsChanges(QueryLocation location)
        {
            string path = location == QueryLocation.Project ? ProjectPath : FrameworkPath;
            string command = "status --porcelain --untracked-files=all -- '*.unity' '*.prefab' '*.cs'";
            string output = Run(command, path);

            return !string.IsNullOrEmpty(output);
        }
        
        public static string GetProjectBranchName()
        {
            return GetBranchName(ProjectPath);
        }

        public static string GetFrameworkBranchName()
        {
            return GetBranchName(FrameworkPath);
        }
        
        /// <summary>
        /// Returns branch name
        /// </summary>
        public static string GetBranchName(string path)
        {
            return Run(@"rev-parse --abbrev-ref HEAD", path);
        }
        
        public static string GetRepoName()
        {
            string remoteResult = Run("remote -v");
            
            string pattern = @"/([^/]+)\.git";
            Match match = Regex.Match(remoteResult, pattern);

            if (match.Success)
            {
                return match.Groups[1].Value;
            }

            return "";
        }

        /// <summary>
        /// Returns list of local changes
        /// </summary>
        public static string[] GetListOfChanges(string path)
        {
            return Run(@"status --porcelain", path).Split('\n');
        }
        
        public static void CheckoutBranch(string path, string branch)
        {
            Run("fetch --prune --all --verbose", path);
            Run($"checkout -f {branch}", path);
            Run($"pull --rebase=false origin {branch} --prune --verbose", path);
        }

        public static string GetGitUserName()
        {
            return GetGitUserName(Application.dataPath.Replace("/Assets", ""));
        }
        
        public static string GetGitUserName(string path)
        {
            return Run("config user.name", path);
        }

        /// <summary>
        /// Runs git.exe with the specified arguments and returns the output
        /// </summary>
        public static string Run(string arguments, string path = null)
        {
            using (Process process = new Process())
            {
                int exitCode = process.Run(@"git", arguments, path ?? Application.dataPath.Replace("/Assets", ""),
                    out string output, out string errors);
                if (exitCode == 0)
                {
                    return output;
                }
                throw new GitException(exitCode, errors);
            }
        }
        
        /// <summary>
        /// Async version of the Run() method
        /// </summary>
        public static async Task<ProcessResult> RunAsync(string arguments, string path = null)
        {
            return await ProcessHelper.RunProcessAsync(@"git", arguments,
                path ?? Application.dataPath.Replace("/Assets", ""));
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/GitHelper.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/LdxEditorHelper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 0488f04533ef461b8f40cade9641982c
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Helpers
{
    /// <summary>
    /// Contains generic editor helpers for a wide variety of cases
    /// </summary>
    public static class LdxEditorHelper
    {
        private static GUIStyle redLabelStyle;

        public static GUIStyle RedLabelStyle
        {
            get
            {
                if (redLabelStyle == null)
                {
                    redLabelStyle = new GUIStyle(EditorStyles.label);
                    redLabelStyle.normal.textColor = Color.red;
                }
                return redLabelStyle;
            }
        }
        
        private static GUIStyle greenLabelStyle;

        public static GUIStyle GreenLabelStyle
        {
            get
            {
                if (greenLabelStyle == null)
                {
                    greenLabelStyle = new GUIStyle(EditorStyles.label);
                    greenLabelStyle.normal.textColor = new Color(0.1f,0.7f,0.1f);
                }
                return greenLabelStyle;
            }
        }
        
        /// <summary>
        /// A coroutine that returns when the editor is loaded
        /// </summary>
        public static IEnumerator WaitUntilEditorIsLoadedAsync()
        {
            bool loaded = false;
            while (!loaded)
            {
                yield return new WaitForSeconds(1);
                // This seems like a weird way to do it, but it's one of the only reliable ones
                if (Object.FindAnyObjectByType<GameObject>() == null)
                {
                    continue;
                }
                loaded = true;
            }
        }

        /// <summary>
        /// Draws an editor separator
        /// </summary>
        public static void DrawHorizontalSeparator()
        {
            EditorGUILayout.LabelField("", GUI.skin.horizontalSlider);
        }

        /// <summary>
        /// Draws a bold label
        /// </summary>
        public static void DrawBoldLabel(string text)
        {
            EditorGUILayout.LabelField(text, EditorStyles.boldLabel);
        }
        
        /// <summary>
        /// Draws a title
        /// </summary>
        public static void DrawTitle(string text)
        {
            EditorGUILayout.LabelField(text, EditorStyles.whiteLargeLabel);
        }

        /// <summary>
        /// Draws small text
        /// </summary>
        public static void DrawSmallText(string text)
        {
            EditorGUILayout.LabelField(text, EditorStyles.miniLabel);
        }

        /// <summary>
        /// Draws a help box
        /// </summary>
        public static void DrawHelpBox(string text)
        {
            EditorGUILayout.LabelField(text, EditorStyles.helpBox);
        }
        
        /// <summary>
        /// Creates a texture with an outline for the editor
        /// </summary>
        /// <param name="outlineColor">The outline color to use</param>
        /// <param name="fillColor">The fill color to use, default is null for transparent</param>
        /// <param name="width">Texture width</param>
        /// <param name="height">Texture Height</param>
        public static Texture2D CreateOutlineTexture(Color outlineColor, 
            Color? fillColor = null,
            int width = 64,
            int height = 32)
        {

            if (fillColor == null)
            {
                fillColor = Color.clear;
            }
            
            Texture2D tex = new Texture2D(width, height);

            Color[] pixels = new Color[width * height];
            for (int i = 0; i < pixels.Length; i++)
            {
                pixels[i] = fillColor.Value;
            }

            for (int x = 0; x < width; x++)
            {
                pixels[x] = outlineColor;
                pixels[x + (height - 1) * width] = outlineColor;
            }
            for (int y = 0; y < height; y++)
            {
                pixels[y * width] = outlineColor;
                pixels[(y + 1) * width - 1] = outlineColor;
            }

            tex.SetPixels(pixels);
            tex.Apply();
            return tex;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/LdxEditorHelper.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/ModalEditorWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c894e726e135453185a173e1da4b06ab
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Helpers
{
    /// <summary>
    /// A small generic modal editor window for when you don't
    /// want to implement a whole class
    /// </summary>
    public class ModalEditorWindow : EditorWindow
    {
        public event Action OnModalLostFocus;
        public event Action OnModalClosed;
        
        private Action DrawCallback;

        public static ModalEditorWindow ShowModal(string title, Action drawCallback)
        {
            var modal = GetWindow<ModalEditorWindow>();
            modal.DrawCallback = drawCallback;
            modal.titleContent = new GUIContent(title);
            modal.Show();
            return modal;
        }

        public void SetSize(int w, int h)
        {
            minSize = new Vector2(w, h);
            maxSize = new Vector2(w, h);
        }

        public void SetMinSize(int? w = null, int? h = null)
        {
            int width = w ?? (int)minSize.x;
            int height = h ?? (int)minSize.y;
            minSize = new Vector2(width, height);
        }
        
        public void SetMaxSize(int? w = null, int? h = null)
        {
            int width = w ?? (int)maxSize.x;
            int height = h ?? (int)maxSize.y;
            maxSize = new Vector2(width, height);
        }

        private void OnLostFocus()
        {
            OnModalLostFocus?.Invoke();
        }

        private void OnDestroy()
        {
            OnModalClosed?.Invoke();
            DrawCallback = null;
        }

        private void OnGUI()
        {
            DrawCallback?.Invoke();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/ModalEditorWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/PackagesHelper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 675985f81aaf4e2980e027d26e9bd07a
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Cysharp.Threading.Tasks;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using UnityEditor;
using UnityEditor.PackageManager;
using UnityEditor.PackageManager.Requests;
using UnityEngine;
using PackageInfo = UnityEditor.PackageManager.PackageInfo;

namespace Ldx.Framework.Utilities.Helpers
{
    /// <summary>
    /// Utility class for package related operations
    /// </summary>
    public static class PackagesHelper
    {
        /// <summary>
        /// Given a package name, returns its current version
        /// </summary>
        public static async UniTask<string> GetPackageVersionAsync(string name)
        {
            ListRequest listRequest = Client.List();
            await UniTask.WaitUntil(() => listRequest.IsCompleted);
            if (listRequest.Status != StatusCode.Success)
            {
                return "";
            }

            string result = listRequest.Result.FirstOrDefault(p => p.name == name)?.version;

            if (!String.IsNullOrEmpty(result))
            {
                if (result.EndsWith(".0"))
                {
                    result = result.Substring(0, result.Length - 2);
                }
            }
            return result;
        }
        
        public static async UniTask UpdatePackageVersionAsync(string packagePath, string newVersion)
        {
            string[] versionSegments = newVersion.Split('.');
            if (versionSegments.Length < 3)
            {
                newVersion += ".0";
            }
            string filePath = packagePath + Path.DirectorySeparatorChar + "package.json";
            string jsonContent = await File.ReadAllTextAsync(filePath);
            JObject packageJson = JObject.Parse(jsonContent);
            packageJson["version"] = newVersion;
            string modifiedJsonContent = packageJson.ToString(Formatting.Indented);
            await File.WriteAllTextAsync(filePath, modifiedJsonContent);
        }

        public static string GetFrameworkVersionRecordedInProject(string rootPath, string filename)
        {
            string filePath = $@"{rootPath}{Path.DirectorySeparatorChar}{filename}";
            if (!File.Exists(filePath))
            {
                return "";
            }
            return File.ReadAllText(filePath).Trim();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/PackagesHelper.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/ProcessHelper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 0adc788f2a2c4579a54d2fc6d164d6b6
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Diagnostics;
using System.Text;
using System.Threading.Tasks;

namespace Ldx.Framework.Utilities.Helpers
{
    /// <summary>
    /// Result of an async process
    /// </summary>
    public class ProcessResult
    {
        public string Output { get; set; }
        public string Errors { get; set; }
        public int ExitCode { get; set; }
    }

    /// <summary>
    /// Utility class for 'Process' related operations
    /// </summary>
    public static class ProcessHelper
    {
        /// <summary>
        /// Runs the specified process and waits for it to exit. Its output and errors are
        /// returned as well as the exit code from the process.
        /// </summary>
        public static int Run(this Process process, string application,
            string arguments, string workingDirectory, out string output,
            out string errors)
        {
            process.StartInfo = new ProcessStartInfo
            {
                CreateNoWindow = true,
                UseShellExecute = false,
                RedirectStandardError = true,
                RedirectStandardOutput = true,
                FileName = application,
                Arguments = arguments,
                WorkingDirectory = workingDirectory
            };

            // Use the following event to read both output and errors output.
            StringBuilder outputBuilder = new StringBuilder();
            StringBuilder errorsBuilder = new StringBuilder();
            process.OutputDataReceived += (_, args) => outputBuilder.AppendLine(args.Data);
            process.ErrorDataReceived += (_, args) => errorsBuilder.AppendLine(args.Data);

            // Start the process and wait for it to exit.
            process.Start();
            process.BeginOutputReadLine();
            process.BeginErrorReadLine();
            process.WaitForExit();

            output = outputBuilder.ToString().TrimEnd();
            errors = errorsBuilder.ToString().TrimEnd();
            return process.ExitCode;
        }

        /// <summary>
        /// Runs an async process taking raw parameters
        /// </summary>
        public static async Task<ProcessResult> RunProcessAsync(string application, string args,
            string workingDirectory)
        {
            using Process process = new Process
            {
                StartInfo =
                {
                    FileName = application, Arguments = args,
                    UseShellExecute = false, CreateNoWindow = true,
                    RedirectStandardOutput = true, RedirectStandardError = true,
                    WorkingDirectory = workingDirectory
                },
                EnableRaisingEvents = true
            };
            return await RunProcessAsync(process).ConfigureAwait(false);
        }

        private static Task<ProcessResult> RunProcessAsync(Process process)
        {
            TaskCompletionSource<ProcessResult> tcs = new TaskCompletionSource<ProcessResult>();
            ProcessResult result = new ProcessResult();
            tcs.SetResult(result);
            process.Exited += (s, ea) => result.ExitCode = process.ExitCode;
            process.OutputDataReceived += (s, ea) => result.Output = ea.Data;
            process.ErrorDataReceived += (s, ea) =>
            {
                result.Errors = ea.Data;
                if (ea.Data != null)
                {
                    UnityEngine.Debug.LogError(result.Errors);
                }
            };

            bool started = process.Start();
            if (!started)
            {
                //you may allow for the process to be re-used (started = false) 
                //but I'm not sure about the guarantees of the Exited event in such a case
                throw new InvalidOperationException("Could not start process: " + process);
            }

            process.BeginOutputReadLine();
            process.BeginErrorReadLine();

            return tcs.Task;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/ProcessHelper.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/ScenarioEditorHelper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c5d38fc3470d4d52b872e8180d3171ef
# ASMDEF: ldx.framework.editor.dll
# ---
using Ldx.Framework.Systems.ScenarioManagement;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Helpers
{
    /// <summary>
    /// Helper for unified methods of accessing scenario data and scenario related
    /// references
    /// </summary>
    public static class ScenarioEditorHelper
    {
        /// <summary>
        /// Gets scenario instance from the scene
        /// </summary>
        public static BaseScenario GetScenarioInstance()
        {
            BaseScenario scenarioInstance = Object.FindAnyObjectByType<BaseScenario>();
            return scenarioInstance;
        }

        /// <summary>
        /// Gets scenario data by looking up all scenario data with the scenario scene
        /// assigned
        /// </summary>
        /// <param name="scenarioInstance">Optional scenario instance to minimize lookup overhead</param>
        public static ScenarioData GetScenarioData(BaseScenario scenarioInstance = null)
        {
            if (scenarioInstance == null)
            {
                scenarioInstance = GetScenarioInstance();
                if (scenarioInstance == null)
                {
                    return null;
                }
            }

            string sceneName = scenarioInstance.gameObject.scene.name;
            
            string[] guids = AssetDatabase.FindAssets("t:ScenarioData");

            foreach (string guid in guids)
            {
                string assetPath = AssetDatabase.GUIDToAssetPath(guid);

                ScenarioData scenarioData = AssetDatabase.LoadAssetAtPath<ScenarioData>(assetPath);

                if (scenarioData != null)
                {
                    if (scenarioData.SceneReference != null && scenarioData.SceneReference.GetSceneName() == sceneName)
                    {
                        return scenarioData;
                    }
                }
            }

            return null;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/ScenarioEditorHelper.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/SystemExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 263f29d3a5074a18930233ef2b50bd44
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;

namespace Ldx.Framework.Utilities.Helpers
{
    public static class SystemExtensions
    {
        /// <summary>
        /// Copies string into clipboard
        /// </summary>
        public static void CopyToClipboard(this string str)
        {
            GUIUtility.systemCopyBuffer = str;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Helpers/SystemExtensions.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Hierarchy/HierarchyEditorFeatures.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 122ad2c154be43b8be7581ed6ca262d4
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Ldx.Framework.Utilities.Hierarchy
{
    /// <summary>
    /// Class for hierarchy editor features
    /// </summary>
    [InitializeOnLoad]
    public class HierarchyEditorFeatures
    {
        private const string KEY_HIERARCHY_COLORS_ENABLED_EDITOR = "HIERARCHY_COLORS_ENABLED_EDITOR";
        
        private static bool hierarchyColorsEnabled = true;
        private static bool showPreviousObjectHighlight;
        private static Vector2 offset = new(19, 0);
        private static Stack<Object> backwardNavStack = new();
        private static Stack<Object> forwardNavStack = new();
        // Used for highlighting
        private static Object[] lastTwoSelectedObjects = new Object[2]; 

        private static GUIStyle defaultTextStyle;

        private static GUIStyle DefaultTextStyle
        {
            get
            {
                if (defaultTextStyle == null)
                {
                    defaultTextStyle = new GUIStyle()
                    {
                        normal = new GUIStyleState() { textColor = Color.white }
                    };   
                }
                return defaultTextStyle;
            }
        }
        
        // Given that we have [InitializeOnLoad], this static constructor
        // will be called when Unity launches
        static HierarchyEditorFeatures()
        {
            // Option to enable/disable is stored in EditorPrefs
            hierarchyColorsEnabled = EditorPrefs.GetBool(KEY_HIERARCHY_COLORS_ENABLED_EDITOR, true);
            
            // Subscribe to hierarchy item drawing
            EditorApplication.hierarchyWindowItemOnGUI -= HandleHierarchyItemGUI;
            EditorApplication.hierarchyWindowItemOnGUI += HandleHierarchyItemGUI;

            // Editor update
            EditorApplication.update -= EditorUpdate;
            EditorApplication.update += EditorUpdate;
        }
        
        /// <summary>
        /// Modal window for displaying any hierarchy colors related settings
        /// </summary>
        [MenuItem("LogicalDox/Editor/Hierarchy Colors")]
        private static void ShowHierarchyColorsSettingsWindow()
        {
            // Just draw a modal window with a bool to enable/disable
            ModalEditorWindow modal = ModalEditorWindow.ShowModal("Hierarchy Colors", hierarchyColorsSettingsModalDrawCallback);
            modal.SetSize(200, 40);
            
            void hierarchyColorsSettingsModalDrawCallback()
            {
                LdxEditorHelper.DrawTitle("Hierarchy Colors");
                EditorGUI.BeginChangeCheck();
                hierarchyColorsEnabled = EditorGUILayout.Toggle("Enabled", hierarchyColorsEnabled);
                if (EditorGUI.EndChangeCheck())
                {
                    EditorPrefs.SetBool(KEY_HIERARCHY_COLORS_ENABLED_EDITOR, hierarchyColorsEnabled);   
                }
            }
        }

        /// <summary>
        /// Handler for the editor event that gets invoked when drawing hierarchy items
        /// </summary>
        private static void HandleHierarchyItemGUI(int instanceID, Rect selectionRect)
        {
            // We use this to check for keyboard shortcuts
            HandleGUIInput();
            TryDrawHierarchyColors(instanceID, selectionRect);
            HierarchyLockedAssetDrawer.TryDrawLockCheck(instanceID, selectionRect);
        }

        private static void TryDrawHierarchyColors(int instanceID, Rect selectionRect)
        {
            if (!hierarchyColorsEnabled)
            {
                return;
            }

            // Requires ReferenceBank in the scene
            if (!ReferenceBank.IsValid)
            {
                return;
            }

            // Get object from instanceID
            Object obj = EditorUtility.InstanceIDToObject(instanceID);
            if (obj == null || obj is not GameObject gameObject)
            {
                return;
            }

            // When conditions are fulfilled, highlight the previously selected object
            if (showPreviousObjectHighlight && obj == lastTwoSelectedObjects[1])
            {
                drawPreviousObjHighlight();
            }

            // HierarchyColor references are stored in the ReferenceBank
            Color? backgroundColor = ReferenceBank.Instance.GetHierarchyColorForObject(gameObject);
            // No color = no desired hierarchy color
            if (backgroundColor == null)
            {
                return;
            }

            // Drawing logic
            Rect offsetRect = new Rect(selectionRect.position + offset, selectionRect.size);
            Rect bgRect = new Rect(selectionRect.x + offset.x, selectionRect.y, selectionRect.width,
                selectionRect.height);

            Color color = backgroundColor.Value;
            color.a = HierarchyColorSettings.ColorAlpha;
            EditorGUI.DrawRect(bgRect, color);
            EditorGUI.LabelField(offsetRect, gameObject.name, DefaultTextStyle);
            EditorApplication.RepaintHierarchyWindow();

            void drawPreviousObjHighlight()
            {
                // This draws a highlight on the previously selected object if shift is held
                Color highlightColor = HierarchyColorSettings.PreviousSelectionColor;
                highlightColor.a = HierarchyColorSettings.PreviousSelectionAlpha;
                EditorGUI.DrawRect(selectionRect, highlightColor);
                EditorApplication.RepaintHierarchyWindow();
            }
        }

        private static void EditorUpdate()
        {
            Object selected = Selection.activeObject;
            if (selected == null)
            {
                return;
            }

            // Current object = last recorded object in the stack, return
            if (backwardNavStack.Count > 0 && backwardNavStack.Peek() == selected)
            {
                return;
            }

            // We have a new selection, remove all the "forward" navigation stack
            if (forwardNavStack.Count > 0)
            {
                forwardNavStack.Clear();
            }

            // Push the new objects in the array
            lastTwoSelectedObjects[1] = lastTwoSelectedObjects[0];
            lastTwoSelectedObjects[0] = selected;
            
            // *** Navigation is explained in a block before NavigateBackwards()
            // Add this object to the backward stack
            backwardNavStack.Push(selected);
            showPreviousObjectHighlight = false;
        }
        
        /*
         * [NAVIGATION]
         * When an object is selected, it's pushed to the backwards stack to keep the history
         * 
         * Backwards Navigation:
         * When you navigate backwards, the last object in the backward stack is popped,
         * it then gets pushed to the forward stack so we can use it to navigate forward if we decide so
         * The popped object is then selected
         *
         * Forward Navigation:
         * When you navigate forward, the last object in the forward stack is popped,
         * it then gets added to the backwards stack so we can use it to navigate backwards if we decide so
         * The popped object is then selected
         */
        private static void NavigateBackwards()
        {
            // Can't move backwards if there's no previous object
            if (backwardNavStack.Count < 2)
            {
                return;
            }
            Object popped = backwardNavStack.Pop();
            forwardNavStack.Push(popped);
            Selection.activeObject = backwardNavStack.Peek();
            lastTwoSelectedObjects[0] = null;
            lastTwoSelectedObjects[1] = null;
        }
        
        private static void NavigateForward()
        {
            if (forwardNavStack.Count < 1)
            {
                return;
            }
            Object popped = forwardNavStack.Pop();
            backwardNavStack.Push(popped);
            Selection.activeObject = backwardNavStack.Peek();
            lastTwoSelectedObjects[0] = null;
            lastTwoSelectedObjects[1] = null;
        }

        private static void HandleGUIInput()
        {
            Event e = Event.current;
            if (e == null)
            {
                return;
            }
            if (e.type == EventType.KeyDown)
            {
                if (e.keyCode == KeyCode.LeftShift || e.keyCode == KeyCode.RightShift)
                {
                    showPreviousObjectHighlight = true;
                }
                
                if (!e.shift)
                {
                    return;
                }

                if (e.keyCode == KeyCode.LeftArrow)
                {
                    NavigateBackwards();
                    e.Use();
                }
                else if(e.keyCode == KeyCode.RightArrow)
                {
                    NavigateForward();
                    e.Use();
                }
            }
            else if (e.type == EventType.KeyUp)
            {
                if (e.keyCode == KeyCode.LeftShift || e.keyCode == KeyCode.RightShift)
                {
                    showPreviousObjectHighlight = false;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Hierarchy/HierarchyEditorFeatures.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Hierarchy/HierarchyLockedAssetDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 5b237cf8cf2f47958ded4d12596e2e75
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Utilities.AssetsCheckout;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Ldx.Framework.Utilities.Hierarchy
{
    /// <summary>
    /// Drawer functionality for marking assets in the hierarchy as locked
    /// </summary>
    public static class HierarchyLockedAssetDrawer
    {
        private const string LOCKED_TEXT = "[Locked]";
        private const float SCENE_MARGIN = 25.0f;
        private const float PREFAB_MARGIN = 20.0f;
        
        private static HashSet<int> excludedInstanceIDsSet = new();
        private static Dictionary<int, float> validIDToMarginMap = new();

        private static GUIStyle lockedStyle;

        private static GUIStyle LockedStyle
        {
            get
            {
                if (lockedStyle == null)
                {
                    lockedStyle = new GUIStyle(EditorStyles.label);
                    lockedStyle.fontSize = 10;
                    lockedStyle.normal.textColor = LockedBGColor;
                    lockedStyle.fontStyle = FontStyle.Bold | FontStyle.Italic;
                }
                return lockedStyle;
            }
        }

        private static GUIStyle shadowStyle;
        
        private static GUIStyle ShadowStyle
        {
            get
            {
                if (shadowStyle == null)
                {
                    shadowStyle = new GUIStyle(LockedStyle);
                    shadowStyle.normal.textColor = Color.black.Modify(a: 0.3f);
                }
                return shadowStyle;
            }
        }

        private static Color LockedBGColor { get; } = new Color(1f, 0f, 0.088f, 0.68f);
        
        /// <summary>
        /// If conditions are met, will add a label indicating the asset in the hierarchy is locked 
        /// </summary>
        public static bool TryDrawLockCheck(int instanceID, Rect selectionRect)
        {
            // We have two containers, a hashset for excluded instance IDs that has been checked before 
            // since the latest change, so we can exit immediately the second time around we check them
            if (excludedInstanceIDsSet.Contains(instanceID))
            {
                return false;
            }

            // Then we have a dictionary that should give us the used margin if the asset was locked and registered
            // in it previously
            if (validIDToMarginMap.ContainsKey(instanceID))
            {
                DrawLocked(validIDToMarginMap[instanceID], selectionRect);
                return true;
            }

            // If it's something new, it gets checked here and added to the dictionary with the appropriate margin
            if (TryDrawScene(instanceID, selectionRect) || TryDrawPrefab(instanceID, selectionRect))
            {
                return true;
            }

            excludedInstanceIDsSet.Add(instanceID);

            return false;
        }

        // Tries to draw for a locked scene asset in the hierarchy
        private static bool TryDrawScene(int instanceID, Rect selectionRect)
        {

            for (int i = 0; i < SceneManager.sceneCount; i++)
            {
                Scene scene = SceneManager.GetSceneAt(i);
                if (scene.GetHashCode() == instanceID)
                {
                    string name = scene.name;
                    if (!AssetCheckoutCache.AssetNameToData.TryGetValue(name, out AssetCheckoutItem item))
                    {
                        return false;
                    }

                    if (item.GetStatus() == AssetCheckoutStatus.Unlocked)
                    {
                        return false;
                    }
                    float margin = SCENE_MARGIN;
                    Vector2 textSize = EditorStyles.boldLabel.CalcSize(new GUIContent(name));
                    margin += textSize.x;
                    DrawLocked(margin, selectionRect);
                    validIDToMarginMap.Add(instanceID, margin);
                    return true;
                }
            }
            
            return false;
        }

        // Tries to draw for a locked prefab asset in the hierarchy
        private static bool TryDrawPrefab(int instanceID, Rect selectionRect)
        {
            Object obj = EditorUtility.InstanceIDToObject(instanceID);
            if (obj == null)
            {
                return false;
            }

            if (PrefabUtility.GetPrefabInstanceStatus(obj) == PrefabInstanceStatus.NotAPrefab)
            {
                return false;
            }
            
            GameObject prefabAsset = PrefabUtility.GetCorrespondingObjectFromOriginalSource(obj) as GameObject;
            if (prefabAsset == null)
            {
                return false;
            }
            
            string name = prefabAsset.name;
            if (!AssetCheckoutCache.AssetNameToData.TryGetValue(prefabAsset.name, out AssetCheckoutItem item))
            {
                return false;
            }

            if (item.GetStatus() == AssetCheckoutStatus.Unlocked)
            {
                return false;
            }

            float margin = PREFAB_MARGIN;
            Vector2 textSize = EditorStyles.boldLabel.CalcSize(new GUIContent(name));
            margin += textSize.x;
            validIDToMarginMap.Add(instanceID, margin);
            DrawLocked(margin, selectionRect);
            return true;
        }

        private static void DrawLocked(float margin, Rect selectionRect)
        {
            selectionRect.x += margin;
            selectionRect.y += EditorStyles.label.fontSize - LockedStyle.fontSize - 1;
            Vector2 lockedSize = LockedStyle.CalcSize(new GUIContent(LOCKED_TEXT));
            selectionRect.width = lockedSize.x + 3;
            selectionRect.height = lockedSize.y;
            // Drop shadow by offsetting the rect
            Rect shadowRect = new Rect(selectionRect);
            shadowRect.x++;
            shadowRect.y++;
            EditorGUI.LabelField(shadowRect, LOCKED_TEXT, ShadowStyle);
            EditorGUI.LabelField(selectionRect, LOCKED_TEXT, LockedStyle);
            
        }

        public static void Refresh()
        {
            excludedInstanceIDsSet.Clear();
            validIDToMarginMap.Clear();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Hierarchy/HierarchyLockedAssetDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/LdxEditorUtilities.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 29691806c1ec12749bc8ec76f2b12e0c
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine.SceneManagement;

namespace Ldx.Framework.Utilities.Editor
{
    public static class LdxEditorUtilities
    {
        public static void DrawDefaultLine()
        {
            DrawLine(new Color(0.37f, 0.37f, 0.37f), thickness: 1, padding: 10);
        }

        private static void DrawLine(Color color, int thickness, int padding)
        {
            Rect rect = EditorGUILayout.GetControlRect(GUILayout.Height(padding + thickness));
            rect.height = thickness;
            rect.y += (float)padding / 2;
            rect.x -= 2;
            rect.width += 6;
            EditorGUI.DrawRect(rect, color);
        }

        /// <summary>
        /// Asks user to save unsaved changes if applicable
        /// </summary>
        /// <returns>True if no changes, or if user saves. False if user declines.</returns>
        public static bool CheckAndAskToSaveUnsavedScenes()
        {
            bool hasUnsavedChanges = false;

            for (int i = 0; i < EditorSceneManager.sceneCount; i++)
            {
                Scene scene = EditorSceneManager.GetSceneAt(i);
                if (scene.isDirty)
                {
                    hasUnsavedChanges = true;
                    break;
                }
            }

            if (!hasUnsavedChanges)
            {
                return true;
            }

            return EditorSceneManager.SaveCurrentModifiedScenesIfUserWantsTo();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/LdxEditorUtilities.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/LdxProjectSettingsWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 0eeb54fd56d347c08ed9614c82d5af4e
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities
{
    public partial class LdxProjectSettingsWindow : EditorWindow
    {
        private List<SettingsTab> settingsTabs;
        private int selectedTabIndex;
        private Vector2 sideBarScrollPosition;
        
        [MenuItem("LogicalDox/Project Settings")]
        public static void ShowWindow()
        {
            GetWindow<LdxProjectSettingsWindow>("LDX Settings");
        }
        
        private void OnEnable()
        {
            settingsTabs = new List<SettingsTab>();
            IEnumerable<Type> settingsTypes = AppDomain.CurrentDomain.GetAssemblies()
                .SelectMany(assembly => assembly.GetTypes())
                .Where(type => type.IsClass && !type.IsAbstract && type.BaseType != null &&
                               type.BaseType.IsGenericType &&
                               type.BaseType.GetGenericTypeDefinition() == typeof(GlobalSettings<>));

            foreach (Type type in settingsTypes)
            {
                Type tabType = typeof(SettingsTab<>).MakeGenericType(type);
                if (Activator.CreateInstance(tabType) is SettingsTab tabInstance)
                {
                    tabInstance.Initialize();
                    settingsTabs.Add(tabInstance);
                }
            }
        
            settingsTabs = settingsTabs.OrderBy(tab => tab.Name).ToList();
        }

        private void OnGUI()
        {
            if (settingsTabs == null || settingsTabs.Count == 0)
            {
                EditorGUILayout.HelpBox("No classes deriving from 'GlobalSettings<T>' were found in this project.", MessageType.Info);
                return;
            }

            EditorGUILayout.BeginHorizontal();
            DrawSidebar();
            if (selectedTabIndex >= 0 && selectedTabIndex < settingsTabs.Count)
            {
                settingsTabs[selectedTabIndex].Draw();
            }
            EditorGUILayout.EndHorizontal();
        }

        private void DrawSidebar()
        {
            EditorGUILayout.BeginVertical(EditorStyles.helpBox, GUILayout.Width(150), GUILayout.ExpandHeight(true));
            sideBarScrollPosition = EditorGUILayout.BeginScrollView(sideBarScrollPosition);

            string[] tabNames = settingsTabs.Select(tab => tab.Name).ToArray();
        
            GUIStyle selectionGridStyle = new(EditorStyles.toolbarButton)
            {
                alignment = TextAnchor.MiddleLeft,
                fixedHeight = 30,
                fontSize = 12
            };

            selectedTabIndex = GUILayout.SelectionGrid(selectedTabIndex, tabNames, 1, selectionGridStyle);

            EditorGUILayout.EndScrollView();
            EditorGUILayout.EndVertical();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/LdxProjectSettingsWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/LdxProjectSettingsWindow.SettingsTab.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e4377e8383584379a78683c2dfb13aab
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities
{
    public partial class LdxProjectSettingsWindow
    {
        private class SettingsTab<T> : SettingsTab where T : ScriptableSingleton<T>
        {
            public override Type SettingsType => typeof(T);

            public SettingsTab() : base(typeof(T)) {}
        }
        
        private abstract class SettingsTab
        {
            private const string GENERAL_HEADER = "General";
            private const float RESPONSIVE_THRESHOLD = 400f; 
            
            public string Name { get; }
            public abstract Type SettingsType { get; }
            public ScriptableObject ProjectInstance { get; private set; }
            public ScriptableObject FrameworkInstance { get; private set; }
            public bool IsUsingOverride { get; private set; }
            
            private SerializedObject projectSerializedObject;
            private SerializedObject frameworkSerializedObject;
            
            private bool isEditingFramework;

            private readonly Dictionary<string, List<SerializedProperty>> propertiesByHeader = new();
            private readonly List<string> headerTitles = new();
            private int selectedHeaderIndex;
            private Vector2 contentScrollPosition;
            
            private static GUIStyle iconButtonStyle;
            private static GUIContent resetIcon, compareIcon, applyIcon, pullIcon, editIcon;

            protected SettingsTab(Type type)
            {
                Name = ObjectNames.NicifyVariableName(type.Name.Replace("GlobalSettings", ""));
            }

            public void Initialize()
            {
                PropertyInfo instanceProperty = SettingsType.GetProperty("Instance", 
                    BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy);
                if (instanceProperty == null)
                {
                    return;
                }
                
                ProjectInstance = instanceProperty.GetValue(null) as ScriptableObject;
                if (ProjectInstance == null)
                {
                    return;
                }
                
                projectSerializedObject = new SerializedObject(ProjectInstance);

                string frameworkTypeName = $"Framework{SettingsType.Name}";
                string[] guids = AssetDatabase.FindAssets($"t:ScriptableObject {frameworkTypeName}");
                if (guids.Length > 0)
                {
                    FrameworkInstance = AssetDatabase.LoadAssetAtPath<ScriptableObject>(AssetDatabase.GUIDToAssetPath(guids[0]));
                    if (FrameworkInstance != null)
                        frameworkSerializedObject = new SerializedObject(FrameworkInstance);
                }
                
                IsUsingOverride = ProjectInstance != FrameworkInstance;
                DistributePropertiesByHeader();
                CacheStylesAndContent();
            }
            
            private void CacheStylesAndContent()
            {
                iconButtonStyle ??= new GUIStyle(EditorStyles.miniButton)
                    { padding = new RectOffset(0, 0, 0, 0), fixedWidth = 22 };

                resetIcon = new GUIContent("", "Reset this field to Framework Default");
                compareIcon = new GUIContent("", "Compare Project and Framework files");
                applyIcon = new GUIContent("", "Apply this Project value to the Framework Master");
                pullIcon = new GUIContent("", "Pull value from Project Override into Framework Master");
                editIcon = new GUIContent("", "Edit Framework Default");
            }

            private void DistributePropertiesByHeader()
            {
                propertiesByHeader.Clear();
                headerTitles.Clear();
                
                ScriptableObject activeObject = isEditingFramework ? FrameworkInstance : ProjectInstance;
                SerializedObject activeSerializedObject = isEditingFramework ? frameworkSerializedObject : projectSerializedObject;
                if (activeSerializedObject == null) return;

                string currentHeader = GENERAL_HEADER;
                SerializedProperty propertyIterator = activeSerializedObject.GetIterator();
                bool enterChildren = true;
                
                while (propertyIterator.NextVisible(enterChildren))
                {
                    enterChildren = false;
                    if (propertyIterator.name == "m_Script")
                    {
                        continue;
                    }
                    
                    FieldInfo field = activeObject.GetType().GetField(propertyIterator.name, BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
                    HeaderAttribute headerAttribute = field?.GetCustomAttribute<HeaderAttribute>();
                
                    if (headerAttribute != null) currentHeader = headerAttribute.header;
                    if (!propertiesByHeader.ContainsKey(currentHeader))
                    {
                        propertiesByHeader[currentHeader] = new List<SerializedProperty>();
                        headerTitles.Add(currentHeader);
                    }
                    propertiesByHeader[currentHeader].Add(propertyIterator.Copy());
                }
                
                if (headerTitles.Contains(GENERAL_HEADER))
                {
                    headerTitles.Remove(GENERAL_HEADER);
                    headerTitles.Insert(0, GENERAL_HEADER);
                }
            }

            public void Draw()
            {
                SerializedObject activeSerializedObject = isEditingFramework ? frameworkSerializedObject : projectSerializedObject;
                if (activeSerializedObject == null)
                {
                    string missingObjectName = isEditingFramework ? "Framework Master" : "Project Override";
                    EditorGUILayout.HelpBox($"{missingObjectName} for '{Name}' not found.", MessageType.Error);
                    return;
                }

                activeSerializedObject.Update();
                EditorGUILayout.BeginVertical();
                
                DrawManagementHeader();
                DrawWrappingHeaderToolbar();

                contentScrollPosition = EditorGUILayout.BeginScrollView(contentScrollPosition, EditorStyles.helpBox);
                if (selectedHeaderIndex >= 0 && selectedHeaderIndex < headerTitles.Count)
                {
                    if (propertiesByHeader.TryGetValue(headerTitles[selectedHeaderIndex], out List<SerializedProperty> properties))
                    {
                        EditorGUILayout.Space();
                        DrawResponsiveProperties(properties);
                    }
                }
                EditorGUILayout.EndScrollView();
                EditorGUILayout.EndVertical();

                if (GUI.changed)
                {
                    activeSerializedObject.ApplyModifiedProperties();
                }
            }
            
            private void DrawManagementHeader()
            {
                EditorGUILayout.BeginVertical(EditorStyles.helpBox);
                
                // --- Top Bar with Title and Edit Button ---
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.LabelField("Settings Management", EditorStyles.boldLabel);
                GUILayout.FlexibleSpace();
                
                GUI.enabled = FrameworkInstance != null; // Can only edit framework if it exists
                EditorGUI.BeginChangeCheck();
                isEditingFramework = GUILayout.Toggle(isEditingFramework, editIcon, iconButtonStyle);
                if(EditorGUI.EndChangeCheck()) DistributePropertiesByHeader();
                GUI.enabled = true;
                
                EditorGUILayout.EndHorizontal();
                EditorGUILayout.Space(3);

                // --- Color Coded Object Fields ---
                Color defaultColor = GUI.contentColor;
                
                // Project Instance Row
                GUI.contentColor = !isEditingFramework ? new Color(0.7f, 1f, 0.7f) : defaultColor; // Green when active
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.ObjectField("Project Instance:", ProjectInstance, SettingsType, false);
                GUI.contentColor = defaultColor;

                if (IsUsingOverride)
                {
                    if (GUILayout.Button(new GUIContent("", "Reset ALL fields to Framework Default"), iconButtonStyle))
                    {
                        if (EditorUtility.DisplayDialog("Reset Settings?", $"This will reset ALL settings for '{Name}' to the framework default values.", "Reset All", "Cancel"))
                        {
                            EditorJsonUtility.FromJsonOverwrite(EditorJsonUtility.ToJson(FrameworkInstance), ProjectInstance);
                            EditorUtility.SetDirty(ProjectInstance);
                        }
                    }
                    GUI.enabled = FrameworkInstance != null;
                    if (GUILayout.Button(compareIcon, iconButtonStyle)) Selection.objects = new[] { ProjectInstance, FrameworkInstance };
                    GUI.enabled = true;
                }
                else
                {
                    if (GUILayout.Button("Create Override"))
                    {
                         GetWindow<LdxProjectSettingsWindow>().OnEnable();
                         return;
                    }
                }
                EditorGUILayout.EndHorizontal();
                
                // Framework Master Row
                if(FrameworkInstance != null)
                {
                    GUI.contentColor = isEditingFramework ? new Color(1f, 0.9f, 0.5f) : defaultColor; // Yellow when active
                    EditorGUI.BeginDisabledGroup(true);
                    EditorGUILayout.ObjectField("Framework Master:", FrameworkInstance, SettingsType, false);
                    EditorGUI.EndDisabledGroup();
                    GUI.contentColor = defaultColor;
                }

                EditorGUILayout.EndVertical();
                EditorGUILayout.Space();
            }
            
            private void DrawWrappingHeaderToolbar()
            {
                if (headerTitles.Count <= 1) return;
                
                float availableWidth = EditorGUIUtility.currentViewWidth - 25;
                float currentWidth = 0;
                GUIStyle style = EditorStyles.toolbarButton;

                EditorGUILayout.BeginHorizontal();
                for (int i = 0; i < headerTitles.Count; i++)
                {
                    GUIContent content = new(headerTitles[i]);
                    Vector2 size = style.CalcSize(content);
                    if (currentWidth > 0 && currentWidth + size.x > availableWidth)
                    {
                        EditorGUILayout.EndHorizontal();
                        EditorGUILayout.BeginHorizontal();
                        currentWidth = 0;
                    }
                    if (GUILayout.Toggle(selectedHeaderIndex == i, content, style))
                    {
                        selectedHeaderIndex = i;
                    }
                    currentWidth += size.x;
                }
                
                EditorGUILayout.EndHorizontal();
            }

            private void DrawResponsiveProperties(List<SerializedProperty> properties)
            {
                bool isCompactMode = EditorGUIUtility.currentViewWidth < RESPONSIVE_THRESHOLD;
                foreach (SerializedProperty property in properties)
                {
                    EditorGUILayout.BeginHorizontal();
                    if (isCompactMode)
                    {
                        EditorGUILayout.BeginVertical();
                        EditorGUILayout.LabelField(property.displayName);
                        EditorGUILayout.PropertyField(property, GUIContent.none, true);
                        EditorGUILayout.EndVertical();
                    }
                    else
                    {
                        EditorGUILayout.PropertyField(property, true);
                    }
                    DrawSyncButtonsForProperty(property);
                    EditorGUILayout.EndHorizontal();
                    if (isCompactMode) EditorGUILayout.Space(5);
                }
            }
            
            private void DrawSyncButtonsForProperty(SerializedProperty property)
            {
                if (projectSerializedObject == null || frameworkSerializedObject == null) return;

                SerializedProperty projectProperty = projectSerializedObject.FindProperty(property.propertyPath);
                SerializedProperty frameworkProperty = frameworkSerializedObject.FindProperty(property.propertyPath);
                if (projectProperty == null || frameworkProperty == null) return;

                projectSerializedObject.Update();
                frameworkSerializedObject.Update();
                
                // Sync buttons are only enabled if the values are actually different
                GUI.enabled = !SerializedProperty.DataEquals(projectProperty, frameworkProperty);

                if (isEditingFramework)
                {
                    if (GUILayout.Button(pullIcon, iconButtonStyle))
                    {
                        CopyPropertyValue(projectProperty, frameworkProperty);
                        frameworkSerializedObject.ApplyModifiedProperties();
                    }
                }
                else
                {
                    if (GUILayout.Button(resetIcon, iconButtonStyle))
                    {
                        CopyPropertyValue(frameworkProperty, projectProperty);
                        projectSerializedObject.ApplyModifiedProperties();
                    }
                }
                GUI.enabled = true;
            }
            
             private void CopyPropertyValue(SerializedProperty source, SerializedProperty dest)
            {
                switch (source.propertyType)
                {
                    case SerializedPropertyType.Integer: dest.intValue = source.intValue; break;
                    case SerializedPropertyType.Boolean: dest.boolValue = source.boolValue; break;
                    case SerializedPropertyType.Float: dest.floatValue = source.floatValue; break;
                    case SerializedPropertyType.String: dest.stringValue = source.stringValue; break;
                    case SerializedPropertyType.Color: dest.colorValue = source.colorValue; break;
                    case SerializedPropertyType.ObjectReference: dest.objectReferenceValue = source.objectReferenceValue; break;
                    case SerializedPropertyType.LayerMask: dest.intValue = source.intValue; break;
                    case SerializedPropertyType.Enum: dest.enumValueIndex = source.enumValueIndex; break;
                    case SerializedPropertyType.Vector2: dest.vector2Value = source.vector2Value; break;
                    case SerializedPropertyType.Vector3: dest.vector3Value = source.vector3Value; break;
                    case SerializedPropertyType.Vector4: dest.vector4Value = source.vector4Value; break;
                    case SerializedPropertyType.Rect: dest.rectValue = source.rectValue; break;
                    case SerializedPropertyType.ArraySize: dest.arraySize = source.arraySize; break;
                    case SerializedPropertyType.Character: dest.intValue = source.intValue; break;
                    case SerializedPropertyType.AnimationCurve: dest.animationCurveValue = source.animationCurveValue; break;
                    case SerializedPropertyType.Bounds: dest.boundsValue = source.boundsValue; break;
                    case SerializedPropertyType.Quaternion: dest.quaternionValue = source.quaternionValue; break;
                    case SerializedPropertyType.Vector2Int: dest.vector2IntValue = source.vector2IntValue; break;
                    case SerializedPropertyType.Vector3Int: dest.vector3IntValue = source.vector3IntValue; break;
                    case SerializedPropertyType.RectInt: dest.rectIntValue = source.rectIntValue; break;
                    case SerializedPropertyType.BoundsInt: dest.boundsIntValue = source.boundsIntValue; break;
                    default:
                        // For complex nested properties, the best way is a deep copy.
                        dest.boxedValue = source.boxedValue;
                        break;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/LdxProjectSettingsWindow.SettingsTab.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Logger/LogVerbositySettingArrayDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 79179c65b2dcbd547971af72a6c1c6e1
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Logging
{
    [CustomPropertyDrawer(typeof(LogVerbosityCollection))]
    public class LogVerbositySettingArrayDrawer : PropertyDrawer
    {
        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            Array categories = Enum.GetValues(typeof(LogCategory));
            return (EditorGUIUtility.singleLineHeight + 1) * categories.Length;
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            LogCategory[] categories = (LogCategory[])Enum.GetValues(typeof(LogCategory));
            SerializedProperty arrayProperty = property.FindPropertyRelative("logVerbositySettings");
            
            if (categories.Length != arrayProperty.arraySize)
            {
                arrayProperty.arraySize = categories.Length;
            }

            float labelWidth = EditorGUIUtility.labelWidth;
            float lineHeight = EditorGUIUtility.singleLineHeight;

            for (int i = 0; i < categories.Length; i++)
            {
                Rect totalRect = new Rect(position.x, position.y + lineHeight * i + i, position.width, lineHeight);
                Rect leftRect = new Rect(totalRect.x, totalRect.y, labelWidth, lineHeight);
                Rect rightRect = new Rect(totalRect.x + labelWidth, 
                    totalRect.y, 
                    position.width - labelWidth, 
                    lineHeight);
                Rect dividerRect = new Rect(totalRect.x, totalRect.y + totalRect.height - 1, position.width, 1);
                EditorGUI.LabelField(dividerRect, "", EditorStyles.textField);
                EditorGUI.LabelField(leftRect, categories[i].ToString());
                EditorGUI.PropertyField(rightRect, arrayProperty.GetArrayElementAtIndex(i), new GUIContent());
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Logger/LogVerbositySettingArrayDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/NoteEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1087364b8da8421497a7491a00687082
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities
{
    [CustomEditor(typeof(EditorNote))]
    public class NoteEditor : UnityEditor.Editor
    {
        private const int MIN_HEIGHT = 50;
        private const int PADDING_AMOUNT = 10;

        private GUIStyle textAreaDisplayStyle;
        private GUIStyle TextAreaDisplayStyle
        {
            get
            {
                if (textAreaDisplayStyle == null)
                {
                    RectOffset padding = new RectOffset(PADDING_AMOUNT, PADDING_AMOUNT, PADDING_AMOUNT, PADDING_AMOUNT);
                    textAreaDisplayStyle = new GUIStyle();
                    Texture2D displayBg = GetBackgroundTexture(new Color(0.15f, 0.15f, 0.15f));
                    textAreaDisplayStyle.normal.textColor = new Color(0.5f, 0.67f, 0.34f);
                    textAreaDisplayStyle.fontStyle = FontStyle.Bold;
                    textAreaDisplayStyle.padding = padding;
                    textAreaDisplayStyle.normal.background = displayBg;
                    textAreaDisplayStyle.wordWrap = true;
                }

                return textAreaDisplayStyle;
            }
        }
        
        private GUIStyle textAreaEditingStyle;

        private GUIStyle TextAreaEditingStyle
        {
            get
            {
                if (textAreaEditingStyle == null)
                {
                    RectOffset padding = new RectOffset(PADDING_AMOUNT, PADDING_AMOUNT, PADDING_AMOUNT, PADDING_AMOUNT);
                    textAreaEditingStyle = new GUIStyle(EditorStyles.textArea);
                    textAreaEditingStyle.padding = padding;
                    textAreaEditingStyle.wordWrap = true;
                }

                return textAreaEditingStyle;
            }
        }
        
        private SerializedProperty noteProperty;
        private bool isEditing;
        
        private void OnEnable()
        {
            noteProperty = serializedObject.FindProperty("noteText");
        }

        public override void OnInspectorGUI()
        {
            DrawNoteArea();
            DrawEditButton();
        }

        private void DrawNoteArea()
        {
            EditorGUI.BeginChangeCheck();

            string editingText = noteProperty.stringValue;
            // Calculate the height needed for the text area
            float textAreaHeight = TextAreaDisplayStyle.CalcHeight(new GUIContent(noteProperty.stringValue), 
                EditorGUIUtility.currentViewWidth - 30) + PADDING_AMOUNT*2;

            textAreaHeight = Mathf.Max(textAreaHeight, MIN_HEIGHT);
            if (isEditing)
            {
                // Use EditorGUILayout.TextArea for editing
                editingText = EditorGUILayout.TextArea(editingText,
                    TextAreaEditingStyle,
                    GUILayout.MinHeight(textAreaHeight));
            }
            else
            {
                // Use EditorGUI.LabelField with a manually defined Rect for display
                EditorGUILayout.LabelField(
                    noteProperty.stringValue, 
                    TextAreaDisplayStyle,
                    GUILayout.MinHeight(textAreaHeight));
            }

            if (EditorGUI.EndChangeCheck() || noteProperty.stringValue != editingText)
            {
                Undo.RecordObject(target, "Edit Text");

                noteProperty.stringValue = editingText;

                EditorUtility.SetDirty(target);

                serializedObject.ApplyModifiedProperties();
            }
        }


        private void DrawEditButton()
        {
            if (GUILayout.Button(isEditing ? "Done" : "Edit"))
            {
                isEditing = !isEditing;
            }

            if (isEditing)
            {
                EditorGUILayout.HelpBox(new GUIContent("The note text will autosave as you're editing"));   
            }
        }

        private static Texture2D GetBackgroundTexture(Color color)
        {
            Texture2D texture = new Texture2D(1, 1);
            texture.SetPixel(0, 0, color);
            texture.Apply();
            return texture;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/NoteEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/PathFinding/GraphNodeEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 86d5a71124ca4f40b2aa5b0f74979a93
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.PathFinding
{
    [CustomEditor(typeof(GraphNode))]
    public class GraphNodeEditor: UnityEditor.Editor
    {
        private const string SESSION_KEY_GIZMO_MULTIPLIER = "GRAPH_NODE_GIZMO_MULTIPLIER";

        private GraphNode Target => (GraphNode)target;
        
        private static float SessionGizmoMultiplier
        {
            get => SessionState.GetFloat(SESSION_KEY_GIZMO_MULTIPLIER, 1.0f);
            set => SessionState.SetFloat(SESSION_KEY_GIZMO_MULTIPLIER, value);
        }

        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
            if (GUILayout.Button("Add Node"))
            {
                GameObject gO = new GameObject();
                gO.transform.SetParent(Target.transform.parent);
                gO.transform.position = Target.transform.position + Target.transform.forward * 0.1f;
                GraphNode graphNode = gO.AddComponent<GraphNode>();
                gO.name = "Node";
                Target.Neighbours.Add(graphNode);
                EditorUtility.SetDirty(Target);
            }
            
            LdxEditorHelper.DrawHorizontalSeparator();
            LdxEditorHelper.DrawBoldLabel("Global");

            using (new EditorGUILayout.HorizontalScope())
            {
                float viewW = EditorGUIUtility.currentViewWidth;
                EditorGUILayout.LabelField("Gizmo Scale", GUILayout.MaxWidth(viewW * 0.2f));
                float sliderValue = GUILayout.HorizontalSlider(SessionGizmoMultiplier, 0.2f, 1f, 
                    GUILayout.MinWidth(viewW * 0.4f));
                SessionGizmoMultiplier = Mathf.Clamp(Mathf.Round(sliderValue / 0.2f) * 0.2f, 0.2f, 1f);
                EditorGUILayout.LabelField($"{SessionGizmoMultiplier}x",GUILayout.MaxWidth(viewW * 0.1f));
            }
            GUILayout.Space(EditorGUIUtility.singleLineHeight);
            GraphNode.EDITOR_GizmoSizeMultiplier = SessionGizmoMultiplier;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/PathFinding/GraphNodeEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/ScenarioScriptGenerator/ScenarioScriptGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 606173d472624184cbb61c12a0e38f8b
# ASMDEF: ldx.framework.editor.dll
# ---
using System.IO;
using System.Text;
using UnityEngine;
using UnityEditor;

namespace Ldx.Framework.Utilities.ScenarioScriptGenerator
{
    public class ScenarioScriptGenerator : EditorWindow
    {
        // Window label strings
        private const string WINDOW_LABEL = "Ldx Script Wizard";
        private const string TITLE_LABEL = "Create Customized Ldx Scenario Script";
        private const string NAME_LABEL = "Script Name: ";
        private const string NAMESPACE_LABEL = "Enter Namespace:             Ldx.";
        private const string SUMMARY_LABEL = "Class Summary: ";
        private const string START_DESTROY_LABEL = "Use ScenarioStarted/Destroy: ";
        private const string ENABLE_DISABLE_LABEL = "Use Enable/Disable: ";
        private const string SUB_TRACKING_LABEL = "Sub to Track Events?";
        private const string BROADCAST_LABEL = "Broadcast Track Events?";
        private const string NUM_EVENTS_LABEL = "Number of Events to Add: ";
        private const string NUM_TRANSFORMS_LABEL = "# of Serialized Transforms: ";
        private const string NUM_BOOLS_LABEL = "# of Serialized bools: ";
        private const string NUM_FLOATS_LABEL = "# of Serialized floats: ";
        private const string BUTTON_LABEL = "Create Script";
        private const int SUMMARY_MAX_LINE_LENGTH = 111;
        
        private string scriptName = "ScriptNameHere";
        private string namespaceName = "Enter Namespace here (Ldx already added)";
        private string summary = "Enter Class Summary here";
        private bool useStartDestroy = true;
        private bool useEnableDisable;
        private bool subscribeToTrackingEvents;
        private bool broadcastTrackingEvents;
        private int numberOfEventsToAttach;
        private int numberOfTransformsToAttach;
        private int numberOfBoolsToAttach;
        private int numberOfFloatsToAttach;
        private string folderPath;
        private StreamWriter writer;

        [MenuItem("Assets/Create/Scenario Starter Script", false, 80)]
        private static void CreateDefaultScript()
        {
            // Get the selected folder path
            string path = "Assets";
            foreach (Object obj in Selection.GetFiltered(typeof(Object), SelectionMode.Assets))
            {
                path = AssetDatabase.GetAssetPath(obj);
                if (File.Exists(path))
                {
                    path = Path.GetDirectoryName(path);
                }
                break;
            }

            // Show the editor window
            ScenarioScriptGenerator window = GetWindow<ScenarioScriptGenerator>(WINDOW_LABEL);
            window.folderPath = path;
            window.Show();
        }

        private void OnGUI()
        {
            // Determine the width of the longest label
            GUIStyle labelStyle = GUI.skin.label;
            int width = (int)Mathf.Max(
                labelStyle.CalcSize(new GUIContent(NAME_LABEL)).x,
                labelStyle.CalcSize(new GUIContent(NAMESPACE_LABEL)).x,
                labelStyle.CalcSize(new GUIContent(SUMMARY_LABEL)).x,
                labelStyle.CalcSize(new GUIContent(START_DESTROY_LABEL)).x,
                labelStyle.CalcSize(new GUIContent(ENABLE_DISABLE_LABEL)).x,
                labelStyle.CalcSize(new GUIContent(SUB_TRACKING_LABEL)).x,
                labelStyle.CalcSize(new GUIContent(BROADCAST_LABEL)).x,
                labelStyle.CalcSize(new GUIContent(NUM_EVENTS_LABEL)).x,
                labelStyle.CalcSize(new GUIContent(NUM_TRANSFORMS_LABEL)).x,
                labelStyle.CalcSize(new GUIContent(NUM_BOOLS_LABEL)).x,
                labelStyle.CalcSize(new GUIContent(NUM_FLOATS_LABEL)).x
            );
            
            GUILayout.Label(TITLE_LABEL, EditorStyles.boldLabel);
            EditorGUILayout.BeginHorizontal();
            GUILayout.Label(NAME_LABEL, GUILayout.Width(width));
            scriptName = EditorGUILayout.TextField(scriptName);
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.BeginHorizontal();
            GUILayout.Label(NAMESPACE_LABEL, GUILayout.Width(width));
            namespaceName = EditorGUILayout.TextField(namespaceName);
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.BeginHorizontal();
            GUILayout.Label(SUMMARY_LABEL, GUILayout.Width(width));
            summary = EditorGUILayout.TextField(summary);
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.BeginHorizontal();
            GUILayout.Label(START_DESTROY_LABEL, GUILayout.Width(width));
            bool newUseStartDestroy = EditorGUILayout.Toggle(useStartDestroy);
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.BeginHorizontal();
            GUILayout.Label(ENABLE_DISABLE_LABEL, GUILayout.Width(width));
            bool newUseEnableDisable = EditorGUILayout.Toggle(useEnableDisable);
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.BeginHorizontal();
            GUILayout.Label(SUB_TRACKING_LABEL, GUILayout.Width(width));
            subscribeToTrackingEvents = EditorGUILayout.Toggle(subscribeToTrackingEvents);
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.BeginHorizontal();
            GUILayout.Label(BROADCAST_LABEL, GUILayout.Width(width));
            broadcastTrackingEvents = EditorGUILayout.Toggle(broadcastTrackingEvents);
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.BeginHorizontal();
            GUILayout.Label(NUM_EVENTS_LABEL, GUILayout.Width(width));
            numberOfEventsToAttach = Mathf.Max(0, EditorGUILayout.IntField(numberOfEventsToAttach));
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.BeginHorizontal();
            GUILayout.Label(NUM_TRANSFORMS_LABEL, GUILayout.Width(width));
            numberOfTransformsToAttach = Mathf.Max(0, EditorGUILayout.IntField(numberOfTransformsToAttach));
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.BeginHorizontal();
            GUILayout.Label(NUM_BOOLS_LABEL, GUILayout.Width(width));
            numberOfBoolsToAttach = Mathf.Max(0, EditorGUILayout.IntField(numberOfBoolsToAttach));
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.BeginHorizontal();
            GUILayout.Label(NUM_FLOATS_LABEL, GUILayout.Width(width));
            numberOfFloatsToAttach = Mathf.Max(0, EditorGUILayout.IntField(numberOfFloatsToAttach));
            EditorGUILayout.EndHorizontal();

            if (newUseStartDestroy != useStartDestroy || newUseEnableDisable != useEnableDisable)
            {
                useStartDestroy = !useStartDestroy;
                useEnableDisable = !useEnableDisable;
            }

            if (GUILayout.Button(BUTTON_LABEL))
            {
                CreateScript();
            }
        }

        private void CreateScript()
        {
            if (string.IsNullOrEmpty(scriptName))
            {
                Debug.LogError("Script name cannot be empty.");
                return;
            }

            string path = Path.Combine(folderPath, scriptName + ".cs");

            if (string.IsNullOrEmpty(path))
            {
                Debug.LogError("Error getting saving path.");
                return;
            }
            
            using (StreamWriter writerNew = new StreamWriter(path))
            {
                writer = writerNew;
                if (subscribeToTrackingEvents)
                {
                    writer.WriteLine("using Cysharp.Threading.Tasks;");
                }

                if (numberOfEventsToAttach > 0)
                {
                    writer.WriteLine("using Ldx.Framework.Systems.Objectives;");
                }
                    
                if (subscribeToTrackingEvents || broadcastTrackingEvents)
                {
                    writer.WriteLine("using Ldx.Framework.Systems.Objectives.Tracking;");
                }

                if (useStartDestroy)
                {
                    writer.WriteLine("using Ldx.Framework.Systems.ScenarioManagement;");
                    writer.WriteLine("using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;");
                }

                if (numberOfEventsToAttach > 0)
                {
                    writer.WriteLine("using Ldx.Framework.Utilities.Attributes;");
                }
                    
                writer.WriteLine("using UnityEngine;");
                writer.WriteLine("");
                writer.WriteLine($"namespace Ldx.{namespaceName}");
                writer.WriteLine("{");
                writer.WriteLine("    /// <summary>");
                PrintSummary(summary, SUMMARY_MAX_LINE_LENGTH);
                writer.WriteLine("    /// </summary>");
                writer.WriteLine($"    public class {scriptName} : MonoBehaviour");
                writer.WriteLine("    {");
                    
                // Set default events if needed
                if (numberOfEventsToAttach > 0)
                {
                    writer.WriteLine("        [Header(\"Events:\")]");
                    for (int i = 0; i < numberOfEventsToAttach; i++)
                    {
                        writer.WriteLine("        [IDSelection(LdxIdSettings.IdType.TrackingEvent)]");
                        writer.WriteLine($"        [SerializeField] private string referencedEvent{i + 1};  // Rename as needed.");
                    }
                    
                    writer.WriteLine("");
                }
                    
                // Set default transforms if needed
                if (numberOfTransformsToAttach > 0)
                {
                    writer.WriteLine("        [Header(\"Serialized References:\")]");
                    for (int i = 0; i < numberOfTransformsToAttach; i++)
                    {
                        writer.WriteLine($"        [SerializeField] private Transform referencedTransform{i + 1};  // Rename as needed.");
                    }
                    
                    if (numberOfBoolsToAttach == 0 && numberOfFloatsToAttach == 0)
                    {
                        writer.WriteLine("");
                    }
                }
                
                // Set default bools if needed
                if (numberOfBoolsToAttach > 0)
                {
                    if (numberOfTransformsToAttach == 0)
                    {
                        writer.WriteLine("        [Header(\"Serialized References:\")]");
                    }
                    
                    for (int i = 0; i < numberOfBoolsToAttach; i++)
                    {
                        writer.WriteLine($"        [SerializeField] private bool referencedBool{i + 1};  // Rename as needed.");
                    }
                    
                    if (numberOfFloatsToAttach == 0)
                    {
                        writer.WriteLine("");
                    }
                }
                    
                // Set default floats if needed
                if (numberOfFloatsToAttach > 0)
                {
                    if (numberOfTransformsToAttach == 0 && numberOfBoolsToAttach == 0)
                    {
                        writer.WriteLine("        [Header(\"Serialized References:\")]");
                    }
                    
                    for (int i = 0; i < numberOfTransformsToAttach; i++)
                    {
                        writer.WriteLine($"        [SerializeField] private float referencedFloat{i + 1};  // Rename as needed.");
                    }
                    
                    writer.WriteLine("");
                }

                // Functionality of the start menu, starting Scenario Manager or OnEnable
                writer.WriteLine(useStartDestroy ? "        private void Start()" : "        private void OnEnable()");
                writer.WriteLine("        {");
                if (useStartDestroy)
                {
                    writer.WriteLine("            if (ScenarioManager.Instance != null)");
                    writer.WriteLine("            {");
                    writer.WriteLine(
                        "                ScenarioManager.Instance.OnScenarioStarted += HandleScenarioStarted;");
                    writer.WriteLine("            }");
                    writer.WriteLine("        }");
                }
                else
                {
                    if (subscribeToTrackingEvents)
                    {
                        writer.WriteLine("            OnEnableAsync().Forget();");
                        writer.WriteLine("        }");
                    }
                    else
                    {
                        writer.WriteLine("            ");
                        writer.WriteLine("        }");
                    }
                }
                
                // Functionality of OnEnableAsync
                if (useEnableDisable && subscribeToTrackingEvents)
                {
                    writer.WriteLine("");
                    writer.WriteLine("        private async UniTaskVoid OnEnableAsync()");
                    writer.WriteLine("        {");
                    writer.WriteLine("            await UniTask.WaitUntil(() => LdxTrackingManager.IsValid);");
                    writer.WriteLine("            LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;");
                    writer.WriteLine("        }");
                }

                writer.WriteLine("");

                // Functionality of OnDestroy or OnDisable
                writer.WriteLine(useStartDestroy
                    ? "        private void OnDestroy()"
                    : "        private void OnDisable()");
                writer.WriteLine("        {");
                
                if (useStartDestroy)
                {
                    writer.WriteLine("            if (ScenarioManager.IsValid)");
                    writer.WriteLine("            {");
                    writer.WriteLine(
                        "                ScenarioManager.Instance.OnScenarioStarted -= HandleScenarioStarted;");
                    writer.WriteLine("            }");
                }

                if (subscribeToTrackingEvents)
                {
                    if (useStartDestroy)
                    {
                        writer.WriteLine("");
                    }
                    writer.WriteLine("            if (LdxTrackingManager.IsValid)");
                    writer.WriteLine("            {");
                    writer.WriteLine("                LdxTrackingManager.Instance.OnTrackingEvent -= HandleTrackingEvent;");
                    writer.WriteLine("            }");
                }
                else if (useEnableDisable)
                {
                    writer.WriteLine("            ");
                }
                
                writer.WriteLine("        }");
                    
                // Functionality of Handle Scenario Started
                if (useStartDestroy)
                {
                    writer.WriteLine("");
                    writer.WriteLine(
                        "        private async void HandleScenarioStarted(ScenarioManager scrMgr, ScenarioDataType dType)");
                    writer.WriteLine("        {");
                    
                    if (subscribeToTrackingEvents)
                    {
                        writer.WriteLine("            await UniTask.WaitUntil(()=> LdxTrackingManager.IsValid);");
                        writer.WriteLine(
                            "            LdxTrackingManager.Instance.OnTrackingEvent += HandleTrackingEvent;");
                    }
                    else
                    {
                        writer.WriteLine("            // Add logic for OnScenarioStarted.");
                    }

                    writer.WriteLine("        }");
                }

                // Functionality for HandleTrackingEvent
                if (subscribeToTrackingEvents)
                {
                    writer.WriteLine("");
                    writer.WriteLine("        private void HandleTrackingEvent(string eventId)");
                    writer.WriteLine("        {");
                    writer.WriteLine("            // Add logic for handling tracking event.");
                    writer.WriteLine("        }");
                }
                    
                // Functionality for Broadcasting Tracking Events
                if (broadcastTrackingEvents)
                {
                    writer.WriteLine("");
                    writer.WriteLine("        private void BroadcastEvent(string eventId)");
                    writer.WriteLine("        {");
                    writer.WriteLine("            LdxTrackingManager.Instance.BroadcastTrackingEvent(eventId);");
                    writer.WriteLine("        }");
                }
                    
                writer.WriteLine("    }");
                writer.WriteLine("}");
            }

            AssetDatabase.Refresh();

            MonoScript scriptAsset = AssetDatabase.LoadAssetAtPath<MonoScript>(path);
            if (scriptAsset != null)
            {
                GameObject selectedObject = Selection.activeGameObject;
                if (selectedObject != null)
                {
                    selectedObject.AddComponent(scriptAsset.GetClass());
                }
            }

            Close();
        }
        private void PrintSummary(string text, int maxLength)
        {
            string[] words = text.Split(' ');
            StringBuilder currentLine = new StringBuilder();
    
            foreach (string word in words)
            {
                if (currentLine.Length + word.Length + 1 <= maxLength) // +1 for the space
                {
                    if (currentLine.Length > 0)
                        currentLine.Append(" ");
                    currentLine.Append(word);
                }
                else
                {
                    writer.WriteLine("    /// " + currentLine);
                    currentLine.Clear();
                    currentLine.Append(word);
                }
            }

            if (currentLine.Length > 0)
            {
                writer.WriteLine("    /// " + currentLine);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/ScenarioScriptGenerator/ScenarioScriptGenerator.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/ScriptableSingletonEditorInitializer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e40736867c6a4416a557e08c50a01cbc
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Linq;
using System.Reflection;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;

namespace Ldx.Framework.Utilities
{
    /// <summary>
    /// Initializes scriptable singletons in editor so their asset files are created
    /// </summary>
    public class ScriptableSingletonEditorInitializer
    {
        private const string INIT_ON_LOAD_METHOD_NAME = "EDITOR_InitializeOnLoad";
        private const string SCRIPTABLE_SINGLETON_SESSION_KEY = "SCRIPTABLE_SINGLETON_SESSION_INIT";

        private static bool isSceneLoaded = false;
        
        [InitializeOnLoadMethod]
        public static void InitializeOnLoad()
        {
            // To make sure this runs automatically only once per session, avoiding recompilation reloads
            if (SessionState.GetBool(SCRIPTABLE_SINGLETON_SESSION_KEY, false))
            {
                return;
            }
            SessionState.SetBool(SCRIPTABLE_SINGLETON_SESSION_KEY, true);
            WaitUntilLoadedThenSetFlagAsync().Forget();
            EditorApplication.update += EditorUpdate;
        }

        private static void EditorUpdate()
        {
            if (isSceneLoaded)
            {
                InitializeAllScriptableSingletons();
                EditorApplication.update -= EditorUpdate;
            }
        }

        private static async UniTask WaitUntilLoadedThenSetFlagAsync()
        {
            await LdxEditorHelper.WaitUntilEditorIsLoadedAsync();
            isSceneLoaded = true;
        }

        private static void InitializeAllScriptableSingletons()
        {
            foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                foreach (Type t in assembly.GetTypes())
                {
                    if (t.IsAbstract || !t.IsSubclassOf(typeof(ScriptableSingleton)))
                    {
                        continue;
                    }

                    Type baseType = GetLowestBaseType(t);
                    
                    try
                    {
                        baseType.InvokeMember(INIT_ON_LOAD_METHOD_NAME, BindingFlags.InvokeMethod | BindingFlags.Public | BindingFlags.Static, null,
                            null, null);
                    }
                    catch (Exception e)
                    {
                        UnityEngine.Debug.LogError($"{t.Name}: {e}");
                    }
                }
            }
            AssetDatabase.Refresh();
        }
        
        private static Type GetLowestBaseType(Type t)
        {
            while (t.BaseType != null && t.BaseType.IsSubclassOf(typeof(ScriptableSingleton)))
            {
                t = t.BaseType;
            }
            return t;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/ScriptableSingletonEditorInitializer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Serializable/ListHashSetDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e1179162ab384c1d8af63e8a8ddb09a5
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using UnityEngine;
using Utilities.Serializable;

namespace Ldx.Framework.Utilities.Serializable
{
    [CustomPropertyDrawer(typeof(ListHashSet<>), true)]
    public class ListHashSetDrawer : PropertyDrawer
    {
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            // Just draw the list
            SerializedProperty listProp = property.FindPropertyRelative("list");
            EditorGUI.PropertyField(position, listProp, label, true);
        }
        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            SerializedProperty listProp = property.FindPropertyRelative("list");
            return EditorGUI.GetPropertyHeight(listProp, label, true);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Serializable/ListHashSetDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Serializable/SerializableDictionaryPropertyDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 42def83422c6418faf57b9b8eaac04e8
# ASMDEF: ldx.framework.editor.dll
# ---
#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.Reflection;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEngine;
using Utilities.Serializable;

namespace Ldx.Framework.Utilities.Serializable
{
	[CustomPropertyDrawer(typeof(SerializableDictionaryBase), true)]
#if NET_4_6 || NET_STANDARD_2_0
	[CustomPropertyDrawer(typeof(SerializableHashSetBase), true)]
#endif
	public class SerializableDictionaryPropertyDrawer : PropertyDrawer
	{
		const string KeysFieldName = "m_keys";
		const string ValuesFieldName = "m_values";
		protected const float IndentWidth = 15f;

		static GUIContent s_iconPlus = IconContent ("Toolbar Plus", "Add entry");
		static GUIContent s_iconMinus = IconContent ("Toolbar Minus", "Remove entry");
		static GUIContent s_warningIconConflict = IconContent ("console.warnicon.sml", "Conflicting key, this entry will be lost");
		static GUIContent s_warningIconOther = IconContent ("console.infoicon.sml", "Conflicting key");
		static GUIContent s_warningIconNull = IconContent ("console.warnicon.sml", "Null key, this entry will be lost");
		static GUIStyle s_buttonStyle = GUIStyle.none;
		static GUIContent s_tempContent = new GUIContent();
		
		class ConflictState
		{
			public object conflictKey = null;
			public object conflictValue = null;
			public int conflictIndex = -1 ;
			public int conflictOtherIndex = -1 ;
			public bool conflictKeyPropertyExpanded = false;
			public bool conflictValuePropertyExpanded = false;
			public float conflictLineHeight = 0f;
		}

		struct PropertyIdentity
		{
			public PropertyIdentity(SerializedProperty property)
			{
				this.instance = property.serializedObject.targetObject;
				this.propertyPath = property.propertyPath;
			}

			public UnityEngine.Object instance;
			public string propertyPath;
		}

		static Dictionary<PropertyIdentity, ConflictState> s_conflictStateDict = new Dictionary<PropertyIdentity, ConflictState>();

		enum Action
		{
			None,
			Add,
			Remove
		}

		public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
		{
			position = position.Modify(width: position.width - position.x);
			label = EditorGUI.BeginProperty(position, label, property);

			Action buttonAction = Action.None;
			int buttonActionIndex = 0;

			SerializedProperty keyArrayProperty = property.FindPropertyRelative(KeysFieldName);
			SerializedProperty valueArrayProperty = property.FindPropertyRelative(ValuesFieldName);

			ConflictState conflictState = GetConflictState(property);

			if(conflictState.conflictIndex != -1)
			{
				keyArrayProperty.InsertArrayElementAtIndex(conflictState.conflictIndex);
				SerializedProperty keyProperty = keyArrayProperty.GetArrayElementAtIndex(conflictState.conflictIndex);
				SetPropertyValue(keyProperty, conflictState.conflictKey);
				keyProperty.isExpanded = conflictState.conflictKeyPropertyExpanded;

				if(valueArrayProperty != null)
				{
					valueArrayProperty.InsertArrayElementAtIndex(conflictState.conflictIndex);
					SerializedProperty valueProperty = valueArrayProperty.GetArrayElementAtIndex(conflictState.conflictIndex);
					SetPropertyValue(valueProperty, conflictState.conflictValue);
					valueProperty.isExpanded = conflictState.conflictValuePropertyExpanded;
				}
			}

			float buttonWidth = s_buttonStyle.CalcSize(s_iconPlus).x;

			Rect labelPosition = position;
			labelPosition.height = EditorGUIUtility.singleLineHeight;
			if (property.isExpanded)
				labelPosition.xMax -= s_buttonStyle.CalcSize(s_iconPlus).x;

			EditorGUI.PropertyField(labelPosition, property, label, false);
			// property.isExpanded = EditorGUI.Foldout(labelPosition, property.isExpanded, label);
			if (property.isExpanded)
			{
				Rect buttonPosition = position;
				buttonPosition.xMin = buttonPosition.xMax - buttonWidth;
				buttonPosition.height = EditorGUIUtility.singleLineHeight;
				EditorGUI.BeginDisabledGroup(conflictState.conflictIndex != -1);
				if(GUI.Button(buttonPosition, s_iconPlus, s_buttonStyle))
				{
					buttonAction = Action.Add;
					buttonActionIndex = keyArrayProperty.arraySize;
				}
				EditorGUI.EndDisabledGroup();

				EditorGUI.indentLevel++;
				Rect linePosition = position;
				linePosition.y += EditorGUIUtility.singleLineHeight;
				linePosition.xMax -= buttonWidth;

				foreach(EnumerationEntry entry in EnumerateEntries(keyArrayProperty, valueArrayProperty))
				{
					SerializedProperty keyProperty = entry.keyProperty;
					SerializedProperty valueProperty = entry.valueProperty;
					int i = entry.index;

					float lineHeight = DrawKeyValueLine(keyProperty, valueProperty, linePosition, i);

					buttonPosition = linePosition;
					buttonPosition.x = linePosition.xMax;
					buttonPosition.height = EditorGUIUtility.singleLineHeight;
					if(GUI.Button(buttonPosition, s_iconMinus, s_buttonStyle))
					{
						buttonAction = Action.Remove;
						buttonActionIndex = i;
					}

					if(i == conflictState.conflictIndex && conflictState.conflictOtherIndex == -1)
					{
						Rect iconPosition = linePosition;
						iconPosition.size =  s_buttonStyle.CalcSize(s_warningIconNull);
						GUI.Label(iconPosition, s_warningIconNull);
					}
					else if(i == conflictState.conflictIndex)
					{
						Rect iconPosition = linePosition;
						iconPosition.size =  s_buttonStyle.CalcSize(s_warningIconConflict);
						GUI.Label(iconPosition, s_warningIconConflict);
					}
					else if(i == conflictState.conflictOtherIndex)
					{
						Rect iconPosition = linePosition;
						iconPosition.size =  s_buttonStyle.CalcSize(s_warningIconOther);
						GUI.Label(iconPosition, s_warningIconOther);
					}


					linePosition.y += lineHeight;
				}

				EditorGUI.indentLevel--;
			}

			if(buttonAction == Action.Add)
			{
				keyArrayProperty.InsertArrayElementAtIndex(buttonActionIndex);
				if(valueArrayProperty != null)
					valueArrayProperty.InsertArrayElementAtIndex(buttonActionIndex);
			}
			else if(buttonAction == Action.Remove)
			{
				DeleteArrayElementAtIndex(keyArrayProperty, buttonActionIndex);
				if(valueArrayProperty != null)
					DeleteArrayElementAtIndex(valueArrayProperty, buttonActionIndex);
			}

			conflictState.conflictKey = null;
			conflictState.conflictValue = null;
			conflictState.conflictIndex = -1;
			conflictState.conflictOtherIndex = -1;
			conflictState.conflictLineHeight = 0f;
			conflictState.conflictKeyPropertyExpanded = false;
			conflictState.conflictValuePropertyExpanded = false;

			foreach(EnumerationEntry entry1 in EnumerateEntries(keyArrayProperty, valueArrayProperty))
			{
				SerializedProperty keyProperty1 = entry1.keyProperty;
				int i = entry1.index;
				object keyProperty1Value = GetPropertyValue(keyProperty1);

				if(keyProperty1Value == null)
				{
					SerializedProperty valueProperty1 = entry1.valueProperty;
					SaveProperty(keyProperty1, valueProperty1, i, -1, conflictState);
					DeleteArrayElementAtIndex(keyArrayProperty, i);
					if(valueArrayProperty != null)
						DeleteArrayElementAtIndex(valueArrayProperty, i);

					break;
				}


				foreach(EnumerationEntry entry2 in EnumerateEntries(keyArrayProperty, valueArrayProperty, i + 1))
				{
					SerializedProperty keyProperty2 = entry2.keyProperty;
					int j = entry2.index;
					object keyProperty2Value = GetPropertyValue(keyProperty2);

					if(ComparePropertyValues(keyProperty1Value, keyProperty2Value))
					{
						SerializedProperty valueProperty2 = entry2.valueProperty;
						SaveProperty(keyProperty2, valueProperty2, j, i, conflictState);
						DeleteArrayElementAtIndex(keyArrayProperty, j);
						if(valueArrayProperty != null)
							DeleteArrayElementAtIndex(valueArrayProperty, j);

						goto breakLoops;
					}
				}
			}
			breakLoops:

			EditorGUI.EndProperty();
		}

		static float DrawKeyValueLine(SerializedProperty keyProperty, SerializedProperty valueProperty, Rect linePosition, int index)
		{
			bool keyCanBeExpanded = CanPropertyBeExpanded(keyProperty);

			if(valueProperty != null)
			{
				bool valueCanBeExpanded = CanPropertyBeExpanded(valueProperty);

				if(!keyCanBeExpanded && valueCanBeExpanded)
				{
					return DrawKeyValueLineExpand(keyProperty, valueProperty, linePosition);
				}
				else
				{
					string keyLabel = keyCanBeExpanded ? ("Key " + index.ToString()) : "";
					string valueLabel = valueCanBeExpanded ? ("Value " + index.ToString()) : "";
					return DrawKeyValueLineSimple(keyProperty, valueProperty, keyLabel, valueLabel, linePosition);
				}
			}
			else
			{
				if(!keyCanBeExpanded)
				{
					return DrawKeyLine(keyProperty, linePosition, null);
				}
				else
				{
					string keyLabel = string.Format("{0} {1}", ObjectNames.NicifyVariableName(keyProperty.type), index);
					return DrawKeyLine(keyProperty, linePosition, keyLabel);
				}
			}
		}

		static float DrawKeyValueLineSimple(SerializedProperty keyProperty, SerializedProperty valueProperty, string keyLabel, string valueLabel, Rect linePosition)
		{
			float labelWidth = EditorGUIUtility.labelWidth;
			float labelWidthRelative = labelWidth / linePosition.width;

			float keyPropertyHeight = EditorGUI.GetPropertyHeight(keyProperty);
			Rect keyPosition = linePosition;
			keyPosition.height = keyPropertyHeight;
			keyPosition.width = labelWidth - IndentWidth;
			EditorGUIUtility.labelWidth = keyPosition.width * labelWidthRelative;
			EditorGUI.PropertyField(keyPosition, keyProperty, TempContent(keyLabel), true);

			float valuePropertyHeight = EditorGUI.GetPropertyHeight(valueProperty);
			Rect valuePosition = linePosition;
			valuePosition.height = valuePropertyHeight;
			valuePosition.xMin += labelWidth;
			EditorGUIUtility.labelWidth = valuePosition.width * labelWidthRelative;
			EditorGUI.indentLevel--;
			EditorGUI.PropertyField(valuePosition, valueProperty, TempContent(valueLabel), true);
			EditorGUI.indentLevel++;

			EditorGUIUtility.labelWidth = labelWidth;

			return Mathf.Max(keyPropertyHeight, valuePropertyHeight);
		}

		static float DrawKeyValueLineExpand(SerializedProperty keyProperty, SerializedProperty valueProperty, Rect linePosition)
		{
			float labelWidth = EditorGUIUtility.labelWidth;

			float keyPropertyHeight = EditorGUI.GetPropertyHeight(keyProperty);
			Rect keyPosition = linePosition;
			keyPosition.height = keyPropertyHeight;
			keyPosition.width = labelWidth - IndentWidth;
			EditorGUI.PropertyField(keyPosition, keyProperty, GUIContent.none, true);

			float valuePropertyHeight = EditorGUI.GetPropertyHeight(valueProperty);
			Rect valuePosition = linePosition;
			valuePosition.height = valuePropertyHeight;
			EditorGUI.PropertyField(valuePosition, valueProperty, GUIContent.none, true);

			EditorGUIUtility.labelWidth = labelWidth;

			return Mathf.Max(keyPropertyHeight, valuePropertyHeight);
		}

		static float DrawKeyLine(SerializedProperty keyProperty, Rect linePosition, string keyLabel)
		{
			float keyPropertyHeight = EditorGUI.GetPropertyHeight(keyProperty);
			Rect keyPosition = linePosition;
			keyPosition.height = keyPropertyHeight;
			keyPosition.width = linePosition.width;

			GUIContent keyLabelContent = keyLabel != null ? TempContent(keyLabel) : GUIContent.none;
			EditorGUI.PropertyField(keyPosition, keyProperty, keyLabelContent, true);

			return keyPropertyHeight;
		}

		static bool CanPropertyBeExpanded(SerializedProperty property)
		{
			switch(property.propertyType)
			{
				case SerializedPropertyType.Generic:
				case SerializedPropertyType.Vector4:
				case SerializedPropertyType.Quaternion:
					return true;
				default:
					return false;
			}
		}

		static void SaveProperty(SerializedProperty keyProperty, SerializedProperty valueProperty, int index, int otherIndex, ConflictState conflictState)
		{
			conflictState.conflictKey = GetPropertyValue(keyProperty);
			conflictState.conflictValue = valueProperty != null ? GetPropertyValue(valueProperty) : null;
			float keyPropertyHeight = EditorGUI.GetPropertyHeight(keyProperty);
			float valuePropertyHeight = valueProperty != null ? EditorGUI.GetPropertyHeight(valueProperty) : 0f;
			float lineHeight = Mathf.Max(keyPropertyHeight, valuePropertyHeight);
			conflictState.conflictLineHeight = lineHeight;
			conflictState.conflictIndex = index;
			conflictState.conflictOtherIndex = otherIndex;
			conflictState.conflictKeyPropertyExpanded = keyProperty.isExpanded;
			conflictState.conflictValuePropertyExpanded = valueProperty != null ? valueProperty.isExpanded : false;
		}

		public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
		{
			float propertyHeight = EditorGUIUtility.singleLineHeight;

			if (property.isExpanded)
			{
				SerializedProperty keysProperty = property.FindPropertyRelative(KeysFieldName);
				SerializedProperty valuesProperty = property.FindPropertyRelative(ValuesFieldName);

				foreach(EnumerationEntry entry in EnumerateEntries(keysProperty, valuesProperty))
				{
					SerializedProperty keyProperty = entry.keyProperty;
					SerializedProperty valueProperty = entry.valueProperty;
					float keyPropertyHeight = EditorGUI.GetPropertyHeight(keyProperty);
					float valuePropertyHeight = valueProperty != null ? EditorGUI.GetPropertyHeight(valueProperty) : 0f;
					float lineHeight = Mathf.Max(keyPropertyHeight, valuePropertyHeight);
					propertyHeight += lineHeight;
				}

				ConflictState conflictState = GetConflictState(property);

				if(conflictState.conflictIndex != -1)
				{
					propertyHeight += conflictState.conflictLineHeight;
				}
			}

			return propertyHeight;
		}

		static ConflictState GetConflictState(SerializedProperty property)
		{
			ConflictState conflictState;
			PropertyIdentity propId = new PropertyIdentity(property);
			if(!s_conflictStateDict.TryGetValue(propId, out conflictState))
			{
				conflictState = new ConflictState();
				s_conflictStateDict.Add(propId, conflictState);
			}
			return conflictState;
		}

		static Dictionary<SerializedPropertyType, PropertyInfo> s_serializedPropertyValueAccessorsDict;

		static SerializableDictionaryPropertyDrawer()
		{
			Dictionary<SerializedPropertyType, string> serializedPropertyValueAccessorsNameDict = new Dictionary<SerializedPropertyType, string>() {
				{ SerializedPropertyType.Integer, "intValue" },
				{ SerializedPropertyType.Boolean, "boolValue" },
				{ SerializedPropertyType.Float, "floatValue" },
				{ SerializedPropertyType.String, "stringValue" },
				{ SerializedPropertyType.Color, "colorValue" },
				{ SerializedPropertyType.ObjectReference, "objectReferenceValue" },
				{ SerializedPropertyType.LayerMask, "intValue" },
				{ SerializedPropertyType.Enum, "intValue" },
				{ SerializedPropertyType.Vector2, "vector2Value" },
				{ SerializedPropertyType.Vector3, "vector3Value" },
				{ SerializedPropertyType.Vector4, "vector4Value" },
				{ SerializedPropertyType.Rect, "rectValue" },
				{ SerializedPropertyType.ArraySize, "intValue" },
				{ SerializedPropertyType.Character, "intValue" },
				{ SerializedPropertyType.AnimationCurve, "animationCurveValue" },
				{ SerializedPropertyType.Bounds, "boundsValue" },
				{ SerializedPropertyType.Quaternion, "quaternionValue" },
			};
			Type serializedPropertyType = typeof(SerializedProperty);

			s_serializedPropertyValueAccessorsDict	= new Dictionary<SerializedPropertyType, PropertyInfo>();
			BindingFlags flags = BindingFlags.Instance | BindingFlags.Public;

			foreach(KeyValuePair<SerializedPropertyType, string> kvp in serializedPropertyValueAccessorsNameDict)
			{
				PropertyInfo propertyInfo = serializedPropertyType.GetProperty(kvp.Value, flags);
				s_serializedPropertyValueAccessorsDict.Add(kvp.Key, propertyInfo);
			}
		}

		static GUIContent IconContent(string name, string tooltip)
		{
			GUIContent builtinIcon = EditorGUIUtility.IconContent (name);
			return new GUIContent(builtinIcon.image, tooltip);
		}

		static GUIContent TempContent(string text)
		{
			s_tempContent.text = text;
			return s_tempContent;
		}

		static void DeleteArrayElementAtIndex(SerializedProperty arrayProperty, int index)
		{
			SerializedProperty property = arrayProperty.GetArrayElementAtIndex(index);
			// if(arrayProperty.arrayElementType.StartsWith("PPtr<$"))
			if(property.propertyType == SerializedPropertyType.ObjectReference)
			{
				property.objectReferenceValue = null;
			}

			arrayProperty.DeleteArrayElementAtIndex(index);
		}

		public static object GetPropertyValue(SerializedProperty p)
		{
			PropertyInfo propertyInfo;
			if(s_serializedPropertyValueAccessorsDict.TryGetValue(p.propertyType, out propertyInfo))
			{
				return propertyInfo.GetValue(p, null);
			}
			else
			{
				if(p.isArray)
					return GetPropertyValueArray(p);
				else
					return GetPropertyValueGeneric(p);
			}
		}

		static void SetPropertyValue(SerializedProperty p, object v)
		{
			PropertyInfo propertyInfo;
			if(s_serializedPropertyValueAccessorsDict.TryGetValue(p.propertyType, out propertyInfo))
			{
				propertyInfo.SetValue(p, v, null);
			}
			else
			{
				if(p.isArray)
					SetPropertyValueArray(p, v);
				else
					SetPropertyValueGeneric(p, v);
			}
		}

		static object GetPropertyValueArray(SerializedProperty property)
		{
			object[] array = new object[property.arraySize];
			for(int i = 0; i < property.arraySize; i++)
			{
				SerializedProperty item = property.GetArrayElementAtIndex(i);
				array[i] = GetPropertyValue(item);
			}
			return array;
		}

		static object GetPropertyValueGeneric(SerializedProperty property)
		{
			Dictionary<string, object> dict = new Dictionary<string, object>();
			SerializedProperty iterator = property.Copy();
			if(iterator.Next(true))
			{
				SerializedProperty end = property.GetEndProperty();
				do
				{
					string name = iterator.name;
					object value = GetPropertyValue(iterator);
					dict.Add(name, value);
				} while(iterator.Next(false) && iterator.propertyPath != end.propertyPath);
			}
			return dict;
		}

		static void SetPropertyValueArray(SerializedProperty property, object v)
		{
			object[] array = (object[]) v;
			property.arraySize = array.Length;
			for(int i = 0; i < property.arraySize; i++)
			{
				SerializedProperty item = property.GetArrayElementAtIndex(i);
				SetPropertyValue(item, array[i]);
			}
		}

		static void SetPropertyValueGeneric(SerializedProperty property, object v)
		{
			Dictionary<string, object> dict = (Dictionary<string, object>) v;
			SerializedProperty iterator = property.Copy();
			if(iterator.Next(true))
			{
				SerializedProperty end = property.GetEndProperty();
				do
				{
					string name = iterator.name;
					SetPropertyValue(iterator, dict[name]);
				} while(iterator.Next(false) && iterator.propertyPath != end.propertyPath);
			}
		}

		static bool ComparePropertyValues(object value1, object value2)
		{
			if(value1 is Dictionary<string, object> && value2 is Dictionary<string, object>)
			{
				Dictionary<string, object> dict1 = (Dictionary<string, object>)value1;
				Dictionary<string, object> dict2 = (Dictionary<string, object>)value2;
				return CompareDictionaries(dict1, dict2);
			}
			else
			{
				return object.Equals(value1, value2);
			}
		}

		static bool CompareDictionaries(Dictionary<string, object> dict1, Dictionary<string, object> dict2)
		{
			if(dict1.Count != dict2.Count)
				return false;

			foreach(KeyValuePair<string, object> kvp1 in dict1)
			{
				string key1 = kvp1.Key;
				object value1 = kvp1.Value;

				object value2;
				if(!dict2.TryGetValue(key1, out value2))
					return false;

				if(!ComparePropertyValues(value1, value2))
					return false;
			}
		
			return true;
		}

		struct EnumerationEntry
		{
			public SerializedProperty keyProperty;
			public SerializedProperty valueProperty;
			public int index;

			public EnumerationEntry(SerializedProperty keyProperty, SerializedProperty valueProperty, int index)
			{
				this.keyProperty = keyProperty;
				this.valueProperty = valueProperty;
				this.index = index;
			}
		}

		static IEnumerable<EnumerationEntry> EnumerateEntries(SerializedProperty keyArrayProperty, SerializedProperty valueArrayProperty, int startIndex = 0)
		{
			if(keyArrayProperty.arraySize > startIndex)
			{
				int index = startIndex;
				SerializedProperty keyProperty = keyArrayProperty.GetArrayElementAtIndex(startIndex);
				SerializedProperty valueProperty = valueArrayProperty != null ? valueArrayProperty.GetArrayElementAtIndex(startIndex) : null;
				SerializedProperty endProperty = keyArrayProperty.GetEndProperty();

				do
				{
					yield return new EnumerationEntry(keyProperty, valueProperty, index);
					index++;
				} while(keyProperty.Next(false)
				        && (valueProperty != null ? valueProperty.Next(false) : true)
				        && !SerializedProperty.EqualContents(keyProperty, endProperty));
			}
		}
	}

	[CustomPropertyDrawer(typeof(SerializableDictionaryBase.Storage), true)]
	public class SerializableDictionaryStoragePropertyDrawer : PropertyDrawer
	{
		public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
		{
			property.Next(true);
			EditorGUI.PropertyField(position, property, label, true);
		}

		public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
		{
			property.Next(true);
			return EditorGUI.GetPropertyHeight(property);
		}
	}
#endif
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Serializable/SerializableDictionaryPropertyDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Seurat/EnvironmentTransitionControllerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a5df2db966dd48218159b07885e3310e
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections;
using Unity.EditorCoroutines.Editor;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Seurat
{
    [CustomEditor(typeof(EnvironmentTransitionController))]
    public class EnvironmentTransitionControllerEditor : UnityEditor.Editor
    {
        private EnvironmentTransitionController controller;
        private float showRendererTime;
        private float visualizeEndTime;
        private float nextVisualizeTime;
        private bool isVisualizing;
        private EditorCoroutine activeCoroutine;
        
        private void OnEnable()
        {
            controller = (EnvironmentTransitionController)target;
        }

        public override void OnInspectorGUI()
        {
            EditorGUILayout.HelpBox(
                "Seurat box colliders will be automatically assigned upon scene save",
                MessageType.Info);

            DrawDefaultInspector();

            if (controller.ColliderCount < 1)
            {
                EditorGUILayout.HelpBox(
                    "Note: All Seurat headboxes will require a box collider set to 'Trigger' in order for this to work. This component should always be on the 'Seurat Headboxes' level as a parent to the actual Seurat headboxes.",
                    MessageType.Warning);
            }
            
            
            if (GUILayout.Button("Disable all renderers"))
            {
                controller.DisableAllRenderers();
            }
            
            if (GUILayout.Button("Enable all renderers"))
            {
                controller.EnableAllRenderers();
            }

            if (GUILayout.Button("Visualize current camera"))
            {
                Vector3 location = SceneView.lastActiveSceneView.camera.transform.position;
                //controller.SceneViewLocation = SceneView.lastActiveSceneView.camera.transform.position;
                controller.VisualizeCurrentCamera(location);
                showRendererTime = Time.realtimeSinceStartup + 5f;
            }
            
            // Check if the selected renderer should be displayed
            if (controller.SelectedRenderer != null && Time.realtimeSinceStartup < showRendererTime)
            {
                EditorGUILayout.ObjectField("Selected Renderer", controller.SelectedRenderer, typeof(MeshRenderer), true);
            }
            
            if (isVisualizing)
            {
                GUI.color = Color.red;
                if (GUILayout.Button("Visualizing..."))
                {
                    StopVisualization();
                }
                GUI.color = Color.white;
            }
            else
            {   
                GUI.color = Color.green;
                if (GUILayout.Button("Visualize for 30 seconds"))
                {
                    StartVisualization();
                }
                GUI.color = Color.white;
            }
        }
        
        private void StartVisualization()
        {
            if (activeCoroutine != null)
                return;
            
            isVisualizing = true;
            visualizeEndTime = Time.realtimeSinceStartup + 30f;
            nextVisualizeTime = 0f;
            activeCoroutine = EditorCoroutineUtility.StartCoroutine(Visualize(), this);
        }

        private void StopVisualization()
        {
            isVisualizing = false;
            EditorCoroutineUtility.StopCoroutine(activeCoroutine);
            activeCoroutine = null;
            OnInspectorGUI(); //Force it, as it won't change if youre not moving, ignoring the coroutine.
        }

        private void UpdateVisualization(EnvironmentTransitionController controller)
        {
            if (controller == null || Time.realtimeSinceStartup > visualizeEndTime)
            {
                StopVisualization();
                return;
            }

            if (Time.realtimeSinceStartup > nextVisualizeTime)
            {
                Vector3 location = SceneView.lastActiveSceneView.camera.transform.position;
                controller.VisualizeCurrentCamera(location);
                UnityEngine.Debug.Log($"We're updating again");
                nextVisualizeTime = Time.realtimeSinceStartup + 0.1f;
            }
        }

        private IEnumerator Visualize()
        {
            while (Time.realtimeSinceStartup < visualizeEndTime)
            {
                UpdateVisualization(controller);
                yield return null; //limitation of editor coroutines is null only
            }

            StopVisualization();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Seurat/EnvironmentTransitionControllerEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Seurat/SeuratEnvironmentEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e53fbbaba5f076d4d989e5ef616931f7
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Seurat
{
    public class SeuratEnvironmentEditor : EditorWindow
    {
        public Texture mainTexture;
        public GameObject prefabToApply;

        [MenuItem("LogicalDox/Seurat/Create Seurat Environment")]
        static private void Init()
        {
            SeuratEnvironmentEditor window = (SeuratEnvironmentEditor)GetWindow(typeof(SeuratEnvironmentEditor));
            window.Show();
        }

        private void OnGUI()
        {
            GUILayout.Label("Create Seurat Environment", EditorStyles.boldLabel);

            mainTexture = (Texture)EditorGUILayout.ObjectField("Main Texture", mainTexture, typeof(Texture), false);
            prefabToApply = (GameObject)EditorGUILayout.ObjectField("Prefab to Apply Settings To", prefabToApply,
                typeof(GameObject), false);

            if (GUILayout.Button("Create and Apply Settings"))
            {
                CreateSeuratEnvironment();
            }
        }

        GameObject FindLastChild(GameObject parent)
        {
            Transform lastTransform = FindLastTransform(parent.transform);
            return lastTransform != null ? lastTransform.gameObject : null;
        }
        Transform FindLastTransform(Transform parent)
        {
            if (parent.childCount == 0)
            {
                return parent;
            }

            Transform lastChildObject = parent.GetChild(parent.childCount - 1);
            return FindLastTransform(lastChildObject);
        }

        private void CreateSeuratEnvironment()
        {
            if (prefabToApply == null)
            {
                Debug.LogError("SEURAT: Prefab to apply settings to is not assigned.");
                return;
            }

            GameObject instance = PrefabUtility.InstantiatePrefab(prefabToApply) as GameObject;
            if (instance == null)
            {
                Debug.LogError("SEURAT: Failed to instantiate prefab.");
                return;
            }

            GameObject lastChildObject = FindLastChild(instance);
            SeuratEnvironment seuratEnv = lastChildObject.AddComponent<SeuratEnvironment>();
            seuratEnv.SetReferenceObject(lastChildObject.transform, mainTexture);
            seuratEnv.ApplyMaterialToLastChild();
            seuratEnv.Start();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Seurat/SeuratEnvironmentEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/FilterVisualizer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f844d5d1a7a75734795b901724513d80
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using UnityEngine;
using System.Collections.Generic;
using System.Globalization;

namespace Ldx.Framework.Utilities.SoundBrowser
{
    /// <summary>
    /// Editor utility class for drawing high pass and low pass filter visualizations
    /// </summary>
    public static class FilterVisualizer
    {
        private const int GRAPH_RESOLUTION = 200;
        private const float SQUARE_SIZE = 10f;
        private const float MIN_FREQ = 10f;
        private const float MAX_FREQ = 22000f;
        
        private static readonly Color BackgroundColor = new(0.2f, 0.2f, 0.2f, 1f);
        private static readonly Color GridColor = new(0.3f, 0.3f, 0.3f, 0.5f);
        private static readonly Color LowPassColor = new(0.7f, 0.3f, 0.7f);
        private static readonly Color HighPassColor = new(0.3f, 0.7f, 0.7f);
        private static readonly Color FilterAreaColor = new(0.5f, 0.5f, 0.8f, 0.3f);
        private static readonly Color DefaultHandlesColor = Handles.color;
        private static readonly Color UnityGainColor = new(0.3f, 0.6f, 0.9f, 0.5f);
        
        private static readonly List<Vector3> PointCache = new(GRAPH_RESOLUTION + 1);
        
        private static readonly GUIStyle Style = new(EditorStyles.miniLabel)
        {
            normal = { textColor = Color.white }
        };

        /// <summary>
        /// Draw visualizations for audio filters (low pass and high pass)
        /// </summary>
        public static void DrawFilterVisualization(
            Rect rect,
            bool useLowPass,
            float lowPassCutoff,
            float lowPassQ,
            bool useHighPass,
            float highPassCutoff,
            float highPassQ)
        {
            if (!useLowPass && !useHighPass)
            {
                return;
            }
            
            EditorGUI.DrawRect(rect, BackgroundColor);
            DrawFilterGrid(rect);
            
            // Draw unity gain line at 2/3 from the top
            float unityGainY = rect.y + rect.height * 2/3;
            Handles.color = UnityGainColor;
            Handles.DrawLine(new Vector3(rect.x, unityGainY), new Vector3(rect.xMax, unityGainY));
            Handles.color = DefaultHandlesColor;
            
            if (useLowPass)
            {
                DrawLowPassFilter(rect, lowPassCutoff, lowPassQ, MIN_FREQ, MAX_FREQ, unityGainY);
            }
            
            if (useHighPass)
            {
                DrawHighPassFilter(rect, highPassCutoff, highPassQ, MIN_FREQ, MAX_FREQ, unityGainY);
            }
            
            // Draw passband area (overlap between filters) if both filters active and overlapping
            if (useLowPass && useHighPass && highPassCutoff < lowPassCutoff)
            {
                DrawPassbandArea(rect, lowPassCutoff, highPassCutoff, MIN_FREQ, MAX_FREQ, unityGainY);
            }
            
            DrawFrequencyLabels(rect, MIN_FREQ, MAX_FREQ);
            
            // Draw legend
            Rect legendRect = new(
                rect.x + 10, 
                rect.yMax + 15,
                rect.width - 20, 
                20);
                
            DrawFilterLegend(legendRect, useLowPass, useHighPass);
        }
        
        private static void DrawFilterGrid(Rect rect)
        {
            Handles.color = GridColor;
            
            // Draw horizontal lines
            for (int i = 0; i <= 3; i++)
            {
                float y = rect.y + (rect.height * i / 3);
                Handles.DrawLine(new Vector3(rect.x, y), new Vector3(rect.xMax, y));
            }
            
            // Draw log-spaced vertical lines for frequencies
            float[] frequencyMarkers = {20, 100, 1000, 10000, 20000};
            
            foreach (float freq in frequencyMarkers)
            {
                float normalizedX = Mathf.Log10(freq / MIN_FREQ) / Mathf.Log10(MAX_FREQ / MIN_FREQ);
                float x = rect.x + normalizedX * rect.width;
                
                Handles.DrawLine(new Vector3(x, rect.y), new Vector3(x, rect.yMax));
            }
            
            Handles.color = DefaultHandlesColor;
        }
        
        private static void DrawFrequencyLabels(Rect rect, float minFreq, float maxFreq)
        {
            float[] majorFrequencyMarkers = {20, 100, 1000, 10000, 20000};
            
            foreach (float freq in majorFrequencyMarkers)
            {
                float normalizedX = Mathf.Log10(freq / minFreq) / Mathf.Log10(maxFreq / minFreq);
                float x = rect.x + normalizedX * rect.width;
                
                string label = freq >= 1000 ? $"{freq / 1000}k" : freq.ToString(CultureInfo.CurrentCulture);
                
                Rect labelRect = new(
                    x - 15,
                    rect.yMax + 2,
                    30,
                    15
                );
                
                GUI.Label(labelRect, label, Style);
            }
        }
        
        private static void DrawLowPassFilter(Rect rect, float cutoffFrequency, float q, float minFreq, float maxFreq, float unityGainY)
        {
            PointCache.Clear();
            
            // Convert cutoff to x position
            float normalizedCutoff = Mathf.Log10(cutoffFrequency / minFreq) / Mathf.Log10(maxFreq / minFreq);
            float cutoffX = rect.x + normalizedCutoff * rect.width;
            
            // Starting points for filled area
            PointCache.Add(new Vector3(rect.x, unityGainY, 0));
            
            // Simple second-order low-pass filter response
            for (int i = 0; i <= GRAPH_RESOLUTION; i++)
            {
                float t = i / (float)GRAPH_RESOLUTION;
                float freq = Mathf.Pow(10, Mathf.Lerp(Mathf.Log10(minFreq), Mathf.Log10(maxFreq), t));
                
                float x = rect.x + t * rect.width;
                
                // Normalized frequency (f/fc)
                float w = freq / cutoffFrequency;
                
                // Calculate magnitude response using standard biquad filter equation
                float magnitude;
                if (q <= 1.0f)
                {
                    // No resonance case - just use simple rolloff
                    float wSquared = w * w;
                    magnitude = 1.0f / Mathf.Sqrt(1.0f + wSquared);
                }
                else
                {
                    // With resonance case - standard resonant low-pass filter equation
                    float wSquared = w * w;
                    float denominator = Mathf.Sqrt((1.0f - wSquared) * (1.0f - wSquared) + wSquared / (q * q));
                    magnitude = 1.0f / denominator;
                    
                    // Limit magnitude to avoid extremely high values with high Q
                    magnitude = Mathf.Min(magnitude, 10.0f);
                }
                
                // Map magnitude to visual position
                float y;
                if (magnitude >= 1.0f)
                {
                    // Map resonance peaks above unity gain
                    float peakHeight = rect.height * 2/3; // From unity gain to top
                    y = unityGainY - (peakHeight * (magnitude - 1.0f) / 9.0f); // Scale to fit
                }
                else
                {
                    // Map attenuation below unity gain
                    float attenuationDepth = rect.height / 3; // From unity gain to bottom
                    y = unityGainY + (attenuationDepth * (1.0f - magnitude));
                }
                
                PointCache.Add(new Vector3(x, y, 0));
            }
            
            // Add ending points for filled area
            PointCache.Add(new Vector3(rect.xMax, rect.yMax, 0));
            PointCache.Add(new Vector3(rect.x, rect.yMax, 0));
            
            // Draw filled area under the curve
            Handles.color = new Color(LowPassColor.r, LowPassColor.g, LowPassColor.b, 0.2f);
            Handles.DrawAAConvexPolygon(PointCache.ToArray());
            
            // Remove the added points for the line drawing
            PointCache.RemoveAt(PointCache.Count - 1);
            PointCache.RemoveAt(PointCache.Count - 1);
            PointCache.RemoveAt(0);
            
            // Draw the curve
            Handles.color = LowPassColor;
            Handles.DrawAAPolyLine(2f, PointCache.ToArray());
            
            // Draw cutoff frequency marker
            Handles.color = LowPassColor;
            Handles.DrawLine(new Vector3(cutoffX, rect.y), new Vector3(cutoffX, rect.yMax));
            
            // Find the point closest to cutoff frequency and draw a dot there
            int closestIndex = 0;
            float minDistance = float.MaxValue;
            
            for (int i = 0; i < PointCache.Count; i++)
            {
                float distance = Mathf.Abs(PointCache[i].x - cutoffX);
                if (!(distance < minDistance))
                {
                    continue;
                }
                
                minDistance = distance;
                closestIndex = i;
            }
            
            if (closestIndex < PointCache.Count)
            {
                Handles.DrawSolidDisc(PointCache[closestIndex], Vector3.forward, 3f);
            }
            
            Handles.color = DefaultHandlesColor;
        }
        
        private static void DrawHighPassFilter(Rect rect, float cutoffFrequency, float q, float minFreq, float maxFreq, float unityGainY)
        {
            PointCache.Clear();
            
            // Convert cutoff to x position
            float normalizedCutoff = Mathf.Log10(cutoffFrequency / minFreq) / Mathf.Log10(maxFreq / minFreq);
            float cutoffX = rect.x + normalizedCutoff * rect.width;
            
            // Starting points for filled area
            PointCache.Add(new Vector3(rect.xMax, unityGainY, 0));
            
            // Simple second-order high-pass filter response
            for (int i = GRAPH_RESOLUTION; i >= 0; i--)
            {
                float t = i / (float)GRAPH_RESOLUTION;
                float freq = Mathf.Pow(10, Mathf.Lerp(Mathf.Log10(minFreq), Mathf.Log10(maxFreq), t));
                
                float x = rect.x + t * rect.width;
                
                // Normalized frequency (fc/f) for high-pass
                float w = cutoffFrequency / freq;
                
                // Calculate magnitude response using standard biquad filter equation
                float magnitude;
                
                if (q <= 1.0f)
                {
                    float wSquared = w * w;
                    magnitude = 1.0f / Mathf.Sqrt(1.0f + wSquared);
                }
                else
                {
                    float wSquared = w * w;
                    float denominator = Mathf.Sqrt((1.0f - wSquared) * (1.0f - wSquared) + wSquared / (q * q));
                    magnitude = 1.0f / denominator;
                    magnitude = Mathf.Min(magnitude, 10.0f);
                }
                
                // Map magnitude to visual position
                float y;
                if (magnitude >= 1.0f)
                {
                    // Map resonance peaks above unity gain
                    float peakHeight = rect.height * 2/3; // From unity gain to top
                    y = unityGainY - (peakHeight * (magnitude - 1.0f) / 9.0f); // Scale to fit
                }
                else
                {
                    // Map attenuation below unity gain
                    float attenuationDepth = rect.height / 3;
                    y = unityGainY + (attenuationDepth * (1.0f - magnitude));
                }
                
                PointCache.Add(new Vector3(x, y, 0));
            }
            
            // Add ending points for filled area
            PointCache.Add(new Vector3(rect.x, rect.yMax, 0));
            PointCache.Add(new Vector3(rect.xMax, rect.yMax, 0));
            
            // Draw filled area under the curve
            Handles.color = new Color(HighPassColor.r, HighPassColor.g, HighPassColor.b, 0.2f);
            Handles.DrawAAConvexPolygon(PointCache.ToArray());
            
            // Remove the added points for the line drawing
            PointCache.RemoveAt(PointCache.Count - 1);
            PointCache.RemoveAt(PointCache.Count - 1);
            PointCache.RemoveAt(0);
            
            // Draw the curve
            Handles.color = HighPassColor;
            Handles.DrawAAPolyLine(2f, PointCache.ToArray());
            
            // Draw cutoff frequency marker
            Handles.color = HighPassColor;
            Handles.DrawLine(new Vector3(cutoffX, rect.y), new Vector3(cutoffX, rect.yMax));
            
            // Find the point closest to cutoff frequency and draw a dot there
            int closestIndex = 0;
            float minDistance = float.MaxValue;
            
            for (int i = 0; i < PointCache.Count; i++)
            {
                float distance = Mathf.Abs(PointCache[i].x - cutoffX);
                if (!(distance < minDistance))
                {
                    continue;
                }
                
                minDistance = distance;
                closestIndex = i;
            }
            
            if (closestIndex < PointCache.Count)
            {
                Handles.DrawSolidDisc(PointCache[closestIndex], Vector3.forward, 3f);
            }
            
            Handles.color = DefaultHandlesColor;
        }
        
        private static void DrawPassbandArea(Rect rect, float lowPassCutoff, float highPassCutoff, float minFreq, float maxFreq, float unityGainY)
        {
            float normalizedHighPass = Mathf.Log10(highPassCutoff / minFreq) / Mathf.Log10(maxFreq / minFreq);
            float highPassX = rect.x + normalizedHighPass * rect.width;
            
            float normalizedLowPass = Mathf.Log10(lowPassCutoff / minFreq) / Mathf.Log10(maxFreq / minFreq);
            float lowPassX = rect.x + normalizedLowPass * rect.width;
            
            // Draw passband area from high pass to low pass cutoff
            Rect passbandRect = new(
                highPassX,
                unityGainY - rect.height / 6,
                lowPassX - highPassX,
                rect.height / 3
            );
            
            EditorGUI.DrawRect(passbandRect, FilterAreaColor);
        }
        
        private static void DrawFilterLegend(Rect rect, bool showLowPass, bool showHighPass)
        {
            float itemWidth = rect.width / 3;
            float currentX = rect.x;
            
            if (showLowPass)
            {
                DrawLegendItem(new Rect(currentX, rect.y, itemWidth, rect.height), "Low Pass", LowPassColor);
                currentX += itemWidth;
            }
            
            if (showHighPass)
            {
                DrawLegendItem(new Rect(currentX, rect.y, itemWidth, rect.height), "High Pass", HighPassColor);
                currentX += itemWidth;
            }
            
            if (showLowPass && showHighPass)
            {
                DrawLegendItem(new Rect(currentX, rect.y, itemWidth, rect.height), "Passband", FilterAreaColor);
            }
        }
        
        private static void DrawLegendItem(Rect rect, string label, Color color)
        {
            Rect colorRect = new(rect.x, rect.y + (rect.height - SQUARE_SIZE) / 2, SQUARE_SIZE, SQUARE_SIZE);
            
            EditorGUI.DrawRect(colorRect, color);
            EditorGUI.LabelField(
                new Rect(rect.x + SQUARE_SIZE + 5, rect.y, rect.width - SQUARE_SIZE - 5, rect.height), 
                label);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/FilterVisualizer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/RolloffVisualizer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 3bee3a612809d6c4285228493814e883
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.SoundBrowser
{
    /// <summary>
    /// Editor utility class for drawing volume rolloff curves in editor windows
    /// </summary>
    public static class RolloffVisualizer
    {
        private const int GRAPH_RESOLUTION = 100;
        private const float GRAPH_PADDING = 5f;
        private const float LOGARITHMIC_ROLLOFF_FACTOR = 20f;
        private const float SQUARE_SIZE = 10f;
        
        public static readonly Color VolumeColor = new(1f, 0.3f, 0.3f);
        private static readonly Color SpatialBlendColor = new(0.3f, 1f, 0.3f);
        private static readonly Color SpreadColor = new(0.3f, 0.3f, 1f);
        private static readonly Color ReverbMixColor = new(1f, 1f, 0.3f);
        private static readonly Color GridColor = new (0.3f, 0.3f, 0.3f, 0.5f);
        private static readonly Color DefaultHandlesColor = Handles.color;
        
        private static readonly List<Vector3> PointCache = new(GRAPH_RESOLUTION);
        
        /// <summary>
        /// Draw a visualization of the volume rolloff curve in the given rect
        /// </summary>
        public static void DrawRolloffCurve(
            Rect rect,
            float minDistance,
            float maxDistance,
            AudioRolloffMode rolloffMode,
            bool showSpatialBlend,
            float spatialBlend,
            bool showSpread,
            float spread,
            bool showReverbMix,
            float reverbMix,
            AnimationCurve customCurve = null)
        {
            // Calculate space for legend (outside graph)
            const float legendHeight = 25;
            const float xAxisLabelsHeight = 20;
            
            Rect graphRect = new(
                rect.x + GRAPH_PADDING,
                rect.y + GRAPH_PADDING,
                rect.width - (GRAPH_PADDING * 2),
                rect.height - (GRAPH_PADDING * 2) - legendHeight - xAxisLabelsHeight);
            
            // Draw background
            EditorGUI.DrawRect(graphRect, new Color(0.2f, 0.2f, 0.2f));
            
            DrawGrid(graphRect, maxDistance);
            
            DrawDistanceMarkers(graphRect, minDistance, maxDistance);
            
            if (showSpatialBlend)
            {
                DrawHorizontalLine(graphRect, spatialBlend, SpatialBlendColor);
            }
            
            if (showSpread)
            {
                DrawHorizontalLine(graphRect, spread / 360f, SpreadColor);
            }
            
            if (showReverbMix)
            {
                DrawHorizontalLine(graphRect, reverbMix > 1f ? 1f : reverbMix, ReverbMixColor);
            }
            
            if (rolloffMode == AudioRolloffMode.Custom && customCurve != null)
            {
                DrawCustomRolloffCurve(graphRect, customCurve, minDistance, maxDistance);
            }
            else 
            {
                DrawVolumeRolloff(graphRect, minDistance, maxDistance, rolloffMode);
            }
            
            DrawDistanceLabels(graphRect, maxDistance);
            
            Rect legendRect = new(
                rect.x + 10, 
                graphRect.yMax + xAxisLabelsHeight, 
                rect.width - 20, 
                legendHeight);
                
            DrawLegend(legendRect, showSpatialBlend, showSpread, showReverbMix);
        }
        
        private static void DrawGrid(Rect rect, float maxDistance)
        {
            Handles.color = GridColor;
            
            for (int i = 0; i <= 4; i++)
            {
                float y = rect.y + rect.height * (1 - (i / 4f));
                Handles.DrawLine(new Vector3(rect.x, y), new Vector3(rect.xMax, y));
                
                float value = i * 0.25f;
                GUI.Label(new Rect(rect.x, y - 10, 30, 20), value.ToString("0.0"));
            }
            
            float[] distanceMarkers = CalculateDistanceMarkers(maxDistance);
            foreach (float distance in distanceMarkers)
            {
                float x = rect.x + (distance / maxDistance) * rect.width;
                if (x <= rect.xMax)
                {
                    Handles.DrawLine(new Vector3(x, rect.y), new Vector3(x, rect.yMax));
                }
            }
            
            Handles.color = DefaultHandlesColor;
        }
        
        private static void DrawDistanceLabels(Rect rect, float maxDistance)
        {
            float[] distanceMarkers = CalculateDistanceMarkers(maxDistance);
            
            foreach (float distance in distanceMarkers)
            {
                float x = rect.x + (distance / maxDistance) * rect.width;
                if (!(x <= rect.xMax))
                {
                    continue;
                }
                
                string label = distance.ToString("0");
                GUI.Label(new Rect(x - 15, rect.yMax + 5, 30, 20), label);
            }
        }
        
        private static float[] CalculateDistanceMarkers(float maxDistance)
        {
            float interval = maxDistance switch
            {
                <= 10 => 1,
                <= 50 => 10,
                <= 100 => 25,
                <= 500 => 50,
                _ => 100
            };

            int numMarkers = Mathf.CeilToInt(maxDistance / interval) + 1;
            float[] markers = new float[numMarkers];
            
            for (int i = 0; i < numMarkers; i++)
            {
                markers[i] = i * interval;
            }
            
            return markers;
        }
        
        private static void DrawDistanceMarkers(Rect rect, float minDistance, float maxDistance)
        {
            float minX = rect.x + (minDistance / maxDistance) * rect.width;
            if (minX <= rect.xMax)
            {
                Handles.color = Color.yellow;
                Handles.DrawLine(
                    new Vector3(minX, rect.y), 
                    new Vector3(minX, rect.yMax));
            }
            
            float maxX = rect.x + rect.width;
            Handles.color = Color.red;
            Handles.DrawLine(
                new Vector3(maxX, rect.y), 
                new Vector3(maxX, rect.yMax));

            Handles.color = DefaultHandlesColor;
        }
        
        private static void DrawCustomRolloffCurve(
            Rect rect, 
            AnimationCurve curve,
            float minDistance,
            float maxDistance)
        {
            PointCache.Clear();
            
            float startX = rect.x;
            float startY = rect.y;
            PointCache.Add(new Vector3(startX, startY, 0));
            
            float minDistX = rect.x + (minDistance / maxDistance) * rect.width;
            PointCache.Add(new Vector3(minDistX, startY, 0));
            
            for (int i = 0; i <= GRAPH_RESOLUTION; i++)
            {
                float t = i / (float)GRAPH_RESOLUTION;
                
                float distance = Mathf.Lerp(minDistance, maxDistance, t);
                float normalizedDistance = (distance - minDistance) / (maxDistance - minDistance);
                normalizedDistance = Mathf.Clamp01(normalizedDistance);
                
                float volume = curve.Evaluate(normalizedDistance);
                
                float x = rect.x + (distance / maxDistance) * rect.width;
                float y = rect.y + (1 - volume) * rect.height;
                
                PointCache.Add(new Vector3(x, y, 0));
            }
            
            Handles.color = VolumeColor;
            Handles.DrawAAPolyLine(2f, PointCache.ToArray());

            if (curve.keys.Length <= 0)
            {
                return;
            }
            
            Handles.color = Color.white;
            foreach (Keyframe key in curve.keys)
            {
                float mappedX = minDistance + key.time * (maxDistance - minDistance);
                float x = rect.x + (mappedX / maxDistance) * rect.width;
                float y = rect.y + (1 - key.value) * rect.height;
                
                Handles.DrawSolidDisc(new Vector3(x, y, 0), Vector3.forward, 3f);
            }

            Handles.color = DefaultHandlesColor;
        }
        
        private static void DrawVolumeRolloff(
            Rect rect, 
            float minDistance, 
            float maxDistance, 
            AudioRolloffMode rolloffMode)
        {
            PointCache.Clear();
            
            float startX = rect.x;
            float startY = rect.y;
            PointCache.Add(new Vector3(startX, startY, 0));
            
            float minDistX = rect.x + (minDistance / maxDistance) * rect.width;
            PointCache.Add(new Vector3(minDistX, startY, 0));
            
            for (int i = 0; i <= GRAPH_RESOLUTION; i++)
            {
                float t = i / (float)GRAPH_RESOLUTION;
                float distance = Mathf.Lerp(minDistance, maxDistance, t);
                float volume = CalculateRolloffVolume(distance, minDistance, maxDistance, rolloffMode);
                
                float x = rect.x + (distance / maxDistance) * rect.width;
                float y = rect.y + (1 - volume) * rect.height;
                
                PointCache.Add(new Vector3(x, y, 0));
            }
            
            Handles.color = VolumeColor;
            Handles.DrawAAPolyLine(2f, PointCache.ToArray());
            Handles.color = DefaultHandlesColor;
        }
        
        private static float CalculateRolloffVolume(
            float distance, 
            float minDistance, 
            float maxDistance,
            AudioRolloffMode rolloffMode)
        {
            if (distance < minDistance)
            {
                return 1f;
            }
                
            if (distance > maxDistance && rolloffMode != AudioRolloffMode.Custom)
            {
                return 0f;
            }
                
            switch (rolloffMode)
            {
                case AudioRolloffMode.Logarithmic:
                    return minDistance / (minDistance + (LOGARITHMIC_ROLLOFF_FACTOR * (distance - minDistance)));
                case AudioRolloffMode.Linear:
                    return 1f - ((distance - minDistance) / (maxDistance - minDistance));
                case AudioRolloffMode.Custom:
                    return Mathf.Exp(-(distance - minDistance) / (maxDistance - minDistance));
                default:
                    Debug.LogError($"{rolloffMode} is not supported in the Rolloff Visualizer, Defaulting to Linear.");
                    return 1f - ((distance - minDistance) / (maxDistance - minDistance));
            }
        }
        
        private static void DrawHorizontalLine(Rect rect, float value, Color color)
        {
            float y = rect.y + (1 - value) * rect.height;
            Handles.color = color;
            Handles.DrawLine(new Vector3(rect.x, y), new Vector3(rect.xMax, y));
            Handles.color = DefaultHandlesColor;
        }
        
        private static void DrawLegend(Rect rect, bool showSpatialBlend, bool showSpread, bool showReverbMix)
        {
            float itemWidth = rect.width / 4;
            float currentX = rect.x;
            
            DrawLegendItem(new Rect(currentX, rect.y, itemWidth, rect.height), "Volume", VolumeColor);
            currentX += itemWidth;
            
            if (showSpatialBlend)
            {
                DrawLegendItem(new Rect(currentX, rect.y, itemWidth, rect.height), "Spatial Blend", SpatialBlendColor);
                currentX += itemWidth;
            }
            
            if (showSpread)
            {
                DrawLegendItem(new Rect(currentX, rect.y, itemWidth, rect.height), "Spread", SpreadColor);
                currentX += itemWidth;
            }
            
            if (showReverbMix)
            {
                DrawLegendItem(new Rect(currentX, rect.y, itemWidth, rect.height), "Reverb Zone Mix", ReverbMixColor);
            }
        }
        
        private static void DrawLegendItem(Rect rect, string label, Color color)
        {
            Rect colorRect = new(rect.x, rect.y + (rect.height - SQUARE_SIZE) / 2, SQUARE_SIZE, SQUARE_SIZE);
            
            EditorGUI.DrawRect(colorRect, color);
            EditorGUI.LabelField(
                new Rect(rect.x + SQUARE_SIZE + 5, rect.y, rect.width - SQUARE_SIZE - 5, rect.height), 
                label);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/RolloffVisualizer.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/SelectableElement.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 287e0ee899ce9304a80cc898f98cd28a
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Systems.AudioSystem;
using UnityEngine;
using UnityEngine.UIElements;

namespace Ldx.Framework.Utilities.SoundBrowser
{
    /// <summary>
    /// Base class for an element that can be selected in the Sound Browser.
    /// Contains any necessary data for the element.
    /// Handles hovering, selecting, dragging, etc, with a reference to the visual
    /// element that represents the data.
    /// </summary>
    public abstract class SelectableElement : PointerManipulator
    {
        protected const string SOUND_BROWSER_FOLDER_CLASS_NAME = "folder";
        protected const string SOUND_BROWSER_SOUND_CLASS_NAME = "sound";
        private const string SOUND_BROWSER_MOVE_OVER_FOLDER_CLASS_NAME = "move-over-folder";
        private const string SOUND_BROWSER_MOVE_OVER_FILE_CLASS_NAME = "move-over-file";
        private const string HOVER_CLASS = "selectable-hover";
        private const string SELECTED_CLASS = "selectable-selected";
        
        public event Action<SelectableElement> OnSelected;
        
        /// <summary>
        /// The first argument is this selectable element. The second is the visual element representing
        /// the folder that this element has been moved to.
        /// </summary>
        public event Action<SelectableElement, VisualElement> OnMovedToFolder;

        protected Label Label => (Label)target;

        private bool selected;

        private bool Selected
        {
            get => selected;
            set
            {
                selected = value;
                if (value)
                {
                    target.RemoveFromClassList(HOVER_CLASS);
                    target.AddToClassList(SELECTED_CLASS);
                }
                else
                {
                    target.RemoveFromClassList(SELECTED_CLASS);
                }
                UpdateLabel();
                OnSelectedValueChanged(value);
                
                if (selected) OnSelected?.Invoke(this);
            }
        }

        /// <summary>
        /// The Visual Element containing all selectables.
        /// </summary>
        private readonly VisualElement selectablesParentElement;
        
        /// <summary>
        /// The path to the asset as used by AssetDatabase.LoadAssetAtPath.
        /// </summary>
        public string AssetPath { get; }

        /// <summary>
        /// The path to the Sound asset after the Sounds/ directory.
        /// </summary>
        public string SimplifiedPath => AudioGlobalSettings.EDITOR_GetSimplifiedPathFromAssetPath(AssetPath);

        /// <summary>
        /// The name of the file or folder without directories or filetype specified.
        /// </summary>
        public string Name => AudioGlobalSettings.EDITOR_GetFileOrFolderNameFromAssetPath(AssetPath);
        
        /// <summary>
        /// The path to the folder containing this asset as used by AssetDatabase.LoadAssetAtPath.
        /// </summary>
        public abstract string ContainingFolderAssetPath { get; }
        
        private VisualElement lastOverlappedSlot;
        private string lastMoveOverElementClassName;
        
        private Vector2 targetStartPosition;
        private Vector3 pointerStartPosition;
        private bool enabled;
        
        protected SelectableElement(VisualElement selectablesParentElement, string assetPath)
        {
            this.selectablesParentElement = selectablesParentElement;
            AssetPath = assetPath;
            target = new Label(Name);
            targetStartPosition = target.transform.position;
            target.AddToClassList(SoundBrowserWindow.SOUND_BROWSER_GENERAL_CLASS_NAME);
            target.AddToClassList(SoundBrowserWindow.SOUND_BROWSER_SELECTABLE_CLASS_NAME);
        }

        public virtual void UpdateLabel()
        {
        }
        
        /// <summary>
        /// Programmatically select this element
        /// </summary>
        public void Select()
        {
            Selected = true;
        }
        
        protected override void RegisterCallbacksOnTarget()
        {
            target.RegisterCallback<PointerEnterEvent>(PointerEnterHandler);
            target.RegisterCallback<PointerLeaveEvent>(PointerLeaveHandler);
            target.RegisterCallback<PointerDownEvent>(PointerDownHandler);
            target.RegisterCallback<PointerUpEvent>(PointerUpHandler);
            target.RegisterCallback<PointerMoveEvent>(PointerMoveHandler);
            target.RegisterCallback<PointerCaptureOutEvent>(PointerCaptureOutHandler);
        }

        protected override void UnregisterCallbacksFromTarget()
        {
            target.UnregisterCallback<PointerEnterEvent>(PointerEnterHandler);
            target.UnregisterCallback<PointerLeaveEvent>(PointerLeaveHandler);
            target.UnregisterCallback<PointerDownEvent>(PointerDownHandler);
            target.UnregisterCallback<PointerUpEvent>(PointerUpHandler);
            target.UnregisterCallback<PointerMoveEvent>(PointerMoveHandler);
            target.UnregisterCallback<PointerCaptureOutEvent>(PointerCaptureOutHandler);
        }

        protected virtual void OnSelectedValueChanged(bool value)
        {
        }

        private void PointerEnterHandler(PointerEnterEvent evt)
        {
            if (!Selected)
            {
                target.AddToClassList(HOVER_CLASS);
            }
        }

        private void PointerLeaveHandler(PointerLeaveEvent evt)
        {
            target.RemoveFromClassList(HOVER_CLASS);
        }

        public void Deselect()
        {
            Selected = false;
            target.RemoveFromClassList(SELECTED_CLASS);
            target.transform.position = targetStartPosition;
        }

        /// <summary>
        /// This method selects the element, stores the starting position of target and the pointer,
        /// makes target capture the pointer, and denotes that a drag is now in progress.
        /// </summary>
        private void PointerDownHandler(PointerDownEvent evt)
        {
            Selected = true;
            pointerStartPosition = evt.position;
            target.CapturePointer(evt.pointerId);
            enabled = true;
        }

        /// <summary>
        /// This method checks whether a drag is in progress and whether target has captured the pointer.
        /// If both are true, calculates a new position for target within the bounds of the window.
        /// </summary>
        private void PointerMoveHandler(PointerMoveEvent evt)
        {
            if (enabled && target.HasPointerCapture(evt.pointerId))
            {
                Vector3 pointerDelta = evt.position - pointerStartPosition;

                // Note: The minimums here are arbitrary
                target.transform.position = new Vector2(
                    Mathf.Clamp(targetStartPosition.x + pointerDelta.x, -1000, target.panel.visualTree.worldBound.width),
                    Mathf.Clamp(targetStartPosition.y + pointerDelta.y, -1000, target.panel.visualTree.worldBound.height));
                
                UQueryBuilder<VisualElement> allSlots = selectablesParentElement.Query<VisualElement>(className: SoundBrowserWindow.SOUND_BROWSER_SELECTABLE_CLASS_NAME);
                UQueryBuilder<VisualElement> overlappingSlots = allSlots.Where(OverlapsTarget);
                VisualElement closestOverlappingSlot = FindClosestSlot(overlappingSlots);
                
                if (closestOverlappingSlot == null || closestOverlappingSlot == target)
                {
                    ClearMoveOverClassFromLastOverlappedSlot();
                }
                else if (closestOverlappingSlot != lastOverlappedSlot)
                {
                    ClearMoveOverClassFromLastOverlappedSlot();

                    if (closestOverlappingSlot.ClassListContains(SOUND_BROWSER_FOLDER_CLASS_NAME))
                        lastMoveOverElementClassName = SOUND_BROWSER_MOVE_OVER_FOLDER_CLASS_NAME;
                    else if (closestOverlappingSlot.ClassListContains(SOUND_BROWSER_SOUND_CLASS_NAME))
                        lastMoveOverElementClassName = SOUND_BROWSER_MOVE_OVER_FILE_CLASS_NAME;

                    closestOverlappingSlot.AddToClassList(lastMoveOverElementClassName);
                }
                
                lastOverlappedSlot = closestOverlappingSlot;
            }
        }

        private void ClearMoveOverClassFromLastOverlappedSlot()
        {
            if (lastOverlappedSlot != null && lastMoveOverElementClassName != null)
            {
                lastOverlappedSlot.RemoveFromClassList(lastMoveOverElementClassName);
            }
        }

        /// <summary>
        /// Checks whether a drag is in progress and whether target has captured the pointer.
        /// If both are true, makes target release the pointer.
        /// </summary>
        private void PointerUpHandler(PointerUpEvent evt)
        {
            if (enabled && target.HasPointerCapture(evt.pointerId))
            {
                target.ReleasePointer(evt.pointerId);
            }
        }

        /// <summary>
        /// Checks whether a drag has ended. If the element is overlapping another it can move to,
        /// invokes an event to let the sound browser window know to move the relevant file/folder
        /// to that new folder. Sets the position of target back to its original position if there
        /// is no overlapping folder.
        /// </summary>
        private void PointerCaptureOutHandler(PointerCaptureOutEvent evt)
        {
            if (enabled)
            {
                if (lastOverlappedSlot != null && lastOverlappedSlot != target)
                {
                    OnMovedToFolder?.Invoke(this, lastOverlappedSlot);
                }
                target.transform.position = targetStartPosition;

                ClearMoveOverClassFromLastOverlappedSlot();
                
                lastOverlappedSlot = null;
                lastMoveOverElementClassName = null;
                enabled = false;
            }
        }

        private bool OverlapsTarget(VisualElement slot)
        {
            return target.worldBound.Overlaps(slot.worldBound);
        }

        private VisualElement FindClosestSlot(UQueryBuilder<VisualElement> slots)
        {
            List<VisualElement> slotsList = slots.ToList();
            float bestDistanceSq = float.MaxValue;
            VisualElement closest = null;
            foreach (VisualElement slot in slotsList)
            {
                Vector3 displacement = RootSpaceOfSlot(slot) - target.transform.position;
                float distanceSq = displacement.sqrMagnitude;
                if (distanceSq < bestDistanceSq)
                {
                    bestDistanceSq = distanceSq;
                    closest = slot;
                }
            }
            return closest;
        }

        private Vector3 RootSpaceOfSlot(VisualElement slot)
        {
            Vector2 slotWorldSpace = slot.parent.LocalToWorld(slot.layout.position);
            return selectablesParentElement.WorldToLocal(slotWorldSpace);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/SelectableElement.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/SelectableFolder.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 146483782d3974049ac236430c180687
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using System.Text;
using UnityEngine.UIElements;

namespace Ldx.Framework.Utilities.SoundBrowser
{
    /// <summary>
    /// A folder element in the sound browser which can be expanded
    /// and which contains a list of all the elements that the folder contains.
    /// </summary>
    public class SelectableFolder : SelectableElement
    {
        private const char COLLAPSED_CHAR = '';
        private const char EXPANDED_CHAR = '';

        private string customDisplayNameOverride;
        
        public bool IsExpanded { get; private set; }

        private List<SelectableElement> containedElements = new List<SelectableElement>();
        public List<SelectableElement> ContainedElements => containedElements;

        public override string ContainingFolderAssetPath
        {
            get
            {
                int nameLength = Name.Length;
                return AssetPath.Remove(AssetPath.Length - nameLength - 1);
            }
        }

        public SelectableFolder(VisualElement selectableArea, string assetPath) : base(selectableArea, assetPath)
        {
            target.AddToClassList(SOUND_BROWSER_FOLDER_CLASS_NAME);
            int amt = containedElements.Count;
            Label.text = $"{COLLAPSED_CHAR} {Label.text} ({amt} item{(amt == 1 ? string.Empty : 's' )})";
        }

        public void SetDisplayName(string name)
        {
            customDisplayNameOverride = name;
            UpdateLabel();
        }
        
        public override void UpdateLabel()
        {
            StringBuilder sb = new StringBuilder();
            int amt = containedElements.Count;
            sb.Append(IsExpanded ? EXPANDED_CHAR : COLLAPSED_CHAR);
            sb.Append(' ');
            sb.Append(string.IsNullOrEmpty(customDisplayNameOverride) ? Name : customDisplayNameOverride);
            sb.Append(' ');
            sb.Append($"({amt} item{(amt == 1 ? string.Empty : 's' )})");
            Label.text = sb.ToString();
        }

        protected override void OnSelectedValueChanged(bool value)
        {
            if (value)
            {
                IsExpanded = !IsExpanded;
            }
        }

        public void AddElementToFolder(SelectableElement element)
        {
            containedElements.Add(element);
        }

        public SelectableElement[] GetElementsInFolder()
        {
            return containedElements.ToArray();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/SelectableFolder.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/SelectableSound.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c76324eb82b9ce042a3e5cbf5c3b1057
# ASMDEF: ldx.framework.editor.dll
# ---
using Ldx.Framework.Systems.AudioSystem;
using UnityEngine.UIElements;

namespace Ldx.Framework.Utilities.SoundBrowser
{
    /// <summary>
    /// A Sound element in the Sound Browser which can be selected
    /// to edit the Sound referenced inside.
    /// </summary>
    public class SelectableSound : SelectableElement
    {
        /// <summary>
        /// Reference to the Sound itself
        /// </summary>
        public Sound Sound { get; }

        public override string ContainingFolderAssetPath => AssetPath.Replace($"/{Name}.asset", string.Empty);

        public SelectableSound(VisualElement selectableArea, string assetPath, Sound sound) : base(selectableArea, assetPath)
        {
            target.AddToClassList(SOUND_BROWSER_SOUND_CLASS_NAME);
            Sound = sound;
        }

    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/SelectableSound.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/SoundBrowserContextMenu.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 48fbfe74899a86f40b8e9b391866739b
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Utilities.SoundBrowser;

namespace Ldx.Framework.Utilities.Attributes
{
    /// <summary>
    /// Provides Project window context menu options for importing audio clips to the Sound Browser allowing you to
    /// right-click a folder to import all audio clips or right-click a selection of audio clips to import those
    /// audio clips into the sound browser. Skips duplicate files.
    /// </summary>
    public static class SoundBrowserContextMenu
    {
        private const string PROJECT_MENU_PREFIX = "Assets/Import to Project Sound Browser/";
        private const string FRAMEWORK_MENU_PREFIX = "Assets/Import to Framework Sound Browser/";
        
        [InitializeOnLoad]
        private static class ProjectWindowSelectionOnRightClick
        {
            static ProjectWindowSelectionOnRightClick()
            {
                EditorApplication.projectWindowItemOnGUI -= HandleProjectWindowItemGUI;
                EditorApplication.projectWindowItemOnGUI += HandleProjectWindowItemGUI;
            }

            private static void HandleProjectWindowItemGUI(string guid, Rect selectionRect)
            {
                Event evt = Event.current;
                if (evt.type != EventType.ContextClick || !selectionRect.Contains(evt.mousePosition))
                {
                    return;
                }
                
                string path = AssetDatabase.GUIDToAssetPath(guid);
                Object obj = AssetDatabase.LoadAssetAtPath<Object>(path);
                if (obj) Selection.activeObject = obj;
            }
        }
        
        #region Validation
        
        [MenuItem(PROJECT_MENU_PREFIX + "Selected Audio Clips", true)]
        [MenuItem(FRAMEWORK_MENU_PREFIX + "Selected Audio Clips", true)]
        private static bool ValidateImportSelectedAudioClips() => GetSelectedAudioClips().Any();

        [MenuItem(PROJECT_MENU_PREFIX + "All Audio In Folder", true)]
        [MenuItem(FRAMEWORK_MENU_PREFIX + "All Audio In Folder", true)]
        private static bool ValidateImportAllAudioInFolder() => Selection.objects.Any(obj => AssetDatabase.IsValidFolder(AssetDatabase.GetAssetPath(obj)));
        
        #endregion

        #region Menu Items

        [MenuItem(PROJECT_MENU_PREFIX + "Selected Audio Clips", false, 20)]
        private static void ImportSelectedAudioClipsToProject() => ImportSelectedAudioClips(AudioGlobalSettings.SOUNDS_ASSET_PATH);
        
        [MenuItem(FRAMEWORK_MENU_PREFIX + "Selected Audio Clips", false, 20)]
        private static void ImportSelectedAudioClipsToFramework() => ImportSelectedAudioClips(AudioGlobalSettings.FRAMEWORK_SOUNDS_ASSET_PATH);

        [MenuItem(PROJECT_MENU_PREFIX + "All Audio In Folder", false, 20)]
        private static void ImportAllAudioInFolderToProject() => ImportAllAudioInSelection(AudioGlobalSettings.SOUNDS_ASSET_PATH);
        
        [MenuItem(FRAMEWORK_MENU_PREFIX + "All Audio In Folder", false, 20)]
        private static void ImportAllAudioInFolderToFramework() => ImportAllAudioInSelection(AudioGlobalSettings.FRAMEWORK_SOUNDS_ASSET_PATH);
        
        #endregion
        
        private static void ImportSelectedAudioClips(string targetRootPath)
        {
            List<string> clipPaths = GetSelectedAudioClips();
            if (!clipPaths.Any()) return;
            ImportAudioClipsToSoundBrowser(clipPaths, targetRootPath);
        }

        private static void ImportAllAudioInSelection(string targetRootPath)
        {
            List<string> clipPaths = new();
            Object[] selectedObjects = Selection.objects;
            if (selectedObjects == null || selectedObjects.Length == 0)
            {
                return;
            }
    
            foreach (Object selectedObj in selectedObjects)
            {
                string path = AssetDatabase.GetAssetPath(selectedObj);
                if (!AssetDatabase.IsValidFolder(path)) continue;
                FindAudioClipsRecursively(path, clipPaths);
            }

            if (!clipPaths.Any())
            {
                EditorUtility.DisplayDialog("Import Audio", "No audio clips found in the selected folder(s).", "OK");
                return;
            }

            ImportAudioClipsToSoundBrowser(clipPaths, targetRootPath);
        }

        private static List<string> GetSelectedAudioClips() => Selection.objects.OfType<AudioClip>().Select(AssetDatabase.GetAssetPath).ToList();

        private static void FindAudioClipsRecursively(string folderPath, List<string> clipPaths)
        {
            string[] guids = AssetDatabase.FindAssets("t:AudioClip", new[] { folderPath });
            foreach(string guid in guids) clipPaths.Add(AssetDatabase.GUIDToAssetPath(guid));
        }

        private static void ImportAudioClipsToSoundBrowser(List<string> clipPaths, string targetRootPath)
        {
            int createdCount = 0, skippedCount = 0;
            AudioGlobalSettings.CheckValidOrCreateSoundsPath();
            EditorUtility.DisplayProgressBar("Importing Audio Clips", "Preparing...", 0f);

            try
            {
                for (int i = 0; i < clipPaths.Count; i++)
                {
                    string clipPath = clipPaths[i];
                    EditorUtility.DisplayProgressBar("Importing Audio Clips", $"Importing {Path.GetFileName(clipPath)}...", (float)i / clipPaths.Count);

                    if (ProcessAudioClip(clipPath, targetRootPath)) createdCount++;
                    else skippedCount++;
                }
                
                AudioGlobalSettings.EDITOR_UpdateSoundGUIDToPathTable();
                if (EditorWindow.HasOpenInstances<SoundBrowserWindow>())
                {
                    EditorWindow.GetWindow<SoundBrowserWindow>().RefreshSoundBrowserWindow();
                }
            }
            finally
            {
                EditorUtility.ClearProgressBar();
            }

            EditorUtility.DisplayDialog("Import Complete", $"Created {createdCount} Sound assets in {targetRootPath}.\nSkipped {skippedCount} clips (already exists).", "OK");
        }

        private static bool ProcessAudioClip(string clipPath, string targetRootPath)
        {
            try
            {
                AudioClip clip = AssetDatabase.LoadAssetAtPath<AudioClip>(clipPath);
                if (clip == null) return false;

                string soundName = Path.GetFileNameWithoutExtension(clipPath);
                string originalAssetDirectory = Path.GetDirectoryName(clipPath);

                string relativeSubPath = "";
                // This logic correctly determines the subfolder structure to replicate
                if (originalAssetDirectory.StartsWith("Assets/"))
                {
                    relativeSubPath = originalAssetDirectory.Substring("Assets/".Length);
                }
                
                string targetDirectory = Path.Combine(targetRootPath, relativeSubPath).Replace('\\', '/');
                CreateDirectoryStructure(targetDirectory);
                
                string soundAssetPath = Path.Combine(targetDirectory, $"{soundName}.asset").Replace('\\', '/');
                if (AssetDatabase.LoadAssetAtPath<Sound>(soundAssetPath)) return false;

                Sound newSound = ScriptableObject.CreateInstance<Sound>();
                newSound.AddAudioClip(clip);
                AssetDatabase.CreateAsset(newSound, soundAssetPath);
                EditorUtility.SetDirty(newSound);
                return true;
            }
            catch (System.Exception ex)
            {
                Debug.LogError($"Error processing audio clip {clipPath}: {ex.Message}");
                return false;
            }
        }

        private static void CreateDirectoryStructure(string directoryPath)
        {
            if (AssetDatabase.IsValidFolder(directoryPath)) return;

            string[] pathParts = directoryPath.Split('/');
            string currentPath = pathParts[0];
            
            for (int i = 1; i < pathParts.Length; i++)
            {
                string nextPath = $"{currentPath}/{pathParts[i]}";
                if (!AssetDatabase.IsValidFolder(nextPath))
                {
                    AssetDatabase.CreateFolder(currentPath, pathParts[i]);
                }
                currentPath = nextPath;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/SoundBrowserContextMenu.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/SoundBrowserWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 47a3d1fe49b762a4f89e2795fe074bf7
# ASMDEF: ldx.framework.editor.dll
# ---
#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Utilities.Logging;
using UnityEngine;
using UnityEngine.UIElements;
using UnityEditor;
using UnityEditor.UIElements;
using UnityEngine.Audio;
using Debug = Ldx.Framework.Utilities.Logging.Debug;

namespace Ldx.Framework.Utilities.SoundBrowser
{
	/// <summary>
	/// Window for tracking & editing Sounds.
	/// </summary>
	public class SoundBrowserWindow : EditorWindow
	{
		public const string SOUND_BROWSER_GENERAL_CLASS_NAME = "general";
		public const string SOUND_BROWSER_SELECTABLE_CLASS_NAME = "selectable";

		private const string WINDOW_TITLE = "Sound Browser";

		private static readonly string UXML_PATH =
			string.Format(
				"Packages{0}com_ldx_framework{0}Editor{0}Assets{0}CustomEditors{0}SoundBrowser{0}SoundBrowser.uxml",
				Path.DirectorySeparatorChar);

		private static readonly string USS_PATH =
			string.Format(
				"Packages{0}com_ldx_framework{0}Editor{0}Assets{0}CustomEditors{0}SoundBrowser{0}SoundBrowser.uss",
				Path.DirectorySeparatorChar);

		/// <summary>
		/// How many pixels to left indent a sub-element (folder, sound) relative to its parent folder?
		/// </summary>
		private const int NUM_PIXELS_LEFT_INDENT_SUB_ELEMENT = 8;

		private enum Operation
		{
			NewSound,
			NewFolder,
			Rename,
			Delete,
			ImportSounds //New feature
		}

		#region Fields & Properties

		[SerializeField] private Sound selectedSound;
		[SerializeField] private Sound sourceSound; // The sound whose settings are to be copied

		private Dictionary<VisualElement, SelectableElement> visualElementToSelectable;
		private List<SelectableElement> selectableElementsHierarchy = new ();
		private VisualElement container;
		private VisualElement foldoutArea;
		private VisualElement buttonsArea;
		private VisualElement dialogArea;
		private VisualElement soundArea;
		private VisualElement soundBrowserElement;
		private ObjectField sourceSoundField; // UI for selecting the source sound

		private TextField renameTextField;
		private Label warningLabel;
		private Label dialogLabel;
		private ToolbarSearchField soundSearchField;
		private string lastSearchFieldValue;

		private Button refreshSoundsButton;
		private Button renameButton;
		private Button deleteButton;
		private Button newSoundButton;
		private Button newFolderButton;
		private Button dialogCancelButton;
		private Button dialogConfirmButton;
		private Button copySettingsButton; // Button to trigger the settings copy
		private Label selectedItemLabel;

		private SerializedObject serializedObject;
		private PropertyField selectedSoundPropertyField;
		private SerializedProperty selectedSoundSerializedProperty;

		private SelectableElement previouslySelectedElement;
		private SelectableElement selectedElement;
		
		// Drag and Drop Sound Addition
		private VisualElement dropArea;
		private Label dropAreaLabel;
		private string currentSelectedFolderPath;
		private AudioMixerGroup newImportsMixerGroup;
		private bool newImportsAre3DSounds;

		private SelectableElement SelectedElement
		{
			get => selectedElement;
			set
			{
				if (selectedElement == value)
				{
					return;
				}

				previouslySelectedElement = selectedElement;
				previouslySelectedElement?.Deselect();
				selectedElement = value;
				
				EnableModificationButtons(value != null);
				
				bool canCreate = value is SelectableFolder || (value != null && !string.IsNullOrEmpty(value.ContainingFolderAssetPath));
				newFolderButton.SetEnabled(canCreate);
				newSoundButton.SetEnabled(canCreate);
				
				if (value == null) return;
				selectedItemLabel.text = selectedElement.SimplifiedPath;

				if (selectedElement is SelectableFolder)
				{
					HandleSelectFolder();
				}
				else if (container.Contains(sourceSoundField))
				{
					container.Remove(sourceSoundField);
					container.Remove(copySettingsButton);
				}
			}
		}

		#endregion

		#region Window Setup

		[MenuItem("LogicalDox/Sound Browser")]
		public static void ShowWindow()
		{
			SoundBrowserWindow window = GetWindow<SoundBrowserWindow>();
			window.titleContent = new GUIContent(WINDOW_TITLE);
			window.minSize = new Vector2(500, 500);
		}

		public void CreateGUI()
		{
			// Main Visual Tree & Styles Setup
			container = rootVisualElement;
			VisualTreeAsset visualTree = AssetDatabase.LoadAssetAtPath<VisualTreeAsset>(UXML_PATH);
			container.Add(visualTree.Instantiate());
			StyleSheet styleSheet = AssetDatabase.LoadAssetAtPath<StyleSheet>(USS_PATH);
			container.styleSheets.Add(styleSheet);

			// Testing new
			Button newFoldersButton = rootVisualElement.Q<Button>("NewSoundFolderButton");
			newFoldersButton.clicked += HandleNewFolderClicked;

			// Top Bar Setup
			refreshSoundsButton = container.Q<Button>("RefreshSoundsButton");
			refreshSoundsButton.clickable.clicked += HandleRefreshSoundsButtonClicked;
			soundSearchField = container.Q<ToolbarSearchField>("SoundSearchField");
			soundSearchField.RegisterValueChangedCallback(HandleSearchFieldValueChanged);

			// Foldout Area Setup
			foldoutArea = container.Q("FoldoutArea");

			// Sound Area Setup
			soundArea = container.Q("SoundArea");
			warningLabel = container.Q<Label>("WarningLabel");
			ShowElement(warningLabel, false);
			selectedItemLabel = container.Q<Label>("SelectedItemLabel");
			serializedObject = new SerializedObject(this);
			selectedSoundSerializedProperty = serializedObject.FindProperty(nameof(selectedSound));
			selectedSoundPropertyField = container.Q<PropertyField>("SelectedSoundPropertyField");
			selectedSoundPropertyField.BindProperty(selectedSoundSerializedProperty);
			selectedSoundPropertyField.Bind(serializedObject);
			serializedObject.ApplyModifiedProperties();

			// Lower Buttons Setup
			buttonsArea = container.Q("ButtonsArea");
			newFolderButton = container.Q<Button>("NewFolderButton");
			newFolderButton.clicked += () => HandleOperationButtonClicked(Operation.NewFolder);
			newSoundButton = container.Q<Button>("NewSoundButton");
			newSoundButton.clicked += () => HandleOperationButtonClicked(Operation.NewSound);
			renameButton = container.Q<Button>("RenameButton");
			renameButton.clicked += () => HandleOperationButtonClicked(Operation.Rename);
			renameButton.SetEnabled(false);
			deleteButton = container.Q<Button>("DeleteButton");
			deleteButton.clicked += () => HandleOperationButtonClicked(Operation.Delete);
			deleteButton.SetEnabled(false);
			
			EnableModificationButtons(false);
			newFolderButton.SetEnabled(false);
			newSoundButton.SetEnabled(false);

			// Dialog Setup
			dialogArea = container.Q("DialogArea");
			dialogLabel = dialogArea.Q<Label>("DialogLabel");
			renameTextField = dialogArea.Q<TextField>("RenameTextField");
			dialogCancelButton = dialogArea.Q<Button>("DialogCancelButton");
			dialogConfirmButton = dialogArea.Q<Button>("DialogConfirmButton");
			ShowElement(dialogArea, false);
			
			// Setup drop area
			dropArea = new VisualElement
			{
				style =
				{
					flexGrow = 1,
					alignItems = new StyleEnum<Align>(Align.Center),
					justifyContent = new StyleEnum<Justify>(Justify.Center),
					backgroundColor = new Color(0.2f, 0.2f, 0.2f, 1), // Add visible background
					minHeight = 200, // Ensure minimum height
					borderBottomWidth = 1,
					borderTopWidth = 1,
					borderLeftWidth = 1,
					borderRightWidth = 1,
					borderBottomColor = new Color(0.5f, 0.5f, 0.5f, 1),
					borderTopColor = new Color(0.5f, 0.5f, 0.5f, 1),
					borderLeftColor = new Color(0.5f, 0.5f, 0.5f, 1),
					borderRightColor = new Color(0.5f, 0.5f, 0.5f, 1)
				}
			};

			dropAreaLabel = new Label("Drag and Drop to import and create sounds")
			{
				style =
				{
					fontSize = 18,
					unityFontStyleAndWeight = new StyleEnum<FontStyle>(FontStyle.Bold),
					color = new Color(0.7f, 0.7f, 0.7f)
				}
			};

			dropArea.Add(dropAreaLabel);
            
			// Set up drag and drop handlers
			dropArea.RegisterCallback<DragEnterEvent>(HandleDragEnter);
			dropArea.RegisterCallback<DragLeaveEvent>(HandleDragLeave);
			dropArea.RegisterCallback<DragUpdatedEvent>(HandleDragUpdated);
			dropArea.RegisterCallback<DragPerformEvent>(HandleDragPerform);
            
			// Add to UI
			soundArea.Add(dropArea);

			// Update Sounds
			RepopulateSoundBrowserElement();

			ObjectChangeEvents.changesPublished -= HandleChangesStreamPublished;
			ObjectChangeEvents.changesPublished += HandleChangesStreamPublished;
		}
		
		private void HandleDragEnter(DragEnterEvent evt)
		{
			dropArea.style.backgroundColor = new Color(0.3f, 0.5f, 0.8f, 0.3f);
			dropAreaLabel.text = "Release to Import";
		}
		
		private void HandleDragLeave(DragLeaveEvent evt)
		{
			dropArea.style.backgroundColor = new Color(0, 0, 0, 0);
			dropAreaLabel.text = "Drag and Drop to import and create sounds";
		}
		
		private void HandleDragUpdated(DragUpdatedEvent evt)
		{
			DragAndDrop.visualMode = DragAndDropVisualMode.Copy;
			evt.StopPropagation();
		}
		
		private void HandleDragPerform(DragPerformEvent evt)
		{
			dropArea.style.backgroundColor = new Color(0, 0, 0, 0);
			dropAreaLabel.text = "Drag and Drop to import and create sounds";
            
			DragAndDrop.AcceptDrag();
            
			string targetFolder = GetCurrentSelectedFolderPath();
			if (string.IsNullOrEmpty(targetFolder))
			{
				targetFolder = AudioGlobalSettings.SOUNDS_ASSET_PATH;
				EditorUtility.DisplayDialog("Import Notice", $"No folder selected. Importing to default project location: {targetFolder}", "OK");
			}
            
			ProcessDroppedFiles(DragAndDrop.paths, targetFolder);
			evt.StopPropagation();
		}
		
		private string GetCurrentSelectedFolderPath()
		{
			if (SelectedElement == null)
			{
				return AudioGlobalSettings.SOUNDS_ASSET_PATH;
			}
    
			if (SelectedElement is SelectableFolder folder)
			{
				return folder.AssetPath;
			}
			
			return SelectedElement.ContainingFolderAssetPath;
		}
		
		private void ProcessDroppedFiles(string[] paths, string targetFolder)
		{
			List<string> validAudioFiles =
				(from path in paths
					let extension = Path.GetExtension(path).ToLower()
					where extension is ".mp3" or ".wav" or ".ogg"
					select path).ToList();

			if (validAudioFiles.Count == 0)
			{
				EditorUtility.DisplayDialog("No Audio Files", 
					"No valid audio files were found. Please drag .mp3, .wav, or .ogg files.", "OK");
				return;
			}
            
			foreach (string audioFilePath in validAudioFiles)
			{
				ImportAudioAndCreateSound(audioFilePath, targetFolder);
			}
            
			AssetDatabase.Refresh();
			RepopulateSoundBrowserElement();
		}
		
		private void ImportAudioAndCreateSound(string audioFilePath, string targetFolder)
		{
		    try
		    {
		        string fileName = Path.GetFileNameWithoutExtension(audioFilePath);
		        
		        const string soundsFolder = "Assets/Sounds";
		        if (!AssetDatabase.IsValidFolder(soundsFolder))
		        {
		            AssetDatabase.CreateFolder("Assets", "Sounds");
		        }
		        
		        // Create destination path for audio clips
		        string relativePath = targetFolder.Replace(AudioGlobalSettings.SOUNDS_ASSET_PATH, "");
		        if (relativePath.StartsWith("/"))
		        {
		            relativePath = relativePath.Substring(1);
		        }
		        
		        string soundsDestFolder = Path.Combine(soundsFolder, relativePath);
		        
		        EnsureFolderPath(soundsDestFolder);
		        
		        // Destination path for the audio file in the project
		        string destFileName = Path.GetFileName(audioFilePath);
		        string destAudioPath = Path.Combine(soundsDestFolder, destFileName);
		        
		        // Convert to system path for file operations
		        string fullDestPath = Path.Combine(
		            Directory.GetCurrentDirectory(), 
		            destAudioPath.Replace('/', Path.DirectorySeparatorChar)
		        );
		        
		        Directory.CreateDirectory(Path.GetDirectoryName(fullDestPath)!);
		        
		        File.Copy(audioFilePath, fullDestPath, true);
		        
		        // Import the file into Unity
		        string unityPath = destAudioPath.Replace('\\', '/');
		        AssetDatabase.ImportAsset(unityPath);
		        
		        // Create Sound asset
		        string resourcesSoundPath = Path.Combine(targetFolder, $"{fileName}.asset");
		        resourcesSoundPath = AssetDatabase.GenerateUniqueAssetPath(resourcesSoundPath);
		        
		        Sound newSound = CreateInstance<Sound>();
		        
		        // Apply the user-selected settings
		        if (newImportsMixerGroup)
		        {
		            SerializedObject serializedSound = new (newSound);
		            SerializedProperty mixerGroupProperty = serializedSound.FindProperty("overrideMixerGroup");
		            mixerGroupProperty.objectReferenceValue = newImportsMixerGroup;
		            serializedSound.ApplyModifiedProperties();
		        }
		        
		        if (newImportsAre3DSounds)
		        {
		            SerializedObject serializedSound = new (newSound);
		            SerializedProperty spatialBlendProperty = serializedSound.FindProperty("spatialBlend");
		            spatialBlendProperty.floatValue = 1.0f;
		            serializedSound.ApplyModifiedProperties();
		        }
		        
		        AssetDatabase.CreateAsset(newSound, resourcesSoundPath);
		        
		        AssetDatabase.Refresh();
		        
		        AudioClip audioClip = AssetDatabase.LoadAssetAtPath<AudioClip>(unityPath);
		        if (audioClip != null)
		        {
		            newSound.AddAudioClip(audioClip);
		            EditorUtility.SetDirty(newSound);
		            AssetDatabase.SaveAssets();
		            Debug.LogVerbose(LogCategory.Audio, $"Successfully imported {fileName} to {unityPath} and created Sound asset at {resourcesSoundPath}");
		        }
		        else
		        {
		            Debug.LogError(LogCategory.Audio, $"Failed to load audio clip at {unityPath}");
		        }
		    }
		    catch (Exception ex)
		    {
		        Debug.LogError(LogCategory.Audio, $"Error importing audio file: {ex.Message}\n{ex.StackTrace}");
		    }
		}
		
		private void EnsureFolderPath(string folderPath)
		{
			string[] parts = folderPath.Split('/');
			string currentPath = parts[0];
            
			for (int i = 1; i < parts.Length; i++)
			{
				string parentFolder = currentPath;
				currentPath = Path.Combine(currentPath, parts[i]);

				if (AssetDatabase.IsValidFolder(currentPath))
				{
					continue;
				}
				
				string folderName = parts[i];
				AssetDatabase.CreateFolder(parentFolder, folderName);
			}
		}

		private void OnDestroy()
		{
			ObjectChangeEvents.changesPublished -= HandleChangesStreamPublished;
		}

		#endregion

		// Updated when changes to the stream occur - like values being modified 
		private void HandleChangesStreamPublished(ref ObjectChangeEventStream stream)
		{
			// Selected sound == null? Change probably not to selected sound
			if (selectedSound == null)
			{
				return;
			}

			for (int i = 0; i < stream.length; ++i)
			{
				ObjectChangeKind eventKind = stream.GetEventType(i);
				// We iterate until we find a change of the type that indicates a change to the object
				if (eventKind == ObjectChangeKind.ChangeAssetObjectProperties)
				{
					stream.GetChangeAssetObjectPropertiesEvent(i, out ChangeAssetObjectPropertiesEventArgs data);

					// Compare instance ids to confirm it's a change to selectedSound
					if (data.instanceId == selectedSound.GetInstanceID())
					{
						// Save
						if (serializedObject != null)
						{
							serializedObject.ApplyModifiedProperties();
							AssetDatabase.SaveAssets();
							AssetDatabase.Refresh();
							AudioGlobalSettings.EDITOR_UpdateSoundGUIDToPathTable();
						}

						break;
					}
				}
			}
		}

		private void HandleSearchFieldValueChanged(ChangeEvent<string> evt)
		{
			// Hacky way to handle a search ending and restoring the UI layout, but it's okay for now.
			// TODO: Make this less hacky and better UX.
			if (!string.IsNullOrEmpty(lastSearchFieldValue) && soundSearchField.value == string.Empty)
			{
				RepopulateSoundBrowserElement();
				lastSearchFieldValue = soundSearchField.value;
				return;
			}

			showResultsRecursive(selectableElementsHierarchy);
			lastSearchFieldValue = soundSearchField.value;
			return;

			void showResultsRecursive(List<SelectableElement> folderContents)
			{
				foreach (SelectableElement selectableElement in folderContents)
				{
					if (selectableElement is SelectableSound sound)
					{
						bool show = soundSearchField.value == string.Empty ||
						            sound.Name.ToLower().StartsWith(soundSearchField.value.ToLower());

						if (show && !soundBrowserElement.Contains(sound.target))
						{
							soundBrowserElement.Add(sound.target);
						}
						else if (!show && soundBrowserElement.Contains(sound.target))
						{
							soundBrowserElement.Remove(sound.target);
						}

						ShowElement(sound.target, show);
					}
					else if (selectableElement is SelectableFolder selectableFolder)
					{
						showResultsRecursive(selectableFolder.ContainedElements);
						ShowElement(selectableFolder.target, soundSearchField.value == string.Empty);
					}
				}
			}
		}

		private void HandleNewFolderClicked()
		{
			string path = EditorUtility.OpenFolderPanel("Select Folder to Import", "", "");
			if (!string.IsNullOrEmpty(path))
			{
				ImportSoundsFromDirectory(path);
			}
		}

		private bool ImportSoundsFromDirectory(string sourceFolderPath)
		{
			if (string.IsNullOrEmpty(sourceFolderPath))
			{
				dialogLabel.text = "No folder selected!";
				return false;
			}

			// Extract the main folder name from the path
			string mainFolderName = new DirectoryInfo(sourceFolderPath).Name;
			string relativePath = Path.Combine(AudioGlobalSettings.SOUNDS_ASSET_PATH, mainFolderName);

			// Create the main folder inside Unity's asset structure
			if (!AssetDatabase.IsValidFolder(relativePath))
			{
				AssetDatabase.CreateFolder(AudioGlobalSettings.SOUNDS_ASSET_PATH, mainFolderName);
			}

			// Now import sounds from the selected directory and its subdirectories
			CreateFoldersAndImportSounds(sourceFolderPath, relativePath);
			AssetDatabase.Refresh(); // Refresh the AssetDatabase to show new assets
			RepopulateSoundBrowserElement(); // Refresh sound browser to show newly imported sounds
			return true;
		}

		private void CreateFoldersAndImportSounds(string directoryPath, string relativePath)
		{
			foreach (string subDirectory in Directory.GetDirectories(directoryPath))
			{
				string folderName = Path.GetFileName(subDirectory);
				string newRelativePath = Path.Combine(relativePath, folderName);
				if (!AssetDatabase.IsValidFolder(newRelativePath))
				{
					AssetDatabase.CreateFolder(relativePath, folderName);
				}

				CreateFoldersAndImportSounds(subDirectory, newRelativePath);
			}

			// Handle both .wav and .mp3 files in one go
			string[] soundFiles = Directory.GetFiles(directoryPath, "*.*", SearchOption.TopDirectoryOnly)
				.Where(f => f.EndsWith(".wav") || f.EndsWith(".mp3")).ToArray();

			foreach (string soundFile in soundFiles)
			{
				CreateSoundAsset(soundFile, relativePath);
			}
		}

		private void CreateSoundAsset(string filePath, string relativePath)
		{
			string fileName = Path.GetFileNameWithoutExtension(filePath);
			string assetPath = Path.Combine(relativePath, fileName + ".asset");
			assetPath = AssetDatabase.GenerateUniqueAssetPath(assetPath);
			string correctPath = GetRelativePath(filePath);

			AudioClip newClip = AssetDatabase.LoadAssetAtPath<AudioClip>(correctPath);
			Sound newSound = CreateInstance<Sound>();

			if (newClip != null)
			{
				Debug.LogVerbose(LogCategory.Audio, $"Loaded new sound {newClip.name} and adding to {newSound} file");
				newSound.AddAudioClip(newClip);
			}
			else
			{
				Debug.LogError(LogCategory.Audio, $"Failed to load AudioClip at path: {correctPath}");
			}

			AssetDatabase.CreateAsset(newSound, assetPath);
			AssetDatabase.SaveAssets();
			AssetDatabase.Refresh();
		}

		/// <summary>
		/// This will take a full directory path, cut it off at "Assets", and give you the proper relative path.
		/// </summary>
		/// <param name="filePath"></param>
		/// <returns></returns>
		private string GetRelativePath(string filePath)
		{
			int assetsIndex = filePath.IndexOf("Assets", StringComparison.Ordinal);
			return assetsIndex >= 0 ? filePath[assetsIndex..].Replace("\\", "/") : null;
		}

		private void CopySoundSettings()
		{
			if (!sourceSound || !(SelectedElement is SelectableFolder selectedFolder))
			{
				EditorUtility.DisplayDialog("Error", "No source sound selected or selected element is not a folder.",
					"OK");
				return;
			}

			// Recursive copy of settings
			ApplySettingsToFolder(selectedFolder.AssetPath);
		}

		private void ApplySettingsToFolder(string folderPath)
		{
			string[] soundFiles = AssetDatabase.FindAssets("t:Sound", new[] { folderPath });
			foreach (string fileGUID in soundFiles)
			{
				string filePath = AssetDatabase.GUIDToAssetPath(fileGUID);
				Sound sound = AssetDatabase.LoadAssetAtPath<Sound>(filePath);

				if (sound == sourceSound)
				{
					continue;
				}
				
				CopySettings(sourceSound, sound);
				EditorUtility.SetDirty(sound);
			}

			string[] subFolders = AssetDatabase.GetSubFolders(folderPath);
			foreach (string subFolder in subFolders)
			{
				ApplySettingsToFolder(subFolder);
			}

			AssetDatabase.SaveAssets();
			AssetDatabase.Refresh();
		}

		private void CopySettings(Sound source, Sound target)
		{
			target.CopyFromSource(source);
		}

		private void ShowElement(VisualElement element, bool show)
		{
			element.style.display = show ? DisplayStyle.Flex : DisplayStyle.None;
		}

		private void HandleOperationButtonClicked(Operation operation)
		{
			ShowElement(dialogArea, true);
			ShowElement(buttonsArea, false);
			foldoutArea.SetEnabled(false);
			soundArea.SetEnabled(false);
			refreshSoundsButton.SetEnabled(false);
			dialogConfirmButton.clicked += handleConfirmClicked;
			dialogCancelButton.clicked += handleCancelClicked;

			switch (operation)
			{
				case Operation.NewSound:
					dialogLabel.text = $"Create New Sound";
					renameTextField.value = "New Sound";
					dialogConfirmButton.text = "Create";
					dialogCancelButton.text = "Cancel";
					ShowElement(renameTextField, true);
					break;
				case Operation.NewFolder:
					dialogLabel.text = $"Create New Folder";
					renameTextField.value = "New Folder";
					dialogConfirmButton.text = "Create";
					dialogCancelButton.text = "Cancel";
					ShowElement(renameTextField, true);
					break;
				case Operation.Rename:
					if (SelectedElement == null)
					{
						unsubscribeButtonsHideDialog(refreshSounds: true);
						return;
					}

					string fileName = SelectedElement.Name;
					renameTextField.value = fileName;
					dialogLabel.text = $"Rename '{fileName}'?";
					dialogConfirmButton.text = "Rename";
					dialogCancelButton.text = "Cancel";
					ShowElement(renameTextField, true);
					renameTextField.Focus();
					break;
				case Operation.Delete:
					if (SelectedElement == null)
					{
						unsubscribeButtonsHideDialog(refreshSounds: true);
						return;
					}

					dialogLabel.text = $"Delete '{SelectedElement.Name}'?";
					dialogConfirmButton.text = "Delete";
					dialogCancelButton.text = "Cancel";
					ShowElement(renameTextField, false);
					break;
				case Operation.ImportSounds:
					dialogLabel.text = "Select a folder to import sounds from:";
					renameTextField.value = "Browse..."; // Just a placeholder
					dialogConfirmButton.text = "Import";
					dialogCancelButton.text = "Cancel";
					ShowElement(renameTextField, false); // Hide rename field, not needed here
					break;
				default:
					throw new ArgumentOutOfRangeException(nameof(operation), operation, null);
			}
			return;

			void handleConfirmClicked()
			{
				bool completed = false;

				switch (operation)
				{
					case Operation.NewSound:
						completed = newSound();
						break;
					case Operation.NewFolder:
						completed = newFolder();
						break;
					case Operation.Delete:
						completed = deleteElement();
						break;
					case Operation.Rename:
						completed = renameElement();
						break;
					case Operation.ImportSounds:
						break;
					default:
						throw new ArgumentOutOfRangeException(nameof(operation), operation, null);
				}

				if (completed) unsubscribeButtonsHideDialog(refreshSounds: true);
			}

			void handleCancelClicked()
			{
				unsubscribeButtonsHideDialog(refreshSounds: false);
			}

			void unsubscribeButtonsHideDialog(bool refreshSounds)
			{
				dialogConfirmButton.clicked -= handleConfirmClicked;
				dialogCancelButton.clicked -= handleCancelClicked;
				ShowElement(buttonsArea, true);
				ShowElement(dialogArea, false);
				foldoutArea.SetEnabled(true);
				soundArea.SetEnabled(true);
				refreshSoundsButton.SetEnabled(true);

				if (refreshSounds) RepopulateSoundBrowserElement();
			}

			bool newSound()
			{
				if (string.IsNullOrEmpty(renameTextField.value))
				{
					dialogLabel.text = "New Sound name cannot be blank!";
					return false;
				}
				
				string parentFolder = GetSelectedFolderPath();
				if (parentFolder == null) return false; 
				string newSoundAssetPath = AssetDatabase.GenerateUniqueAssetPath(
					$"{parentFolder}/{renameTextField.value}.asset");

				AssetDatabase.CreateAsset(CreateInstance<Sound>(), newSoundAssetPath);
				AssetDatabase.SaveAssets();
				return true;
			}

			bool newFolder()
			{
				if (string.IsNullOrEmpty(renameTextField.value))
				{
					dialogLabel.text = "New folder name cannot be blank!";
					return false;
				}
				
				string parentFolder = GetSelectedFolderPath();
				if (parentFolder == null) return false;
				AssetDatabase.CreateFolder(parentFolder, renameTextField.value);
    
				AssetDatabase.SaveAssets();
				return true;
			}

			bool renameElement()
			{
				if (string.IsNullOrEmpty(renameTextField.value))
				{
					dialogLabel.text = "Name cannot be blank!";
					return false;
				}

				if (AssetDatabase.RenameAsset(SelectedElement.AssetPath, renameTextField.value) != string.Empty)
				{
					dialogLabel.text = "Rename failed!";
					return false;
				}

				return true;
			}

			bool deleteElement()
			{
				// Keep path variable locally because we clear it from the field in ClearSoundSelection
				string assetPath = SelectedElement.AssetPath;
				ClearSelection();

				if (AssetDatabase.DeleteAsset(assetPath))
				{
					AssetDatabase.SaveAssets();
					RepopulateSoundBrowserElement();
					return true;
				}

				UnityEngine.Debug.LogError($"Could not delete {assetPath}");
				return false;
			}
		}
		
		private string GetSelectedFolderPath()
		{
			if (SelectedElement == null)
			{
				if(EditorUtility.DisplayDialog("No Folder Selected", 
					   "No folder or item is selected. Would you like to create this in the root of Project Sounds?", 
					   "Yes", "No"))
				{
					return AudioGlobalSettings.SOUNDS_ASSET_PATH;
				}
				return null;
			}
			
			if (SelectedElement is SelectableFolder folder)
			{
				return folder.AssetPath;
			}
			
			return SelectedElement.ContainingFolderAssetPath;
		}

		private void EnableModificationButtons(bool enable)
		{
			renameButton.SetEnabled(enable);
			deleteButton.SetEnabled(enable);
		}

		private void RepopulateSoundBrowserElement()
		{
			ClearSelection();
			foldoutArea.Clear();
			AudioGlobalSettings.EDITOR_UpdateSoundGUIDToPathTable();
			selectableElementsHierarchy = GetFolderStructure();
			soundBrowserElement = GetBrowserVisualElement();
			foldoutArea.Add(soundBrowserElement);
			ShowElement(warningLabel, false);
		}

		public void RefreshSoundBrowserWindow()
		{
			RepopulateSoundBrowserElement();
		}

		private void ClearSelection()
		{
			selectedItemLabel.text = string.Empty;
			soundArea.Clear();
			ShowElement(selectedSoundPropertyField, false);
			EnableModificationButtons(false);
		}

		private void HandleSelectFolder()
		{
			if (selectedElement is SelectableFolder)
			{
				selectedItemLabel.text += " (Folder)";

				soundArea.Clear();

				if (container.Contains(sourceSoundField))
					return;

				// Setup for sound settings copy
				sourceSoundField = new ObjectField("Source Sound Settings")
				{
					objectType = typeof(Sound),
					allowSceneObjects = false
				};
				sourceSoundField.RegisterValueChangedCallback(evt => { sourceSound = evt.newValue as Sound; });
				container.Add(sourceSoundField);

				copySettingsButton = new Button(CopySoundSettings)
				{
					text = "Apply settings to all sounds within folder hierarchy"
				};
				container.Add(copySettingsButton);
			}
			else if (container.Contains(sourceSoundField))
			{
				container.Remove(sourceSoundField);
				container.Remove(copySettingsButton);
			}
		}

		private void HandleRefreshSoundsButtonClicked()
		{
			RepopulateSoundBrowserElement();
		}

		private List<SelectableElement> GetFolderStructure()
		{
			List<SelectableElement> topFolderList = new ();
			AudioGlobalSettings.CheckValidOrCreateSoundsPath();
			
			SelectableFolder projectRoot = CreateSelectableFolder(AudioGlobalSettings.SOUNDS_ASSET_PATH);
			projectRoot.SetDisplayName("Project Sounds");
			GetSubFoldersRecursive(projectRoot.ContainedElements, AudioGlobalSettings.SOUNDS_ASSET_PATH);
			topFolderList.Add(projectRoot);
			
			SelectableFolder frameworkRoot = CreateSelectableFolder(AudioGlobalSettings.FRAMEWORK_SOUNDS_ASSET_PATH);
			frameworkRoot.SetDisplayName("Framework Sounds");
			GetSubFoldersRecursive(frameworkRoot.ContainedElements, AudioGlobalSettings.FRAMEWORK_SOUNDS_ASSET_PATH);
			topFolderList.Add(frameworkRoot);
    
			return topFolderList;
		}

		private void GetSubFoldersRecursive(List<SelectableElement> parentList, string folderAssetPath)
		{
			// Get sub-folders at the current level
			string[] subFolders = AssetDatabase.GetSubFolders(folderAssetPath);
			foreach (string subFolderAssetPath in subFolders)
			{
				SelectableFolder selectableFolder = CreateSelectableFolder(subFolderAssetPath);
				parentList.Add(selectableFolder);
				GetSubFoldersRecursive(selectableFolder.ContainedElements, subFolderAssetPath);
			}

			// Get sound files at the current level (not including subfolders)
			string[] soundGuids = AssetDatabase.FindAssets("t:Sound", new[] { folderAssetPath });
			foreach (string guid in soundGuids)
			{
				string assetPath = AssetDatabase.GUIDToAssetPath(guid);
				if (Path.GetDirectoryName(assetPath)?.Replace('\\', '/') == folderAssetPath)
				{
					Sound sound = AssetDatabase.LoadAssetAtPath<Sound>(assetPath);
					if (!sound)
					{
						Debug.LogError(LogCategory.Audio,
							$"Asset {assetPath} is not a Sound! Remove it from the Sounds directories");
						continue;
					}

					SelectableSound selectableSound = CreateSelectableSound(assetPath, sound);
					parentList.Add(selectableSound);
				}
			}
		}

		private VisualElement GetBrowserVisualElement()
		{
			VisualElement topBrowserElement = new ();
			foreach (SelectableElement selectableElement in selectableElementsHierarchy)
			{
				selectableElement.UpdateLabel();
				topBrowserElement.Add(selectableElement.target);
			}

			return topBrowserElement;
		}

		private void HandleSelectableElementMovedToFolder(SelectableElement movedSelectableElement,
			VisualElement folderVisualElement)
		{
			// Return early if moving to "same" folder
			if (movedSelectableElement is SelectableFolder selectableFolder &&
			    selectableFolder.target == folderVisualElement)
			{
				ShowElement(warningLabel, false);
				return;
			}

			SelectableElement targetSelectableElement =
				GetSelectableElementMatchingVisualElement(selectableElementsHierarchy, folderVisualElement);

			if (targetSelectableElement == null)
			{
				ShowElement(warningLabel, true);
				warningLabel.text = $"Could not find target path.";
				return;
			}

			string targetPath = targetSelectableElement.AssetPath;

			// If hovering over a Sound in a different folder, change the target path to its containing folder
			if (targetSelectableElement is SelectableSound)
			{
				targetPath = targetSelectableElement.ContainingFolderAssetPath;
			}

			if (movedSelectableElement is SelectableSound)
			{
				targetPath += $"/{movedSelectableElement.Name}.asset";
			}
			else if (movedSelectableElement is SelectableFolder)
			{
				targetPath += $"/{movedSelectableElement.Name}";
			}

			// Return early if attempting to move to the same path
			if (targetPath == movedSelectableElement.AssetPath)
			{
				ShowElement(warningLabel, false);
				return;
			}

			if (AssetDatabase.MoveAsset(movedSelectableElement.AssetPath, targetPath) == string.Empty)
			{
				ShowElement(warningLabel, false);
				RepopulateSoundBrowserElement();
			}
			else
			{
				ShowElement(warningLabel, true);
				warningLabel.text =
					$"Could not move {movedSelectableElement.Name} to {targetPath}. Check file/folder with same name does not already exist.";
			}
		}
		
		/// <summary>
        /// Selects a sound in the browser by its path.
        /// </summary>
        /// <param name="soundPath">The path to the sound asset (relative to Sounds folder)</param>
        public void SelectSound(string soundPath)
        {
            RepopulateSoundBrowserElement();
            
            string fullAssetPath = $"{AudioGlobalSettings.SOUNDS_ASSET_PATH}/{soundPath}.asset";
            
            string containerPath = Path.GetDirectoryName(fullAssetPath);
            ExpandFoldersForPath(selectableElementsHierarchy, containerPath);
            
            if (!FindAndSelectSound(selectableElementsHierarchy, fullAssetPath))
            {
	            Debug.LogError(LogCategory.Audio, $"Could not find sound at path: {fullAssetPath}");
            }
        }
        
        /// <summary>
        /// Recursively searches through the elements hierarchy to find and select a sound by its asset path
        /// </summary>
        private bool FindAndSelectSound(List<SelectableElement> elements, string targetAssetPath)
        {
            foreach (SelectableElement element in elements)
            {
                if (element.AssetPath.Equals(targetAssetPath, StringComparison.OrdinalIgnoreCase))
                {
	                ExpandParentFolders(element);
                    HandleSelectableElementSelected(element);
                    element.Select();
                    
                    return true;
                }
                
                if (element is SelectableFolder folder)
                {
	                if (FindAndSelectSound(folder.ContainedElements, targetAssetPath))
	                {
		                return true;
	                }
                }
            }
            
            return false;
        }
        
        /// <summary>
        /// Ensures all parent folders of the element are expanded
        /// </summary>
        private void ExpandParentFolders(SelectableElement element)
        {
            string containerPath = element.ContainingFolderAssetPath;
            
            ExpandFoldersForPath(selectableElementsHierarchy, containerPath);
        }
        
        /// <summary>
        /// Recursively expands folders to show a specific path
        /// </summary>
        private bool ExpandFoldersForPath(List<SelectableElement> elements, string targetPath)
        {
	        foreach (SelectableElement element in elements)
	        {
		        if (element is not SelectableFolder folder)
		        {
			        continue;
		        }
		        
		        if (targetPath.StartsWith(folder.AssetPath, StringComparison.OrdinalIgnoreCase))
		        {
			        bool wasSelected = folder.IsExpanded;
			        if (!wasSelected)
			        {
				        folder.Select();
			        }
                        
			        if (ExpandFoldersForPath(folder.ContainedElements, targetPath))
			        {
				        return true;
			        }
		        }
		        else if (folder.AssetPath.Equals(targetPath, StringComparison.OrdinalIgnoreCase))
		        {
			        if (!folder.IsExpanded)
			        {
				        folder.Select();
			        }
			        return true;
		        }
	        }
            
            return false;
        }

		/// <summary>
		/// Get the selectable element which is using the given visual element.
		/// Returns null if it cannot be found.
		/// </summary>
		private SelectableElement GetSelectableElementMatchingVisualElement(List<SelectableElement> selectableElements,
			VisualElement visualElement)
		{
			SelectableElement matchingElement = null;

			foreach (SelectableElement element in selectableElements)
			{
				if (element.target == visualElement)
				{
					matchingElement = element;
					break;
				}

				if (element is not SelectableFolder folder)
				{
					continue;
				}
				
				matchingElement =
					GetSelectableElementMatchingVisualElement(folder.ContainedElements, visualElement);
				if (matchingElement != null)
				{
					break;
				}
			}

			return matchingElement;
		}

		private void HandleSelectableElementSelected(SelectableElement selectableElement)
		{
			SelectedElement = selectableElement;
			selectableElement.UpdateLabel();

			switch (selectableElement)
			{
				case SelectableSound selectableSound:
					SelectSound(selectableSound);
					break;
				case SelectableFolder selectableFolder:
					SelectFolder(selectableFolder);
					break;
			}
		}

		private void SelectSound(SelectableSound selectableSound)
		{
		    soundArea.Clear();
		    selectedSound = selectableSound.Sound;
		    
		    Button openSoundPlayerButton = new (() => SoundPlayerEditorWindow.SetSound(selectedSound))
		    {
		        tooltip = "Open in Sound Player Editor Window"
		    };
		    
		    Image playIcon = new ()
		    {
		        image = EditorGUIUtility.IconContent("d_PlayButton").image
		    };
		    openSoundPlayerButton.Add(playIcon);
		    
		    openSoundPlayerButton.style.width = 30;
		    openSoundPlayerButton.style.height = 20;
		    openSoundPlayerButton.style.marginBottom = 5;
		    
		    soundArea.Add(openSoundPlayerButton);
		    
		    InspectorElement soundInspector = new(selectedSound);
		    UnityEditor.Editor soundEditor = UnityEditor.Editor.CreateEditor(selectedSound);
		    soundInspector.Bind(soundEditor.serializedObject);
		    soundArea.Add(soundInspector);
		    
		    SerializedObject serializedSound = soundEditor.serializedObject;
		    SerializedProperty spatialBlendProperty = serializedSound.FindProperty("spatialBlend");
		    
		    // Create a container for the rolloff visualization
		    VisualElement rolloffContainer = new();
		    soundArea.Add(rolloffContainer);
		    
		    // Track the current state
		    bool is3D = spatialBlendProperty.floatValue > 0;
		    
		    // Initial setup
		    UpdateRolloffVisualization(rolloffContainer, serializedSound, is3D);
		    
		    // Add a callback for when any property changes
		    soundInspector.RegisterCallback<SerializedPropertyChangeEvent>(evt => 
		    {
		        if (evt.changedProperty.propertyPath == "spatialBlend")
		        {
		            bool newIs3D = spatialBlendProperty.floatValue > 0;
		            
		            // Only update if the 3D state changed
		            if (newIs3D != is3D)
		            {
		                is3D = newIs3D;
		                UpdateRolloffVisualization(rolloffContainer, serializedSound, is3D);
		            }
		        }
		    });

		    ShowElement(selectedSoundPropertyField, true);
		    selectedSoundPropertyField.SetEnabled(true);
		    selectedSoundPropertyField.BindProperty(selectedSoundSerializedProperty);
		    selectedSoundPropertyField.Bind(serializedSound);
		    serializedSound.ApplyModifiedProperties();
		}

		// Helper method to show/hide the rolloff visualization
		private void UpdateRolloffVisualization(VisualElement rolloffContainer, SerializedObject serializedSound, bool show)
		{
		    // Clear existing content
		    rolloffContainer.Clear();

		    if (!show)
		    {
			    return;
		    }
		    
		    SerializedProperty rolloffProperty = serializedSound.FindProperty("volumeRolloff");
		    SerializedProperty spatialBlendProperty = serializedSound.FindProperty("spatialBlend");
		        
		    IMGUIContainer rolloffVisualization = new(() => 
		    {
			    EditorGUILayout.Space(10);
		            
			    AudioRolloffMode rolloffMode = (AudioRolloffMode)rolloffProperty.enumValueIndex;
			    string visualizerTitle = $"{rolloffMode} Rolloff Visualization";
			    EditorGUILayout.LabelField(visualizerTitle, EditorStyles.boldLabel);
		            
			    SerializedProperty minDistProperty = serializedSound.FindProperty("minDistance");
			    SerializedProperty maxDistProperty = serializedSound.FindProperty("maxDistance");
			    SerializedProperty spreadProperty = serializedSound.FindProperty("spread");
			    SerializedProperty reverbProperty = serializedSound.FindProperty("reverbZoneMix");
		            
			    Rect visualizationRect = EditorGUILayout.GetControlRect(false, 200);
		            
			    AnimationCurve customCurve = null;
			    if (rolloffMode == AudioRolloffMode.Custom && selectedSound)
			    {
				    customCurve = selectedSound.CustomRolloffCurve;
			    }

			    RolloffVisualizer.DrawRolloffCurve(
				    visualizationRect,
				    minDistProperty.floatValue,
				    maxDistProperty.floatValue,
				    rolloffMode,
				    true,
				    spatialBlendProperty.floatValue,
				    true,
				    spreadProperty.floatValue,
				    true,
				    reverbProperty.floatValue,
				    customCurve);
		    });
		        
		    rolloffContainer.Add(rolloffVisualization);
		}

		private void SelectFolder(SelectableFolder selectableFolder)
		{
			soundArea.Clear();
			ShowElement(selectedSoundPropertyField, false);
			
			soundArea.Add(dropArea);
			
			ObjectField mixerGroupField = new ("New Imports Mixer Group")
			{
				objectType = typeof(AudioMixerGroup),
				allowSceneObjects = false,
				value = newImportsMixerGroup
			};
			mixerGroupField.RegisterValueChangedCallback(evt => 
			{
				newImportsMixerGroup = evt.newValue as AudioMixerGroup;
			});
			soundArea.Add(mixerGroupField);
    
			Toggle is3DSoundsToggle = new("New imports are 3D sounds")
			{
				value = newImportsAre3DSounds
			};
			is3DSoundsToggle.RegisterValueChangedCallback(evt => 
			{
				newImportsAre3DSounds = evt.newValue;
			});
			soundArea.Add(is3DSoundsToggle);
    
			ShowOrHideFolderRecursive(selectableFolder, null);
		}

		private void ShowOrHideFolderRecursive(SelectableFolder thisFolder, SelectableFolder parentFolder)
		{
			for (int i = thisFolder.ContainedElements.Count - 1; i >= 0; i--)
			{
				SelectableElement element = thisFolder.ContainedElements[i];
				element.UpdateLabel();
				if ((parentFolder == null || parentFolder.IsExpanded) && thisFolder.IsExpanded)
				{
					showElementInFolder(element, thisFolder);
				}
				else
				{
					hideElementInSoundBrowser(element);
				}

				if (element is SelectableFolder subFolder)
				{
					ShowOrHideFolderRecursive(subFolder, thisFolder);
				}
			}
			return;

			void showElementInFolder(SelectableElement element, SelectableFolder folder)
			{
				if (soundBrowserElement.Contains(element.target))
				{
					return;
				}

				soundBrowserElement.Add(element.target);
				ShowElement(element.target, true);
				element.target.PlaceInFront(folder.target);
				element.target.style.position = new StyleEnum<Position>(Position.Relative);
				element.target.style.left = new StyleLength(new Length(
					folder.target.style.left.value.value + NUM_PIXELS_LEFT_INDENT_SUB_ELEMENT, LengthUnit.Pixel));
			}

			void hideElementInSoundBrowser(SelectableElement element)
			{
				if (soundBrowserElement.Contains(element.target))
				{
					soundBrowserElement.Remove(element.target);
				}
			}
		}

		private SelectableFolder CreateSelectableFolder(string assetPath)
		{
			SelectableFolder selectableFolder = new (foldoutArea, assetPath);
			SubscribeSelectableElement(selectableFolder);
			return selectableFolder;
		}

		private SelectableSound CreateSelectableSound(string assetPath, Sound sound)
		{
			SelectableSound selectableSound = new (foldoutArea, assetPath, sound);
			SubscribeSelectableElement(selectableSound);
			return selectableSound;
		}

		/// <summary>
		/// Prevent double subscribes
		/// </summary>
		private void SubscribeSelectableElement(SelectableElement selectableElement)
		{
			selectableElement.OnSelected -= HandleSelectableElementSelected;
			selectableElement.OnSelected += HandleSelectableElementSelected;
			selectableElement.OnMovedToFolder -= HandleSelectableElementMovedToFolder;
			selectableElement.OnMovedToFolder += HandleSelectableElementMovedToFolder;
		}
	}
}
#endif
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/SoundBrowserWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/SoundPlayerEditorWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 5c803e0de8000d84f96f9e3c04141014
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using System.Linq;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.AudioSystem;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.SoundBrowser
{
    /// <summary>
    /// Editor window that allows playing and modifying Sound scriptable objects.
    /// </summary>
    public class SoundPlayerEditorWindow : EditorWindow
    {
        private const float MIN_PITCH_VALUE = 0.01f;
        private const float DEFAULT_PITCH_VALUE = 1.0f;
        private const float MAX_PITCH_VALUE = 3.0f;
        private const int MID_Y = 50;
        private const float LABEL_HEIGHT = 16f;
        private const float PADDING = 2f;
        private const float SECTION_SPACING = 6f;
        
        private static readonly Color WaveformBgColor = new (0.2f, 0.2f, 0.2f, 1f);
        private static readonly Color TimeMarkerColor = new (0.5f, 0.5f, 0.5f);
        private static readonly Color WaveColorStart = new (0.3f, 0.4f, 0.8f, 0.7f);
        private static readonly Color WaveColorEnd = new (0.4f, 0.6f, 1f);
        private static readonly Color SelectedRegionColor = new (0.2f, 0.6f, 1.0f, 0.2f);

        // Serialize sound references and use static instance for persistence of sound when clicking other objects
        [SerializeField] private Sound currentSoundAsset;
        [SerializeField] private string currentAssetPath = string.Empty;
        private static SoundPlayerEditorWindow instance;
        
        private AudioSource audioSource;
        private bool isPlaying;
        private bool isPaused;
        private float pausedTime;
        private UnityEditor.Editor soundEditor;
        private Vector2 scrollPosition;

        private AudioClip currentClip;
        private int selectedClipIndex;
        
        // Waveform preview
        private float[] waveformData;
        private Texture2D waveformTexture;
        private bool waveformGenerated;
        
        private float stopTime;
        private bool isDraggingStartHandle;
        private bool isDraggingStopHandle;
        private int startHandleControlID;
        private int stopHandleControlID;

        [MenuItem("Window/Sound Player")]
        private static void ShowWindow()
        {
            GetWindow<SoundPlayerEditorWindow>("Sound Player");
        }

        private void OnEnable()
        {
            instance = this;
        }
        
        private void OnFocus()
        {
            instance = this;
        }

        private void OnDisable()
        {
            StopSound();
            
            if (soundEditor != null)
            {
                DestroyImmediate(soundEditor);
                soundEditor = null;
            }
            
            if (audioSource != null)
            {
                DestroyImmediate(audioSource.gameObject);
                audioSource = null;
            }
            
            if (waveformTexture != null)
            {
                DestroyImmediate(waveformTexture);
                waveformTexture = null;
            }
            
            if (instance == this)
            {
                instance = null;
            }
        }

        private void Initialize()
        {
            if (!audioSource)
            {
                GameObject tempAudio = new("TempAudioSource");
                audioSource = tempAudio.AddComponent<AudioSource>();
                tempAudio.hideFlags = HideFlags.HideAndDontSave;
            }

            if (!currentSoundAsset || (soundEditor && soundEditor.target == currentSoundAsset))
            {
                return;
            }
    
            if (soundEditor)
            {
                DestroyImmediate(soundEditor);
            }
        
            soundEditor = UnityEditor.Editor.CreateEditor(currentSoundAsset);
        
            List<AudioClip> clips = currentSoundAsset.GetAudioClips();
            if (clips is not { Count: > 0 })
            {
                return;
            }
        
            selectedClipIndex = 0;
            currentClip = clips[selectedClipIndex];
            stopTime = currentClip.length;
            waveformGenerated = false;
        }
        
        public static void SetSound(Sound sound)
        {
            if (!sound)
            {
                return;
            }
                
            if (!instance)
            {
                instance = GetWindow<SoundPlayerEditorWindow>("Sound Player");
                instance.minSize = new Vector2(400, 500);
            }
            
            instance.InternalSetSound(sound);
            instance.Show();
            instance.Focus();
        }

        private void InternalSetSound(Sound sound)
        {
            currentSoundAsset = sound;
            currentAssetPath = AssetDatabase.GetAssetPath(sound);
            Initialize();
            Repaint(); 
        }

        private void OnGUI()
        {
            if (!currentSoundAsset)
            {
                EditorGUILayout.HelpBox("No sound selected", MessageType.Info);
                ReloadSound().Forget();
                return;
            }
            
            scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);

            EditorGUILayout.LabelField(currentSoundAsset.name, EditorStyles.boldLabel);
            EditorGUILayout.Space();

            DisplayWaveform();
            
            EditorGUILayout.BeginHorizontal();
            
            GUIContent playContent = EditorGUIUtility.IconContent("PlayButton");
            GUIContent pauseContent = EditorGUIUtility.IconContent("PauseButton");
            GUIContent stopContent = EditorGUIUtility.IconContent("d_PreMatQuad");
            
            playContent.tooltip = "Play";
            pauseContent.tooltip = "Pause";
            stopContent.tooltip = "Stop";
            
            if (isPlaying)
            {
                if (GUILayout.Button(pauseContent, GUILayout.Width(40)))
                {
                    PauseSound();
                }
                
                if (GUILayout.Button(stopContent, GUILayout.Width(40)))
                {
                    StopSound();
                }
            }
            else if (isPaused)
            {
                playContent.tooltip = "Resume";
                
                if (GUILayout.Button(playContent, GUILayout.Width(40)))
                {
                    ResumeSound();
                }
                
                if (GUILayout.Button(stopContent, GUILayout.Width(40)))
                {
                    StopSound();
                }
            }
            else
            {
                if (GUILayout.Button(playContent, GUILayout.Width(40)))
                {
                    PlaySound();
                }
            }
            
            List<AudioClip> clips = currentSoundAsset.GetAudioClips();
            if (clips.Count > 1)
            {
                DisplayClipSelectionControls(clips);
            }
            
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.Space(5);
            
            DisplaySoundSettings();
            
            EditorGUILayout.EndScrollView();
            
            if (GUI.changed && currentSoundAsset)
            {
                EditorUtility.SetDirty(currentSoundAsset);
            }
        }
        
        private void DisplayClipSelectionControls(List<AudioClip> clips)
        {
            EditorGUILayout.BeginHorizontal();
            
            EditorGUILayout.LabelField("Audio Clip:", GUILayout.Width(70));
            
            EditorGUI.BeginDisabledGroup(selectedClipIndex <= 0);
            if (GUILayout.Button("<", GUILayout.Width(30)))
            {
                ChangeSelectedClip(selectedClipIndex - 1);
            }
            EditorGUI.EndDisabledGroup();
            
            GUIStyle centeredStyle = new(EditorStyles.textField)
            {
                alignment = TextAnchor.MiddleCenter
            };
            
            string clipName = clips[selectedClipIndex] 
                ? clips[selectedClipIndex].name 
                : "Missing Clip";
            
            // Display format: "1/5: ClipName"
            string indexDisplay = $"{selectedClipIndex + 1}/{clips.Count}: {clipName}";
            
            EditorGUILayout.LabelField(indexDisplay, centeredStyle, GUILayout.ExpandWidth(true));
            
            EditorGUI.BeginDisabledGroup(selectedClipIndex >= clips.Count - 1);
            if (GUILayout.Button(">", GUILayout.Width(30)))
            {
                ChangeSelectedClip(selectedClipIndex + 1);
            }
            EditorGUI.EndDisabledGroup();
            
            EditorGUILayout.EndHorizontal();
        }
        
        private void ChangeSelectedClip(int newIndex)
        {
            List<AudioClip> clips = currentSoundAsset.GetAudioClips();
            if (newIndex < 0 || newIndex >= clips.Count)
            {
                return;
            }
            
            StopSound();
            
            selectedClipIndex = newIndex;
            currentClip = clips[selectedClipIndex];
            stopTime = currentClip.length;
            waveformGenerated = false;
        }

        private void DisplaySoundSettings()
        {
            if (!currentSoundAsset || !soundEditor)
            {
                return;
            }
            
            SerializedObject serializedSound = soundEditor.serializedObject;
            
            EditorGUILayout.LabelField("Basic Settings", EditorStyles.boldLabel);
            
            SerializedProperty volumeProperty = serializedSound.FindProperty("volume");
            EditorGUI.BeginChangeCheck();
            float newVolume = EditorGUILayout.Slider("Volume", volumeProperty.floatValue, 0f, 1f);
            if (EditorGUI.EndChangeCheck())
            {
                volumeProperty.floatValue = newVolume;
                serializedSound.ApplyModifiedProperties();
                
                if (isPlaying && audioSource)
                {
                    audioSource.volume = newVolume;
                }
            }
            
            SerializedProperty pitchProperty = serializedSound.FindProperty("pitch");
            
            float currentPitch = Mathf.Max(MIN_PITCH_VALUE, pitchProperty.floatValue);
            
            if (!Mathf.Approximately(currentPitch, DEFAULT_PITCH_VALUE))
            {
                EditorGUILayout.HelpBox("Pitch affects both tone and playback speed. 1.0 is normal speed/pitch.",
                    MessageType.Info);
            }
            
            EditorGUI.BeginChangeCheck();
            float newPitch = EditorGUILayout.Slider("Pitch", currentPitch, MIN_PITCH_VALUE, MAX_PITCH_VALUE);
            
            if (EditorGUI.EndChangeCheck())
            {
                pitchProperty.floatValue = newPitch;
                serializedSound.ApplyModifiedProperties();
                
                if (isPlaying && audioSource)
                {
                    audioSource.pitch = newPitch;
                }
            }
            
            SerializedProperty panProperty = serializedSound.FindProperty("stereoPan");
            EditorGUI.BeginChangeCheck();
            float newPan = EditorGUILayout.Slider("Stereo Pan", panProperty.floatValue, -1f, 1f);
            if (EditorGUI.EndChangeCheck())
            {
                panProperty.floatValue = newPan;
                serializedSound.ApplyModifiedProperties();
                
                if (isPlaying && audioSource)
                {
                    audioSource.panStereo = newPan;
                }
            }
            
            SerializedProperty reverbProperty = serializedSound.FindProperty("reverbZoneMix");
            EditorGUI.BeginChangeCheck();
            float newReverb = EditorGUILayout.Slider("Reverb Zone Mix", reverbProperty.floatValue, 0f, 1.1f);
            if (EditorGUI.EndChangeCheck())
            {
                reverbProperty.floatValue = newReverb;
                serializedSound.ApplyModifiedProperties();
                
                if (isPlaying && audioSource)
                {
                    audioSource.reverbZoneMix = newReverb;
                }
            }
            
            EditorGUILayout.Space(SECTION_SPACING);
            EditorGUILayout.LabelField("Playback Settings", EditorStyles.boldLabel);
            
            SerializedProperty playbackModeProperty = serializedSound.FindProperty("playbackMode");
            EditorGUILayout.PropertyField(playbackModeProperty, new GUIContent("Playback Mode"));
            
            SerializedProperty repeatModeProperty = serializedSound.FindProperty("repeatMode");
            EditorGUILayout.PropertyField(repeatModeProperty, new GUIContent("Repeat Mode"));
            
            EditorGUILayout.Space(SECTION_SPACING);
            EditorGUILayout.LabelField("Spatial Settings", EditorStyles.boldLabel);
            
            SerializedProperty spatialBlendProperty = serializedSound.FindProperty("spatialBlend");
            EditorGUI.BeginChangeCheck();
            float newSpatialBlend =
                EditorGUILayout.Slider("Spatial Blend (2D-3D)", spatialBlendProperty.floatValue, 0f, 1f);
            if (EditorGUI.EndChangeCheck())
            {
                spatialBlendProperty.floatValue = newSpatialBlend;
                serializedSound.ApplyModifiedProperties();
                
                if (isPlaying && audioSource)
                {
                    audioSource.spatialBlend = newSpatialBlend;
                }
            }
            
            if (spatialBlendProperty.floatValue > 0)
            {
                SerializedProperty dopplerProperty = serializedSound.FindProperty("dopplerLevel");
                EditorGUI.BeginChangeCheck();
                float newDoppler = EditorGUILayout.Slider("Doppler Level", dopplerProperty.floatValue, 0f, 5f);
                if (EditorGUI.EndChangeCheck())
                {
                    dopplerProperty.floatValue = newDoppler;
                    serializedSound.ApplyModifiedProperties();
                    
                    if (isPlaying && audioSource)
                    {
                        audioSource.dopplerLevel = newDoppler;
                    }
                }
                
                SerializedProperty spreadProperty = serializedSound.FindProperty("spread");
                EditorGUI.BeginChangeCheck();
                float newSpread = EditorGUILayout.Slider("Spread", spreadProperty.floatValue, 0f, 360f);
                if (EditorGUI.EndChangeCheck())
                {
                    spreadProperty.floatValue = newSpread;
                    serializedSound.ApplyModifiedProperties();
                    
                    if (isPlaying && audioSource)
                    {
                        audioSource.spread = newSpread;
                    }
                }
                
                SerializedProperty minDistProperty = serializedSound.FindProperty("minDistance");
                EditorGUI.BeginChangeCheck();
                float newMinDist = EditorGUILayout.FloatField("Min Distance", minDistProperty.floatValue);
                if (EditorGUI.EndChangeCheck())
                {
                    minDistProperty.floatValue = Mathf.Max(0.1f, newMinDist);
                    serializedSound.ApplyModifiedProperties();
                    
                    if (isPlaying && audioSource)
                    {
                        audioSource.minDistance = minDistProperty.floatValue;
                    }
                }
                
                SerializedProperty maxDistProperty = serializedSound.FindProperty("maxDistance");
                EditorGUI.BeginChangeCheck();
                float newMaxDist = EditorGUILayout.FloatField("Max Distance", maxDistProperty.floatValue);
                if (EditorGUI.EndChangeCheck())
                {
                    maxDistProperty.floatValue = Mathf.Max(minDistProperty.floatValue, newMaxDist);
                    serializedSound.ApplyModifiedProperties();
                    
                    if (isPlaying && audioSource)
                    {
                        audioSource.maxDistance = maxDistProperty.floatValue;
                    }
                }
                
                SerializedProperty rolloffProperty = serializedSound.FindProperty("volumeRolloff");
                EditorGUI.BeginChangeCheck();
                AudioRolloffMode newRolloff = (AudioRolloffMode)EditorGUILayout.EnumPopup("Volume Rolloff", (AudioRolloffMode)rolloffProperty.enumValueIndex);
                if (EditorGUI.EndChangeCheck())
                {
                    rolloffProperty.enumValueIndex = (int)newRolloff;
                    serializedSound.ApplyModifiedProperties();
                    
                    if (isPlaying && audioSource)
                    {
                        audioSource.rolloffMode = newRolloff;
                    }
                }
            
                EditorGUILayout.Space(1);
                
                if ((AudioRolloffMode)rolloffProperty.enumValueIndex == AudioRolloffMode.Custom)
                {
                    SerializedProperty customCurveProperty = serializedSound.FindProperty("customRolloffCurve");
                    
                    EditorGUILayout.BeginHorizontal();
                    
                    Rect curveRect = EditorGUILayout.GetControlRect(false, 18);
                    EditorGUI.BeginChangeCheck();
                    EditorGUI.CurveField(curveRect, customCurveProperty, RolloffVisualizer.VolumeColor, new Rect(0, 0, 1, 1));
                    if (EditorGUI.EndChangeCheck())
                    {
                        serializedSound.ApplyModifiedProperties();
                    }
                    EditorGUILayout.EndHorizontal();
                }
                
                Rect visualizationRect = EditorGUILayout.GetControlRect(false, 200);
                
                RolloffVisualizer.DrawRolloffCurve(
                    visualizationRect,
                    minDistProperty.floatValue,
                    maxDistProperty.floatValue,
                    (AudioRolloffMode)rolloffProperty.enumValueIndex,
                    true,
                    spatialBlendProperty.floatValue,
                    true,
                    spreadProperty.floatValue,
                    true,
                    reverbProperty.floatValue,
                    rolloffProperty.enumValueIndex == (int)AudioRolloffMode.Custom ? currentSoundAsset.CustomRolloffCurve : null);
            }
            
            bool checkLowPass = serializedSound.FindProperty("useLowPassFilter").boolValue;
            bool checkHighPass = serializedSound.FindProperty("useHighPassFilter").boolValue;
            
            if (checkLowPass || checkHighPass)
            {
                EditorGUILayout.LabelField("Audio Filters Response", EditorStyles.boldLabel);
                
                Rect filterVisualizationRect = EditorGUILayout.GetControlRect(false, 50);
                
                float lowPassCutoff = serializedSound.FindProperty("cutoffFrequency").floatValue;
                float lowPassQ = serializedSound.FindProperty("lowpassResonanceQ").floatValue;
                float highPassCutoff = serializedSound.FindProperty("highPassCutoffFrequency").floatValue;
                float highPassQ = serializedSound.FindProperty("highPassResonanceQ").floatValue;
                
                FilterVisualizer.DrawFilterVisualization(
                    filterVisualizationRect,
                    checkLowPass,
                    lowPassCutoff,
                    lowPassQ,
                    checkHighPass,
                    highPassCutoff,
                    highPassQ);
                
                EditorGUILayout.Space(30); // Add space for the legend
            }
            
            EditorGUILayout.LabelField("Low Pass Filter", EditorStyles.boldLabel);
            
            SerializedProperty useLowPassProperty = serializedSound.FindProperty("useLowPassFilter");
            EditorGUI.BeginChangeCheck();
            bool useLowPass = EditorGUILayout.Toggle("Use Low Pass Filter", useLowPassProperty.boolValue);
            if (EditorGUI.EndChangeCheck())
            {
                useLowPassProperty.boolValue = useLowPass;
                serializedSound.ApplyModifiedProperties();
                
                if (isPlaying && audioSource)
                {
                    AudioLowPassFilter lowPassFilter = audioSource.GetComponent<AudioLowPassFilter>();
                    switch (useLowPass)
                    {
                        case true when !lowPassFilter:
                            lowPassFilter = audioSource.gameObject.AddComponent<AudioLowPassFilter>();
                            lowPassFilter.cutoffFrequency = currentSoundAsset.CutoffFrequency;
                            lowPassFilter.lowpassResonanceQ = currentSoundAsset.LowpassResonanceQ;
                            break;
                        case false when lowPassFilter:
                            DestroyImmediate(lowPassFilter);
                            break;
                    }
                }
            }

            if (useLowPassProperty.boolValue)
            {
                SerializedProperty cutoffProperty = serializedSound.FindProperty("cutoffFrequency");
                EditorGUI.BeginChangeCheck();
                float newCutoff = EditorGUILayout.Slider("Cutoff Frequency", cutoffProperty.floatValue, 10f, 22000f);
                if (EditorGUI.EndChangeCheck())
                {
                    cutoffProperty.floatValue = newCutoff;
                    serializedSound.ApplyModifiedProperties();
                    
                    if (isPlaying && audioSource)
                    {
                        AudioLowPassFilter lowPassFilter = audioSource.GetComponent<AudioLowPassFilter>();
                        if (lowPassFilter)
                        {
                            lowPassFilter.cutoffFrequency = newCutoff;
                        }
                    }
                }
                
                SerializedProperty resonanceProperty = serializedSound.FindProperty("lowpassResonanceQ");
                EditorGUI.BeginChangeCheck();
                float newResonance = EditorGUILayout.Slider("Resonance Q", resonanceProperty.floatValue, 1f, 10f);
                if (EditorGUI.EndChangeCheck())
                {
                    resonanceProperty.floatValue = newResonance;
                    serializedSound.ApplyModifiedProperties();
                    
                    if (isPlaying && audioSource)
                    {
                        AudioLowPassFilter lowPassFilter = audioSource.GetComponent<AudioLowPassFilter>();
                        if (lowPassFilter)
                        {
                            lowPassFilter.lowpassResonanceQ = newResonance;
                        }
                    }
                }
            }
            
            EditorGUILayout.Space(SECTION_SPACING);
            EditorGUILayout.LabelField("High Pass Filter", EditorStyles.boldLabel);
            
            SerializedProperty useHighPassProperty = serializedSound.FindProperty("useHighPassFilter");
            EditorGUI.BeginChangeCheck();
            bool useHighPass = EditorGUILayout.Toggle("Use High Pass Filter", useHighPassProperty.boolValue);
            if (EditorGUI.EndChangeCheck())
            {
                useHighPassProperty.boolValue = useHighPass;
                serializedSound.ApplyModifiedProperties();
                
                if (isPlaying && audioSource)
                {
                    AudioHighPassFilter highPassFilter = audioSource.GetComponent<AudioHighPassFilter>();
                    switch (useHighPass)
                    {
                        case true when !highPassFilter:
                            highPassFilter = audioSource.gameObject.AddComponent<AudioHighPassFilter>();
                            highPassFilter.cutoffFrequency = currentSoundAsset.HighPassCutoffFrequency;
                            highPassFilter.highpassResonanceQ = currentSoundAsset.HighPassResonanceQ;
                            break;
                        case false when highPassFilter:
                            DestroyImmediate(highPassFilter);
                            break;
                    }
                }
            }

            if (useHighPassProperty.boolValue)
            {
                SerializedProperty highPassCutoffProperty = serializedSound.FindProperty("highPassCutoffFrequency");
                EditorGUI.BeginChangeCheck();
                float newHighPassCutoff = EditorGUILayout.Slider("Cutoff Frequency", highPassCutoffProperty.floatValue, 10f, 22000f);
                if (EditorGUI.EndChangeCheck())
                {
                    highPassCutoffProperty.floatValue = newHighPassCutoff;
                    serializedSound.ApplyModifiedProperties();
                    
                    if (isPlaying && audioSource)
                    {
                        AudioHighPassFilter highPassFilter = audioSource.GetComponent<AudioHighPassFilter>();
                        if (highPassFilter)
                        {
                            highPassFilter.cutoffFrequency = newHighPassCutoff;
                        }
                    }
                }
                
                SerializedProperty highPassResonanceProperty = serializedSound.FindProperty("highPassResonanceQ");
                EditorGUI.BeginChangeCheck();
                float newHighPassResonance = EditorGUILayout.Slider("Resonance Q", highPassResonanceProperty.floatValue, 1f, 10f);
                if (EditorGUI.EndChangeCheck())
                {
                    highPassResonanceProperty.floatValue = newHighPassResonance;
                    serializedSound.ApplyModifiedProperties();
                    
                    if (isPlaying && audioSource)
                    {
                        AudioHighPassFilter highPassFilter = audioSource.GetComponent<AudioHighPassFilter>();
                        if (highPassFilter)
                        {
                            highPassFilter.highpassResonanceQ = newHighPassResonance;
                        }
                    }
                }
            }
            
            EditorGUILayout.Space(SECTION_SPACING);
            EditorGUILayout.LabelField("Bit Crush Filter", EditorStyles.boldLabel);
            
            SerializedProperty useBitCrushProperty = serializedSound.FindProperty("useBitCrushFilter");
            if (useBitCrushProperty == null)
            {
                Debug.LogError("Could not find useBitCrushFilter property. Check the property name in Sound.cs");
                return;
            }
            
            EditorGUI.BeginChangeCheck();
            bool useBitCrush = EditorGUILayout.Toggle("Use Bit Crush Filter", useBitCrushProperty.boolValue);
            if (EditorGUI.EndChangeCheck())
            {
                useBitCrushProperty.boolValue = useBitCrush;
                serializedSound.ApplyModifiedProperties();
                
                if (isPlaying && audioSource)
                {
                    BitCrushFilter bitCrushFilter = audioSource.GetComponent<BitCrushFilter>();
                    switch (useBitCrush)
                    {
                        case true when !bitCrushFilter:
                            bitCrushFilter = audioSource.gameObject.AddComponent<BitCrushFilter>();
                            SerializedObject serializedFilter = new(bitCrushFilter);
                            SerializedProperty bitDepthProperty = serializedFilter.FindProperty("bitDepth");
                            SerializedProperty sampleRateProperty = serializedFilter.FindProperty("sampleRateReduction");
                            
                            bitDepthProperty.intValue = currentSoundAsset.BitDepth;
                            sampleRateProperty.intValue = currentSoundAsset.SampleRateReduction;
                            
                            serializedFilter.ApplyModifiedProperties();
                            break;
                        case false when bitCrushFilter:
                            DestroyImmediate(bitCrushFilter);
                            break;
                    }
                }
            }
            
            if (currentSoundAsset.UseBitCrushFilter)
            {
                SerializedProperty bitDepthProperty = serializedSound.FindProperty("bitDepth");
                EditorGUI.BeginChangeCheck();
                int newBitDepth = EditorGUILayout.IntSlider("Bit Depth", bitDepthProperty.intValue, 1, 16);
                bool bitDepthChanged = EditorGUI.EndChangeCheck();
                if (bitDepthChanged)
                {
                    bitDepthProperty.intValue = newBitDepth;
                    serializedSound.ApplyModifiedProperties();
                    
                    // Regenerate waveform when bit depth changes
                    waveformGenerated = false;
                    
                    if (isPlaying && audioSource)
                    {
                        BitCrushFilter bitCrushFilter = audioSource.GetComponent<BitCrushFilter>();
                        if (bitCrushFilter)
                        {
                            SerializedObject serializedFilter = new(bitCrushFilter);
                            SerializedProperty filterBitDepthProperty = serializedFilter.FindProperty("bitDepth");
                            filterBitDepthProperty.intValue = newBitDepth;
                            serializedFilter.ApplyModifiedProperties();
                        }
                    }
                }
                
                SerializedProperty sampleRateProperty = serializedSound.FindProperty("sampleRateReduction");
                EditorGUI.BeginChangeCheck();
                int newSampleRate = EditorGUILayout.IntSlider("Sample Rate Reduction", sampleRateProperty.intValue, 1, 32);
                bool sampleRateChanged = EditorGUI.EndChangeCheck();
                if (sampleRateChanged)
                {
                    sampleRateProperty.intValue = newSampleRate;
                    serializedSound.ApplyModifiedProperties();
                    
                    // Regenerate waveform when sample rate changes
                    waveformGenerated = false;
                    
                    if (isPlaying && audioSource)
                    {
                        BitCrushFilter bitCrushFilter = audioSource.GetComponent<BitCrushFilter>();
                        if (bitCrushFilter)
                        {
                            SerializedObject serializedFilter = new(bitCrushFilter);
                            SerializedProperty filterSampleRateProperty = serializedFilter.FindProperty("sampleRateReduction");
                            filterSampleRateProperty.intValue = newSampleRate;
                            serializedFilter.ApplyModifiedProperties();
                        }
                    }
                }
                
                if (newSampleRate > 1)
                {
                    EditorGUILayout.HelpBox("Higher values create a more lo-fi, retro sound effect.", MessageType.Info);
                }
            }
        }
        
        private void DisplayWaveform()
        {
            if (!currentClip)
            {
                return;
            }
            
            float availableWidth = EditorGUIUtility.currentViewWidth - 20;
            
            float currentTime = (isPlaying && audioSource) ? audioSource.time : pausedTime;
            
            // Initialize stop time to the end of clip if it's not set
            if (stopTime <= 0 || stopTime > currentClip.length)
            {
                stopTime = currentClip.length;
            }
            
            // Display playback stop time only if less than clip length
            string label = $"Time: {currentTime:F3} / {currentClip.length:F3}s";
            if (stopTime < currentClip.length)
            {
                label += $" -- Playback Stop Time: {stopTime:F3}s";
            }
            
            EditorGUILayout.LabelField(label);
            EditorGUILayout.Space(5);
            
            // Slider for current time
            Rect sliderRect = GUILayoutUtility.GetRect(availableWidth, 15);
            EditorGUI.BeginChangeCheck();
            float newCurrentTime = GUI.HorizontalSlider(sliderRect, currentTime, 0f, currentClip.length);
            if (EditorGUI.EndChangeCheck())
            {
                if (isPlaying && audioSource)
                    audioSource.time = newCurrentTime;
                else
                    pausedTime = newCurrentTime;
            }
            
            // Slider for stop time
            Rect stopSliderRect = GUILayoutUtility.GetRect(availableWidth, 15);
            EditorGUI.BeginChangeCheck();
            stopTime = Mathf.Max(newCurrentTime, GUI.HorizontalSlider(stopSliderRect, stopTime, 0f, currentClip.length));
            if (EditorGUI.EndChangeCheck())
            {
                if (stopTime < newCurrentTime)
                {
                    stopTime = newCurrentTime;
                }
            }
            
            EditorGUILayout.Space(5);
            
            // Waveform rect
            const float handleHalfWidth = 5f; 
            float waveformWidth = sliderRect.width - (handleHalfWidth * 2);
            
            Rect waveformRect = new(
                sliderRect.x + handleHalfWidth,
                stopSliderRect.yMax + 5,
                waveformWidth,
                100
            );
            
            GUILayoutUtility.GetRect(availableWidth, waveformRect.height + 5);
            
            if (!waveformGenerated || 
                !waveformTexture 
                || Mathf.Abs(waveformTexture.width - Mathf.RoundToInt(waveformRect.width)) > 1)
            {
                GenerateWaveformData(Mathf.RoundToInt(waveformRect.width));
            }
            
            if (Event.current.type == EventType.Repaint)
            {
                if (waveformTexture)
                {
                    GUI.DrawTexture(waveformRect, waveformTexture);
                    
                    // Highlight selected region
                    float startX = waveformRect.x + (currentTime / currentClip.length) * waveformRect.width;
                    float endX = waveformRect.x + (stopTime / currentClip.length) * waveformRect.width;
                    Rect selectionRect = new(startX, waveformRect.y, endX - startX, waveformRect.height);
                    EditorGUI.DrawRect(selectionRect, SelectedRegionColor);
                }
                
                // Draw playhead precisely aligned with slider handle
                float playheadX = waveformRect.x + (currentTime / currentClip.length) * waveformRect.width;
                Rect playheadRect = new(playheadX - 1, waveformRect.y, 2, waveformRect.height);
                EditorGUI.DrawRect(playheadRect, Color.yellow);
                
                // Draw stop time marker
                float stopX = waveformRect.x + (stopTime / currentClip.length) * waveformRect.width;
                Rect stopRect = new(stopX - 1, waveformRect.y, 2, waveformRect.height);
                EditorGUI.DrawRect(stopRect, Color.red);
                
                DrawTimeMarkers(waveformRect);
            }
            
            GUILayout.Space(20);
        }
        
        private void DrawTimeMarkers(Rect rect)
        {
            if (!currentClip)
            {
                return;
            }
            
            float totalSeconds = currentClip.length;
            float interval = totalSeconds switch
            {
                <= 3f => 0.25f,
                <= 20f => 1f,
                <= 60f => 5f,
                _ => 10f
            };
            
            GUIStyle labelStyle = new (EditorStyles.miniLabel)
            {
                alignment = TextAnchor.UpperCenter,
                normal = { textColor = Color.white }
            };
            
            float markerLabelY = rect.yMax + PADDING;
            Color defaultHandlesColor = Handles.color;
            for (float second = 0; second <= totalSeconds; second += interval)
            {
                float xPos = rect.x + (second / totalSeconds) * rect.width;
                Handles.color = TimeMarkerColor;
                Handles.DrawLine(new Vector2(xPos, rect.y), new Vector2(xPos, rect.yMax));
                
                // Draw label manually positioned below waveform
                Rect labelRect = new (
                    xPos - 15,
                    markerLabelY,
                    30,
                    LABEL_HEIGHT
                );
                
                GUI.Label(labelRect, second.ToString("0.##"), labelStyle);
            }
            
            Handles.color = defaultHandlesColor;
        }
        
        private void GenerateWaveformData(int width)
        {
            if (!currentClip || width <= 0)
            {
                return;
            }
            
            int resolution = Mathf.Clamp(width, 1, 2048);
            float[] samples = new float[currentClip.samples * currentClip.channels];
            currentClip.GetData(samples, 0);
            waveformData = new float[resolution];
            
            float samplesPerPixel = samples.Length / (float)resolution;
            float maxAmplitude = samples.Aggregate(0.01f, (current, t) => Mathf.Max(current, Mathf.Abs(t)));
            
            // Apply bit crush simulation if enabled
            int sampleRateReduction = 1;
            int bitDepth = 16;
            bool useBitCrush = false;
            if (currentSoundAsset && currentSoundAsset.UseBitCrushFilter)
            {
                sampleRateReduction = Mathf.Max(1, currentSoundAsset.SampleRateReduction);
                bitDepth = Mathf.Max(1, currentSoundAsset.BitDepth);
                useBitCrush = true;
            }
            
            float lastValue = 0;
            for (int i = 0; i < resolution; i++)
            {
                int start = Mathf.FloorToInt(i * samplesPerPixel);
                int end = Mathf.Min(samples.Length, Mathf.FloorToInt((i + 1) * samplesPerPixel));
                
                // Safety checks
                if (start >= samples.Length)
                {
                    start = samples.Length - 1;
                }
                
                if (end <= start)
                {
                    end = start + 1;
                }
                
                float maxSample = 0;
                for (int j = start; j < end; j++)
                {
                    maxSample = Mathf.Max(maxSample, Mathf.Abs(samples[j]));
                }
                
                // Normalized sample value
                float normalizedSample = maxSample / maxAmplitude;
                
                // Apply bit crush effects to waveform visualization if enabled
                if (useBitCrush)
                {
                    // Apply bit depth reduction 
                    if (bitDepth < 16)
                    {
                        // Calculate blend factor
                        float bitDepthFactor = Mathf.Lerp(0.2f, 0.5f, (16 - bitDepth) / 15f);
                        
                        // Calculate quantization steps - fewer levels for more visible effect
                        int levels = Mathf.Max(2, 1 << Mathf.Min(6, bitDepth/2));
                        float quantizedSample = Mathf.Floor(normalizedSample * levels) / levels;
                        
                        // Apply blend
                        normalizedSample = Mathf.Lerp(normalizedSample, quantizedSample, bitDepthFactor);
                    }
                    
                    // Apply sample rate reduction effect
                    if (sampleRateReduction > 1)
                    {
                        // Calculate step size - smaller divisor for more visible steps
                        int effectiveStepSize = Mathf.Max(1, Mathf.FloorToInt(sampleRateReduction / 2f));
                        
                        // Apply step effect
                        if (i % effectiveStepSize == 0)
                        {
                            lastValue = normalizedSample;
                        }
                        else if (i > 0)
                        {
                            // Blend with the previous step value
                            float blendFactor = Mathf.Lerp(0.2f, 0.6f, (sampleRateReduction - 1) / 31f);
                            normalizedSample = Mathf.Lerp(normalizedSample, lastValue, blendFactor);
                        }
                    }
                }
                
                waveformData[i] = normalizedSample;
            }
            
            GenerateWaveformTexture(width);
            waveformGenerated = true;
        }

        private void GenerateWaveformTexture(int width)
        {
            if (waveformData == null || width <= 0)
            {
                return;
            }
            
            if (waveformTexture)
            {
                DestroyImmediate(waveformTexture);
            }
            
            waveformTexture = new Texture2D(width, 100, TextureFormat.RGBA32, false);
            Color[] pixels = Enumerable.Repeat(WaveformBgColor, width * 100).ToArray();
            waveformTexture.SetPixels(pixels);
            
            int bitDepth = 16;
            bool useBitCrush = false;
            
            if (currentSoundAsset && currentSoundAsset.UseBitCrushFilter)
            {
                bitDepth = Mathf.Max(1, currentSoundAsset.BitDepth);
                useBitCrush = true;
            }
            
            for (int x = 0; x < width; x++)
            {
                // Safety check
                if (x >= waveformData.Length)
                {
                    continue;
                }
                
                float amplitude = waveformData[x];
                int waveHeight = Mathf.RoundToInt(amplitude * MID_Y);
                
                for (int y = -waveHeight; y <= waveHeight; y++)
                {
                    int drawY = MID_Y + y;
                    if (drawY is < 0 or >= 100)
                    {
                        continue;
                    }
                    
                    // Calculate normalized y position (0-1)
                    float normalizedY = 1.0f;
                    if (waveHeight > 0) // Avoid division by zero
                    {
                        normalizedY = 1.0f - Mathf.Abs(y) / (float)waveHeight;
                    }
                    
                    // Apply color quantization based on bit depth
                    if (useBitCrush && bitDepth < 16)
                    {
                        // Calculate effect factor
                        float bitDepthFactor = Mathf.Lerp(0.2f, 0.4f, (16 - bitDepth) / 15f);
                        
                        // Calculate color levels
                        int colorLevels = Mathf.Max(4, 1 << (bitDepth/3));
                        
                        // Apply quantization
                        float quantizedY = Mathf.Floor(normalizedY * colorLevels) / colorLevels;
                        
                        // Apply blend
                        normalizedY = Mathf.Lerp(normalizedY, quantizedY, bitDepthFactor);
                    }
                    
                    // Apply the final color
                    Color waveColor = Color.Lerp(WaveColorStart, WaveColorEnd, normalizedY);
                    waveformTexture.SetPixel(x, drawY, waveColor);
                }
            }
            
            waveformTexture.Apply();
        }
        
        private void Update()
        {
            if (!isPlaying || !audioSource)
            {
                return;
            }
            
            if (audioSource.time >= stopTime)
            {
                audioSource.Stop();
                audioSource.time = 0f;
                isPlaying = false;
                isPaused = false;
                pausedTime = 0f;
            }
            else if (!audioSource.isPlaying)
            {
                isPlaying = false;
                pausedTime = 0f;
            }
            else
            {
                pausedTime = audioSource.time;
            }
            
            Repaint();
        }
        
        private void PlaySound()
        {
            if (!currentClip || !audioSource)
            {
                return;
            }
            
            // Save the current position before anything else
            float startPosition = pausedTime;
            
            // Stop any current playback but without resetting pausedTime
            if (audioSource && audioSource.isPlaying)
            {
                audioSource.Stop();
            }
            
            audioSource.clip = currentClip;
            if (currentSoundAsset.OverrideMixerGroup)
            {
                audioSource.outputAudioMixerGroup = currentSoundAsset.OverrideMixerGroup;
            }
            
            audioSource.volume = currentSoundAsset.Volume;
            audioSource.pitch = Mathf.Clamp(currentSoundAsset.Pitch, MIN_PITCH_VALUE, MAX_PITCH_VALUE);
            audioSource.panStereo = currentSoundAsset.StereoPan;
            audioSource.reverbZoneMix = currentSoundAsset.ReverbZoneMix;
            audioSource.spatialBlend = currentSoundAsset.SpatialBlend;
            
            if (currentSoundAsset.SpatialBlend > 0)
            {
                audioSource.dopplerLevel = currentSoundAsset.DopplerLevel;
                audioSource.spread = currentSoundAsset.Spread;
                audioSource.rolloffMode = currentSoundAsset.VolumeRolloff;
                audioSource.minDistance = currentSoundAsset.MinDistance;
                audioSource.maxDistance = currentSoundAsset.MaxDistance;
            }
            
            if (currentSoundAsset.UseLowPassFilter)
            {
                AudioLowPassFilter lowPassFilter = audioSource.GetOrAddComponent<AudioLowPassFilter>();
                lowPassFilter.cutoffFrequency = currentSoundAsset.CutoffFrequency;
                lowPassFilter.lowpassResonanceQ = currentSoundAsset.LowpassResonanceQ;
            }
            else
            {
                AudioLowPassFilter lowPassFilter = audioSource.GetComponent<AudioLowPassFilter>();
                if (lowPassFilter)
                {
                    DestroyImmediate(lowPassFilter);
                }
            }
            
            if (currentSoundAsset.UseHighPassFilter)
            {
                AudioHighPassFilter highPassFilter = audioSource.GetOrAddComponent<AudioHighPassFilter>();
                highPassFilter.cutoffFrequency = currentSoundAsset.HighPassCutoffFrequency;
                highPassFilter.highpassResonanceQ = currentSoundAsset.HighPassResonanceQ;
            }
            else
            {
                AudioHighPassFilter highPassFilter = audioSource.GetComponent<AudioHighPassFilter>();
                if (highPassFilter)
                {
                    DestroyImmediate(highPassFilter);
                }
            }
            
            if (currentSoundAsset.UseBitCrushFilter)
            {
                BitCrushFilter bitCrushFilter = audioSource.GetOrAddComponent<BitCrushFilter>();
                
                SerializedObject serializedFilter = new (bitCrushFilter);
                SerializedProperty bitDepthProperty = serializedFilter.FindProperty("bitDepth");
                SerializedProperty sampleRateProperty = serializedFilter.FindProperty("sampleRateReduction");
                
                bitDepthProperty.intValue = currentSoundAsset.BitDepth;
                sampleRateProperty.intValue = currentSoundAsset.SampleRateReduction;
                
                serializedFilter.ApplyModifiedProperties();
            }
            else
            {
                BitCrushFilter bitCrushFilter = audioSource.GetComponent<BitCrushFilter>();
                if (bitCrushFilter)
                {
                    DestroyImmediate(bitCrushFilter);
                }
            }
            
            // Set the audio source time to saved position before playing
            audioSource.time = startPosition;
            audioSource.Play();
            isPlaying = true;
            isPaused = false;
        }
        
        private void PauseSound()
        {
            if (!audioSource || !audioSource.isPlaying)
            {
                return;
            }
            
            pausedTime = audioSource.time;
            audioSource.Pause();
            isPlaying = false;
            isPaused = true;
        }
        
        private void ResumeSound()
        {
            if (!audioSource || !isPaused)
            {
                return;
            }
            
            audioSource.time = pausedTime;
            audioSource.Play();
            isPlaying = true;
            isPaused = false;
        }
        
        private void StopSound()
        {
            if (audioSource && audioSource.isPlaying)
            {
                audioSource.Stop();
            }
            
            if (audioSource && audioSource.clip)
            {
                audioSource.time = 0f;
            }
            
            isPlaying = false;
            isPaused = false;
            pausedTime = 0f;
            
            Repaint();
        }
        
        private async UniTaskVoid ReloadSound()
        {
            await UniTask.Yield();
            string soundGUID = AssetDatabase.AssetPathToGUID(currentAssetPath);
            Sound sound = Audio.LoadSound(soundGUID);
            instance.InternalSetSound(sound);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/SoundBrowser/SoundPlayerEditorWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/ConvertToStandardShader.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 9a1bd04836de4c2d922a5b6b3d92dd8c
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Systems.Tools
{
    public class ConvertToStandardShader : MonoBehaviour
    {
        [MenuItem("Tools/Convert Materials To Standard")]
        private static void ConvertMaterials()
        {
            // Get the selected materials
            Material[] selectedMaterials = Selection.GetFiltered<Material>(SelectionMode.DeepAssets);

            // Iterate over each selected material
            foreach (Material material in selectedMaterials)
            {
                // Change the shader of the material to standard
                material.shader = Shader.Find("Standard");

                // Get the path of the material
                string path = AssetDatabase.GetAssetPath(material);

                // Add "_SRP" to the asset's name
                string newName = material.name + "_SRP";

                // Rename the asset
                AssetDatabase.RenameAsset(path, newName);

                // Force a save of the material
                EditorUtility.SetDirty(material);
            }

            // Finally, make sure all changes are saved to disk
            AssetDatabase.SaveAssets();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/ConvertToStandardShader.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/CopyLightingSettingsWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 49210353e63f45b4a5adf93a88d4e585
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Systems.ScenarioManagement.ScenarioUtilities;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Ldx.Framework.Systems.Tools
{
    /// <summary>
    /// Copies lighting and rendering settings from one currently open scene to another
    /// Added to Window > Rendering
    /// </summary>
    public class CopyLightingSettingsWindow : EditorWindow
    {
        private const int WINDOW_W = 500;
        private const int WINDOW_H = 200;
        
        private List<Scene> loadedScenes;
        private string[] sceneNames;
        private int fromIndex;
        private int toIndex;

        private bool didPerformCopy;
        private static GUIStyle finishedTextStyle;

        private static GUIStyle FinishedTextStyle
        {
            get
            {
                if (finishedTextStyle == null)
                {
                    finishedTextStyle = new GUIStyle(EditorStyles.boldLabel);
                    finishedTextStyle.normal.textColor = new Color(0.2f, 0.8f, 0.2f);
                    finishedTextStyle.alignment = TextAnchor.MiddleCenter;
                }
                return finishedTextStyle;
            }
        }
        
        [MenuItem("Window/Rendering/Copy Lighting Settings")]
        private static void ShowWindow()
        {
            var window = GetWindow<CopyLightingSettingsWindow>();
            window.titleContent = new GUIContent("Copy Lighting Settings");
            window.minSize = new Vector2(WINDOW_W, WINDOW_H);
            window.maxSize = new Vector2(WINDOW_W, WINDOW_H);
            window.Show();
        }

        private void OnEnable()
        {
            loadedScenes = SceneUtilities.GetAllLoadedScenes();
            sceneNames = loadedScenes.Select(s => s.name).ToArray();
            toIndex = Mathf.Max(0, sceneNames.Length - 1);
        }

        private void OnGUI()
        {
            LdxEditorHelper.DrawTitle("Copy Lighting Settings");
            LdxEditorHelper.DrawHorizontalSeparator();
            DrawSelection();
        }

        private void DrawSelection()
        {
            GUI.enabled = !didPerformCopy;
            using (new EditorGUILayout.HorizontalScope())
            {
                GUILayout.FlexibleSpace();
                using (new EditorGUILayout.VerticalScope())
                {
                    EditorGUILayout.LabelField("Copy From");
                    fromIndex = EditorGUILayout.Popup(fromIndex, sceneNames);
                    EditorGUILayout.LabelField("To");
                    toIndex = EditorGUILayout.Popup(toIndex, sceneNames);

                    GUI.enabled = !didPerformCopy && fromIndex != toIndex;
                    if (GUILayout.Button("Apply"))
                    {
                        CopyLightingSettings(sceneNames[fromIndex], sceneNames[toIndex]);
                        didPerformCopy = true;
                    }
                    GUI.enabled = true;

                    if (didPerformCopy)
                    {
                        GUILayout.FlexibleSpace();
                        EditorGUILayout.LabelField("Copying finished", FinishedTextStyle);
                    }
                }
                GUILayout.FlexibleSpace();
            }

            GUI.enabled = true;
        }
        
        private static void CopyLightingSettings(string fromSceneName, string toSceneName)
        {
            Scene activeScene = SceneManager.GetActiveScene();

            Scene sourceScene = SceneManager.GetSceneByName(fromSceneName);
            if (!sourceScene.IsValid())
            {
                Debug.LogError("Source scene is not loaded: " + fromSceneName);
                return;
            }
            SceneManager.SetActiveScene(sourceScene);
            RenderSettingsCache sourceCache = new RenderSettingsCache();

            Scene targetScene = SceneManager.GetSceneByName(toSceneName);
            if (!targetScene.IsValid())
            {
                Debug.LogError("Target scene is not loaded: " + toSceneName);
                return;
            }
            SceneManager.SetActiveScene(targetScene);

            sourceCache.Apply();

            EditorSceneManager.MarkSceneDirty(targetScene);

            SceneManager.SetActiveScene(activeScene);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/CopyLightingSettingsWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/EditorAssemblySanitizationTools.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 799d07eaabef49e4b277449e06284dbf
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using UnityEditor;
using UnityEngine;
using Debug = UnityEngine.Debug;
using Object = UnityEngine.Object;

namespace Ldx.Framework.Systems.Tools
{
    /// <summary>
    /// MenuItem tools to sanitize Runtime assembly from Editor scripts
    /// </summary>
    public static class EditorAssemblySanitizationTools
    {
        private static string RuntimePath => $"Modules{Separator}LdxFramework{Separator}Runtime";
        private static string EditorPath => $"Modules{Separator}LdxFramework{Separator}Editor";
        private static char Separator => Path.DirectorySeparatorChar;

        /// <summary>
        /// Quick MenuItem tool to move selected folder from the Runtime package to Editor package, recreating path  
        /// </summary>
        [MenuItem("Assets/Move To/Editor Assembly")]
        public static void MoveDirectoryToEditorAssemblyAction()
        {
            if (!EditorUtility.DisplayDialog("Confirmation",
                    "Are you sure you'd like to move this directory to the editor assembly?",
                    "Yes", "No"))
            {
                return;
            }

            Object selection = Selection.activeObject;
            string sourcePath = GetFullPath(AssetDatabase.GetAssetPath(selection.GetInstanceID()));
            MoveDirectoryToEditorAssembly(sourcePath);
        }

        [MenuItem("Assets/Move To/Editor Assembly", true)]
        public static bool MoveDirectoryToEditorAssemblyValidator()
        {
            Object selection = Selection.activeObject;
            if (selection == null)
            {
                return false;
            }

            if (!IsAssetAFolder(selection))
            {
                return false;
            }

            return GetFullPath(AssetDatabase.GetAssetPath(selection.GetInstanceID())).Contains(RuntimePath);
        }

        /// <summary>
        /// Quick editor tool to list any suspected Editor directory in the package's runtime assembly
        /// </summary>
        [MenuItem("LogicalDox/Framework/List Editor Directories in Runtime Assembly")]
        public static void ListEditorDirectoriesInRuntimeAssembly()
        {
            List<string> editorDirectories = GetRuntimeEditorDirectories();

            string output = "";

            if (editorDirectories.Count == 0)
            {
                output = "No Editor paths found";
            }
            else
            {
                output = "Found paths:\n\n";
                foreach (string dir in editorDirectories)
                {
                    output += $"* {dir}\n";
                }
            }

            EditorUtility.DisplayDialog("Result", output, "Ok");
        }

        /// <summary>
        /// Quick editor tool to move any suspected Editor directory in the package's runtime assembly
        /// </summary>
        [MenuItem("LogicalDox/Framework/Move Editor Directories From Runtime Assembly")]
        public static void MoveAllEditorDirectoriesFromRuntimeAssembly()
        {
            var output =
                "By clicking Continue, you'll move the following Editor paths from Runtime to Editor assemblies\n\n";

            List<string> editorDirectories = GetRuntimeEditorDirectories();

            if (editorDirectories.Count == 0)
            {
                EditorUtility.DisplayDialog("Result", "No Editor paths found in runtime assembly to move", "Ok");
                return;
            }

            foreach (string dir in editorDirectories)
            {
                output += $"* {dir}\n";
            }

            if (!EditorUtility.DisplayDialog("Warning", output, "Continue", "Cancel"))
            {
                return;
            }

            foreach (string dir in editorDirectories)
            {
                try
                {
                    MoveDirectoryToEditorAssembly(dir, false);
                }
                catch (Exception e)
                {
                    EditorUtility.DisplayDialog("Error", $"Error while moving {dir}\n\n{e}", "Ok");
                }
            }
            
            AssetDatabase.Refresh();
        }


        private static List<string> GetRuntimeEditorDirectories()
        {
            string rootPath = GetFullPath(RuntimePath);
            string[] subDirectories = Directory.GetDirectories(rootPath, "*", SearchOption.AllDirectories);

            // Initialize a list to store the paths that meet the conditions
            var editorDirectories = new List<string>();

            foreach (string directoryPath in subDirectories)
            {
                // Check if the directory name is "Editor"
                string directoryName = new DirectoryInfo(directoryPath).Name;
                if (directoryName.Equals("Editor", StringComparison.OrdinalIgnoreCase))
                {
                    // Check if the directory contains other files or sub-directories
                    string[] files = Directory.GetFiles(directoryPath);
                    string[] subDirs = Directory.GetDirectories(directoryPath);
                    if (files.Length > 0 || subDirs.Length > 0)
                    {
                        editorDirectories.Add(directoryPath);
                    }
                }
            }

            return editorDirectories;
        }

        private static void MoveDirectoryToEditorAssembly(string sourcePath, bool refreshAssetDatabaseAfter = true)
        {
            string destPath = sourcePath;
            // Replace with Editor path
            destPath = destPath.Replace(RuntimePath, EditorPath);
            // Remove last "Editor" directory from the path if applicable
            destPath = RemoveLastEditorDirectoryFromPathIfPresent(destPath);
            string parentDir = Path.GetDirectoryName(destPath);
            if (!Directory.Exists(parentDir))
            {
                Directory.CreateDirectory(parentDir);
            }

            CopyDirectoryContent(sourcePath, destPath);
            DeleteDirectory(sourcePath);
            if (Directory.Exists(sourcePath))
            {
                Directory.Delete(sourcePath);
            }

            if (refreshAssetDatabaseAfter)
            {
                AssetDatabase.Refresh();
            }
        }

        private static string RemoveLastEditorDirectoryFromPathIfPresent(string directoryPath)
        {
            string output = directoryPath;
            try
            {
                // Ensure the last sub-directory isn't called "Editor"
                string[] directories = output.Split(Path.DirectorySeparatorChar);

                if (directories.Length > 0 && directories[directories.Length - 1]
                        .Equals("Editor", StringComparison.OrdinalIgnoreCase))
                {
                    output = Path.GetDirectoryName(output);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e);
            }

            return output;
        }

        private static bool IsAssetAFolder(Object obj)
        {
            string path = "";

            if (obj == null)
            {
                return false;
            }

            path = AssetDatabase.GetAssetPath(obj.GetInstanceID());

            if (path.Length > 0)
            {
                Debug.Log(path);
                Debug.Log(GetFullPath(path));
                if (Directory.Exists(path))
                {
                    return true;
                }
            }

            return false;
        }

        private static string GetFullPath(string localPath)
        {
            return (Application.dataPath.Replace($"/Assets", $"/") + localPath)
                .Replace('\\', Separator).Replace('/', Separator);
        }

        private static void CopyDirectoryContent(string sourcePath, string destinationPath)
        {
            // Create the destination directory if it doesn't exist
            if (!Directory.Exists(destinationPath))
            {
                Directory.CreateDirectory(destinationPath);
            }

            // Copy files
            foreach (string filePath in Directory.GetFiles(sourcePath))
            {
                string fileName = Path.GetFileName(filePath);
                string destinationFilePath = Path.Combine(destinationPath, fileName);
                File.Copy(filePath, destinationFilePath, true);
            }

            // Copy subdirectories recursively
            foreach (string subdirectoryPath in Directory.GetDirectories(sourcePath))
            {
                string subdirectoryName = new DirectoryInfo(subdirectoryPath).Name;
                string destinationSubdirectoryPath = Path.Combine(destinationPath, subdirectoryName);
                CopyDirectoryContent(subdirectoryPath, destinationSubdirectoryPath);
            }
        }

        private static void DeleteDirectory(string directoryPath)
        {
            // Delete files
            foreach (string filePath in Directory.GetFiles(directoryPath))
            {
                File.Delete(filePath);
            }

            // Delete sub-directories recursively
            foreach (string subdirectoryPath in Directory.GetDirectories(directoryPath))
            {
                DeleteDirectory(subdirectoryPath);
            }

            // Delete the empty directory
            Directory.Delete(directoryPath);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/EditorAssemblySanitizationTools.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/IDSelectionOperation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 9ce543e82c6b4188a74aa78d3caa78ac
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Systems.Objectives;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    public abstract class IDSelectionOperation
    {
        public event Action OnPerformedOperation;
        
        public virtual string Title { get; }
        public virtual string WarningMessage { get; }
        public virtual string ButtonText { get; }
        protected HashSet<IDInfo> SelectionHashset { get; }
        protected SerializedObject SerializedObject { get; }
        protected LdxIdSettings Settings { get; }
        protected LdxIdSettings.IdType IDType { get; }

        protected bool IsGlobalSettings =>
            LdxIdSettings.GetInstanceType(Settings) == LdxIdSettings.InstanceTypeResult.Global;

        protected IDSelectionOperation(HashSet<IDInfo> selectionHashset, LdxIdSettings settings, SerializedObject serializedObject, LdxIdSettings.IdType idType)
        {
            SelectionHashset = selectionHashset;
            Settings = settings;
            IDType = idType;
            SerializedObject = serializedObject;
        }

        public void Draw()
        {
            EditorGUILayout.LabelField(Title, EditorStyles.boldLabel);
            DrawOperation();
            if (GUILayout.Button(ButtonText))
            {
                if (EditorUtility.DisplayDialog("Warning", WarningMessage, "Ok", "Cancel"))
                {
                    PerformOperation();
                    OnPerformedOperation?.Invoke();
                }
            }
        }

        public abstract void DrawOperation();
        public abstract void PerformOperation();
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/IDSelectionOperation.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/LdxSelectCommonMenu.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e74854bf3eec404b8a2332afbfa172b9
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Systems.ScenarioWindow;
using Ldx.Framework.Systems.UI;
using Ldx.Framework.UI.Dialog;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEditor.Callbacks;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Ldx.Framework.Utilities.Tools
{
    public class LdxSelectCommonMenu
    {
        public class ObjectSelection
        {
            public string Label { get; }
            public KeyCode KeyCode { get; }
            public Action Callback { get; }

            public void Select()
            {
                Callback?.Invoke();
            }
            
            public ObjectSelection(string label, KeyCode keyCode, Action callback)
            {
                Label = label;
                KeyCode = keyCode;
                Callback = callback;
            }
        }

        private static ModalEditorWindow modal = null;
        private static List<ObjectSelection> selections = null;

        [DidReloadScripts]
        [InitializeOnLoadMethod]
        private static void InitOnLoadEditor()
        {
            InitSelections();

            SceneView.duringSceneGui -= handleSceneGui;
            SceneView.duringSceneGui += handleSceneGui;
            EditorApplication.projectWindowItemOnGUI -= handleProjectWindowItem;
            EditorApplication.projectWindowItemOnGUI += handleProjectWindowItem;
            EditorApplication.hierarchyWindowItemOnGUI -= handleHierarchyWindow;
            EditorApplication.hierarchyWindowItemOnGUI += handleHierarchyWindow;
            
            void handleProjectWindowItem(string guid, Rect selectionrect)
            {
                HandleGUIUpdate();
            }

            void handleSceneGui(SceneView view)
            {
                HandleGUIUpdate();
            }
            
            void handleHierarchyWindow(int instanceid, Rect selectionrect)
            {
                HandleGUIUpdate();
            }
        }

        private static void HandleGUIUpdate()
        {
            Event e = Event.current;
            if (e == null)
            {
                return;
            }
            if (e.type == EventType.KeyDown)
            {
                if (e.keyCode == KeyCode.Tab && (e.control || e.command))
                {
                    e.Use();
                    DrawSelectionModal();
                }
                
                if (e.keyCode == KeyCode.Q && (e.control || e.command))
                {
                    e.Use();
                    ScenarioManagementEditorWindow.ShowWindow();
                }

            }
        }

        [MenuItem ("LogicalDox/Quick Select (ctrl+tab)", false, priority: 0)]
        private static void DrawSelectionModal()
        {
            float height = EditorGUIUtility.singleLineHeight * 5;
            height += EditorGUIUtility.singleLineHeight * selections.Count;
            modal = ModalEditorWindow.ShowModal("Quick Select", drawCallback);
            modal.SetSize(400, (int)height);
            modal.OnModalLostFocus += handleModalLostFocus;
            modal.OnModalClosed += handleModalClosed;
            
            void drawCallback()
            {
                checkKeyEvents();
                using (new GUILayout.VerticalScope(GUILayout.Height(height)))
                {
                    EditorGUILayout.LabelField("Tip: Use indicated shortcuts to select", EditorStyles.miniLabel);
                    foreach (ObjectSelection selection in selections)
                    {
                        string key = selection.KeyCode.ToString();
                        key = $"{key[^1]}";
                        if (GUILayout.Button($"{key}: {selection.Label}"))
                        {
                            selectObject(selection);
                            break;
                        }
                    }
                }
            }

            void checkKeyEvents()
            {
                Event e = Event.current;
                if (e.type == EventType.KeyDown)
                {
                    foreach (ObjectSelection selection in selections)
                    {
                        if (e.keyCode == selection.KeyCode)
                        {
                            e.Use();
                            if (!e.control && !e.command && !e.alt && !e.shift)
                            {
                                selectObject(selection);
                                return;    
                            }
                            
                        }
                    }
                }
            }

            void selectObject(ObjectSelection selection)
            {
                selection.Callback?.Invoke();
                closeModal();
            }

            void handleModalLostFocus()
            {
                if (modal == null)
                {
                    return;
                }
                modal.OnModalLostFocus -= handleModalLostFocus;
                modal.OnModalClosed -= handleModalClosed;   
                closeModal();
            }

            void handleModalClosed()
            {
                if (modal == null)
                {
                    return;
                }
                modal.OnModalLostFocus -= handleModalLostFocus;
                modal.OnModalClosed -= handleModalClosed;   
            }

            void closeModal()
            {
                if (modal == null)
                {
                    return;
                }
                modal.OnModalLostFocus -= handleModalLostFocus;
                modal.Close();
                modal = null;
            }
        }
        
        public static void InitSelections()
        {
            if (selections != null)
            {
                return;
            }

            selections = new List<ObjectSelection>
            {
                new("Tracking Manager", KeyCode.Alpha2, 
                    TrySelectObject<LdxTrackingManager>),
                new("UI Anchor Controller", KeyCode.Alpha3, 
                    TrySelectObject<UIAnchorController>),
                new("Global Data", KeyCode.Alpha4, 
                    ()=> Selection.activeObject = GlobalData.Instance),
                new("Player Controller", KeyCode.Alpha5, 
                    TrySelectObject<PlayerController>),
                new("UI Controller", KeyCode.Alpha6, 
                    TrySelectObject<UIController>),
                new(nameof(ScenarioData), KeyCode.Alpha7,
                    TrySelectScenarioData),
                new(nameof(PlayerRigData), KeyCode.Alpha8,
                    TrySelectRigData)
            };
        }

        private static void TrySelectObject<T>() where T : MonoBehaviour
        {
            T o = Object.FindFirstObjectByType<T>();
            if (o == null)
            {
                return;
            }
            Selection.activeObject = o;
        }

        private static void TrySelectScenarioData()
        {
            ScenarioData scenarioData = ScenarioEditorHelper.GetScenarioData();
            if (scenarioData == null)
            {
                return;
            }

            Selection.activeObject = scenarioData;
        }

        private static void TrySelectRigData()
        {
            ScenarioData scenarioData = ScenarioEditorHelper.GetScenarioData();
            if (scenarioData == null)
            {
                return;
            }

            PlayerRigData rigData = scenarioData.EDITOR_FindDataFileByType<PlayerRigData>();
            if (rigData == null)
            {
                return;
            }

            Selection.activeObject = rigData;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/LdxSelectCommonMenu.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/MigrateSelectionOperation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: abd7ba1ee1af4df7a791f65e5ddf7ef1
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using Ldx.Framework.Systems.Objectives;
using UnityEditor;

namespace Ldx.Framework.Utilities.Tools
{
    public class MigrateSelectionOperation : IDSelectionOperation
    {
        public override string Title => "Migrate";
        public override string ButtonText => "Migrate";
        public override string WarningMessage => "This will migrate the selected IDs and remove them from this file";

        private LdxIdSettings SourceSettings =>
            IsGlobalSettings ? LdxIdSettings.GlobalInstance : LdxIdSettings.GetScenarioIDSettings();
        private LdxIdSettings TargetSettings => 
            IsGlobalSettings ? LdxIdSettings.GetScenarioIDSettings() : LdxIdSettings.GlobalInstance;
        
        public MigrateSelectionOperation(HashSet<IDInfo> selectionHashset, LdxIdSettings settings, SerializedObject serializedObject, LdxIdSettings.IdType idType) : base(selectionHashset, settings, serializedObject, idType)
        {
        }
        
        public override void DrawOperation()
        {
            string from = IsGlobalSettings ? "global" : "scenario";
            string to = IsGlobalSettings ? "scenario" : "global";
            EditorGUILayout.LabelField($"This operation will migrate the selected IDs from {from} to {to} settings");
        }

        public override void PerformOperation()
        {
            foreach (var info in SelectionHashset)
            {
                TargetSettings.EDITOR_AddIdInfo(info, IDType);
                int? indexToRemove = null;
                var listProperty = IDInfoContainerDrawer.CurrentListProperty;
                for (int i = 0; i < listProperty.arraySize; i++)
                {
                    if (listProperty.GetArrayElementAtIndex(i).FindPropertyRelative("id").stringValue == info.ID)
                    {
                        indexToRemove = i;
                        break;
                    }
                }

                if (indexToRemove == null)
                {
                    continue;
                }
                listProperty.DeleteArrayElementAtIndex(indexToRemove.Value);
            }

            SerializedObject.ApplyModifiedProperties();
            EditorUtility.SetDirty(SourceSettings);
            EditorUtility.SetDirty(TargetSettings);
            
        }

    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/MigrateSelectionOperation.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/SceneSelectionToolbarMenu.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: ead49cb3a5d84ba4a93b87cbe74fe497
# ASMDEF: ldx.framework.editor.dll
# ---
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.ScenarioManagement.Data;
using Ldx.Framework.Systems.ScenarioManagement.Data.Scenarios;
using Ldx.Framework.Systems.ScenarioManagement.ScenarioUtilities;
using Ldx.Framework.Systems.SceneManagement;
using Ldx.Framework.Utilities.Editor;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEditor.SceneManagement;

namespace Ldx.Framework.Utilities.Tools
{
    public static class SceneSelectionToolbarMenu
    {
        private const string PARENT_PATH = "Scenes/";

        [InitializeOnLoadMethod]
        private static void Init()
        {
            EditorApplication.delayCall += CreateCustomMenus;
        }

        private static void CreateCustomMenus()
        {
            EditorApplication.delayCall -= CreateCustomMenus;

            GlobalData.Instance.Initialize();

            SceneReference bootstrapperScene = GlobalData.Instance.BootstrapperScene;

            // Add bootstrapper item
            DynamicMenuItem.AddMenuItem($"{PARENT_PATH}Bootstrapper", "", false,
                0, () => EditorSceneManager.OpenScene(bootstrapperScene.ScenePath),
                () => bootstrapperScene != null);

            ScenarioDataInfoContainer container = GlobalData.Instance.GetScenarioDataInfo();
            DynamicMenuItem.AddMenuItem($"{PARENT_PATH}----Scenarios----", "", false, 1, () => { }, () => false);
            DynamicMenuItem.AddMenuItem($"{PARENT_PATH}----Others----", "", false, 3, () => { }, () => false);

            foreach (ScenarioDataInfo info in container)
            {
                if (info.SceneReference == null)
                {
                    continue;
                }

                int priority = info.Type == ScenarioDataType.Scenario ? 2 : 4;
                string sceneName = info.SceneReference.GetSceneName();
                string path = PARENT_PATH + sceneName
                    .Replace("Scene", "")
                    .Replace("_", "")
                    .SeparateWords();
                DynamicMenuItem.AddMenuItem(path, "", false, priority,
                    () => loadSceneAndCheckRenderSettingsAsync(info).Forget(), () => true);
            }

            async UniTaskVoid loadSceneAndCheckRenderSettingsAsync(ScenarioDataInfo info)
            {
                if (!LdxEditorUtilities.CheckAndAskToSaveUnsavedScenes())
                {
                    return;
                }
                EditorSceneManager.OpenScene(info.SceneReference.ScenePath, OpenSceneMode.Single);
                foreach (SceneReference additionalScene in info.AdditionalScenes)
                {
                    EditorSceneManager.OpenScene(additionalScene.ScenePath, OpenSceneMode.Additive);
                }

                if (!info.CopyRenderSettingsFromAdditionalScene
                    || (info.AdditionalScenes == null || info.AdditionalScenes.Count < 1))
                {
                    return;
                }

                await UniTask.Yield();
                bool doRenderSettingsMatch =
                    await ScenarioHelper.CompareSceneRenderSettingsAsync(info.SceneReference, info.AdditionalScenes[0]);

                if (doRenderSettingsMatch)
                {
                    return;
                }

                string warningMessage = "Scenario scene's render settings don't match first additional scene." +
                                        "\nWould you like to match the scenario scene's render settings?";

                if (!EditorUtility.DisplayDialog("Warning", warningMessage, "Yes", "No"))
                {
                    return;
                }

                bool success = await ScenarioHelper.ApplyLightingSettingsFromFirstAdditionalSceneAsync(info.SceneReference,
                        info.AdditionalScenes);

                string operationMessage = success ? "Scenario's render settings matched successfully" : "Operation failed";
                EditorUtility.DisplayDialog("Message", operationMessage, "Ok");
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/SceneSelectionToolbarMenu.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/SelectObjectsWithMissingScripts.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 72f3ef3c0f624f2586167e3d4830e240
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Ldx.Framework.Utilities.Tools
{
    public static class SelectObjectsWithMissingScripts
    {
        private static GUIStyle deleteButtonStyle;

        private static GUIStyle DeleteButtonStyle
        {
            get
            {
                if (deleteButtonStyle == null)
                {
                    deleteButtonStyle = new GUIStyle(GUI.skin.button);
                    Texture2D bg = TextureUtilities.CreateRoundedTexture(30,
                        (int)EditorGUIUtility.singleLineHeight,
                        4,
                        new Color(0.8f, 0.3f, 0.3f));
                    deleteButtonStyle.normal.background = bg;
                    deleteButtonStyle.normal.scaledBackgrounds = new[] { bg };
                    deleteButtonStyle.normal.textColor = Color.white;
                    deleteButtonStyle.alignment = TextAnchor.LowerCenter;
                    deleteButtonStyle.fontStyle = FontStyle.Bold;
                }

                return deleteButtonStyle;
            }
        }

        [MenuItem("LogicalDox/Tools/Select \u2215 Delete Objects With Missing Scripts")]
        public static void SelectObjectsWithMissingScriptFeature()
        {
            List<GameObject> targetObjects = new List<GameObject>();
            GameObject selectedObject = Selection.activeObject as GameObject;
            List<GameObject> searchedObjects = new List<GameObject>();
            if (selectedObject != null)
            {
                if (EditorUtility.DisplayDialog("Options", "Which would you like to search?",
                        "Children of selected",
                        "All objects"))
                {
                    searchedObjects.Add(selectedObject);
                }
                else
                {
                    searchedObjects = Object.FindObjectsByType<GameObject>(FindObjectsInactive.Include, FindObjectsSortMode.None).ToList();
                }
            }
            else
            {
                searchedObjects = Object.FindObjectsByType<GameObject>(FindObjectsInactive.Include, FindObjectsSortMode.None).ToList();
            }

            foreach (GameObject obj in searchedObjects)
            {
                foreach (Component c in obj.GetComponents<Component>())
                {
                    if (c == null)
                    {
                        targetObjects.Add(obj);
                        break;
                    }
                }
            }

            if (targetObjects.Count == 0)
            {
                return;
            }

            if (targetObjects.Count == 1)
            {
                Selection.activeObject = targetObjects[0];
                return;
            }

            DrawSelectionModal(targetObjects);
        }

        private static void DrawSelectionModal(List<GameObject> objects)
        {
            ModalEditorWindow.ShowModal("Missing Scripts", drawSelectionModal);

            void drawSelectionModal()
            {
                using (new EditorGUILayout.HorizontalScope())
                {
                    if (GUILayout.Button("Remove All", DeleteButtonStyle))
                    {
                        deleteAllMissingScripts();
                    }

                    GUILayout.FlexibleSpace();
                }

                using (new EditorGUILayout.VerticalScope())
                {
                    foreach (GameObject obj in objects)
                    {
                        if (GUILayout.Button(obj.name))
                        {
                            Selection.activeObject = obj;
                        }
                    }
                }
            }

            void deleteAllMissingScripts()
            {
                int totalRemoved = 0;
                int originalCount = objects.Count;

                for (int i = objects.Count - 1; i >= 0; i--)
                {
                    if (DeleteMissingScripts(objects[i]))
                    {
                        totalRemoved++;
                        objects.RemoveAt(i);
                    }
                }

                string message = $"Removed missing scripts from {totalRemoved}/{originalCount} objects";
                Debug.Log(message);
                EditorUtility.DisplayDialog("Message", message, "Ok");
            }
        }

        private static bool DeleteMissingScripts(GameObject go)
        {
            bool success = true;
            bool didRemove = false;
            try
            {
                Component[] components = go.GetComponents<Component>();
                SerializedObject serializedObject = new SerializedObject(go);

                for (int i = components.Length - 1; i >= 0; i--)
                {
                    if (components[i] == null)
                    {
                        GameObjectUtility.RemoveMonoBehavioursWithMissingScript(go);
                        didRemove = true;
                    }
                }

                if (didRemove)
                {
                    serializedObject.ApplyModifiedProperties();
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e);
                success = false;
            }

            return success;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/SelectObjectsWithMissingScripts.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/ToolNameButton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: fc863e15839e2a14d89fbde388f8a9dc
# ASMDEF: ldx.framework.editor.dll
# ---
#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    [CustomEditor(typeof(ToolNameChanger))]
    public class ToolNameButton : UnityEditor.Editor
    {
        public override void OnInspectorGUI()
        {
            DrawDefaultInspector();

            ToolNameChanger myTarget = (ToolNameChanger)target;

            string currentNotice = "Please note that you should ALWAYS run a TestRun before you rename objects.";
            string cachedNotice = currentNotice;

            EditorGUILayout.HelpBox(currentNotice, MessageType.Info);

            if (GUILayout.Button("Start Renaming"))
            {
                myTarget.BeginRenameSequence();
            }
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/ToolNameButton.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/ToolNameChanger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 4a45f43607548ea4590ca420f3e2a2cb
# ASMDEF: ldx.framework.editor.dll
# ---
#if UNITY_EDITOR
using System.Collections.Generic;
using System.IO;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Tools
{
    public class ToolNameChanger : MonoBehaviour
    {
        public static ToolNameChanger instance;

        public string prefix;
        public string[] excludeNamesWith = { "debug", "Debug", "SDF", "sdf", "Sdf", "Lightmap" };
        [Tooltip("You can leave this blank")]
        public string mustContainString;
        [Tooltip("You can leave this blank")]
        public string removeString;
        public enum FileType { Material, Model, Prefab, Texture, Scene };
        public FileType fileType;

        [Header("Click below to begin renaming process [WARNING: THIS IS FINAL]")]
        [Tooltip("Click this if you want to read how it will be handled through console but not actually rename")]
        public bool testRun = true;


        public void BeginRenameSequence()
        {
            UnityEngine.Debug.ClearDeveloperConsole();
            instance = this;
            DetermineFileType();
            AssetDatabase.SaveAssets();
        }

        public void DetermineFileType()
        {
            switch (fileType)
            {
                case FileType.Material:
                    FindAssetsWithExtension<Object>(".mat");
                    break;
                case FileType.Model:
                    FindAssetsWithExtension<Object>(".fbx");
                    FindAssetsWithExtension<Object>(".obj");
                    break;
                case FileType.Prefab:
                    FindAssetsWithExtension<Object>(".prefab");
                    break;
                case FileType.Texture:
                    FindAssetsWithExtension<Object>(".png");
                    FindAssetsWithExtension<Object>(".jpeg");
                    FindAssetsWithExtension<Object>(".bmp");
                    break;
                case FileType.Scene:
                    FindAssetsWithExtension<Object>(".unity");
                    break;
            }
        }

        public static T[] FindAssetsWithExtension<T>(string fileExtension) where T : UnityEngine.Object
        {
            var paths = FindAssetPathsWithExtension(fileExtension);
            if (paths == null || paths.Length == 0)
                return null;

            List<T> assetsOfType = new List<T>();
            for (int i = 0; i < paths.Length; i++)
            {
                var asset = AssetDatabase.LoadAssetAtPath(paths[i], typeof(T)) as T;
                if (asset == null || (asset is T) == false)
                    continue;

                assetsOfType.Add(asset);
                //AssetDatabase.RenameAsset(paths[i], asset.name);
                instance.RenameObject(paths[i], asset.name);
                //Debug.Log($"adding {asset}");
            }

            return assetsOfType.ToArray();
        }


        /// <summary>
        /// A simple way to check if names and types area mismatched, very low level line of defense that only will catch a very small amount of misnames. 
        /// </summary>
        /// <returns></returns>
        public bool CorrectSetup()
        {
            string mismatchError = "CHECK YOUR PARAMETERS! Clear name/type mismatch.";

            // Maybe switch later?
            if (fileType == FileType.Material && (prefix == "Model_" || prefix == "model_" || prefix == "MODEL_" || prefix == "Prefab_" || prefix == "pref_" || prefix == "Pref_" || prefix == "prefab_" || prefix == "Tex_" || prefix == "tex_" || prefix == "TEX_"))
            {
                UnityEngine.Debug.LogError(mismatchError);
                return false;
            }
            else if (fileType == FileType.Model && (prefix == "Mat_" || prefix == "mat_" || prefix == "MAT_" || prefix == "Prefab_" || prefix == "pref_" || prefix == "Pref_" || prefix == "prefab_" || prefix == "Tex_" || prefix == "tex_" || prefix == "TEX_"))
            {
                UnityEngine.Debug.LogError(mismatchError);
                return false;
            }
            else if (fileType == FileType.Prefab && (prefix == "Mat_" || prefix == "mat_" || prefix == "MAT_" || prefix == "model_" || prefix == "MODEL_" || prefix == "Model_" || prefix == "Tex_" || prefix == "tex_" || prefix == "TEX_"))
            {
                UnityEngine.Debug.LogError(mismatchError);
                return false;
            }
            else if (fileType == FileType.Texture && (prefix == "Mat_" || prefix == "mat_" || prefix == "MAT_" || prefix == "model_" || prefix == "MODEL_" || prefix == "Model_" || prefix == "Prefab_" || prefix == "pref_" || prefix == "Pref_" || prefix == "prefab_"))
            {
                UnityEngine.Debug.LogError(mismatchError);
                return false;
            }
            else if (fileType == FileType.Scene && (prefix == "Mat_" || prefix == "mat_" || prefix == "MAT_" || prefix == "model_" || prefix == "MODEL_" || prefix == "Model_" || prefix == "Prefab_" || prefix == "pref_" || prefix == "Pref_" || prefix == "prefab_"))
            {
                UnityEngine.Debug.LogError(mismatchError);
                return false;
            }

            return true;
        }

        //Overengineered - leaving it as the "prefix ==" above - keeping this for reference
        //private bool prefixCheck()
        //{
        //    string[] matPrefix = { "Mat_", "mat_", "MAT_", "Material_", "MATERIAL_", "material_" };
        //    string[] scenePrefix = { "Scene_", "scene_", "SCENE_" };
        //    string[] modelPrefix = { "Model_", "MODEL_", "model_" };
        //    string[] texPrefix = { "Tex_", "tex_", "TEX_", "texture_", "Texture_", "TEXTURE_" };
        //    string[] prefabPrefix = { "pref_", "Pref_", "PREF_", "prefab_", "Prefab_", "PREFAB_" };

        //    switch (fileType)
        //    {
        //        case FileType.Scene:
        //            CheckList(matPrefix);
        //            CheckList(modelPrefix);
        //            CheckList(texPrefix);
        //            CheckList(prefabPrefix);
        //            break;
        //        case FileType.Material:
        //            CheckList(scenePrefix);
        //            CheckList(modelPrefix);
        //            CheckList(texPrefix);
        //            CheckList(prefabPrefix);
        //            break;
        //        case FileType.Model:
        //            CheckList(matPrefix);
        //            CheckList(scenePrefix);
        //            CheckList(texPrefix);
        //            CheckList(prefabPrefix);
        //            break;
        //        case FileType.Texture:
        //            CheckList(matPrefix);
        //            CheckList(modelPrefix);
        //            CheckList(scenePrefix);
        //            CheckList(prefabPrefix);
        //            break;
        //        case FileType.Prefab:
        //            CheckList(matPrefix);
        //            CheckList(modelPrefix);
        //            CheckList(texPrefix);
        //            CheckList(scenePrefix);
        //            break;

        //    }

        //    return true;

        //}

        //private bool CheckList(string[] list)
        //{
        //    foreach (string m_string in list)
        //        if (prefix == m_string)
        //            return true;
        //    return false;
        //}


        /// <summary>
        /// returns true if the prefix is the same as your prefix, only in lower or upper case.
        /// </summary>
        /// <param name="word"></param>
        /// <returns></returns>
        public bool CheckCase(string word)
        {
            if (prefix == "") //otherwise this will always be false.
                return false;

            else if (word.StartsWith(prefix.ToLower()) || word.StartsWith(prefix.ToUpper()))
            {
                UnityEngine.Debug.LogWarning($"Not renaming {word} as it's either upper or lower case {prefix}, reading {prefix.ToLower()} or {prefix.ToUpper()}");
                return true;
            }

            //Debug.LogWarning($"Not renaming {word} as it is merely a case issue");
            return false;
        }


        public static string[] FindAssetPathsWithExtension(string fileExtension)
        {
            if (string.IsNullOrEmpty(fileExtension))
                return null;

            if (fileExtension[0] == '.')
                fileExtension = fileExtension.Substring(1);

            DirectoryInfo directoryInfo = new DirectoryInfo(Application.dataPath);
            FileInfo[] fileInfos = directoryInfo.GetFiles("*." + fileExtension, SearchOption.AllDirectories);

            List<string> assetPaths = new List<string>();
            foreach (var file in fileInfos)
            {
                var assetPath = file.FullName.Replace(@"\", "/").Replace(Application.dataPath, "Assets");
                assetPaths.Add(assetPath);
            }

            return assetPaths.ToArray();
        }

        /// <summary>
        /// Rename an asset in the project hierarchy. Checks the prefix and banned word name first.
        /// </summary>
        /// <param name="path"></param>
        /// <param name="assetName"></param>
        public void RenameObject(string path, string assetName)
        {
            if (CorrectSetup())
            {
                if (!assetName.StartsWith(prefix) || prefix == "")
                {
                    if (excludeNamesWith.Length < 0)
                        foreach (string name in excludeNamesWith)
                        {
                            if (assetName.Contains(name))
                            {
                                UnityEngine.Debug.LogWarning($"Found forbidden word {name}");
                                break;
                            }

                            FinalChecksBeforeRename(path, assetName);

                        }
                    else
                    {
                        FinalChecksBeforeRename(path, assetName);
                    }
                }
                else
                {
                    UnityEngine.Debug.Log($"Not including {assetName} as it already is changed, or has a prohibited word");
                }
            }
        }

        public void FinalChecksBeforeRename(string path, string assetName)
        {
            if (!CheckCase(assetName))
            {
                UnityEngine.Debug.Log($"Renaming {assetName} to {prefix + assetName}!");
                if (assetName.Contains(mustContainString) || mustContainString == "")
                {
                    if (removeString != "" && assetName.Contains(removeString))
                    {
                        UnityEngine.Debug.LogWarning($"Removing {removeString} from {assetName} before applying final name");
                        string newName = assetName.Replace(removeString, "");
                        UnityEngine.Debug.Log($"New name: {newName}");
                        RenameAsset(path, prefix + newName);
                    }
                    else
                        RenameAsset(path, prefix + assetName);
                }
                else
                    UnityEngine.Debug.Log($"Not renaming {assetName} as it did not contain {mustContainString}");

            }
        }

        public void RenameAsset(string path, string assetName)
        {
            if (!testRun)
                AssetDatabase.RenameAsset(path, assetName);
        }


    }
}
#endif
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Tools/ToolNameChanger.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/GrabbingSocketingOperations.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e3738cc83d3793149bd8556af2d1ba9f
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using Autohand;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Player;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using Ldx.Framework.Utilities.Tools.Resocketing;
using UnityEngine;

namespace Ldx.Framework.Utilities.Wizard.Operations
{
    /// <summary>
    /// Wizard operation for making an object grabbable
    /// </summary>
    [Serializable] [WizardCategory(WizardCategoryList.GRABBING_AND_SOCKETING)]
    public class MakeGrabbableOperation : WizardOperation
    {
        private const string CHILD_NAME = "DesiredHandPositionAndRotation";
        
        [SerializeField] 
        private ColliderTypes colliderType = ColliderTypes.None;
        [SerializeField] 
        private bool addRigidbody = true;
        [SerializeField]
        private bool resocketsWhenDropped;
        [Tooltip("Allows you to set a hand position and rotation relative to the grabbable")]
        [SerializeField] 
        private bool addGrabbableCustomAlignment;
        
        public override string Description => "Sets up an object as Grabbable";
        
        public override bool IsConfigurationValid(out List<string> errors)
        {
            errors = null;
            return true;
        }
        
#pragma warning disable CS1998
        public override async UniTask PerformAsync(GameObject target)
#pragma warning restore CS1998
        {
            // Add grabbable
            target.GetOrAddComponent<Grabbable>();
            
            // Add collider
            switch (colliderType)
            {
                case ColliderTypes.Box:
                    target.GetOrAddComponent<BoxCollider>();
                    break;
                case ColliderTypes.Sphere:
                    target.GetOrAddComponent<SphereCollider>();
                    break;
                case ColliderTypes.Mesh:
                    target.GetOrAddComponent<MeshCollider>();
                    break;
                case ColliderTypes.None:
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            // Add rigidbody
            if (addRigidbody)
            {
                target.GetOrAddComponent<Rigidbody>();
            }
            
            // Add ResocketableItem
            if (resocketsWhenDropped)
            {
                target.GetOrAddComponent<ResocketableItem>();
            }

            // Add Grabbable Custom Alignment (Desired hand position/rotation in relation to the grabbable)
            if (addGrabbableCustomAlignment)
            {
                GrabbableCustomAlignment reference = target.GetOrAddComponent<GrabbableCustomAlignment>();
                GameObject desiredHandPosition = new GameObject(CHILD_NAME);
                desiredHandPosition.transform.SetParent(target.transform);
                desiredHandPosition.transform.position = target.transform.position;
                desiredHandPosition.transform.rotation = target.transform.rotation;
                //TODO: here
                /*reference.HandPositioningTransform = desiredHandPosition.transform;*/
            }
        }
    }
    
    [Serializable] [WizardCategory(WizardCategoryList.GRABBING_AND_SOCKETING)]
    public class SocketOperation : WizardOperation
    {
        [SerializeField] private ColliderTypes colliderType = ColliderTypes.None;
        [SerializeField] private bool addSocketIdFilter;
        
        public override string Description => "Add HVR Socket to object.";
        
        public override bool IsConfigurationValid(out List<string> errors)
        {
            errors = new List<string>();
            return true;
        }
        
#pragma warning disable CS1998
        public override async UniTask PerformAsync(GameObject target)
#pragma warning restore CS1998
        {
            Collider collider = null;
            switch (colliderType)
            {
                case ColliderTypes.Box:
                    collider = target.GetOrAddComponent<BoxCollider>();
                    break;
                case ColliderTypes.Sphere:
                    collider = target.GetOrAddComponent<SphereCollider>();
                    break;
                case ColliderTypes.Mesh:
                    collider = target.GetOrAddComponent<MeshCollider>();
                    break;
                case ColliderTypes.None:
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            if (collider != null)
            {
                collider.isTrigger = true;
            }
          
            target.GetOrAddComponent<PlacePoint>();
            
            /*if (addSocketIdFilter)
            {
                target.GetOrAddComponent<IDSocketFilter>();
            }*/
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/GrabbingSocketingOperations.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/HighlightingOperations.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 94ba333cec97d2648a542c61de24a0e9
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using HighlightPlus;
using Ldx.Framework.Features.Highlighting;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Ldx.Framework.Utilities.Wizard.Operations
{/// <summary>
    /// A wizard operation to setup an object for use with the hazard/highlighting system
    /// </summary>
    [WizardCategory(WizardCategoryList.HIGHLIGHTING)]
    [Serializable]
    public class HighlightableObjectOperation : WizardOperation
    {
        [SerializeField] private ColliderTypes colliderType;
        [SerializeField] private bool colliderIsTrigger;
        [Header("Override Default Highlighting Profile on Start?")] 
        [SerializeField] private HighlightProfile overrideProfile;

        public override string Description => "Sets up an object for use with the hazard/highlighting system";
        
        public override bool IsConfigurationValid(out List<string> errors)
        {
            errors = null;
            return true;
        }
        
#pragma warning disable CS1998
        public override async UniTask PerformAsync(GameObject target)
        {
            HighlightableObject highlightableObject = target.GetOrAddComponent<HighlightableObject>();
            target.layer = HighlightingGlobalSettings.GetHighlightingLayer();
            
            if (overrideProfile != null)
            {
                highlightableObject.SetNewOverrideProfile(overrideProfile);
            }
            
            target.GetOrAddComponent<HighlightEffect>();
            
            AddCollider(target);
        }
#pragma warning restore CS1998

        private void AddCollider(GameObject target)
        {
            if (colliderType == ColliderTypes.None)
            {
                return;
            }

            if (target.TryGetComponent(out Collider previous))
            {
                Object.DestroyImmediate(previous);
            }

            Collider addedCollider = null;

            switch (colliderType)
            {
                case ColliderTypes.Box:
                    addedCollider = target.AddComponent<BoxCollider>();
                    break;
                case ColliderTypes.Sphere:
                    addedCollider = target.AddComponent<SphereCollider>();
                    break;
                case ColliderTypes.Mesh:
                    addedCollider = target.AddComponent<MeshCollider>();
                    break;
                case ColliderTypes.None:
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            if (addedCollider != null)
            {
                addedCollider.isTrigger = colliderIsTrigger;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/HighlightingOperations.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/MakeInteractableObjectOperation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d80d79938d504733860fd7752b8908b3
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Features.Interaction;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Utilities.Wizard.Operations
{
    [Serializable] [WizardCategory(WizardCategoryList.GRABBING_AND_SOCKETING)]
    public class MakeInteractableObjectOperation : WizardOperation
    {
        [SerializeField] private ColliderTypes colliderType = ColliderTypes.None;
        
        public override string Description => "Sets up an object as Interactable";
        
        public override bool IsConfigurationValid(out List<string> errors)
        {
            errors = null;
            return true;
        }

        #pragma warning disable CS1998
        public override async UniTask PerformAsync(GameObject target)
#pragma warning restore CS1998
        {
            target.GetOrAddComponent<InteractableObject>();
            
            switch (colliderType)
            {
                case ColliderTypes.Box:
                    target.GetOrAddComponent<BoxCollider>();
                    break;
                case ColliderTypes.Sphere:
                    target.GetOrAddComponent<SphereCollider>();
                    break;
                case ColliderTypes.Mesh:
                    target.GetOrAddComponent<MeshCollider>();
                    break;
                case ColliderTypes.None:
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
            
            target.GetOrAddComponent<Rigidbody>();
            target.GetOrAddComponent<ObjectHighlighting>();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/MakeInteractableObjectOperation.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/MakePPEObjectOperation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: add9bf0d1992444198ee8ecd6bf3286a
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using Autohand;
using Cysharp.Threading.Tasks;
using HighlightPlus;
using Ldx.Framework.Features.PPE;
using Ldx.Framework.Features.Visual.FadeEffect;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Utilities.Wizard.Operations
{
    [WizardCategory(WizardCategoryList.FEATURES)]
    [Serializable]
    public class MakePPEObjectOperation : WizardOperation
    {
        public override string Description => "Sets up an object as PPE";
        
        [SerializeField] private ColliderTypes colliderType = ColliderTypes.None;
        [SerializeField] private bool addRigidbody = true;
        
        private enum HighlightingTypes
        {
            ScanShader,
            HighlightEffect,
            None,
        }
        
        [SerializeField] private HighlightingTypes highlightingType = HighlightingTypes.None;
        [SerializeField] private bool addAudioSource = true;
        
        public override bool IsConfigurationValid(out List<string> errors)
        {
            errors = null;
            return true;
        }
        
#pragma warning disable CS1998
        public override async UniTask PerformAsync(GameObject target)
#pragma warning restore CS1998
        {
            target.GetOrAddComponent<PPEObject>();
            target.GetOrAddComponent<Grabbable>();
            
            switch (colliderType)
            {
                case ColliderTypes.Box:
                    target.GetOrAddComponent<BoxCollider>();
                    break;
                case ColliderTypes.Sphere:
                    target.GetOrAddComponent<SphereCollider>();
                    break;
                case ColliderTypes.Mesh:
                    target.GetOrAddComponent<MeshCollider>();
                    break;
                case ColliderTypes.None:
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
            
            if (addRigidbody)
            {
                target.GetOrAddComponent<Rigidbody>();
            }

            switch (highlightingType)
            {
                case HighlightingTypes.ScanShader:
                    target.GetOrAddComponent<HighlightPulseEffect>();
                    break;
                case HighlightingTypes.HighlightEffect:
                    target.GetOrAddComponent<HighlightEffect>();
                    break;
                case HighlightingTypes.None:
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
            
            if (addAudioSource)
            {
                target.GetOrAddComponent<AudioSource>();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/MakePPEObjectOperation.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/MeshesCollidersOperations.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6bd932557a14030448e987aa4c8b9b2a
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Utilities.Wizard.Operations
{
    /// <summary>
    /// Wizard operation for combining children meshes into a mesh collider on the parent 
    /// </summary>
    [WizardCategory(WizardCategoryList.MESHES_AND_COLLIDERS)]
    public class CombineChildMeshesToMeshColliderOperation : WizardOperation
    {
        [SerializeField] 
        private bool convex = true;
        [SerializeField] 
        private bool removeCollidersOnChildrenWithMeshes;
        
        public override string Description => "Combines all child meshes in a single mesh assigned to a new or existing MeshCollider on this object" +
                                              "Use case: setting up all features on the parent, leaving the children for visuals";
        
        public override bool IsConfigurationValid(out List<string> errors)
        {
            errors = null;
            return true;
        }
        
#pragma warning disable CS1998
        public override async UniTask PerformAsync(GameObject target)
#pragma warning restore CS1998
        {
            target.CombineChildMeshes(removeCollidersOnChildrenWithMeshes);
            target.GetComponent<MeshCollider>().convex = convex;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/MeshesCollidersOperations.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/ObjectivesOperations.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e0efb2a4a9eea4141a1930fa613d9dc2
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Systems.Objectives.Tracking;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Utilities.Wizard.Operations
{
    /// <summary>
    /// Adds one of the trackable objective ID types to the object
    /// </summary>
    [WizardCategory(WizardCategoryList.OBJECTIVE_SYSTEM)]
    public class ObjectiveIdComponentOperation : WizardOperation
    {
        public enum IdsToAdd
        {
            Transform,
            ObjectGroup,
            SpawnPoint
        }

        [SerializeField] private IdsToAdd idTypeToAdd;
        
        public override string Description => "Add trackable IDs to game objects";
        
        public override bool IsConfigurationValid(out List<string> errors)
        {
            errors = null;
            return true;
        }
        
#pragma warning disable CS1998
        public override async UniTask PerformAsync(GameObject target)
#pragma warning restore CS1998
        {
            // Add ID Component
            switch (idTypeToAdd)
            {
                case IdsToAdd.Transform:
                    target.GetOrAddComponent<ObjectiveTransform>();
                    break;
                case IdsToAdd.ObjectGroup:
                    target.GetOrAddComponent<LdxObjectGroup>();
                    break;
                case IdsToAdd.SpawnPoint:
                    target.GetOrAddComponent<SpawnPoint>();
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
    }
    
    /// <summary>
    ///  A wizard operation to setup a zone configured to set a tracking key to true or false based on whether the player is inside
    /// </summary>
    [WizardCategory(WizardCategoryList.OBJECTIVE_SYSTEM)]
    public class ZoneWithTrackingKeySetterOperation : WizardOperation
    {
        public enum KeySetterTypes
        {
            Default = 0,
            CheckEverySecond
        }
        
        [SerializeField] private KeySetterTypes keySetterType;
        [SerializeField] private bool addGizmo = true;
        [SerializeField] private string gizmoLabel = "";
        
        public override string Description => "Sets up a zone configured to set a tracking key to true or false based on whether the player is inside";
        
        public override bool IsConfigurationValid(out List<string> errors)
        {
            errors = null;
            return true;
        }
        
#pragma warning disable CS1998
        public override async UniTask PerformAsync(GameObject target)
#pragma warning restore CS1998
        {
            BoxCollider col = target.GetOrAddComponent<BoxCollider>();
            col.isTrigger = true;

            switch (keySetterType)
            {
                case KeySetterTypes.Default:
                    target.GetOrAddComponent<CollisionTrackingKeySetter>();
                    break;
                case KeySetterTypes.CheckEverySecond:
                    target.GetOrAddComponent<CollisionTrackingKeySetterEverySecond>();
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            if (!addGizmo)
            {
                return;
            }

            DrawGizmo gizmo = target.GetOrAddComponent<DrawGizmo>();
            gizmo.Label = gizmoLabel;
            gizmo.Type = DrawGizmo.GizmoType.BoxCollider;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/ObjectivesOperations.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/RenderingShadersOperations.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 39b81fbd2dbf73f4d982d541b38ece0a
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Features.LineRenderers;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Utilities.Wizard.Operations
{
    /// <summary>
    /// Adds a custom wire simulator to an object
    /// </summary>
    [WizardCategory(WizardCategoryList.RENDERING)]
    public class WireSimulatorWithLineRendererOperation : WizardOperation
    {
        public override string Description => "Adds a custom component that uses a line renderer to simulate wires";
        
        public override bool IsConfigurationValid(out List<string> errors)
        {
            errors = null;
            return true;
        }
        
#pragma warning disable CS1998
        public override async UniTask PerformAsync(GameObject target)
#pragma warning restore CS1998
        {
            target.GetOrAddComponent<LineRenderer>();
            target.GetOrAddComponent<WireSimulator>();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/RenderingShadersOperations.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/SetupInstallObjectFeatureOperation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: ad301609c57c4d53a1d7daf091f3a7e8
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Linq;
using System.Collections.Generic;
using Autohand;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Features;
using Ldx.Framework.Features.Interaction;
using Ldx.Framework.Systems.Objectives;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Utilities.Wizard.Operations
{
    [Serializable] [WizardCategory(WizardCategoryList.FEATURES)]
    public class SetupInstallObjectFeatureOperation : WizardOperation
    {
        private const string EDITOR_NOTE_TEXT =
            "To complete the setup for '{1}':\n\n" + // {1} is interactableObject.name, good to lead with
            "1. Configure Events on '{0}' (the InstallObjectFeature component):\n" + // {0} is target.name
            "   - Set up the 'Start Feature' and 'Completed Feature' events.\n" +
            "   - Optionally, specify any GameObjects to enable/disable upon successful installation.\n\n" +
            "2. Adjust the Socket Pose for '{1}':\n" +
            "   - Select the '{2}' object and assign the 'Pose tag'.\n" + // {2} is socket.name
            "   - Assign the same pose tag and modify the position and rotation on the '{1}' interactable object.\n\n" +
            "3. Add Your Hologram Mesh:\n" +
            "   - Parent your model under the '{3}' GameObject. Make sure it's the same object as you are planning to install but remove all custom components (leave mesh renderers and filters).\n" + // {3} is hologramObject.name
            "   - Replace the placeholder child object '{4}' with your actual mesh."; // {3} is hMesh.name
        
        public override string Description => "Sets up an interactable object";

        [SerializeField] private InteractableObject interactableObject;
        [SerializeField] private bool setCurrentObjAsParentOfObject = true;
        [SerializeField] private uint numberOfSockets;
        [SerializeField] [IDSelection(LdxIdSettings.IdType.Socketable)]
        private string socketID;
        
        public override bool IsConfigurationValid(out List<string> errors)
        {
            errors = new List<string>();

            if (interactableObject == null)
            {
                errors.Add("interactableObject is null. Please set an interactable object to assign.");
            }
            
            return errors.Count < 1;
        }
        
#pragma warning disable CS1998
        public override async UniTask PerformAsync(GameObject target)
#pragma warning restore CS1998
        {
            target.name = $"InstallFeature: {interactableObject.name}";
            InstallObjectFeature feature = target.GetOrAddComponent<InstallObjectFeature>();

            if (setCurrentObjAsParentOfObject)
            {
                interactableObject.transform.SetParent(target.transform);
            }
            /*IDSocketable socketable = interactableObject.GetOrAddComponent<IDSocketable>();
            socketable.ID = socketID;*/

            PlacePoint[] sockets = new PlacePoint[numberOfSockets];
            HologramObjectHighlighting[] hologramObjects = new HologramObjectHighlighting[numberOfSockets];
            GameObject[] hMeshes = new GameObject[numberOfSockets];
            for (int i = 0; i < numberOfSockets; i++)
            {
                PlacePoint socket = new GameObject($"Socket: {interactableObject.name} ({i})")
                    .AddComponent<PlacePoint>();
                socket.transform.SetParent(target.transform);
                socket.transform.localPosition = Vector3.zero;
                socket.transform.localRotation = Quaternion.identity;
                
                BoxCollider collider = socket.GetOrAddComponent<BoxCollider>();
                collider.isTrigger = true;
            
                HologramObjectHighlighting hologramObject = new GameObject($"Hologram: {interactableObject.name} ({i})")
                    .AddComponent<HologramObjectHighlighting>();
                hologramObject.transform.SetParent(socket.transform);
                hologramObject.transform.localPosition = Vector3.zero;
                hologramObject.transform.localRotation = Quaternion.identity;
            
                GameObject hMesh = new("ADD YOUR MESH HERE");
                hMesh.transform.SetParent(hologramObject.transform);
                
                sockets[i] = socket;
                hologramObjects[i] = hologramObject;
                hMeshes[i] = hMesh;
            }

            /*IDSocketFilter socketFilter = socket.GetOrAddComponent<IDSocketFilter>();
            socketFilter.SetIDFilters(new List<string> { socketID });*/
            
            feature.EDITOR_AssignReferences(interactableObject, sockets, hologramObjects);

            EditorNote editorNote = target.AddComponent<EditorNote>();
            editorNote.NoteText = string.Format(
                EDITOR_NOTE_TEXT,
                target.name,
                interactableObject.name,
                string.Join(", ", sockets.Select(s => s.name)),
                string.Join(", ", hologramObjects.Select(h => h.name)),
                string.Join(", ", hMeshes.Select(m => m.name))
            );
            await UniTask.Yield();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/SetupInstallObjectFeatureOperation.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/SetupInteractableObjectOperation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 3d281f98ce004515a75b6c4e399b7ef3
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using Autohand;
using Cysharp.Threading.Tasks;
using HighlightPlus;
using Ldx.Framework.Features.Interaction;
using Ldx.Framework.Features.Visual.FadeEffect;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace Ldx.Framework.Utilities.Wizard.Operations
{
    /// <summary>
    /// Wizard operation to set up an interactable object on a Unity GameObject.
    /// </summary>
    [Serializable] [WizardCategory(WizardCategoryList.FEATURES)]
    public class SetupInteractableObjectOperation : WizardOperation
    {
        public override string Description => "Sets up an interactable object";
        
        [SerializeField] private ColliderTypes colliderType = ColliderTypes.None;
        [SerializeField] private bool addRigidbody = true;
        
        private enum HighlightingTypes
        {
            ScanShader,
            HighlightEffect,
            None,
        }
        
        [SerializeField] private HighlightingTypes highlightingType = HighlightingTypes.None;
        [SerializeField] private bool addAudioSource = true;
        
        public override bool IsConfigurationValid(out List<string> errors)
        {
            errors = null;
            return true;
        }
        
#pragma warning disable CS1998
        public override async UniTask PerformAsync(GameObject target)
#pragma warning restore CS1998
        {
            target.GetOrAddComponent<InteractableObject>();
            target.GetOrAddComponent<Grabbable>();
            
            switch (colliderType)
            {
                case ColliderTypes.Box:
                    target.GetOrAddComponent<BoxCollider>();
                    break;
                case ColliderTypes.Sphere:
                    target.GetOrAddComponent<SphereCollider>();
                    break;
                case ColliderTypes.Mesh:
                    target.GetOrAddComponent<MeshCollider>();
                    break;
                case ColliderTypes.None:
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
            
            if (addRigidbody)
            {
                target.GetOrAddComponent<Rigidbody>();
            }

            switch (highlightingType)
            {
                case HighlightingTypes.ScanShader:
                    target.GetOrAddComponent<HighlightPulseEffect>();
                    break;
                case HighlightingTypes.HighlightEffect:
                    target.GetOrAddComponent<HighlightEffect>();
                    break;
                case HighlightingTypes.None:
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
            
            if (addAudioSource)
            {
                target.GetOrAddComponent<AudioSource>();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/SetupInteractableObjectOperation.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/SplineOperations.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a846a7948c9a4d943bc1ca4b4ecac846
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Features.Splines;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Extensions;
using SplineMesh;
using UnityEngine;

namespace Ldx.Framework.Utilities.Wizard.Operations
{
    /// <summary>
    /// Creates a spline to simulate ropes or cables that move
    /// </summary>
    [WizardCategory(WizardCategoryList.SPLINES)]
    public class SplineCableSimulatorOperation : WizardOperation
    {
        public override string Description => "Use for simulating cables or ropes that deform to maintain length when nodes are grabbed\n" +
                                              "Adds the setup for Spline, SplineMeshTiling, and a custom cable simulator script";
        
        public override bool IsConfigurationValid(out List<string> errors)
        {
            errors = null;
            return true;
        }
        
#pragma warning disable CS1998
        public override async UniTask PerformAsync(GameObject target)
#pragma warning restore CS1998
        {
            target.GetOrAddComponent<Spline>();
            target.GetOrAddComponent<SplineMeshTiling>();
            target.GetOrAddComponent<SplineCableSimulator>();
        }
    }
    
    /// <summary>
    /// Adds a spline with a repeating mesh with optional tiling
    /// </summary>
    [WizardCategory(WizardCategoryList.SPLINES)]
    public class SplineMeshOperation : WizardOperation
    {
        [SerializeField] private bool addMeshTilingAlongSpline = true;
        
        public override string Description => "Adds splines that can be used for many purposes including cables and ropes.\n" +
                                              "Works by repeating a mesh along the spline with optional deforming options.";
        
        public override bool IsConfigurationValid(out List<string> errors)
        {
            errors = null;
            return true;
        }
        
#pragma warning disable CS1998
        public override async UniTask PerformAsync(GameObject target)
#pragma warning restore CS1998 
        {
            target.GetOrAddComponent<Spline>();
            if (addMeshTilingAlongSpline)
            {
                target.GetOrAddComponent<SplineMeshTiling>();
            }
        }
    }
    
    [WizardCategory(WizardCategoryList.SPLINES)]
    public class SplineMasterControllerOperation : WizardOperation
    {
        private const string VISUAL_PARENT_NAME = "VisualTransformNodesParent";
        private const string GRAB_START_NAME = "GrabStartNode";
        private const string GRAB_POINT_NAME = "GrabPointNode";
        private const string FINAL_POSITION_NAME = "GrabPointFinalPosition";
        private const string ANIMATION_PARENT_NAME = "AnimationTransformNodesParent";
        
        [SerializeField] private bool addStaticVisualComponents;
        [SerializeField] private bool enableGrabbing;
        [SerializeField] private bool playsAnAnimation;
        
        public override string Description => "Adds a spline master controller, along with necessary components." +
                                              "Used for advanced manipulations of splines as well as simple ones.";
        
        public override bool IsConfigurationValid(out List<string> errors)
        {
            errors = null;
            return true;
        }
        
#pragma warning disable CS1998
        public override async UniTask PerformAsync(GameObject target)
        {
#pragma warning restore CS1998
            SplineMasterController controller = target.GetOrAddComponent<SplineMasterController>();
            target.GetOrAddComponent<Spline>();
            target.GetOrAddComponent<SplineMeshTiling>();
            
            if (addStaticVisualComponents)
            {
                controller.AddFeature(SplineFeature.SplineFeatureType.StaticVisualSplineFeature);
                GameObject visualTransforms = new (VISUAL_PARENT_NAME);
                visualTransforms.transform.SetParent(target.transform);
                visualTransforms.transform.localPosition = Vector3.zero;
            }

            if (enableGrabbing)
            {
                SplineFeature grabbingFeature = controller.AddFeature(SplineFeature.SplineFeatureType.GrabbingSplineFeature);
                GameObject startPoint = new (GRAB_START_NAME);
                GameObject grabPoint = new (GRAB_POINT_NAME);
                GameObject finalPosition = new (FINAL_POSITION_NAME);
                startPoint.transform.SetParent(target.transform);
                grabPoint.transform.SetParent(target.transform);
                finalPosition.transform.SetParent(target.transform);
                startPoint.transform.localPosition = Vector3.zero;
                grabPoint.transform.localPosition = Vector3.zero;
                finalPosition.transform.localPosition = Vector3.zero;
                grabbingFeature.SetGrabbingReferences(
                    startPoint.transform, 
                    grabPoint.transform,
                    finalPosition.transform);
            }

            if (playsAnAnimation)
            {
                controller.AddFeature(SplineFeature.SplineFeatureType.AnimationSplineFeature);
                GameObject animationTransforms = new (ANIMATION_PARENT_NAME);
                animationTransforms.transform.SetParent(target.transform);
                animationTransforms.transform.localPosition = Vector3.zero;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/Operations/SplineOperations.cs

# FILE: Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/SetupWizardEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 784759cde1ed45f8bd574b49eddd5a39
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Cysharp.Threading.Tasks;
using Ldx.Framework.Utilities.Attributes;
using Ldx.Framework.Utilities.Helpers;
using UnityEditor;
using UnityEngine;

namespace Ldx.Framework.Utilities.Wizard
{
    /// <summary>
    /// Editor for the setup wizard script
    /// </summary>
    [CustomEditor(typeof(SetupWizard))]
    public class SetupWizardEditor : UnityEditor.Editor
    {
        private const string SELECT_OPERATION_LABEL = "Select Wizard Operation";
        private const string CHANGE_OPERATION_LABEL = "Change Wizard Operation";
        private const string APPLY_SETUP_LABEL = "Apply Setup";
        private const string EXPAND_ALL_LABEL = "Expand All";
        private const string COLLAPSE_ALL_LABEL = "Collapse All";
        private const string CATEGORIES_LABEL = "Categories:";
        private const string DESCRIPTION_LABEL = "Description";
        private const string CONFIG_LABEL = "Config";
        private const string REMOVE_END_OPERATION = "Operation";
        private const int INDENT_AMT = 20;
        private const int BUTTON_PADDING = 10;
        
        private static GUIStyle DescriptionStyle;
        
        private SerializedProperty operationProp;
        private bool isPerformingOperation;
        private readonly Dictionary<string, List<Type>> categorizedOperations = new Dictionary<string, List<Type>>();
        private readonly Dictionary<string, bool> categoryFoldouts = new Dictionary<string, bool>();

        private SetupWizard Target => (SetupWizard)target;
        private WizardOperation Operation => Target.Operation;

        private void OnEnable()
        {
            operationProp = serializedObject.FindProperty("operation");

            // Initialize categorized operations
            categorizedOperations.Clear();
            IEnumerable<Type> operationTypes = AppDomain.CurrentDomain.GetAssemblies()
                .SelectMany(assembly => assembly.GetTypes())
                .Where(type => typeof(WizardOperation).IsAssignableFrom(type) && !type.IsAbstract);

            foreach (Type type in operationTypes)
            {
                WizardCategoryAttribute categoryAttribute = (WizardCategoryAttribute)Attribute.GetCustomAttribute(type, typeof(WizardCategoryAttribute));
                if (categoryAttribute != null)
                {
                    if (!categorizedOperations.ContainsKey(categoryAttribute.Category))
                    {
                        categorizedOperations[categoryAttribute.Category] = new List<Type>();
                    }
                    categorizedOperations[categoryAttribute.Category].Add(type);
                }
            }
        }

        public override void OnInspectorGUI()
        {
            if (target == null)
            {
                // The target has been destroyed
                return;
            }

            GUI.enabled = !isPerformingOperation;
            serializedObject.Update();

            EditorGUI.BeginChangeCheck();
            DrawCategoriesDropdowns();
            if (EditorGUI.EndChangeCheck())
            {
                ApplyModifiedPropertiesSafely();
            }

            if (Operation == null)
            {
                GUI.enabled = true;
                return;
            }

            DrawDescription();
            DrawConfig();
            DrawApplyButton();

            ApplyModifiedPropertiesSafely();
            GUI.enabled = true;
        }

        private void DrawCategoriesDropdowns()
        {
            if (operationProp == null)
            {
                EditorGUILayout.HelpBox("Operation property not found.", MessageType.Error);
                return;
            }

            // Check if no operation is selected
            if (operationProp.managedReferenceValue == null)
            {
                // Draw the "Select Operation" label
                EditorGUILayout.LabelField(SELECT_OPERATION_LABEL, EditorStyles.boldLabel);

                // Calculate the width of the "Collapse All" button
                float collapseExpandButtonWidth = GUI.skin.button.CalcSize(new GUIContent(COLLAPSE_ALL_LABEL)).x;

                EditorGUILayout.Space();

                EditorGUILayout.BeginHorizontal();

                // Draw the "Expand All" button
                if (GUILayout.Button(EXPAND_ALL_LABEL, GUILayout.Width(collapseExpandButtonWidth)))
                {
                    ExpandAllCategories();
                }

                // Draw the "Collapse All" button with the same width
                if (GUILayout.Button(COLLAPSE_ALL_LABEL, GUILayout.Width(collapseExpandButtonWidth)))
                {
                    CollapseAllCategories();
                }

                EditorGUILayout.EndHorizontal();

                EditorGUILayout.LabelField(CATEGORIES_LABEL, EditorStyles.boldLabel);

                // Draw categories and operations
                foreach (string category in categorizedOperations.Keys)
                {
                    // Check if foldout state exists for this category, if not, set default value to false
                    if (!categoryFoldouts.ContainsKey(category))
                    {
                        categoryFoldouts[category] = false;
                    }

                    GUILayout.BeginHorizontal();
                    categoryFoldouts[category] = EditorGUILayout.Foldout(categoryFoldouts[category], category);

                    if (!categoryFoldouts[category])
                    {
                        // Calculate the number of operations in the category
                        int operationCount = categorizedOperations[category].Count;

                        // Display the number of operations aligned to the right in bold if the foldout is collapsed
                        GUIStyle boldStyle = new GUIStyle(EditorStyles.label);
                        boldStyle.fontStyle = FontStyle.Bold;
                        GUILayout.FlexibleSpace(); 
                        GUILayout.Label(operationCount.ToString(), boldStyle, GUILayout.ExpandWidth(false));
                    }

                    GUILayout.EndHorizontal();

                    if (categoryFoldouts[category])
                    {
                        EditorGUI.indentLevel++;

                        foreach (Type type in categorizedOperations[category])
                        {
                            string displayName = FormatOperationName(type.Name);

                            // Calculate the width based on the length of the button label
                            float buttonWidth = GUI.skin.button.CalcSize(new GUIContent(displayName)).x;

                            // Add the button padding to the calculated width
                            buttonWidth += BUTTON_PADDING;

                            // Limit the width of the button containing the operation
                            GUILayout.BeginHorizontal();
                            GUILayout.Space(INDENT_AMT); // Add indentation to the left of the button
                            if (GUILayout.Button(displayName, GUILayout.Width(buttonWidth)))
                            {
                                object instance = Activator.CreateInstance(type);
                                if (instance == null)
                                {
                                    Debug.LogError($"Failed to create instance of {type.Name}");
                                    return;
                                }

                                serializedObject.Update();
                                operationProp.managedReferenceValue = instance;
                                ApplyModifiedPropertiesSafely();
                                
                                return; // Exit early after selecting an operation
                            }
                            GUILayout.EndHorizontal();
                        }

                        EditorGUI.indentLevel--;
                    }
                }
            }
            else
            {
                // Draw the "Change Operation" button with dynamically calculated width
                float buttonWidth = GUI.skin.button.CalcSize(new GUIContent(CHANGE_OPERATION_LABEL)).x;
                buttonWidth += BUTTON_PADDING;
                if (GUILayout.Button(CHANGE_OPERATION_LABEL, GUILayout.Width(buttonWidth)))
                {
                    // Reset operation selection and go back to category selection
                    operationProp.managedReferenceValue = null;
                    CollapseAllCategories(); // Collapse all menus when changing operation
                    ApplyModifiedPropertiesSafely();
                }
            }
        }

        private void ExpandAllCategories()
        {
            List<string> categoryKeys = new List<string>(categoryFoldouts.Keys);
            foreach (string category in categoryKeys)
            {
                categoryFoldouts[category] = true;
            }
        }

        private void CollapseAllCategories()
        {
            List<string> categoryKeys = new List<string>(categoryFoldouts.Keys);
            foreach (string category in categoryKeys)
            {
                categoryFoldouts[category] = false;
            }
        }
        
        private string FormatOperationName(string typeName)
        {
            if (typeName.EndsWith(REMOVE_END_OPERATION))
            {
                typeName = typeName.Substring(0, typeName.Length - REMOVE_END_OPERATION.Length); // Remove "Operation" from the end
            }

            return Regex.Replace(typeName, "(?<!^)([A-Z])", " $1"); // Insert space before each capital letter except the first one
        }

        private void DrawDescription()
        {
            DescriptionStyle ??= new GUIStyle(GUI.skin.label)
            {
                wordWrap = true
            };

            LdxEditorHelper.DrawHorizontalSeparator();
            LdxEditorHelper.DrawTitle(DESCRIPTION_LABEL);
            string[] lines = Operation.Description.Split('\n');
            foreach (string line in lines)
            {
                EditorGUILayout.LabelField(line, DescriptionStyle);
            }
        }

        private void DrawConfig()
        {
            if (!operationProp.hasVisibleChildren)
            {
                return;
            }

            LdxEditorHelper.DrawHorizontalSeparator();
            LdxEditorHelper.DrawTitle(CONFIG_LABEL);

            if (operationProp.managedReferenceValue != null || operationProp.isExpanded)
            {
                serializedObject.Update();
                DrawOperationProperties(operationProp);
                ApplyModifiedPropertiesSafely();
            }
        }

        private void DrawOperationProperties(SerializedProperty property)
        {
            if (property == null)
            {
                Debug.LogError("Property is null in DrawOperationProperties.");
                return;
            }

            if (!property.hasVisibleChildren)
            {
                Debug.LogError("Property has no visible children in DrawOperationProperties.");
                return;
            }

            property = property.Copy(); // Ensure we have a valid copy to iterate over
            SerializedProperty endProperty = property.GetEndProperty();

            while (property.NextVisible(true) && !SerializedProperty.EqualContents(property, endProperty))
            {
                EditorGUILayout.PropertyField(property, true);
            }
        }

        private void DrawApplyButton()
        {
            LdxEditorHelper.DrawHorizontalSeparator();
            using (new EditorGUILayout.HorizontalScope())
            {
                GUILayout.FlexibleSpace();
                if (GUILayout.Button(APPLY_SETUP_LABEL))
                {
                    PerformOperationAsync().Forget();
                }
                GUILayout.FlexibleSpace();
            }
        }

        private async UniTaskVoid PerformOperationAsync()
        {
            isPerformingOperation = true;
            GameObject gameObject = Target.gameObject;

            if (!Operation.IsConfigurationValid(out List<string> errors))
            {
                // Add "-" at the beginning of each
                errors = errors.Select(e => "-" + e).ToList();
                // Join list into string separated by newline 
                string allErrors = string.Join("\n", errors);
                // Display errors
                EditorUtility.DisplayDialog("Setup Wizard configuration is invalid.", $"Ensure all required references are assigned and settings are properly configured in the inspector." +
                                                     $"\n Following issues were found:\n{allErrors}", "Ok");
                return;
            }
            
            Undo.RegisterFullObjectHierarchyUndo(gameObject, "Before Setup Wizard");
            await Operation.PerformAsync(gameObject);
            GUI.enabled = true;

            // Ensure the target object is still valid before trying to destroy it
            if (Target != null)
            {
                DestroyImmediate(Target);
            }

            // Check if the serialized object is still valid before applying changes
            if (serializedObject.targetObject != null)
            {
                Undo.RegisterFullObjectHierarchyUndo(gameObject, "After Setup Wizard");
                serializedObject.Update();
                ApplyModifiedPropertiesSafely();
            }

            isPerformingOperation = false;
        }

        private void ApplyModifiedPropertiesSafely()
        {
            if (serializedObject.targetObject == null)
            {
                return;
            }
            
            serializedObject.ApplyModifiedProperties();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Scripts/Utilities/Wizard/SetupWizardEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftAdditionalConfig.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1da9342d2a59abd49a8dfb8aa73a87b3
# ASMDEF: BakeryEditorAssembly.dll
# ---
using UnityEditor;
using UnityEngine;

public class ftAdditionalConfig
{
    // Affects texture import settings for lightmaps
    public const bool mipmapLightmaps = false;

    // Shader eval coeff * gaussian convolution coeff
    // ... replaced with more typical convolution coeffs
    // Used for legacy light probes
    public const float irradianceConvolutionL0 =       0.2820947917f;
    public const float irradianceConvolutionL1 =       0.32573500793527993f;//0.4886025119f * 0.7346029443286334f;
    public const float irradianceConvolutionL2_4_5_7 = 0.2731371076480198f;//0.29121293321402086f * 1.0925484306f;
    public const float irradianceConvolutionL2_6 =     0.07884789131313001f;//0.29121293321402086f * 0.3153915652f;
    public const float irradianceConvolutionL2_8 =     0.1365685538240099f;//0.29121293321402086f * 0.5462742153f;

    // Coefficients used in "Remove ringing" mode
    public const float rr_irradianceConvolutionL0 =       irradianceConvolutionL0;
    public const float rr_irradianceConvolutionL1 =       irradianceConvolutionL1;
    public const float rr_irradianceConvolutionL2_4_5_7 = irradianceConvolutionL2_4_5_7 * 0.6F;
    public const float rr_irradianceConvolutionL2_6 =     irradianceConvolutionL2_6 * 0.6f;
    public const float rr_irradianceConvolutionL2_8 =     irradianceConvolutionL2_8 * 0.6f;

    // Used for L1 light probes and volumes
    public const float convL0 = 1;
    public const float convL1 = 0.9f; // approx convolution

    // Calculate multiple point lights in one pass. No reason to disable it, unless there is a bug.
    public static bool batchPointLights = true;

    public static bool batchAreaLights = true;

#if UNITY_2017_3_OR_NEWER
    public const int sectorFarSphereResolution = 256;
#else
    // older version can't handle 32 bit meshes
    public const int sectorFarSphereResolution = 64;
#endif

    public const int volumeSceneLODLevel = -1;

/*
    Following settings are moved to Project Settings
    (on >= 2018.3; you can also edit BakeryProjectSettings.asset directly)

    // Use PNG instead of TGA for shadowmasks, directions and L1 maps
    public const bool preferPNG = false;

    // Padding values for atlas packers
    public const int texelPaddingForDefaultAtlasPacker = 3;
    public const int texelPaddingForXatlasAtlasPacker = 1;

    // Scales resolution for alpha Meta Pass maps
    public const int alphaMetaPassResolutionMultiplier = 2;

    // Render mode for all volumes in the scene. Defaults to Auto, which uses global scene render mode.
    public const BakeryLightmapGroup.RenderMode volumeRenderMode = BakeryLightmapGroup.RenderMode.Auto;

    // Should previously rendered Bakery lightmaps be deleted before the new bake?
    // Turned off by default because I'm scared of deleting anything
    public const bool deletePreviousLightmapsBeforeBake = false;

    // Print information about the bake process to console?
    public enum LogLevel
    {
        Nothing = 0,
        Info = 1,   // print to Debug.Log
        Warning = 2 // print to Debug.LogWarning
    }
    public const LogLevel logLevel = LogLevel.Info | LogLevel.Warning;

    // Make it work more similar to original Unity behaviour
    public const bool alternativeScaleInLightmap = false;

    // Should we adjust sample positions to prevent incorrect shadowing on very low-poly meshes with smooth normals?
    public const bool generateSmoothPos = true;
*/
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftAdditionalConfig.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftAtlasPreview.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 42f4cd34e81c6a1498d3b0574f6124e0
# ASMDEF: BakeryEditorAssembly.dll
# ---
using UnityEngine;
using UnityEditor;

public class ftAtlasPreview : EditorWindow
{
    RenderTexture atlasRT;
    int curAtlas, numAtlases;
    int firstID, lastID;

    public bool update = true;
    BakeryLightmapGroup grp = null;

    static Shader shader;
    static Material mat;

    public static ftAtlasPreview instance;

    public static bool selectionChanged = false;

    public static void SelectionCallback()
    {
        if (instance == null) return;
        instance.update = true;
        instance.OnGUI();
    }

    void Awake()
    {
         Selection.selectionChanged -= SelectionCallback;
         Selection.selectionChanged += SelectionCallback;
    }

    public void OnGUI()
    {
        instance = this;
        if (!ftRenderLightmap.showChecker) Close();

        titleContent.text = "Atlas preview";

        var objs = ftBuildGraphics.atlasOnlyObj;
        if (objs == null)
        {
            return;
        }
        var scaleOffset = ftBuildGraphics.atlasOnlyScaleOffset;
        var ids = ftBuildGraphics.atlasOnlyID;
        var groups = ftBuildGraphics.atlasOnlyGroup;

        if (shader == null)
        {
            shader = Shader.Find("Hidden/ftAtlas");
            if (shader == null)
            {
                Debug.LogError("Can't load atlas shader");
                return;
            }
        }
        if (mat == null)
        {
            mat = new Material(shader);
        }

        if (atlasRT == null) atlasRT = new RenderTexture(1024, 1024, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.sRGB);
        if (update)
        {
            Graphics.SetRenderTarget(atlasRT);
            GL.Clear(true, true, new Color(0,0,0,0));
            GL.sRGBWrite = true;

            var worldMatrix = Matrix4x4.identity;
            //numAtlases = 0;
            firstID = 99999;
            lastID = 0;

            for(int i=0; i<objs.Count; i++)
            {
                if (ids[i] > lastID) lastID = ids[i];
                if (ids[i] < firstID) firstID = ids[i];
            }
            numAtlases = (lastID - firstID) + 1;
            if (curAtlas < firstID) curAtlas = firstID;

            grp = null;
            for(int i=0; i<objs.Count; i++)
            {
                if (ids[i] != curAtlas) continue;
                if (objs[i] == null) continue;
                var mf = objs[i].GetComponent<MeshFilter>();
                if (mf == null) continue;
                var mesh = mf.sharedMesh;
                if (mesh == null) continue;
                int numSubs = mesh.subMeshCount;
                Shader.SetGlobalVector("unity_LightmapST", scaleOffset[i]);
                mat.SetPass(0);
                for(int s=0; s<numSubs; s++)
                {
                    Graphics.DrawMeshNow(mesh, worldMatrix, s);
                }
                if (System.Array.IndexOf(Selection.objects, objs[i].gameObject) >= 0)
                {
                    GL.wireframe = true;
                    Shader.SetGlobalFloat("isSelected", 1.0f);
                    mat.SetPass(0);
                    for(int s=0; s<numSubs; s++)
                    {
                        Graphics.DrawMeshNow(mesh, worldMatrix, s);
                    }
                    GL.wireframe = false;
                    Shader.SetGlobalFloat("isSelected", 0.0f);
                }
                grp = groups[i];
            }
            Graphics.SetRenderTarget(null);
            GL.sRGBWrite = false;
            update = false;
            Repaint();
        }

        this.minSize = new Vector2(160, 160);
        this.maxSize = new Vector2(2048, 2048);

        var pos = this.position;
        if (pos.height != pos.width+32)
        {
            this.position = new Rect(pos.x, pos.y, pos.width, pos.width+32);
        }

        if (GUI.Button(new Rect(0, 0, 32, 32), "<"))
        {
            curAtlas--;
            if (curAtlas < 0) curAtlas = 0;
            update = true;
        }
        if (GUI.Button(new Rect(32, 0, 32, 32), ">"))
        {
            curAtlas++;
            if (curAtlas > lastID) curAtlas = lastID;
            update = true;
        }

        int y = 0;
        #if UNITY_2019_3_OR_NEWER
            y = -10;
        #endif

        GUI.Label(new Rect(64, y, 320, 32), "Showing atlas "+((curAtlas-firstID)+1)+" of "+numAtlases);
        if (grp != null)
        {
            GUI.Label(new Rect(64, y+15, 320, 32), grp.name + " (" + grp.resolution + "x" + grp.resolution + ")");
        }
        else
        {
            GUI.Label(new Rect(64, y+15, 320, 32), "(Not shown / per-vertex)");
        }

        if (atlasRT != null)
        {
            EditorGUI.DrawPreviewTexture(new Rect(0, 32, position.width, position.height-32), atlasRT);//, ScaleMode.ScaleToFit, false, 1.0f);
        }
        else
        {
            Close();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftAtlasPreview.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftBuildGraphics.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1f3ae15d674398b46a90bf2c1aced7ac
# ASMDEF: BakeryEditorAssembly.dll
# ---
#if UNITY_EDITOR
#define USE_TERRAINS

// Disable 'obsolete' warnings
#pragma warning disable 0618

using UnityEngine;
using UnityEditor;
using System;
using System.IO;
using System.Text;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using UnityEngine.SceneManagement;
using UnityEditor.SceneManagement;
using UnityEngine.Rendering;
using System.Reflection;

public class ftBuildGraphics : ScriptableWizard
{
    const int UVGBFLAG_NORMAL = 1;
    const int UVGBFLAG_FACENORMAL = 2;
    const int UVGBFLAG_ALBEDO = 4;
    const int UVGBFLAG_EMISSIVE = 8;
    const int UVGBFLAG_POS = 16;
    const int UVGBFLAG_SMOOTHPOS = 32;
    const int UVGBFLAG_TANGENT = 64;
    const int UVGBFLAG_TERRAIN = 128;
    const int UVGBFLAG_RESERVED = 256;

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern void InitShaders();

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern void LoadScene(string path);

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    private static extern void SetAlbedos(int count, IntPtr[] tex);

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    private static extern int CopyAlbedos();

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    private static extern int CopyHeightmapsFromRAM(int count, TexInput[] tex);

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern void FreeAlbedoCopies();

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    private static extern void SetAlphas(int count, IntPtr[] tex, float[] alphaRefs, int[] alphaChannels, int numLODs, bool flip);

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    private static extern void SetAlphasFromRAM(int count, System.IntPtr tex, float[] alphaRefs, int[] alphaChannels, int numLODs, bool flip);

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern void SaveSky(IntPtr tex, float rx, float ry, float rz, float ux, float uy, float uz, float fx, float fy, float fz, string path, bool isLinear, bool doubleLDR, bool rgbm);

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern void SaveCookie(IntPtr tex, string path);

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern void SaveCookieFromRAM(TexInput tex, string path);

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern int ftRenderUVGBuffer();

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern void SetUVGBFlags(int flags);

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern void SetFixPos(bool enabled);

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern void SetCompression(bool enabled);

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern int ftGenerateAlphaBuffer();

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern int SaveGBufferMap(IntPtr tex, string path, bool compressed);

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern int SaveGBufferMapFromRAM(byte[] tex, int size, string path, bool compressed);

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern int GetABGErrorCode();

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern int GetUVGBErrorCode();

    [DllImport ("uvrepack", CallingConvention=CallingConvention.Cdecl)]
    public static extern int uvrLoad(float[] inputUVs, int numVerts, int[] inputIndices, int numIndices);

    [DllImport ("uvrepack", CallingConvention=CallingConvention.Cdecl)]
    public static extern int uvrRepack(float padding, int resolution);

    [DllImport ("uvrepack", CallingConvention=CallingConvention.Cdecl)]
    public static extern int uvrUnload();

    public enum TexInputType
    {
        Color,
        FloatColor,
        HalfColor
    };

    public struct TexInput
    {
        public byte[] data;
        public ushort width, height;
    };

    static Material matCubemapToStripExport;
    static Material matAreaLight;

    static int voffset, soffset, ioffset;

    static public string scenePath = "";

    static BufferedBinaryWriterFloat fvbfull, fvbtrace, fvbtraceTex, fvbtraceUV0;
    static BufferedBinaryWriterInt fib;
    static BinaryWriter fscene, fmesh, flmid, fseamfix, fsurf, fmatid, fmatide, fmatidh, fmatideb, falphaid, fib32, fhmaps;
    static BinaryWriter[] fib32lod;
    static BinaryWriter[] falphaidlod;

    public static ftLightmapsStorage.ImplicitLightmapData tempStorage = new ftLightmapsStorage.ImplicitLightmapData();

    public static float texelsPerUnit = 20;
    public static int minAutoResolution = 16;
    public static int maxAutoResolution = 4096;
    public static bool mustBePOT = true;
    public static bool autoAtlas = true;
    public static bool unwrapUVs = true;
    public static bool forceDisableUnwrapUVs = false;
    public static bool exportShaderColors = true; // albedo and emission (sometimes normal) always come from the engine now
    //public static int atlasPaddingPixels = ftAdditionalConfig.texelPaddingForDefaultAtlasPacker;
    public static bool atlasCountPriority = false;
    public static bool splitByScene = false;
    public static bool splitByTag = true;
    public static bool uvPaddingMax = false;
    public static bool exportTerrainAsHeightmap = true;
    public static bool exportTerrainTrees = false;
    public static bool uvgbHeightmap = true;

    public static int terrainTreeLODLevel = 0;

    public static bool texelsPerUnitPerMap = false;
    public static float mainLightmapScale = 1;
    public static float maskLightmapScale = 1;
    public static float dirLightmapScale = 1;

    public static bool autosetAreaLightLMID = true;

    const float atlasScaleUpValue = 1.01f;
    const int atlasMaxTries = 100;
    const float alphaInstanceThreshold = 5.0f / 255.0f;

    const bool flipAlpha = true;

    public static string overwriteExtensionCheck = ".hdr";
    public static bool overwriteWarning = false;
    public static bool overwriteWarningSelectedOnly = false;
    public static bool memoryWarning = false;
    public static bool modifyLightmapStorage = true;
    public static bool validateLightmapStorageImmutability = true;
    public static bool sceneNeedsToBeRebuilt = false;
    //public static int unityVersionMajor = 0;
    //public static int unityVersionMinor = 0;

    static int areaLightCounter = -2;
    public static int sceneLodsUsed = 0;

    static GameObject lmgroupHolder;
    static BakeryLightmapGroup lightProbeLMGroup = null;
    static BakeryLightmapGroup volumeLMGroup = null;

    static List<GameObject> terrainObjectList;
#if USE_TERRAINS
    static List<Terrain> terrainObjectToActual;
#endif
    static List<Texture> terrainObjectToHeightMap;
    static List<TexInput> terrainObjectToHeightMapRAM;
    static List<float> terrainObjectToBounds;
    static List<int> terrainObjectToLMID;
    static List<float> terrainObjectToBoundsUV;
    static List<int> terrainObjectToFlags;
    static List<List<float[]>> terrainObjectToHeightMips;
    //static List<List<Vector3[]>> terrainObjectToNormalMips;
    //static List<Vector3[]> terrainObjectToNormalMip0;
    static List<GameObject> temporaryAreaLightMeshList;
    static List<BakeryLightMesh> temporaryAreaLightMeshList2;
    public static List<GameObject> temporaryGameObjects;

    static Dictionary<GameObject, int> cmp_objToLodLevel;
    static Dictionary<GameObject, float> cmp_holderObjArea;

    public static Dictionary<int,List<int>> lodLevelsVisibleInLodLevel = new Dictionary<int,List<int>>(); // defines LOD levels visible in chosen LOD level

    public static List<float> vbtraceTexPosNormalArray; // global vbTraceTex.bin positions/normals
    public static List<float> vbtraceTexUVArray; // global vbTraceTex.bin UVs
    public static float[] vbtraceTexUVArrayLOD; // global vbTraceTex.bin LOD UVs

    public static List<Renderer> atlasOnlyObj;
    public static List<Vector4> atlasOnlyScaleOffset;
    public static List<int> atlasOnlySize;
    public static List<int> atlasOnlyID;
    public static List<BakeryLightmapGroup> atlasOnlyGroup;

    public static ftGlobalStorage.AtlasPacker atlasPacker = ftGlobalStorage.AtlasPacker.xatlas;

    public static bool forceAllAreaLightsSelfshadow = false;

    public static bool postPacking = true;
    public static bool holeFilling = false;

    static int floatOverWarnCount = 0;
    const int maxFloatOverWarn = 10;

    static ftGlobalStorage gstorage;
    static BakeryProjectSettings pstorage;

    static ExportSceneData _tempData;

    static public void DebugLogError(string text)
    {
        ftRenderLightmap.DebugLogError(text);
    }

    class FarSphereRenderData
    {
        public RenderTexture[] albedo, depth, normal;
        public Matrix4x4[] viewProj;
        public Vector3 pos;
        public Mesh[] meshes;
        public Texture2D[] textures;
    }

    static Shader farSphereRshader, farSphereRshaderOcc, farSphereSshader, farSphereProjClipShader, farSphereDilateShader;
    static Material farSphereMat, farSphereMatOcc, farSphereProjClipMat, farSphereDilateMat;
    static ComputeShader farSphereCSTransform, farSphereCSCull;

    class AtlasNode
    {
        public AtlasNode child0, child1;
        public Rect rc;
        public GameObject obj;
        bool leaf = true;

        public AtlasNode Insert(GameObject o, Rect rect)
        {
            if (!leaf)
            {
                var newNode = child0.Insert(o, rect);
                if (newNode != null) return newNode;

                return child1.Insert(o, rect);
            }
            else
            {
                if (obj != null) return null;

                var fits = (rect.width <= rc.width && rect.height <= rc.height);
                if (!fits) return null;

                var fitsExactly = (rect.width == rc.width && rect.height == rc.height);
                if (fitsExactly)
                {
                    obj = o;
                    return this;
                }

                child0 = new AtlasNode();
                child1 = new AtlasNode();

                var dw = rc.width - rect.width;
                var dh = rc.height - rect.height;

                if (dw > dh)
                {
                    child0.rc = new Rect(rc.x, rc.y, rect.width, rc.height);
                    child1.rc = new Rect(rc.x + rect.width, rc.y, rc.width - rect.width, rc.height);
                }
                else
                {
                    child0.rc = new Rect(rc.x, rc.y, rc.width, rect.height);
                    child1.rc = new Rect(rc.x, rc.y + rect.height, rc.width, rc.height - rect.height);
                }
                leaf = false;

                return child0.Insert(o, rect);
            }
        }

        public void GetMax(ref float maxx, ref float maxy)
        {
            if (obj != null)
            {
                if ((rc.x + rc.width) > maxx) maxx = rc.x + rc.width;
                if ((rc.y + rc.height) > maxy) maxy = rc.y + rc.height;
            }
            if (child0 != null) child0.GetMax(ref maxx, ref maxy);
            if (child1 != null) child1.GetMax(ref maxx, ref maxy);
        }

        public void Transform(float offsetx, float offsety, float scalex, float scaley)
        {
            rc.x *= scalex;
            rc.y *= scaley;
            rc.x += offsetx;
            rc.y += offsety;
            rc.width *= scalex;
            rc.height *= scaley;
            if (child0 != null) child0.Transform(offsetx, offsety, scalex, scaley);
            if (child1 != null) child1.Transform(offsetx, offsety, scalex, scaley);
        }
    };

    static ftBuildGraphics()
    {
        //ftRenderLightmap.PatchPath();
        //var unityVer = Application.unityVersion.Split('.');
        //unityVersionMajor = Int32.Parse(unityVer[0]);
        //unityVersionMinor = Int32.Parse(unityVer[1]);
    }

    static void DebugLogInfo(string info)
    {
        if (pstorage == null) pstorage = ftLightmaps.GetProjectSettings();
        if ((pstorage.logLevel & (int)BakeryProjectSettings.LogLevel.Info) != 0) Debug.Log(info);
    }

    static void DebugLogWarning(string info)
    {
        if (pstorage == null) pstorage = ftLightmaps.GetProjectSettings();
        if ((pstorage.logLevel & (int)BakeryProjectSettings.LogLevel.Warning) != 0) Debug.LogWarning(info);
    }

    static string FilterNonASCII(string s)
    {
        if (Encoding.UTF8.GetByteCount(s) == s.Length) return s;
        var bytes = Encoding.UTF8.GetBytes(s);
        var newStr = "";
        for(int i=0; i<bytes.Length; i++)
        {
            if (bytes[i] > 127)
            {
                newStr += "_" + (int)bytes[i];
            }
            else
            {
                newStr += Convert.ToChar(bytes[i]);
            }
        }
        return newStr;
    }

    static void exportVBPos(BinaryWriter f, Transform t, Mesh m, Vector3[] vertices)
    {
        for(int i=0;i<vertices.Length;i++)
        {
            Vector3 pos = vertices[i];//t.(vertices[i]);
            f.Write(pos.x);
            f.Write(pos.y);
            f.Write(pos.z);
        }
    }

    static void exportVBTrace(BufferedBinaryWriterFloat f, Mesh m, Vector3[] vertices, Vector3[] normals)
    {
        for(int i=0;i<vertices.Length;i++)
        {
            Vector3 pos = vertices[i];//t.(vertices[i]);
            f.Write(pos.x);
            f.Write(pos.y);
            f.Write(pos.z);

            Vector3 normal = normals[i];//t.TransformDirection(normals[i]);
            f.Write(normal.x);
            f.Write(normal.y);
            f.Write(normal.z);
        }
    }

    public static Renderer GetValidRenderer(GameObject obj)
    {
        var mr = obj.GetComponent<Renderer>();
        if (mr as MeshRenderer == null && mr as SkinnedMeshRenderer == null)
        {
            // possibly multiple renderers on one gameobject?
            mr = obj.GetComponent<MeshRenderer>() as Renderer;
            if (mr != null) return mr;
            mr = obj.GetComponent<SkinnedMeshRenderer>() as Renderer;
            if (mr != null) return mr;
            return null;
        }
        return mr;
    }

    static BakeryLightmapGroup GetLMGroupFromObjectExplicit(GameObject obj, ExportSceneData data)
    {
        lmgroupHolder = null;
        var lmgroupSelector = obj.GetComponent<BakeryLightmapGroupSelector>(); // if object has explicit lmgroup
        if (lmgroupSelector == null)
        {
            // if parents have explicit lmgroup
            var t2 = obj.transform.parent;
            while(lmgroupSelector == null && t2 != null)
            {
                lmgroupSelector = t2.GetComponent<BakeryLightmapGroupSelector>();
                t2 = t2.parent;
            }
        }
        BakeryLightmapGroup lmgroup = null;
        if (lmgroupSelector != null)
        {
            if (lmgroupSelector.active)
            {
                lmgroup = lmgroupSelector.lmgroupAsset as BakeryLightmapGroup;
                lmgroupHolder = lmgroupSelector.gameObject;

                var scaleInLm = data.objToScaleInLm[obj];
                if (scaleInLm == 0.0f) lmgroup = data.autoVertexGroup;
                    //null; // ignore lightmaps when scaleInLightmap == 0
            }
        }
        return lmgroup;
    }

    static BakeryLightmapGroup GetLMGroupFromObject(GameObject obj, ExportSceneData data)
    {
        UnityEngine.Object lmgroupObj = null;
        BakeryLightmapGroup lmgroup = null;
        lmgroupHolder = null;

        var lmgroupSelector = obj.GetComponent<BakeryLightmapGroupSelector>(); // if object has explicit lmgroup
        tempStorage.implicitGroupMap.TryGetValue(obj, out lmgroupObj); // or implicit
        lmgroup = (BakeryLightmapGroup)lmgroupObj;
        lmgroupHolder = obj;
        if (lmgroupSelector == null && lmgroup == null)
        {
            // if parents have explicit/implicit lmgroup
            var t2 = obj.transform.parent;
            while(lmgroupSelector == null && lmgroup == null && t2 != null)
            {
                lmgroupSelector = t2.GetComponent<BakeryLightmapGroupSelector>();
                tempStorage.implicitGroupMap.TryGetValue(t2.gameObject, out lmgroupObj);
                lmgroup = (BakeryLightmapGroup)lmgroupObj;
                lmgroupHolder = t2.gameObject;
                t2 = t2.parent;
            }
        }
        if (lmgroupSelector != null)
        {
            if (lmgroupSelector.active)
            {
                lmgroup = lmgroupSelector.lmgroupAsset as BakeryLightmapGroup;
            }
        }

        if (lmgroup != null)
        {
            var r = GetValidRenderer(obj);
            if (r)
            {
                var scaleInLm = data.objToScaleInLm[obj];
                if (scaleInLm == 0.0f) lmgroup = data.autoVertexGroup;
                // null; // ignore lightmaps when scaleInLightmap == 0
            }
        }
        else
        {
            lmgroupHolder = null;
        }

        return lmgroup;
    }

    // use by ftRenderLightmap
    public static BakeryLightmapGroup GetLMGroupFromObject(GameObject obj)
    {
        UnityEngine.Object lmgroupObj = null;
        BakeryLightmapGroup lmgroup = null;
        lmgroupHolder = null;

        var lmgroupSelector = obj.GetComponent<BakeryLightmapGroupSelector>(); // if object has explicit lmgroup
        tempStorage.implicitGroupMap.TryGetValue(obj, out lmgroupObj); // or implicit
        lmgroup = (BakeryLightmapGroup)lmgroupObj;
        lmgroupHolder = obj;
        if (lmgroupSelector == null && lmgroup == null)
        {
            // if parents have explicit/implicit lmgroup
            var t2 = obj.transform.parent;
            while(lmgroupSelector == null && lmgroup == null && t2 != null)
            {
                lmgroupSelector = t2.GetComponent<BakeryLightmapGroupSelector>();
                tempStorage.implicitGroupMap.TryGetValue(t2.gameObject, out lmgroupObj);
                lmgroup = (BakeryLightmapGroup)lmgroupObj;
                lmgroupHolder = t2.gameObject;
                t2 = t2.parent;
            }
        }
        if (lmgroupSelector != null)
        {
            if (lmgroupSelector.active)
            {
                lmgroup = lmgroupSelector.lmgroupAsset as BakeryLightmapGroup;
            }
        }

        if (lmgroup != null)
        {
            var r = GetValidRenderer(obj);
            if (r)
            {
                var so = new SerializedObject(r);
                var scaleInLm = so.FindProperty("m_ScaleInLightmap").floatValue;
#if UNITY_2019_2_OR_NEWER
                var _r = r as MeshRenderer;
                if (pstorage.takeReceiveGIIntoAccount && _r != null && _r.receiveGI == ReceiveGI.LightProbes) scaleInLm = 0;
#endif
                //var scaleInLm = data.objToScaleInLm[obj];
                if (scaleInLm == 0.0f) lmgroup = null;
                // null; // ignore lightmaps when scaleInLightmap == 0
            }
        }
        else
        {
            lmgroupHolder = null;
        }

        return lmgroup;
    }

    public static void exportVBTraceTexAttribs(List<float> arrPosNormal, List<float> arrUV,
     Vector3[] vertices, Vector3[] normals, Vector2[] uv2, int lmid, bool vertexBake, GameObject obj)
    {
        for(int i=0;i<vertices.Length;i++)
        {
            Vector3 pos = vertices[i];//t.(vertices[i]);
            arrPosNormal.Add(pos.x);
            arrPosNormal.Add(pos.y);
            arrPosNormal.Add(pos.z);

            Vector3 normal = normals[i];//t.TransformDirection(normals[i]);
            arrPosNormal.Add(normal.x);
            arrPosNormal.Add(normal.y);
            arrPosNormal.Add(normal.z);

            float u = 0;
            float v = 0;

            if (lmid < 0)
            {
                //u = lmid * 10;
                if (uv2.Length>0)
                {
                    u = Mathf.Clamp(uv2[i].x, 0, 0.99999f);
                    v = Mathf.Clamp(1.0f - uv2[i].y, 0, 0.99999f);
                }
            }
            else
            {
                if (uv2.Length>0 && !vertexBake)
                {
                    u = Mathf.Clamp(uv2[i].x, 0, 0.99999f);
                    v = Mathf.Clamp(uv2[i].y, 0, 0.99999f);
                }
                else if (vertexBake)
                {
                    u = uv2[i].x;
                    v = uv2[i].y - 1.0f;
                }
            }

            float origU = u;
            if (lmid >= 0)
            {
                u += lmid * 10;
                if ((int)u > lmid*10)
                {
                    // attempt fixing float overflow
                    u = (lmid*10+1) - (lmid*10+1)*0.0000002f;
                    if ((int)u > lmid*10)
                    {
                        if (floatOverWarnCount < maxFloatOverWarn)
                        {
                            Debug.LogError("Float overflow for " + obj.name + " (U: " + origU + ", LMID: " + lmid + ")");
                            floatOverWarnCount++;
                        }
                    }
                }
            }
            else
            {
                u = lmid * 10 - u;
                if ((int)u != lmid*10)
                {
                    u = -u;
                    lmid = -lmid;
                    u = (lmid*10+1) - (lmid*10+1)*0.0000002f;
                    if ((int)u > lmid*10)
                    {
                        if (floatOverWarnCount < maxFloatOverWarn)
                        {
                            Debug.LogError("Float overflow for " + obj.name + " (U: " + origU + ", LMID: " + lmid + ")");
                            floatOverWarnCount++;
                        }
                    }
                    u = -u;
                    lmid = -lmid;
                }
            }

            arrUV.Add(u);
            arrUV.Add(v);
        }
    }

    static void exportVBTraceUV0(BufferedBinaryWriterFloat f, Vector2[] uvs, int vertCount)
    {
        if (uvs.Length == 0)
        {
            for(int i=0;i<vertCount;i++)
            {
                f.Write(0.0f);
                f.Write(0.0f);
            }
        }
        else
        {
            for(int i=0;i<vertCount;i++)
            {
                f.Write(uvs[i].x);
                f.Write(uvs[i].y);
            }
        }
    }

    static void exportVBBasic(BinaryWriter f, Transform t, Mesh m, Vector3[] vertices, Vector3[] normals, Vector2[] uv2)
    {
        for(int i=0;i<vertices.Length;i++)
        {
            Vector3 pos = vertices[i];//t.(vertices[i]);
            f.Write(pos.x);
            f.Write(pos.y);
            f.Write(pos.z);

            Vector3 normal = normals[i];//t.TransformDirection(normals[i]);
            f.Write(normal.x);
            f.Write(normal.y);
            f.Write(normal.z);

            if (uv2.Length>0)
            {
                f.Write(uv2[i].x);
                f.Write(uv2[i].y);
            }
            else
            {
                f.Write(0.0f);
                f.Write(0.0f);
            }
        }
    }

    // Either I'm dumb, or it's impossible to make generics work with it (only worked in .NET 3.5)
    class BufferedBinaryWriterFloat
    {
        [StructLayout(LayoutKind.Explicit)]
        public class ReinterpretBuffer
        {
           [FieldOffset(0)]
           public byte[] bytes;
           [FieldOffset(0)]
           public float[] elements;
       }

        BinaryWriter f;
        ReinterpretBuffer buffer;
        int bufferPtr;
        int bufferSize;
        int elementSize;

        public BufferedBinaryWriterFloat(BinaryWriter b, int elemSize = 4, int buffSizeInFloats = 1024*1024)
        {
            f = b;
            buffer = new ReinterpretBuffer();
            buffer.bytes = new byte[buffSizeInFloats * elemSize];
            bufferPtr = 0;
            bufferSize = buffSizeInFloats;
            elementSize = elemSize;
        }

        void Flush()
        {
            if (bufferPtr == 0) return;
            f.Write(buffer.bytes, 0, bufferPtr * elementSize);
            bufferPtr = 0;
        }

        public void Write(float x)
        {
            buffer.elements[bufferPtr] = x;
            bufferPtr++;
            if (bufferPtr == bufferSize) Flush();
        }

        public void Close()
        {
            Flush();
            f.Close();
        }
    }
    class BufferedBinaryWriterInt
    {
        [StructLayout(LayoutKind.Explicit)]
        public class ReinterpretBuffer
        {
           [FieldOffset(0)]
           public byte[] bytes;
           [FieldOffset(0)]
           public int[] elements;
       }

        BinaryWriter f;
        ReinterpretBuffer buffer;
        int bufferPtr;
        int bufferSize;
        int elementSize;

        public BufferedBinaryWriterInt(BinaryWriter b, int elemSize = 4, int buffSizeInFloats = 1024*1024)
        {
            f = b;
            buffer = new ReinterpretBuffer();
            buffer.bytes = new byte[buffSizeInFloats * elemSize];
            bufferPtr = 0;
            bufferSize = buffSizeInFloats;
            elementSize = elemSize;
        }

        void Flush()
        {
            if (bufferPtr == 0) return;
            f.Write(buffer.bytes, 0, bufferPtr * elementSize);
            bufferPtr = 0;
        }

        public void Write(int x)
        {
            buffer.elements[bufferPtr] = x;
            bufferPtr++;
            if (bufferPtr == bufferSize) Flush();
        }

        public void Close()
        {
            Flush();
            f.Close();
        }
    }

    static void exportVBFull(BufferedBinaryWriterFloat f, Vector3[] vertices, Vector3[] normals, Vector4[] tangents, Vector2[] uv, Vector2[] uv2)
    {
        bool hasUV = uv.Length > 0;
        bool hasUV2 = uv2.Length > 0;

        for(int i=0;i<vertices.Length;i++)
        {
            Vector3 pos = vertices[i];//t.(vertices[i]);
            f.Write(pos.x);
            f.Write(pos.y);
            f.Write(pos.z);

            Vector3 normal = normals[i];//t.TransformDirection(normals[i]);
            f.Write(normal.x);
            f.Write(normal.y);
            f.Write(normal.z);

            if (tangents == null)
            {
                f.Write(0.0f);
                f.Write(0.0f);
                f.Write(0.0f);
                f.Write(0.0f);
            }
            else
            {
                Vector4 tangent = tangents[i];
                f.Write(tangent.x);
                f.Write(tangent.y);
                f.Write(tangent.z);
                f.Write(tangent.w);
            }

            if (hasUV)
            {
                f.Write(uv[i].x);
                f.Write(uv[i].y);
            }
            else
            {
                f.Write(0.0f);
                f.Write(0.0f);
            }

            if (hasUV2)
            {
                f.Write(uv2[i].x);
                f.Write(uv2[i].y);
            }
            else
            {
                f.Write(0.0f);
                f.Write(0.0f);
            }
        }
    }

    static int exportIB(BufferedBinaryWriterInt f, int[] indices, bool isFlipped, bool is32Bit, int offset, BinaryWriter falphaid, ushort alphaID)
    {
        //var indices = m.GetTriangles(i);
        for(int j=0;j<indices.Length;j+=3)
        {
            if (!isFlipped)
            {
                if (is32Bit)
                {
                    f.Write(indices[j] + offset);
                    f.Write(indices[j+1] + offset);
                    f.Write(indices[j+2] + offset);
                }
                else
                {
                    f.Write(indices[j]);
                    f.Write(indices[j+1]);
                    f.Write(indices[j+2]);
                }
            }
            else
            {
                if (is32Bit)
                {
                    f.Write(indices[j+2] + offset);
                    f.Write(indices[j+1] + offset);
                    f.Write(indices[j] + offset);
                }
                else
                {
                    f.Write(indices[j+2]);
                    f.Write(indices[j+1]);
                    f.Write(indices[j]);
                }
            }

            if (falphaid!=null) falphaid.Write(alphaID);
        }
        return indices.Length;
    }

    // returns mesh area if requested
    static void exportIB32(List<int> indicesOpaque, List<int> indicesTransparent, List<int> indicesLMID,
        int[] indices, bool isFlipped, int offset, int indexOffsetLMID, BinaryWriter falphaid,
        ushort alphaID)
    {
        //var indices = m.GetTriangles(i);
        var indicesOut = alphaID == 0xFFFF ? indicesOpaque : indicesTransparent;

        int indexA, indexB, indexC;

        for(int j=0;j<indices.Length;j+=3)
        {
            if (!isFlipped)
            {
                indexA = indices[j];
                indexB = indices[j + 1];
                indexC = indices[j + 2];
            }
            else
            {
                indexA = indices[j + 2];
                indexB = indices[j + 1];
                indexC = indices[j];
            }

            indicesOut.Add(indexA + offset);
            indicesOut.Add(indexB + offset);
            indicesOut.Add(indexC + offset);

            if (indicesLMID != null)
            {
                indicesLMID.Add(indexA + indexOffsetLMID);
                indicesLMID.Add(indexB + indexOffsetLMID);
                indicesLMID.Add(indexC + indexOffsetLMID);
            }

            if (alphaID != 0xFFFF) falphaid.Write(alphaID);
        }
    }


    static void exportSurfs(BinaryWriter f, int[][] indices, int subMeshCount)// Mesh m)
    {
        int offset = ioffset;
        for(int i=0;i<subMeshCount;i++) {
            int size = indices[i].Length;//m.GetTriangles(i).Length;
            f.Write(offset);
            f.Write(size);
            offset += size;// * 2;
        }
        soffset += subMeshCount;
    }

    static void exportMesh(BinaryWriter f, Mesh m)
    {
        f.Write(voffset);
        f.Write(soffset);
        f.Write((ushort)m.subMeshCount);
        f.Write((ushort)0);
    }

    static int exportLMID(BinaryWriter f, GameObject obj, BakeryLightmapGroup lmgroup)
    {
        var areaLight =  obj.GetComponent<BakeryLightMesh>();
        if (areaLight == null)
        {
            int index = temporaryAreaLightMeshList.IndexOf(obj);
            if (index >= 0)
            {
                areaLight = temporaryAreaLightMeshList2[index];
            }
        }
        if (areaLight != null)
        {
            if (autosetAreaLightLMID)
            {
                f.Write(areaLightCounter);
                areaLight.lmid = areaLightCounter;
                areaLightCounter--;
                return areaLightCounter;
            }
            else
            {
                f.Write(areaLight.lmid);
                //Debug.LogError(areaLight.name+" "+areaLight.lmid);
                return areaLight.lmid;
            }
        }
        else if (lmgroup != null)
        {
            f.Write(lmgroup.id);
            return lmgroup.id;
        }
        else
        {
            f.Write(0xFFFFFFFF);
            return -1;
        }
    }

    static Vector2[] GenerateVertexBakeUVs(int voffset, int vlength, int totalVertexCount)
    {
        int atlasTexSize = (int)Mathf.Ceil(Mathf.Sqrt((float)totalVertexCount));
        atlasTexSize = (int)Mathf.Ceil(atlasTexSize / (float)ftRenderLightmap.tileSize) * ftRenderLightmap.tileSize;
        var uvs = new Vector2[vlength];
        float mul = 1.0f / atlasTexSize;
        float add = mul * 0.5f;
        for(int i=0; i<vlength; i++)
        {
            int x = (i + voffset) % atlasTexSize;
            int y = (i + voffset) / atlasTexSize;
            uvs[i] = new Vector2(x * mul + add, y * mul + add);// - 1.0f);
        }
        return uvs;
    }

    public static Mesh GetSharedMesh(Renderer mr)
    {
        if (mr == null) return null;
        var mrSkin = mr as SkinnedMeshRenderer;
        var mf = mr.gameObject.GetComponent<MeshFilter>();
        return mrSkin != null ? mrSkin.sharedMesh : (mf != null ? mf.sharedMesh : null);
    }

    public static Mesh GetSharedMeshBaked(GameObject obj)
    {
        var mrSkin = obj.GetComponent<SkinnedMeshRenderer>();
        if (mrSkin != null)
        {
            var baked = new Mesh();
            mrSkin.BakeMesh(baked);
            return baked;
        }
        var mf = obj.GetComponent<MeshFilter>();
        return (mf != null ? mf.sharedMesh : null);
    }

    public static Mesh GetSharedMesh(GameObject obj)
    {
        var mrSkin = obj.GetComponent<SkinnedMeshRenderer>();
        var mf = obj.GetComponent<MeshFilter>();
        return mrSkin != null ? mrSkin.sharedMesh : (mf != null ? mf.sharedMesh : null);
    }

    public static Mesh GetSharedMeshSkinned(GameObject obj, out bool isSkin)
    {
        var mrSkin = obj.GetComponent<SkinnedMeshRenderer>();
        Mesh mesh;
        if (mrSkin != null)
        {
            mesh = new Mesh();
            mrSkin.BakeMesh(mesh);
            isSkin = mrSkin.bones.Length > 0; // blendshape-only don't need scale?
        }
        else
        {
            isSkin = false;
            var mf = obj.GetComponent<MeshFilter>();
            if (mf == null) return null;
            mesh = mf.sharedMesh;
        }
        return mesh;
    }

    static GameObject TestPackAsSingleSquare(GameObject holder)
    {
        var t = holder.transform;
        var p = t.parent;
        while(p != null)
        {
            if (p.GetComponent<BakeryPackAsSingleSquare>() != null) return p.gameObject;
            p = p.parent;
        }
        return holder;
    }

    static bool ModelUVsOverlap(ModelImporter importer, ftGlobalStorage store)
    {
        if (importer.generateSecondaryUV) return true;

        var path = importer.assetPath;
        /*for(int i=0; i<storages.Length; i++)
        {
            var store = storages[i];
            if (store == null) continue;
            var index = store.assetList.IndexOf(path);
            if (index < 0) continue;

            if (store.uvOverlapAssetList[index] == 0)
            {
                return false;
            }
            else
            {
                return true;
            }
        }*/
        var index = store.assetList.IndexOf(path);
        if (index >= 0 && index < store.uvOverlapAssetList.Count)
        {
            if (store.uvOverlapAssetList[index] == 0)
            {
                return false;
            }
            else
            {
                return true;
            }
        }

        var newAsset = AssetDatabase.LoadAssetAtPath(path, typeof(GameObject)) as GameObject;
        ftModelPostProcessor.CheckUVOverlap(newAsset, path);

        /*for(int i=0; i<storages.Length; i++)
        {
            var store = storages[i];
            var index = store.assetList.IndexOf(path);
            if (index < 0) continue;

            if (store.uvOverlapAssetList[index] == 0)
            {
                return false;
            }
            else
            {
                return true;
            }
        }*/
        index = store.assetList.IndexOf(path);
        if (index >= 0)
        {
            if (store.uvOverlapAssetList[index] == 0)
            {
                return false;
            }
            else
            {
                return true;
            }
        }

        return true;
    }

    static bool NeedsTangents(BakeryLightmapGroup lmgroup, bool tangentSHLights)
    {
        // RNM requires tangents
        if (ftRenderLightmap.renderDirMode == ftRenderLightmap.RenderDirMode.RNM ||
            (lmgroup!=null && lmgroup.renderDirMode == BakeryLightmapGroup.RenderDirMode.RNM)) return true;

        // SH requires tangents only if there is a SH skylight
        if (!tangentSHLights) return false;

        if (ftRenderLightmap.renderDirMode == ftRenderLightmap.RenderDirMode.SH || ftRenderLightmap.renderDirMode == ftRenderLightmap.RenderDirMode.MonoSH ||
            (lmgroup!=null && (lmgroup.renderDirMode == BakeryLightmapGroup.RenderDirMode.SH || lmgroup.renderDirMode == BakeryLightmapGroup.RenderDirMode.MonoSH))) return true;

        return false;
    }

    static long GetTime()
    {
        return System.DateTime.Now.Ticks / System.TimeSpan.TicksPerMillisecond;
    }

    static public string progressBarText;
    static public float progressBarPercent = 0;
    static public bool userCanceled = false;
    //static IEnumerator progressFunc;
    static EditorWindow activeWindow;
    static void ProgressBarInit(string startText, EditorWindow window = null)
    {
        progressBarText = startText;
        if (ftRenderLightmap.showProgressBar) ftRenderLightmap.simpleProgressBarShow("Bakery", progressBarText, progressBarPercent, 0, false);
    }
    static void ProgressBarShow(string text, float percent, bool onTop)
    {
        progressBarText = text;
        progressBarPercent = percent;
        if (ftRenderLightmap.showProgressBar) ftRenderLightmap.simpleProgressBarShow("Bakery", progressBarText, progressBarPercent, 0, onTop);
        userCanceled = ftRenderLightmap.simpleProgressBarCancelled();
    }

    public static void InitTemporaryAreaLightArray()
    {
        temporaryAreaLightMeshList = new List<GameObject>();
        temporaryAreaLightMeshList2 = new List<BakeryLightMesh>();
    }

    public static void FreeTemporaryAreaLightMeshes()
    {
        if (temporaryAreaLightMeshList != null)
        {
            for(int i=0; i<temporaryAreaLightMeshList.Count; i++)
            {
                if (temporaryAreaLightMeshList[i] != null)
                {
                    //var mr = temporaryAreaLightMeshList[i].GetComponent<Renderer>();
                    //if (mr != null) DestroyImmediate(mr);
                    //var mf = temporaryAreaLightMeshList[i].GetComponent<MeshFilter>();
                    //if (mf != null) DestroyImmediate(mf);
                    DestroyImmediate(temporaryAreaLightMeshList[i]);
                }
            }
            temporaryAreaLightMeshList = null;
        }
    }

    public static void ProgressBarEnd(bool removeTempObjects)// bool isError = true)
    {
        if (removeTempObjects)
        {
            if (terrainObjectList != null)
            {
                for(int i=0; i<terrainObjectList.Count; i++)
                {
                    if (terrainObjectList[i] != null) DestroyImmediate(terrainObjectList[i]);
                }
                terrainObjectList = null;
            }

            if (temporaryGameObjects != null)
            {
                for(int i=0; i<temporaryGameObjects.Count; i++)
                {
                    if (temporaryGameObjects[i] != null) DestroyImmediate(temporaryGameObjects[i]);
                }
                temporaryGameObjects = null;
            }

            //if (isError)
            {
                FreeTemporaryAreaLightMeshes();
            }
        }

        if (ftRenderLightmap.showProgressBar) ftRenderLightmap.simpleProgressBarEnd();
    }
    void OnInspectorUpdate()
    {
        Repaint();
    }

    static void CloseAllFiles()
    {
        if (fscene != null) fscene.Close();
        if (fmesh != null) fmesh.Close();
        if (flmid != null) flmid.Close();
        if (fseamfix != null) fseamfix.Close();
        if (fsurf != null) fsurf.Close();
        if (fmatid != null) fmatid.Close();
        if (fmatide != null) fmatide.Close();
        if (fmatideb != null) fmatideb.Close();
        if (fmatidh != null) fmatidh.Close();
        if (falphaid != null) falphaid.Close();
        if (fvbfull != null) fvbfull.Close();
        if (fvbtrace != null) fvbtrace.Close();
        if (fvbtraceTex != null) fvbtraceTex.Close();
        if (fvbtraceUV0 != null) fvbtraceUV0.Close();
        if (fib != null) fib.Close();
        if (fib32 != null) fib32.Close();
        if (fhmaps != null) fhmaps.Close();
        if (fib32lod != null)
        {
            for(int i=0; i<fib32lod.Length; i++) fib32lod[i].Close();
        }
        if (falphaidlod != null)
        {
            for(int i=0; i<falphaidlod.Length; i++) falphaidlod[i].Close();
        }
        fvbfull = fvbtrace = fvbtraceTex = fvbtraceUV0 = null;
        fib = null;
        fscene = fmesh = flmid = fsurf = fmatid = fmatide = fmatideb = falphaid  = fib32 = fseamfix = fmatidh = fhmaps = null;
        fib32lod = falphaidlod = null;
    }

    static bool CheckUnwrapError()
    {
        if (ftModelPostProcessor.unwrapError)
        {

            DebugLogError("Unity failed unwrapping some models. See console for details. Last failed model: " + ftModelPostProcessor.lastUnwrapErrorAsset+"\nModel will now be reverted to original state.");

            int mstoreIndex = gstorage.modifiedAssetPathList.IndexOf(ftModelPostProcessor.lastUnwrapErrorAsset);
            if (mstoreIndex < 0)
            {
                Debug.LogError("Failed to find failed asset?");
            }
            else
            {
                gstorage.ClearAssetModifications(mstoreIndex);
            }

            ftModelPostProcessor.unwrapError = false;
            CloseAllFiles();
            userCanceled = true;
            ProgressBarEnd(true);
            return true;
        }
        return false;
    }

    static Mesh BuildAreaLightMesh(Light areaLight)
    {
        var mesh = new Mesh();

        var verts = new Vector3[4];

        Vector2 areaSize = ftLightMeshInspector.GetAreaLightSize(areaLight);

        verts[0] = new Vector3(-0.5f * areaSize.x, -0.5f * areaSize.y, 0);
        verts[1] = new Vector3(0.5f * areaSize.x, -0.5f * areaSize.y, 0);
        verts[2] = new Vector3(0.5f * areaSize.x, 0.5f * areaSize.y, 0);
        verts[3] = new Vector3(-0.5f * areaSize.x, 0.5f * areaSize.y, 0);

        var uvs = new Vector2[4];
        uvs[0] = new Vector2(0, 0);
        uvs[1] = new Vector2(1, 0);
        uvs[2] = new Vector2(1, 1);
        uvs[3] = new Vector2(0, 1);

        var indices = new int[6];

        indices[0] = 0;
        indices[1] = 1;
        indices[2] = 2;

        indices[3] = 0;
        indices[4] = 2;
        indices[5] = 3;

        var normals = new Vector3[4];
        var n = Vector3.forward;// -areaLight.transform.forward; // transformation will be applied later
        for(int i=0; i<4; i++) normals[i] = n;

        mesh.vertices = verts;
        mesh.triangles = indices;
        mesh.normals = normals;
        mesh.uv = uvs;

        return mesh;
    }

    static bool CheckForTangentSHLights()
    {
        var All2 = FindObjectsOfType(typeof(BakerySkyLight));
        for(int i=0; i<All2.Length; i++)
        {
            var obj = All2[i] as BakerySkyLight;
            if (!obj.enabled) continue;
            if (!obj.gameObject.activeInHierarchy) continue;
            if (obj.tangentSH)
            {
                return true;
            }
        }
        return false;
    }

    public static void CreateSceneFolder()
    {
        if (scenePath == "" || !Directory.Exists(scenePath))
        {
            // Default scene path is TEMP/frender
            var tempDir = System.Environment.GetEnvironmentVariable("TEMP", System.EnvironmentVariableTarget.Process);
            scenePath = tempDir + "\\frender";
            if (!Directory.Exists(scenePath)) Directory.CreateDirectory(scenePath);
        }
    }

    static int CorrectLMGroupID(int id, BakeryLightmapGroup lmgroup, List<BakeryLightmapGroup> groupList)
    {
        id = id < 0 ? -1 : id;
        if (lmgroup != null && lmgroup.parentName != null && lmgroup.parentName.Length > 0 && lmgroup.parentName != "|")
        {
            for(int g=0; g<groupList.Count; g++)
            {
                if (groupList[g].name == lmgroup.parentName)
                {
                    id = g;
                    break;
                }
            }
        }
        return id;
    }

    static void InitSceneStorage(ExportSceneData data)
    {
        var storages = data.storages;
        var sceneToID = data.sceneToID;

        bool first = true;
        for(int i=0; i<storages.Length; i++)
        {
            var scene = SceneManager.GetSceneAt(i);
            if (!scene.isLoaded) continue;
            var gg = ftLightmaps.FindInScene("!ftraceLightmaps", scene);

            if (gg == null)
            {
                gg = new GameObject();
                SceneManager.MoveGameObjectToScene(gg, scene);
                gg.name = "!ftraceLightmaps";
                gg.hideFlags = HideFlags.HideInHierarchy;
            }

            storages[i] = gg.GetComponent<ftLightmapsStorage>();
            if (storages[i] == null)
            {
                storages[i] = gg.AddComponent<ftLightmapsStorage>();
            }

            if (modifyLightmapStorage)
            {
                /*
                storages[i].bakedRenderers = new List<Renderer>();
                storages[i].bakedIDs = new List<int>();
                storages[i].bakedScaleOffset = new List<Vector4>();
                storages[i].bakedVertexOffset = new List<int>();
                storages[i].bakedVertexColorMesh = new List<Mesh>();
                storages[i].bakedRenderersTerrain = new List<Terrain>();
                storages[i].bakedIDsTerrain = new List<int>();
                storages[i].bakedScaleOffsetTerrain = new List<Vector4>();
                */
                storages[i].hasEmissive = new List<bool>();
                storages[i].lmGroupLODResFlags = null;
                storages[i].lmGroupMinLOD = null;
                storages[i].lmGroupLODMatrix = null;
                storages[i].nonBakedRenderers = new List<Renderer>();
            }
            if (first)
            {
                data.firstNonNullStorage = i;
                first = false;
            }
            storages[i].implicitGroups = new List<UnityEngine.Object>();
            storages[i].implicitGroupedObjects = new List<GameObject>();
            sceneToID[scene] = i;
        }

        //var go = GameObject.Find("!ftraceLightmaps");
        //data.settingsStorage = go.GetComponent<ftLightmapsStorage>();
    }

    static void InitSceneStorage2(ExportSceneData data)
    {
        var storages = data.storages;
        for(int i=0; i<storages.Length; i++)
        {
            var scene = SceneManager.GetSceneAt(i);
            if (!scene.isLoaded) continue;
            if (modifyLightmapStorage)
            {
                storages[i].bakedRenderers = new List<Renderer>();
                storages[i].bakedIDs = new List<int>();
                storages[i].bakedScaleOffset = new List<Vector4>();
                storages[i].bakedVertexOffset = new List<int>();
                storages[i].bakedVertexColorMesh = new List<Mesh>();
#if USE_TERRAINS
                storages[i].bakedRenderersTerrain = new List<Terrain>();
                storages[i].bakedIDsTerrain = new List<int>();
                storages[i].bakedScaleOffsetTerrain = new List<Vector4>();
#endif
            }
        }
    }

    // Used to pass maps to alphaBufferGen/frender via RAM (non-DX11)
    public static TexInput InputDataFromTex(Texture tex, TexInputType ttype = TexInputType.Color)
    {
        RenderTextureFormat rtFormat = RenderTextureFormat.ARGB32;
        TextureFormat texFormat = TextureFormat.RGBA32;
        if (ttype == TexInputType.FloatColor)
        {
            rtFormat = RenderTextureFormat.ARGBFloat;
            texFormat = TextureFormat.RGBAFloat;
        }
        else if (ttype == TexInputType.HalfColor)
        {
            rtFormat = RenderTextureFormat.ARGBHalf;
            texFormat = TextureFormat.RGBAHalf;
        }
        var rt = new RenderTexture(tex.width, tex.height, 0, rtFormat);
        var readableTex = new Texture2D(tex.width, tex.height, texFormat, false);
        Graphics.Blit(tex, rt);
        Graphics.SetRenderTarget(rt);
        readableTex.ReadPixels(new Rect(0,0,tex.width,tex.height), 0, 0, false);
        readableTex.Apply();
        var bytes = readableTex.GetRawTextureData();

        var a = new TexInput();
        a.data = bytes;
        a.width = (ushort)tex.width;
        a.height = (ushort)tex.height;

        DestroyImmediate(readableTex);
        rt.Release();

        return a;
    }

    public static byte[] InputBytesFromTex(Texture tex, TexInputType ttype = TexInputType.Color)
    {
        RenderTextureFormat rtFormat = RenderTextureFormat.ARGB32;
        TextureFormat texFormat = TextureFormat.RGBA32;
        byte[] header = ftDDS.ddsHeaderRGBA8;
        if (ttype == TexInputType.FloatColor)
        {
            rtFormat = RenderTextureFormat.ARGBFloat;
            texFormat = TextureFormat.RGBAFloat;
            header = ftDDS.ddsHeaderFloat4;
        }
        else if (ttype == TexInputType.HalfColor)
        {
            rtFormat = RenderTextureFormat.ARGBHalf;
            texFormat = TextureFormat.RGBAHalf;
            header = ftDDS.ddsHeaderHalf4;
        }
        var rt = new RenderTexture(tex.width, tex.height, 0, rtFormat);
        var readableTex = new Texture2D(tex.width, tex.height, texFormat, false);
        Graphics.Blit(tex, rt);
        Graphics.SetRenderTarget(rt);
        readableTex.ReadPixels(new Rect(0,0,tex.width,tex.height), 0, 0, false);
        readableTex.Apply();
        var bytes = readableTex.GetRawTextureData();

        var fbytes = new byte[128 + bytes.Length];
        System.Buffer.BlockCopy(header, 0, fbytes, 0, 128);
        System.Buffer.BlockCopy(BitConverter.GetBytes(tex.height), 0, fbytes, 12, 4);
        System.Buffer.BlockCopy(BitConverter.GetBytes(tex.width), 0, fbytes, 16, 4);
        System.Buffer.BlockCopy(bytes, 0, fbytes, 128, bytes.Length);

        DestroyImmediate(readableTex);
        rt.Release();

        return fbytes;
    }

    public static TexInput InputDataFromCubemap(Texture tex, Matrix4x4 mtx, bool isLinear, bool isDoubleLDR, TexInputType ttype = TexInputType.Color)
    {
        RenderTextureFormat rtFormat = RenderTextureFormat.ARGB32;
        TextureFormat texFormat = TextureFormat.RGBA32;
        if (ttype == TexInputType.FloatColor)
        {
            rtFormat = RenderTextureFormat.ARGBFloat;
            texFormat = TextureFormat.RGBAFloat;
        }
        else if (ttype == TexInputType.HalfColor)
        {
            rtFormat = RenderTextureFormat.ARGBHalf;
            texFormat = TextureFormat.RGBAHalf;
        }

        int outWidth = System.Math.Min(tex.width, 512);
        int outHeight = System.Math.Min(tex.height, 512);

        var rt = new RenderTexture(outWidth, outHeight * 6, 0, rtFormat);
        var readableTex = new Texture2D(outWidth, outHeight * 6, texFormat, false);

        if (matCubemapToStripExport == null)  matCubemapToStripExport = new Material(Shader.Find("Hidden/ftCubemap2StripExport"));
        matCubemapToStripExport.SetMatrix("transform", mtx);
        matCubemapToStripExport.SetVector("isLinear_isDoubleLDR", new Vector4(isLinear ? 1 : 0, isDoubleLDR ? 1 : 0, 0, 0));

        Graphics.Blit(tex, rt, matCubemapToStripExport);
        Graphics.SetRenderTarget(rt);
        readableTex.ReadPixels(new Rect(0,0,outWidth, outHeight * 6), 0, 0, false);
        readableTex.Apply();
        var bytes = readableTex.GetRawTextureData();

        var a = new TexInput();
        a.data = bytes;
        a.width = (ushort)outWidth;
        a.height = (ushort)(outHeight * 6);

        DestroyImmediate(readableTex);
        rt.Release();

        return a;
    }

    static IEnumerator CreateLightProbeLMGroup(ExportSceneData data)
    {
        var storages = data.storages;
        var sceneToID = data.sceneToID;
        var lmBounds = data.lmBounds;
        var groupList = data.groupList;

        var probes = LightmapSettings.lightProbes;
        if (probes == null)
        {
            DebugLogError("No probes in LightingDataAsset");
            yield break;
        }
        var positions = probes.positions;

        int atlasTexSize = (int)Mathf.Ceil(Mathf.Sqrt((float)probes.count));
        atlasTexSize = (int)Mathf.Ceil(atlasTexSize / (float)ftRenderLightmap.tileSize) * ftRenderLightmap.tileSize;

        ftRenderLightmap.sectorProbePosHash = null;
        bool sectorOnly = ftRenderLightmap.fullSectorRender && ftRenderLightmap.curSector != null && ftRenderLightmap.curSector.bakeChildLightProbeGroups;
        if (sectorOnly)
        {
            // Hash sector probe positions
            ftRenderLightmap.sectorProbePosHash = new HashSet<Vector3>();
            var lgroups = ftRenderLightmap.curSector.transform.GetComponentsInChildren<LightProbeGroup>();
            Vector3 lpos;
            for(int i=0; i<lgroups.Length; i++)
            {
                var ltform = lgroups[i].transform;
                var lpositions = lgroups[i].probePositions;
                int numPos = lpositions.Length;
                for(int j=0; j<numPos; j++)
                {
                    lpos = lpositions[j];
                    lpos = ltform.TransformPoint(lpos);

                    //var go = GameObject.CreatePrimitive(PrimitiveType.Sphere);
                    //go.transform.position = lpos;
                    //var lpos2 = SnapProbePos(lpos);
                    //go.name = "# " + lpos2.x+" "+lpos2.y+" "+lpos2.z;

                    ftRenderLightmap.sectorProbePosHash.Add(ftRenderLightmap.SnapProbePos(lpos));
                }
            }
        }

        var uvpos = new float[atlasTexSize * atlasTexSize * 4];
        var uvnormal = new byte[atlasTexSize * atlasTexSize * 4];

        for(int i=0; i<probes.count; i++)
        {
            bool use = (!sectorOnly) || ftRenderLightmap.sectorProbePosHash.Contains(ftRenderLightmap.SnapProbePos(positions[i]));
            if (!use) continue;
            int x = i % atlasTexSize;
            int y = i / atlasTexSize;
            int index = y * atlasTexSize + x;
            uvpos[index * 4] =     positions[i].x;
            uvpos[index * 4 + 1] = positions[i].y;
            uvpos[index * 4 + 2] = positions[i].z;
            uvpos[index * 4 + 3] = 1.0f;
            uvnormal[index * 4 + 1] = 255;
            uvnormal[index * 4 + 3] = 255;
        }

        var posFile = new byte[128 + uvpos.Length * 4];
        System.Buffer.BlockCopy(ftDDS.ddsHeaderFloat4, 0, posFile, 0, 128);
        System.Buffer.BlockCopy(BitConverter.GetBytes(atlasTexSize), 0, posFile, 12, 4);
        System.Buffer.BlockCopy(BitConverter.GetBytes(atlasTexSize), 0, posFile, 16, 4);
        System.Buffer.BlockCopy(uvpos, 0, posFile, 128, uvpos.Length * 4);
        SaveGBufferMapFromRAM(posFile, posFile.Length, scenePath + "/uvpos_probes" + (ftRenderLightmap.compressedGBuffer ? ".lz4" : ".dds"), ftRenderLightmap.compressedGBuffer);
        //GL.IssuePluginEvent(8);
        //yield return null;

        var posNormal = new byte[128 + uvnormal.Length];
        System.Buffer.BlockCopy(ftDDS.ddsHeaderRGBA8, 0, posNormal, 0, 128);
        System.Buffer.BlockCopy(BitConverter.GetBytes(atlasTexSize), 0, posNormal, 12, 4);
        System.Buffer.BlockCopy(BitConverter.GetBytes(atlasTexSize), 0, posNormal, 16, 4);
        System.Buffer.BlockCopy(uvnormal, 0, posNormal, 128, uvnormal.Length);
        SaveGBufferMapFromRAM(posNormal, posNormal.Length, scenePath + "/uvnormal_probes" + (ftRenderLightmap.compressedGBuffer ? ".lz4" : ".dds"), ftRenderLightmap.compressedGBuffer);
        //GL.IssuePluginEvent(8);
        //yield return null;

        lightProbeLMGroup = ScriptableObject.CreateInstance<BakeryLightmapGroup>();
        lightProbeLMGroup.name = "probes";
        lightProbeLMGroup.probes = true;
        lightProbeLMGroup.isImplicit = true;
        lightProbeLMGroup.resolution = 256;
        lightProbeLMGroup.bitmask = 1;
        lightProbeLMGroup.mode = BakeryLightmapGroup.ftLMGroupMode.Vertex;
        lightProbeLMGroup.id = data.lmid;
        lightProbeLMGroup.totalVertexCount = probes.count;
        lightProbeLMGroup.vertexCounter = 0;
        lightProbeLMGroup.renderDirMode = BakeryLightmapGroup.RenderDirMode.ProbeSH;
        lightProbeLMGroup.renderMode = (ftRenderLightmap.instance.userRenderMode == ftRenderLightmap.RenderMode.Subtractive && ftRenderLightmap.useUnityForOcclsusionProbes) ? BakeryLightmapGroup.RenderMode.Indirect : BakeryLightmapGroup.RenderMode.Auto;
        groupList.Add(lightProbeLMGroup);
        lmBounds.Add(new Bounds(new Vector3(0,0,0), new Vector3(10000,10000,10000)));
        data.lmid++;

        storages[sceneToID[EditorSceneManager.GetActiveScene()]].implicitGroups.Add(lightProbeLMGroup);
        storages[sceneToID[EditorSceneManager.GetActiveScene()]].implicitGroupedObjects.Add(null);
    }

    static IEnumerator CreateVolumeLMGroup(ExportSceneData data)
    {
        ftRenderLightmap.hasAnyVolumes = false;

        var vols = ftRenderLightmap.FindBakeableVolumes();
        if (vols.Length == 0) yield break;

        ftRenderLightmap.hasAnyVolumes = true;

        var storages = data.storages;
        var sceneToID = data.sceneToID;
        var lmBounds = data.lmBounds;
        var groupList = data.groupList;

        int numTotalProbes = 0;
        for(int v=0; v<vols.Length; v++)
        {
            numTotalProbes += ftRenderLightmap.VolumeDimension(vols[v].resolutionX) * ftRenderLightmap.VolumeDimension(vols[v].resolutionY) * ftRenderLightmap.VolumeDimension(vols[v].resolutionZ);
        }

        var positions = new Vector3[numTotalProbes];
        int i = 0;
        Vector3 halfVoxelSize = Vector3.one;
        for(int v=0; v<vols.Length; v++)
        {
            var vol = vols[v];
            int rx = ftRenderLightmap.VolumeDimension(vol.resolutionX);
            int ry = ftRenderLightmap.VolumeDimension(vol.resolutionY);
            int rz = ftRenderLightmap.VolumeDimension(vol.resolutionZ);
            vol.UpdateBounds();
            var bmin = vol.bounds.min;
            var bmax = vol.bounds.max;
            halfVoxelSize = bmax - bmin;
            halfVoxelSize = new Vector3(halfVoxelSize.x/rx, halfVoxelSize.y/ry, halfVoxelSize.z/rz) * 0.5f;
            float lx, ly, lz;
            for(int z=0; z<rz; z++)
            {
                lz = Mathf.Lerp(bmin.z, bmax.z, z/(float)rz) + halfVoxelSize.z;
                for(int y=0; y<ry; y++)
                {
                    ly = Mathf.Lerp(bmin.y, bmax.y, y/(float)ry) + halfVoxelSize.y;
                    for(int x=0; x<rx; x++)
                    {
                        lx = Mathf.Lerp(bmin.x, bmax.x, x/(float)rx) + halfVoxelSize.x;
                        positions[i] = new Vector3(lx, ly, lz);
                        i++;
                    }
                }
            }
        }

        int atlasTexSize = (int)Mathf.Ceil(Mathf.Sqrt((float)numTotalProbes));
        atlasTexSize = (int)Mathf.Ceil(atlasTexSize / (float)ftRenderLightmap.tileSize) * ftRenderLightmap.tileSize;
        var uvpos = new float[atlasTexSize * atlasTexSize * 4];
        var uvnormal = new byte[atlasTexSize * atlasTexSize * 4];

        for(i=0; i<numTotalProbes; i++)
        {
            int x = i % atlasTexSize;
            int y = i / atlasTexSize;
            int index = y * atlasTexSize + x;
            uvpos[index * 4] =     positions[i].x;
            uvpos[index * 4 + 1] = positions[i].y;
            uvpos[index * 4 + 2] = positions[i].z;
            uvpos[index * 4 + 3] = 1.0f;
            uvnormal[index * 4 + 1] = 255;
            uvnormal[index * 4 + 3] = 255;
        }

        var posFile = new byte[128 + uvpos.Length * 4];
        System.Buffer.BlockCopy(ftDDS.ddsHeaderFloat4, 0, posFile, 0, 128);
        System.Buffer.BlockCopy(BitConverter.GetBytes(atlasTexSize), 0, posFile, 12, 4);
        System.Buffer.BlockCopy(BitConverter.GetBytes(atlasTexSize), 0, posFile, 16, 4);
        System.Buffer.BlockCopy(uvpos, 0, posFile, 128, uvpos.Length * 4);
        SaveGBufferMapFromRAM(posFile, posFile.Length, scenePath + "/uvpos_volumes" + (ftRenderLightmap.compressedGBuffer ? ".lz4" : ".dds"), ftRenderLightmap.compressedGBuffer);
        //GL.IssuePluginEvent(8);
        //yield return null;

        var posNormal = new byte[128 + uvnormal.Length];
        System.Buffer.BlockCopy(ftDDS.ddsHeaderRGBA8, 0, posNormal, 0, 128);
        System.Buffer.BlockCopy(BitConverter.GetBytes(atlasTexSize), 0, posNormal, 12, 4);
        System.Buffer.BlockCopy(BitConverter.GetBytes(atlasTexSize), 0, posNormal, 16, 4);
        System.Buffer.BlockCopy(uvnormal, 0, posNormal, 128, uvnormal.Length);
        SaveGBufferMapFromRAM(posNormal, posNormal.Length, scenePath + "/uvnormal_volumes" + (ftRenderLightmap.compressedGBuffer ? ".lz4" : ".dds"), ftRenderLightmap.compressedGBuffer);
        //GL.IssuePluginEvent(8);
        //yield return null;

        volumeLMGroup = ScriptableObject.CreateInstance<BakeryLightmapGroup>();
        volumeLMGroup.name = "volumes";
        volumeLMGroup.probes = true;
        volumeLMGroup.fixPos3D = true;
        volumeLMGroup.voxelSize = halfVoxelSize * 2; // incorrect... should be different for every probe
        volumeLMGroup.isImplicit = true;
        volumeLMGroup.resolution = 256;
        volumeLMGroup.bitmask = 1;
        volumeLMGroup.mode = BakeryLightmapGroup.ftLMGroupMode.Vertex;
        volumeLMGroup.id = data.lmid;
        volumeLMGroup.totalVertexCount = numTotalProbes;
        volumeLMGroup.vertexCounter = 0;
        volumeLMGroup.renderMode = (BakeryLightmapGroup.RenderMode)pstorage.volumeRenderMode;
        volumeLMGroup.renderDirMode = BakeryLightmapGroup.RenderDirMode.ProbeSH;
        volumeLMGroup.sceneLodLevel = ftAdditionalConfig.volumeSceneLODLevel;
        groupList.Add(volumeLMGroup);
        lmBounds.Add(new Bounds(new Vector3(0,0,0), new Vector3(10000,10000,10000)));
        data.lmid++;

        storages[sceneToID[EditorSceneManager.GetActiveScene()]].implicitGroups.Add(volumeLMGroup);
        storages[sceneToID[EditorSceneManager.GetActiveScene()]].implicitGroupedObjects.Add(null);
    }

    static void CollectExplicitLMGroups(ExportSceneData data)
    {
        var groupList = data.groupList;
        var lmBounds = data.lmBounds;

        // Find explicit LMGroups
        // (Also init lmBounds and LMID)
        var groupSelectors = new List<BakeryLightmapGroupSelector>(FindObjectsOfType(typeof(BakeryLightmapGroupSelector)) as BakeryLightmapGroupSelector[]);
        for(int i=0; i<groupSelectors.Count; i++)
        {
            if (!groupSelectors[i].active) continue;
            var lmgroup = groupSelectors[i].lmgroupAsset as BakeryLightmapGroup;
            if (lmgroup == null) continue;
            if (!groupList.Contains(lmgroup))
            {
                lmgroup.name = FilterNonASCII(lmgroup.name);
                lmgroup.id = data.lmid;
                lmgroup.sceneLodLevel = -1;
                lmgroup.sceneName = "";
                groupList.Add(lmgroup);
                lmBounds.Add(new Bounds(new Vector3(0,0,0), new Vector3(0,0,0)));
                data.lmid++;
            }
            EditorUtility.SetDirty(lmgroup);
        }
    }

    static bool CheckForMultipleSceneStorages(GameObject obj, ExportSceneData data)
    {
        var sceneHasStorage = data.sceneHasStorage;

        // Check for storage count in each scene
        if (obj.name == "!ftraceLightmaps")
        {
            if (!sceneHasStorage.ContainsKey(obj.scene))
            {
                sceneHasStorage[obj.scene] = true;
            }
            else
            {
                return ExportSceneValidationMessage("Scene " + obj.scene.name + " has multiple lightmap storage objects. This is not currently supported. Make sure you don't bake a scene with already baked prefabs.");
            }
        }
        return true;
    }

#if USE_TERRAINS
    static void ConvertTerrain(GameObject obj)
    {
        var terr = obj.GetComponent<Terrain>();
        if (terr == null) return;
        if (!terr.enabled) return;

        if (!obj.activeInHierarchy) return;
        if ((obj.hideFlags & (HideFlags.DontSave|HideFlags.HideAndDontSave)) != 0) return; // skip temp objects
        if (obj.tag == "EditorOnly") return; // skip temp objects
        if ((GameObjectUtility.GetStaticEditorFlags(obj) & StaticEditorFlags.LightmapStatic) == 0) return; // skip dynamic

        var so = new SerializedObject(terr);
        var scaleInLmTerr = so.FindProperty("m_ScaleInLightmap").floatValue;

        var terrParent = new GameObject();
        SceneManager.MoveGameObjectToScene(terrParent, obj.scene);
        terrParent.transform.parent = obj.transform;//.parent;
        var expGroup = obj.GetComponent<BakeryLightmapGroupSelector>();
        if (expGroup != null && expGroup.active)
        {
            var expGroup2 = terrParent.AddComponent<BakeryLightmapGroupSelector>();
            expGroup2.lmgroupAsset = expGroup.lmgroupAsset;
            expGroup2.instanceResolutionOverride = expGroup.instanceResolutionOverride;
            expGroup2.instanceResolution = expGroup.instanceResolution;
        }
        terrParent.name = "__ExportTerrainParent";
        terrainObjectList.Add(terrParent);
        terrainObjectToActual.Add(terr);

        var tdata = terr.terrainData;
        int res = tdata.heightmapResolution;
        var heightmap = tdata.GetHeights(0, 0, res, res);
        var uvscale = new Vector2(1,1) / (res-1);
        var uvoffset = new Vector2(0,0);
        var gposOffset = obj.transform.position;
        float scaleX = tdata.size.x / (res-1);
        float scaleY = tdata.size.y;
        float scaleZ = tdata.size.z / (res-1);

        int patchRes = res;
#if UNITY_2017_3_OR_NEWER
        // supports 32-bit indices
#else
        while(patchRes > 254) patchRes = 254;//patchRes /= 2;
#endif
        int numVerts = patchRes * patchRes;
        int numPatches = (int)Mathf.Ceil(res / (float)patchRes);

        // Gen terrain texture
        var oldMat = terr.materialTemplate;
        var oldMatType = terr.materialType;
        var oldPos = obj.transform.position;
#if UNITY_2018_3_OR_NEWER
        var oldInstanced = terr.drawInstanced;
#endif
        var unlitTerrainMat = new Material(Shader.Find("Hidden/ftUnlitTerrain"));
            //unlitTerrainMat = AssetDatabase.LoadAssetAtPath("Assets/Bakery/ftUnlitTerrain.mat", typeof(Material)) as Material;
        terr.materialTemplate = unlitTerrainMat;
        terr.materialType = Terrain.MaterialType.Custom;
#if UNITY_2018_3_OR_NEWER
        terr.drawInstanced = false;
#endif

        int baseMapResolution = tdata.baseMapResolution;
#if UNITY_2019_3_OR_NEWER
        int holesResolution = tdata.holesResolution;
        if (holesResolution > baseMapResolution) baseMapResolution = holesResolution;
#endif

        obj.transform.position = new Vector3(-10000, -10000, -10000); // let's hope it's not the worst idea
        var tempCamGO = new GameObject();
        tempCamGO.transform.parent = obj.transform;
        tempCamGO.transform.localPosition = new Vector3(tdata.size.x * 0.5f, scaleY + 1, tdata.size.z * 0.5f);
        tempCamGO.transform.eulerAngles = new Vector3(90,0,0);
        var tempCam = tempCamGO.AddComponent<Camera>();
        tempCam.orthographic = true;
        tempCam.orthographicSize = Mathf.Max(tdata.size.x, tdata.size.z) * 0.5f;
        tempCam.aspect = Mathf.Max(tdata.size.x, tdata.size.z) / Mathf.Min(tdata.size.x, tdata.size.z);
        tempCam.enabled = false;
        tempCam.clearFlags = CameraClearFlags.SolidColor;
        tempCam.backgroundColor = new Color(0,0,0,0);
        tempCam.targetTexture =
            new RenderTexture(baseMapResolution, baseMapResolution, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.sRGB);
        var tex = new Texture2D(baseMapResolution, baseMapResolution, TextureFormat.ARGB32, true, false);
        RenderTexture.active = tempCam.targetTexture;
        tempCam.Render();
        terr.materialTemplate = oldMat;
        terr.materialType = oldMatType;
#if UNITY_2018_3_OR_NEWER
        terr.drawInstanced = oldInstanced;
#endif
        obj.transform.position = oldPos;
        RenderTexture.active = tempCam.targetTexture;
        tex.ReadPixels(new Rect(0,0,baseMapResolution, baseMapResolution), 0, 0, true);
        tex.Apply();
        unlitTerrainMat.mainTexture = tex;
        Graphics.SetRenderTarget(null);
        DestroyImmediate(tempCamGO);

        bool isDX11 = SystemInfo.graphicsDeviceType == GraphicsDeviceType.Direct3D11;

        if (exportTerrainAsHeightmap)
        {
            var hmap = new BinaryWriter(File.Open(scenePath + "/height" + terrainObjectToHeightMap.Count + ".dds", FileMode.Create));
            if (ftRenderLightmap.clientMode) ftClient.serverFileList.Add("height" + terrainObjectToHeightMap.Count + ".dds");

            hmap.Write(ftDDS.ddsHeaderR32F);
            var bytes = new byte[res * res * 4];

            // Normalize heights
            float maxHeight = 0;
            float height;
            for(int y=0; y<res; y++)
            {
                for(int x=0; x<res; x++)
                {
                    height = heightmap[x,y];
                    if (height > maxHeight) maxHeight = height;
                }
            }
            maxHeight = Mathf.Max(maxHeight, 0.0001f);
            float invMaxHeight = 1.0f / maxHeight;
            for(int y=0; y<res; y++)
            {
                for(int x=0; x<res; x++)
                {
                    heightmap[x,y] *= invMaxHeight;
                }
            }
            float aabbHeight = maxHeight * scaleY;

            // First mip is the real heightmap
            System.Buffer.BlockCopy(heightmap, 0, bytes, 0, bytes.Length);
            hmap.Write(bytes);

            if (isDX11)
            {
                var htex = new Texture2D(res, res, TextureFormat.RFloat, false, true);
                htex.LoadRawTextureData(bytes);
                htex.Apply();
                terrainObjectToHeightMap.Add(htex);
            }
            else
            {
                var a = new TexInput();
                a.data = bytes;
                a.width = (ushort)res;
                a.height = a.width;
                terrainObjectToHeightMapRAM.Add(a);
                terrainObjectToHeightMap.Add(null);
            }

            // min
            terrainObjectToBounds.Add(obj.transform.position.x);
            terrainObjectToBounds.Add(obj.transform.position.y);
            terrainObjectToBounds.Add(obj.transform.position.z);
            // max
            terrainObjectToBounds.Add(obj.transform.position.x + tdata.size.x);
            terrainObjectToBounds.Add(obj.transform.position.y + aabbHeight);
            terrainObjectToBounds.Add(obj.transform.position.z + tdata.size.z);

            // filled later
            terrainObjectToLMID.Add(0);
            terrainObjectToBoundsUV.Add(0);
            terrainObjectToBoundsUV.Add(0);
            terrainObjectToBoundsUV.Add(0);
            terrainObjectToBoundsUV.Add(0);

            terrainObjectToFlags.Add(terr.castShadows ? 1 : 0);

            // Second mip is max() of 3x3 corners
            float[] floats = null;
            float[] floatsPrev = null;
            float[] floatsTmp;
            int mipCount = 1;
            int mipRes = res / 2;
            //int prevRes = res;
            float h00, h10, h01, h11;
            /*Vector3 n00, n10, n01, n11;
            Vector3[] normals = null;
            Vector3[] normalsPrev = null;

            var origNormals = new Vector3[res * res];
            for(int y=0; y<res; y++)
            {
                for(int x=0; x<res; x++)
                {
                    origNormals[y*res+x] = data.GetInterpolatedNormal(x / (float)res, y / (float)res);
                }
            }*/
            int terrIndex = terrainObjectToHeightMap.Count - 1;//terrainObjectToNormalMip0.Count;
            //terrainObjectToNormalMip0.Add(origNormals);
            //normalsPrev = origNormals;
            terrainObjectToHeightMips.Add(new List<float[]>());
            //terrainObjectToNormalMips.Add(new List<Vector3[]>());

            if (mipRes > 0)
            {
                floats = new float[mipRes * mipRes];
                //normals = new Vector3[mipRes * mipRes];
                for(int y=0; y<mipRes; y++)
                {
                    for(int x=0; x<mipRes; x++)
                    {
                        /*h00 = heightmap[y*2,x*2];
                        h10 = heightmap[y*2,x*2+1];
                        h01 = heightmap[y*2+1,x*2];
                        h11 = heightmap[y*2+1,x*2+1];
                        height = h00 > h10 ? h00 : h10;
                        height = height > h01 ? height : h01;
                        height = height > h11 ? height : h11;
                        floats[y*mipRes+x] = height;*/

                        float maxVal = 0;
                        for(int yy=0; yy<3; yy++)
                        {
                            for(int xx=0; xx<3; xx++)
                            {
                                float val = heightmap[y*2+yy, x*2+xx];
                                if (val > maxVal) maxVal = val;
                            }
                        }
                        floats[y*mipRes+x] = maxVal;

                        //n00 = normalsPrev[y*2 * res + x*2];
                        //n10 = normalsPrev[y*2 * res + x*2+1];
                        //n01 = normalsPrev[(y*2+1) * res + x*2];
                        //n11 = normalsPrev[(y*2+1) * res + x*2+1];
                        //normals[y*mipRes+x] = (n00 + n10 + n01 + n11);
                    }
                }

                System.Buffer.BlockCopy(floats, 0, bytes, 0, mipRes*mipRes*4);
                hmap.Write(bytes, 0, mipRes*mipRes*4);

                float[] storedMip = new float[mipRes*mipRes];
                System.Buffer.BlockCopy(floats, 0, storedMip, 0, mipRes*mipRes*4);
                terrainObjectToHeightMips[terrIndex].Add(storedMip);
                //terrainObjectToNormalMips[terrIndex].Add(normals);

                mipCount++;
                mipRes /= 2;
            }

            // Next mips are regular max() of 4 texels
            while(mipRes > 1)
            {
                if (floatsPrev == null)
                {
                    floatsPrev = floats;
                    floats = new float[mipRes * mipRes];
                }

                //normalsPrev = normals;
                //normals = new Vector3[mipRes * mipRes];

                for(int y=0; y<mipRes; y++)
                {
                    for(int x=0; x<mipRes; x++)
                    {
                        h00 = floatsPrev[y*2 * mipRes*2 + x*2];
                        h10 = floatsPrev[y*2 * mipRes*2 + x*2+1];
                        h01 = floatsPrev[(y*2+1) * mipRes*2 + x*2];
                        h11 = floatsPrev[(y*2+1) * mipRes*2 + x*2+1];
                        height = h00 > h10 ? h00 : h10;
                        height = height > h01 ? height : h01;
                        height = height > h11 ? height : h11;
                        floats[y*mipRes+x] = height;

                        //n00 = normalsPrev[y*2 * mipRes*2 + x*2];
                        //n10 = normalsPrev[y*2 * mipRes*2 + x*2+1];
                        //n01 = normalsPrev[(y*2+1) * mipRes*2 + x*2];
                        //n11 = normalsPrev[(y*2+1) * mipRes*2 + x*2+1];
                        //normals[y*mipRes+x] = (n00 + n10 + n01 + n11);
                    }
                }

                System.Buffer.BlockCopy(floats, 0, bytes, 0, mipRes*mipRes*4);
                hmap.Write(bytes, 0, mipRes*mipRes*4);

                float[] storedMip = new float[mipRes*mipRes];
                System.Buffer.BlockCopy(floats, 0, storedMip, 0, mipRes*mipRes*4);
                terrainObjectToHeightMips[terrIndex].Add(storedMip);
                //terrainObjectToNormalMips[terrIndex].Add(normals);

                mipCount++;
                mipRes /= 2;

                floatsTmp = floatsPrev;
                floatsPrev = floats;
                floats = floatsTmp;
            }

            hmap.BaseStream.Seek(12, SeekOrigin.Begin);
            hmap.Write(res);
            hmap.Write(res);
            hmap.BaseStream.Seek(28, SeekOrigin.Begin);
            hmap.Write(mipCount);
            hmap.Close();

            // Create dummy plane for packing/albedo/emissive purposes
            var mesh = new Mesh();
            mesh.vertices = new Vector3[] { gposOffset,
                                            gposOffset + new Vector3(tdata.size.x, 0, 0),
                                            gposOffset + new Vector3(tdata.size.x, 0, tdata.size.z),
                                            gposOffset + new Vector3(0, 0, tdata.size.z) };
            mesh.triangles = new int[]{0,1,2, 2,3,0};
            mesh.normals = new Vector3[]{Vector3.up, Vector3.up, Vector3.up, Vector3.up};
            mesh.uv = new Vector2[]{new Vector2(0,0), new Vector2(1,0), new Vector2(1,1), new Vector2(0,1)};
            mesh.uv2 = mesh.uv;

            var terrGO = new GameObject();
            terrGO.name = "__ExportTerrain";
            GameObjectUtility.SetStaticEditorFlags(terrGO, StaticEditorFlags.LightmapStatic);
            terrGO.transform.parent = terrParent.transform;
            var mf = terrGO.AddComponent<MeshFilter>();
            var mr = terrGO.AddComponent<MeshRenderer>();
            mf.sharedMesh = mesh;
#if UNITY_2019_3_OR_NEWER
            // using standard materialTemplates in 2019.3 doesn't work
            mr.sharedMaterial = unlitTerrainMat;
#else
            mr.sharedMaterial = (terr.materialTemplate == null) ? unlitTerrainMat : terr.materialTemplate;
#endif

            terrGO.transform.position = obj.transform.position;

            var so2 = new SerializedObject(mr);
            so2.FindProperty("m_ScaleInLightmap").floatValue = scaleInLmTerr;
            so2.ApplyModifiedProperties();

            //terrainObjectList.Add(terrGO);
            //terrainObjectToActual.Add(terr);
        }
        else
        {
            for (int patchX=0; patchX<numPatches; patchX++)
            {
                for (int patchY=0; patchY<numPatches; patchY++)
                {
                    int patchResX = patchX < numPatches-1 ? patchRes : (res - patchRes*(numPatches-1));
                    int patchResY = patchY < numPatches-1 ? patchRes : (res - patchRes*(numPatches-1));
                    if (patchX < numPatches-1) patchResX += 1;
                    if (patchY < numPatches-1) patchResY += 1;
                    numVerts = patchResX * patchResY;
                    var posOffset = gposOffset + new Vector3(patchX*patchRes*scaleX, 0, patchY*patchRes*scaleZ);

                    var positions = new Vector3[numVerts];
                    var uvs = new Vector2[numVerts];
                    var normals = new Vector3[numVerts];
                    var indices = new int[(patchResX-1) * (patchResY-1) * 2 * 3];
                    int vertOffset = 0;
                    int indexOffset = 0;

                    for (int x=0;x<patchResX;x++)
                    {
                        for (int y=0;y<patchResY;y++)
                        {
                            int gx = x + patchX * patchRes;
                            int gy = y + patchY * patchRes;

                            int index = x * patchResY + y;
                            float height = heightmap[gy,gx];

                            positions[index] = new Vector3(x * scaleX, height * scaleY, y * scaleZ) + posOffset;
                            uvs[index] = new Vector2(gx * uvscale.x + uvoffset.x, gy * uvscale.y + uvoffset.y);

                            normals[index] = tdata.GetInterpolatedNormal(gx / (float)res, gy / (float)res);

                            if (x < patchResX-1 && y < patchResY-1)
                            {
                                indices[indexOffset] = vertOffset + patchResY + 1;
                                indices[indexOffset + 1] = vertOffset + patchResY;
                                indices[indexOffset + 2] = vertOffset;

                                indices[indexOffset + 3] = vertOffset + 1;
                                indices[indexOffset + 4] = vertOffset + patchResY + 1;
                                indices[indexOffset + 5] = vertOffset;

                                indexOffset += 6;
                            }

                            vertOffset++;
                        }
                    }

                    var mesh = new Mesh();
#if UNITY_2017_3_OR_NEWER
                    mesh.indexFormat = UnityEngine.Rendering.IndexFormat.UInt32;
#endif
                    mesh.vertices = positions;
                    mesh.triangles = indices;
                    mesh.normals = normals;
                    mesh.uv = uvs;
                    mesh.uv2 = uvs;

                    var terrGO = new GameObject();
                    terrGO.name = "__ExportTerrain";
                    GameObjectUtility.SetStaticEditorFlags(terrGO, StaticEditorFlags.LightmapStatic);
                    terrGO.transform.parent = terrParent.transform;
                    var mf = terrGO.AddComponent<MeshFilter>();
                    var mr = terrGO.AddComponent<MeshRenderer>();
                    mf.sharedMesh = mesh;
#if UNITY_2019_3_OR_NEWER
                    // using standard materialTemplates in 2019.3 doesn't work
                    mr.sharedMaterial = unlitTerrainMat;
#else
                    mr.sharedMaterial = (terr.materialTemplate == null) ? unlitTerrainMat : terr.materialTemplate;
#endif

                    var so2 = new SerializedObject(mr);
                    so2.FindProperty("m_ScaleInLightmap").floatValue = scaleInLmTerr;
                    so2.ApplyModifiedProperties();

                    mr.shadowCastingMode = terr.castShadows ? UnityEngine.Rendering.ShadowCastingMode.On : UnityEngine.Rendering.ShadowCastingMode.Off;

                    terrainObjectList.Add(terrGO);
                    terrainObjectToActual.Add(terr);
                }
            }
        }

        if (exportTerrainTrees && terr.drawTreesAndFoliage)
        {
            var trees = tdata.treeInstances;
            for (int t = 0; t < trees.Length; t++)
            {
                Vector3 pos = Vector3.Scale(trees[t].position, tdata.size) + obj.transform.position;

                var treeProt = tdata.treePrototypes[trees[t].prototypeIndex];
                var prefab = treeProt.prefab;

                var newObj = GameObject.Instantiate(prefab, pos, Quaternion.AngleAxis(trees[t].rotation, Vector3.up)) as GameObject;
                newObj.name = "__Export" + newObj.name;
                temporaryGameObjects.Add(newObj);

                var lodGroup = newObj.GetComponent<LODGroup>();
                if (lodGroup == null)
                {
                    var renderers = newObj.GetComponentsInChildren<Renderer>();
                    for(int r=0; r<renderers.Length; r++)
                    {
                        GameObjectUtility.SetStaticEditorFlags(renderers[r].gameObject, StaticEditorFlags.LightmapStatic);
                        var s = new SerializedObject(renderers[r]);
                        s.FindProperty("m_ScaleInLightmap").floatValue = 0;
                        s.ApplyModifiedProperties();
                    }
                }
                else
                {
                    var lods = lodGroup.GetLODs();
                    int numLODs = lods.Length;
                    int desiredLODLevel = System.Math.Min(terrainTreeLODLevel, numLODs-1);
                    for (int tl = 0; tl < numLODs; tl++)
                    {
                        int numLODRenderers = lods[tl].renderers.Length;
                        for (int h = 0; h < numLODRenderers; h++)
                        {
                            GameObjectUtility.SetStaticEditorFlags(lods[tl].renderers[h].gameObject, tl == desiredLODLevel ? StaticEditorFlags.LightmapStatic : 0);
                            if (tl == desiredLODLevel)
                            {
                                var s = new SerializedObject(lods[tl].renderers[h]);
                                s.FindProperty("m_ScaleInLightmap").floatValue = 0;
                                s.ApplyModifiedProperties();
                            }
                        }
                    }
                    if (desiredLODLevel > 0) DestroyImmediate(lodGroup);
                }

                var xform = newObj.transform;
                xform.localScale = new Vector3(trees[t].widthScale, trees[t].heightScale, trees[t].widthScale);
            }
        }
    }
#endif

    public static bool ConvertUnityAreaLight(GameObject obj)
    {
        // Add temporary meshes to area lights
        var areaLightMesh = obj.GetComponent<BakeryLightMesh>();
        if (areaLightMesh != null)
        {
            var areaLight = obj.GetComponent<Light>();
            var mr = GetValidRenderer(obj);
            var mf = obj.GetComponent<MeshFilter>();

            if (!forceAllAreaLightsSelfshadow)
            {
                if (!areaLightMesh.selfShadow) return true; // no selfshadow - ignore mesh export
            }
            if (areaLight != null && ftLightMeshInspector.IsArea(areaLight) && (mr == null || mf == null))
            {
                var areaObj = new GameObject();
                if (mf == null) mf = areaObj.AddComponent<MeshFilter>();
                mf.sharedMesh = BuildAreaLightMesh(areaLight);
                if (mr == null)
                {
                    mr = areaObj.AddComponent<MeshRenderer>();
                    if (matAreaLight == null)  matAreaLight = new Material(Shader.Find("Bakery/Light"));
                    mr.sharedMaterial = matAreaLight;
                }

                var props = new MaterialPropertyBlock();
                props.SetColor("_Color", areaLightMesh.color);
                props.SetFloat("intensity", areaLightMesh.intensity);
                if (areaLightMesh.texture != null) props.SetTexture("_MainTex", areaLightMesh.texture);
                mr.SetPropertyBlock(props);
                GameObjectUtility.SetStaticEditorFlags(areaObj, StaticEditorFlags.LightmapStatic);
                temporaryAreaLightMeshList.Add(areaObj);
                temporaryAreaLightMeshList2.Add(areaLightMesh);

                var xformSrc = obj.transform;
                var xformDest = areaObj.transform;
                xformDest.position = xformSrc.position;
                xformDest.rotation = xformSrc.rotation;
                var srcMtx = xformSrc.localToWorldMatrix;
                xformDest.localScale = new Vector3(srcMtx.GetColumn(0).magnitude, srcMtx.GetColumn(1).magnitude, srcMtx.GetColumn(2).magnitude);

                return true; // mesh created
            }
        }
        return false; // not Light Mesh
    }

    static void MapObjectsToSceneLODs(ExportSceneData data, UnityEngine.Object[] objects)
    {
        var objToLodLevel = data.objToLodLevel;
        var objToLodLevelVisible = data.objToLodLevelVisible;
        lodLevelsVisibleInLodLevel = new Dictionary<int, List<int>>();

        const int maxSceneLodLevels = 100;
        var sceneLodUsed = new int[maxSceneLodLevels];
        for(int i=0; i<maxSceneLodLevels; i++) sceneLodUsed[i] = -1;
        var lodGroups = Resources.FindObjectsOfTypeAll(typeof(LODGroup));
        var lodLevelsInLodGroup = new List<int>[lodGroups.Length];
        var localLodLevelsInLodGroup = new List<int>[lodGroups.Length];
        int lcounter = -1;
        foreach(LODGroup lodgroup in lodGroups)
        {
            lcounter++;
            if (!lodgroup.enabled) continue;
            var obj = lodgroup.gameObject;
            if (obj == null) continue;
            if (!obj.activeInHierarchy) continue;
            var path = AssetDatabase.GetAssetPath(obj);
            if (path != "") continue; // must belond to scene
            if ((obj.hideFlags & (HideFlags.DontSave|HideFlags.HideAndDontSave)) != 0) continue; // skip temp objects
            if (obj.tag == "EditorOnly") continue; // skip temp objects

            var lods = lodgroup.GetLODs();
            if (lods.Length == 0) continue;

            for(int i=0; i<lods.Length; i++)
            {
                var lodRenderers = lods[i].renderers;
                if (lodRenderers.Length == 0) continue;

                bool lightmappedLOD = false;
                for(int j=0; j<lodRenderers.Length; j++)
                {
                    var r = lodRenderers[j];
                    if (r == null) continue;
                    if (!r.enabled) continue;
                    if (!r.gameObject.activeInHierarchy) continue;
                    if ((r.gameObject.hideFlags & (HideFlags.DontSave|HideFlags.HideAndDontSave)) != 0) continue; // skip temp objects
                    if (r.gameObject.tag == "EditorOnly") continue; // skip temp objects
                    if ((GameObjectUtility.GetStaticEditorFlags(r.gameObject) & StaticEditorFlags.LightmapStatic) == 0) continue; // skip dynamic
                    var mr = GetValidRenderer(r.gameObject);
                    var sharedMesh = GetSharedMesh(mr);
                    if (mr == null || sharedMesh == null) continue; // must have visible mesh
                    var mrEnabled = mr.enabled || r.gameObject.GetComponent<BakeryAlwaysRender>() != null;
                    if (!mrEnabled) continue;
                    //if (mf.sharedMesh == null) continue;

                    var so = new SerializedObject(mr);
                    var scaleInLm = so.FindProperty("m_ScaleInLightmap").floatValue; // (before FilterObjects)
#if UNITY_2019_2_OR_NEWER
                    var _r = mr as MeshRenderer;
                    if (pstorage.takeReceiveGIIntoAccount && _r != null && _r.receiveGI == ReceiveGI.LightProbes) scaleInLm = 0;
#endif
                    if (scaleInLm == 0) continue;

                    lightmappedLOD = true;
                    break;
                }
                if (!lightmappedLOD) continue;

                var lodDist = i == 0 ? 0 : (int)Mathf.Clamp((1.0f-lods[i-1].screenRelativeTransitionHeight) * (maxSceneLodLevels-1), 0, maxSceneLodLevels-1);
                if (sceneLodUsed[lodDist] < 0)
                {
                    sceneLodUsed[lodDist] = sceneLodsUsed;
                    sceneLodsUsed++;
                }
                int newLodLevel = sceneLodUsed[lodDist];

                if (lodLevelsInLodGroup[lcounter] == null)
                {
                    lodLevelsInLodGroup[lcounter] = new List<int>();
                    localLodLevelsInLodGroup[lcounter] = new List<int>();
                }
                if (lodLevelsInLodGroup[lcounter].IndexOf(newLodLevel) < 0)
                {
                    lodLevelsInLodGroup[lcounter].Add(newLodLevel);
                    localLodLevelsInLodGroup[lcounter].Add(i);
                }

                for(int j=0; j<lodRenderers.Length; j++)
                {
                    var r = lodRenderers[j];
                    if (r == null) continue;
                    int existingLodLevel = -1;
                    if (objToLodLevel.ContainsKey(r.gameObject)) existingLodLevel = objToLodLevel[r.gameObject];
                    if (existingLodLevel < newLodLevel)
                    {
                        objToLodLevel[r.gameObject] = existingLodLevel < 0 ? newLodLevel : existingLodLevel; // set to lowest LOD

                        // Collect LOD levels where this object is visible
                        List<int> visList;
                        if (!objToLodLevelVisible.TryGetValue(r.gameObject, out visList)) objToLodLevelVisible[r.gameObject] = visList = new List<int>();
                        visList.Add(newLodLevel);
                    }
                }
            }
        }

        // Sort scene LOD levels
        int counter = 0;
        var unsortedLodToSortedLod = new int[maxSceneLodLevels];
        for(int i=0; i<maxSceneLodLevels; i++)
        {
            int unsorted = sceneLodUsed[i];
            if (unsorted >= 0)
            {
                unsortedLodToSortedLod[unsorted] = counter;
                sceneLodUsed[i] = counter;
                counter++;
            }
        }
        var keys = new GameObject[objToLodLevel.Count];
        counter = 0;
        foreach(var pair in objToLodLevel)
        {
            keys[counter] = pair.Key;
            counter++;
        }
        foreach(var key in keys)
        {
            int unsorted = objToLodLevel[key];
            objToLodLevel[key] = unsortedLodToSortedLod[unsorted];
            var visList = objToLodLevelVisible[key];
            for(int j=0; j<visList.Count; j++)
            {
                visList[j] = unsortedLodToSortedLod[visList[j]];
            }
        }
        for(int i=0; i<lodLevelsInLodGroup.Length; i++)
        {
            if (lodLevelsInLodGroup[i] == null) continue;
            var levels = lodLevelsInLodGroup[i];
            for(int j=0; j<levels.Count; j++)
            {
                levels[j] = unsortedLodToSortedLod[levels[j]];
            }
        }

        // Fill LOD gaps
        for(int i=0; i<lodLevelsInLodGroup.Length; i++)
        {
            if (lodLevelsInLodGroup[i] == null) continue;
            var levels = lodLevelsInLodGroup[i];
            var localLevels = localLodLevelsInLodGroup[i];
            var lgroup = lodGroups[i] as LODGroup;
            var lods = lgroup.GetLODs();
            for(int j=0; j<levels.Count; j++)
            {
                int level = levels[j];
                int localLevel = localLevels[j];
                int nextLevel = (j == levels.Count-1) ? (sceneLodsUsed-1) : levels[j+1];
                if (nextLevel - level > 1)
                {
                    var lodRenderers = lods[localLevel].renderers;
                    for(int k=0; k<lodRenderers.Length; k++)
                    {
                        var r = lodRenderers[k];
                        if (r == null) continue;

                        var visList = objToLodLevelVisible[r.gameObject];
                        for(int l=level+1; l<nextLevel; l++)
                        {
                            visList.Add(l);
                        }
                    }
                }
            }
        }

        // Compute which LOD levels are visible in other LOD levels
        foreach(var objToVisible in objToLodLevelVisible)
        {
            var obj = objToVisible.Key;
            var objAffects = objToVisible.Value;
            if (objAffects == null) continue;

            int objOwnLOD = -1;
            if (!objToLodLevel.TryGetValue(obj, out objOwnLOD)) continue;
            if (objOwnLOD < 0) continue;

            for(int i=0; i<objAffects.Count; i++)
            {
                int affectedLOD = objAffects[i];

                List<int> visList;
                if (!lodLevelsVisibleInLodLevel.TryGetValue(affectedLOD, out visList)) lodLevelsVisibleInLodLevel[affectedLOD] = visList = new List<int>();
                if (visList.IndexOf(objOwnLOD) < 0) visList.Add(objOwnLOD);
            }
        }
        /*foreach(var pair in lodLevelsVisibleInLodLevel)
        {
            string str = "LOD " + pair.Key + " sees: ";
            for(int i=0; i<pair.Value.Count; i++)
            {
                str += pair.Value[i] + ", ";
            }
            Debug.LogError(str);
        }*/

        DebugLogInfo("Scene LOD levels: " + sceneLodsUsed);

        // Init scene LOD index buffers
        data.indicesOpaqueLOD = new List<int>[sceneLodsUsed];
        data.indicesTransparentLOD = new List<int>[sceneLodsUsed];
        for(int i=0; i<sceneLodsUsed; i++)
        {
            data.indicesOpaqueLOD[i] = new List<int>();
            data.indicesTransparentLOD[i] = new List<int>();
        }

        // Sort objects by scene-wide LOD level
        if (sceneLodsUsed > 0)
        {
            Array.Sort(objects, delegate(UnityEngine.Object a, UnityEngine.Object b)
            {
                if (a == null || b == null) return 0;
                int lodLevelA = -1;
                int lodLevelB = -1;
                if (!objToLodLevel.TryGetValue((GameObject)a, out lodLevelA)) lodLevelA = -1;
                if (!objToLodLevel.TryGetValue((GameObject)b, out lodLevelB)) lodLevelB = -1;
                return lodLevelA.CompareTo(lodLevelB);
            });
        }
    }

    public static int IsInsideSector(Transform tform, Transform sectorTform, Bounds b, BakerySector s)
    {
        var parent = tform;
        while(parent != null)
        {
            if (parent == sectorTform) return 1; // belongs to this sector
            parent = parent.parent;
        }

        return 0; // far
    }

    static bool ClipFarSphere(FarSphereRenderData clipee, FarSphereRenderData clipper)
    {
        if (farSphereProjClipShader == null)
        {
            farSphereProjClipShader = Shader.Find("Hidden/ftFarSphereProjClip");
            if (farSphereProjClipShader == null)
            {
                Debug.LogError("Can't find ftFarSphereProjClip shader");
                return false;
            }
        }

        if (farSphereProjClipMat == null)
        {
            farSphereProjClipMat = new Material(farSphereProjClipShader);
        }

        // Project clipper depth to clipee
        // If projected pixel is on screen and is closer to the projector
        //      draw empty pixel
        // else
        //      discard
        var cmd = new CommandBuffer();
        Shader.SetGlobalFloat("_InvCubeSize", 1.0f / ftAdditionalConfig.sectorFarSphereResolution);
        for(int i=0; i<6; i++)
        {
            Shader.SetGlobalTexture("_CurDepth", clipee.depth[i]);
            Shader.SetGlobalMatrix("_CurInvViewProj", Matrix4x4.Inverse(clipee.viewProj[i]));
            Shader.SetGlobalVector("_CurPos", clipee.pos);
            Shader.SetGlobalTexture("_CurNormal", clipee.normal[i]);

            for(int j=0; j<6; j++)
            {
                Shader.SetGlobalTexture("_ProjDepth", clipper.depth[j]);
                Shader.SetGlobalMatrix("_ProjViewProj", clipper.viewProj[j]);
                Shader.SetGlobalVector("_ProjPos", clipper.pos);

                //Graphics.Blit(null, clipee.albedo[i], farSphereProjClipMat); // can flip

                cmd.Clear();
                cmd.SetRenderTarget(new RenderTargetIdentifier(clipee.albedo[i]), 0, CubemapFace.Unknown, 0);
                cmd.DrawProcedural(Matrix4x4.identity, farSphereProjClipMat, 0, MeshTopology.Triangles, 6, 1, null);
                Graphics.ExecuteCommandBuffer(cmd);
            }
        }

        return true;
    }

    static FarSphereRenderData GenerateFarSphereData(ExportSceneData data, Vector3 capturePoint, int objCount, bool genProjMatrix)
    {
        // Constants
        const int cubeRes = ftAdditionalConfig.sectorFarSphereResolution;

        var rot = new Vector3[6];
        rot[0] = new Vector3(0, -90,    0);
        rot[1] = new Vector3(0, 90,     0);
        rot[2] = new Vector3(90, 0,     0);
        rot[3] = new Vector3(-90, 0,    0);
        rot[4] = new Vector3(0, 180,    180);
        rot[5] = new Vector3(0, 0,      180);

        var wnormal = new Vector3[6];
        wnormal[0] = -Vector3.right;
        wnormal[1] = Vector3.right;
        wnormal[2] = -Vector3.up;
        wnormal[3] = Vector3.up;
        wnormal[4] = -Vector3.forward;
        wnormal[5] = Vector3.forward;

        var objsToWrite = data.objsToWrite;
        //var sector = ftRenderLightmap.curSector;

        // Load shaders
        if (farSphereRshader == null)
        {
            farSphereRshader = Shader.Find("Hidden/ftFarSphereRender");
            if (farSphereRshader == null)
            {
                Debug.LogError("Can't find ftFarSphereRender shader");
                return null;
            }
        }

        if (farSphereRshaderOcc == null)
        {
            farSphereRshaderOcc = Shader.Find("Hidden/ftFarSphereRenderOccluder");
            if (farSphereRshaderOcc == null)
            {
                Debug.LogError("Can't find ftFarSphereRenderOccluder shader");
                return null;
            }
        }

        if (farSphereMatOcc == null)
        {
            farSphereMatOcc = new Material(farSphereRshaderOcc);
        }

        // Create RTs
        FarSphereRenderData outData = new FarSphereRenderData();
        outData.albedo = new RenderTexture[6];
        outData.depth = new RenderTexture[6];
        outData.normal = new RenderTexture[6];
        outData.viewProj = new Matrix4x4[6];
        outData.pos = capturePoint;
        for(int i=0; i<6; i++)
        {
            outData.albedo[i] = new RenderTexture(cubeRes, cubeRes, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.sRGB);
            outData.albedo[i].wrapMode = TextureWrapMode.Clamp;
            outData.albedo[i].Create();
            outData.depth[i] = new RenderTexture(cubeRes, cubeRes, 32, RenderTextureFormat.Depth, RenderTextureReadWrite.Linear);
            outData.depth[i].filterMode = FilterMode.Point;
            outData.depth[i].wrapMode = TextureWrapMode.Clamp;
            outData.depth[i].Create();
            outData.normal[i] = new RenderTexture(cubeRes, cubeRes, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
            outData.normal[i].filterMode = FilterMode.Point;
            outData.normal[i].wrapMode = TextureWrapMode.Clamp;
            outData.normal[i].Create();
        }

        bool useCamera = true;
        List<Renderer> outsideRenderers = null;
//#if UNITY_2019_1_OR_NEWER
//        if (GraphicsSettings.renderPipelineAsset != null)
//        {
            useCamera = false;
            outsideRenderers = data.outsideRenderers;
            if (farSphereMat == null)
            {
                farSphereMat = new Material(farSphereRshader);
            }
//        }
//#endif

        GameObject tempCamGO = null;
        Camera tempCam = null;
        Transform camTform = null;
        Matrix4x4 uProj;
        if (useCamera)
        {
            // Create temp camera
            tempCamGO = new GameObject();
            tempCamGO.name = "BakerySectorFarCamera";
            camTform = tempCamGO.transform;
            camTform.localPosition = capturePoint;// sectorCenter;
            tempCam = tempCamGO.AddComponent<Camera>();
            tempCam.orthographic = false;
            tempCam.aspect = 1.0f;
            tempCam.fieldOfView = 90.0f;
            tempCam.enabled = false;
            tempCam.clearFlags = CameraClearFlags.Nothing;
            tempCam.backgroundColor = new Color(0,0,0,0);
            tempCam.SetReplacementShader(farSphereRshader, "RenderType");
            tempCam.nearClipPlane = 0.1f;
            tempCam.farClipPlane = 1000.0f;
            tempCam.renderingPath = RenderingPath.Forward;

            uProj = tempCam.projectionMatrix;
        }
        else
        {
            uProj = Matrix4x4.Perspective(90, 1, 0.1f, 1000.0f);
        }

        var proj = GL.GetGPUProjectionMatrix(uProj, true);

        /*// Set culling matrices for the render (cull things inside the sector + near distance)
        if (sector.tforms.Count == 0)
        {
            Shader.SetGlobalFloat("cullMatricesCount", 0);
        }
        else
        {
            var cullMatrices = new Matrix4x4[sector.tforms.Count];
            for(int i=0; i<sector.tforms.Count; i++)
            {
                cullMatrices[i] = Matrix4x4.TRS(sector.tforms[i].position, sector.tforms[i].rotation, sector.tforms[i].localScale).inverse;// + Vector3.one * sector.nearDistance).inverse;//sector.tforms[i].worldToLocalMatrix;
                //cullMatrices[i] = sector.tforms[i].worldToLocalMatrix;
            }
            Shader.SetGlobalMatrixArray("cullMatrices", cullMatrices);
            Shader.SetGlobalFloat("cullMatricesCount", cullMatrices.Length);
        }*/

#if UNITY_2022_1_OR_NEWER
        GL.modelview = Matrix4x4.identity;
#endif

        // Iterate over cube faces
        for(int i=0; i<6; i++)
        {
            // Render cube face

            // Render far objects
            var mrt = new RenderBuffer[2];
            mrt[0] = outData.albedo[i].colorBuffer;
            mrt[1] = outData.normal[i].colorBuffer;
            Graphics.SetRenderTarget(mrt, outData.depth[i].depthBuffer);
            GL.Clear(true, true, new Color(0,0,0, 1.0f / 255.0f)); // 0 is reserverd for projClip

            // Get view matrix for this cube face
            Matrix4x4 v;
            if (useCamera)
            {
                camTform.localEulerAngles = rot[i];
                v = tempCam.worldToCameraMatrix;
            }
            else
            {
                v = Matrix4x4.TRS(capturePoint, Quaternion.Euler(rot[i]), new Vector3(1,1,-1)).inverse;
            }
            // Compute/set viewProj
            var vp = uProj * v;
            if (Camera.current != null) vp *= Camera.current.worldToCameraMatrix.inverse;
            GL.LoadProjectionMatrix(vp);
            outData.viewProj[i] = proj * v;

            // Render near objects to depth
            Graphics.SetRenderTarget(mrt, outData.depth[i].depthBuffer);
            farSphereMatOcc.SetPass(0);
            for(int o=0; o<objCount; o++)
            {
                var m = objsToWrite[o].GetComponent<MeshFilter>().sharedMesh;
                var worldMatrix = objsToWrite[o].transform.localToWorldMatrix;
                for(int s=0; s<m.subMeshCount; s++)
                {
                    Graphics.DrawMeshNow(m, worldMatrix, s);
                }
            }

            var uvOffset = ftUVGBufferGen.uvOffset;
            float texelSize = 1.0f / cubeRes;
            var pTo = Shader.PropertyToID("texelOffset");

            if (useCamera)
            {
                // Render far objects via camera
                tempCam.SetTargetBuffers(mrt, outData.depth[i].depthBuffer);
                tempCam.Render();
            }
            else
            {
                // ... or via individual draws (SRP)
                Graphics.SetRenderTarget(mrt, outData.depth[i].depthBuffer);
                GL.sRGBWrite = true;
                GL.LoadProjectionMatrix(vp);
                for(int o=0; o<outsideRenderers.Count; o++)
                {
                    var m = outsideRenderers[o].GetComponent<MeshFilter>().sharedMesh;
                    var worldMatrix = outsideRenderers[o].transform.localToWorldMatrix;
                    var mats = outsideRenderers[o].sharedMaterials;
                    for(int s=0; s<m.subMeshCount; s++)
                    {
                        int pass = 0;
                        if (mats.Length > s && mats[s] != null)// && mats[s].HasProperty("_MainTex"))
                        {
                            var mat = mats[s];
                            Texture tex = null;

                            if (mat.HasProperty("_MainTex"))
                            {
                                tex = mat.mainTexture;
                            }
                            else if (mat.HasProperty("_BaseColorMap"))
                            {
                                // HDRP
                                tex = mat.GetTexture("_BaseColorMap");
                            }
                            else if (mat.HasProperty("_BaseMap"))
                            {
                                // URP
                                tex = mat.GetTexture("_BaseMap");
                            }

                            farSphereMat.SetTexture("_MainTex", tex);

                            pass = 0; // opaque
                            if (tex != null)
                            {
                                var matTag = mat.GetTag("RenderType", true);
                                if (matTag == "TransparentCutout" || matTag == "Transparent" || matTag == "TreeLeaf")
                                {
                                    pass = 2; // transparent cutout
                                }
                            }

                            farSphereMat.SetPass(pass);
                        }

                        for(int j=0; j<uvOffset.Length/2; j++)
                        {
                            var to = new Vector4(uvOffset[j*2] * texelSize, uvOffset[j*2+1] * texelSize, 0, 0);
                            farSphereMat.SetVector(pTo, to);
                            farSphereMat.SetPass(pass);
                            Graphics.DrawMeshNow(m, worldMatrix, s);
                        }
                    }
                }
            }

        }

        if (useCamera)
        {
            DestroyImmediate(tempCamGO);
        }

        return outData;
    }

    static bool GenerateFarSpheres(ExportSceneData data, FarSphereRenderData[] fdatas, List<Transform> capturePoints)
    {
        if (fdatas.Length == 0) return true;

        // Constants
        const int cubeRes = ftAdditionalConfig.sectorFarSphereResolution;
        const int threadWidth = 16;
        const int vertWidth = cubeRes;
        const int dispatchWidth = vertWidth / threadWidth;
        const int triCount = (vertWidth-1)*(vertWidth-1)*2;
        int dispatchIndexGroups = (int)Mathf.Ceil(triCount / (float)(threadWidth * threadWidth));

        var wnormal = new Vector3[6];
        wnormal[0] = -Vector3.right;
        wnormal[1] = Vector3.right;
        wnormal[2] = -Vector3.up;
        wnormal[3] = Vector3.up;
        wnormal[4] = -Vector3.forward;
        wnormal[5] = Vector3.forward;

        var objsToWrite = data.objsToWrite;
        var objsToWriteNames = data.objsToWriteNames;
        var objsToWriteLightmapped = data.objsToWriteLightmapped;
        var objsToWriteGroup = data.objsToWriteGroup;
        var objsToWriteHolder = data.objsToWriteHolder;
        var objsToWriteVerticesUV = data.objsToWriteVerticesUV;
        var objsToWriteVerticesUV2 = data.objsToWriteVerticesUV2;
        var objsToWriteIndices = data.objsToWriteIndices;
        var objToScaleInLm = data.objToScaleInLm;
        if (data.autoVertexGroup == null) CreateAutoVertexGroup(data, data.objsToWrite.Count > 0 ? data.objsToWrite[0] : null);
        var storages = data.storages;
        var sceneToID = data.sceneToID;

        if (farSphereSshader == null)
        {
            farSphereSshader = Shader.Find("Hidden/ftFarSphere");
            if (farSphereSshader == null)
            {
                Debug.LogError("Can't find ftFarSphere shader");
                return false;
            }
        }

        var bakeryEditorPath = ftLightmaps.GetEditorPath();

        if (farSphereCSTransform == null)
        {
            farSphereCSTransform = AssetDatabase.LoadAssetAtPath(bakeryEditorPath + "shaderSrc/ftTransformFarSphere.compute", typeof(ComputeShader)) as ComputeShader;
            if (farSphereCSTransform == null)
            {
                Debug.LogError("Can't find ftTransformFarSphere");
                return false;
            }
        }

        if (farSphereCSCull == null)
        {
            farSphereCSCull = AssetDatabase.LoadAssetAtPath(bakeryEditorPath + "shaderSrc/ftCullFarSphere.compute", typeof(ComputeShader)) as ComputeShader;
            if (farSphereCSCull == null)
            {
                Debug.LogError("Can't find ftCullFarSphere");
                return false;
            }
        }

        // Create temp buffers
        var rwBuff = new ComputeBuffer(vertWidth * vertWidth, 12); // vertices in/out
        var indBuff = new ComputeBuffer(triCount, 3*4); // indices in
        var appendBuff = new ComputeBuffer(triCount, 3*4, ComputeBufferType.Append); // indices out
        var countBuff = new ComputeBuffer(1, 4, ComputeBufferType.Raw); // out index count
        var countArray = new int[1];
        var uvBuff = new ComputeBuffer(vertWidth * vertWidth, 8); // vertex UVs

        // Create shared input index buffer
        var tris = new int[(vertWidth-1) * (vertWidth-1) * 2 * 3];
        int indCount = 0;
        for(int y=0; y<vertWidth-1; y++)
        {
            for(int x=0; x<vertWidth-1; x++)
            {
                tris[indCount]   = y*vertWidth+x;
                tris[indCount+1] = y*vertWidth+x+1;
                tris[indCount+2] = (y+1)*vertWidth+x;
                indCount += 3;
                tris[indCount]   = y*vertWidth+x+1;
                tris[indCount+1] = (y+1)*vertWidth+x+1;
                tris[indCount+2] = (y+1)*vertWidth+x;
                indCount += 3;
            }
        }

        // Create shared UVs
        var uv = new Vector2[vertWidth * vertWidth];
        float invDiv = 1.0f / (vertWidth-1);
        for(int y=0; y<vertWidth; y++)
        {
            int yoffset = y*vertWidth;
            for(int x=0; x<vertWidth; x++)
            {
                uv[yoffset+x] = new Vector2(x*invDiv, 1.0f - y*invDiv);
            }
        }

        ftLightmapsStorage sceneST = null;
        int totalTris = 0;

        var tempTex = new RenderTexture(cubeRes, cubeRes, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.sRGB);
        tempTex.Create();
        var cmd = new CommandBuffer();
        var rtiTemp = new RenderTargetIdentifier(tempTex);
        var mblock = new MaterialPropertyBlock();
        if (farSphereDilateShader == null)
        {
            farSphereDilateShader = Shader.Find("Hidden/ftFarSphereDilate");
            if (farSphereDilateShader == null)
            {
                Debug.LogError("Can't find farSphereDilate shader");
                return false;
            }
        }
        if (farSphereDilateMat == null)
        {
            farSphereDilateMat = new Material(farSphereDilateShader);
        }
        var pMainTex = Shader.PropertyToID("_MainTex");

        for(int f=0; f<fdatas.Length; f++)
        {
            var fdata = fdatas[f];
            fdata.meshes = new Mesh[6];
            fdata.textures = new Texture2D[6];
            var capturePoint = capturePoints[f].position;

            // Iterate over cube faces
            for(int i=0; i<6; i++)
            {
                // Create tex readable by the lightmapper
                var texAlbedo = new Texture2D(cubeRes, cubeRes, TextureFormat.RGBA32, false, false);
                texAlbedo.wrapMode = TextureWrapMode.Clamp;
                texAlbedo.filterMode = FilterMode.Point;
                fdata.textures[i] = texAlbedo;

                // Dilate
                mblock.SetTexture(pMainTex, fdata.albedo[i]);
                cmd.Clear();
                cmd.SetRenderTarget(rtiTemp, 0, CubemapFace.Unknown, 0);
                cmd.DrawProcedural(Matrix4x4.identity, farSphereDilateMat, 0, MeshTopology.Triangles, 6, 1, mblock);
                Graphics.ExecuteCommandBuffer(cmd);

                // Copy tex
                //Graphics.SetRenderTarget(fdata.albedo[i]);
                Graphics.SetRenderTarget(tempTex);
                texAlbedo.ReadPixels(new Rect(0,0,cubeRes,cubeRes), 0, 0, false);
                texAlbedo.Apply();
                Graphics.SetRenderTarget(null);

                // Create verts
                var verts = new Vector3[vertWidth * vertWidth];
                for(int y=0; y<vertWidth; y++)
                {
                    int yoffset = y*vertWidth;
                    float fy = -0.5f + y * invDiv;
                    for(int x=0; x<vertWidth; x++)
                    {
                        float fx = -0.5f + x * invDiv;
                        uv[yoffset+x] = new Vector2(x*invDiv, 1.0f - y*invDiv);
                        switch(i)
                        {
                            case 0:
                            verts[yoffset+x] = new Vector3(-0.5f, -fy, fx);
                            break;
                            case 1:
                            verts[yoffset+x] = new Vector3(0.5f, -fy, -fx);
                            break;
                            case 2:
                            verts[yoffset+x] = new Vector3(fx, -0.5f, -fy);
                            break;
                            case 3:
                            verts[yoffset+x] = new Vector3(fx, 0.5f, fy);
                            break;
                            case 4:
                            verts[yoffset+x] = new Vector3(fx, fy, -0.5f);
                            break;
                            case 5:
                            verts[yoffset+x] = new Vector3(-fx, fy, 0.5f);
                            break;
                        }
                    }
                }

                // Displace verts
                rwBuff.SetData(verts);
                farSphereCSTransform.SetBuffer(0, "verts", rwBuff);
                farSphereCSTransform.SetTexture(0, "_DepthTex", fdata.depth[i]);
                farSphereCSTransform.SetVector("objectCenter", capturePoint);
                farSphereCSTransform.SetInt("vertWidth", vertWidth);
                var ivp = fdata.viewProj[i].inverse;
                farSphereCSTransform.SetVector("_InvProj0", ivp.GetRow(0));
                farSphereCSTransform.SetVector("_InvProj1", ivp.GetRow(1));
                farSphereCSTransform.SetVector("_InvProj2", ivp.GetRow(2));
                farSphereCSTransform.SetVector("_InvProj3", ivp.GetRow(3));
                //farSphereCSTransform.SetVector("wnormal", wnormal[i]);
                farSphereCSTransform.Dispatch(0, dispatchWidth, dispatchWidth, 1);
                rwBuff.GetData(verts);

                // Cull tris
                indBuff.SetData(tris);
                appendBuff.SetCounterValue(0);
                uvBuff.SetData(uv);
                farSphereCSCull.SetBuffer(0, "verts", rwBuff);
                farSphereCSCull.SetBuffer(0, "uvs", uvBuff);
                farSphereCSCull.SetBuffer(0, "indices", indBuff);
                farSphereCSCull.SetBuffer(0, "newIndices", appendBuff);
                farSphereCSCull.SetInt("triCount", tris.Length/3);
                farSphereCSCull.SetTexture(0, "alphaTex", texAlbedo);
                farSphereCSCull.SetFloat("cubeSize", ftAdditionalConfig.sectorFarSphereResolution);
                farSphereCSCull.Dispatch(0, dispatchIndexGroups, 1, 1);

                // Get culled count
                ComputeBuffer.CopyCount(appendBuff, countBuff, 0);
                countBuff.GetData(countArray);

                // Get new tris
                var arr = new int[countArray[0]*3];
                appendBuff.GetData(arr);

                // Create temp material
                var mat = new Material(farSphereSshader);
                mat.mainTexture = texAlbedo;

                // Create temp object
                var faceMesh = new GameObject();
                faceMesh.name = "f_" + f + "_" + i;
                faceMesh.transform.position = capturePoint;
                temporaryGameObjects.Add(faceMesh);

                var mr = faceMesh.AddComponent<MeshRenderer>();
                var so = new SerializedObject(mr);
                var scaleInLm = so.FindProperty("m_ScaleInLightmap");
                scaleInLm.floatValue = 0;
                so.ApplyModifiedProperties();
                mr.sharedMaterial = mat;
                GameObjectUtility.SetStaticEditorFlags(faceMesh, StaticEditorFlags.LightmapStatic);

                var mf = faceMesh.AddComponent<MeshFilter>();

                var mesh = new Mesh();
                mesh.vertices = verts;
                mesh.uv = uv;
                mesh.triangles = arr;
                totalTris += arr.Length;
                mesh.RecalculateNormals();
                mf.sharedMesh = mesh;
                fdata.meshes[i] = mesh;

                objsToWrite.Add(faceMesh);
                objsToWriteNames.Add("");
                objsToWriteLightmapped.Add(false);
                objsToWriteGroup.Add(data.autoVertexGroup);
                objsToWriteHolder.Add(faceMesh);
                objsToWriteVerticesUV.Add(uv);
                objsToWriteVerticesUV2.Add(uv);
                var inds = new int[1][];
                inds[0] = arr;
                objsToWriteIndices.Add(inds);
                objToScaleInLm[faceMesh] = 0;

                if (sceneST == null) sceneST = storages[sceneToID[faceMesh.scene]];
                sceneST.implicitGroupedObjects.Add(faceMesh);
                sceneST.implicitGroups.Add(data.autoVertexGroup);
                tempStorage.implicitGroupMap[faceMesh] = data.autoVertexGroup;

                if (modifyLightmapStorage) sceneST.nonBakedRenderers.Add(mr);

                fdata.albedo[i].Release();
                fdata.depth[i].Release();
                fdata.normal[i].Release();
            }
        }

        Debug.Log("Total out-of-sector tris: " + totalTris);

        tempTex.Release();
        rwBuff.Release();
        indBuff.Release();
        appendBuff.Release();
        countBuff.Release();
        uvBuff.Release();

        return true;
    }

    static bool LoadSectorCapture(ExportSceneData data, BakerySectorCapture capture, Transform sectorTform)
    {
        if (capture.meshes == null)
        {
            Debug.LogError("No meshes in capture");
            return false;
        }
        if (capture.positions == null)
        {
            Debug.LogError("No positions in capture");
            return false;
        }
        if (capture.textures == null)
        {
            Debug.LogError("No textures in capture");
            return false;
        }

        if (farSphereSshader == null)
        {
            farSphereSshader = Shader.Find("Hidden/ftFarSphere");
            if (farSphereSshader == null)
            {
                Debug.LogError("Can't find ftFarSphere shader");
                return false;
            }
        }

        var objsToWrite = data.objsToWrite;
        var objsToWriteNames = data.objsToWriteNames;
        var objsToWriteLightmapped = data.objsToWriteLightmapped;
        var objsToWriteGroup = data.objsToWriteGroup;
        var objsToWriteHolder = data.objsToWriteHolder;
        var objsToWriteVerticesUV = data.objsToWriteVerticesUV;
        var objsToWriteVerticesUV2 = data.objsToWriteVerticesUV2;
        var objsToWriteIndices = data.objsToWriteIndices;
        var objToScaleInLm = data.objToScaleInLm;
        if (data.autoVertexGroup == null) CreateAutoVertexGroup(data, data.objsToWrite.Count > 0 ? data.objsToWrite[0] : null);
        var storages = data.storages;
        var sceneToID = data.sceneToID;

        var parent = new GameObject();
        parent.name = "fp";
        var parentTform = parent.transform;
        parentTform.position = capture.sectorPos;
        parentTform.rotation = capture.sectorRot;
        temporaryGameObjects.Add(parent);

        ftLightmapsStorage sceneST = null;

        for(int i=0; i<capture.meshes.Count; i++)
        {
            var capturePoint = capture.positions[i];

            // Create temp material
            var mat = new Material(farSphereSshader);
            mat.mainTexture = capture.textures[i];

            // Create temp object
            var faceMesh = new GameObject();
            faceMesh.name = "f_" + i;
            var faceTform = faceMesh.transform;
            faceTform.position = capturePoint;
            faceTform.parent = parentTform;
            temporaryGameObjects.Add(faceMesh);

            var mr = faceMesh.AddComponent<MeshRenderer>();
            var so = new SerializedObject(mr);
            var scaleInLm = so.FindProperty("m_ScaleInLightmap");
            scaleInLm.floatValue = 0;
            so.ApplyModifiedProperties();
            mr.sharedMaterial = mat;
            GameObjectUtility.SetStaticEditorFlags(faceMesh, StaticEditorFlags.LightmapStatic);

            var mf = faceMesh.AddComponent<MeshFilter>();
            mf.sharedMesh = capture.meshes[i];

            objsToWrite.Add(faceMesh);
            objsToWriteNames.Add("");
            objsToWriteLightmapped.Add(false);
            objsToWriteGroup.Add(data.autoVertexGroup);
            objsToWriteHolder.Add(faceMesh);

            var uv = mf.sharedMesh.uv;
            objsToWriteVerticesUV.Add(uv);
            objsToWriteVerticesUV2.Add(uv);

            var inds = new int[1][];
            inds[0] = mf.sharedMesh.triangles;
            objsToWriteIndices.Add(inds);
            objToScaleInLm[faceMesh] = 0;

            if (sceneST == null) sceneST = storages[sceneToID[faceMesh.scene]];
            sceneST.implicitGroupedObjects.Add(faceMesh);
            sceneST.implicitGroups.Add(data.autoVertexGroup);
            tempStorage.implicitGroupMap[faceMesh] = data.autoVertexGroup;

            if (modifyLightmapStorage) sceneST.nonBakedRenderers.Add(mr);
        }

        parentTform.rotation = sectorTform.rotation;
        parentTform.position = sectorTform.position;

        return true;
    }

    static void CreateAutoVertexGroup(ExportSceneData data, GameObject anyObj)
    {
        var groupList = data.groupList;
        var lmBounds = data.lmBounds;

        data.autoVertexGroup = ScriptableObject.CreateInstance<BakeryLightmapGroup>();
        data.autoVertexGroup.name = (anyObj == null ? "scene" : FilterNonASCII(anyObj.scene.name)) + "_VLM";
        data.autoVertexGroup.isImplicit = true;
        data.autoVertexGroup.resolution = 256;
        data.autoVertexGroup.bitmask = 1;
        data.autoVertexGroup.mode = BakeryLightmapGroup.ftLMGroupMode.Vertex;
        data.autoVertexGroup.id = data.lmid;
        groupList.Add(data.autoVertexGroup);
        lmBounds.Add(new Bounds(new Vector3(0,0,0), new Vector3(0,0,0)));
        data.lmid++;
    }

    static int GetLightmapTag(GameObject obj, ExportSceneData data)
    {
        var objToBakeTag = data.objToBakeTag;
        if (objToBakeTag == null) objToBakeTag = data.objToBakeTag = new Dictionary<GameObject, int>();

        int tag;
        if (objToBakeTag.TryGetValue(obj, out tag)) return tag;
        tag = -1;

        var mr = obj.GetComponent<MeshRenderer>();
        if (mr != null)
        {
            var so = new SerializedObject(mr);
            var param = so.FindProperty("m_LightmapParameters").objectReferenceValue;
            if (param != null)
            {
                var param2 = param as LightmapParameters;
                if (param2 != null)
                {
                    tag = param2.bakedLightmapTag;
                }
            }
        }
        objToBakeTag[obj] = tag;
        return tag;
    }

    static bool FilterObjects(ExportSceneData data, UnityEngine.Object[] objects)
    {
        var objToLodLevel = data.objToLodLevel;
        var storages = data.storages;
        var sceneToID = data.sceneToID;
        var objsToWrite = data.objsToWrite;
        var objsToWriteNames = data.objsToWriteNames;
        var objsToWriteLightmapped = data.objsToWriteLightmapped;
        var objsToWriteGroup = data.objsToWriteGroup;
        var objsToWriteHolder = data.objsToWriteHolder;
        var objsToWriteVerticesUV = data.objsToWriteVerticesUV;
        var objsToWriteVerticesUV2 = data.objsToWriteVerticesUV2;
        var objsToWriteIndices = data.objsToWriteIndices;
        var objToScaleInLm = data.objToScaleInLm;
        List<Renderer> outsideRenderers = null;

        outsideRenderers = data.outsideRenderers;
/*#if UNITY_2019_1_OR_NEWER
        if (GraphicsSettings.renderPipelineAsset != null)
        {
             outsideRenderers = data.outsideRenderers;
        }
#endif*/
        Transform sectorTform = null;
        if (ftRenderLightmap.fullSectorRender)
        {
            sectorTform = ftRenderLightmap.curSector.transform;
        }

        var prop = new MaterialPropertyBlock();
        foreach(GameObject obj in objects)
        {
            if (obj == null) continue;
            if (!obj.activeInHierarchy) continue;
            var path = AssetDatabase.GetAssetPath(obj);
            if (path != "") continue; // must belond to scene
            if ((obj.hideFlags & (HideFlags.DontSave|HideFlags.HideAndDontSave)) != 0) continue; // skip temp objects
            if (obj.tag == "EditorOnly") continue; // skip temp objects

            var areaLight = obj.GetComponent<BakeryLightMesh>();
            if (areaLight == null)
            {
                int areaIndex = temporaryAreaLightMeshList.IndexOf(obj);
                if (areaIndex >= 0) areaLight = temporaryAreaLightMeshList2[areaIndex];
            }

            if (areaLight != null)
            {
                if (!forceAllAreaLightsSelfshadow)
                {
                    if (!areaLight.selfShadow) continue;
                }
            }
            var mr = GetValidRenderer(obj);

            if (mr == null)
            {
                // must be MR or SMR
                continue;
            }

            var sharedMesh = GetSharedMesh(mr);
            if (sharedMesh == null) continue; // must have visible mesh

            // Remove previous lightmap
#if UNITY_2018_1_OR_NEWER
            if (mr.HasPropertyBlock())
            {
                // Reset shader props
                mr.GetPropertyBlock(prop);
                prop.SetFloat("bakeryLightmapMode", 0);
                mr.SetPropertyBlock(prop);
            }
#else
            mr.GetPropertyBlock(prop);
            if (!prop.isEmpty)
            {
                prop.SetFloat("bakeryLightmapMode", 0);
                mr.SetPropertyBlock(prop);
            }
#endif
            if (((GameObjectUtility.GetStaticEditorFlags(obj) & StaticEditorFlags.LightmapStatic) == 0) && areaLight==null)
            {
                mr.lightmapIndex = 0xFFFF;
                continue; // skip dynamic
            }

            var mrEnabled = mr.enabled || obj.GetComponent<BakeryAlwaysRender>() != null;
            if (!mrEnabled && areaLight == null) continue;

            var so = new SerializedObject(mr);//obj.GetComponent<Renderer>());
            var scaleInLm = so.FindProperty("m_ScaleInLightmap").floatValue;
#if UNITY_2019_2_OR_NEWER
            var _r = mr as MeshRenderer;
            if (pstorage.takeReceiveGIIntoAccount && _r != null && _r.receiveGI == ReceiveGI.LightProbes) scaleInLm = 0;
#endif

            if (ftRenderLightmap.fullSectorRender)
            {
                int status = IsInsideSector(obj.transform, sectorTform, mr.bounds, ftRenderLightmap.curSector);
                if (status == 0)
                {
                    if (outsideRenderers != null) outsideRenderers.Add(mr);
                    continue;
                }
                if (status == 2) scaleInLm = 0;
            }

            objToScaleInLm[obj] = scaleInLm;

            BakeryLightmapGroup group = null;
            if (scaleInLm > 0)
            {
                group = GetLMGroupFromObjectExplicit(obj, data);
                if (group != null)
                {
                    // Set LOD level for explicit group
                    int lodLevel;
                    if (!objToLodLevel.TryGetValue(obj, out lodLevel)) lodLevel = -1;

                    var packer = group.atlasPacker == BakeryLightmapGroup.AtlasPacker.Auto ? atlasPacker : (ftGlobalStorage.AtlasPacker)group.atlasPacker;

                    if (!postPacking || packer != ftGlobalStorage.AtlasPacker.xatlas)
                    {
                        if (group.sceneLodLevel == -1)
                        {
                            group.sceneLodLevel = lodLevel;
                        }
                        else
                        {
                            if (lodLevel > 0)
                            {
                                if (!ExportSceneValidationMessage("Multiple LOD levels in " + group.name + ", this is only supported when xatlas is set as the atlas packer and post-packing is enabled.")) return false;
                            }
                        }
                    }

                    if (exportTerrainAsHeightmap && !group.isImplicit && obj.name == "__ExportTerrain")
                    {
                        if (!ExportSceneValidationMessage("Terrain Optimization is enabled and terrains are inside a lightmap group. This is not currently supported. Try disabling Terrain Optimization (" + group.name + ", " + group.isImplicit + ").")) return false;
                    }

                    // Set for explicit group
                    if (splitByScene) group.sceneName = obj.scene.name;
                    if (splitByTag) group.tag = GetLightmapTag(obj, data);

                    // New explicit Pack Atlas holder selection
                    if (!group.isImplicit && group.mode == BakeryLightmapGroup.ftLMGroupMode.PackAtlas)
                    {
                        lmgroupHolder = obj; // by default pack each object
                        lmgroupHolder = TestPackAsSingleSquare(lmgroupHolder);
                        var prefabParent = PrefabUtility.GetPrefabParent(obj) as GameObject;
                        if (prefabParent != null)
                        {
                            var ptype = PrefabUtility.GetPrefabType(prefabParent);
                            if (ptype == PrefabType.ModelPrefab)
                            {
                                // but if object is a part of prefab/model
                                var sharedMesh2 = GetSharedMesh(obj);
                                var importer = AssetImporter.GetAtPath(AssetDatabase.GetAssetPath(sharedMesh2)) as ModelImporter;
                                if (importer != null && !ModelUVsOverlap(importer, gstorage))
                                {
                                    // or actually just non-overlapping model,
                                    // then pack it as a whole

                                    // find topmost asset parent
                                    var t = prefabParent.transform;
                                    while(t.parent != null) t = t.parent;
                                    var assetTopMost = t.gameObject;

                                    // find topmost scene instance parent
                                    var g = obj;
                                    while(PrefabUtility.GetPrefabParent(g) as GameObject != assetTopMost && g.transform.parent != null)
                                    {
                                        g = g.transform.parent.gameObject;
                                    }
                                    lmgroupHolder = g;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                if (data.autoVertexGroup == null) CreateAutoVertexGroup(data, obj);
                group = data.autoVertexGroup;
                lmgroupHolder = obj;

                tempStorage.implicitGroupMap[obj] = data.autoVertexGroup;

                if (modifyLightmapStorage)
                {
                    var st = storages[sceneToID[obj.scene]];
                    st.implicitGroupedObjects.Add(obj);
                    st.implicitGroups.Add(data.autoVertexGroup);
                    st.nonBakedRenderers.Add(mr);
                }
            }

            bool vertexBake = (group != null && group.mode == BakeryLightmapGroup.ftLMGroupMode.Vertex);
            // must have UVs or be arealight or vertexbaked
            var uv = sharedMesh.uv;
            var uv2 = sharedMesh.uv2;
            if (uv.Length == 0 && uv2.Length == 0 && areaLight==null && !vertexBake) continue;

            var usedUVs = uv2.Length == 0 ? uv : uv2;
            //bool validUVs = true;
            for(int v=0; v<usedUVs.Length; v++)
            {
                if (usedUVs[v].x < -0.0001f || usedUVs[v].x > 1.0001f || usedUVs[v].y < -0.0001f || usedUVs[v].y > 1.0001f)
                {
                    DebugLogWarning("Mesh " + sharedMesh.name + " on object " + obj.name + " possibly has incorrect UVs (UV2: " + (uv2.Length == 0 ? "no" : "yes")+", U: " + usedUVs[v].x + ", V: " + usedUVs[v].y + ")");
                    //validUVs = false;
                    break;
                }
            }
            //if (!validUVs) continue;

            if (vertexBake)
            {
                group.totalVertexCount = 0;
                group.vertexCounter = 0;
            }

            objsToWrite.Add(obj);
            objsToWriteNames.Add(obj.name);
            objsToWriteLightmapped.Add((scaleInLm > 0 && areaLight == null) ? true : false);
            objsToWriteGroup.Add(group);
            objsToWriteHolder.Add(lmgroupHolder);

            objsToWriteVerticesUV.Add(uv);
            objsToWriteVerticesUV2.Add(uv2);
            var inds = new int[sharedMesh.subMeshCount][];
            for(int n=0; n<inds.Length; n++) inds[n] = sharedMesh.GetTriangles(n);
            objsToWriteIndices.Add(inds);

            if (group != null) group.passedFilter = ftRenderLightmap.passedFilterFlag;
        }

        return true;
    }

    static void CalculateVertexCountForVertexGroups(ExportSceneData data)
    {
        var objsToWrite = data.objsToWrite;
        var objsToWriteGroup = data.objsToWriteGroup;

        // Calculate total vertex count for vertex-baked groups
        for(int i=0; i<objsToWrite.Count; i++)
        {
            var lmgroup = objsToWriteGroup[i];
            if (lmgroup == null || lmgroup.mode != BakeryLightmapGroup.ftLMGroupMode.Vertex) continue;
            var sharedMesh = GetSharedMesh(objsToWrite[i]);
            lmgroup.totalVertexCount += sharedMesh.vertexCount;
        }
    }

    static void CreateAutoAtlasLMGroups(ExportSceneData data, bool renderTextures, bool atlasOnly)
    {
        var objsToWrite = data.objsToWrite;
        var objsToWriteLightmapped = data.objsToWriteLightmapped;
        var objsToWriteGroup = data.objsToWriteGroup;
        var objsToWriteHolder = data.objsToWriteHolder;
        var objToLodLevel = data.objToLodLevel;
        var storages = data.storages;
        var sceneToID = data.sceneToID;
        var groupList = data.groupList;
        var lmBounds = data.lmBounds;
        var autoAtlasGroups = data.autoAtlasGroups;
        var autoAtlasGroupRootNodes = data.autoAtlasGroupRootNodes;

        // Create implicit temp LMGroups.
        // If object is a part of prefab, and if UVs are not generated in Unity, group is only addded to the topmost object (aka holder).

        // Implicit groups are added on every static object without ftLMGroupSelector.
        // (Also init lmBounds and LMID as well)
        // if autoAtlas == false: new group for every holder.
        // if autoAtlas == true: single group for all holders (will be split later).
        for(int i=0; i<objsToWrite.Count; i++)
        {
            if (!objsToWriteLightmapped[i]) continue; // skip objects with scaleInLM == 0
            if (objsToWriteGroup[i] != null) continue; // skip if already has lightmap assigned
            var obj = objsToWrite[i];

            var holder = obj; // holder is object itself (packed individually)
            holder = TestPackAsSingleSquare(holder);
            var prefabParent = PrefabUtility.GetPrefabParent(obj) as GameObject;
            if (prefabParent != null) // object is part of prefab
            {
                // unity doesn't generate non-overlapping UVs for the whole model, only submeshes
                // // if importer == null, it's an actual prefab, not model <-- not really; importer points to mesh's prefab, not real
                // importer of a mesh is always model asset
                // importers of components never exist
                // at least check the prefab type
                var ptype = PrefabUtility.GetPrefabType(prefabParent);
                if (ptype == PrefabType.ModelPrefab)
                {
                    var sharedMesh = GetSharedMesh(obj);
                    var importer = AssetImporter.GetAtPath(AssetDatabase.GetAssetPath(sharedMesh)) as ModelImporter;

                    if (importer != null && !ModelUVsOverlap(importer, gstorage))
                    {
                        // find topmost asset parent
                        var t = prefabParent.transform;
                        while(t.parent != null) t = t.parent;
                        var assetTopMost = t.gameObject;

                        // find topmost scene instance parent
                        var g = obj;
                        var assetG = PrefabUtility.GetPrefabParent(g) as GameObject;
                        while(assetG != assetTopMost && g.transform.parent != null && assetG.transform.parent != null)
                        {
                            var g2 = g.transform.parent.gameObject;
                            var assetG2 = assetG.transform.parent.gameObject;

                            if (PrefabUtility.GetPrefabParent(g2) != assetG2) break; // avoid using parents which don't belong to this model

                            g = g2;
                            assetG = assetG2;
                        }
                        var sceneTopMost = g;
                        holder = sceneTopMost; // holder is topmost model object (non-overlapped UVs)

                        int lodLevel;
                        if (objToLodLevel.TryGetValue(obj, out lodLevel)) holder = obj; // separated if used in LOD
                    }
                }
            }
            else if (obj.name == "__ExportTerrain")
            {
                holder = obj.transform.parent.gameObject; // holder is terrain parent

                int lodLevel;
                if (objToLodLevel.TryGetValue(obj, out lodLevel)) holder = obj; // separated if used in LOD
            }

            if (!storages[sceneToID[holder.scene]].implicitGroupedObjects.Contains(holder))
            {
                BakeryLightmapGroup newGroup;
                if (autoAtlas && autoAtlasGroups.Count > 0)
                {
                    newGroup = autoAtlasGroups[0];
                }
                else
                {
                    newGroup = ScriptableObject.CreateInstance<BakeryLightmapGroup>();

                    // Make sure first lightmap is always LM0, not LM1, if probes are used
                    int lmNum = storages[sceneToID[holder.scene]].implicitGroups.Count;
                    if (ftRenderLightmap.lightProbeMode == ftRenderLightmap.LightProbeMode.L1 && ftRenderLightmap.hasAnyProbes && renderTextures && !atlasOnly) lmNum--;

                    newGroup.name = FilterNonASCII(holder.scene.name) + "_LM" + autoAtlasGroups.Count;//lmNum;
                    newGroup.isImplicit = true;
                    newGroup.resolution = 256;
                    newGroup.bitmask = 1;
                    newGroup.area = 0;
                    newGroup.mode = autoAtlas ? BakeryLightmapGroup.ftLMGroupMode.PackAtlas : BakeryLightmapGroup.ftLMGroupMode.OriginalUV;

                    newGroup.id = data.lmid;
                    groupList.Add(newGroup);
                    lmBounds.Add(new Bounds(new Vector3(0,0,0), new Vector3(0,0,0)));
                    data.lmid++;

                    if (autoAtlas)
                    {
                        autoAtlasGroups.Add(newGroup);
                        var rootNode = new AtlasNode();
                        rootNode.rc = new Rect(0, 0, 1, 1);
                        autoAtlasGroupRootNodes.Add(rootNode);
                    }
                }
                storages[sceneToID[holder.scene]].implicitGroupedObjects.Add(holder);

                storages[sceneToID[holder.scene]].implicitGroups.Add(newGroup);
                //Debug.LogError("Add "+(storages[sceneToID[holder.scene]].implicitGroups.Count-1)+" "+newGroup.name);

                tempStorage.implicitGroupMap[holder] = newGroup;

                // Set for implicit group
                if (splitByScene) newGroup.sceneName = holder.scene.name;
                if (splitByTag) newGroup.tag = GetLightmapTag(holder, data);
            }

            if (!tempStorage.implicitGroupMap.ContainsKey(holder))
            {
                // happens with modifyLightmapStorage == false
                var gholders = storages[sceneToID[holder.scene]].implicitGroupedObjects;
                var grs = storages[sceneToID[holder.scene]].implicitGroups;
                for(int g=0; g<gholders.Count; g++)
                {
                    if (gholders[g] == holder)
                    {
                        tempStorage.implicitGroupMap[holder] = grs[g];
                        break;
                    }
                }
            }

            objsToWriteGroup[i] = (BakeryLightmapGroup)tempStorage.implicitGroupMap[holder];
            objsToWriteHolder[i] = holder;
        }
    }

    static void TransformVertices(ExportSceneData data, bool tangentSHLights, int onlyID = -1)
    {
        var objsToWrite = data.objsToWrite;
        var objsToWriteGroup = data.objsToWriteGroup;
        var objsToWriteVerticesPosW = data.objsToWriteVerticesPosW;
        var objsToWriteVerticesNormalW = data.objsToWriteVerticesNormalW;
        var objsToWriteVerticesTangentW = data.objsToWriteVerticesTangentW;

        int startIndex = 0;
        int endIndex = objsToWrite.Count-1;

        if (onlyID >= 0)
        {
            startIndex = onlyID;
            endIndex = onlyID;
        }

        // Transform vertices to world space
        for(int i=startIndex; i<=endIndex; i++)
        {
            var obj = objsToWrite[i];
            var lmgroup = objsToWriteGroup[i];
            bool isSkin;
            var m = GetSharedMeshSkinned(obj, out isSkin);
            var vertices = m.vertices;
            var tform = obj.transform;

            while(objsToWriteVerticesPosW.Count <= i)
            {
                objsToWriteVerticesPosW.Add(null);
                objsToWriteVerticesNormalW.Add(null);
            }

            objsToWriteVerticesPosW[i] = new Vector3[vertices.Length];
            if (isSkin)
            {
                var lossyScale = tform.lossyScale;
                var inverseWorldScale = new Vector3(1.0f/lossyScale.x, 1.0f/lossyScale.y, 1.0f/lossyScale.z);
                for(int t=0; t<vertices.Length; t++)
                {
                    vertices[t].Scale(inverseWorldScale);
                }
            }
            for(int t=0; t<vertices.Length; t++)
            {
                objsToWriteVerticesPosW[i][t] = tform.TransformPoint(vertices[t]);
            }
            var normals = m.normals;
            objsToWriteVerticesNormalW[i] = new Vector3[vertices.Length];
            var nbuff = objsToWriteVerticesNormalW[i];
            var localScale = obj.transform.localScale;
            bool flipX = localScale.x < 0;
            bool flipY = localScale.y < 0;
            bool flipZ = localScale.z < 0;
            if (lmgroup != null && lmgroup.flipNormal)
            {
                flipX = !flipX;
                flipY = !flipY;
                flipZ = !flipZ;
            }
            for(int t=0; t<vertices.Length; t++)
            {
                if (normals.Length == 0)
                {
                    nbuff[t] = Vector3.up;
                }
                else
                {
                    nbuff[t] = normals[t];
                    if (flipX) nbuff[t].x *= -1;
                    if (flipY) nbuff[t].y *= -1;
                    if (flipZ) nbuff[t].z *= -1;
                    nbuff[t] = tform.TransformDirection(nbuff[t]);
                }
            }
            if (NeedsTangents(lmgroup, tangentSHLights))
            {
                var tangents = m.tangents;
                while(objsToWriteVerticesTangentW.Count <= i) objsToWriteVerticesTangentW.Add(null);
                objsToWriteVerticesTangentW[i] = new Vector4[vertices.Length];
                var tbuff = objsToWriteVerticesTangentW[i];
                Vector3 tangent = Vector3.zero;
                for(int t=0; t<vertices.Length; t++)
                {
                    if (tangents.Length == 0)
                    {
                        tbuff[t] = Vector3.right;
                    }
                    else
                    {
                        tangent.Set(flipX ? -tangents[t].x : tangents[t].x,
                                    flipY ? -tangents[t].y : tangents[t].y,
                                    flipZ ? -tangents[t].z : tangents[t].z);
                        tangent = tform.TransformDirection(tangent);
                        tbuff[t] = new Vector4(tangent.x, tangent.y, tangent.z, tangents[t].w);
                    }
                }
            }
        }
    }

    static void CalculateUVPadding(ExportSceneData data, AdjustUVPaddingData adata)
    {
        var meshToPaddingMap = adata.meshToPaddingMap;
        var meshToObjIDs = adata.meshToObjIDs;

        float smallestMapScale = 1;
        float colorScale = 1.0f / (1 << (int)((1.0f - ftBuildGraphics.mainLightmapScale) * 6));
        float maskScale = 1.0f / (1 << (int)((1.0f - ftBuildGraphics.maskLightmapScale) * 6));
        float dirScale = 1.0f / (1 << (int)((1.0f - ftBuildGraphics.dirLightmapScale) * 6));
        smallestMapScale = Mathf.Min(colorScale, maskScale);
        smallestMapScale = Mathf.Min(smallestMapScale, dirScale);

        var objsToWrite = data.objsToWrite;
        var objsToWriteGroup = data.objsToWriteGroup;
        var objsToWriteVerticesPosW = data.objsToWriteVerticesPosW;
        var objsToWriteIndices = data.objsToWriteIndices;
        var objsToWriteHolder = data.objsToWriteHolder;

        // Calculate every implicit mesh area and convert to proper padding value
        var explicitGroupTotalArea = new Dictionary<int, float>();
        var objsWithExplicitGroupPadding = new List<int>();
        var objsWithExplicitGroupPaddingWidth = new List<float>();

        for(int i=0; i<objsToWrite.Count; i++)
        {
            var lmgroup = objsToWriteGroup[i];
            if (lmgroup == null) continue;
            if (lmgroup.mode == BakeryLightmapGroup.ftLMGroupMode.Vertex) continue; // no need to adjust for vertex-baked meshes
            var prefabParent = PrefabUtility.GetPrefabParent(objsToWrite[i]) as GameObject;
            if (prefabParent == null) continue;
            var sharedMesh = GetSharedMesh(objsToWrite[i]);
            var assetPath = AssetDatabase.GetAssetPath(sharedMesh);
            var importer = AssetImporter.GetAtPath(assetPath) as ModelImporter;
            if (importer == null || !importer.generateSecondaryUV) continue;
            // user doesn't care much about UVs - adjust

            var m = sharedMesh;
            var vpos = objsToWriteVerticesPosW[i];
            float area = 0;
            var inds = objsToWriteIndices[i];
            for(int k=0;k<m.subMeshCount;k++) {
                var indices = inds[k];// m.GetTriangles(k);
                int indexA, indexB, indexC;
                for(int j=0;j<indices.Length;j+=3)
                {
                    indexA = indices[j];
                    indexB = indices[j + 1];
                    indexC = indices[j + 2];

                    var v1 = vpos[indexA];
                    var v2 = vpos[indexB];
                    var v3 = vpos[indexC];
                    area += Vector3.Cross(v2 - v1, v3 - v1).magnitude;
                }
            }
            //var so = new SerializedObject(objsToWrite[i].GetComponent<Renderer>());
            //var scaleInLm = so.FindProperty("m_ScaleInLightmap").floatValue;
            var scaleInLm = data.objToScaleInLm[objsToWrite[i]];
            if (scaleInLm == 0) continue; // don't reunwrap objects with scale in lightmap == 0

            area *= scaleInLm;

            float width = Mathf.Sqrt(area);
            float twidth = 1;
            if (lmgroup.isImplicit)
            {
                twidth = width * texelsPerUnit;
            }
            else
            {
                float currentArea;
                if (!explicitGroupTotalArea.TryGetValue(lmgroup.id, out currentArea)) currentArea = 0;
                explicitGroupTotalArea[lmgroup.id] = currentArea + area;

                var holder = objsToWriteHolder[i];
                BakeryLightmapGroupSelector comp = null;
                if (holder != null) comp = holder.GetComponent<BakeryLightmapGroupSelector>();
                if (comp != null && comp.instanceResolutionOverride && comp.active)
                {
                    // Explicit holder size
                    twidth = width * comp.instanceResolution;
                }
                else
                {
                    // Texel size in atlas - can't calculate at this point
                    objsWithExplicitGroupPadding.Add(i);
                    objsWithExplicitGroupPaddingWidth.Add(width);
                    continue;
                }
            }
            float requiredPadding = 4 * (1024.0f / (twidth * smallestMapScale));
            int requiredPaddingClamped = (int)Mathf.Clamp(requiredPadding, 1, 256);

            int existingPadding = 0;
            meshToPaddingMap.TryGetValue(m, out existingPadding);
            meshToPaddingMap[m] = Math.Max(requiredPaddingClamped, existingPadding); // select largest padding among instances

            List<int> arr;
            if (!meshToObjIDs.TryGetValue(m, out arr))
            {
                meshToObjIDs[m] = arr = new List<int>();
            }
            if (!arr.Contains(i)) arr.Add(i);
        }

        for(int j=0; j<objsWithExplicitGroupPadding.Count; j++)
        {
            int i = objsWithExplicitGroupPadding[j];
            float width = objsWithExplicitGroupPaddingWidth[j];
            var lmgroup = objsToWriteGroup[i];
            float totalArea = explicitGroupTotalArea[lmgroup.id];
            float twidth = (width / Mathf.Sqrt(totalArea)) * lmgroup.resolution;
            var m = GetSharedMesh(objsToWrite[i]);

            // Following is copy-pasted from the loop above
            float requiredPadding = 4 * (1024.0f / (twidth * smallestMapScale));
            int requiredPaddingClamped = (int)Mathf.Clamp(requiredPadding, 1, 256);

            int existingPadding = 0;
            meshToPaddingMap.TryGetValue(m, out existingPadding);
            meshToPaddingMap[m] = Math.Max(requiredPaddingClamped, existingPadding); // select largest padding among instances

            List<int> arr;
            if (!meshToObjIDs.TryGetValue(m, out arr))
            {
                meshToObjIDs[m] = arr = new List<int>();
            }
            if (!arr.Contains(i)) arr.Add(i);
        }
    }

    static void ResetPaddingStorageData(ExportSceneData data)
    {
        var storages = data.storages;

        // Reset scene padding backup
        for(int s=0; s<storages.Length; s++)
        {
            var str = storages[s];
            if (str == null) continue;
            str.modifiedAssetPathList = new List<string>();
            str.modifiedAssets = new List<ftGlobalStorage.AdjustedMesh>();
        }
    }

    static void StoreNewUVPadding(ExportSceneData data, AdjustUVPaddingData adata)
    {
        var meshToPaddingMap = adata.meshToPaddingMap;
        var meshToObjIDs = adata.meshToObjIDs;
        var dirtyAssetList = adata.dirtyAssetList;
        var dirtyObjList = adata.dirtyObjList;
        var storages = data.storages;

        foreach(var pair in meshToPaddingMap)
        {
            var m = pair.Key;
            var requiredPaddingClamped = pair.Value;
            var assetPath = AssetDatabase.GetAssetPath(m);

            var ids = meshToObjIDs[m];

            //for(int s=0; s<sceneCount; s++)
            {
                var objStorage = gstorage;// == null ? storages[0] : gstorage;// storages[s];
                int mstoreIndex = objStorage.modifiedAssetPathList.IndexOf(assetPath);
                int ind = -1;
                var mname = m.name;
                if (mstoreIndex >= 0) ind = objStorage.modifiedAssets[mstoreIndex].meshName.IndexOf(mname);
                if (ind < 0)
                {
                    if (mstoreIndex < 0)
                    {
                        // add new record to globalstorage
                        objStorage.modifiedAssetPathList.Add(assetPath);
                        var newStruct = new ftGlobalStorage.AdjustedMesh();
                        newStruct.meshName = new List<string>();
                        newStruct.padding = new List<int>();
                        objStorage.modifiedAssets.Add(newStruct);
                        mstoreIndex = objStorage.modifiedAssets.Count - 1;
                    }

                    var nameList = objStorage.modifiedAssets[mstoreIndex].meshName;
                    var paddingList = objStorage.modifiedAssets[mstoreIndex].padding;
                    var unwrapperList = objStorage.modifiedAssets[mstoreIndex].unwrapper;
                    if (unwrapperList == null)
                    {
                        var s = objStorage.modifiedAssets[mstoreIndex];
                        unwrapperList = s.unwrapper = new List<int>();
                        objStorage.modifiedAssets[mstoreIndex] = s;
                    }
                    while(nameList.Count > unwrapperList.Count) unwrapperList.Add(0); // fix legacy

                    nameList.Add(mname);
                    paddingList.Add(requiredPaddingClamped);
                    unwrapperList.Add((int)ftRenderLightmap.unwrapper);

                    if (!dirtyAssetList.Contains(assetPath)) dirtyAssetList.Add(assetPath);
                    for(int xx=0; xx<ids.Count; xx++) dirtyObjList.Add(ids[xx]);
#if UNITY_2017_1_OR_NEWER
                    objStorage.SyncModifiedAsset(mstoreIndex);
#endif
                }
                else
                {
                    var nameList = objStorage.modifiedAssets[mstoreIndex].meshName;
                    var paddingList = objStorage.modifiedAssets[mstoreIndex].padding;
                    var unwrapperList = objStorage.modifiedAssets[mstoreIndex].unwrapper;
                    if (unwrapperList == null)
                    {
                        var s = objStorage.modifiedAssets[mstoreIndex];
                        unwrapperList = s.unwrapper = new List<int>();
                        objStorage.modifiedAssets[mstoreIndex] = s;
                    }
                    while(nameList.Count > unwrapperList.Count) unwrapperList.Add(0); // fix legacy

                    // modify existing record
                    var oldValue = paddingList[ind];
                    var oldUnwrapperValue = (ftGlobalStorage.Unwrapper)unwrapperList[ind];
                    bool shouldModify = oldValue != requiredPaddingClamped;
                    if (uvPaddingMax)
                    {
                        shouldModify = oldValue < requiredPaddingClamped;
                    }
                    if (oldUnwrapperValue != ftRenderLightmap.unwrapper) shouldModify = true;
                    if (shouldModify)
                    {
                        if (!dirtyAssetList.Contains(assetPath)) dirtyAssetList.Add(assetPath);
                        for(int xx=0; xx<ids.Count; xx++) dirtyObjList.Add(ids[xx]);
                        paddingList[ind] = requiredPaddingClamped;
                        unwrapperList[ind] = (int)ftRenderLightmap.unwrapper;
#if UNITY_2017_1_OR_NEWER
                        objStorage.SyncModifiedAsset(mstoreIndex);
#endif
                    }
                }

                // Backup padding storage to scene
                for(int s=0; s<storages.Length; s++)
                {
                    var str = storages[s];
                    if (str == null) continue;
                    var localIndex = str.modifiedAssetPathList.IndexOf(assetPath);
                    if (localIndex < 0)
                    {
                        str.modifiedAssetPathList.Add(assetPath);
                        str.modifiedAssets.Add(objStorage.modifiedAssets[mstoreIndex]);
                    }
                    else
                    {
                        str.modifiedAssets[localIndex] = objStorage.modifiedAssets[mstoreIndex];
                    }
                }
            }
        }

        EditorUtility.SetDirty(gstorage);
    }

    static bool ValidatePaddingImmutability(AdjustUVPaddingData adata)
    {
        if (validateLightmapStorageImmutability)
        {
            if (adata.dirtyAssetList.Count > 0)
            {
                sceneNeedsToBeRebuilt = true;
                return false;
            }
        }
        return true;
    }

    static bool ValidateScaleOffsetImmutability(ExportSceneData data)
    {
        if (validateLightmapStorageImmutability)
        {
            var holderRect = data.holderRect;
            var objsToWrite = data.objsToWrite;
            var objsToWriteGroup = data.objsToWriteGroup;
            var objsToWriteHolder = data.objsToWriteHolder;
            var storages = data.storages;
            var sceneToID = data.sceneToID;

            var emptyVec4 = new Vector4(1,1,0,0);
            Rect rc = new Rect();
            for(int i=0; i<objsToWrite.Count; i++)
            {
                var obj = objsToWrite[i];
                var lmgroup = objsToWriteGroup[i];
                var holderObj = objsToWriteHolder[i];
                if (holderObj != null)
                {
                    if (!holderRect.TryGetValue(holderObj, out rc))
                    {
                        holderObj = null;
                    }
                }
                var scaleOffset = holderObj == null ? emptyVec4 : new Vector4(rc.width, rc.height, rc.x, rc.y);

                var sceneID = sceneToID[obj.scene];
                var st = storages[sceneID];
                if (st == null)
                {
                    Debug.LogError("ValidateScaleOffsetImmutability: no storage");
                    return false;
                }

                var storedScaleOffset = Vector4.zero;
                if (obj.name == "__ExportTerrain")
                {
#if USE_TERRAINS
                    var tindex = terrainObjectList.IndexOf(obj.transform.parent.gameObject);
                    var terrain = terrainObjectToActual[tindex];
                    int index = st.bakedRenderersTerrain.IndexOf(terrain);
                    /*if (st.bakedIDsTerrain[index] != lmgroup.id)
                    {
                        Debug.LogError("ValidateScaleOffsetImmutability: terrain LMID does not match");
                        return false;
                    }*/
                    if (index < 0 || st.bakedScaleOffsetTerrain.Count <= index) continue;
                    storedScaleOffset = st.bakedScaleOffsetTerrain[index];
#endif
                }
                else
                {
                    int index = st.bakedRenderers.IndexOf(GetValidRenderer(obj));
                    /*if (st.bakedIDs[index] != lmgroup.id)
                    {
                        Debug.LogError("ValidateScaleOffsetImmutability: LMID does not match");
                        Debug.LogError(st.bakedIDs[index]+" "+lmgroup.id+" "+lmgroup.name);
                        return false;
                    }*/
                    if (index < 0 || st.bakedScaleOffset.Count <= index) continue;
                    storedScaleOffset = st.bakedScaleOffset[index];
                }
                // approx equality
                if (!(scaleOffset == storedScaleOffset))
                {
                    Debug.LogError("ValidateScaleOffsetImmutability: scale/offset does not match on " + obj.name);
                    Debug.Log("(" + scaleOffset.x + ", " + scaleOffset.y + "," + scaleOffset.z + ", " + scaleOffset.w + ") vs (" +
                                    storedScaleOffset.x + ", " + storedScaleOffset.y + "," + storedScaleOffset.z + ", " + storedScaleOffset.w + ")"
                        );
                    return false;
                }
            }
        }
        return true;
    }

    static bool ClearUVPadding(ExportSceneData data, AdjustUVPaddingData adata)
    {
        var objsToWrite = data.objsToWrite;
        var dirtyAssetList = adata.dirtyAssetList;
        var dirtyObjList = adata.dirtyObjList;

        for(int i=0; i<objsToWrite.Count; i++)
        {
            var sharedMesh = GetSharedMesh(objsToWrite[i]);
            var assetPath = AssetDatabase.GetAssetPath(sharedMesh);

            int mstoreIndex = gstorage.modifiedAssetPathList.IndexOf(assetPath);
            if (mstoreIndex < 0) continue;

            dirtyObjList.Add(i);
            if (!dirtyAssetList.Contains(assetPath))
            {
                dirtyAssetList.Add(assetPath);
            }
        }

        if (!ValidatePaddingImmutability(adata)) return false;

        for(int i=0; i<dirtyAssetList.Count; i++)
        {
            var assetPath = dirtyAssetList[i];
            int mstoreIndex = gstorage.modifiedAssetPathList.IndexOf(assetPath);
            DebugLogInfo("Reimport " + assetPath);
            ProgressBarShow("Exporting scene - clearing UV adjustment for " + assetPath + "...", 0, false);

            gstorage.ClearAssetModifications(mstoreIndex);
        }

        EditorUtility.SetDirty(gstorage);

        return true;
    }

    static bool ReimportModifiedAssets(AdjustUVPaddingData adata)
    {
        var dirtyAssetList = adata.dirtyAssetList;

        for(int i=0; i<dirtyAssetList.Count; i++)
        {
            var assetPath = dirtyAssetList[i];
            DebugLogInfo("Reimport " + assetPath);
            ProgressBarShow("Exporting scene - adjusting UV padding for " + assetPath + "...", 0, false);
            //AssetDatabase.ImportAsset(assetPath);
            (AssetImporter.GetAtPath(assetPath) as ModelImporter).SaveAndReimport();

            if (CheckUnwrapError())
            {
                return false;
            }
        }
        return true;
    }

    static void TransformModifiedAssets(ExportSceneData data, AdjustUVPaddingData adata, bool tangentSHLights)
    {
        // Transform modified vertices to world space again
        for(int d=0; d<adata.dirtyObjList.Count; d++)
        {
            int i = adata.dirtyObjList[d];

            // Refresh attributes and indices after reimport
            bool isSkin;
            var m = GetSharedMeshSkinned(data.objsToWrite[i], out isSkin);
            data.objsToWriteVerticesUV[i] = m.uv;
            data.objsToWriteVerticesUV2[i] = m.uv2;
            var inds = new int[m.subMeshCount][];
            for(int n=0; n<inds.Length; n++) inds[n] = m.GetTriangles(n);
            data.objsToWriteIndices[i] = inds;

            TransformVertices(data, tangentSHLights, i); // because vertex count/order could be modified
        }
    }

    static void CalculateHolderUVBounds(ExportSceneData data)
    {
        var objsToWrite = data.objsToWrite;
        var objsToWriteGroup = data.objsToWriteGroup;
        var objsToWriteHolder = data.objsToWriteHolder;
        var objsToWriteVerticesPosW = data.objsToWriteVerticesPosW;
        var objsToWriteVerticesUV = data.objsToWriteVerticesUV;
        var objsToWriteVerticesUV2 = data.objsToWriteVerticesUV2;
        var objsToWriteIndices = data.objsToWriteIndices;
        var objToLodLevel = data.objToLodLevel;
        var holderObjUVBounds = data.holderObjUVBounds;
        var holderObjArea = data.holderObjArea;
        var groupToHolderObjects = data.groupToHolderObjects;

        // Calculate implicit group / atlas packing data
        // UV bounds and worldspace area
        for(int i=0; i<objsToWrite.Count; i++)
        {
            var obj = objsToWrite[i];
            var lmgroup = objsToWriteGroup[i];
            var calculateArea = lmgroup == null ? false : (lmgroup.isImplicit || lmgroup.mode == BakeryLightmapGroup.ftLMGroupMode.PackAtlas || lmgroup.autoResolution);
            if (!calculateArea) continue;

            var holderObj = objsToWriteHolder[i];
            var m = GetSharedMesh(obj);
            //var mr = obj.GetComponent<Renderer>();

            var vpos = objsToWriteVerticesPosW[i];
            var vuv = objsToWriteVerticesUV2[i];//m.uv2;
            var inds = objsToWriteIndices[i];
            //if (vuv.Length == 0 || obj.GetComponent<BakeryLightMesh>()!=null) vuv = objsToWriteVerticesUV[i];//m.uv; // area lights or objects without UV2 export UV1 instead
            if (vuv.Length == 0 || obj.GetComponent<BakeryLightMesh>()!=null || temporaryAreaLightMeshList.Contains(obj)) vuv = objsToWriteVerticesUV[i];//m.uv; // area lights or objects without UV2 export UV1 instead
            Vector2 uv1 = Vector2.zero;
            Vector2 uv2 = Vector2.zero;
            Vector2 uv3 = Vector2.zero;

            int lodLevel;
            if (!objToLodLevel.TryGetValue(obj, out lodLevel)) lodLevel = -1;

            for(int k=0;k<m.subMeshCount;k++) {

                var indices = inds[k];//m.GetTriangles(k);
                int indexA, indexB, indexC;
                float area = 0;
                //float areaUV = 0;
                Vector4 uvBounds = new Vector4(1,1,0,0); // minx, miny, maxx, maxy

                for(int j=0;j<indices.Length;j+=3)
                {
                    indexA = indices[j];
                    indexB = indices[j + 1];
                    indexC = indices[j + 2];

                    var v1 = vpos[indexA];
                    var v2 = vpos[indexB];
                    var v3 = vpos[indexC];
                    area += Vector3.Cross(v2 - v1, v3 - v1).magnitude;

                    if (vuv.Length > 0)
                    {
                        uv1 = vuv[indexA];
                        uv2 = vuv[indexB];
                        uv3 = vuv[indexC];
                    }

                    /*var uv31 = new Vector3(uv1.x, uv1.y, 0);
                    var uv32 = new Vector3(uv2.x, uv2.y, 0);
                    var uv33 = new Vector3(uv3.x, uv3.y, 0);
                    areaUV += Vector3.Cross(uv32 - uv31, uv33 - uv31).magnitude;*/

                    if (uv1.x < uvBounds.x) uvBounds.x = uv1.x;
                    if (uv1.y < uvBounds.y) uvBounds.y = uv1.y;
                    if (uv1.x > uvBounds.z) uvBounds.z = uv1.x;
                    if (uv1.y > uvBounds.w) uvBounds.w = uv1.y;

                    if (uv2.x < uvBounds.x) uvBounds.x = uv2.x;
                    if (uv2.y < uvBounds.y) uvBounds.y = uv2.y;
                    if (uv2.x > uvBounds.z) uvBounds.z = uv2.x;
                    if (uv2.y > uvBounds.w) uvBounds.w = uv2.y;

                    if (uv3.x < uvBounds.x) uvBounds.x = uv3.x;
                    if (uv3.y < uvBounds.y) uvBounds.y = uv3.y;
                    if (uv3.x > uvBounds.z) uvBounds.z = uv3.x;
                    if (uv3.y > uvBounds.w) uvBounds.w = uv3.y;
                }

                // uv layouts always have empty spaces
                //area /= areaUV;

                var scaleInLm = data.objToScaleInLm[obj];

                if (!pstorage.alternativeScaleInLightmap) area *= scaleInLm;

                if ((lmgroup.isImplicit || lmgroup.autoResolution) && lodLevel == -1)
                {
                    lmgroup.area += area; // accumulate LMGroup area
                    // only use base scene values, no LODs, to properly initialize autoatlas size
                }
                if (lmgroup.mode == BakeryLightmapGroup.ftLMGroupMode.PackAtlas)
                {
                    // Accumulate per-holder area and UV bounds
                    float existingArea;
                    Vector4 existingBounds;
                    holderObjUVBounds.TryGetValue(holderObj, out existingBounds);
                    if (!holderObjArea.TryGetValue(holderObj, out existingArea))
                    {
                        existingArea = 0;
                        existingBounds = uvBounds;
                        List<GameObject> holderList;
                        if (!groupToHolderObjects.TryGetValue(lmgroup, out holderList))
                        {
                            groupToHolderObjects[lmgroup] = holderList = new List<GameObject>();
                        }
                        holderList.Add(holderObj);
                    }
                    holderObjArea[holderObj] = existingArea + area;

                    existingBounds.x = existingBounds.x < uvBounds.x ? existingBounds.x : uvBounds.x;
                    existingBounds.y = existingBounds.y < uvBounds.y ? existingBounds.y : uvBounds.y;
                    existingBounds.z = existingBounds.z > uvBounds.z ? existingBounds.z : uvBounds.z;
                    existingBounds.w = existingBounds.w > uvBounds.w ? existingBounds.w : uvBounds.w;
                    holderObjUVBounds[holderObj] = existingBounds;
                }
            }
        }
    }

    static int ResolutionFromArea(float area)
    {
        int resolution = (int)(Mathf.Sqrt(area) * texelsPerUnit);
        if (mustBePOT)
        {
            if (atlasCountPriority)
            {
                resolution = Mathf.NextPowerOfTwo(resolution);
            }
            else
            {
                resolution = Mathf.ClosestPowerOfTwo(resolution);
            }
        }
        resolution = Math.Max(resolution, minAutoResolution);
        resolution = Math.Min(resolution, maxAutoResolution);

        return resolution;
    }

    static void CalculateAutoAtlasInitResolution(ExportSceneData data)
    {
        var groupList = data.groupList;

        // Calculate implicit lightmap resolution
        for(int i=0; i<groupList.Count; i++)
        {
            var lmgroup = groupList[i];
            if (lmgroup.isImplicit || lmgroup.autoResolution)
            {
                lmgroup.resolution = ResolutionFromArea(lmgroup.area);
            }
        }
    }

    static void NormalizeHolderArea(BakeryLightmapGroup lmgroup, List<GameObject> holderObjs, ExportSceneData data)
    {
        var holderObjArea = data.holderObjArea;
        var holderObjUVBounds = data.holderObjUVBounds;

        // Divide holders area to get from world space to -> UV space
        float areaMult = 1.0f;
        if (lmgroup.isImplicit && lmgroup.mode == BakeryLightmapGroup.ftLMGroupMode.PackAtlas)
        {
            // ...by maximum lightmap area given texel size (autoAtlas)
            //areaMult = 1.0f / lightmapMaxArea;
            // don't modify
        }
        else
        {
            // ... by maximum holder area (normalize)
            float lmgroupArea = 0;
            for(int i=0; i<holderObjs.Count; i++)
            {
                // space outside of UV bounds shouldn't affect area
                var uvbounds = holderObjUVBounds[holderObjs[i]];
                var width = uvbounds.z - uvbounds.x;
                var height = uvbounds.w - uvbounds.y;
                float uvboundsArea = width * height;

                lmgroupArea += holderObjArea[holderObjs[i]] * uvboundsArea;
            }
            areaMult = 1.0f / lmgroupArea;
        }

        // Perform the division and sum up total UV area
        for(int i=0; i<holderObjs.Count; i++)
        {
            holderObjArea[holderObjs[i]] *= areaMult;
        }
    }

    static void SumHolderAreaPerLODLevel(List<GameObject> holderObjs, ExportSceneData data, PackData pdata)
    {
        var objToLodLevel = data.objToLodLevel;
        var holderObjArea = data.holderObjArea;
        var remainingAreaPerLodLevel = pdata.remainingAreaPerLodLevel;

        for(int i=0; i<holderObjs.Count; i++)
        {
            int lodLevel = -1;
            if (!objToLodLevel.TryGetValue(holderObjs[i], out lodLevel)) lodLevel = -1;

            float lodArea = 0;
            if (!remainingAreaPerLodLevel.TryGetValue(lodLevel, out lodArea)) lodArea = 0;

            remainingAreaPerLodLevel[lodLevel] = lodArea + holderObjArea[holderObjs[i]];
        }
    }

    static int CompareGameObjectsForPacking(GameObject a, GameObject b)
    {
        if (splitByScene)
        {
            if (a.scene.name != b.scene.name) return a.scene.name.CompareTo(b.scene.name);
        }

        if (splitByTag)
        {
            int tagA = GetLightmapTag(a, _tempData);
            int tagB = GetLightmapTag(b, _tempData);
            if (tagA != tagB) return tagA.CompareTo(tagB);
        }

        /*if (ftRenderLightmap.giLodMode != ftRenderLightmap.GILODMode.ForceOff && exportTerrainAsHeightmap)
        {
            bool ba = a.name != "__ExportTerrainParent";
            bool bb = b.name != "__ExportTerrainParent";
            if (ba != bb) return ba.CompareTo(bb);
        }*/

        int lodLevelA = -1;
        int lodLevelB = -1;
        if (!cmp_objToLodLevel.TryGetValue(a, out lodLevelA)) lodLevelA = -1;
        if (!cmp_objToLodLevel.TryGetValue(b, out lodLevelB)) lodLevelB = -1;

        if (lodLevelA != lodLevelB) return lodLevelA.CompareTo(lodLevelB);

        float areaA = cmp_holderObjArea[a];
        float areaB = cmp_holderObjArea[b];

        // Workaround for "override resolution"
        // Always pack such rectangles first
        var comp = a.GetComponent<BakeryLightmapGroupSelector>();
        if (comp != null && comp.instanceResolutionOverride && comp.active) areaA = comp.instanceResolution * 10000;

        comp = b.GetComponent<BakeryLightmapGroupSelector>();
        if (comp != null && comp.instanceResolutionOverride && comp.active) areaB = comp.instanceResolution * 10000;

        int comparisonResult = areaB.CompareTo(areaA);
        if (comparisonResult == 0)
        {
            // We need to sort identical-area objects consistently, so their order doesn't change between bakes
            comparisonResult = b.name.CompareTo(a.name);
            if (comparisonResult == 0)
            {
                var apos = a.transform.position;
                var bpos = b.transform.position;
                comparisonResult = bpos.x.CompareTo(apos.x);
                if (comparisonResult == 0)
                {
                    comparisonResult = bpos.y.CompareTo(apos.y);
                    if (comparisonResult == 0)
                    {
                        comparisonResult = bpos.z.CompareTo(apos.z);
                    }
                }
            }
        }
        return comparisonResult;
    }

    static void ApplyAreaToUVBounds(float area, Vector4 uvbounds, out float width, out float height)
    {
        if (pstorage.alternativeScaleInLightmap) area *= 2;
        width = height = Mathf.Sqrt(area);
        if (pstorage.alternativeScaleInLightmap) width = height = Mathf.Max(1.0f, Mathf.Floor(height * 0.5f));
        float uwidth = uvbounds.z - uvbounds.x;
        float uheight = uvbounds.w - uvbounds.y;
        if (uwidth == 0 && uheight == 0)
        {
            width = height = 0;
        }
        else
        {
            float uvratio = uheight / uwidth;
            if (uvratio <= 1.0f)
            {
                width /= uvratio;
                //height *= uvratio;
            }
            else
            {
                height *= uvratio;
                //width /= uvratio;
            }
        }
    }

    static bool Pack(BakeryLightmapGroup lmgroup, List<GameObject> holderObjs, ExportSceneData data, PackData pdata)
    {
        var holderObjArea = data.holderObjArea;
        var holderObjUVBounds = data.holderObjUVBounds;
        var holderRect = data.holderRect;
        var objToLodLevel = data.objToLodLevel;
        var groupList = data.groupList;
        var lmBounds = data.lmBounds;
        var autoAtlasGroups = data.autoAtlasGroups;
        var autoAtlasGroupRootNodes = data.autoAtlasGroupRootNodes;

        var remainingAreaPerLodLevel = pdata.remainingAreaPerLodLevel;

        int atlasPaddingPixels = pstorage.texelPaddingForDefaultAtlasPacker;

        //Debug.LogError("repack: "+repackScale);
        pdata.repack = false;

        AtlasNode rootNode;

        if (lmgroup.isImplicit && lmgroup.mode == BakeryLightmapGroup.ftLMGroupMode.PackAtlas && autoAtlasGroupRootNodes != null && autoAtlasGroupRootNodes.Count > 0)
        {
            rootNode = autoAtlasGroupRootNodes[0];
        }
        else
        {
            rootNode = new AtlasNode();
        }

        rootNode.rc = new Rect(0, 0, 1, 1);
        for(int i=0; i<holderObjs.Count; i++)
        {
            var area = holderObjArea[holderObjs[i]];
            var uvbounds = holderObjUVBounds[holderObjs[i]];

            // Calculate width and height of each holder in atlas UV space
            float width, height;
            var comp = holderObjs[i].GetComponent<BakeryLightmapGroupSelector>();
            if (comp != null && comp.instanceResolutionOverride && comp.active)
            {
                // Explicit holder size
                pdata.hasResOverrides = true;
                width = height = comp.instanceResolution / (float)lmgroup.resolution;
            }
            else
            {
                // Automatic: width and height = sqrt(area) transformed by UV AABB aspect ratio
                ApplyAreaToUVBounds(area, uvbounds, out width, out height);

                if (pstorage.alternativeScaleInLightmap)
                {
                    var mr = GetValidRenderer(holderObjs[i]);
                    if (mr != null)
                    {
                        var so = new SerializedObject(mr);
                        var scaleInLm = so.FindProperty("m_ScaleInLightmap").floatValue;
#if UNITY_2019_2_OR_NEWER
                        var _r = mr as MeshRenderer;
                        if (pstorage.takeReceiveGIIntoAccount && _r != null && _r.receiveGI == ReceiveGI.LightProbes) scaleInLm = 0;
#endif
                        width *= scaleInLm;
                        height *= scaleInLm;
                    }
                }
            }

            // Clamp to full lightmap size
            float twidth = width;
            float theight = height;
            if (lmgroup.isImplicit && lmgroup.mode == BakeryLightmapGroup.ftLMGroupMode.PackAtlas)
            {
                twidth = (width * texelsPerUnit) / lmgroup.resolution;
                theight = (height * texelsPerUnit) / lmgroup.resolution;

                //if (i==0) Debug.LogError(texelsPerUnit+" "+twidth);
            }
            //float unclampedTwidth = twidth;
            //float unclampedTheight = twidth;
            if (comp != null && comp.instanceResolutionOverride)
            {
            }
            else
            {
                twidth *= pdata.repackScale;
                theight *= pdata.repackScale;
            }
            twidth = twidth > 1 ? 1 : twidth;
            theight = theight > 1 ? 1 : theight;
            twidth = Mathf.Max(twidth, 1.0f / lmgroup.resolution);
            theight = Mathf.Max(theight, 1.0f / lmgroup.resolution);
            var rect = new Rect(0, 0, twidth, theight);

            if (float.IsNaN(twidth) || float.IsNaN(theight))
            {
                ExportSceneError("NaN UVs detected for " + holderObjs[i].name+" "+rect.width+" "+rect.height+" "+width+" "+height+" "+lmgroup.resolution+" "+area+" "+(uvbounds.z - uvbounds.x)+" "+(uvbounds.w - uvbounds.y));
                return false;
            }

            // Try inserting this rect
            // Break autoatlas if lod level changes
            // Optionally break autoatlas if scene changes
            AtlasNode node = null;
            int lodLevel;
            if (!objToLodLevel.TryGetValue(holderObjs[i], out lodLevel)) lodLevel = -1;
            bool splitAtlas = false;
            if (splitByScene)
            {
                if (holderObjs[i].scene.name != lmgroup.sceneName)
                {
                    splitAtlas = true;
                }
            }
            if (splitByTag)
            {
                if (GetLightmapTag(holderObjs[i], data) != lmgroup.tag)
                {
                    splitAtlas = true;
                }
            }
            /*if (ftRenderLightmap.giLodMode != ftRenderLightmap.GILODMode.ForceOff && exportTerrainAsHeightmap)
            {
                bool ba = holderObjs[i].name == "__ExportTerrainParent";
                if (ba) lmgroup.containsTerrains = true;

                if (i > 0)
                {
                    bool bb = holderObjs[i-1].name == "__ExportTerrainParent";
                    if (ba != bb)
                    {
                        splitAtlas = true;
                    }
                }
            }*/
            if (!splitAtlas)
            {
                if (lmgroup.isImplicit && lmgroup.mode == BakeryLightmapGroup.ftLMGroupMode.PackAtlas)
                {
                    if (lodLevel == lmgroup.sceneLodLevel)
                    {
                        node = rootNode.Insert(holderObjs[i], rect);
                    }
                }
                else
                {
                    node = rootNode.Insert(holderObjs[i], rect);
                }
            }

            /*if (node!=null)
            {
                Debug.Log(holderObjs[i].name+" goes straight into "+lmgroup.name);
            }*/

            if (node == null)
            {
                if (lmgroup.isImplicit && lmgroup.mode == BakeryLightmapGroup.ftLMGroupMode.PackAtlas)
                {
                    // Can't fit - try other autoAtlas lightmaps
                    BakeryLightmapGroup newGroup = null;
                    var holder = holderObjs[i];
                    int goodGroup = -1;
                    for(int g=1; g<autoAtlasGroups.Count; g++)
                    {
                        if (splitByScene)
                        {
                            if (autoAtlasGroups[g].sceneName != holderObjs[i].scene.name) continue;
                        }
                        if (splitByTag)
                        {
                            if (autoAtlasGroups[g].tag != GetLightmapTag(holderObjs[i], data)) continue;
                        }
                        /*if (ftRenderLightmap.giLodMode != ftRenderLightmap.GILODMode.ForceOff && exportTerrainAsHeightmap)
                        {
                            bool ba = holderObjs[i].name != "__ExportTerrainParent";
                            bool bb = !autoAtlasGroups[g].containsTerrains;
                            if (ba != bb) continue;
                        }*/
                        if (autoAtlasGroups[g].sceneLodLevel != lodLevel) continue;
                        twidth = (width * texelsPerUnit) / autoAtlasGroups[g].resolution;
                        theight = (height * texelsPerUnit) / autoAtlasGroups[g].resolution;
                        //unclampedTwidth = twidth;
                        //unclampedTheight = twidth;
                        twidth = twidth > 1 ? 1 : twidth;
                        theight = theight > 1 ? 1 : theight;
                        rect = new Rect(0, 0, twidth, theight);

                        node = autoAtlasGroupRootNodes[g].Insert(holder, rect);
                        if (node != null)
                        {
                            //Debug.Log(holder.name+" fits into "+autoAtlasGroups[g].name);
                            newGroup = autoAtlasGroups[g];
                            goodGroup = g;
                            break;
                        }
                    }

                    // Can't fit - create new lightmap (autoAtlas)
                    if (goodGroup < 0)
                    {
                        newGroup = ScriptableObject.CreateInstance<BakeryLightmapGroup>();
                        newGroup.name = FilterNonASCII(holder.scene.name) + "_LMA" + autoAtlasGroups.Count;
                        newGroup.isImplicit = true;
                        newGroup.sceneLodLevel = lodLevel;
                        if (splitByScene) newGroup.sceneName = holderObjs[i].scene.name;
                        if (splitByTag) newGroup.tag = GetLightmapTag(holderObjs[i], data);
                        //Debug.Log(holder.name+" creates "+newGroup.name);

                        /*if (ftRenderLightmap.giLodMode != ftRenderLightmap.GILODMode.ForceOff && exportTerrainAsHeightmap)
                        {
                            newGroup.containsTerrains = holderObjs[i].name == "__ExportTerrainParent";
                        }*/

                        newGroup.resolution = (int)(Mathf.Sqrt(remainingAreaPerLodLevel[lodLevel]) * texelsPerUnit);
                        if (mustBePOT)
                        {
                            if (atlasCountPriority)
                            {
                                newGroup.resolution = Mathf.NextPowerOfTwo(newGroup.resolution);
                            }
                            else
                            {
                                newGroup.resolution = Mathf.ClosestPowerOfTwo(newGroup.resolution);
                            }
                        }
                        newGroup.resolution = Math.Max(newGroup.resolution, minAutoResolution);
                        newGroup.resolution = Math.Min(newGroup.resolution, maxAutoResolution);

                        newGroup.bitmask = 1;
                        newGroup.area = 0;
                        newGroup.mode = BakeryLightmapGroup.ftLMGroupMode.PackAtlas;

                        newGroup.id = data.lmid;
                        groupList.Add(newGroup);
                        lmBounds.Add(new Bounds(new Vector3(0,0,0), new Vector3(0,0,0)));
                        data.lmid++;

                        autoAtlasGroups.Add(newGroup);
                        var rootNode2 = new AtlasNode();
                        rootNode2.rc = new Rect(0, 0, 1, 1);
                        autoAtlasGroupRootNodes.Add(rootNode2);

                        twidth = (width * texelsPerUnit) / newGroup.resolution;
                        theight = (height * texelsPerUnit) / newGroup.resolution;
                        //unclampedTwidth = twidth;
                        //unclampedTheight = twidth;
                        twidth = twidth > 1 ? 1 : twidth;
                        theight = theight > 1 ? 1 : theight;

                        rect = new Rect(0, 0, twidth, theight);

                        node = rootNode2.Insert(holder, rect);
                    }

                    // Modify implicit group storage
                    MoveObjectToImplicitGroup(holder, newGroup, data);
                    /*
                    var scn = holder.scene;
                    tempStorage.implicitGroupMap[holder] = newGroup;
                    for(int k=0; k<storages[sceneToID[holder.scene]].implicitGroupedObjects.Count; k++)
                    {
                        if (storages[sceneToID[holder.scene]].implicitGroupedObjects[k] == holder)
                        {
                            storages[sceneToID[holder.scene]].implicitGroups[k] = newGroup;
                            //Debug.LogError("Implicit set: " + k+" "+newGroup.name+" "+holder.name);
                        }
                    }
                    */
                    //lmgroup = newGroup;
                }
                else
                {
                    if (!pdata.repackStage2)
                    {
                        // explicit packed atlas - can't fit - try shrinking the whole atlas
                        pdata.repackTries++;
                        if (pdata.repackTries < atlasMaxTries)
                        {
                            pdata.repack = true;
                            pdata.repackScale *= 0.75f;
                            //Debug.LogError("Can't fit, set " +repackScale);
                            break;
                        }
                    }
                    else
                    {
                        // explicit packed atlas - did fit, now trying to scale up, doesn't work - found optimal fit
                        pdata.repack = true;
                        pdata.repackScale /= atlasScaleUpValue;//*= 0.75f;
                        //Debug.LogError("Final, set " +repackScale);
                        pdata.finalRepack = true;
                        pdata.repackTries = 0;
                        break;
                    }
                }
            }

            if (node == null)
            {
                // No way to fit
                ExportSceneError("Can't fit " + holderObjs[i].name+" "+rect.width+" "+rect.height);
                return false;
            }
            else
            {
                // Generate final rectangle to transform local UV -> atlas UV
                float padding = ((float)atlasPaddingPixels) / lmgroup.resolution;

                var paddedRc = new Rect(node.rc.x + padding,
                                        node.rc.y + padding,
                                        node.rc.width - padding * 2,
                                        node.rc.height - padding * 2);

                paddedRc.x -= uvbounds.x * (paddedRc.width / (uvbounds.z - uvbounds.x));
                paddedRc.y -= uvbounds.y * (paddedRc.height / (uvbounds.w - uvbounds.y));
                paddedRc.width /= uvbounds.z - uvbounds.x;
                paddedRc.height /= uvbounds.w - uvbounds.y;

                holderRect[holderObjs[i]] = paddedRc;
            }

            //float areaReduction = (twidth*theight) / (unclampedTwidth*unclampedTheight);
            remainingAreaPerLodLevel[lodLevel] -= area;// * areaReduction;
        }

        if (!lmgroup.isImplicit && lmgroup.mode == BakeryLightmapGroup.ftLMGroupMode.PackAtlas)
        {
            if (pdata.finalRepack && pdata.repack)
            {
                pdata.continueRepack = true;
                return true;
            }
            if (pdata.finalRepack)
            {
                pdata.continueRepack = false;
                return true;
            }

            if (!pdata.repack && !pdata.repackStage2)
            {
                //if (repackTries > 0) break; // shrinked down just now - don't scale up

                pdata.repackStage2 = true; // scale up now
                pdata.repack = true;
                pdata.repackScale *= atlasScaleUpValue;///= 0.75f;
                pdata.repackTries = 0;
                //Debug.LogError("Scale up, set " +repackScale);
            }
            else if (pdata.repackStage2)
            {
                pdata.repackTries++;
                if (pdata.repackTries == atlasMaxTries)
                {
                    pdata.continueRepack = false;
                    return true;
                }
                pdata.repack = true;
                pdata.repackScale *= atlasScaleUpValue;///= 0.75f;
                //Debug.LogError("Scale up cont, set " +repackScale);
            }
        }
        return true;
    }

    static void MoveObjectToImplicitGroup(GameObject holder, BakeryLightmapGroup newGroup, ExportSceneData data)
    {
        var storages = data.storages;
        var sceneToID = data.sceneToID;

        // Modify implicit group storage
        var scn = holder.scene;
        tempStorage.implicitGroupMap[holder] = newGroup;
        for(int k=0; k<storages[sceneToID[holder.scene]].implicitGroupedObjects.Count; k++)
        {
            if (storages[sceneToID[holder.scene]].implicitGroupedObjects[k] == holder)
            {
                storages[sceneToID[holder.scene]].implicitGroups[k] = newGroup;
                //Debug.LogError("Implicit set: " + k+" "+newGroup.name+" "+holder.name);
            }
        }
    }

    static List<int> GetAtlasBucketRanges(List<GameObject> holderObjs, ExportSceneData data, bool onlyUserSplits)
    {
        var objToLodLevel = data.objToLodLevel;

        var ranges = new List<int>();
        int start = 0;
        int end = 0;
        if (holderObjs.Count > 0)
        {
            var sceneName = holderObjs[0].scene.name;
            int tag = -1;
            if (splitByTag) tag = GetLightmapTag(holderObjs[0], data);
            int lodLevel;
            if (!objToLodLevel.TryGetValue(holderObjs[0], out lodLevel)) lodLevel = -1;
            //bool isTerrain = holderObjs[0].name == "__ExportTerrainParent";

            for(int i=0; i<holderObjs.Count; i++)
            {
                bool splitAtlas = false;

                // Split by scene
                if (splitByScene)
                {
                    var objSceneName = holderObjs[i].scene.name;
                    if (objSceneName != sceneName)
                    {
                        splitAtlas = true;
                        sceneName = objSceneName;
                    }
                }

                if (splitByTag)
                {
                    var objTag = GetLightmapTag(holderObjs[i], data);
                    if (objTag != tag)
                    {
                        splitAtlas = true;
                        tag = objTag;
                    }
                }

                if (!onlyUserSplits)
                {
                    // Split by LOD
                    int objLodLevel;
                    if (!objToLodLevel.TryGetValue(holderObjs[i], out objLodLevel)) objLodLevel = -1;
                    if (objLodLevel != lodLevel)
                    {
                        //bool objNonOr0 = objLodLevel <= 0;
                        //bool lodNonOr0 = lodLevel <= 0;
                        //bool validToCombine = objNonOr0 && lodNonOr0;
                        //if (!validToCombine) // didn't work; LOD0 never showed up in lmlods, thus never loaded as shadowcast for non-LOD
                        {
                            lodLevel = objLodLevel;
                            splitAtlas = true;
                        }
                    }

                    // Split by terrain
                    /*if (ftRenderLightmap.giLodMode != ftRenderLightmap.GILODMode.ForceOff && exportTerrainAsHeightmap)
                    {
                        bool ba = holderObjs[i].name == "__ExportTerrainParent";
                        if (ba != isTerrain)
                        {
                            isTerrain = ba;
                            splitAtlas = true;
                        }
                    }*/
                }

                if (splitAtlas)
                {
                    end = i;
                    ranges.Add(start);
                    ranges.Add(end-1);
                    start = end;
                }
            }
        }
        end = holderObjs.Count-1;
        ranges.Add(start);
        ranges.Add(end);
        return ranges;
    }

    static float SumObjectsArea(List<GameObject> holderObjs, int start, int end, ExportSceneData data)
    {
        var holderObjArea = data.holderObjArea;

        float area = 0;
        for(int i=start; i<=end; i++)
        {
            float a = holderObjArea[holderObjs[i]];
            var mr = holderObjs[i].GetComponent<Renderer>();
            if (mr != null)
            {
                var so = new SerializedObject(mr);
                var scaleInLm = so.FindProperty("m_ScaleInLightmap").floatValue;
#if UNITY_2019_2_OR_NEWER
                var _r = mr as MeshRenderer;
                if (pstorage.takeReceiveGIIntoAccount && _r != null && _r.receiveGI == ReceiveGI.LightProbes) scaleInLm = 0;
#endif
                if (pstorage.alternativeScaleInLightmap)
                {
                    a *= scaleInLm * scaleInLm;
                }
                else
                {
                    a *= scaleInLm;
                }
            }
            area += a;
        }
        return area;
    }

    static BakeryLightmapGroup AllocateAutoAtlas(int count, BakeryLightmapGroup lmgroup, ExportSceneData data, int[] atlasSizes = null)
    {
        var lmBounds = data.lmBounds;
        var groupList = data.groupList;
        var autoAtlasGroups = data.autoAtlasGroups;
        var autoAtlasGroupRootNodes = data.autoAtlasGroupRootNodes;

        BakeryLightmapGroup newGroup = null;

        for(int i=0; i<count; i++)
        {
            // Create additional lightmaps
            newGroup = ScriptableObject.CreateInstance<BakeryLightmapGroup>();
            newGroup.name = lmgroup.sceneName + "_LMA" + autoAtlasGroups.Count;
            newGroup.isImplicit = true;
            newGroup.sceneLodLevel = lmgroup.sceneLodLevel;
            if (splitByScene) newGroup.sceneName = lmgroup.sceneName;
            if (splitByTag) newGroup.tag = lmgroup.tag;
            newGroup.containsTerrains = lmgroup.containsTerrains;

            newGroup.resolution = atlasSizes != null ? atlasSizes[i] : lmgroup.resolution;

            newGroup.bitmask = lmgroup.bitmask;
            newGroup.area = 0;
            newGroup.mode = lmgroup.mode;// BakeryLightmapGroup.ftLMGroupMode.PackAtlas;

            newGroup.renderMode = lmgroup.renderMode;
            newGroup.renderDirMode = lmgroup.renderDirMode;
            newGroup.atlasPacker = lmgroup.atlasPacker;
            newGroup.computeSSS = lmgroup.computeSSS;
            newGroup.sssSamples = lmgroup.sssSamples;
            newGroup.sssDensity = lmgroup.sssDensity;
            newGroup.sssColor = lmgroup.sssColor * lmgroup.sssScale;
            newGroup.fakeShadowBias = lmgroup.fakeShadowBias;
            newGroup.transparentSelfShadow = lmgroup.transparentSelfShadow;
            newGroup.flipNormal = lmgroup.flipNormal;

            newGroup.id = data.lmid;
            groupList.Add(newGroup);
            lmBounds.Add(new Bounds(new Vector3(0,0,0), new Vector3(0,0,0)));
            data.lmid++;

            autoAtlasGroups.Add(newGroup);
            var rootNode2 = new AtlasNode();
            rootNode2.rc = new Rect(0, 0, 1, 1);
            autoAtlasGroupRootNodes.Add(rootNode2);
        }

        return newGroup;
    }

    static bool PackWithXatlas(BakeryLightmapGroup lmgroup, List<GameObject> holderObjs, ExportSceneData data, PackData pdata)
    {
        var holderObjArea = data.holderObjArea;
        var holderObjUVBounds = data.holderObjUVBounds;
        var holderRect = data.holderRect;
        var autoAtlasGroups = data.autoAtlasGroups;
        var objToLodLevel = data.objToLodLevel;
        var objsToWriteHolder = data.objsToWriteHolder;
        var objsToWrite = data.objsToWrite;

        bool warned = false;

        // Split objects into "buckets" by scene, terrains, LODs, etc
        // Objects are already pre-sorted, so we need only ranges
        int bStart = 0;
        int bEnd = holderObjs.Count-1;
        int bucketCount = 2;
        List<int> buckets = null;
        if (lmgroup.isImplicit)
        {
            buckets = GetAtlasBucketRanges(holderObjs, data, postPacking);
            bucketCount = buckets.Count;
        }

        var holderAutoIndex = new int[holderObjs.Count];

        bool fillHoles = holeFilling;
        if (lmgroup.holeFilling != BakeryLightmapGroup.HoleFilling.Auto) fillHoles = lmgroup.holeFilling == BakeryLightmapGroup.HoleFilling.Yes;

        for(int bucket=0; bucket<bucketCount; bucket+=2)
        {
            if (lmgroup.isImplicit)
            {
                bStart = buckets[bucket];
                bEnd = buckets[bucket+1];
            }
            int bSize = bEnd - bStart;
            if (bucket > 0)
            {
                // Start new bucket
                lmgroup = AllocateAutoAtlas(1, lmgroup, data);
            }
            int firstAutoAtlasIndex = autoAtlasGroups.Count - 1;
            if (autoAtlasGroups.Count > 0 && autoAtlasGroups[0] == lmgroup)
            {
                // new bucket always uses the original LMGroup
                // if the original LMGroup is implicit, it'll be moved to firstAutoAtlasIndex
                // but in case of the actual autoAtlas, the original LMGroup should use atlas index 0
                firstAutoAtlasIndex = 0;
            }

            if (lmgroup.isImplicit)
            {
                float bucketArea = SumObjectsArea(holderObjs, bStart, bEnd, data);
                lmgroup.resolution = ResolutionFromArea(bucketArea);
            }

            // Fill some LMGroup data
            lmgroup.sceneName = holderObjs[bStart].scene.name;
            if (splitByTag)
            {
                lmgroup.tag = GetLightmapTag(holderObjs[bStart], data);
            }
            int lodLevel;
            if (!objToLodLevel.TryGetValue(holderObjs[bStart], out lodLevel)) lodLevel = -1;
            lmgroup.sceneLodLevel = lodLevel;
            /*if (ftRenderLightmap.giLodMode != ftRenderLightmap.GILODMode.ForceOff && exportTerrainAsHeightmap)
            {
                lmgroup.containsTerrains = holderObjs[bStart].name == "__ExportTerrainParent";
            }*/

            var atlas = xatlas.xatlasCreateAtlas();

            const int attempts = 4096;
            int padding = pstorage.texelPaddingForXatlasAtlasPacker;
            const bool allowRotate = false;
            float packTexelsPerUnit = lmgroup.isImplicit ? 1.0f : 0.0f; // multiple atlaseses vs single atlas
            int packResolution = lmgroup.resolution;
            int maxChartSize = 0;//packResolution;
            bool bruteForce = true; // high quality

            int vertCount = 4;
            int indexCount = 6;
            Vector2[] uv = null;
            int[] indices = null;
            if (!fillHoles)
            {
                uv = new Vector2[4];
                indices = new int[6];
                indices[0] = 0;
                indices[1] = 1;
                indices[2] = 2;
                indices[3] = 2;
                indices[4] = 3;
                indices[5] = 0;
            }
            var uvBuffer = new Vector2[4];
            var xrefBuffer = new int[4];
            var indexBuffer = new int[6];

            for(int i=bStart; i<=bEnd; i++)
            {
                if (!warned)
                {
                    var comp = holderObjs[i].GetComponent<BakeryLightmapGroupSelector>();
                    if (comp != null && comp.instanceResolutionOverride && comp.active)
                    {
                        if (!ExportSceneValidationMessage("When using xatlas as atlas packer, 'Override resolution' option is not supported for LMGroups.\nOption is used on: " + holderObjs[i].name))
                        {
                            xatlas.xatlasClear(atlas);
                            return false;
                        }
                        warned = true;
                    }
                }

                var area = holderObjArea[holderObjs[i]];
                var uvbounds = holderObjUVBounds[holderObjs[i]];

                // Automatic: width and height = sqrt(area) transformed by UV AABB aspect ratio
                float width, height;
                ApplyAreaToUVBounds(area, uvbounds, out width, out height);

                if (pstorage.alternativeScaleInLightmap)
                {
                    var mr = holderObjs[i].GetComponent<Renderer>();
                    if (mr != null)
                    {
                        var so = new SerializedObject(mr);
                        var scaleInLm = so.FindProperty("m_ScaleInLightmap").floatValue;
#if UNITY_2019_2_OR_NEWER
                        var _r = mr as MeshRenderer;
                        if (pstorage.takeReceiveGIIntoAccount && _r != null && _r.receiveGI == ReceiveGI.LightProbes) scaleInLm = 0;
#endif
                        width *= scaleInLm;
                        height *= scaleInLm;
                    }
                }

                // Clamp to full lightmap size
                float twidth = width;
                float theight = height;
                if (lmgroup.isImplicit && lmgroup.mode == BakeryLightmapGroup.ftLMGroupMode.PackAtlas)
                {
                    twidth = (width * texelsPerUnit);// / lmgroup.resolution;
                    theight = (height * texelsPerUnit);// / lmgroup.resolution;
                }

                if (!fillHoles)
                {
                    uv[0] = new Vector2(0,0);
                    uv[1] = new Vector2(twidth,0);
                    uv[2] = new Vector2(twidth,theight);
                    uv[3] = new Vector2(0,theight);
                }
                else
                {
                    List<int> indexList = null;
                    List<Vector2> uvList = null;
                    vertCount = indexCount = 0;
                    int numMeshes = 0;
                    var ubounds = holderObjUVBounds[holderObjs[i]];
                    var holder = holderObjs[i];
                    for(int o=0; o<objsToWriteHolder.Count; o++)
                    {
                        if (objsToWriteHolder[o] != holder) continue;

                        if (numMeshes == 1)
                        {
                            indexList = new List<int>();
                            uvList = new List<Vector2>();
                            for(int j=0; j<indices.Length; j++)
                            {
                                indexList.Add(indices[j]);
                            }
                            for(int j=0; j<uv.Length; j++)
                            {
                                uvList.Add(uv[j]);
                            }
                        }

                        bool isSkin;
                        var mesh = GetSharedMeshSkinned(objsToWrite[o], out isSkin);
                        indices = mesh.triangles;
                        var uv1 = mesh.uv;
                        var uv2 = mesh.uv2;
                        if (uv2 == null || uv2.Length == 0)
                        {
                            uv = uv1;
                        }
                        else
                        {
                            uv = uv2;
                        }
                        for(int t=0; t<uv.Length; t++)
                        {
                            float u = (uv[t].x - ubounds.x) / (ubounds.z - ubounds.x);
                            float v = (uv[t].y - ubounds.y) / (ubounds.w - ubounds.y);
                            u *= twidth;
                            v *= theight;
                            uv[t] = new Vector2(u, v);
                        }

                        if (numMeshes > 0)
                        {
                            for(int j=0; j<indices.Length; j++)
                            {
                                indexList.Add(indices[j] + vertCount);
                            }
                            for(int j=0; j<uv.Length; j++)
                            {
                                uvList.Add(uv[j]);
                            }
                        }

                        vertCount += uv.Length;
                        indexCount += indices.Length;
                        numMeshes++;
                    }
                    if (numMeshes > 1)
                    {
                        uv = uvList.ToArray();
                        indices = indexList.ToArray();
                    }
                }

                var handleUV = GCHandle.Alloc(uv, GCHandleType.Pinned);
                int err = 0;

                try
                {
                    var pointerUV = handleUV.AddrOfPinnedObject();

                    err = xatlas.xatlasAddUVMesh(atlas, vertCount, pointerUV, indexCount, indices, allowRotate);
                }
                finally
                {
                    if (handleUV.IsAllocated) handleUV.Free();
                }

                if (err == 1)
                {
                    Debug.LogError("xatlas::AddMesh: indices are out of range");
                    xatlas.xatlasClear(atlas);
                    return false;
                }
                else if (err == 2)
                {
                    Debug.LogError("xatlas::AddMesh: index count is incorrect");
                    xatlas.xatlasClear(atlas);
                    return false;
                }
                else if (err != 0)
                {
                    Debug.LogError("xatlas::AddMesh: unknown error");
                    xatlas.xatlasClear(atlas);
                    return false;
                }
            }

            //xatlas.xatlasParametrize(atlas);
            xatlas.xatlasPack(atlas, attempts, packTexelsPerUnit, packResolution, maxChartSize, padding, bruteForce, pstorage.alignToTextureBlocksWithXatlas);//, allowRotate);

            int atlasCount = xatlas.xatlasGetAtlasCount(atlas);
            var atlasSizes = new int[atlasCount];

            xatlas.xatlasNormalize(atlas, atlasSizes, pstorage.alternativeScaleInLightmap);

            // Create additional lightmaps
            AllocateAutoAtlas(atlasCount-1, lmgroup, data, atlasSizes);

            // Move objects into new atlases
            if (lmgroup.isImplicit)
            {
                for(int i=0; i<=bSize; i++)
                {
                    int atlasIndex = xatlas.xatlasGetAtlasIndex(atlas, i, 0);

                    // Modify implicit group storage
                    var holder = holderObjs[bStart + i];
                    var newGroup = autoAtlasGroups[firstAutoAtlasIndex + atlasIndex];
                    MoveObjectToImplicitGroup(holderObjs[bStart + i], newGroup, data);
                    holderAutoIndex[bStart + i] = firstAutoAtlasIndex + atlasIndex;
                }
            }

            for(int i=0; i<=bSize; i++)
            {
                // Get data from xatlas
                int newVertCount = xatlas.xatlasGetVertexCount(atlas, i);
                uvBuffer = new Vector2[newVertCount];
                xrefBuffer = new int[newVertCount];

                int newIndexCount = xatlas.xatlasGetIndexCount(atlas, i);
                indexBuffer = new int[newIndexCount];

                if (fillHoles)
                {
                   uvBuffer = new Vector2[newVertCount];
                   xrefBuffer = new int[newVertCount];
                   indexBuffer = new int[newIndexCount];
                }

                var handleT = GCHandle.Alloc(uvBuffer, GCHandleType.Pinned);
                var handleX = GCHandle.Alloc(xrefBuffer, GCHandleType.Pinned);
                var handleI = GCHandle.Alloc(indexBuffer, GCHandleType.Pinned);
                try
                {
                    var pointerT = handleT.AddrOfPinnedObject();
                    var pointerX = handleX.AddrOfPinnedObject();
                    var pointerI = handleI.AddrOfPinnedObject();
                    xatlas.xatlasGetData(atlas, i, pointerT, pointerX, pointerI);
                }
                finally
                {
                    if (handleT.IsAllocated) handleT.Free();
                    if (handleX.IsAllocated) handleX.Free();
                    if (handleI.IsAllocated) handleI.Free();
                }

                float minU = float.MaxValue;
                float minV = float.MaxValue;
                float maxU = -float.MaxValue;
                float maxV = -float.MaxValue;
                for(int j=0; j<newVertCount; j++)
                {
                    if (uvBuffer[j].x < minU) minU = uvBuffer[j].x;
                    if (uvBuffer[j].y < minV) minV = uvBuffer[j].y;
                    if (uvBuffer[j].x > maxU) maxU = uvBuffer[j].x;
                    if (uvBuffer[j].y > maxV) maxV = uvBuffer[j].y;
                }

                // Generate final rectangle to transform local UV -> atlas UV
                float upadding = 0;
                var uvbounds = holderObjUVBounds[holderObjs[bStart + i]];
                var paddedRc = new Rect(minU + upadding,
                                        minV + upadding,
                                        (maxU-minU) - upadding * 2,
                                        (maxV-minV) - upadding * 2);

                paddedRc.x -= uvbounds.x * (paddedRc.width / (uvbounds.z - uvbounds.x));
                paddedRc.y -= uvbounds.y * (paddedRc.height / (uvbounds.w - uvbounds.y));
                paddedRc.width /= uvbounds.z - uvbounds.x;
                paddedRc.height /= uvbounds.w - uvbounds.y;

                holderRect[holderObjs[bStart + i]] = paddedRc;
            }

            xatlas.xatlasClear(atlas);
        }

        if (postPacking)
        {
            buckets = GetAtlasBucketRanges(holderObjs, data, false);
            bucketCount = buckets.Count;

            DebugLogInfo("Bucket count for " + lmgroup.name +": " + (bucketCount/2));

            if (lmgroup.isImplicit)
            {
                // Post-packing for auto-atlased groups
                var autoLMBuckets = new List<int>[autoAtlasGroups.Count];
                for(int bucket=0; bucket<bucketCount; bucket+=2)
                {
                    bStart = buckets[bucket];
                    bEnd = buckets[bucket+1];
                    for(int i=bStart; i<=bEnd; i++)
                    {
                        int autoLM = holderAutoIndex[i];
                        if (autoLMBuckets[autoLM] == null) autoLMBuckets[autoLM] = new List<int>();
                        if (!autoLMBuckets[autoLM].Contains(bucket)) autoLMBuckets[autoLM].Add(bucket);
                    }
                }
                int origGroupCount = autoAtlasGroups.Count;
                for(int i=0; i<origGroupCount; i++)
                {
                    if (autoLMBuckets[i] != null && autoLMBuckets[i].Count > 1)
                    {
                        // Split
                        for(int j=1; j<autoLMBuckets[i].Count; j++)
                        {
                            autoAtlasGroups[i].sceneName = holderObjs[bStart].scene.name;

                            var newGroup = AllocateAutoAtlas(1, autoAtlasGroups[i], data);
                            int bucket = autoLMBuckets[i][j];
                            bStart = buckets[bucket];
                            bEnd = buckets[bucket+1];

                            // Update LMGroup data
                            //newGroup.sceneName = holderObjs[bStart].scene.name;
                            int lodLevel;
                            if (!objToLodLevel.TryGetValue(holderObjs[bStart], out lodLevel)) lodLevel = -1;
                            newGroup.sceneLodLevel = lodLevel;
                            /*if (ftRenderLightmap.giLodMode != ftRenderLightmap.GILODMode.ForceOff && exportTerrainAsHeightmap)
                            {
                                newGroup.containsTerrains = holderObjs[bStart].name == "__ExportTerrainParent";
                            }*/
                            newGroup.parentName = autoAtlasGroups[i].name;
                            autoAtlasGroups[i].parentName = "|";
                            //Debug.LogError(autoAtlasGroups[i].name+" (" +autoAtlasGroups[i].id+") -> "+newGroup.name + " (" + newGroup.id+", "+newGroup.parentID+")");

                            for(int k=bStart; k<=bEnd; k++)
                            {
                                int autoLM = holderAutoIndex[k];
                                if (autoLM == i)
                                {
                                    MoveObjectToImplicitGroup(holderObjs[k], newGroup, data);
                                    holderAutoIndex[k] = -1; // mark as moved
                                }
                            }
                        }
                    }
                }
                for(int i=0; i<origGroupCount; i++)
                {
                    if (autoLMBuckets[i] != null)
                    {
                        for(int j=0; j<holderObjs.Count; j++)
                        {
                            if (holderAutoIndex[j] != i) continue;

                            // Update LMGroup data
                            var newGroup = autoAtlasGroups[i];
                            newGroup.sceneName = holderObjs[j].scene.name;
                            int lodLevel;
                            if (!objToLodLevel.TryGetValue(holderObjs[j], out lodLevel)) lodLevel = -1;
                            newGroup.sceneLodLevel = lodLevel;
                            /*if (ftRenderLightmap.giLodMode != ftRenderLightmap.GILODMode.ForceOff && exportTerrainAsHeightmap)
                            {
                                newGroup.containsTerrains = holderObjs[j].name == "__ExportTerrainParent";
                            }*/

                            break;
                        }
                    }
                }
            }
            else if (bucketCount > 0)
            {
                // Post-packing for explicit groups
                // Single LMGroup -> LMGroup*buckets

                // Setup first bucket
                bStart = buckets[0];
                bEnd = buckets[1];
                int lodLevel;
                if (!objToLodLevel.TryGetValue(holderObjs[bStart], out lodLevel)) lodLevel = -1;
                lmgroup.sceneLodLevel = lodLevel;
                /*if (ftRenderLightmap.giLodMode != ftRenderLightmap.GILODMode.ForceOff && exportTerrainAsHeightmap)
                {
                    lmgroup.containsTerrains = holderObjs[bStart].name == "__ExportTerrainParent";
                }*/
                //Debug.LogError(lmgroup.name+": "+ lmgroup.sceneLodLevel+" because of " + holderObjs[bStart].name);

                // Skip first bucket
                for(int bucket=2; bucket<bucketCount; bucket+=2)
                {
                    bStart = buckets[bucket];
                    bEnd = buckets[bucket+1];

                    var newGroup = AllocateAutoAtlas(1, lmgroup, data);

                    if (!objToLodLevel.TryGetValue(holderObjs[bStart], out lodLevel)) lodLevel = -1;
                    newGroup.sceneLodLevel = lodLevel;
                    /*if (ftRenderLightmap.giLodMode != ftRenderLightmap.GILODMode.ForceOff && exportTerrainAsHeightmap)
                    {
                        newGroup.containsTerrains = holderObjs[bStart].name == "__ExportTerrainParent";
                    }*/
                    newGroup.mode = lmgroup.mode;
                    newGroup.parentName = lmgroup.name;
                    lmgroup.parentName = "|";

                    //Debug.LogError(newGroup.name+": "+ newGroup.sceneLodLevel+" because of " + holderObjs[bStart].name);

                    for(int k=bStart; k<=bEnd; k++)
                    {
                        //MoveObjectToImplicitGroup(holderObjs[k], newGroup, data);
                        data.storages[data.sceneToID[holderObjs[k].scene]].implicitGroupedObjects.Add(holderObjs[k]);
                        data.storages[data.sceneToID[holderObjs[k].scene]].implicitGroups.Add(newGroup);
                        tempStorage.implicitGroupMap[holderObjs[k]] = newGroup;
                    }
                }
            }
        }

        return true;
    }

    static void NormalizeAtlas(BakeryLightmapGroup lmgroup, List<GameObject> holderObjs, ExportSceneData data, PackData pdata)
    {
        var holderRect = data.holderRect;

        if (!lmgroup.isImplicit && lmgroup.mode == BakeryLightmapGroup.ftLMGroupMode.PackAtlas && !pdata.hasResOverrides)
        {
            float maxx = 0;
            float maxy = 0;
            for(int i=0; i<holderObjs.Count; i++)
            {
                var rect = holderRect[holderObjs[i]];
                if ((rect.x + rect.width) > maxx) maxx = rect.x + rect.width;
                if ((rect.y + rect.height) > maxy) maxy = rect.y + rect.height;
            }
            float maxDimension = maxx > maxy ? maxx : maxy;
            float normalizeScale = 1.0f / maxDimension;
            for(int i=0; i<holderObjs.Count; i++)
            {
                var rect = holderRect[holderObjs[i]];
                holderRect[holderObjs[i]] = new Rect(rect.x * normalizeScale, rect.y * normalizeScale, rect.width * normalizeScale, rect.height * normalizeScale);
            }
        }
    }

    static bool PackAtlases(ExportSceneData data)
    {
        // IN, OUT lmgroup.containsTerrains, OUT holderObjs (sort)
        var groupToHolderObjects = data.groupToHolderObjects;

        // IN
        var objToLodLevel = data.objToLodLevel; // LODs packed to separate atlases
        cmp_objToLodLevel = objToLodLevel;

        // IN/OUT
        var holderObjArea = data.holderObjArea; // performs normalization
        cmp_holderObjArea = holderObjArea;

        // Pack atlases
        // Try to scale all objects to occupy all atlas space
        for(int pass=0; pass<2; pass++)
        {
            foreach(var pair in groupToHolderObjects)
            {
                // For every LMGroup with PackAtlas mode
                var lmgroup = pair.Key;
                if (pass == 0 && !lmgroup.isImplicit) continue; // implicit groups get packed first
                if (pass == 1 && lmgroup.isImplicit) continue;
                var holderObjs = pair.Value; // get all objects

                var pdata = new PackData();

                // Normalize by worldspace area and uv area
                // Read/write holderObjArea
                NormalizeHolderArea(lmgroup, holderObjs, data);

                // Sort objects by area and scene LOD level
                // + optionally by scene
                // + split by terrain
                _tempData = data;
                holderObjs.Sort(CompareGameObjectsForPacking);
                _tempData = null;

                var packer = lmgroup.atlasPacker == BakeryLightmapGroup.AtlasPacker.Auto ? atlasPacker : (ftGlobalStorage.AtlasPacker)lmgroup.atlasPacker;
                if (packer == ftGlobalStorage.AtlasPacker.xatlas)
                {
                    if (!PackWithXatlas(lmgroup, holderObjs, data, pdata))
                    {
                        ExportSceneError("Failed packing atlas");
                        return false;
                    }
                }
                else
                {
                    // Calculate area sum for every scene LOD level in LMGroup
                    // Write remainingAreaPerLodLevel
                    SumHolderAreaPerLODLevel(holderObjs, data, pdata);

                    // Perform recursive packing
                    while(pdata.repack)
                    {
                        pdata.continueRepack = true;
                        if (!Pack(lmgroup, holderObjs, data, pdata)) return false;
                        if (!pdata.continueRepack) break;
                    }
                    // Normalize atlas by largest axis
                    NormalizeAtlas(lmgroup, holderObjs, data, pdata);
                }
            }
        }
        cmp_objToLodLevel = null;
        cmp_holderObjArea = null;

        return true;
    }

    static void NormalizeAutoAtlases(ExportSceneData data)
    {
        var autoAtlasGroups = data.autoAtlasGroups;
        var autoAtlasGroupRootNodes = data.autoAtlasGroupRootNodes;
        var holderRect = data.holderRect;

        // Normalize autoatlases
        var stack = new Stack<AtlasNode>();
        for(int g=0; g<autoAtlasGroups.Count; g++)
        {
            var lmgroup = autoAtlasGroups[g];
            if (lmgroup.parentName != null && lmgroup.parentName.Length > 0) continue;

            var rootNode = autoAtlasGroupRootNodes[g];
            float maxx = 0;
            float maxy = 0;
            rootNode.GetMax(ref maxx, ref maxy);
            float maxDimension = maxx > maxy ? maxx : maxy;
            float normalizeScale = 1.0f / maxDimension;
            stack.Clear();
            stack.Push(rootNode);
            while(stack.Count > 0)
            {
                var node = stack.Pop();
                if (node.obj != null)
                {
                    var rect = holderRect[node.obj];
                    holderRect[node.obj] = new Rect(rect.x * normalizeScale, rect.y * normalizeScale, rect.width * normalizeScale, rect.height * normalizeScale);
                }
                if (node.child0 != null) stack.Push(node.child0);
                if (node.child1 != null) stack.Push(node.child1);
            }
            if (maxDimension < 0.5f)
            {
                lmgroup.resolution /= 2; // shrink the lightmap after normalization if it was too empty
                lmgroup.resolution = Math.Max(lmgroup.resolution, minAutoResolution);
            }
        }
    }

    static void JoinAutoAtlases(ExportSceneData data)
    {
        var autoAtlasGroups = data.autoAtlasGroups;
        var autoAtlasGroupRootNodes = data.autoAtlasGroupRootNodes;
        var groupList = data.groupList;
        var lmBounds = data.lmBounds;
        var holderRect = data.holderRect;
        var objsToWrite = data.objsToWrite;
        var objsToWriteGroup = data.objsToWriteGroup;

        var stack = new Stack<AtlasNode>();

        // Join autoatlases
        var autoAtlasCategories = new List<string>();
        bool joined = false;
        for(int g=0; g<autoAtlasGroups.Count; g++)
        {
            if (autoAtlasGroups[g].parentName != null && autoAtlasGroups[g].parentName.Length > 0) continue;

            string cat = "/" + autoAtlasGroups[g].sceneLodLevel;
            if (splitByScene) cat = autoAtlasGroups[g].sceneName + cat;
            if (splitByTag) cat = autoAtlasGroups[g].tag + "/" + cat;
            if (!autoAtlasCategories.Contains(cat)) autoAtlasCategories.Add(cat);
        }
        for(int alod=0; alod<autoAtlasCategories.Count; alod++)
        {
            var cat = autoAtlasCategories[alod];
            var autoAtlasSizes = new List<int>();
            var atlasStack = new Stack<BakeryLightmapGroup>();
            for(int g=0; g<autoAtlasGroups.Count; g++)
            {
                if (autoAtlasGroups[g].parentName != null && autoAtlasGroups[g].parentName.Length > 0) continue;

                var thisCat = "/" + autoAtlasGroups[g].sceneLodLevel;
                if (splitByScene) thisCat = autoAtlasGroups[g].sceneName + thisCat;
                if (splitByTag) thisCat = autoAtlasGroups[g].tag + "/" + thisCat;

                if (thisCat != cat) continue;
                if (autoAtlasGroups[g].resolution == maxAutoResolution) continue;
                if (!autoAtlasSizes.Contains(autoAtlasGroups[g].resolution)) autoAtlasSizes.Add(autoAtlasGroups[g].resolution);
            }
            autoAtlasSizes.Sort();
            for(int s=0; s<autoAtlasSizes.Count; s++)
            {
                int asize = autoAtlasSizes[s];
                atlasStack.Clear();
                for(int g=0; g<autoAtlasGroups.Count; g++)
                {
                    if (autoAtlasGroups[g].parentName != null && autoAtlasGroups[g].parentName.Length > 0) continue;

                    var thisCat = "/" + autoAtlasGroups[g].sceneLodLevel;
                    if (splitByScene) thisCat = autoAtlasGroups[g].sceneName + thisCat;
                    if (splitByTag) thisCat = autoAtlasGroups[g].tag + "/" + thisCat;

                    if (thisCat != cat) continue;
                    if (autoAtlasGroups[g].resolution != asize) continue;
                    atlasStack.Push(autoAtlasGroups[g]);
                    if (atlasStack.Count == 4)
                    {
                        var newGroup = ScriptableObject.CreateInstance<BakeryLightmapGroup>();
                        newGroup.name = autoAtlasGroups[g].name;
                        newGroup.isImplicit = true;
                        newGroup.sceneLodLevel = autoAtlasGroups[g].sceneLodLevel;
                        newGroup.sceneName = autoAtlasGroups[g].sceneName;

                        newGroup.resolution = asize * 2;

                        newGroup.bitmask = autoAtlasGroups[g].bitmask;
                        newGroup.mode = BakeryLightmapGroup.ftLMGroupMode.PackAtlas;

                        newGroup.id = data.lmid;
                        groupList.Add(newGroup);
                        lmBounds.Add(new Bounds(new Vector3(0,0,0), new Vector3(0,0,0)));
                        data.lmid++;

                        autoAtlasGroups.Add(newGroup);
                        var rootNode2 = new AtlasNode();
                        rootNode2.rc = new Rect(0, 0, 1, 1);
                        autoAtlasGroupRootNodes.Add(rootNode2);

                        // Top
                        rootNode2.child0 = new AtlasNode();
                        rootNode2.child0.rc = new Rect(0, 0, 1, 0.5f);

                        // Bottom
                        rootNode2.child1 = new AtlasNode();
                        rootNode2.child1.rc = new Rect(0, 0.5f, 1, 0.5f);

                        for(int gg=0; gg<4; gg++)
                        {
                            var subgroup = atlasStack.Pop();
                            var id = autoAtlasGroups.IndexOf(subgroup);
                            var subgroupRootNode = autoAtlasGroupRootNodes[id];
                            float ox, oy, sx, sy;

                            if (gg == 0)
                            {
                                // Left top
                                rootNode2.child0.child0 = subgroupRootNode;
                                //rootNode2.child0.child0.Transform(0, 0, 0.5f, 0.5f);
                                //offsetScale = rootNode2.child0.child0.rc;
                                ox = 0; oy = 0; sx = 0.5f; sy = 0.5f;
                            }
                            else if (gg == 1)
                            {
                                // Right top
                                rootNode2.child0.child1 = subgroupRootNode;
                                //rootNode2.child0.child1.Transform(0.5f, 0, 0.5f, 0.5f);
                                //offsetScale = rootNode2.child0.child1.rc;
                                ox = 0.5f; oy = 0; sx = 0.5f; sy = 0.5f;
                            }
                            else if (gg == 2)
                            {
                                // Left bottom
                                rootNode2.child1.child0 = subgroupRootNode;
                                //rootNode2.child1.child0.Transform(0, 0.5f, 0.5f, 0.5f);
                                //offsetScale = rootNode2.child1.child0.rc;
                                ox = 0; oy = 0.5f; sx = 0.5f; sy = 0.5f;
                            }
                            else
                            {
                                // Right bottom
                                rootNode2.child1.child1 = subgroupRootNode;
                                //rootNode2.child1.child1.Transform(0.5f, 0.5f, 0.5f, 0.5f);
                                //offsetScale = rootNode2.child1.child1.rc;
                                ox = 0.5f; oy = 0.5f; sx = 0.5f; sy = 0.5f;
                            }

                            autoAtlasGroups.RemoveAt(id);
                            autoAtlasGroupRootNodes.RemoveAt(id);

                            id = groupList.IndexOf(subgroup);
                            groupList.RemoveAt(id);
                            lmBounds.RemoveAt(id);

                            for(int x=id; x<groupList.Count; x++)
                            {
                                groupList[x].id--;
                                data.lmid--;
                            }

                            // Modify implicit group storage
                            joined = true;
                            stack.Clear();
                            stack.Push(subgroupRootNode);
                            while(stack.Count > 0)
                            {
                                var node = stack.Pop();
                                if (node.obj != null)
                                {
                                    var rect = holderRect[node.obj];
                                    holderRect[node.obj] = new Rect(rect.x * sx + ox,
                                                                    rect.y * sy + oy,
                                                                    rect.width * sx,
                                                                    rect.height * sy);

                                    MoveObjectToImplicitGroup(node.obj, newGroup, data);

                                    /*
                                    tempStorage.implicitGroupMap[node.obj] = newGroup;
                                    for(int k=0; k<storages[sceneToID[node.obj.scene]].implicitGroupedObjects.Count; k++)
                                    {
                                        if (storages[sceneToID[node.obj.scene]].implicitGroupedObjects[k] == node.obj)
                                        {
                                            storages[sceneToID[node.obj.scene]].implicitGroups[k] = newGroup;
                                            //Debug.LogError("Implicit set (join): " + k+" "+newGroup.name);
                                        }
                                    }
                                    */
                                }
                                if (node.child0 != null) stack.Push(node.child0);
                                if (node.child1 != null) stack.Push(node.child1);
                            }
                        }
                    }
                }
            }
        }
        if (joined)
        {
            for(int i=0; i<objsToWrite.Count; i++)
            {
                objsToWriteGroup[i] = GetLMGroupFromObject(objsToWrite[i], data);
            }
        }
    }

    static bool ExportSceneValidationMessage(string msg)
    {
        ProgressBarEnd(false);
        if (ftRenderLightmap.verbose)
        {
            if (!EditorUtility.DisplayDialog("Bakery", msg, "Continue anyway", "Cancel"))
            {
                CloseAllFiles();
                userCanceled = true;
                ProgressBarEnd(true);
                return false;
            }
        }
        else
        {
            Debug.LogError(msg);
        }
        ProgressBarInit("Exporting scene - preparing...");
        return true;
    }

    static void ExportSceneError(string phase)
    {
        DebugLogError("Error exporting scene (" + phase + ") - see console for details");
        CloseAllFiles();
        userCanceled = true;
        ProgressBarEnd(true);
    }

    class ExportSceneData
    {
        // Per-scene data
        public ftLightmapsStorage[] storages;
        public int firstNonNullStorage;
        //public ftLightmapsStorage settingsStorage;
        public Dictionary<Scene, int> sceneToID = new Dictionary<Scene, int>();
        public Dictionary<Scene,bool> sceneHasStorage = new Dictionary<Scene,bool>();

        // Object properties
        public Dictionary<GameObject,int> objToLodLevel = new Dictionary<GameObject,int>(); // defines atlas LOD level
        public Dictionary<GameObject,List<int>> objToLodLevelVisible = new Dictionary<GameObject,List<int>>(); // defines LOD levels where this object is visible
        public Dictionary<GameObject, float> objToScaleInLm = new Dictionary<GameObject, float>();
        public Dictionary<GameObject, int> objToBakeTag;

        public List<GameObject> objsToWrite = new List<GameObject>();
        public List<bool> objsToWriteLightmapped = new List<bool>();
        public List<BakeryLightmapGroup> objsToWriteGroup = new List<BakeryLightmapGroup>();
        public List<GameObject> objsToWriteHolder = new List<GameObject>();
        public List<Vector4> objsToWriteScaleOffset = new List<Vector4>();
        public List<Vector2[]> objsToWriteUVOverride = new List<Vector2[]>();
        public List<string> objsToWriteNames = new List<string>();
        public List<Vector3[]> objsToWriteVerticesPosW = new List<Vector3[]>();
        public List<Vector3[]> objsToWriteVerticesNormalW = new List<Vector3[]>();
        public List<Vector4[]> objsToWriteVerticesTangentW = new List<Vector4[]>();
        public List<Vector2[]> objsToWriteVerticesUV = new List<Vector2[]>();
        public List<Vector2[]> objsToWriteVerticesUV2 = new List<Vector2[]>();
        public List<int[][]> objsToWriteIndices = new List<int[][]>();
        public List<bool> objsToWriteHasMetaAlpha = new List<bool>();

        public List<Renderer> outsideRenderers = new List<Renderer>(); // for sector+SRP only

        // Auto-atlasing
        public List<BakeryLightmapGroup> autoAtlasGroups = new List<BakeryLightmapGroup>();
        public List<AtlasNode> autoAtlasGroupRootNodes = new List<AtlasNode>();
        public BakeryLightmapGroup autoVertexGroup;

        // Data to collect for atlas packing
        public Dictionary<GameObject, float> holderObjArea = new Dictionary<GameObject, float>(); // LMGroup holder area, accumulated from all children
        public Dictionary<GameObject, Vector4> holderObjUVBounds = new Dictionary<GameObject, Vector4>(); // LMGroup holder 2D UV AABB
        public Dictionary<BakeryLightmapGroup, List<GameObject>> groupToHolderObjects = new Dictionary<BakeryLightmapGroup, List<GameObject>>(); // LMGroup -> holders map
        public Dictionary<GameObject, Rect> holderRect = new Dictionary<GameObject, Rect>();

        // Per-LMGroup data
        public List<BakeryLightmapGroup> groupList = new List<BakeryLightmapGroup>();
        public List<Bounds> lmBounds = new List<Bounds>(); // list of bounding boxes around LMGroups for testing lights

        // Geometry data
        public List<int>[] indicesOpaqueLOD = null;
        public List<int>[] indicesTransparentLOD = null;

        public int lmid = 0; // LMID counter

        public ExportSceneData(int sceneCount)
        {
            storages = new ftLightmapsStorage[sceneCount];
        }
    }

    class AdjustUVPaddingData
    {
        public List<int> dirtyObjList = new List<int>();
        public List<string> dirtyAssetList = new List<string>();
        public Dictionary<Mesh, List<int>> meshToObjIDs = new Dictionary<Mesh, List<int>>();
        public Dictionary<Mesh, int> meshToPaddingMap = new Dictionary<Mesh, int>();
    }

    class PackData
    {
        public Dictionary<int,float> remainingAreaPerLodLevel = new Dictionary<int,float>();
        public bool repack = true;
        public bool repackStage2 = false;
        public bool finalRepack = false;
        public float repackScale = 1;
        public int repackTries = 0;
        public bool hasResOverrides = false;
        public bool continueRepack = false;
    }

    static void UpdateLMGroupBounds(List<Bounds> lmBounds, List<GameObject> objsToWrite, List<BakeryLightmapGroup> objsToWriteGroup, ftLightmapsStorage[] storages)
    {
        for(int i=0; i<objsToWrite.Count; i++)
        {
            var obj = objsToWrite[i];
            if (obj == null) continue;

            var lmgroup = objsToWriteGroup[i];
            if (lmgroup == null) continue;
            int id = lmgroup.id;

            var mr = GetValidRenderer(obj);
            
            if (modifyLightmapStorage)
            {
                if (lmBounds[id].size == Vector3.zero) {
                    lmBounds[id] = mr.bounds;
                } else {
                    var b = lmBounds[id];
                    b.Encapsulate(mr.bounds);
                    lmBounds[id] = b;
                }

#if USE_TERRAINS
                bool isTerrain = (exportTerrainAsHeightmap && obj.name == "__ExportTerrain");
                if (isTerrain)
                {
                    var b = lmBounds[id];
                    var hindex = terrainObjectList.IndexOf(obj.transform.parent.gameObject);
                    var terr = terrainObjectToActual[hindex];
                    var tb = terr.terrainData.bounds;
                    tb.center += terr.transform.position;
                    b.Encapsulate(tb);
                    lmBounds[id] = b;
                }
#endif
            }
        }

        if (modifyLightmapStorage)
        {
            var sceneCount = SceneManager.sceneCount;
            for(int s=0; s<sceneCount; s++)
            {
                if (storages[s] == null) continue;
                storages[s].bounds = lmBounds;
            }
        }
    }

    static public IEnumerator ExportScene(EditorWindow window, bool renderTextures = true, bool atlasOnly = false, BakerySectorCapture sectorCaptureAsset = null)
    {
        lmgroupHolder = null; // important to properly flush previous scale-in-lightmaps

        userCanceled = false;
        ProgressBarInit("Exporting scene - preparing...", window);
        yield return null;

        var bakeryRuntimePath = ftLightmaps.GetRuntimePath();
        gstorage = AssetDatabase.LoadAssetAtPath(bakeryRuntimePath + "ftGlobalStorage.asset", typeof(ftGlobalStorage)) as ftGlobalStorage;
        pstorage = ftLightmaps.GetProjectSettings();

        bool isDX11 = SystemInfo.graphicsDeviceType == GraphicsDeviceType.Direct3D11;
        bool nonDX11 = !isDX11;

        bool _unwrapUVs = unwrapUVs;
        bool _forceDisableUnwrapUVs = forceDisableUnwrapUVs;
        if (ftRenderLightmap.fullSectorRender && !ftRenderLightmap.curSector.allowUVPaddingAdjustment)
        {
            _unwrapUVs = false;
            _forceDisableUnwrapUVs = false;
        }

        var time = GetTime();
        var ms = time;
        var startMsU = ms;
        double totalTime = GetTime();
        double vbTimeRead = 0;
        double vbTimeWrite = 0;
        double vbTimeWriteFull = 0;
        double vbTimeWriteT = 0;
        double vbTimeWriteT2 = 0;
        double vbTimeWriteT3 = 0;
        double ibTime = 0;
        var sceneCount = SceneManager.sceneCount;
        var indicesOpaque = new List<int>();
        var indicesTransparent = new List<int>();

        var data = new ExportSceneData(sceneCount);

        bool tangentSHLights = CheckForTangentSHLights();

        // Per-LMGroup data
        var lmAlbedoList = new List<IntPtr>(); // list of albedo texture for UV GBuffer rendering
        var lmAlbedoListTex = new List<Texture>();
        var lmAlphaList = new List<IntPtr>(); // list of alpha textures for alpha buffer generation
        var lmAlphaListRAM = new List<TexInput>(); // non-DX11 array
        var lmAlphaListTex = new List<Texture>();
        var lmAlphaRefList = new List<float>(); // list of alpha texture refs
        var lmAlphaChannelList = new List<int>(); // list of alpha channels

        // lod-related
        var lmVOffset = new List<int>();
        var lmUVArrays = new List<List<float>>();
        var lmIndexArrays = new List<List<int>>();
        var lmLocalToGlobalIndices = new List<List<int>>();

        vbtraceTexPosNormalArray = new List<float>();
        vbtraceTexUVArray = new List<float>();

        sceneLodsUsed = 0;

        // Create temp path
        CreateSceneFolder();

        // Disable preview of any sectors
        if (sectorCaptureAsset == null)
        {
            var allSectors = FindObjectsOfType(typeof(BakerySector)) as BakerySector[];
            for(int i=0; i<allSectors.Length; i++)
            {
                if (allSectors[i].previewEnabled) BakerySectorInspector.DisablePreview(allSectors[i]);
            }
        }

        // Init storages
        try
        {
            InitSceneStorage(data);
        }
        catch(Exception e)
        {
            ExportSceneError("Global storage init");
            Debug.LogError("Exception caught: " + e.ToString());
            throw;
        }

        // Create LMGroup for light probes
        bool renderProbesNow = ftRenderLightmap.lightProbeMode == ftRenderLightmap.LightProbeMode.L1 && renderTextures && !atlasOnly && ftRenderLightmap.hasAnyProbes;
        if (renderProbesNow && ftRenderLightmap.fullSectorRender && ftRenderLightmap.curSector != null)
        {
            renderProbesNow = ftRenderLightmap.curSector.bakeChildLightProbeGroups;
        }
        if (renderProbesNow)
        {
            var c = CreateLightProbeLMGroup(data);
            while(c.MoveNext()) yield return null;
        }

        if (ftRenderLightmap.hasAnyVolumes)
        {
            var c2 = CreateVolumeLMGroup(data);
            while(c2.MoveNext()) yield return null;
        }

        // wip
        var lmBounds = data.lmBounds;
        var storages = data.storages;
        var sceneToID = data.sceneToID;
        var groupList = data.groupList;
        var objToLodLevel = data.objToLodLevel;
        var objToLodLevelVisible = data.objToLodLevelVisible;
        var objsToWrite = data.objsToWrite;
        var objsToWriteGroup = data.objsToWriteGroup;
        var objsToWriteHolder = data.objsToWriteHolder;
        var objsToWriteIndices = data.objsToWriteIndices;
        var objsToWriteNames = data.objsToWriteNames;
        var objsToWriteUVOverride = data.objsToWriteUVOverride;
        var objsToWriteScaleOffset = data.objsToWriteScaleOffset;
        var objsToWriteVerticesUV = data.objsToWriteVerticesUV;
        var objsToWriteVerticesUV2 = data.objsToWriteVerticesUV2;
        var objsToWriteVerticesPosW = data.objsToWriteVerticesPosW;
        var objsToWriteVerticesNormalW = data.objsToWriteVerticesNormalW;
        var objsToWriteVerticesTangentW = data.objsToWriteVerticesTangentW;
        var objsToWriteHasMetaAlpha = data.objsToWriteHasMetaAlpha;
        var holderRect = data.holderRect;

        terrainObjectList = new List<GameObject>();
#if USE_TERRAINS
        terrainObjectToActual = new List<Terrain>();
#endif
        terrainObjectToHeightMap = new List<Texture>();
        terrainObjectToHeightMapRAM = new List<TexInput>();
        terrainObjectToBounds = new List<float>();
        terrainObjectToBoundsUV = new List<float>();
        terrainObjectToFlags = new List<int>();
        terrainObjectToLMID = new List<int>();
        terrainObjectToHeightMips = new List<List<float[]>>();
        temporaryGameObjects = new List<GameObject>();
        temporaryAreaLightMeshList = new List<GameObject>();
        temporaryAreaLightMeshList2 = new List<BakeryLightMesh>();

        var objects = Resources.FindObjectsOfTypeAll(typeof(GameObject));
        //var objects = UnityEngine.Object.FindObjectsOfTypeAll(typeof(GameObject));

        try
        {
            ms = GetTime();

            //if (!onlyUVdata)
            //{
                time = ms;

                // Get manually created LMGroups
                CollectExplicitLMGroups(data);

                // Object conversion loop / also validate for multiple scene storages
                for(int objNum = 0; objNum < objects.Length; objNum++)
                {
                    GameObject obj = (GameObject)objects[objNum];
                    if (obj == null) continue;

                    if (!obj.activeInHierarchy) continue;
                    var path = AssetDatabase.GetAssetPath(obj);
                    if (path != "") continue; // must belong to scene
                    

                    if (!CheckForMultipleSceneStorages(obj, data)) yield break;
                    if (ConvertUnityAreaLight(obj)) continue;
#if USE_TERRAINS
                    ConvertTerrain(obj);
#endif
                }

                // Regather objects if new were added
                if (terrainObjectList.Count > 0 || temporaryGameObjects.Count > 0 || temporaryAreaLightMeshList.Count > 0)
                {
                    //objects = UnityEngine.Object.FindObjectsOfTypeAll(typeof(GameObject));
                    objects = Resources.FindObjectsOfTypeAll(typeof(GameObject));
                }

                tempStorage.implicitGroupMap = new Dictionary<GameObject, UnityEngine.Object>(); // implicit holder -> LMGroup map. used by GetLMGroupFromObject

                // Find LODGroups -> LODs -> scene-wide LOD distances
                // Map objects to scene-wide LOD levels
                MapObjectsToSceneLODs(data, objects);

                ftModelPostProcessor.Init();

                // Filter objects, convert to property arrays
                if (!FilterObjects(data, objects)) yield break;

                if (ftRenderLightmap.fullSectorRender)
                {
                    var sector = ftRenderLightmap.curSector;
                    if (sector.captureMode == BakerySector.CaptureMode.CaptureInPlace || (sectorCaptureAsset != null && sectorCaptureAsset.write))
                    {
                        int objCount = data.objsToWrite.Count;
                        var cpoints = sector.cpoints;

                        // Render albedo/alpha/depth for each sector point
                        var fdata = new FarSphereRenderData[cpoints.Count];
                        for(int i=0; i<cpoints.Count; i++)
                        {
                            //if (!GenerateFarSphere(data, sector.cpoints[i].position, objCount)) yield break;
                            fdata[i] = GenerateFarSphereData(data, cpoints[i].position, objCount, i == 0);
                            if (fdata[i] == null)
                            {
                                DebugLogError("GenerateFarSphereData failed");
                                userCanceled = true;
                                yield break;
                            }
                        }

                        // Cull each other (closest texels win)
                        for(int i=0; i<cpoints.Count; i++)
                        {
                            for(int j=0; j<cpoints.Count; j++)
                            {
                                if (i == j) continue;
                                if (!ClipFarSphere(fdata[i], fdata[j]))
                                {
                                    DebugLogError("ClipFarSphere failed");
                                    userCanceled = true;
                                    yield break;
                                }
                            }
                        }

                        // Generate meshes
                        if (!GenerateFarSpheres(data, fdata, cpoints))
                        {
                            DebugLogError("GenerateFarSpheres failed");
                            userCanceled = true;
                            yield break;
                        }

                        if (sectorCaptureAsset != null)
                        {
                            sectorCaptureAsset.meshes = new List<Mesh>();
                            sectorCaptureAsset.positions = new List<Vector3>();
                            sectorCaptureAsset.textures = new List<Texture2D>();
                            for(int i=0; i<cpoints.Count; i++)
                            {
                                var fd = fdata[i];
                                for(int j=0; j<fd.meshes.Length; j++)
                                {
                                    sectorCaptureAsset.meshes.Add(fd.meshes[j]);
                                    sectorCaptureAsset.positions.Add(fd.pos);
                                    sectorCaptureAsset.textures.Add(fd.textures[j]);
                                }
                            }
                            sectorCaptureAsset.outsideRenderers = data.outsideRenderers;
                            yield break;
                        }
                    }
                    else if (sector.captureMode == BakerySector.CaptureMode.LoadCaptured)
                    {
                        if (sector.captureAsset == null)
                        {
                            DebugLogError("No capture asset is specified for sector " + sector.name);
                            userCanceled = true;
                            yield break;
                        }
                        else
                        {
                            if (!LoadSectorCapture(data, sector.captureAsset, sector.transform))
                            {
                                DebugLogError("Can't load sector capture for " + sector.name);
                                userCanceled = true;
                                yield break;
                            }
                        }
                    }
                }

                CalculateVertexCountForVertexGroups(data);
                CreateAutoAtlasLMGroups(data, renderTextures, atlasOnly);

                TransformVertices(data, tangentSHLights);

                if (_unwrapUVs && modifyLightmapStorage)
                {
                    var adata = new AdjustUVPaddingData();

                    CalculateUVPadding(data, adata);
                    ResetPaddingStorageData(data);
                    StoreNewUVPadding(data, adata);

                    if (!ValidatePaddingImmutability(adata)) yield break;

                    if (CheckUnwrapError()) yield break;

                    // Reimport assets with adjusted padding
                    if (!ReimportModifiedAssets(adata)) yield break;

                    TransformModifiedAssets(data, adata, tangentSHLights);
                }
                else if (_forceDisableUnwrapUVs)
                {
                    var adata = new AdjustUVPaddingData();

                    ResetPaddingStorageData(data);
                    if (!ClearUVPadding(data, adata)) yield break;

                    if (CheckUnwrapError()) yield break;

                    TransformModifiedAssets(data, adata, tangentSHLights);
                }

                CalculateHolderUVBounds(data);
                CalculateAutoAtlasInitResolution(data);
                if (!PackAtlases(data)) yield break;

                if (atlasPacker == ftGlobalStorage.AtlasPacker.Default)
                {
                    if (!pstorage.alternativeScaleInLightmap)
                    {
                        NormalizeAutoAtlases(data);
                        JoinAutoAtlases(data);
                    }
                }

                if (!ValidateScaleOffsetImmutability(data))
                {
                    sceneNeedsToBeRebuilt = true;
                    yield break;
                }

                InitSceneStorage2(data);

                //TransformVertices(data); // shouldn't be necessary

                // Update objToWriteGroups because of autoAtlas
                if (autoAtlas)
                {
                    for(int i=0; i<objsToWrite.Count; i++)
                    {
                        objsToWriteGroup[i] = GetLMGroupFromObject(objsToWrite[i], data);
                    }
                }

                // Done collecting groups

                if (groupList.Count == 0 && modifyLightmapStorage)
                {
                    DebugLogError("You need to mark some objects static or add Bakery Lightmap Group Selector components on them.");
                    CloseAllFiles();
                    userCanceled = true;
                    ProgressBarEnd(true);
                    yield break;
                }

                if (objsToWrite.Count == 0)
                {
                    DebugLogError("You need to mark some objects static or add Bakery Lightmap Group Selector components on them.");
                    CloseAllFiles();
                    userCanceled = true;
                    ProgressBarEnd(true);
                    yield break;
                }

                if (atlasOnly)
                {
                    atlasOnlyObj = new List<Renderer>();
                    atlasOnlySize = new List<int>();
                    atlasOnlyID = new List<int>();
                    atlasOnlyGroup = new List<BakeryLightmapGroup>();
                    atlasOnlyScaleOffset = new List<Vector4>();
                    var emptyVec4 = new Vector4(1,1,0,0);
                    Rect rc = new Rect();
                    for(int i=0; i<objsToWrite.Count; i++)
                    {
                        var lmgroup = objsToWriteGroup[i];
                        if (lmgroup == null) continue;
                        if (lmgroup.mode == BakeryLightmapGroup.ftLMGroupMode.Vertex) continue;
                        var obj = objsToWrite[i];
                        if (obj != null && obj.GetComponent<BakeryLightMesh>() != null) continue;
                        var holderObj = objsToWriteHolder[i];
                        if (holderObj != null)
                        {
                            if (!holderRect.TryGetValue(holderObj, out rc))
                            {
                                holderObj = null;
                            }
                        }
                        var scaleOffset = holderObj == null ? emptyVec4 : new Vector4(rc.width, rc.height, rc.x, rc.y);
                        atlasOnlyObj.Add(GetValidRenderer(objsToWrite[i]));
                        atlasOnlyScaleOffset.Add(scaleOffset);
                        atlasOnlySize.Add(lmgroup == null ? 0 : lmgroup.resolution);
                        int id = lmgroup == null ? 0 : lmgroup.id;
                        if (lmgroup != null)
                        {
                            var nm = lmgroup.parentName;
                            if (nm != null && nm.Length > 0 && nm != "|")
                            {
                                // dependant sub-lightmaps
                                for(int j=0; j<groupList.Count; j++)
                                {
                                    if (groupList[j].name == nm)
                                    {
                                        id = groupList[j].id;
                                        break;
                                    }
                                }
                            }
                        }
                        atlasOnlyID.Add(id);
                        atlasOnlyGroup.Add(lmgroup);
                    }
                    yield break;
                }

                // Sort LMGroups so vertex groups are never first (because Unity assumes lightmap compression on LM0)
                for(int i=0; i<groupList.Count; i++)
                {
                    groupList[i].sortingID = i;
                }
                groupList.Sort(delegate(BakeryLightmapGroup a, BakeryLightmapGroup b)
                {
                    int aa = (a.mode == BakeryLightmapGroup.ftLMGroupMode.Vertex) ? -1 : 1;
                    int bb = (b.mode == BakeryLightmapGroup.ftLMGroupMode.Vertex) ? -1 : 1;
                    return bb.CompareTo(aa);
                });
                var lmBounds2 = new List<Bounds>();
                for(int i=0; i<groupList.Count; i++)
                {
                    lmBounds2.Add(lmBounds[groupList[i].sortingID]); // apply same sorting to lmBounds
                    groupList[i].id = i;
                }
                lmBounds = lmBounds2;

                if (splitByTag)
                {
                    // Init settings set by tag overrides
                    var tagTable = gstorage.tagOverrides;
                    for(int i=0; i<groupList.Count; i++)
                    {
                        var group = groupList[i];
                        if (group.isImplicit && group.tag >= 0)
                        {
                            for(int j=0; j<tagTable.Count; j++)
                            {
                                var tagData = tagTable[j];
                                if (tagData.tag != group.tag) continue;

                                if (tagData.renderMode != (int)BakeryLightmapGroup.RenderMode.Auto) group.renderMode = (BakeryLightmapGroup.RenderMode)tagData.renderMode;
                                if (tagData.renderDirMode != (int)BakeryLightmapGroup.RenderDirMode.Auto) group.renderDirMode = (BakeryLightmapGroup.RenderDirMode)tagData.renderDirMode;
                                group.bitmask = tagData.bitmask;
                                group.transparentSelfShadow = tagData.transparentSelfShadow;
                                group.computeSSS = tagData.computeSSS;
                                if (group.computeSSS)
                                {
                                    group.sssSamples = tagData.sssSamples;
                                    group.sssDensity = tagData.sssDensity;
                                    group.sssColor = tagData.sssColor;
                                }
                            }
                        }
                    }
                }

                // Check for existing files
                if (overwriteWarning)
                {
                    var checkGroupList = groupList;
                    if (overwriteWarningSelectedOnly)
                    {
                        var selObjs = Selection.objects;
                        checkGroupList = new List<BakeryLightmapGroup>();
                        for(int o=0; o<selObjs.Length; o++)
                        {
                            if (selObjs[o] as GameObject == null) continue;
                            var selGroup = GetLMGroupFromObject(selObjs[o] as GameObject, data);
                            if (selGroup == null) continue;
                            if (!checkGroupList.Contains(selGroup))
                            {
                                checkGroupList.Add(selGroup);
                            }
                        }
                    }
                    var existingFilenames = "";
                    for(int i=0; i<checkGroupList.Count; i++)
                    {
                        var nm = checkGroupList[i].name;
                        var filename = nm + "_final" + overwriteExtensionCheck;
                        var outputPath = ftRenderLightmap.outputPathFull;
                        if (File.Exists("Assets/" + outputPath + "/" + filename))
                        {
                            existingFilenames += filename + "\n";
                        }
                    }
                    if (existingFilenames.Length > 0 && ftRenderLightmap.verbose)
                    {
                        ProgressBarEnd(false);
                        if (!EditorUtility.DisplayDialog("Lightmap overwrite", "These lightmaps will be overwritten:\n\n" + existingFilenames, "Overwrite", "Cancel"))
                        {
                            CloseAllFiles();
                            userCanceled = true;
                            ProgressBarEnd(true);
                            yield break;
                        }
                        ProgressBarInit("Exporting scene - preparing...", window);
                    }
                }

                ftRenderLightmap.giLodModeEnabled = false;//ftRenderLightmap.giLodMode == ftRenderLightmap.GILODMode.ForceOn;
                ulong approxMem = 0;

                if (groupList.Count > 100 && ftRenderLightmap.verbose)
                {
                    ProgressBarEnd(false);
                    if (!EditorUtility.DisplayDialog("Lightmap count check", groupList.Count + " lightmaps are going to be rendered. Continue?", "Continue", "Cancel"))
                    {
                        CloseAllFiles();
                        userCanceled = true;
                        ProgressBarEnd(true);
                        yield break;
                    }
                    ProgressBarInit("Exporting scene - preparing...", window);
                }

                if (memoryWarning || ftRenderLightmap.giLodMode == ftRenderLightmap.GILODMode.Auto)
                {
                    for(int i=0; i<groupList.Count; i++)
                    {
                        var lmgroup = groupList[i];
                        var res = lmgroup.resolution;
                        ulong lightingSize = (ulong)(res * res * 4 * 2); // RGBA16f
                        approxMem += lightingSize;
                    }
                    var tileSize = ftRenderLightmap.tileSize;
                    approxMem += (ulong)(tileSize * tileSize * 16 * 2); // maximum 2xRGBA32f (for fixPos12)
                }

                if (memoryWarning && ftRenderLightmap.verbose)
                {
                    ProgressBarEnd(false);
                    if (!EditorUtility.DisplayDialog("Lightmap memory check", "Rendering may require more than " + (ulong)((approxMem/1024)/1024) + "MB of video memory. Continue?", "Continue", "Cancel"))
                    {
                        CloseAllFiles();
                        userCanceled = true;
                        ProgressBarEnd(true);
                        yield break;
                    }
                    ProgressBarInit("Exporting scene - preparing...", window);
                }


                if (ftRenderLightmap.giLodMode == ftRenderLightmap.GILODMode.Auto)
                {

                    approxMem /= 1024;
                    approxMem /= 1024;
                    approxMem += 1024; // scene geometry size estimation - completely random

                    if ((int)approxMem > SystemInfo.graphicsMemorySize)
                    {
                        DebugLogInfo("GI VRAM auto optimization ON: estimated usage " + (int)approxMem + " > " + SystemInfo.graphicsMemorySize);
                        ftRenderLightmap.giLodModeEnabled = true;
                    }
                    else
                    {
                        DebugLogInfo("GI VRAM auto optimization OFF: estimated usage " + (int)approxMem + " < " + SystemInfo.graphicsMemorySize);
                    }
                }

                // Generate terrain geometry with detail enough for given size for UVGBuffer purposes
                fhmaps = new BinaryWriter(File.Open(scenePath + "/heightmaps.bin", FileMode.Create));
                if (ftRenderLightmap.clientMode) ftClient.serverFileList.Add("heightmaps.bin");
#if USE_TERRAINS
                if (exportTerrainAsHeightmap)
                {
                    for(int i=0; i<objsToWrite.Count; i++)
                    {
                        var obj = objsToWrite[i];
                        if (obj.name != "__ExportTerrain") continue;

                        var holderObj = objsToWriteHolder[i];
                        Rect rc = new Rect();
                        if (holderObj != null)
                        {
                            if (!holderRect.TryGetValue(holderObj, out rc))
                            {
                                holderObj = null;
                            }
                        }
                        if (holderObj == null) continue;

                        var lmgroup = objsToWriteGroup[i];
                        //float terrainPixelWidth = rc.width * lmgroup.resolution;
                        //float terrainPixelHeight = rc.height * lmgroup.resolution;

                        var index = terrainObjectList.IndexOf(obj.transform.parent.gameObject);
                        var terrain = terrainObjectToActual[index];
                        var tdata = terrain.terrainData;
                        //var heightmapResolution = tdata.heightmapResolution;

                        //int closestSize = (int)Mathf.Min(Mathf.NextPowerOfTwo((int)Mathf.Max(terrainPixelWidth, terrainPixelHeight)), heightmapResolution-1);
                        //if (closestSize < 2) continue;
                        //int mipLog2 = (int)(Mathf.Log(closestSize) / Mathf.Log(2.0f));
                        //int maxMipLog2 = (int)(Mathf.Log(heightmapResolution-1) / Mathf.Log(2.0f));
                        //int mip = maxMipLog2 - mipLog2;

                        float scaleX = tdata.size.x;// / (heightmapResolution-1);
                        //float scaleY = tdata.size.y;
                        float scaleZ = tdata.size.z;// / (heightmapResolution-1);
                        float offsetX = obj.transform.position.x;
                        float offsetY = obj.transform.position.y;
                        float offsetZ = obj.transform.position.z;

                        terrainObjectToLMID[index] = lmgroup.id;
                        terrainObjectToBoundsUV[index*4] = rc.x;
                        terrainObjectToBoundsUV[index*4+1] = rc.y;
                        terrainObjectToBoundsUV[index*4+2] = rc.width;
                        terrainObjectToBoundsUV[index*4+3] = rc.height;

                        if (uvgbHeightmap)
                        {
                            var indexArrays = objsToWriteIndices[i] = new int[1][];
                            var indexArray = indexArrays[0] = new int[6];//(closestSize-1)*(closestSize-1)*6];
                            //int indexOffset = 0;
                            //int vertOffset = 0;
                            var uvArray = objsToWriteVerticesUV[i] = objsToWriteVerticesUV2[i] = new Vector2[4];//closestSize*closestSize];

                            var posArray = objsToWriteVerticesPosW[i] = new Vector3[4];
                            var normalArray = objsToWriteVerticesNormalW[i] = new Vector3[4];

                            posArray[0] = new Vector3(offsetX, offsetY, offsetZ);
                            posArray[1] = new Vector3(offsetX + scaleX, offsetY, offsetZ);
                            posArray[2] = new Vector3(offsetX, offsetY, offsetZ + scaleZ);
                            posArray[3] = new Vector3(offsetX + scaleX, offsetY, offsetZ + scaleZ);

                            normalArray[0] = Vector3.up;
                            normalArray[1] = Vector3.up;
                            normalArray[2] = Vector3.up;
                            normalArray[3] = Vector3.up;

                            uvArray[0] = new Vector2(0,0);
                            uvArray[1] = new Vector2(1,0);
                            uvArray[2] = new Vector2(0,1);
                            uvArray[3] = new Vector2(1,1);

                            indexArray[0] = 0;
                            indexArray[1] = 2;
                            indexArray[2] = 3;

                            indexArray[3] = 0;
                            indexArray[4] = 3;
                            indexArray[5] = 1;
                        }
                        else
                        {
                            /*if (mip == 0)
                            {
                                // use existing heightmap
                                var heights = tdata.GetHeights(0, 0, heightmapResolution, heightmapResolution);
                                var posArray = objsToWriteVerticesPosW[i] = new Vector3[heightmapResolution * heightmapResolution];
                                objsToWriteVerticesNormalW[i] = terrainObjectToNormalMip0[index];
                                closestSize = heightmapResolution;
                                scaleX /= closestSize-1;
                                scaleZ /= closestSize-1;
                                for(int y=0; y<closestSize; y++)
                                {
                                    for(int x=0; x<closestSize; x++)
                                    {
                                        float px = x * scaleX + offsetX;
                                        float pz = y * scaleZ + offsetZ;
                                        posArray[y * closestSize + x] = new Vector3(px, heights[y, x] * scaleY + offsetY, pz);
                                    }
                                }
                            }
                            else
                            {
                                // use mip
                                var heights = terrainObjectToHeightMips[index][mip - 1];
                                var posArray = objsToWriteVerticesPosW[i] = new Vector3[closestSize * closestSize];
                                objsToWriteVerticesNormalW[i] = terrainObjectToNormalMips[index][mip - 1];
                                scaleX /= closestSize-1;
                                scaleZ /= closestSize-1;
                                for(int y=0; y<closestSize; y++)
                                {
                                    for(int x=0; x<closestSize; x++)
                                    {
                                        float px = x * scaleX + offsetX;
                                        float pz = y * scaleZ + offsetZ;
                                        posArray[y * closestSize + x] = new Vector3(px, heights[y * closestSize + x] * scaleY + offsetY, pz);
                                    }
                                }
                            }
                            var indexArrays = objsToWriteIndices[i] = new int[1][];
                            var indexArray = indexArrays[0] = new int[(closestSize-1)*(closestSize-1)*6];
                            int indexOffset = 0;
                            int vertOffset = 0;
                            var uvArray = objsToWriteVerticesUV[i] = objsToWriteVerticesUV2[i] = new Vector2[closestSize*closestSize];
                            for(int y=0; y<closestSize; y++)
                            {
                                for(int x=0; x<closestSize; x++)
                                {
                                    uvArray[y * closestSize + x] = new Vector2(x / (float)(closestSize-1), y / (float)(closestSize-1));

                                    if (x < closestSize-1 && y < closestSize-1)
                                    {
                                        indexArray[indexOffset] = vertOffset;
                                        indexArray[indexOffset + 1] = vertOffset + closestSize;
                                        indexArray[indexOffset + 2] = vertOffset + closestSize + 1;

                                        indexArray[indexOffset + 3] = vertOffset;
                                        indexArray[indexOffset + 4] = vertOffset + closestSize + 1;
                                        indexArray[indexOffset + 5] = vertOffset + 1;

                                        indexOffset += 6;
                                    }
                                    vertOffset++;
                                }
                            }*/
                        }
                    }

                    // Export heightmap metadata
                    if (terrainObjectToActual.Count > 0)
                    {
                        for(int i=0; i<terrainObjectToHeightMap.Count; i++)
                        {
                            fhmaps.Write(terrainObjectToLMID[i]);
                            for(int fl=0; fl<6; fl++) fhmaps.Write(terrainObjectToBounds[i*6+fl]);
                            for(int fl=0; fl<4; fl++) fhmaps.Write(terrainObjectToBoundsUV[i*4+fl]);
                            fhmaps.Write(terrainObjectToFlags[i]);
                        }
                    }
                }
#endif
                // Write mark last written scene
                File.WriteAllText(scenePath + "/lastscene.txt", ftRenderLightmap.GenerateLightingDataAssetName());

                // Write lightmap definitions
                var flms = new BinaryWriter(File.Open(scenePath + "/lms.bin", FileMode.Create));
                var flmlod = new BinaryWriter(File.Open(scenePath + "/lmlod.bin", FileMode.Create));
                var flmuvgb = new BinaryWriter(File.Open(scenePath + "/lmuvgb.bin", FileMode.Create));

                if (ftRenderLightmap.clientMode)
                {
                    ftClient.serverFileList.Add("lms.bin");
                    ftClient.serverFileList.Add("lmlod.bin");
                    ftClient.serverFileList.Add("lmuvgb.bin");
                }

                // Init global UVGBuffer flags
                int uvgbGlobalFlags = 0;
                int _UVGBFLAG_SMOOTHPOS = pstorage.generateSmoothPos ? UVGBFLAG_SMOOTHPOS : 0;
                if (exportShaderColors)
                {
                    if (ftRenderLightmap.renderDirMode == ftRenderLightmap.RenderDirMode.BakedNormalMaps)
                    {
                        uvgbGlobalFlags = UVGBFLAG_FACENORMAL | UVGBFLAG_POS | _UVGBFLAG_SMOOTHPOS;
                    }
                    else if (ftRenderLightmap.renderDirMode == ftRenderLightmap.RenderDirMode.RNM ||
                            (ftRenderLightmap.renderDirMode == ftRenderLightmap.RenderDirMode.SH && tangentSHLights) ||
                            (ftRenderLightmap.renderDirMode == ftRenderLightmap.RenderDirMode.MonoSH && tangentSHLights))
                    {
                        uvgbGlobalFlags = UVGBFLAG_NORMAL | UVGBFLAG_FACENORMAL | UVGBFLAG_POS | _UVGBFLAG_SMOOTHPOS | UVGBFLAG_TANGENT;
                    }
                    else
                    {
                        uvgbGlobalFlags = UVGBFLAG_NORMAL | UVGBFLAG_FACENORMAL | UVGBFLAG_POS | _UVGBFLAG_SMOOTHPOS;
                    }
                }
                else
                {
                    uvgbGlobalFlags = UVGBFLAG_NORMAL | UVGBFLAG_FACENORMAL | UVGBFLAG_ALBEDO | UVGBFLAG_EMISSIVE | UVGBFLAG_POS | _UVGBFLAG_SMOOTHPOS;
                }
#if USE_TERRAINS
                if (terrainObjectToActual.Count > 0) uvgbGlobalFlags |= UVGBFLAG_TERRAIN;
#endif
                SetUVGBFlags(uvgbGlobalFlags);

                for(int i=0; i<groupList.Count; i++)
                {
                    var lmgroup = groupList[i];
                    flms.Write(lmgroup.name);

                    flmlod.Write(lmgroup.sceneLodLevel);

                    int uvgbflags = 0;

                    if (lmgroup.containsTerrains && exportTerrainAsHeightmap)
                        uvgbflags = uvgbGlobalFlags | (UVGBFLAG_NORMAL | UVGBFLAG_TERRAIN);

                    if (lmgroup.renderDirMode == BakeryLightmapGroup.RenderDirMode.BakedNormalMaps)
                        uvgbflags = UVGBFLAG_FACENORMAL | UVGBFLAG_POS | _UVGBFLAG_SMOOTHPOS;

                    if (lmgroup.renderDirMode == BakeryLightmapGroup.RenderDirMode.RNM ||
                        (lmgroup.renderDirMode == BakeryLightmapGroup.RenderDirMode.SH && tangentSHLights) ||
                        (lmgroup.renderDirMode == BakeryLightmapGroup.RenderDirMode.MonoSH && tangentSHLights))
                        uvgbflags = UVGBFLAG_NORMAL | UVGBFLAG_FACENORMAL | UVGBFLAG_POS | _UVGBFLAG_SMOOTHPOS | UVGBFLAG_TANGENT;

                    if (lmgroup.probes) uvgbflags = UVGBFLAG_RESERVED;

                    flmuvgb.Write(uvgbflags);

                    if (ftRenderLightmap.clientMode)
                    {
                        if (uvgbflags == 0) uvgbflags = uvgbGlobalFlags;

                        ftClient.serverFileList.Add("uvpos_" + lmgroup.name + (ftRenderLightmap.compressedGBuffer ? ".lz4" : ".dds"));
                        ftClient.serverFileList.Add("uvnormal_" + lmgroup.name + (ftRenderLightmap.compressedGBuffer ? ".lz4" : ".dds"));
                        ftClient.serverFileList.Add("uvalbedo_" + lmgroup.name + (ftRenderLightmap.compressedGBuffer ? ".lz4" : ".dds"));
                        if (lmgroup.mode != BakeryLightmapGroup.ftLMGroupMode.Vertex)
                        {
                            if ((uvgbflags & UVGBFLAG_SMOOTHPOS) != 0) ftClient.serverFileList.Add("uvsmoothpos_" + lmgroup.name + (ftRenderLightmap.compressedGBuffer ? ".lz4" : ".dds"));
                        }
                        if ((uvgbflags & UVGBFLAG_FACENORMAL) != 0) ftClient.serverFileList.Add("uvfacenormal_" + lmgroup.name + (ftRenderLightmap.compressedGBuffer ? ".lz4" : ".dds"));
                        if ((uvgbflags & UVGBFLAG_TANGENT) != 0) ftClient.serverFileList.Add("uvtangent_" + lmgroup.name + (ftRenderLightmap.compressedGBuffer ? ".lz4" : ".dds"));
                    }

                    if (lmgroup.mode == BakeryLightmapGroup.ftLMGroupMode.Vertex)
                    {
                        int atlasTexSize = (int)Mathf.Ceil(Mathf.Sqrt((float)lmgroup.totalVertexCount));
                        if (atlasTexSize > 8192) DebugLogWarning("Warning: vertex lightmap group " + lmgroup.name + " uses resolution of " + atlasTexSize);
                        atlasTexSize = (int)Mathf.Ceil(atlasTexSize / (float)ftRenderLightmap.tileSize) * ftRenderLightmap.tileSize;
                        flms.Write(-atlasTexSize);
                    }
                    else
                    {
                        flms.Write(lmgroup.resolution);
                    }
                    //Debug.LogError(lmgroup.name+": " + lmgroup.resolution);
                }
                flms.Close();
                flmlod.Close();
                flmuvgb.Close();

                voffset = ioffset = soffset = 0; // vertex/index/surface write

                // Per-surface alpha texture IDs
                var alphaIDs = new List<ushort>();

                int albedoCounter = 0;
                var albedoMap = new Dictionary<IntPtr, int>(); // albedo ptr -> ID map

                int alphaCounter = 0;
                var alphaMap = new Dictionary<IntPtr, List<int>>(); // alpha ptr -> ID map

                var dummyTexList = new List<Texture>(); // list of single-color 1px textures
                var dummyPixelArray = new Color[1];

                if (ftRenderLightmap.checkOverlaps)
                {
                    var quad = GameObject.CreatePrimitive(PrimitiveType.Quad);
                    var plane = GameObject.CreatePrimitive(PrimitiveType.Plane);
                    var qmesh = quad.GetComponent<MeshFilter>().sharedMesh;
                    var pmesh = plane.GetComponent<MeshFilter>().sharedMesh;
                    DestroyImmediate(quad);
                    DestroyImmediate(plane);
                    bool canCheck = ftModelPostProcessor.InitOverlapCheck();
                    if (!canCheck)
                    {
                        DebugLogError("Can't load ftOverlapTest.shader");
                        CloseAllFiles();
                        userCanceled = true;
                        ProgressBarEnd(true);
                        yield break;
                    }
                    for(int g=0; g<groupList.Count; g++)
                    {
                        var lmgroup = groupList[g];
                        if (lmgroup.mode == BakeryLightmapGroup.ftLMGroupMode.Vertex) continue;
                        for(int i=0; i<objsToWrite.Count; i++)
                        {
                            if (objsToWriteGroup[i] != lmgroup) continue;
                            var obj = objsToWrite[i];

                            var mesh = GetSharedMesh(obj);
                            if (mesh == qmesh || mesh == pmesh) continue;

                            var uv = objsToWriteVerticesUV[i];//mesh.uv;
                            var uv2 = objsToWriteVerticesUV2[i];//mesh.uv2;
                            var usedUVs = uv2.Length == 0 ? uv : uv2;
                            bool validUVs = true;
                            for(int v=0; v<usedUVs.Length; v++)
                            {
                                if (usedUVs[v].x < -0.0001f || usedUVs[v].x > 1.0001f || usedUVs[v].y < -0.0001f || usedUVs[v].y > 1.0001f)
                                {
                                    validUVs = false;
                                    break;
                                }
                            }
                            if (!validUVs && ftRenderLightmap.verbose)
                            {
                                string objPath = obj.name;
                                var prt = obj.transform.parent;
                                while(prt != null)
                                {
                                    objPath = prt.name + "\\" + objPath;
                                    prt = prt.parent;
                                }
                                ftRenderLightmap.simpleProgressBarEnd();
                                if (!EditorUtility.DisplayDialog("Incorrect UVs", "Object " + objPath + " UVs are out of 0-1 bounds", "Continue", "Stop"))
                                {
                                    CloseAllFiles();
                                    userCanceled = true;
                                    ProgressBarEnd(true);
                                    yield break;
                                }
                                ProgressBarInit("Exporting scene - preparing...", window);
                            }

                            int overlap = ftModelPostProcessor.DoOverlapCheck(obj, false);
                            if (overlap != 0 && ftRenderLightmap.verbose)
                            {
                                //storage.debugRT = ftModelPostProcessor.rt;
                                string objPath = obj.name;
                                var prt = obj.transform.parent;
                                while(prt != null)
                                {
                                    objPath = prt.name + "\\" + objPath;
                                    prt = prt.parent;
                                }
                                if (overlap < 0)
                                {
                                    ftRenderLightmap.simpleProgressBarEnd();
                                    if (!EditorUtility.DisplayDialog("Incorrect UVs", "Object " + objPath + " has no UV2", "Continue", "Stop"))
                                    {
                                        CloseAllFiles();
                                        userCanceled = true;
                                        ProgressBarEnd(true);
                                        yield break;
                                    }
                                    ProgressBarInit("Exporting scene - preparing...", window);
                                }
                                else
                                {
                                  ftRenderLightmap.simpleProgressBarEnd();
                                    if (!EditorUtility.DisplayDialog("Incorrect UVs", "Object " + objPath + " has overlapping UVs", "Continue", "Stop"))
                                    {
                                        CloseAllFiles();
                                        userCanceled = true;
                                        ProgressBarEnd(true);
                                        yield break;
                                    }
                                    ProgressBarInit("Exporting scene - preparing...", window);
                                }
                            }
                        }
                    }
                    ftModelPostProcessor.EndOverlapCheck();
                }

                if (ftRenderLightmap.batchAreaLightSampleLimit > 0 && !autosetAreaLightLMID)
                {
                    UpdateLMGroupBounds(lmBounds, objsToWrite, objsToWriteGroup, storages);
                    ftRenderLightmap.instance.ComputeAreaLightLMGroupIntersections(data.groupList);
                    ftRenderLightmap.instance.SetAreaLightLMID();
                }

                // Prepare progressbar
                int progressNumObjects = 0;
                foreach(GameObject obj in objects)
                {
                    if (obj == null) continue;
                    if (!obj.activeInHierarchy) continue;
                    progressNumObjects++;
                }

                // Open files to write
                fscene = new BinaryWriter(File.Open(scenePath + "/objects.bin", FileMode.Create));
                fmesh = new BinaryWriter(File.Open(scenePath + "/mesh.bin", FileMode.Create));
                flmid = new BinaryWriter(File.Open(scenePath + "/lmid.bin", FileMode.Create));
                fseamfix = new BinaryWriter(File.Open(scenePath + "/seamfix.bin", FileMode.Create));
                fsurf = new BinaryWriter(File.Open(scenePath + "/surf.bin", FileMode.Create));
                fmatid = new BinaryWriter(File.Open(scenePath + "/matid.bin", FileMode.Create));
                fmatide = new BinaryWriter(File.Open(scenePath + "/emissiveid.bin", FileMode.Create));
                fmatideb = new BinaryWriter(File.Open(scenePath + "/emissivemul.bin", FileMode.Create));
                fmatidh = new BinaryWriter(File.Open(scenePath + "/heightmapid.bin", FileMode.Create));
                falphaid = new BinaryWriter(File.Open(scenePath + "/alphaid.bin", FileMode.Create));

                fvbfull =     new BufferedBinaryWriterFloat( new BinaryWriter(File.Open(scenePath + "/vbfull.bin", FileMode.Create)) );
                fvbtrace =    new BufferedBinaryWriterFloat( new BinaryWriter(File.Open(scenePath + "/vbtrace.bin", FileMode.Create)) );
                fvbtraceTex = new BufferedBinaryWriterFloat( new BinaryWriter(File.Open(scenePath + "/vbtraceTex.bin", FileMode.Create)) );
                fvbtraceUV0 = new BufferedBinaryWriterFloat( new BinaryWriter(File.Open(scenePath + "/vbtraceUV0.bin", FileMode.Create)) );

                fib =         new BufferedBinaryWriterInt( new BinaryWriter(File.Open(scenePath + "/ib.bin", FileMode.Create)) );

                fib32 = new BinaryWriter(File.Open(scenePath + "/ib32.bin", FileMode.Create));
                fib32lod = new BinaryWriter[sceneLodsUsed];
                for(int i=0; i<sceneLodsUsed; i++)
                {
                    fib32lod[i] = new BinaryWriter(File.Open(scenePath + "/ib32_lod" + i + ".bin", FileMode.Create));
                    if (ftRenderLightmap.clientMode) ftClient.serverFileList.Add("ib32_lod" + i + ".bin");
                }
                falphaidlod = new BinaryWriter[sceneLodsUsed];
                for(int i=0; i<sceneLodsUsed; i++)
                {
                    falphaidlod[i] = new BinaryWriter(File.Open(scenePath + "/alphaid_lod" + i + ".bin", FileMode.Create));
                    if (ftRenderLightmap.clientMode) ftClient.serverFileList.Add("alphaid2_lod" + i + ".bin"); // alphaid2, not alphaid
                }

                if (ftRenderLightmap.clientMode)
                {
                    ftClient.serverFileList.Add("objects.bin");
                    ftClient.serverFileList.Add("mesh.bin");
                    ftClient.serverFileList.Add("lmid.bin");
                    ftClient.serverFileList.Add("seamfix.bin");
                    ftClient.serverFileList.Add("surf.bin");
                    ftClient.serverFileList.Add("matid.bin");
                    ftClient.serverFileList.Add("emissiveid.bin");
                    ftClient.serverFileList.Add("emissivemul.bin");
                    ftClient.serverFileList.Add("heightmapid.bin");
                    ftClient.serverFileList.Add("alphaid2.bin"); // alphaid2, not alphaid
                        ftClient.serverFileList.Add("alphabuffer.bin");
                    ftClient.serverFileList.Add("vbfull.bin");
                    ftClient.serverFileList.Add("vbtrace.bin");
                    ftClient.serverFileList.Add("vbtraceTex.bin");
                    ftClient.serverFileList.Add("vbtraceUV0.bin");
                    ftClient.serverFileList.Add("ib.bin");
                    ftClient.serverFileList.Add("ib32.bin");
                }

                // Export some scene data
                // - LMIDs
                // - mesh definitions
                // - surface definitions
                // - albedo IDs
                // - alpha IDs
                // - update LMGroup bounds
                // - export index buffer
                // - generate tracing index buffer

                areaLightCounter = -2;
                //var defaultTexST = new Vector4(1,1,0,0);
                //var objsToWriteTexST = new List<Vector4>();

                for(int i=0; i<objsToWrite.Count; i++)
                {
                    var obj = objsToWrite[i];
                    var lmgroup = objsToWriteGroup[i];
                    var holderObj = objsToWriteHolder[i];

                    if (obj == null)
                    {
                        // wtf
                        DebugLogError("Object " + objsToWriteNames[i] + " was destroyed mid-export");
                        CloseAllFiles();
                        userCanceled = true;
                        ProgressBarEnd(true);
                        yield break;
                    }

                    var mr = GetValidRenderer(obj);
                    var m = GetSharedMesh(mr);

                    var inds = objsToWriteIndices[i];

                    // Write LMID, mesh and surface definition
                    int id = exportLMID(flmid, obj, lmgroup);
                    exportMesh(fmesh, m);
                    exportSurfs(fsurf, inds, inds.Length);// m);

                    int lodLevel;
                    if (!objToLodLevel.TryGetValue(obj, out lodLevel)) lodLevel = -1;

                    bool isTerrain = (exportTerrainAsHeightmap && obj.name == "__ExportTerrain");
                    bool hasMetaAlpha = false;

                    // Write albedo IDs, collect alpha IDs, update LMGroup bounds
                    if (id >= 0) {
                        for(int k=0; k<m.subMeshCount; k++) {
                            // Get mesh albedos
                            int texID = -1;
                            Material mat = null;
                            Texture tex = null;
                            //var texST = defaultTexST;
                            if (k < mr.sharedMaterials.Length) {
                                mat = mr.sharedMaterials[k];
                                if (mat != null)
                                {
                                    if (mat.HasProperty("_MainTex"))
                                    {
                                        tex = mat.mainTexture;
                                        //if (mat.HasProperty("_MainTex_ST"))
                                        //{
                                          //  texST = mat.GetVector("_MainTex_ST");
                                        //}
                                    }
                                    else if (mat.HasProperty("_BaseColorMap"))
                                    {
                                        // HDRP
                                        tex = mat.GetTexture("_BaseColorMap");
                                    }
                                    else if (mat.HasProperty("_BaseMap"))
                                    {
                                        // URP
                                        tex = mat.GetTexture("_BaseMap");
                                    }
                                }
                            }
                            IntPtr texPtr = (IntPtr)0;
                            Texture texWrite = null;
                            if (tex != null)
                            {
                                texPtr = tex.GetNativeTexturePtr();
                                texWrite = tex;
                                if (texPtr == (IntPtr)0)
                                {
                                    Debug.LogError("Texture " + tex.name + " cannot be used as albedo (GetNativeTexturePtr returned null)");
                                    tex = null;
                                    texWrite = null;
                                }
                                else if ((tex as RenderTexture) != null)
                                {
                                    Debug.LogError("RenderTexture " + tex.name + " cannot be used as albedo (GetNativeTexturePtr returned null)");
                                    tex = null;
                                    texWrite = null;
                                }
                            }
                            if (tex == null)
                            {
                                // Create dummy 1px texture
                                var dummyTex = new Texture2D(1,1);
                                dummyPixelArray[0] = (mat == null || !mat.HasProperty("_Color")) ? Color.white : mat.color;
                                dummyTex.SetPixels(dummyPixelArray);
                                dummyTex.Apply();
                                texWrite = dummyTex;
                                dummyTexList.Add(dummyTex);
                                texPtr = dummyTex.GetNativeTexturePtr();
                                if (texPtr == (IntPtr)0)
                                {
                                    Debug.LogError("Failed to call GetNativeTexturePtr() on newly created texture");
                                    texWrite = null;
                                }
                            }
                            if (!albedoMap.TryGetValue(texPtr, out texID))
                            {
                                lmAlbedoList.Add(texPtr);
                                lmAlbedoListTex.Add(texWrite);
                                albedoMap[texPtr] = albedoCounter;
                                texID = albedoCounter;
                                albedoCounter++;
                            }

                            // Write albedo ID
                            fmatid.Write((ushort)texID);

                            // Get mesh alphas
                            ushort alphaID = 0xFFFF;
                            int alphaChannel = 3; // A
                            if (mat != null && mat.HasProperty("_TransparencyLM")) // will override _MainTex.a if present
                            {
                                var tex2 = mat.GetTexture("_TransparencyLM");
                                if (tex2 != null)
                                {
                                    tex = tex2;
                                    texPtr = tex.GetNativeTexturePtr();
                                    alphaChannel = 0; // R
                                }
                            }
                            bool alphaMetaPass = (mat != null && mat.HasProperty("BAKERY_META_ALPHA_ENABLE"));
                            if (alphaMetaPass && ftRenderLightmap.lightProbeMode ==  ftRenderLightmap.LightProbeMode.Legacy)
                            {
                                alphaMetaPass = false;
                                DebugLogWarning("Skipping alpha meta pass in legacy light probe mode");
                            }

                            if (alphaMetaPass)
                            {
                                float alphaRef = 0.5f;

                                // Will use meta pass alpha

                                lmAlphaList.Add((System.IntPtr)0); // will be replaced after in-engine UVGBuffer part generation
                                if (nonDX11) lmAlphaListRAM.Add(new TexInput());
                                lmAlphaListTex.Add(null);
                                lmAlphaRefList.Add(alphaRef);
                                lmAlphaChannelList.Add(id); // channel is always 3; store LMID instead

                                texID = alphaCounter;
                                alphaCounter++;
                                alphaID = (ushort)texID;

                                hasMetaAlpha = true;
                            }
                            else if (tex != null)
                            {
                                var matTag = mat.GetTag("RenderType", true);
                                bool isCutout = matTag == "TransparentCutout";
                                if (isCutout || matTag == "Transparent" || matTag == "TreeLeaf") {

                                    float alphaRef = 0.5f;
                                    if (mat != null && mat.HasProperty("_Cutoff"))
                                    {
                                        alphaRef = mat.GetFloat("_Cutoff");
                                    }
                                    float opacity = 1.0f;
                                    if (!isCutout && mat.HasProperty("_Color"))
                                    {
                                        opacity = mat.color.a;
                                    }
                                    // let constant alpha affect cutout theshold for alphablend materials
                                    alphaRef = 1.0f - (1.0f - alphaRef) * opacity;
                                    if (alphaRef > 1) alphaRef = 1;

                                    // Using alpha texture directly

                                    // allow same map instances with different threshold
                                    List<int> texIDs;
                                    if (!alphaMap.TryGetValue(texPtr, out texIDs))
                                    {
                                        alphaMap[texPtr] = texIDs = new List<int>();

                                        lmAlphaList.Add(texPtr);
                                        if (nonDX11) lmAlphaListRAM.Add(InputDataFromTex(tex));
                                        lmAlphaListTex.Add(tex);
                                        lmAlphaRefList.Add(alphaRef);
                                        lmAlphaChannelList.Add(alphaChannel);

                                        texIDs.Add(alphaCounter);
                                        texID = alphaCounter;
                                        alphaCounter++;
                                        //Debug.Log("Alpha " + texID+": " + tex.name+" "+alphaRef);
                                        alphaID = (ushort)texID;
                                    }
                                    else
                                    {
                                        int matchingInstance = -1;
                                        for(int instance=0; instance<texIDs.Count; instance++)
                                        {
                                            texID = texIDs[instance];
                                            if (Mathf.Abs(lmAlphaRefList[texID] - alphaRef) <= alphaInstanceThreshold)
                                            {
                                                if (lmAlphaChannelList[texID] == alphaChannel)
                                                {
                                                    matchingInstance = instance;
                                                    alphaID = (ushort)texID;
                                                    break;
                                                }
                                            }
                                        }
                                        if (matchingInstance < 0)
                                        {
                                            lmAlphaList.Add(texPtr);
                                            if (nonDX11) lmAlphaListRAM.Add(InputDataFromTex(tex));
                                            lmAlphaListTex.Add(tex);
                                            lmAlphaRefList.Add(alphaRef);
                                            lmAlphaChannelList.Add(alphaChannel);

                                            texIDs.Add(alphaCounter);
                                            texID = alphaCounter;
                                            alphaCounter++;
                                            //Debug.Log("Alpha " + texID+": " + tex.name+" "+alphaRef);
                                            alphaID = (ushort)texID;
                                        }
                                    }
                                }
                            }
                            alphaIDs.Add(alphaID);

                            // Get mesh emissives
                            if (exportShaderColors)
                            {
                                for(int s=0; s<sceneCount; s++)
                                {
                                    if (storages[s] == null) continue;
                                    while(storages[s].hasEmissive.Count <= id) storages[s].hasEmissive.Add(true);
                                    storages[s].hasEmissive[id] = true;
                                }
                            }

                            texID = -1;
                            tex = null;
                            if (mat!=null && mat.shaderKeywords.Contains("_EMISSION"))
                            {
                                if (mat.HasProperty("_EmissionMap")) tex = mat.GetTexture("_EmissionMap");
                                if (tex != null)
                                {
                                    texPtr = tex.GetNativeTexturePtr();
                                    if (texPtr == (IntPtr)0)
                                    {
                                        if ((tex as RenderTexture) != null)
                                        {
                                            Debug.LogError("RenderTexture " + tex.name + " cannot be used as emission (GetNativeTexturePtr returned null)");
                                            tex = null;
                                        }
                                        else
                                        {
                                            Debug.LogError("Texture " + tex.name + " cannot be used as emission (GetNativeTexturePtr returned null)");
                                            tex = null;
                                        }
                                        //DebugLogError("Null emission tex ptr");
                                    }
                                }
                                if (tex == null && mat.HasProperty("_EmissionColor"))
                                {
                                    // Create dummy 1px texture
                                    var dummyTex = new Texture2D(1,1);
                                    dummyPixelArray[0] = mat.GetColor("_EmissionColor");
                                    dummyTex.SetPixels(dummyPixelArray);
                                    dummyTex.Apply();
                                    tex = dummyTex;
                                    dummyTexList.Add(dummyTex);
                                    texPtr = dummyTex.GetNativeTexturePtr();
                                    if (texPtr == (IntPtr)0)
                                    {
                                        Debug.LogError("Failed to call GetNativeTexturePtr() on newly created texture");
                                        texWrite = null;
                                        //DebugLogError("Null dummy tex ptr");
                                    }
                                }
                                if (!albedoMap.TryGetValue(texPtr, out texID))
                                {
                                    lmAlbedoList.Add(texPtr);
                                    lmAlbedoListTex.Add(tex);
                                    albedoMap[texPtr] = albedoCounter;
                                    texID = albedoCounter;
                                    albedoCounter++;
                                }
                                for(int s=0; s<sceneCount; s++)
                                {
                                    if (storages[s] == null) continue;
                                    while(storages[s].hasEmissive.Count <= id) storages[s].hasEmissive.Add(false);
                                    storages[s].hasEmissive[id] = true;
                                }

                                fmatide.Write((ushort)texID);
                                fmatideb.Write(mat.HasProperty("_EmissionColor") ? mat.GetColor("_EmissionColor").maxColorComponent : 1);
                            }
                            else
                            {
                                fmatide.Write((ushort)0xFFFF);
                                fmatideb.Write(0.0f);
                            }

                            if (isTerrain && uvgbHeightmap)
                            {
                                var hindex = terrainObjectList.IndexOf(obj.transform.parent.gameObject);
                                //var htex = terrainObjectToHeightMap[hindex];
                                //texPtr = htex.GetNativeTexturePtr();

                                //heightmapList.Add(texPtr);
                                //heightmapListTex.Add(htex);
                                //heightmapListBounds.Add();

                                //texID = heightmapCounter;
                                //heightmapCounter++;

                                fmatidh.Write((ushort)hindex);//texID);
                            }
                            else
                            {
                                fmatidh.Write((ushort)0xFFFF);
                            }
                        }

                        // Update LMGroup bounds
                        if (modifyLightmapStorage)
                        {
                            if (lmBounds[id].size == Vector3.zero) {
                                lmBounds[id] = mr.bounds;
                            } else {
                                var b = lmBounds[id];
                                b.Encapsulate(mr.bounds);
                                lmBounds[id] = b;
                            }

#if USE_TERRAINS
                            if (isTerrain && exportTerrainAsHeightmap)
                            {
                                var b = lmBounds[id];
                                var hindex = terrainObjectList.IndexOf(obj.transform.parent.gameObject);
                                var terr = terrainObjectToActual[hindex];
                                var tb = terr.terrainData.bounds;
                                tb.center += terr.transform.position;
                                b.Encapsulate(tb);
                                lmBounds[id] = b;
                            }
#endif
                        }

                    } else {
                        // Write empty albedo/alpha IDs for non-lightmapped
                        for(int k=0; k<m.subMeshCount; k++) {
                            fmatid.Write((ushort)0);
                            alphaIDs.Add(0xFFFF);
                            fmatide.Write((ushort)0xFFFF);
                            fmatideb.Write(0.0f);
                            fmatidh.Write((ushort)0xFFFF);
                        }
                    }

                    // Mark whole mesh that some submeshes use Meta Pass alpha
                    objsToWriteHasMetaAlpha.Add(hasMetaAlpha);

                    int currentVoffset = voffset;
                    voffset += objsToWriteVerticesPosW[i].Length;// m.vertexCount;

                    // Check if mesh is flipped
                    var ls = obj.transform.lossyScale;
                    bool isFlipped = Mathf.Sign(ls.x*ls.y*ls.z) < 0;
                    if (lmgroup != null && lmgroup.flipNormal) isFlipped = !isFlipped;

                    while(lmIndexArrays.Count <= id)
                    {
                        lmIndexArrays.Add(new List<int>());
                        lmLocalToGlobalIndices.Add(new List<int>());
                        lmVOffset.Add(0);
                    }

                    var mmr = GetValidRenderer(obj);
                    var castsShadows = mmr.shadowCastingMode != UnityEngine.Rendering.ShadowCastingMode.Off;
                    if (exportTerrainAsHeightmap && obj.name == "__ExportTerrain") castsShadows = false; // prevent exporting placeholder quads to ftrace

                    time = GetTime();
                    for(int k=0;k<m.subMeshCount;k++) {
                        // Export regular index buffer
                        //var indexCount = exportIB(fib, m, k, isFlipped, false, 0, null, 0);
                        var indexCount = exportIB(fib, inds[k], isFlipped, false, 0, null, 0);

                        bool submeshCastsShadows = castsShadows;
                        if (submeshCastsShadows)
                        {
                            var mats = mmr.sharedMaterials;
                            if (mats.Length > k)
                            {
                                if (mats[k] != null)
                                {
                                    var matTag = mats[k].GetTag("RenderType", true);
                                    if (matTag == "Transparent" || matTag == "TreeLeaf")
                                    {
                                        if (mats[k].HasProperty("_Color"))
                                        {
                                            if (mats[k].color.a < 0.5f)
                                            {
                                                if (!mats[k].HasProperty("BAKERY_META_ALPHA_ENABLE"))
                                                {
                                                    submeshCastsShadows = false;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        // Generate tracing index buffer, write alpha IDs per triangle
                        if (submeshCastsShadows)
                        {
                            var alphaID = alphaIDs[(alphaIDs.Count - m.subMeshCount) + k];

                            if (lodLevel < 0)
                            {
                                // Export persistent IB
                                var indicesOpaqueArray = indicesOpaque;
                                var indicesTransparentArray = indicesTransparent;
                                var falphaidFile = falphaid;
                                exportIB32(indicesOpaqueArray, indicesTransparentArray, id>=0 ? lmIndexArrays[id] : null,
                                             inds[k], isFlipped, currentVoffset, id>=0 ? lmVOffset[id] : 0, falphaidFile, alphaID);
                            }
                            else
                            {
                                // Export LOD IBs
                                var visList = objToLodLevelVisible[obj];
                                for(int vlod=0; vlod<visList.Count; vlod++)
                                {
                                    int lod = visList[vlod];
                                    var indicesOpaqueArray = data.indicesOpaqueLOD[lod];
                                    var indicesTransparentArray = data.indicesTransparentLOD[lod];
                                    var falphaidFile = falphaidlod[lod];
                                    exportIB32(indicesOpaqueArray, indicesTransparentArray, id>=0 ? lmIndexArrays[id] : null,
                                                 inds[k], isFlipped, currentVoffset, id>=0 ? lmVOffset[id] : 0, falphaidFile, alphaID);
                                }
                            }
                        }
                        ioffset += indexCount;
                    }
                    ibTime += GetTime() - time;

                    if (id >= 0)
                    {
                        var vcount = objsToWriteVerticesPosW[i].Length;//m.vertexCount;
                        var remapArray = lmLocalToGlobalIndices[id];
                        var addition = lmVOffset[id];
                        for(int k=0; k<vcount; k++)
                        {
                            remapArray.Add(k + currentVoffset);
                        }
                        lmVOffset[id] += vcount;
                    }
                }

        }
        catch(Exception e)
        {
            DebugLogError("Error exporting scene - see console for details");
            CloseAllFiles();
            userCanceled = true;
            ProgressBarEnd(true);
            Debug.LogError("Exception caught: " + e.ToString());
            throw;
        }

        ProgressBarShow("Exporting scene - finishing objects...", 0.5f, false);
        if (userCanceled)
        {
            CloseAllFiles();
            ProgressBarEnd(true);
            yield break;
        }
        yield return null;

        try
        {
                // Write vertex buffers and update storage
                Rect rc = new Rect();
                var emptyVec4 = new Vector4(1,1,0,0);
                for(int i=0; i<objsToWrite.Count; i++)
                {
                    var obj = objsToWrite[i];
                    var m = GetSharedMesh(obj);
                    var lmgroup = objsToWriteGroup[i];

                    var id = lmgroup == null ? -1 : objsToWriteGroup[i].id;

                    BakeryLightMesh areaLight = obj.GetComponent<BakeryLightMesh>();
                    if (areaLight == null)
                    {
                        var areaIndex = temporaryAreaLightMeshList.IndexOf(obj);
                        if (areaIndex >= 0) areaLight = temporaryAreaLightMeshList2[areaIndex];
                    }
                    //var areaLight =
                    if (areaLight != null) id = areaLight.lmid;

                    var vertexBake = lmgroup != null ? (lmgroup.mode == BakeryLightmapGroup.ftLMGroupMode.Vertex) : false;
                    //var castsShadows = obj.GetComponent<Renderer>().shadowCastingMode != UnityEngine.Rendering.ShadowCastingMode.Off;

                    var holderObj = objsToWriteHolder[i];
                    if (holderObj != null)
                    {
                        if (!holderRect.TryGetValue(holderObj, out rc))
                        {
                            holderObj = null;
                        }
                    }

                    time = GetTime();
                    //var vertices = m.vertices;
                    //var normals = m.normals;
                    //var tangents = m.tangents;
                    var uv = objsToWriteVerticesUV[i];//m.uv;
                    var uv2 = objsToWriteVerticesUV2[i];//m.uv2;
                    if (uv2.Length == 0 && !vertexBake) uv2 = uv;//m.uv;
                    vbTimeRead += GetTime() - time;

                    var inds = objsToWriteIndices[i];

                        var time2 = GetTime();
                        time = time2;

                    // Transform UVs
                    var tformedPos = objsToWriteVerticesPosW[i];// new Vector3[vertices.Length];
                    var tformedNormals = objsToWriteVerticesNormalW[i];// new Vector3[normals.Length];
                    Vector4[] tformedTangents = null;
                    if (NeedsTangents(lmgroup, tangentSHLights))
                    {
                        tformedTangents = objsToWriteVerticesTangentW[i];
                    }
                    Vector2[] tformedUV2;
                    if (areaLight == null && !vertexBake)
                    {
                        tformedUV2 = holderObj == null ? uv2 : new Vector2[tformedPos.Length];
                        for(int t=0; t<tformedPos.Length; t++)
                        {
                            if (holderObj != null)
                            {
                                tformedUV2[t].x = uv2[t].x * rc.width + rc.x;
                                tformedUV2[t].y = uv2[t].y * rc.height + rc.y;
                            }
                        }
                        objsToWriteUVOverride.Add(null);
                    }
                    else if (vertexBake)
                    {
                        tformedUV2 = GenerateVertexBakeUVs(lmgroup.vertexCounter, tformedPos.Length, lmgroup.totalVertexCount);
                        lmgroup.vertexCounter += tformedPos.Length;
                        objsToWriteUVOverride.Add(tformedUV2);
                    }
                    else
                    {
                        tformedUV2 = uv;
                        objsToWriteUVOverride.Add(null);
                    }

                    if (id >= 0)
                    {
                        while(lmUVArrays.Count <= id)
                        {
                            lmUVArrays.Add(new List<float>());
                        }
                        var lmUVArray = lmUVArrays[id];
                        for(int k=0; k<tformedUV2.Length; k++)
                        {
                            lmUVArray.Add(tformedUV2[k].x);
                            lmUVArray.Add(tformedUV2[k].y);
                        }
                    }

                    if (objsToWriteHasMetaAlpha[i]) uv = tformedUV2; // objects using Meta Pass alpha use UV2 instead of UV1

                    exportVBFull(fvbfull, tformedPos, tformedNormals, tformedTangents, uv, tformedUV2);
                        vbTimeWriteFull += GetTime() - time;
                        time = GetTime();
                    //if (castsShadows)
                    //{
                        exportVBTrace(fvbtrace, m, tformedPos, tformedNormals);
                            vbTimeWriteT += GetTime() - time;
                            time = GetTime();
                        exportVBTraceTexAttribs(vbtraceTexPosNormalArray, vbtraceTexUVArray, tformedPos, tformedNormals, tformedUV2, id, vertexBake, obj);
                            vbTimeWriteT2 += GetTime() - time;
                            time = GetTime();
                        exportVBTraceUV0(fvbtraceUV0, uv, tformedPos.Length);
                            vbTimeWriteT3 += GetTime() - time;
                            time = GetTime();
                    //}
                    voffset += tformedPos.Length;
                    vbTimeWrite += GetTime() - time2;


                    // update storage
                    // also write seamfix.bin
                    var sceneID = sceneToID[obj.scene];
                    if (obj.name == "__ExportTerrain")
                    {
#if USE_TERRAINS
                        fseamfix.Write(false);
                        var index = terrainObjectList.IndexOf(obj.transform.parent.gameObject);
                        var terrain = terrainObjectToActual[index];
                        var scaleOffset = holderObj == null ? emptyVec4 : new Vector4(rc.width, rc.height, rc.x, rc.y);
                        if (!storages[sceneID].bakedRenderersTerrain.Contains(terrain))
                        {
                            if (modifyLightmapStorage)
                            {
                                storages[sceneID].bakedRenderersTerrain.Add(terrain);
                                storages[sceneID].bakedIDsTerrain.Add(CorrectLMGroupID(id, lmgroup, groupList));
                                storages[sceneID].bakedScaleOffsetTerrain.Add(scaleOffset);
                            }
                        }
                        objsToWriteScaleOffset.Add(scaleOffset);
#endif
                    }
                    else
                    {
                        fseamfix.Write(true);
                        var scaleOffset = holderObj == null ? emptyVec4 : new Vector4(rc.width, rc.height, rc.x, rc.y);
                        if (modifyLightmapStorage)
                        {
                            bool vertexImplicit = false;
                            if (vertexBake)
                            {
                                if (lmgroup.isImplicit) vertexImplicit = true;
                            }
                            if (!vertexImplicit)
                            {
                                storages[sceneID].bakedRenderers.Add(GetValidRenderer(obj));
                                storages[sceneID].bakedIDs.Add(CorrectLMGroupID(id, lmgroup, groupList));
                                storages[sceneID].bakedScaleOffset.Add(scaleOffset);
                                storages[sceneID].bakedVertexOffset.Add(vertexBake ? (lmgroup.vertexCounter - tformedPos.Length) : -1);
                                storages[sceneID].bakedVertexColorMesh.Add(null);
                            }
                        }
                        objsToWriteScaleOffset.Add(vertexBake ? emptyVec4 : scaleOffset);
                    }
                }

                // Write vbTraceTex
                int numTraceVerts = vbtraceTexUVArray.Count/2;
                for(int i=0; i<numTraceVerts; i++)
                {
                    fvbtraceTex.Write(vbtraceTexPosNormalArray[i * 6]);
                    fvbtraceTex.Write(vbtraceTexPosNormalArray[i * 6 + 1]);
                    fvbtraceTex.Write(vbtraceTexPosNormalArray[i * 6 + 2]);
                    fvbtraceTex.Write(vbtraceTexPosNormalArray[i * 6 + 3]);
                    fvbtraceTex.Write(vbtraceTexPosNormalArray[i * 6 + 4]);
                    fvbtraceTex.Write(vbtraceTexPosNormalArray[i * 6 + 5]);

                    fvbtraceTex.Write(vbtraceTexUVArray[i * 2]);
                    fvbtraceTex.Write(vbtraceTexUVArray[i * 2 + 1]);
                }

                // Write tracing index buffer
                fib32.Write(indicesOpaque.Count); // firstAlphaTriangle
                for(int i=0; i<indicesOpaque.Count; i++) fib32.Write(indicesOpaque[i]); // opaque triangles
                for(int i=0; i<indicesTransparent.Count; i++) fib32.Write(indicesTransparent[i]); // alpha triangles

                // Write scene LOD tracing index buffers
                for(int lod=0; lod<sceneLodsUsed; lod++)
                {
                    var indicesOpaqueArray = data.indicesOpaqueLOD[lod];
                    var indicesTransparentArray = data.indicesTransparentLOD[lod];
                    fib32lod[lod].Write(indicesOpaqueArray.Count);
                    for(int i=0; i<indicesOpaqueArray.Count; i++) fib32lod[lod].Write(indicesOpaqueArray[i]); // opaque triangles
                    for(int i=0; i<indicesTransparentArray.Count; i++) fib32lod[lod].Write(indicesTransparentArray[i]); // alpha triangles
                }

                DebugLogInfo("Wrote binaries in " + ((GetTime() - totalTime)/1000.0) + "s");
                DebugLogInfo("VB read time " + (vbTimeRead/1000.0) + "s");
                DebugLogInfo("VB write time " + (vbTimeWrite/1000.0) + "s");
                DebugLogInfo("VB write time (full) " + (vbTimeWriteFull/1000.0) + "s");
                DebugLogInfo("VB write time (trace) " + (vbTimeWriteT/1000.0) + "s");
                DebugLogInfo("VB write time (trace tex) " + (vbTimeWriteT2/1000.0) + "s");
                DebugLogInfo("VB write time (UV0) " + (vbTimeWriteT3/1000.0) + "s");
                DebugLogInfo("IB time " + (ibTime/1000.0) + "s");


                fscene.Write(objsToWrite.Count);
                int meshID = 0;
                foreach(var obj in objsToWrite) {
                    fscene.Write(meshID);
                    meshID++;
                }
                foreach(var obj in objsToWrite) {
                    fscene.Write(obj.name);
                }

                fscene.Close();
                fmesh.Close();
                flmid.Close();
                fseamfix.Close();
                fsurf.Close();
                fmatid.Close();
                fmatide.Close();
                fmatideb.Close();
                fmatidh.Close();
                fvbfull.Close();
                fvbtrace.Close();
                fvbtraceTex.Close();
                fvbtraceUV0.Close();
                fib.Close();
                fib32.Close();
                falphaid.Close();
                fhmaps.Close();

                if (fib32lod != null)
                {
                    for(int i=0; i<fib32lod.Length; i++) fib32lod[i].Close();
                }
                if (falphaidlod != null)
                {
                    for(int i=0; i<falphaidlod.Length; i++) falphaidlod[i].Close();
                }

                if (modifyLightmapStorage)
                {
                    for(int s=0; s<sceneCount; s++)
                    {
                        if (storages[s] == null) continue;
                        storages[s].bounds = lmBounds;
                    }
                }
            //}

            startMsU = GetTime();
        }
        catch(Exception e)
        {
            DebugLogError("Error exporting scene - see console for details");
            CloseAllFiles();
            userCanceled = true;
            ProgressBarEnd(true);
            Debug.LogError("Exception caught: " + e.ToString());
            throw;
        }

        if (exportShaderColors && renderTextures)
        {
            yield return null;
            ProgressBarShow("Exporting scene - shaded surface colors...", 0.55f, false);
            for(int g=0; g<groupList.Count; g++)
            {
                var str = storages[data.firstNonNullStorage];
                if (str == null) Debug.LogError("storages[data.firstNonNullStorage] == null");
                if (str.hasEmissive == null) Debug.LogError("storages[data.firstNonNullStorage].hasEmissive == null");
                if (groupList[g] == null) Debug.LogError("group is null");

                var hasEmissive = str.hasEmissive.Count > groupList[g].id && str.hasEmissive[groupList[g].id];

                bool vertexBake = groupList[g].mode == BakeryLightmapGroup.ftLMGroupMode.Vertex;

                int res = groupList[g].resolution;
                if (vertexBake)
                {
                    if (groupList[g].totalVertexCount == 0)
                    {
                        DebugLogError("Vertex lightmap group " + groupList[g].name + " has 0 static vertices. Make sure objects inside the group don't all have Scale In Lightmap == 0.");
                        CloseAllFiles();
                        userCanceled = true;
                        ProgressBarEnd(true);
                        yield break;
                    }
                    int atlasTexSize = (int)Mathf.Ceil(Mathf.Sqrt((float)groupList[g].totalVertexCount));
                    atlasTexSize = (int)Mathf.Ceil(atlasTexSize / (float)ftRenderLightmap.tileSize) * ftRenderLightmap.tileSize;
                    res = atlasTexSize;
                }

                var bakeWithNormalMaps = (groupList[g].renderDirMode == BakeryLightmapGroup.RenderDirMode.BakedNormalMaps) ?
                    true : (ftRenderLightmap.renderDirMode == ftRenderLightmap.RenderDirMode.BakedNormalMaps);

                if (groupList[g].probes) bakeWithNormalMaps = false;

                bool hasMetaAlpha = false;

                ftUVGBufferGen.StartUVGBuffer(res, hasEmissive, bakeWithNormalMaps);
                for(int i=0; i<objsToWrite.Count; i++)
                {
                    var obj = objsToWrite[i];
                    var lmgroup = objsToWriteGroup[i];
                    if (lmgroup == null) continue;
                    if (lmgroup.id != groupList[g].id) continue;
                    if (obj.GetComponent<BakeryLightMesh>()) continue;
                    var bakedMesh = GetSharedMeshBaked(obj);
                    ftUVGBufferGen.RenderUVGBuffer(bakedMesh,
                        GetValidRenderer(obj),
                        objsToWriteScaleOffset[i],
                        obj.transform,
                        vertexBake,
                        objsToWriteUVOverride[i],
                        bakeWithNormalMaps && !exportTerrainAsHeightmap && obj.name == "__ExportTerrain",
                        objsToWriteHasMetaAlpha[i]);

                    if (objsToWriteHasMetaAlpha[i]) hasMetaAlpha = true;
                }
                ftUVGBufferGen.EndUVGBuffer();

                var albedo = ftUVGBufferGen.texAlbedo;
                var emissive = ftUVGBufferGen.texEmissive;
                var normal = ftUVGBufferGen.texNormal;
                var alpha = ftUVGBufferGen.texAlpha;
                if (hasEmissive)
                {
                    //albedo = ftUVGBufferGen.GetAlbedoWithoutEmissive(ftUVGBufferGen.texAlbedo, ftUVGBufferGen.texEmissive);
                    //if ((unityVersionMajor == 2017 && unityVersionMinor < 2) || unityVersionMajor < 2017)
                    //{
#if UNITY_2017_2_OR_NEWER
#else
                        // Unity before 2017.2: emissive packed to RGBM
                        // Unity after 2017.2: linear emissive
                        emissive = ftUVGBufferGen.DecodeFromRGBM(emissive);
#endif
                    //}
                    if (ftRenderLightmap.hackEmissiveBoost != 1.0f)
                    {
                        ftUVGBufferGen.Multiply(emissive, ftRenderLightmap.hackEmissiveBoost);
                    }
                    if (!vertexBake) ftUVGBufferGen.Dilate(emissive, 1);
                }
                if (!vertexBake) ftUVGBufferGen.Dilate(albedo, 0);

                if (isDX11)
                {
                    SaveGBufferMap(albedo.GetNativeTexturePtr(),
                        scenePath + "/uvalbedo_" + groupList[g].name + (ftRenderLightmap.compressedGBuffer ? ".lz4" : ".dds"),
                        ftRenderLightmap.compressedGBuffer);
                    GL.IssuePluginEvent(5);
                    yield return null;
                }
                else
                {
                    var bytes = InputBytesFromTex(albedo);
                    SaveGBufferMapFromRAM(bytes, bytes.Length,
                        scenePath + "/uvalbedo_" + groupList[g].name + (ftRenderLightmap.compressedGBuffer ? ".lz4" : ".dds"),
                        ftRenderLightmap.compressedGBuffer);
                }
                DestroyImmediate(albedo);
                //if (g==2) storage.debugTex = emissive;

                if (hasEmissive)
                {
                    if (isDX11)
                    {
                        SaveGBufferMap(emissive.GetNativeTexturePtr(),
                            scenePath + "/uvemissive_" + groupList[g].name + (ftRenderLightmap.compressedGBuffer ? ".lz4" : ".dds"),
                            ftRenderLightmap.compressedGBuffer);
                        GL.IssuePluginEvent(5);
                        yield return null;
                    }
                    else
                    {
                        var bytes = InputBytesFromTex(emissive, TexInputType.HalfColor);
                        SaveGBufferMapFromRAM(bytes, bytes.Length,
                            scenePath + "/uvemissive_" + groupList[g].name + (ftRenderLightmap.compressedGBuffer ? ".lz4" : ".dds"),
                            ftRenderLightmap.compressedGBuffer);
                    }

                    if (ftRenderLightmap.clientMode) ftClient.serverFileList.Add("uvemissive_" + groupList[g].name + (ftRenderLightmap.compressedGBuffer ? ".lz4" : ".dds"));
                    DestroyImmediate(emissive);
                }

                if (bakeWithNormalMaps)
                {
                    if (isDX11)
                    {
                        SaveGBufferMap(normal.GetNativeTexturePtr(),
                            scenePath + "/uvnormal_" + groupList[g].name + (ftRenderLightmap.compressedGBuffer ? ".lz4" : ".dds"),
                            ftRenderLightmap.compressedGBuffer);
                        GL.IssuePluginEvent(5);
                        yield return null;
                    }
                    else
                    {
                        var bytes = InputBytesFromTex(normal);
                        SaveGBufferMapFromRAM(bytes, bytes.Length,
                            scenePath + "/uvnormal_" + groupList[g].name + (ftRenderLightmap.compressedGBuffer ? ".lz4" : ".dds"),
                            ftRenderLightmap.compressedGBuffer);
                    }
                    DestroyImmediate(normal);
                }

                if (hasMetaAlpha)
                {
                    for(int i=0; i<lmAlphaListTex.Count; i++)
                    {
                        if (lmAlphaListTex[i] == null) // must be meta alpha
                        {
                            int alphaLMID = lmAlphaChannelList[i];
                            if (alphaLMID != groupList[g].id) continue; // must link to the same LMID

                            // Patch with the new alpha texture
                            lmAlphaListTex[i] = alpha;
                            lmAlphaList[i] = alpha.GetNativeTexturePtr();
                            if (nonDX11) lmAlphaListRAM[i] = InputDataFromTex(alpha);
                            lmAlphaChannelList[i] = 3;
                        }
                    }
                }
            }
        }

        ProgressBarShow(exportShaderColors ? "Exporting scene - alpha buffer..." : "Exporting scene - UV GBuffer and alpha buffer...", 0.55f, false);
        if (userCanceled)
        {
            CloseAllFiles();
            userCanceled = true;
            ProgressBarEnd(true);
            yield break;
        }
        yield return null;

        InitShaders();
        LoadScene(scenePath);

        // Force load textures to VRAM
        var forceRt = new RenderTexture(1, 1, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.sRGB);
        var forceTex = new Texture2D(1, 1, TextureFormat.ARGB32, false, false);
        if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.Direct3D11)
        {
            if (!exportShaderColors)
            {
                for(int i=0; i<lmAlbedoListTex.Count; i++)
                {
                    Graphics.Blit(lmAlbedoListTex[i] as Texture2D, forceRt);
                    Graphics.SetRenderTarget(forceRt);
                    forceTex.ReadPixels(new Rect(0,0,1, 1), 0, 0, true);
                    forceTex.Apply();
                    lmAlbedoList[i] = lmAlbedoListTex[i].GetNativeTexturePtr();
                }
            }
            for(int i=0; i<lmAlphaListTex.Count; i++)
            {
                Graphics.Blit(lmAlphaListTex[i] as Texture2D, forceRt);
                Graphics.SetRenderTarget(forceRt);
                forceTex.ReadPixels(new Rect(0,0,1, 1), 0, 0, true);
                forceTex.Apply();
                lmAlphaList[i] = lmAlphaListTex[i].GetNativeTexturePtr();
            }
        }

        if (exportShaderColors)
        {
#if USE_TERRAINS
            if (terrainObjectToActual.Count > 0)
            {
                if (isDX11)
                {
                    var terrainObjectToHeightMapPtr = new IntPtr[terrainObjectToHeightMap.Count];
                    for(int i=0; i<terrainObjectToHeightMap.Count; i++)
                    {
                        Graphics.Blit(terrainObjectToHeightMap[i] as Texture2D, forceRt);
                        Graphics.SetRenderTarget(forceRt);
                        forceTex.ReadPixels(new Rect(0,0,1, 1), 0, 0, true);
                        forceTex.Apply();
                        terrainObjectToHeightMapPtr[i] = terrainObjectToHeightMap[i].GetNativeTexturePtr();
                    }
                    SetAlbedos(terrainObjectToHeightMap.Count, terrainObjectToHeightMapPtr);
                    int cerr = CopyAlbedos();
                    if (cerr != 0)
                    {
                        DebugLogError("Failed to copy textures (" + cerr + ")");
                        CloseAllFiles();
                        userCanceled = true;
                        ProgressBarEnd(true);
                        yield break;
                    }
                }
                else
                {
                    int cerr = CopyHeightmapsFromRAM(terrainObjectToHeightMapRAM.Count, terrainObjectToHeightMapRAM.ToArray());
                    if (cerr != 0)
                    {
                        DebugLogError("Failed to copy textures from RAM (" + cerr + ")");
                        CloseAllFiles();
                        userCanceled = true;
                        ProgressBarEnd(true);
                        yield break;
                    }
                }
            }
            else
#endif
            {
                SetAlbedos(0, null);
            }
        }
        else
        {
            SetAlbedos(lmAlbedoList.Count, lmAlbedoList.ToArray());
        }

        var lmAlphaListRAMHandle = new GCHandle();
        if (isDX11)
        {
            // Pass texture objects directly
            SetAlphas(lmAlphaList.Count, lmAlphaList.ToArray(), lmAlphaRefList.ToArray(), lmAlphaChannelList.ToArray(), sceneLodsUsed, flipAlpha);
        }
        else
        {
            // Pass via RAM
            var lmAlphaListRAMArray = lmAlphaListRAM.ToArray();
            lmAlphaListRAMHandle = GCHandle.Alloc(lmAlphaListRAMArray, GCHandleType.Pinned);
            SetAlphasFromRAM(lmAlphaListRAM.Count, lmAlphaListRAMHandle.AddrOfPinnedObject(), lmAlphaRefList.ToArray(), lmAlphaChannelList.ToArray(), sceneLodsUsed, flipAlpha);
        }

        GL.IssuePluginEvent(6); // render alpha buffer
        int uerr = 0;
        while(uerr == 0)
        {
            uerr = GetABGErrorCode();
            yield return null;
        }

        if (nonDX11) lmAlphaListRAMHandle.Free();

        if (uerr != 0 && uerr != 99999)
        {
            DebugLogError("ftGenerateAlphaBuffer error: " + uerr);
            CloseAllFiles();
            userCanceled = true;
            ProgressBarEnd(true);
            yield break;
        }

        DestroyImmediate(forceTex);
        forceRt.Release();

        if (!renderTextures)
        {
            ProgressBarEnd(true);//false);
            yield break;
        }

        SetFixPos(false);//true); // do it manually
        SetCompression(ftRenderLightmap.compressedGBuffer);

        if (!exportShaderColors)
        {
            uerr = ftRenderUVGBuffer();
            if (uerr != 0)
            {
                DebugLogError("ftRenderUVGBuffer error: " + uerr);
                CloseAllFiles();
                userCanceled = true;
                ProgressBarEnd(true);
                yield break;
            }
        }

        ms = GetTime();
        DebugLogInfo("UVGB/fixPos/alpha time: " + ((ms - startMsU) / 1000.0) + " seconds");

        ProgressBarEnd(true);

        DebugLogInfo("Scene export finished");
    }

    int countChildrenFlat(Transform tform)
    {
        int count = 1;
        foreach(Transform t in tform)
        {
            count += countChildrenFlat(t);
        }
        return count;
    }
}

#endif
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftBuildGraphics.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftBuildLights.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6d2a81f0f9d2d0c49bc8e08c6e18e72c
# ASMDEF: BakeryEditorAssembly.dll
# ---
#if UNITY_EDITOR

// Disable 'obsolete' warnings
#pragma warning disable 0618

#define SRGBCONVERT
//#define OPTIMIZEDAREA // BSP
#define OPTIMIZEDAREA2 // efficient weighted sampling
#define LAUNCH_VIA_DLL

//#define DEBUGMESHDATA

using UnityEngine;
using UnityEditor;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using UnityEngine.Rendering;
using System.Reflection;

public class ftBuildLights
{
    static Dictionary<UnityEngine.Object, int> tex2hash;
    static Dictionary<string, bool> lightSaved;
    static bool allowOverwrite = false;

    struct SavedLight
    {
        public float totalWorldAreaHalf;
        public int lmid;
        public int samples;
        public string fname, name;
    }

    static List<SavedLight> savedLights;
    internal static HashSet<BakeryLightMesh> appended;
    static int areaLightCounter;

    static System.Type texUtil;
    static MethodInfo texUtil_GetUsage;

    static public void InitMaps(bool overwrite)
    {
        allowOverwrite = overwrite;
        tex2hash = new Dictionary<UnityEngine.Object, int>();
        lightSaved = new Dictionary<string, bool>();

        savedLights = new List<SavedLight>();
        appended = new HashSet<BakeryLightMesh>();
        areaLightCounter = -2;
    }

    static public void BuildDirectLight(BakeryDirectLight obj, int SAMPLES, bool ignoreNormal = false, string outName = "direct.bin")
    {
        if (!allowOverwrite && lightSaved.ContainsKey(outName)) return;
        lightSaved[outName] = true;

        var folder = ftBuildGraphics.scenePath;//Directory.GetParent(Application.dataPath).FullName + "/frender";
        if (!Directory.Exists(folder)) Directory.CreateDirectory(folder);
        var f = new BinaryWriter(File.Open(folder + "/" + outName, FileMode.Create));
        if (ftRenderLightmap.clientMode) ftClient.serverFileList.Add(outName);

        f.Write(obj.transform.forward.x);
        f.Write(obj.transform.forward.y);
        f.Write(obj.transform.forward.z);

        #if SRGBCONVERT
            f.Write(obj.color.linear.r * obj.intensity);
            f.Write(obj.color.linear.g * obj.intensity);
            f.Write(obj.color.linear.b * obj.intensity);
        #else
            f.Write(obj.color.r * obj.intensity);
            f.Write(obj.color.g * obj.intensity);
            f.Write(obj.color.b * obj.intensity);
        #endif

        f.Write(obj.shadowSpread);
        f.Write(SAMPLES);

        f.Write(obj.cloudShadowTilingX);
        f.Write(obj.cloudShadowTilingY);
        f.Write(obj.cloudShadowOffsetX);
        f.Write(obj.cloudShadowOffsetY);

        f.Write(ignoreNormal);
        f.Write((short)0);

        if (obj.cloudShadow != null)
        {
            var tex = obj.cloudShadow;
            int existingTexHash;
            string texName = "";
            if (!tex2hash.TryGetValue(tex, out existingTexHash)) existingTexHash = -1;
            if (existingTexHash < 0)
            {
                int texHash = tex.GetHashCode();
                tex2hash[tex] = texHash;
                existingTexHash = texHash;
            }
            texName = GetTempTexName(tex, "cookie_");

            // Save original texture to RGBA32F DDS
            if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.Direct3D11)
            {
                ftBuildGraphics.InitShaders();
                ftBuildGraphics.SaveCookie((tex as Texture2D).GetNativeTexturePtr(),
                        folder + "/" + texName
                        );
                GL.IssuePluginEvent(4);
            }
            else
            {
                var a = ftBuildGraphics.InputDataFromTex(tex, ftBuildGraphics.TexInputType.FloatColor);
                ftBuildGraphics.SaveCookieFromRAM(a,
                        folder + "/" + texName
                        );
            }
            if (ftRenderLightmap.clientMode) ftClient.serverFileList.Add(texName);

            f.Write(texName);
        }
        else
        {
            f.Write((byte)0);
        }

        f.Close();
    }

    static public void BuildSkyLight(BakerySkyLight obj, int SAMPLES, bool texDirty, string outName = "sky.bin")
    {
        if (!allowOverwrite && lightSaved.ContainsKey(outName)) return;
        lightSaved[outName] = true;

        var folder = ftBuildGraphics.scenePath;//Directory.GetParent(Application.dataPath).FullName + "/frender";
        if (!Directory.Exists(folder)) Directory.CreateDirectory(folder);
        var f = new BinaryWriter(File.Open(folder + "/" + outName, FileMode.Create));
        if (ftRenderLightmap.clientMode) ftClient.serverFileList.Add(outName);

        #if SRGBCONVERT
            f.Write(obj.color.linear.r * obj.intensity);
            f.Write(obj.color.linear.g * obj.intensity);
            f.Write(obj.color.linear.b * obj.intensity);
        #else
            f.Write(obj.color.r * obj.intensity);
            f.Write(obj.color.g * obj.intensity);
            f.Write(obj.color.b * obj.intensity);
        #endif

        f.Write(SAMPLES);
        f.Write(obj.hemispherical);

        var texName = obj.cubemap != null ? GetTempTexName(obj.cubemap, "sky") : "sky.dds";
        f.Write(texName);

        f.Close();

        if (texDirty)
        {
            /*
            // Disable cubemap compression, so texture is half-float
            var importer = AssetImporter.GetAtPath(AssetDatabase.GetAssetPath(obj.cubemap)) as TextureImporter;
            if (importer.textureCompression != TextureImporterCompression.Uncompressed)
            {
                importer.textureCompression = TextureImporterCompression.Uncompressed;
                importer.SaveAndReimport();
            }
            */

            var tform = obj.transform;
            var rh = tform.right;
            var up = tform.up;
            var fw = tform.forward;

            bool isDoubleLDR = false;
            bool isRGBM = false;

            // Find out texture encoding
            // Even if pixel format is the same, different encoding rules (dLDR, RGBM) can be used
            if (texUtil == null) texUtil = Assembly.Load("UnityEditor.dll").GetType("UnityEditor.TextureUtil");
            if (texUtil == null)
            {
                Debug.LogError("TextureUtil class cannot be found");
            }
            else
            {
                if (texUtil_GetUsage == null) texUtil_GetUsage = texUtil.GetMethod("GetUsageMode", BindingFlags.Static | BindingFlags.Public);
                if (texUtil_GetUsage == null)
                {
                    Debug.LogError("TextureUtil::GetUsage cannot be found");
                }
                else
                {
                    int usage = (int)texUtil_GetUsage.Invoke(null, new object[]{obj.cubemap});
                    isDoubleLDR = usage == 1 // BakedLightmapDoubleLDR
                               || usage == 7;// DoubleLDR
                    isRGBM = usage == 5;     // RGBMEncoded
                }
            }

            bool isLinear = PlayerSettings.colorSpace == ColorSpace.Linear;

            if (obj.correctRotation)
            {
                if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.Direct3D11)
                {
                    ftBuildGraphics.InitShaders();
                    ftBuildGraphics.SaveSky(obj.cubemap.GetNativeTexturePtr(),
                        rh.x,
                        up.x,
                        fw.x,
                        rh.y,
                        up.y,
                        fw.y,
                        rh.z,
                        up.z,
                        fw.z,
                        folder + "/" + texName,
                        isLinear,
                        isDoubleLDR,
                        isRGBM
                        );
                    GL.IssuePluginEvent(3); // convert cubemap to small lat/lon DDS
                }
                else
                {
                    var a = ftBuildGraphics.InputDataFromCubemap(obj.cubemap as Texture, Matrix4x4.TRS(Vector3.zero, obj.transform.rotation, Vector3.one).transpose, isLinear, isDoubleLDR, ftBuildGraphics.TexInputType.FloatColor);
                    ftBuildGraphics.SaveCookieFromRAM(a,
                            folder + "/" + texName
                            );
                }
            }
            else
            {
                if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.Direct3D11)
                {
                    ftBuildGraphics.InitShaders();
                    ftBuildGraphics.SaveSky(obj.cubemap.GetNativeTexturePtr(),
                        obj.transform.right.x,
                        obj.transform.right.y,
                        obj.transform.right.z,
                        obj.transform.up.x,
                        obj.transform.up.y,
                        obj.transform.up.z,
                        obj.transform.forward.x,
                        obj.transform.forward.y,
                        obj.transform.forward.z,
                        folder + "/" + texName,
                        isLinear,
                        isDoubleLDR,
                        isRGBM
                        );
                    GL.IssuePluginEvent(3); // convert cubemap to small lat/lon DDS
                }
                else
                {
                    var a = ftBuildGraphics.InputDataFromCubemap(obj.cubemap as Texture, Matrix4x4.TRS(Vector3.zero, obj.transform.rotation, Vector3.one), isLinear, isDoubleLDR, ftBuildGraphics.TexInputType.FloatColor);
                    ftBuildGraphics.SaveCookieFromRAM(a,
                            folder + "/" + texName
                            );
                }
            }

            if (ftRenderLightmap.clientMode) ftClient.serverFileList.Add(texName);
        }
    }

#if OPTIMIZEDAREA

    class BSPNode
    {
        public BSPNode left, right;
        public float probabilityDivide = 0.0f;
        public List<int> leafIndices;
    };

    static int GetRandomTriFromBSP(BSPNode bspNode, float rndValue)
    {
        //Debug.LogError(bspNode.probabilityDivide);
        if (bspNode.leafIndices != null)
        {
            return bspNode.leafIndices[Random.Range(0, bspNode.leafIndices.Count)];
        }
        if (rndValue < bspNode.probabilityDivide)
        {
            return GetRandomTriFromBSP(bspNode.left, rndValue);// != null ? bspNode.left : bspNode.right, rndValue);
        }
        else
        {
            return GetRandomTriFromBSP(bspNode.right, rndValue);// != null ? bspNode.right : bspNode.left, rndValue);
        }
    }

    static BSPNode BuildProbabilityBSP(int[] triIndices, float[] area, int start, int end, int depth, float parentGlobalOffset, float parentGlobalEnd)
    {
        if (depth > 100) return null;

        var bspNode = new BSPNode();

        int startIndex = triIndices[start];
        int endIndex = triIndices[end];

        // Decide where to split
        //float probabilityDivide = (area[startIndex] + area[endIndex]) * 0.5f;/// (end - start);// * 0.5f;
        float probabilitySum = 0;
        int divisor = start;
        for(int i=start; i<=end; i++)
        {
            int triIndex = triIndices[i];
            probabilitySum += area[triIndex];
            //if (probabilitySum >= probabilityDivide)
            //if (area[triIndex] >= probabilityDivide)
            {
                //divisor = i;
                //break;
            }
        }
        float probabilityDivide = probabilitySum / (end - start);

        //probabilitySum = 0;
        for(int i=start; i<=end; i++)
        {
            int triIndex = triIndices[i];
            //probabilitySum += area[triIndex];
            //if (probabilitySum >= probabilityDivide)
            if (area[triIndex] >= probabilityDivide)
            {
                divisor = i - 1;
                break;
            }
        }

        if (divisor < 0) divisor = 0;

        int beforeDivisorIndex = divisor > 0 ? triIndices[divisor-1] : 0;
        int divisorIndex = triIndices[divisor];

        //Debug.LogError(start+" "+end+" "+divisor+" "+probabilityDivide);

        /*
        // Create new BSP depth layer, if needed
        if (layers.Count <= depth)
        {
            int numElements = triIndices.Length; // conservative?
            layers[depth] = new int[numElements];
        }
        */

        //bspNode.probabilityDivide = probabilityDivide;
        float probabilitySumLeft = 0;
        float probabilitySumRight = 0;
        for(int i=start; i<=end; i++)
        {
            int triIndex = triIndices[i];
            if (i <= divisor)
            {
                probabilitySumLeft += area[triIndex];
            }
            else
            {
                probabilitySumRight += area[triIndex];
            }
        }
        //probabilitySumLeft /= divisor - start + 1;
        //probabilitySumRight /= end - divisor;
        float probabilityLength = probabilitySumLeft + probabilitySumRight;
        //bspNode.probabilityDivide = parentGlobalOffset + (probabilitySumLeft / probabilityLength) * parentGlobalPercent;
        bspNode.probabilityDivide = Mathf.Lerp(parentGlobalOffset, parentGlobalEnd, probabilitySumLeft / probabilityLength);

        //bspNode.leafIndex = startIndex;
        bool isLeaf = true;

        if (divisor != start && divisor != end)
        {
            //Debug.LogError("["+depth+"] Divide global " + bspNode.probabilityDivide+" "+start+" "+divisor+" "+end+" "+probabilitySumLeft + " "+probabilitySumRight+" "+parentGlobalOffset+" "+parentGlobalEnd);

            // Split left part
            int newStart = start;
            int newEnd = divisor > 0 ? divisor : 0;
            //Debug.LogError("left");
            bspNode.left = BuildProbabilityBSP(triIndices, area, newStart, newEnd, depth + 1, parentGlobalOffset, bspNode.probabilityDivide);

            // Split right part
            newStart = divisor + 1;
            newEnd = end;
            //Debug.LogError("right");
            bspNode.right = BuildProbabilityBSP(triIndices, area, newStart, newEnd, depth + 1, bspNode.probabilityDivide, parentGlobalEnd);

            isLeaf = false;
        }

        if (isLeaf)
        {
            bspNode.leafIndices = new List<int>();
            string l = "";
            for(int i=start; i<=end; i++)
            {
                int triIndex = triIndices[i];
                bspNode.leafIndices.Add(triIndex);
                l += area[triIndex] + ", ";
            }
            //Debug.LogError("Leaf: " + l);
        }

        return bspNode;
    }
#endif

    static public float BuildLight(BakeryLightMesh obj, int SAMPLES, Vector3[] corners, string outName = "lights.bin",
        List<Vector3> vplData = null)
    {
        if (!allowOverwrite && lightSaved.ContainsKey(outName)) return 0.0f;
        lightSaved[outName] = true;

        var folder = ftBuildGraphics.scenePath;//Directory.GetParent(Application.dataPath).FullName + "/frender";
        if (!Directory.Exists(folder)) Directory.CreateDirectory(folder);
        BinaryWriter f = null;

        bool append = false;
        int lightToAppendID = 0;
        float appendArea = 0;
        if (ftRenderLightmap.batchAreaLightSampleLimit > 0)
        {
            for(int i=0; i<savedLights.Count; i++)
            {
                if (obj.lmid != savedLights[i].lmid) continue; // lmid must be computed at this point

                if (savedLights[i].samples + obj.samples > ftRenderLightmap.batchAreaLightSampleLimit) continue;

                append = true;
                lightToAppendID = i;

                int newSamples = savedLights[i].samples + obj.samples;
                appendArea = savedLights[i].totalWorldAreaHalf;

                f = new BinaryWriter(File.Open(folder + "/" + savedLights[i].fname, FileMode.Open, FileAccess.Write));
                f.BaseStream.Seek(8, SeekOrigin.Begin);
                f.Write(obj.shadowmaskFalloff ? -newSamples : newSamples);
                f.BaseStream.Seek(12 + (obj.texture != null ? 9 : 6)*4 * savedLights[i].samples, SeekOrigin.Begin);

                var sl = savedLights[i];
                sl.samples = newSamples;
                savedLights[i] = sl;

                //Debug.LogError("Append "+obj.name+" to "+savedLights[i].name);
            }
        }

        if (!append)
        {
            f = new BinaryWriter(File.Open(folder + "/" + outName, FileMode.Create));
            if (ftRenderLightmap.clientMode) ftClient.serverFileList.Add(outName);
        }

        if (!append) f.Write(1);

        Mesh mesh = null;
        var tform = obj.transform;
        Vector3[] verts;
        Vector2[] uv = null;
        int[] indices;
        int tris;
        if (corners == null)
        {
            mesh = ftBuildGraphics.GetSharedMeshBaked(obj.gameObject);
            verts = mesh.vertices;
            indices = mesh.triangles;
            tris = indices.Length / 3;
            if (obj.texture != null) uv = mesh.uv;
        }
        else
        {
            verts = corners;
            indices = new int[6];
            indices[0] = 2;
            indices[1] = 1;
            indices[2] = 0;
            indices[3] = 0;
            indices[4] = 3;
            indices[5] = 2;
            tris = 2;
            if (obj.texture != null)
            {
                uv = new Vector2[4];
                uv[0] = new Vector2(0,0);
                uv[1] = new Vector2(0,1);
                uv[2] = new Vector2(1,1);
                uv[3] = new Vector2(1,0);
            }
        }

        float[] area = new float[tris];
#if (OPTIMIZEDAREA || OPTIMIZEDAREA2)
#else
        float minArea = float.MaxValue;
        float maxArea = -float.MaxValue;
#endif
        float totalWorldArea = 0;

        //Vector2[] uv = null;
        int downsampleRes = 0;
        float[] pixels = null;
        string texName = "";
        if (obj.texture != null)
        {
            //uv = mesh.uv;
            var tex = obj.texture;

            // Save original texture to RGBA32F DDS
            int existingTexHash;
            if (!tex2hash.TryGetValue(tex, out existingTexHash)) existingTexHash = -1;
            if (existingTexHash < 0)
            {
                int texHash = tex.GetHashCode();
                tex2hash[tex] = texHash;
                existingTexHash = texHash;
            }
            texName = "areatex_" + existingTexHash + ".dds";

            if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.Direct3D11)
            {
                ftBuildGraphics.InitShaders();
                ftBuildGraphics.SaveCookie(tex.GetNativeTexturePtr(),
                        folder + "/" + texName
                        );
                GL.IssuePluginEvent(4);
            }
            else
            {
                var a = ftBuildGraphics.InputDataFromTex(tex, ftBuildGraphics.TexInputType.FloatColor);
                ftBuildGraphics.SaveCookieFromRAM(a,
                        folder + "/" + texName
                        );
            }
            if (ftRenderLightmap.clientMode) ftClient.serverFileList.Add(texName);

            // Get downsampled (via mips) texture
            downsampleRes = (int)Mathf.Sqrt(SAMPLES);
            if (downsampleRes == 0) downsampleRes = 1;
            var downsampleRT = new RenderTexture(downsampleRes, downsampleRes, 0, RenderTextureFormat.ARGBFloat, RenderTextureReadWrite.Linear);
            var downsampleTex = new Texture2D(downsampleRes, downsampleRes, TextureFormat.RGBAFloat, false, true);
            Graphics.Blit(tex, downsampleRT);
            Graphics.SetRenderTarget(downsampleRT);
            downsampleTex.ReadPixels(new Rect(0,0,downsampleRes,downsampleRes), 0, 0, false);
            downsampleTex.Apply();
            var bytes = downsampleTex.GetRawTextureData();
            RenderTexture.active = null;
            Object.DestroyImmediate(downsampleTex);
            downsampleRT.Release();
            pixels = new float[bytes.Length / 4];
            System.Buffer.BlockCopy(bytes, 0, pixels, 0, bytes.Length);
        }

        for(int j=0; j<tris; j++)
        {
            var v1 = verts[indices[j*3]];
            var v2 = verts[indices[j*3 + 1]];
            var v3 = verts[indices[j*3 + 2]];

            if (corners == null)
            {
                v1 = tform.TransformPoint(v1);
                v2 = tform.TransformPoint(v2);
                v3 = tform.TransformPoint(v3);
            }

#if (OPTIMIZEDAREA || OPTIMIZEDAREA2)
            area[j] = Vector3.Cross(v2 - v1, v3 - v1).magnitude;
            if (area[j] > 0) totalWorldArea += area[j];
#else
            area[j] = Vector3.Cross(v2 - v1, v3 - v1).magnitude;
            if (area[j] > 0) totalWorldArea += area[j];
            if (area[j] > 0)
            {
                minArea = Mathf.Min(minArea, area[j]);
                maxArea = Mathf.Max(maxArea, area[j]);
            }
#endif
        }

#if OPTIMIZEDAREA2

        // New 2
        var randomTriIndices = new int[SAMPLES];
        // When an area light is with a width or height of 0, this will avoid an OOR exception (this will keep the baking running instead of crashing it...)
        float invTotalArea = totalWorldArea == 0 ? 0 : (1.0f / (totalWorldArea * 0.5f));
        float sumWeights = 0.0f;
        for(int j=0; j<tris; j++)
        {
            area[j] *= invTotalArea * 0.5f;
            sumWeights += area[j];
        }

        float sampleWidth = sumWeights / SAMPLES;
        int outputSampleIx = -1;
        float weightSoFar = -Random.value * sampleWidth;
        for(int i=0; i<SAMPLES; i++)
        {
            float sampleDist = i * sampleWidth;
            while(sampleDist >= weightSoFar && outputSampleIx + 1 < tris)
            {
                weightSoFar += area[++outputSampleIx];
            }
            randomTriIndices[i] = outputSampleIx;
        }

#elif OPTIMIZEDAREA

        // New

        // Collect indices to triangles
        var triIndices = new int[tris];
        float invTotalArea = 1.0f / (totalWorldArea * 0.5f);
        for(int j=0; j<tris; j++)
        {
            area[j] *= invTotalArea * 0.5f;
            triIndices[j] = j;
        }

        // Sort triangle indices by area (probability)
        // Smaller -> Larger
        System.Array.Sort(triIndices, delegate(int a, int b)
        {
            return area[a].CompareTo(area[b]);
        });

        // Put triangle indices into a BSP tree based on area
        int start = 0;
        int end = triIndices.Length - 1;
        //var bspLayers = new List<int[]>(); // tri index array per depth level
        var bspRoot = BuildProbabilityBSP(triIndices, area, start, end, 0, 0.0f, 1.0f);

#else
        // Legacy
        if (maxArea / minArea > 65535)
        {
            minArea = maxArea / 65535;
        }
        float invMinArea = 1.0f / minArea;
        for(int j=0; j<tris; j++)
        {
            area[j] *= invMinArea;
            area[j] = Mathf.Round(area[j]);
        }

        int skipped = 0;
        var uniformTriList = new List<int>();
        for(int j=0; j<tris; j++)
        {
            var tarea = area[j];
            if (tarea > 0 && tarea < 65536)
            {
                for(int k=0; k<tarea; k++)
                {
                    uniformTriList.Add(j);
                }
            }
            else
            {
                skipped++;
            }
        }

        if (skipped > 0) Debug.LogError("Skipped " + skipped + " invalid triangles out of " + tris + " on LightMesh " + obj.name + " (area is too big?)");
#endif


        if (!append) f.Write(obj.shadowmask ? 0 : obj.samples2);
        if (!append) f.Write(obj.shadowmaskFalloff ? -SAMPLES : SAMPLES);
        Vector3 trinormal;
        for(int sample=0; sample<SAMPLES; sample++)
        {
#if OPTIMIZEDAREA2
            int tri = randomTriIndices[sample];

#elif OPTIMIZEDAREA
            int tri = GetRandomTriFromBSP(bspRoot, Random.value);
            //Debug.LogError(tri);
#else
            int rndTri = Random.Range(0, uniformTriList.Count);
            int tri = uniformTriList.Count > 0 ? uniformTriList[rndTri] : 0;
#endif

            var rndA = Random.value;
            var rndB = Random.value;
            var rndC = Random.value;

#if DEBUGMESHDATA
            if ((tri*3+2) >= indices.Length)
            {
                Debug.LogError("tri*3+2 >= indices.Length for " + obj.name);
                return 0.0f;
            }
            else if (indices[tri*3+2] >= verts.Length)
            {
                Debug.LogError("indices[tri*3+2] >= verts.Length for " + obj.name);
                return 0.0f;
            }
#endif

            var A = verts[indices[tri*3]];
            var B = verts[indices[tri*3+1]];
            var C = verts[indices[tri*3+2]];
            var point = (1.0f - Mathf.Sqrt(rndA)) * A + (Mathf.Sqrt(rndA) * (1.0f - rndB)) * B + (Mathf.Sqrt(rndA) * rndB) * C;

            if (corners == null) point = tform.TransformPoint(point);

            trinormal = Vector3.Cross(A - B, B - C);//.normalized;
            float len = Mathf.Sqrt(trinormal.x*trinormal.x + trinormal.y*trinormal.y + trinormal.z*trinormal.z);
            trinormal /= len;

            if (corners == null) trinormal = tform.TransformDirection(trinormal);

            point += trinormal * 0.001f;

            f.Write(point.x);
            f.Write(point.y);
            f.Write(point.z);
            if (vplData != null) vplData.Add(point);

            f.Write(trinormal.x);
            f.Write(trinormal.y);
            f.Write(trinormal.z);
            if (vplData != null) vplData.Add(trinormal);

            if (obj.texture != null)
            {
                var tA = uv[indices[tri*3]];
                var tB = uv[indices[tri*3+1]];
                var tC = uv[indices[tri*3+2]];
                var tpoint = (1.0f - Mathf.Sqrt(rndA)) * tA + (Mathf.Sqrt(rndA) * (1.0f - rndB)) * tB + (Mathf.Sqrt(rndA) * rndB) * tC;
                int tx = (int)((tpoint.x - Mathf.Floor(tpoint.x)) * (downsampleRes - 1));
                int ty = (int)((tpoint.y - Mathf.Floor(tpoint.y)) * (downsampleRes - 1));
                int pixelIndex = ty * downsampleRes + tx;
                if (pixelIndex*4+2 < pixels.Length)
                {
                    float cr = pixels[pixelIndex * 4];
                    float cg = pixels[pixelIndex * 4 + 1];
                    float cb = pixels[pixelIndex * 4 + 2];
                    f.Write(cr);
                    f.Write(cg);
                    f.Write(cb);
                    if (vplData != null) vplData.Add(new Vector3(cr, cg, cb));
                }
                else
                {
                    f.Write(0.0f);
                    f.Write(0.0f);
                    f.Write(0.0f);
                    if (vplData != null) vplData.Add(Vector3.one);
                }
            }
            else if (vplData != null)
            {
                vplData.Add(Vector3.one);
            }

            //var g = GameObject.CreatePrimitive(PrimitiveType.Sphere);
            //g.transform.position = point;
            //g.transform.localScale = new Vector3(0.01f, 0.01f, 0.01f);
        }

        f.Write(obj.cutoff);
        f.Write(totalWorldArea * 0.5f + appendArea);

        #if SRGBCONVERT
            f.Write(obj.color.linear.r * obj.intensity);
            f.Write(obj.color.linear.g * obj.intensity);
            f.Write(obj.color.linear.b * obj.intensity);
        #else
            f.Write(obj.color.r * obj.intensity);
            f.Write(obj.color.g * obj.intensity);
            f.Write(obj.color.b * obj.intensity);
        #endif

        f.Write(obj.lmid);

        if (obj.texture != null)
        {
            f.Write(texName);
        }

        f.Close();

        if (ftRenderLightmap.batchAreaLightSampleLimit > 0)
        {
            if (append)
            {
                var sl = savedLights[lightToAppendID];
                sl.totalWorldAreaHalf += totalWorldArea * 0.5f;
                savedLights[lightToAppendID]  = sl;
            }
            else
            {
                var sl = new SavedLight();
                sl.samples = obj.samples;
                sl.fname = outName;
                sl.name = obj.name;
                sl.totalWorldAreaHalf = totalWorldArea * 0.5f;
                sl.lmid = obj.lmid;
                savedLights.Add(sl);
            }
        }

        if (!append)
        {
            obj.lmid = areaLightCounter;
            areaLightCounter--;
            //Debug.LogError("Set LMID to " + obj.lmid + " for "+obj.name);
        }
        else
        {
            obj.lmid = savedLights[lightToAppendID].lmid;
            //Debug.LogError("Copied LMID to " + obj.name + " from " + savedLights[lightToAppendID].name+ " ("+obj.lmid+")");
        }

        if (append) appended.Add(obj);

        return totalWorldArea * 0.5f;
    }

    static public string GetTempTexName(Object tex, string prefix = "cookie_")
    {
        int existingTexHash;
        if (!tex2hash.TryGetValue(tex, out existingTexHash)) existingTexHash = -1;
        if (existingTexHash < 0)
        {
            int texHash = tex.GetHashCode();
            tex2hash[tex] = texHash;
            existingTexHash = texHash;
        }
        return prefix + existingTexHash + ".dds";
    }

    static public bool BuildLight(BakeryPointLight obj, int SAMPLES, bool texDirty, bool ignoreNormal = false, string outName = "pointlight.bin")
    {
        if (!allowOverwrite && lightSaved.ContainsKey(outName)) return false;
        lightSaved[outName] = true;

        bool isError = false;

        var folder = ftBuildGraphics.scenePath;//Directory.GetParent(Application.dataPath).FullName + "/frender";
        if (!Directory.Exists(folder)) Directory.CreateDirectory(folder);
        var f = new BinaryWriter(File.Open(folder + "/" + outName, FileMode.Create));
        if (ftRenderLightmap.clientMode) ftClient.serverFileList.Add(outName);

        f.Write(SAMPLES);
        f.Write(obj.cutoff);

        float fakeDistMult = 1.0f;
        float falloffMinRadius = obj.falloffMinRadius;
        if (!obj.realisticFalloff)
        {
            fakeDistMult = (1.0f / obj.cutoff) * 5.0f;
            falloffMinRadius = 1;
        }
        f.Write(fakeDistMult);
        f.Write(falloffMinRadius);

        #if SRGBCONVERT
            f.Write(obj.color.linear.r * obj.intensity);
            f.Write(obj.color.linear.g * obj.intensity);
            f.Write(obj.color.linear.b * obj.intensity);
        #else
            f.Write(obj.color.r * obj.intensity);
            f.Write(obj.color.g * obj.intensity);
            f.Write(obj.color.b * obj.intensity);
        #endif

        var pos = obj.transform.position;

        f.Write(pos.x);
        f.Write(pos.y);
        f.Write(pos.z);

        f.Write(obj.shadowSpread);
        f.Write(ignoreNormal);

        bool isCookie = obj.projMode == BakeryPointLight.ftLightProjectionMode.Cookie && obj.cookie != null;
        bool isCone = obj.projMode == BakeryPointLight.ftLightProjectionMode.Cone;
        bool isCubemap = obj.projMode == BakeryPointLight.ftLightProjectionMode.Cubemap && obj.cubemap != null;
        bool isIES = obj.projMode == BakeryPointLight.ftLightProjectionMode.IES && obj.iesFile != null;

        int existingTexHash;
        string texName = "";
        UnityEngine.Object tex = null;
        if (isCookie || isCubemap || isIES)
        {
            if (isCookie)
            {
                tex = obj.cookie;
            }
            else if (isCubemap)
            {
                tex = obj.cubemap;
            }
            else
            {
                tex = obj.iesFile;
            }
            if (!tex2hash.TryGetValue(tex, out existingTexHash)) existingTexHash = -1;
            if (existingTexHash < 0)
            {
                int texHash = tex.GetHashCode();
                tex2hash[tex] = texHash;
                existingTexHash = texHash;
            }
            texName = "cookie_" + existingTexHash + ".dds";
        }

        if (isCone)
        {
            f.Write(obj.transform.forward.x);
            f.Write(obj.transform.forward.y);
            f.Write(obj.transform.forward.z);
            f.Write(obj.angle);
            f.Write(obj.innerAngle / 100.0f);
        }

        if (isCookie || isCubemap || isIES)
        {
            if (isIES && obj.directionMode == BakeryPointLight.Direction.PositiveZ)
            {
                f.Write(obj.transform.right.x);
                f.Write(obj.transform.right.y);
                f.Write(obj.transform.right.z);
                f.Write(-obj.transform.forward.x);
                f.Write(-obj.transform.forward.y);
                f.Write(-obj.transform.forward.z);
                f.Write(obj.transform.up.x);
                f.Write(obj.transform.up.y);
                f.Write(obj.transform.up.z);
            }
            else
            {
                f.Write(obj.transform.right.x);
                f.Write(obj.transform.right.y);
                f.Write(obj.transform.right.z);
                f.Write(obj.transform.up.x);
                f.Write(obj.transform.up.y);
                f.Write(obj.transform.up.z);
                f.Write(obj.transform.forward.x);
                f.Write(obj.transform.forward.y);
                f.Write(obj.transform.forward.z);
            }
            f.Write(texName);
        }

        if (isCookie) f.Write(obj.angle);

        if (texDirty)
        {
            if (!SavePointLightTexture(tex, folder, texName, isCookie, isCubemap, isIES)) isError = true;
        }

        f.Close();

        return isError;
    }

    static void WriteNullTerminatedStringWithNewLine(BinaryWriter f, string s)
    {
        for(int i=0; i<s.Length; i++) f.Write(s[i]);
        f.Write((byte)0);
        f.Write((byte)'\n');
    }

    static bool SavePointLightTexture(UnityEngine.Object tex, string folder, string texName, bool isCookie, bool isCubemap, bool isIES)
    {
        if (File.Exists(folder + "/" + texName))
        {
            if (ftRenderLightmap.clientMode) ftClient.serverFileList.Add(texName);
            return true;
        }

        if (isCookie)
        {
            // Save original texture to RGBA32F DDS
            if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.Direct3D11)
            {
                ftBuildGraphics.InitShaders();
                ftBuildGraphics.SaveCookie((tex as Texture2D).GetNativeTexturePtr(),
                        folder + "/" + texName
                        );
                GL.IssuePluginEvent(4);
            }
            else
            {
                var a = ftBuildGraphics.InputDataFromTex(tex as Texture, ftBuildGraphics.TexInputType.FloatColor);
                ftBuildGraphics.SaveCookieFromRAM(a,
                        folder + "/" + texName
                        );
            }
            if (ftRenderLightmap.clientMode) ftClient.serverFileList.Add(texName);
        }
        else if (isCubemap)
        {
            if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.Direct3D11)
            {
                ftBuildGraphics.InitShaders();
                ftBuildGraphics.SaveSky((tex as Cubemap).GetNativeTexturePtr(),
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    folder + "/" + texName,
                    true,
                    false,
                    false
                    );
                GL.IssuePluginEvent(3); // convert cubemap
            }
            else
            {
                var a = ftBuildGraphics.InputDataFromCubemap(tex as Texture, Matrix4x4.identity, true, false, ftBuildGraphics.TexInputType.FloatColor);
                ftBuildGraphics.SaveCookieFromRAM(a,
                        folder + "/" + texName
                        );
            }
            if (ftRenderLightmap.clientMode) ftClient.serverFileList.Add(texName);
        }
        else if (isIES)
        {
            var startInfo = new System.Diagnostics.ProcessStartInfo();
            startInfo.CreateNoWindow  = false;
            startInfo.UseShellExecute = false;
            startInfo.WorkingDirectory = folder;
            startInfo.FileName        = Application.dataPath + "/Editor/x64/Bakery/ies2tex.exe";
            startInfo.CreateNoWindow = true;
            //startInfo.Arguments       =  "../" + AssetDatabase.GetAssetPath(obj.iesFile) + " " + "cookie" + obj.UID + ".dds 1";
            startInfo.Arguments       =  "\"" + Application.dataPath + "/../" + AssetDatabase.GetAssetPath(tex) + "\" " + texName + " 1";
            if (ftRenderLightmap.clientMode) ftClient.serverFileList.Add(texName);

#if LAUNCH_VIA_DLL
            startInfo.Arguments       =  "\"" + Application.dataPath + "/../" + AssetDatabase.GetAssetPath(tex) + "\" \"" + folder + "/" + texName + "\" 1";
            Debug.Log("Running ies2tex " + startInfo.Arguments);
            var crt = ftRenderLightmap.ProcessCoroutine("ies2tex", startInfo.Arguments, false);
            while(crt.MoveNext()) {}
            int errCode = ftRenderLightmap.lastReturnValue;
#else
            var exeProcess = System.Diagnostics.Process.Start(startInfo);
            exeProcess.WaitForExit();
            int errCode = exeProcess.ExitCode;
#endif
            if (errCode!=0)
            {
                ftRenderLightmap.DebugLogError("ies2tex error: "+ ftErrorCodes.TranslateI2T(errCode));
                Debug.LogError("ies2tex error: "+ ftErrorCodes.TranslateI2T(errCode) + " with args " + startInfo.Arguments);
                return false;
            }
        }
        return true;
    }

    static public bool BuildLights(BakeryPointLight[] allPoints, int start, int end, bool[] skipLight,
                                    int sampleDiv, bool ignoreNormal = false, string outName = "batchpointlight.bin")
    {
        if (!allowOverwrite && lightSaved.ContainsKey(outName)) return false;
        lightSaved[outName] = true;

        //Debug.LogError("---Build:");

        bool isError = false;

        var folder = ftBuildGraphics.scenePath;
        if (!Directory.Exists(folder)) Directory.CreateDirectory(folder);
        var flights = new BinaryWriter(File.Open(folder + "/" + outName, FileMode.Create));
        if (ftRenderLightmap.clientMode) ftClient.serverFileList.Add(outName);

        int numLights = 0;
        for(int L=start; L<=end; L++)
        {
            if (!skipLight[L]) numLights++;
        }
        flights.Write(numLights);

        for(int i=start; i<=end; i++)
        {
            if (skipLight[i]) continue;

            //Debug.LogError(obj.name);

            var obj = allPoints[i];

            var tform = obj.transform;
            var projMode = obj.projMode;

            if (projMode == BakeryPointLight.ftLightProjectionMode.Cookie && obj.cookie == null)
            {
                Debug.LogError("No cookie texture is set for light " + obj.name);
                projMode = BakeryPointLight.ftLightProjectionMode.Omni;
            }
            if (projMode == BakeryPointLight.ftLightProjectionMode.Cubemap && obj.cubemap == null)
            {
                Debug.LogError("No cubemap set for light " + obj.name);
                projMode = BakeryPointLight.ftLightProjectionMode.Omni;
            }
            if (projMode == BakeryPointLight.ftLightProjectionMode.IES && obj.iesFile == null)
            {
                Debug.LogError("No IES file is set for light " + obj.name);
                projMode = BakeryPointLight.ftLightProjectionMode.Omni;
            }

            Vector3 right, up, forward;
            if (projMode == BakeryPointLight.ftLightProjectionMode.IES && obj.directionMode == BakeryPointLight.Direction.PositiveZ)
            {
                right = tform.right;
                up = -tform.forward;
                forward = tform.up;
            }
            else
            {
                right = tform.right;
                up = tform.up;
                forward = tform.forward;
            }

            float projParam1 = 0.0f;
            float projParam2 = 0.0f;
            if (projMode == BakeryPointLight.ftLightProjectionMode.Cone)
            {
                projParam1 = obj.angle;
                projParam2 = obj.innerAngle / 100.0f;
            }
            else if (projMode == BakeryPointLight.ftLightProjectionMode.IES)
            {
                projMode = BakeryPointLight.ftLightProjectionMode.Cubemap;
            }
            else if (projMode == BakeryPointLight.ftLightProjectionMode.Cookie)
            {
                projParam2 = obj.angle;
            }

            flights.Write((float)projMode);
            flights.Write(tform.position.x);
            flights.Write(tform.position.y);
            flights.Write(tform.position.z);

            flights.Write(obj.shadowSpread);
            flights.Write(obj.realisticFalloff ? 1.0f : ((1.0f / obj.cutoff) * 5.0f));
            flights.Write(obj.realisticFalloff ? (obj.falloffMinRadius * obj.falloffMinRadius) : 1.0f);
            flights.Write(1.0f / obj.cutoff);

            flights.Write(obj.color.linear.r * obj.intensity);
            flights.Write(obj.color.linear.g * obj.intensity);
            flights.Write(obj.color.linear.b * obj.intensity);
            flights.Write(projParam1);

            flights.Write(right.x);
            flights.Write(right.y);
            flights.Write(right.z);
            flights.Write(projParam2);

            flights.Write(up.x);
            flights.Write(up.y);
            flights.Write(up.z);
            flights.Write(obj.indirectIntensity * ftRenderLightmap.hackIndirectBoost);

            flights.Write(forward.x);
            flights.Write(forward.y);
            flights.Write(forward.z);

            int samples = obj.samples;
            if (samples > 0)
            {
                samples = System.Math.Max(samples / sampleDiv, 1);
            }

            if (obj.shadowmaskFalloff) samples = -samples;

            flights.Write(samples);
        }

        flights.Write(ignoreNormal ? (byte)1 : (byte)0);

        for(int L=start; L<=end; L++)
        {
            if (skipLight[L]) continue;

            var obj = allPoints[L];

            bool isCookie = obj.projMode == BakeryPointLight.ftLightProjectionMode.Cookie && obj.cookie != null;
            bool isCubemap = obj.projMode == BakeryPointLight.ftLightProjectionMode.Cubemap && obj.cubemap != null;
            bool isIES = obj.projMode == BakeryPointLight.ftLightProjectionMode.IES && obj.iesFile != null;

            int existingTexHash;
            string texName = "";
            UnityEngine.Object tex = null;
            if (isCookie || isCubemap || isIES)
            {
                if (isCookie)
                {
                    tex = obj.cookie;
                }
                else if (isCubemap)
                {
                    tex = obj.cubemap;
                }
                else
                {
                    tex = obj.iesFile;
                }
                if (!tex2hash.TryGetValue(tex, out existingTexHash)) existingTexHash = -1;
                if (existingTexHash < 0)
                {
                    int texHash = tex.GetHashCode();
                    tex2hash[tex] = texHash;
                    existingTexHash = texHash;
                }
                texName = "cookie_" + existingTexHash + ".dds";
                WriteNullTerminatedStringWithNewLine(flights, texName);
            }

            if (!SavePointLightTexture(tex, folder, texName, isCookie, isCubemap, isIES)) isError = true;
        }

        flights.Close();

        return isError;
    }
}

#endif
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftBuildLights.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftClearCache.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 8d87362a9a7d1764092176850188e84b
# ASMDEF: BakeryEditorAssembly.dll
# ---
using UnityEngine;
using UnityEditor;
using UnityEngine.SceneManagement;
using System.Collections;
using System.Collections.Generic;
using System.IO;

public class ftClearCache
{
    static void Clear(string[] files)
    {
        for(int i=0; i<files.Length; i++) File.Delete(files[i]);
    }

    [MenuItem("Bakery/Utilities/Clear cache", false, 51)]
    private static void ClearCache()
    {
        var list = new HashSet<string>();

        var defaultPath = System.Environment.GetEnvironmentVariable("TEMP", System.EnvironmentVariableTarget.Process) + "\\frender";

        var gstorage = ftRenderLightmap.FindGlobalStorage();
        if (gstorage != null && gstorage.renderSettingsTempPath != "") defaultPath = gstorage.renderSettingsTempPath;

        var sceneCount = SceneManager.sceneCount;
        for(int i=0; i<sceneCount; i++)
        {
            var scene = SceneManager.GetSceneAt(i);
            if (!scene.isLoaded) continue;
            var go = ftLightmaps.FindInScene("!ftraceLightmaps", scene);
            if (go == null) continue;
            var storage = go.GetComponent<ftLightmapsStorage>();
            if (storage == null) continue;

            list.Add(storage.renderSettingsTempPath == "" ? defaultPath : storage.renderSettingsTempPath);
        }

        foreach(var tempPath in list)
        {
            if (Directory.Exists(tempPath) && EditorUtility.DisplayDialog("Bakery", "Clear cache from '" + tempPath + "'?", "OK", "Cancel"))
            {
                var files = Directory.GetFiles(tempPath, "*.lz4");
                Clear(files);

                files = Directory.GetFiles(tempPath, "*.dds");
                Clear(files);

                files = Directory.GetFiles(tempPath, "*.bin");
                Clear(files);

                files = Directory.GetFiles(tempPath, "lastscene.txt");
                Clear(files);
            }
        }

        Debug.Log("Done");
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftClearCache.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftClearMenu.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6976907e066f1824581718bc451446bc
# ASMDEF: BakeryEditorAssembly.dll
# ---
// Disable 'obsolete' warnings
#pragma warning disable 0618

using UnityEngine;
using UnityEditor;
using UnityEngine.SceneManagement;
using System.Collections;
using System.Collections.Generic;

public class ftClearMenu : EditorWindow
{
    public enum SceneClearingMode
    {
        nothing = 0,
        lightmapReferences = 1,
        lightmapReferencesAndBakeSettings = 2
    }

    static public string[] options = new string[] {"Nothing", "Baked data references", "All (data and bake settings)"};

    public SceneClearingMode sceneClearingMode = SceneClearingMode.lightmapReferences;
    public bool clearLightmapFiles = false;
    public bool clearVertexStreams = false;

    [MenuItem("Bakery/Utilities/Clear baked data", false, 44)]
    private static void ClearBakedDataShow()
    {
        var instance = (ftClearMenu)GetWindow(typeof(ftClearMenu));
        instance.titleContent.text = "Clear Baked Data";
        instance.minSize = new Vector2(250, 180);
        instance.maxSize = new Vector2(instance.minSize.x, instance.minSize.y + 1);
        instance.Show();
    }

    void OnGUI()
    {
        EditorGUILayout.BeginVertical(EditorStyles.inspectorFullWidthMargins);
        GUILayout.Space(10);
        EditorGUILayout.LabelField("Clear from scenes:", EditorStyles.boldLabel);
        GUILayout.Space(EditorGUIUtility.standardVerticalSpacing);
        sceneClearingMode = (SceneClearingMode)EditorGUILayout.Popup("", (int)sceneClearingMode, options, GUILayout.ExpandWidth(true));
        GUILayout.Space(10);
        EditorGUILayout.LabelField("Delete:", EditorStyles.boldLabel);
        GUILayout.Space(EditorGUIUtility.standardVerticalSpacing);
        EditorGUI.indentLevel++;
        clearLightmapFiles = EditorGUILayout.ToggleLeft(" Lightmap Files", clearLightmapFiles);
        clearVertexStreams = EditorGUILayout.ToggleLeft(" Vertex Lightmap Streams", clearVertexStreams);
        EditorGUI.indentLevel--;
        GUILayout.Space(20);


        if (GUILayout.Button("Clear", GUILayout.Height(24)))
        {
            string txt = "";
            if (sceneClearingMode == SceneClearingMode.nothing)
            {
                if (clearLightmapFiles) { txt += "Delete currently used lightmap files"; }

                if (clearVertexStreams) { txt += " and vertex lightmap stream assets"; }
                else
                {
                    EditorGUILayout.EndVertical();
                    return;
                }
            }
            else
            {
                if (sceneClearingMode == SceneClearingMode.lightmapReferences) { txt = "Clear all Bakery data for currently loaded scenes"; }
                else { txt = "Clear all Bakery data and settings for currently loaded scenes"; }

                if (clearLightmapFiles && clearVertexStreams) txt += ", currently used lightmap files, and vertex lightmap stream assets";
                if (clearLightmapFiles && !clearVertexStreams) txt += " and delete currently used lightmap files";
                if (clearVertexStreams && !clearLightmapFiles) txt += " and vertex lightmap stream assets";
            }

            if (EditorUtility.DisplayDialog("Bakery", txt + "?", "Yes", "No")) { ClearBakedData(sceneClearingMode, clearLightmapFiles, clearVertexStreams); }
        }

        EditorGUILayout.EndVertical();
    }

    static void RemoveFiles(Texture2D map)
    {
        var path = AssetDatabase.GetAssetPath(map);
        AssetDatabase.DeleteAsset(path);
        ftRenderLightmap.DebugLogInfo("Deleted " + path);
    }

    static void RemoveFiles(List<Texture2D> maps)
    {
        for(int i=0; i<maps.Count; i++)
        {
            RemoveFiles(maps[i]);
        }
    }
    
    static void RemoveFiles(Mesh mesh)
    {
        var path = AssetDatabase.GetAssetPath(mesh);
        AssetDatabase.DeleteAsset(path);
        ftRenderLightmap.DebugLogInfo("Deleted " + path);
    }
    
    static void RemoveFiles(List<Mesh> meshes)
    {
        for(int i=0; i<meshes.Count; i++)
        {
            var mesh = meshes[i];
            if (mesh == null) continue;
            RemoveFiles(mesh);
        }
    }

    public static void ClearBakedData(SceneClearingMode sceneClearMode, bool removeLightmapFiles, bool removeVertexStreams = false)
    {
        if (removeLightmapFiles || removeVertexStreams)
        {
            var sceneCount = SceneManager.sceneCount;
            for(int i=0; i<sceneCount; i++)
            {
                var scene = SceneManager.GetSceneAt(i);
                if (!scene.isLoaded) continue;
                var go = ftLightmaps.FindInScene("!ftraceLightmaps", scene);
                if (go == null) continue;
                var storage = go.GetComponent<ftLightmapsStorage>();
                if (storage == null) continue;

                RemoveFiles(storage.maps);
                RemoveFiles(storage.masks);
                RemoveFiles(storage.dirMaps);
                RemoveFiles(storage.rnmMaps0);
                RemoveFiles(storage.rnmMaps1);
                RemoveFiles(storage.rnmMaps2);
                if (removeVertexStreams) { RemoveFiles(storage.bakedVertexColorMesh); }
            }
        }

        if (sceneClearMode == SceneClearingMode.lightmapReferences)
        {
            var newStorages = new List<GameObject>();
            var sceneCount = SceneManager.sceneCount;
            for(int i=0; i<sceneCount; i++)
            {
                var scene = SceneManager.GetSceneAt(i);
                if (!scene.isLoaded) continue;
                var go = ftLightmaps.FindInScene("!ftraceLightmaps", scene);
                if (go == null) continue;
                var storage = go.GetComponent<ftLightmapsStorage>();
                if (storage != null)
                {
                    var newGO = new GameObject();
                    newGO.hideFlags = HideFlags.HideInHierarchy;
                    var newStorage = newGO.AddComponent<ftLightmapsStorage>();
                    ftLightmapsStorage.CopySettings(storage, newStorage);
                    newStorages.Add(newGO);
                }
                Undo.DestroyObjectImmediate(go);
            }
            LightmapSettings.lightmaps = new LightmapData[0];
            for(int i=0; i<newStorages.Count; i++)
            {
                newStorages[i].name = "!ftraceLightmaps";
            }
        }
        else if (sceneClearMode == SceneClearingMode.lightmapReferencesAndBakeSettings)
        {
            var sceneCount = SceneManager.sceneCount;
            for(int i=0; i<sceneCount; i++)
            {
                var scene = SceneManager.GetSceneAt(i);
                if (!scene.isLoaded) continue;
                var go = ftLightmaps.FindInScene("!ftraceLightmaps", scene);
                if (go == null) continue;
                Undo.DestroyObjectImmediate(go);
            }
            LightmapSettings.lightmaps = new LightmapData[0];
        }

#if UNITY_2017_3_OR_NEWER
        var lights = FindObjectsOfType<Light>() as Light[];
        for(int i=0; i<lights.Length; i++)
        {
            var output = lights[i].bakingOutput;
            output.isBaked = false;
            lights[i].bakingOutput = output;
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftClearMenu.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftClient.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 500a77e47a646b24581261ad5e43fe3d
# ASMDEF: BakeryEditorAssembly.dll
# ---
using UnityEngine;
using UnityEditor.SceneManagement;
using System.Text;
using System.IO;
using System.Collections;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;

public class ftClient
{
    public const byte SERVERTASK_COPY = 0;
    public const byte SERVERTASK_FTRACE = 1;
    public const byte SERVERTASK_FTRACERTX = 2;
    public const byte SERVERTASK_COMBINEMASKS = 3;
    public const byte SERVERTASK_COMBINESH = 4;

    public const byte SERVERTASK_DENOISE5 = 5;
    public const byte SERVERTASK_DENOISE6 = 6;
    public const byte SERVERTASK_DENOISE7 = 7;
    public const byte SERVERTASK_DENOISEOIDN = 8;
    public const byte SERVERTASK_DENOISEOIDN2 = 9;

    public const byte SERVERTASK_HF2HDR = 10;
    public const byte SERVERTASK_RGBA2TGA = 11;
    public const byte SERVERTASK_SEAMFIX = 12;

    public const byte SERVERTASK_LMREBAKE = 13;
    public const byte SERVERTASK_LMREBAKESIMPLE = 14;
    public const byte SERVERTASK_LODGEN = 15;
    public const byte SERVERTASK_LODGENINIT = 16;
    public const byte SERVERTASK_GIPARAMS = 17;
    public const byte SERVERTASK_RECEIVEFILE = 18;
    public const byte SERVERTASK_REPORTSTATUS = 19;
    public const byte SERVERTASK_SETSCENENAME = 20;
    public const byte SERVERTASK_GETDATA = 21;
    public const byte SERVERTASK_GETDATAREADY = 22;

    public const byte SERVERERROR_IDLE = 0;
    public const byte SERVERERROR_COPY = 1;
    public const byte SERVERERROR_EXEC = 2;
    public const byte SERVERERROR_APPERR = 3;
    public const byte SERVERERROR_GIPARAMS = 4;
    public const byte SERVERERROR_NOTIMPLEMENTED = 5;
    public const byte SERVERERROR_UNKNOWNTASK = 6;
    public const byte SERVERERROR_BUSY = 7;
    public const byte SERVERERROR_UNKNOWN = 8;
    public const byte SERVERERROR_SCENENAMETOOLONG = 9;
    public const byte SERVERERROR_FILENOTFOUND = 10;
    public const byte SERVERERROR_FILEHASZEROSIZE = 11;
    public const byte SERVERERROR_NOMEM = 12;
    public const byte SERVERERROR_INCORRECT = 13;
    public const byte SERVERERROR_INCORRECTFILENAME = 14;
    public const byte SERVERERROR_WRITEFAILED = 15;
    public const byte SERVERERROR_INCORRECTARGS = 16;
    public const byte SERVERERROR_FILESIZE = 17;
    public const byte SERVERERROR_STATUSLIMIT = 18;

    public static string serverAddress = "127.0.0.1";
    const int serverPort = 27777;
    public static bool connectedToServer = false;
    public static string lastServerMsg = "Server: no data";
    public static string lastServerScene = ""; // last baked scene
    public static int lastServerErrorCode = 0;
    public static bool lastServerMsgIsError = false;
    public static bool serverGetDataMode = false; // if we're in download mode or status polling mode
    public static bool serverMustRefreshData = false; // if ready to apply downloaded data

    static string lastServerFile = ""; // last file loaded via GETDATA on the server
    static int lastServerFileHash = 0;
    static int lastServerFileSize = 0;
    static double timeToUpdateServerStatus = 0;
    static double serverStatusInterval = 1000.0;
    static double serverConnectionTimeout = 2000.0;

    static Socket statusSocket;
    //static System.Threading.Thread statusThread;
    static IEnumerator statusProc;

    public static Dictionary<string, byte> app2serverTask = new Dictionary<string, byte>
    {
        {"ftrace", SERVERTASK_FTRACE},
        {"ftraceRTX", SERVERTASK_FTRACERTX},
        {"combineMasks", SERVERTASK_COMBINEMASKS},
        {"combineSH", SERVERTASK_COMBINESH},

        {"denoiserLegacy", SERVERTASK_DENOISE5},
        {"denoiser", SERVERTASK_DENOISE6},
        {"denoiser72", SERVERTASK_DENOISE7},
        {"denoiserOIDN", SERVERTASK_DENOISEOIDN},
        {"denoiserOIDN2", SERVERTASK_DENOISEOIDN2},

        {"halffloat2hdr", SERVERTASK_HF2HDR},
        {"rgba2tga", SERVERTASK_RGBA2TGA},
        {"seamfixer", SERVERTASK_SEAMFIX},
        {"lmrebake (simple)", SERVERTASK_LMREBAKESIMPLE},
        {"lmrebake", SERVERTASK_LMREBAKE}

    };
    public static List<string> serverFileList, serverGetFileList;
    public static int serverGetFileIterator = 0;


    public static IEnumerator UpdateConnection()//WaitForMessages()
    {
        var ipAdd = System.Net.IPAddress.Parse(serverAddress);
        var remoteEP = new IPEndPoint(ipAdd, serverPort);
        var request = new byte[1];
        request[0] = SERVERTASK_REPORTSTATUS;
        var requestGet = new byte[5];
        requestGet[0] = SERVERTASK_GETDATAREADY;
        int numTasks = 1;
        var taskGet = new byte[1];
        var nullByte = new byte[1];
        taskGet[0] = SERVERTASK_GETDATA;
        nullByte[0] = 0;

        lastServerMsg = "Connecting...";
        lastServerErrorCode = 0;
        lastServerMsgIsError = false;
        var status = new byte[256];
        byte[] fileBuffer = null;
        bool waitingForGet = false;

        while (connectedToServer)
        {
            if (statusSocket != null)
            {
                statusSocket.Close();
                statusSocket = null;
            }

            waitingForGet = false;


            // Attempt connecting to server
            bool connectionInProgress = true;
            bool connectionError = false;
            double timeout = ftRenderLightmap.GetTimeMs() + serverConnectionTimeout;
            while(connectionInProgress)
            {
                connectionInProgress = false;
                try
                {
                    if (statusSocket == null)
                    {
                        statusSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                        statusSocket.Blocking = false;
                        statusSocket.Connect(remoteEP);
                    }
                    else
                    {
                        if (statusSocket.Poll(0, SelectMode.SelectError))
                        {
                            connectionError = true;
                            break;
                        }
                        if (!statusSocket.Poll(0, SelectMode.SelectWrite) && ftRenderLightmap.GetTimeMs() < timeout)
                        {
                            connectionInProgress = true;
                        }
                    }
                }
                catch(SocketException s)
                {
                    if (s.ErrorCode == 10035) // WSAEWOULDBLOCK
                    {
                        connectionInProgress = true;
                    }
                    else
                    {
                        connectionError = true;
                        break;
                    }
                }
                if (connectionInProgress) yield return null;
            }
            statusSocket.Blocking = true;

            // Send request(s)
            try
            {
                if (connectionError) throw new SocketException();
                if (serverGetDataMode && serverGetFileList == null) serverGetDataMode = false;
                if (serverGetDataMode && serverGetFileList.Count <= serverGetFileIterator)
                {
                    serverMustRefreshData = true;
                    serverGetDataMode = false;
                }
                if (serverGetDataMode)
                {
                    var fname = serverGetFileList[serverGetFileIterator];
                    if (lastServerFile != fname)
                    {
                        int len = fname.Length;
                        statusSocket.Send(System.BitConverter.GetBytes(numTasks));
                        statusSocket.Send(taskGet);
                        statusSocket.Send(System.BitConverter.GetBytes(len));
                        statusSocket.Send(Encoding.ASCII.GetBytes(fname));
                        statusSocket.Send(nullByte);
                        statusSocket.Close();

                        statusSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                        statusSocket.Connect(remoteEP);
                        statusSocket.Send(request);
#if BAKERY_NETDEBUG
                        Debug.Log("Request sent (load file " + fname + ")");
#endif
                    }
                    else
                    {
                        fileBuffer = new byte[lastServerFileSize];
                        System.Buffer.BlockCopy(System.BitConverter.GetBytes(lastServerFileHash), 0, requestGet, 1, 4);
                        statusSocket.Send(requestGet);
#if BAKERY_NETDEBUG
                        Debug.Log("Request sent (get file)");
#endif
                        waitingForGet = true;
                    }
                }
                else
                {
                    statusSocket.Send(request);
#if BAKERY_NETDEBUG
                    Debug.Log("Request sent");
#endif
                }
            }
            catch(SocketException s)
            {
                lastServerMsg = "Failed to get data from server (" + s.ErrorCode + ")";
                lastServerMsgIsError = true;
                lastServerErrorCode = 0;

                Debug.LogError(lastServerMsg);
                statusSocket.Close();
                statusSocket = null;
                statusProc = null;
                //statusThread = null;
                connectedToServer = false;
                //return;
                yield break;
            }

#if BAKERY_NETDEBUG
            Debug.Log("Waiting for server to respond");
#endif

            int serverErrCode = 0;
            int appCode = 0;
            int appErrCode = 0;
            int textLen = 0;
            int fileReady = 0;
            int fileHash = 0;
            int fileSize = 0;
            string text = "";
            string fileNameReady = "";

            int byteCount = 0;
            bool interrupted = false;
            double maxTimeToReceive = 10.0;
            double timeToInterrupt = ftRenderLightmap.GetTimeMs() + maxTimeToReceive;

            while(!interrupted)
            {
                if (ftRenderLightmap.GetTimeMs() > timeToInterrupt)
                {
                    timeToInterrupt = ftRenderLightmap.GetTimeMs() + maxTimeToReceive;
                    yield return null;
                }
                //while(statusSocket.Available == 0) yield return null;
                //while(!statusSocket.Poll(0, SelectMode.SelectRead)) yield return null;
                try
                {
                    //while(true)
                    //{
                        if (waitingForGet)
                        {
                            int bytesReceived = statusSocket.Receive(fileBuffer, byteCount, fileBuffer.Length - byteCount, SocketFlags.None);
                            byteCount += bytesReceived;
                            //Debug.Log("Received " + bytesReceived);
                            if (bytesReceived == 0) interrupted = true;//break;
                        }
                        else
                        {
                            byteCount = statusSocket.Receive(status);
                            //break;
                            interrupted = true;
                        }
                    //}
                }
                catch
                {
                    if (waitingForGet)
                    {
                        Debug.LogError("Error getting file from server - retrying");
                        lastServerFile = "";
                    }
                    else
                    {
                        lastServerMsg = "Server disconnected";
                        lastServerMsgIsError = true;
                        lastServerErrorCode = 0;

                        Debug.LogError(lastServerMsg);
                        statusSocket.Close();
                        statusSocket = null;
                        //statusThread = null;
                        statusProc = null;
                        connectedToServer = false;
                        yield break;
                    }
                }
            }

            if (byteCount > 0)
            {
                if (waitingForGet)
                {
                    Debug.Log("Data received: " + byteCount);
                    var ext = lastServerFile.Substring(lastServerFile.Length-3).ToLower();
                    string outPath;
                    if (ext == "lz4" || ext == "dds")
                    {
                        outPath = ftRenderLightmap.scenePath + "/" + lastServerFile;
                    }
                    else
                    {
                        outPath = "Assets/" + ftRenderLightmap.outputPath + "/" + lastServerFile;
                    }
                    BinaryWriter bw = null;
                    try
                    {
                        bw = new BinaryWriter(File.Open(outPath, FileMode.Create));
                    }
                    catch
                    {
                        Debug.LogError("Failed writing " + outPath);
                    }
                    if (bw != null)
                    {
                        bw.Write(fileBuffer);
                        bw.Close();
                        Debug.Log("File saved: " + outPath);
                    }
                    yield return null;
                    serverGetFileIterator++;
                }
                else
                {
                    if (byteCount == 150)
                    {
                        serverErrCode = System.BitConverter.ToInt32(status, 0);
                        appCode = System.BitConverter.ToInt32(status, 4);
                        appErrCode = System.BitConverter.ToInt32(status, 8);
                        textLen = status[12];
                        fileReady = status[13];
                        fileHash = System.BitConverter.ToInt32(status, 14);
                        fileSize = System.BitConverter.ToInt32(status, 18);
                        if (textLen > 0)
                        {
                            text = Encoding.ASCII.GetString(status, 22, textLen);
                        }
                        if (fileReady > 0)
                        {
                            fileNameReady = Encoding.ASCII.GetString(status, 22 + textLen + 1, fileReady);
                        }
                    }
                    else
                    {
                        serverErrCode = SERVERERROR_UNKNOWN;
                        Debug.LogError("Unrecognized response size: " + byteCount);
                    }
                    //if (serverErrCode != 0)
                    {
                        var serverMsg = "Server: " + ftErrorCodes.TranslateServer(serverErrCode, appCode, appErrCode);
                        bool isError = serverErrCode != SERVERERROR_IDLE && serverErrCode != SERVERERROR_BUSY;
                        if (isError)
                        {
                            Debug.LogError(serverMsg);
                        }
                        else
                        {
#if BAKERY_NETDEBUG
                            Debug.Log(serverMsg);
#else
                            if (lastServerMsg != serverMsg) Debug.Log(serverMsg);
#endif
                        }
                        lastServerMsg = serverMsg;
                        lastServerMsgIsError = isError;
                        lastServerErrorCode = serverErrCode;
                        lastServerScene = text;
                        lastServerFile = fileNameReady;
                        lastServerFileHash = fileHash;
                        lastServerFileSize = fileSize;
                    }
                }
            }


            if (!serverGetDataMode)
            {
                //var sleepTime = timeToUpdateServerStatus - curTime;
                //if (sleepTime > 0) System.Threading.Thread.Sleep((int)sleepTime);
                while(true)
                {
                    var curTime = ftRenderLightmap.GetTimeMs();
                    if (curTime >= timeToUpdateServerStatus) break;
                    yield return null;
                }

                timeToUpdateServerStatus = ftRenderLightmap.GetTimeMs() + serverStatusInterval;
            }
        }

        statusSocket.Close();
        statusSocket = null;
        //statusThread = null;
        statusProc = null;
    }

    public static void Disconnect()
    {
        if (statusSocket != null)
        {
            statusSocket.Close();
            statusSocket = null;
        }

        statusProc = null;
        /*if (statusThread != null)
        {
            statusThread.Abort();
            statusThread = null;
        }*/

        connectedToServer = false;
        serverGetDataMode = false;
    }

    public static void ConnectToServer()
    {
        try
        {
            Disconnect();
            connectedToServer = true;

            timeToUpdateServerStatus = 0;
            //statusThread = new System.Threading.Thread(WaitForMessages);
            //statusThread.Start();
            statusProc = UpdateConnection();
            statusProc.MoveNext();
        }
        catch
        {
            Debug.LogError("Failed getting data from server");
            throw;
        }
    }

    public static bool SendRenderSequence(byte[] renderSequence)
    {
        Socket soc = null;
        var ipAdd = System.Net.IPAddress.Parse(serverAddress);
        var remoteEP = new IPEndPoint(ipAdd, serverPort);
        bool connectionInProgress;

        for(int i=0; i<serverFileList.Count; i++)
        {
            var fsoc = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            connectionInProgress = true;
            while(connectionInProgress)
            {
                try
                {
                    connectionInProgress = false;
                    fsoc.Connect(remoteEP);
                }
                catch(SocketException s)
                {
                    if (s.ErrorCode == 10035) // WSAEWOULDBLOCK
                    {
                        connectionInProgress = true;
                    }
                    else if (s.ErrorCode == 10061) //  WSAECONNREFUSED
                    {
                        connectionInProgress = true;
                        System.Threading.Thread.Sleep(1000); // apparently we're sending more than the server can chew - wait a bit
                    }
                    else
                    {
                        Debug.LogError("Socket error");
                        throw s;
                    }
                }
            }
            if (!fsoc.Poll(0, SelectMode.SelectWrite)) return false;

            var sceneFile = File.ReadAllBytes(ftRenderLightmap.scenePath + "/" + serverFileList[i]);
            int headerSize = 5 + serverFileList[i].Length + 1;
            var buff = new byte[sceneFile.Length + headerSize];

            int numTasks = 1;
            System.Buffer.BlockCopy(System.BitConverter.GetBytes(numTasks), 0, buff, 0, 4);
            buff[4] = SERVERTASK_RECEIVEFILE;
            buff[5] = (byte)serverFileList[i].Length;
            for(int j=0; j<serverFileList[i].Length; j++) buff[6+j] = (byte)serverFileList[i][j];
            System.Buffer.BlockCopy(sceneFile, 0, buff, headerSize, sceneFile.Length);

            connectionInProgress = true;
            while(connectionInProgress)
            {
                try
                {
                    connectionInProgress = false;
                    fsoc.Send(buff);
                }
                catch(SocketException s)
                {
                    if (s.ErrorCode == 10035) // WSAEWOULDBLOCK
                    {
                        connectionInProgress = true;
                    }
                    else if (s.ErrorCode == 10061) //  WSAECONNREFUSED
                    {
                        connectionInProgress = true;
                        System.Threading.Thread.Sleep(1000); // apparently we're sending more than the server can chew - wait a bit
                    }
                    else
                    {
                        Debug.LogError("Socket error (2)");
                        throw s;
                    }
                }
            }

            fsoc.Close();
        }

        soc = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        soc.Connect(remoteEP);
        if (!soc.Poll(0, SelectMode.SelectWrite)) return false;
        soc.Send(renderSequence);
        soc.Close();
        return true;
    }

    public static void ServerGetData(List<string> fileList)
    {
        serverGetFileList = fileList;
        serverGetFileIterator = 0;
        serverGetDataMode = true;
    }

    public static void Update()
    {
        if (statusProc != null) statusProc.MoveNext();
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftClient.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftCreateMenu.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1b37b47c815251d4290ee5b16dec9c70
# ASMDEF: BakeryEditorAssembly.dll
# ---
using UnityEngine;
using UnityEditor;

public class ftCreateMenu
{
    [MenuItem("Bakery/Create/Directional Light", false, 20)]
    private static void CreateDirectionalLight()
    {
        var go = new GameObject();
        Undo.RegisterCreatedObjectUndo(go, "Create Bakery light");
        go.AddComponent<BakeryDirectLight>();
        go.name = "DirectLight";
        var ecam = SceneView.lastActiveSceneView.camera.transform;
        go.transform.position = ecam.position + ecam.forward;
        go.transform.eulerAngles = new Vector3(50, -30, 0);
        var arr = new GameObject[1];
        arr[0] = go;
        Selection.objects = arr;
    }

    [MenuItem("Bakery/Create/Skylight", false, 20)]
    private static void CreateSkyLight()
    {
        var go = new GameObject();
        Undo.RegisterCreatedObjectUndo(go, "Create Bakery light");
        go.AddComponent<BakerySkyLight>();
        go.name = "Skylight";
        var ecam = SceneView.lastActiveSceneView.camera.transform;
        go.transform.position = ecam.position + ecam.forward;
        var arr = new GameObject[1];
        arr[0] = go;
        Selection.objects = arr;
    }

    [MenuItem("Bakery/Create/Point Light", false, 20)]
    private static void CreatePointLight()
    {
        var go = new GameObject();
        Undo.RegisterCreatedObjectUndo(go, "Create Bakery light");
        go.AddComponent<BakeryPointLight>();
        go.name = "PointLight";
        var ecam = SceneView.lastActiveSceneView.camera.transform;
        go.transform.position = ecam.position + ecam.forward;
        var arr = new GameObject[1];
        arr[0] = go;
        Selection.objects = arr;
    }

    [MenuItem("Bakery/Create/Area Light (Example)", false, 20)]
    private static void CreateAreaLight()
    {
        var go = GameObject.CreatePrimitive(PrimitiveType.Quad);
        Undo.RegisterCreatedObjectUndo(go, "Create Bakery light");
        go.AddComponent<BakeryLightMesh>();
        go.name = "AreaLight";
        var ecam = SceneView.lastActiveSceneView.camera.transform;
        go.transform.position = ecam.position + ecam.forward;
        var bakeryRuntimePath = ftLightmaps.GetRuntimePath();
        var mat = AssetDatabase.LoadAssetAtPath(bakeryRuntimePath + "ftDefaultAreaLightMat.mat", typeof(Material)) as Material;
        go.GetComponent<MeshRenderer>().material = mat;
        var arr = new GameObject[1];
        arr[0] = go;
        Selection.objects = arr;
    }

    [MenuItem("Bakery/Create/Spotlight", false, 20)]
    private static void CreateSpotLight()
    {
        var go = new GameObject();
        Undo.RegisterCreatedObjectUndo(go, "Create Bakery light");
        var light = go.AddComponent<BakeryPointLight>();
        light.projMode = BakeryPointLight.ftLightProjectionMode.Cookie;
        var bakeryRuntimePath = ftLightmaps.GetRuntimePath();
        light.cookie = AssetDatabase.LoadAssetAtPath(bakeryRuntimePath + "ftUnitySpotTexture.bmp", typeof(Texture2D)) as Texture2D;
        go.name = "SpotLight";
        var ecam = SceneView.lastActiveSceneView.camera.transform;
        go.transform.position = ecam.position + ecam.forward;
        var arr = new GameObject[1];
        arr[0] = go;
        Selection.objects = arr;
    }

    [MenuItem("Bakery/Create/Volume", false, 20)]
    private static void CreateVolume()
    {
        var go = new GameObject();
        Undo.RegisterCreatedObjectUndo(go, "Create Bakery Volume");
        go.AddComponent<BakeryVolume>();
        go.name = "BakeryVolume";
        var ecam = SceneView.lastActiveSceneView.camera.transform;
        go.transform.position = ecam.position + ecam.forward;
        var arr = new GameObject[1];
        arr[0] = go;
        Selection.objects = arr;
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftCreateMenu.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftDDS.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7651ced8d6837974980b54a8c065ca41
# ASMDEF: BakeryEditorAssembly.dll
# ---
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEngine;

public class ftDDS
{
    public static byte[] ddsHeaderFloat4 = new byte[]
    {
        0x44, 0x44, 0x53, 0x20, 0x7C, 0x00, 0x00, 0x00, 0x07, 0x10, 0x08, 0x00, 0xF0, 0x00, 0x00, 0x00,
        0x40, 0x01, 0x00, 0x00, 0x00, 0xC0, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };

    public static byte[] ddsHeaderHalf4 = new byte[]
    {
        0x44, 0x44, 0x53, 0x20, 0x7C, 0x00, 0x00, 0x00, 0x07, 0x10, 0x08, 0x00, 0xCD, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x68, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };

    public static byte[] ddsHeaderRGBA8 = new byte[]
    {
        0x44, 0x44, 0x53, 0x20, 0x7C, 0x00, 0x00, 0x00, 0x07, 0x10, 0x08, 0x00, 0x00, 0x02, 0x00, 0x00,
        0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
        0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00,
        0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x10, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };

    public static byte[] ddsHeaderR32F = new byte[]
    {
        0x44, 0x44, 0x53, 0x20, 0x7C, 0x00, 0x00, 0x00, 0x07, 0x10, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x13, 0x00, 0x00, 0x00, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftDDS.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftDefine.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 993d44f6e3c171944a748e43ca064632
# ASMDEF: BakeryEditorAssembly.dll
# ---
#if UNITY_EDITOR

// Disable 'obsolete' warnings
#pragma warning disable 0618

using UnityEngine;
using UnityEditor;
using System;
using UnityEditor.Build;

[InitializeOnLoad]
#if UNITY_2017_4_OR_NEWER
public class ftDefine : IActiveBuildTargetChanged
#else
public class ftDefine
#endif
{
    static void AddDefine()
    {
        var platform = EditorUserBuildSettings.selectedBuildTargetGroup;
        var defines = PlayerSettings.GetScriptingDefineSymbolsForGroup(platform);
        if (!defines.Contains("BAKERY_INCLUDED"))
        {
            if (defines.Length > 0) defines += ";";
            defines += "BAKERY_INCLUDED";
            if (!defines.Contains("BAKERY_NOREIMPORT"))
            {
                defines += ";BAKERY_NOREIMPORT";
            }
            PlayerSettings.SetScriptingDefineSymbolsForGroup(platform, defines);
        }
    }

    static ftDefine()
    {
        AddDefine();
    }

#if UNITY_2017_4_OR_NEWER
    public int callbackOrder { get { return 0; } }
    public void OnActiveBuildTargetChanged(BuildTarget previousTarget, BuildTarget newTarget)
    {
        AddDefine();
    }
#endif
}

#endif
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftDefine.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftDetectSettings.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: afee4282908768e4a8b35d3e5754110c
# ASMDEF: BakeryEditorAssembly.dll
# ---
using UnityEngine;
using UnityEditor;
using System.IO;
using UnityEngine.SceneManagement;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;

public class ftDetectSettings
{
    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern System.IntPtr RunLocalProcess([MarshalAs(UnmanagedType.LPWStr)]string commandline, bool setWorkDir);

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern bool IsProcessFinished(System.IntPtr proc);

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern int GetProcessReturnValueAndClose(System.IntPtr proc);

    [DllImport ("simpleProgressBar", CallingConvention=CallingConvention.Cdecl)]
    public static extern int simpleProgressBarShow(string header, string msg, float percent, float step, bool onTop);

    [DllImport ("simpleProgressBar", CallingConvention=CallingConvention.Cdecl)]
    public static extern bool simpleProgressBarCancelled();

    [DllImport ("simpleProgressBar", CallingConvention=CallingConvention.Cdecl)]
    public static extern void simpleProgressBarEnd();

    static IEnumerator progressFunc;
    static int lastReturnValue = -1;
    static bool userCanceled = false;

    static bool runsRTX, runsNonRTX, runsOptix5, runsOptix6, runsOptix7, runsOIDN, runsOIDN2;

    const string progressHeader = "Detecting compatible configuration";

    static void ShowProgress(string msg, float percent)
    {
        simpleProgressBarShow(progressHeader, msg, percent, 0, true);
    }

    static void ValidateFileAttribs(string file)
    {
        if (File.Exists(file))
        {
            var attribs = File.GetAttributes(file);
            if ((attribs & FileAttributes.ReadOnly) != 0)
            {
                File.SetAttributes(file, attribs & ~FileAttributes.ReadOnly);
            }
        }
    }

    [MenuItem("Bakery/Utilities/Detect optimal settings", false, 54)]
    public static void DetectCompatSettings()
    {
        var bakeryPath = ftLightmaps.GetEditorPath();
        ValidateFileAttribs(bakeryPath+"/hwtestdata/image.lz4");
        ValidateFileAttribs(bakeryPath+"/hwtestdata/light_HDR.lz4");

        progressFunc = DetectCoroutine();
        EditorApplication.update += DetectUpdate;
    }

    static IEnumerator DetectCoroutine()
    {
        float stages = 7;
        float step = 1.0f / stages;
        float progress = 0;
        IEnumerator crt;

        ShowProgress("Testing: RTX ray-tracing", progress);
        crt = ProcessCoroutine("ftraceRTX.exe /sun hwtestdata light 4 0 0 direct0.bin");
        while (crt.MoveNext()) yield return null;
        if (userCanceled) yield break;
        runsRTX = lastReturnValue==0;
        progress += step;

        ShowProgress("Testing: non-RTX ray-tracing", progress);
        crt = ProcessCoroutine("ftrace.exe /sun hwtestdata light 4 0 0 direct0.bin");
        while (crt.MoveNext()) yield return null;
        if (userCanceled) yield break;
        runsNonRTX = lastReturnValue==0;
        progress += step;

        ShowProgress("Testing: OptiX 5.1 denoiser", progress);
        crt = ProcessCoroutine("denoiserLegacy c hwtestdata/image.lz4 hwtestdata/image.lz4 16 0");
        while (crt.MoveNext()) yield return null;
        if (userCanceled) yield break;
        runsOptix5 = lastReturnValue==0;
        progress += step;

        ShowProgress("Testing: OptiX 6.0 denoiser", progress);
        crt = ProcessCoroutine("denoiser c hwtestdata/image.lz4 hwtestdata/image.lz4 16 0");
        while (crt.MoveNext()) yield return null;
        if (userCanceled) yield break;
        runsOptix6 = lastReturnValue==0;
        progress += step;

        ShowProgress("Testing: OptiX 7.2 denoiser", progress);
        crt = ProcessCoroutine("denoiser72 c hwtestdata/image.lz4 hwtestdata/image.lz4 16 0");
        while (crt.MoveNext()) yield return null;
        if (userCanceled) yield break;
        runsOptix7 = lastReturnValue==0;
        progress += step;

        ShowProgress("Testing: OpenImageDenoise", progress);
        crt = ProcessCoroutine("denoiserOIDN c hwtestdata/image.lz4 hwtestdata/image.lz4 16 0");
        while (crt.MoveNext()) yield return null;
        if (userCanceled) yield break;
        runsOIDN = lastReturnValue==0;
        progress += step;

        ShowProgress("Testing: OpenImageDenoise2 (CUDA)", progress);
        crt = ProcessCoroutine("denoiserOIDN2 c hwtestdata/image.lz4 hwtestdata/image.lz4 16 0");
        while (crt.MoveNext()) yield return null;
        if (userCanceled) yield break;
        runsOIDN2 = lastReturnValue==0;
        progress += step;

        simpleProgressBarEnd();

        if (!runsRTX && !runsNonRTX)
        {
            EditorUtility.DisplayDialog("Error", "Both RTX and non-RTX lightmapper failed to run. Make sure you are using NVIDIA GPU and the drivers are up to date.", "OK");
            yield break;
        }

        string str = "Testing results:\n\n";
        str += "RTX ray-tracing: " + (runsRTX ? "yes" : "no") + "\n";
        str += "Non-RTX ray-tracing: " + (runsNonRTX ? "yes" : "no") + "\n";
        str += "OptiX 5.1 denoiser: " + (runsOptix5 ? "yes" : "no") + "\n";
        str += "OptiX 6.0 denoiser: " + (runsOptix6 ? "yes" : "no") + "\n";
        str += "OptiX 7.2 denoiser: " + (runsOptix7 ? "yes" : "no") + "\n";
        str += "OpenImageDenoise: " + (runsOIDN ? "yes" : "no") + "\n";
        str += "OpenImageDenoise2 (CUDA): " + (runsOIDN2 ? "yes" : "no") + "\n";

        str += "\n";
        str += "Recommended RTX mode: ";
        if (runsRTX && runsNonRTX)
        {
            str += "ON if you are using a GPU with RT acceleration (e.g. 2xxx or 3xxx GeForce series), OFF otherwise.\n";
        }
        else if (runsRTX)
        {
            str += "ON\n";
        }
        else if (runsNonRTX)
        {
            str += "OFF\n";
        }

        str += "\n";
        str += "Recommended denoiser: ";
        if (runsOptix5)
        {
            // OptiX 5.1 has stable quality since release, but not supported on 30XX
            str += "OptiX 5.1\n";
        }
        else if (runsOIDN2)
        {
            // OIDN2+CUDA is the best option on modern HW
            str += "OpenImageDenoise2\n";
        }
        else if (runsOIDN)
        {
            // OIDN is stable and pretty good, but might be slower
            str += "OpenImageDenoise\n";
        }
        // OptiX 6 and 7.2 should run on 30XX, but quality is sometimes questionable IF driver is newer than 442.50
        // as the network is now part of the driver.
        // On older drivers they should work similar to 5.1.
        else if (runsOptix7)
        {
            str += "OptiX 7.2\n";
        }
        else if (runsOptix6)
        {
            str += "OptiX 6.0\n";
        }
        else
        {
            str += "all denoiser tests failed. Try updating GPU drivers.\n";
        }

        var bakeryRuntimePath = ftLightmaps.GetRuntimePath();
        var gstorage = AssetDatabase.LoadAssetAtPath(bakeryRuntimePath + "ftGlobalStorage.asset", typeof(ftGlobalStorage)) as ftGlobalStorage;
        if (gstorage == null) Debug.LogError("Can't find global storage");
        var storage = ftRenderLightmap.FindRenderSettingsStorage();

        if (gstorage != null)
        {
            gstorage.foundCompatibleSetup = true;
            gstorage.gpuName = SystemInfo.graphicsDeviceName;
            gstorage.runsNonRTX = runsNonRTX;
            gstorage.alwaysEnableRTX = false;
            gstorage.runsOptix5 = runsOptix5;
            gstorage.runsOptix6 = runsOptix6;
            gstorage.runsOptix7 = runsOptix7;
            gstorage.runsOIDN = runsOIDN;
            gstorage.runsOIDN2 = runsOIDN2;
        }

        if (!EditorUtility.DisplayDialog("Results", str, "OK", "Set recommended as default"))
        {
            if (runsRTX && runsNonRTX)
            {
                gstorage.renderSettingsRTXMode = EditorUtility.DisplayDialog("Question", "Does your GPU have RT cores (set RTX mode as default)?", "Yes", "No");
            }
            else if (runsRTX)
            {
                gstorage.renderSettingsRTXMode = true;
            }
            else
            {
                gstorage.renderSettingsRTXMode = false;
            }

            if (runsOIDN2)
            {
                gstorage.renderSettingsDenoiserType = (int)ftGlobalStorage.DenoiserType.OpenImageDenoise2;
            }
            else if (runsOptix5)
            {
                gstorage.renderSettingsDenoiserType = (int)ftGlobalStorage.DenoiserType.Optix5;
            }
            else if (runsOIDN)
            {
                gstorage.renderSettingsDenoiserType = (int)ftGlobalStorage.DenoiserType.OpenImageDenoise;
            }
            else if (runsOptix7)
            {
                gstorage.renderSettingsDenoiserType = (int)ftGlobalStorage.DenoiserType.Optix7;
            }
            else if (runsOptix6)
            {
                gstorage.renderSettingsDenoiserType = (int)ftGlobalStorage.DenoiserType.Optix6;
            }

            EditorUtility.SetDirty(gstorage);
            Debug.Log("Default settings saved");

            if (storage != null)
            {
                storage.renderSettingsRTXMode = gstorage.renderSettingsRTXMode;
                storage.renderSettingsDenoiserType = gstorage.renderSettingsDenoiserType;
            }
        }

        var bakery = ftRenderLightmap.instance != null ? ftRenderLightmap.instance : new ftRenderLightmap();
        bakery.LoadRenderSettings();
    }

    static void DetectUpdate()
    {
        if (!progressFunc.MoveNext())
        {
            EditorApplication.update -= DetectUpdate;
        }
    }

    static IEnumerator ProcessCoroutine(string cmd)
    {
        var exeProcess = RunLocalProcess(cmd, true);
        if (exeProcess == (System.IntPtr)null)
        {
            lastReturnValue = -1;
            yield break;
        }
        while(!IsProcessFinished(exeProcess))
        {
            yield return null;
            userCanceled = simpleProgressBarCancelled();
            if (userCanceled)
            {
                simpleProgressBarEnd();
                yield break;
            }
        }
        lastReturnValue = GetProcessReturnValueAndClose(exeProcess);
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftDetectSettings.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftDirectLightInspector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 3a4eb21edcc395a419e2da3246fcbc15
# ASMDEF: BakeryEditorAssembly.dll
# ---

using UnityEditor;
using UnityEngine;
using System;
using System.IO;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using UnityEngine.Rendering;

[CustomEditor(typeof(BakeryDirectLight))]
[CanEditMultipleObjects]
public class ftDirectLightInspector : UnityEditor.Editor
{
    SerializedProperty ftraceLightColor;
    SerializedProperty ftraceLightIntensity;
    SerializedProperty ftraceLightShadowSpread;
    SerializedProperty ftraceLightSamples;
    SerializedProperty ftraceLightBitmask;
    SerializedProperty ftraceLightBakeToIndirect;
    SerializedProperty ftraceLightShadowmask;
    SerializedProperty ftraceLightShadowmaskDenoise;
    SerializedProperty ftraceLightIndirectIntensity;
    SerializedProperty ftraceLightTexture, ftraceLightCSTilingX, ftraceLightCSTilingY, ftraceLightCSOffsetX, ftraceLightCSOffsetY;
    SerializedProperty ftraceLightSupersample;

    ftLightmapsStorage storage;

    static bool projectionMode = false;

    bool isHDRP = false;

    public enum BakeWhat
    {
        DirectAndIndirect = 0,
        IndirectOnly = 1,
        IndirectAndShadowmask = 2,
        DirectIndirectShadowmask = 3
    };

    int texCached = -1;

    void TestPreviewRefreshProperty(ref int cached, int newVal)
    {
        if (cached >= 0)
        {
            if (cached != newVal)
            {
                BakerySkyLight.lightsChanged = 2;
            }
        }
        cached = newVal;
    }

    void TestPreviewRefreshProperty(ref int cached, UnityEngine.Object newVal)
    {
        if (newVal == null)
        {
            TestPreviewRefreshProperty(ref cached, 0);
            return;
        }
        TestPreviewRefreshProperty(ref cached, newVal.GetInstanceID());
    }

    static public string[] directContributionOptions = new string[] {"Direct And Indirect", "Indirect Only", "Shadowmask and Indirect", "Direct, Indirect, Shadowmask (custom lighting only)"};
    static public string[] directContributionIndirectOptions = new string[] {"Direct And Indirect", "Indirect Only", "Shadowmask and Indirect (not applicable in Indirect mode)", "Direct, Indirect, Shadowmask (not applicable in Indirect mode)"};

    static string[] selStrings = new string[] {"0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16",
                                                "17","18","19","20","21","22","23","24","25","26","27","28","29","30"};//,"31"};

    void InitSerializedProperties(SerializedObject obj)
    {
        ftraceLightColor = obj.FindProperty("color");
        ftraceLightIntensity = obj.FindProperty("intensity");
        ftraceLightIndirectIntensity = obj.FindProperty("indirectIntensity");
        ftraceLightShadowSpread = obj.FindProperty("shadowSpread");
        ftraceLightSamples = obj.FindProperty("samples");
        ftraceLightBitmask = obj.FindProperty("bitmask");
        ftraceLightBakeToIndirect = obj.FindProperty("bakeToIndirect");
        ftraceLightShadowmask = obj.FindProperty("shadowmask");
        ftraceLightShadowmaskDenoise = obj.FindProperty("shadowmaskDenoise");
        ftraceLightTexture = obj.FindProperty("cloudShadow");
        ftraceLightCSTilingX = obj.FindProperty("cloudShadowTilingX");
        ftraceLightCSTilingY = obj.FindProperty("cloudShadowTilingY");
        ftraceLightCSOffsetX = obj.FindProperty("cloudShadowOffsetX");
        ftraceLightCSOffsetY = obj.FindProperty("cloudShadowOffsetY");
        ftraceLightSupersample = obj.FindProperty("supersample");

        isHDRP = (target as BakeryDirectLight).GetComponent("HDAdditionalLightData") != null;
    }

    void OnEnable()
    {
        InitSerializedProperties(serializedObject);
    }

    void SetHDRPLight(Light l)
    {
        l.intensity *= Mathf.PI;

        var hdrpLight = l.GetComponent("HDAdditionalLightData");
        if (hdrpLight == null)
        {
            Debug.LogWarning("HDRP: no HDAdditionalLightData");
            return;
        }
        var so = new SerializedObject(hdrpLight);
        if (so == null)
        {
            Debug.LogWarning("HDRP: no SerializedObject");
            return;
        }

        SerializedProperty hdrpInt2 = so.FindProperty("m_Intensity");
        if (hdrpInt2 == null)
        {
            Debug.LogWarning("HDRP: no m_Intensity");
            return;
        }
        hdrpInt2.floatValue = l.intensity;

        so.ApplyModifiedProperties();
    }

    void GetLinearLightParameters(Light light, out float lightR, out float lightG, out float lightB, out float lightInt)
    {
        if (PlayerSettings.colorSpace != ColorSpace.Linear)
        {
            lightInt = light.intensity;
            lightR = light.color.r;
            lightG = light.color.g;
            lightB = light.color.b;
            return;
        }

        if (!GraphicsSettings.lightsUseLinearIntensity)
        {
            lightR = Mathf.Pow(light.color.r * light.intensity, 2.2f);
            lightG = Mathf.Pow(light.color.g * light.intensity, 2.2f);
            lightB = Mathf.Pow(light.color.b * light.intensity, 2.2f);
            lightInt = Mathf.Max(Mathf.Max(lightR, lightG), lightB);
            lightR /= lightInt;
            lightG /= lightInt;
            lightB /= lightInt;
        }
        else
        {
            lightInt = light.intensity;
            lightR = light.color.r;
            lightG = light.color.g;
            lightB = light.color.b;

            if (GraphicsSettings.lightsUseColorTemperature)
            {
#if UNITY_2019_3_OR_NEWER
                if (light.useColorTemperature)
#endif
                {
                    var temp = Mathf.CorrelatedColorTemperatureToRGB(light.colorTemperature).gamma;
                    lightR *= temp.r;
                    lightG *= temp.g;
                    lightB *= temp.b;
                }
            }
        }
    }

    protected virtual void OnSceneGUI()
    {
        if (projectionMode)
        {
            var obj = target as BakeryDirectLight;
            var tform = obj.transform;

            Vector3 normal = tform.forward;
            Vector3 binormal, tangent;
            if(Mathf.Abs(normal.x) > Mathf.Abs(normal.z))
            {
                binormal = new Vector3(-normal.y, normal.x, 0);
            }
            else
            {
                binormal = new Vector3(0, -normal.z, normal.y);
            }
            binormal = binormal.normalized;
            tangent = Vector3.Cross(binormal, normal);
            var rot = Quaternion.LookRotation(normal, -binormal);
            var pos = tangent * -obj.cloudShadowOffsetX/obj.cloudShadowTilingX + binormal * -obj.cloudShadowOffsetY/obj.cloudShadowTilingY;
            pos += tangent * 0.5f/obj.cloudShadowTilingX;
            pos += binormal * 0.5f/obj.cloudShadowTilingY;
            var ntangent = tangent;
            var nbinormal = binormal;

            var mtx = new Matrix4x4();
            tangent /= obj.cloudShadowTilingX;
            binormal /= obj.cloudShadowTilingY;
            float depth = 1000.0f;
            normal *= depth;
            //pos += normal * depth * 0.5f;
            mtx.SetColumn(0, new Vector4(tangent.x, tangent.y, tangent.z, 0));
            mtx.SetColumn(1, new Vector4(binormal.x, binormal.y, binormal.z, 0));
            mtx.SetColumn(2, new Vector4(normal.x, normal.y, normal.z, 0));
            mtx.SetColumn(3, new Vector4(pos.x, pos.y, pos.z, 1.0f));

            Handles.color = Color.red;
            Handles.matrix = mtx;// * Matrix4x4.Translate(Vector3.one * 0.5f);
            Handles.DrawWireCube(Vector3.zero, Vector3.one);
            Handles.matrix = Matrix4x4.identity;

            EditorGUI.BeginChangeCheck();
            var newPos = Handles.PositionHandle(pos, rot);
            if (EditorGUI.EndChangeCheck())
            {
                Undo.RecordObject(obj, "Move directional light projection");
                
                newPos -= ntangent * 0.5f/obj.cloudShadowTilingX;
                newPos -= nbinormal * 0.5f/obj.cloudShadowTilingY;
                obj.cloudShadowOffsetX = Vector3.Dot(ntangent, newPos) * -obj.cloudShadowTilingX;
                obj.cloudShadowOffsetY = Vector3.Dot(nbinormal, newPos) * -obj.cloudShadowTilingY;
                Shader.SetGlobalVector("_BakeryProjectionTilingOffset", new Vector4(obj.cloudShadowTilingX, obj.cloudShadowTilingY, obj.cloudShadowOffsetX, obj.cloudShadowOffsetY));
                if (BakeryDirectLight.lightsChanged == 0) BakeryDirectLight.lightsChanged = 1;
            }

            EditorGUI.BeginChangeCheck();
            float size = HandleUtility.GetHandleSize(pos);
            var newScale = Handles.ScaleHandle(new Vector3(obj.cloudShadowTilingX, obj.cloudShadowTilingY, 0), pos - tform.up * size * 0.25f, rot, -size);
            if (EditorGUI.EndChangeCheck())
            {
                Undo.RecordObject(obj, "Scale directional light projection");
                obj.cloudShadowTilingX = newScale.x;
                obj.cloudShadowTilingY = newScale.y;
                Shader.SetGlobalVector("_BakeryProjectionTilingOffset", new Vector4(obj.cloudShadowTilingX, obj.cloudShadowTilingY, obj.cloudShadowOffsetX, obj.cloudShadowOffsetY));
                if (BakeryDirectLight.lightsChanged == 0) BakeryDirectLight.lightsChanged = 1;
            }
        }
    }

    public override void OnInspectorGUI()
    {
        //if (showFtrace)
        //{
            OnEnable();
            serializedObject.Update();

            TestPreviewRefreshProperty(ref texCached, ftraceLightTexture.objectReferenceValue);

            EditorGUILayout.PropertyField(ftraceLightColor, new GUIContent("Color", "Color of the light"));
            EditorGUILayout.PropertyField(ftraceLightIntensity, new GUIContent("Intensity", "Color multiplier (Lux / Pi)"));
            EditorGUILayout.PropertyField(ftraceLightShadowSpread, new GUIContent("Shadow spread", "Controls shadow blurriness from 0 to 1"));
            EditorGUILayout.PropertyField(ftraceLightSamples, new GUIContent("Shadow samples", "The amount of rays tested for this light. Rays are emitted from lightmap texel towards the light, distributed conically. Radius of the cone depends on Shadow Spread."));

            //ftraceLightBitmask.intValue = EditorGUILayout.MaskField(new GUIContent("Bitmask", "Lights only affect renderers with overlapping bits"), ftraceLightBitmask.intValue, selStrings);
            int prevVal = ftraceLightBitmask.intValue;
            int newVal = EditorGUILayout.MaskField(new GUIContent("Bitmask", "Lights only affect renderers with overlapping bits"), ftraceLightBitmask.intValue, selStrings);
            if (prevVal != newVal) ftraceLightBitmask.intValue = newVal;

            /*
            EditorGUILayout.PropertyField(ftraceLightBakeToIndirect, new GUIContent("Bake to indirect", "Add direct contribution from this light to indirect-only lightmaps"));
            if (ftraceLightBakeToIndirect.boolValue && ftraceLightShadowmask.boolValue) ftraceLightShadowmask.boolValue = false;

            EditorGUILayout.PropertyField(ftraceLightShadowmask, new GUIContent("Shadowmask", "Enable mixed lighting. Static shadows from this light will be baked, and real-time light will cast shadows from dynamic objects."));
            if (ftraceLightBakeToIndirect.boolValue && ftraceLightShadowmask.boolValue) ftraceLightBakeToIndirect.boolValue = false;
            */

            if (storage == null) storage = ftRenderLightmap.FindRenderSettingsStorage();
            var rmode = storage.renderSettingsUserRenderMode;
            if (rmode != (int)ftRenderLightmap.RenderMode.FullLighting)
            {
                BakeWhat contrib;
                if (ftraceLightShadowmask.boolValue)
                {
                    if (ftraceLightBakeToIndirect.boolValue)
                    {
                        contrib = BakeWhat.DirectIndirectShadowmask;
                    }
                    else
                    {
                        contrib = BakeWhat.IndirectAndShadowmask;
                    }
                }
                else if (ftraceLightBakeToIndirect.boolValue)
                {
                    contrib = BakeWhat.DirectAndIndirect;
                }
                else
                {
                    contrib = BakeWhat.IndirectOnly;
                }
                var prevContrib = contrib;

                if (rmode == (int)ftRenderLightmap.RenderMode.Indirect)
                {
                    contrib = (BakeWhat)EditorGUILayout.Popup("Baked contribution", (int)contrib, directContributionIndirectOptions);
                }
                else if (rmode == (int)ftRenderLightmap.RenderMode.Shadowmask)
                {
                    contrib = (BakeWhat)EditorGUILayout.Popup("Baked contribution", (int)contrib, directContributionOptions);
                }

                if (prevContrib != contrib)
                {
                    if (contrib == BakeWhat.IndirectOnly)
                    {
                        ftraceLightShadowmask.boolValue = false;
                        ftraceLightBakeToIndirect.boolValue = false;
                    }
                    else if (contrib == BakeWhat.IndirectAndShadowmask)
                    {
                        ftraceLightShadowmask.boolValue = true;
                        ftraceLightBakeToIndirect.boolValue = false;
                    }
                    else if (contrib == BakeWhat.DirectIndirectShadowmask)
                    {
                        ftraceLightShadowmask.boolValue = true;
                        ftraceLightBakeToIndirect.boolValue = true;
                    }
                    else
                    {
                        ftraceLightShadowmask.boolValue = false;
                        ftraceLightBakeToIndirect.boolValue = true;
                    }
                }

                if (ftraceLightShadowmask.boolValue)
                {
                    EditorGUILayout.PropertyField(ftraceLightShadowmaskDenoise, new GUIContent("Denoise shadowmask", "Apply denoising to shadowmask texture. For sharp shadows it may be unnecessary."));
                }
            }

            EditorGUILayout.PropertyField(ftraceLightIndirectIntensity, new GUIContent("Indirect intensity", "Non-physical GI multiplier for this light"));

            EditorGUILayout.PropertyField(ftraceLightSupersample, new GUIContent("Anti-alias", "Performs supersampling for the shadows, using 8 sub-samples."));

            EditorGUILayout.PropertyField(ftraceLightTexture, new GUIContent("Texture projection", "Tiled projected texture"));
            if (ftraceLightTexture.objectReferenceValue != null)
            {
                var obj = target as BakeryDirectLight;

                EditorGUILayout.PropertyField(ftraceLightCSTilingX, new GUIContent("Tiling U", "Cloud shadow U tiling"));
                EditorGUILayout.PropertyField(ftraceLightCSTilingY, new GUIContent("Tiling V", "Cloud shadow V tiling"));
                EditorGUILayout.PropertyField(ftraceLightCSOffsetX, new GUIContent("Offset U", "Cloud shadow U tiling"));
                EditorGUILayout.PropertyField(ftraceLightCSOffsetY, new GUIContent("Offset V", "Cloud shadow V tiling"));

                if (GUILayout.Button("Tweak projection in Scene View"))
                {
                    ftSceneView.ToggleProjMode();
                    projectionMode = ftSceneView.enabled;

                    UnityEditor.EditorWindow.GetWindow<SceneView>();
                    var lastView = SceneView.lastActiveSceneView;
                    if (lastView == null)
                    {
                        Debug.LogError("Can't get lastActiveSceneView");
                    }
                    else
                    {
                        var cam = lastView.camera;
                        if (cam == null)
                        {
                            Debug.LogError("Can't get sceneView camera");
                        }
                        else
                        {
                            var camTform = cam.transform;
                            var tform = obj.transform;
                        }
                    }
                }

                if (projectionMode)
                {
                    EditorGUILayout.Space();
                    if (GUILayout.Button("Render reference frame"))
                    {
                        float far = 1000.0f;
                        int width = 512;
                        int height = 512;

                        var g = new GameObject();
                        g.name = "TempCamera";
                        var cam = g.AddComponent<Camera>();
                        cam.aspect = obj.cloudShadowTilingY / obj.cloudShadowTilingX;
                        cam.farClipPlane = far;
                        cam.orthographic = true;
                        cam.orthographicSize = (1.0f/obj.cloudShadowTilingY) * 0.5f;
                        //cam.cullingMask = renderMapLayers;

                        var tform = obj.transform;
                        Vector3 normal = tform.forward;
                        Vector3 binormal, tangent;
                        if(Mathf.Abs(normal.x) > Mathf.Abs(normal.z))
                        {
                            binormal = new Vector3(-normal.y, normal.x, 0);
                        }
                        else
                        {
                            binormal = new Vector3(0, -normal.z, normal.y);
                        }
                        binormal = binormal.normalized;
                        tangent = Vector3.Cross(binormal, normal);
                        var rot = Quaternion.LookRotation(normal, -binormal);
                        var pos = tangent * -obj.cloudShadowOffsetX/obj.cloudShadowTilingX + binormal * -obj.cloudShadowOffsetY/obj.cloudShadowTilingY;
                        pos += tangent * 0.5f/obj.cloudShadowTilingX;
                        pos += binormal * 0.5f/obj.cloudShadowTilingY;

                        cam.transform.position = pos - normal * far*0.5f;
                        cam.transform.rotation = rot;

                        var rt = new RenderTexture(width, height, 16, RenderTextureFormat.ARGB32, RenderTextureReadWrite.sRGB);
                        cam.targetTexture = rt;
                        cam.enabled = false;
#if UNITY_2017_1_OR_NEWER
                        cam.cameraType = CameraType.Reflection; // trick for SRP
#endif
                        cam.Render();

                        var tex = new Texture2D(width, height, TextureFormat.RGBA32, false);
                        Graphics.SetRenderTarget(rt);
                        tex.ReadPixels(new Rect(0, 0, width, height), 0, 0, false);
                        tex.Apply();

                        int index, indexA, indexB;
                        int minSwapped;
                        Color a, b;
                        var pixels = tex.GetPixels();
                        for(int y=0; y<height; y++)
                        {
                            index = y*width;
                            minSwapped = 16384;
                            for(int x=0; x<width; x++)
                            {
                                indexA = index+x;
                                if (minSwapped == indexA) break;
                                indexB = index+(width-1)-x;
                                a = pixels[indexA];
                                b = pixels[indexB];
                                pixels[indexA] = b;
                                pixels[indexB] = a;
                                minSwapped = indexB;
                            }
                        }
                        tex.SetPixels(pixels);

                        RenderTexture.active = null;
                        rt.Release();

                        byte[] _bytes = tex.EncodeToPNG();
                        var path = EditorUtility.SaveFilePanelInProject("Save texture", "", "png", "");
                        if (path.Length != 0)
                        {
                            System.IO.File.WriteAllBytes(path, _bytes);
                        }

                        DestroyImmediate(g);

                        AssetDatabase.Refresh();
                    }

                    Shader.SetGlobalTexture("_BakeryProjectionMap", ftraceLightTexture.objectReferenceValue as Texture2D);
                    Shader.SetGlobalVector("_BakeryProjectionDir", obj.gameObject.transform.forward);
                    Shader.SetGlobalVector("_BakeryProjectionTilingOffset", new Vector4(obj.cloudShadowTilingX, obj.cloudShadowTilingY, obj.cloudShadowOffsetX, obj.cloudShadowOffsetY));
                }

                EditorGUILayout.Space();
                EditorGUILayout.Space();
            }

            serializedObject.ApplyModifiedProperties();
        //}


        bool showError = false;
        string why = "";

        bool shadowmaskNoDynamicLight = false;

        foreach(BakeryDirectLight selectedLight in targets)
        {
            bool match = true;

            var light = selectedLight.GetComponent<Light>();
            if (light == null)
            {
                if (ftraceLightShadowmask.boolValue) shadowmaskNoDynamicLight = true;
                continue;
            }
            if (!light.enabled)
            {
                if (ftraceLightShadowmask.boolValue) shadowmaskNoDynamicLight = true;
            }
            var so = new SerializedObject(selectedLight);
            InitSerializedProperties(so);

            if (light.type != LightType.Directional)
            {
                match = false;
                why = "real-time light is not direct";
            }

            if (light.bounceIntensity != ftraceLightIndirectIntensity.floatValue)
            {
                match = false;
                why = "indirect intensity doesn't match";
            }

            var clr = ftraceLightColor.colorValue;
            float eps = 1.0f / 255.0f;
            float lightR, lightG, lightB, lightInt;
            float fr, fg, fb;
            float fintensity = ftraceLightIntensity.floatValue;
            if (isHDRP) fintensity *= Mathf.PI;
            if (PlayerSettings.colorSpace == ColorSpace.Linear)
            {
                fr = clr.r;// * fintensity;
                fg = clr.g;// * fintensity;
                fb = clr.b;// * fintensity;
            }
            else
            {
                fr = clr.r;
                fg = clr.g;
                fb = clr.b;
            }
            GetLinearLightParameters(light, out lightR, out lightG, out lightB, out lightInt);

            if (GraphicsSettings.lightsUseLinearIntensity || PlayerSettings.colorSpace != ColorSpace.Linear)
            {
                if (Mathf.Abs(lightR - fr) > eps || Mathf.Abs(lightG - fg) > eps || Mathf.Abs(lightB - fb) > eps)
                {
                    match = false;
                    why = "color doesn't match";
                }
                else if (Mathf.Abs(lightInt - fintensity) > eps)
                {
                    match = false;
                    why = "intensity doesn't match";
                }
            }
            else
            {
                eps *= Mathf.Max(lightInt, fintensity);
                if (Mathf.Abs(lightR*lightInt - fr*fintensity) > eps ||
                    Mathf.Abs(lightG*lightInt - fg*fintensity) > eps ||
                    Mathf.Abs(lightB*lightInt - fb*fintensity) > eps)
                {
                    match = false;
                    why = "intensity doesn't match";
                }
            }

            if (!match)
            {
                showError = true;
            }
        }

        if (shadowmaskNoDynamicLight)
        {
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Warning: shadowmask needs enabled real-time light to work");
        }

        if (showError)
        {
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Real-time light doesn't match lightmap: " + why);
            if (GUILayout.Button("Match lightmapped to real-time"))
            {
                foreach(BakeryDirectLight selectedLight in targets)
                {
                    var light = selectedLight.GetComponent<Light>();
                    if (light == null) continue;
                    //if (!light.enabled) continue;
                    var so = new SerializedObject(selectedLight);
                    InitSerializedProperties(so);

                    float lightR, lightG, lightB, lightInt;
                    GetLinearLightParameters(light, out lightR, out lightG, out lightB, out lightInt);
                    ftraceLightColor.colorValue = new Color(lightR, lightG, lightB);
                    ftraceLightIntensity.floatValue = lightInt;

                    ftraceLightIndirectIntensity.floatValue = light.bounceIntensity;

                    if (isHDRP) ftraceLightIntensity.floatValue /= Mathf.PI;

                    so.ApplyModifiedProperties();
                }
            }
            if (GUILayout.Button("Match real-time to lightmapped"))
            {
                foreach(BakeryDirectLight selectedLight in targets)
                {
                    var light = selectedLight.GetComponent<Light>();
                    if (light == null) continue;
                    //if (!light.enabled) continue;
                    var so = new SerializedObject(selectedLight);
                    InitSerializedProperties(so);

                    Undo.RecordObject(light, "Change light");
                    if (PlayerSettings.colorSpace != ColorSpace.Linear)
                    {
                        light.color = ftraceLightColor.colorValue;
                        light.intensity = ftraceLightIntensity.floatValue;
                    }
                    else if (!GraphicsSettings.lightsUseLinearIntensity)
                    {
                        float fr, fg, fb;
                        float fintensity = ftraceLightIntensity.floatValue;
                        var clr = ftraceLightColor.colorValue;
                        fr = clr.linear.r;// * fintensity;
                        fg = clr.linear.g;// * fintensity;
                        fb = clr.linear.b;// * fintensity;

                        fr = Mathf.Pow(fr * fintensity, 1.0f / 2.2f);
                        fg = Mathf.Pow(fg * fintensity, 1.0f / 2.2f);
                        fb = Mathf.Pow(fb * fintensity, 1.0f / 2.2f);
                        float fint = Mathf.Max(Mathf.Max(fr, fg), fb);
                        fr /= fint;
                        fg /= fint;
                        fb /= fint;
                        light.color = new Color(fr, fg, fb);
                        light.intensity = fint;
                    }
                    else
                    {
                        light.color = ftraceLightColor.colorValue;
                        light.intensity = ftraceLightIntensity.floatValue;
                    }
                    light.colorTemperature = 6570; // neutral in Unity
                    light.type = LightType.Directional;
                    light.bounceIntensity = ftraceLightIndirectIntensity.floatValue;
                    if (isHDRP) SetHDRPLight(light);
                }
            }
        }


        if (PlayerSettings.colorSpace == ColorSpace.Linear)
        {
            if (!GraphicsSettings.lightsUseLinearIntensity)
            {
                EditorGUILayout.Space();
                EditorGUILayout.LabelField("Warning: project is not set up to use linear light intensity.");
                EditorGUILayout.LabelField("GraphicsSettings.lightsUseLinearIntensity should be TRUE.");
                if (GUILayout.Button("Fix"))
                {
                    GraphicsSettings.lightsUseLinearIntensity = true;
                }
            }
            else
            {
                EditorGUILayout.Space();
                EditorGUILayout.LabelField("Project is using linear light intensity. This is nice.");
                if (GUILayout.Button("Change to non-linear"))
                {
                    GraphicsSettings.lightsUseLinearIntensity = false;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftDirectLightInspector.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftErrorCodes.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 54cb23fa553d8b4479e0374ee0f9c502
# ASMDEF: BakeryEditorAssembly.dll
# ---
#if UNITY_EDITOR

using System.Collections.Generic;

public class ftErrorCodes
{
    static Dictionary<int, string> ftraceMap = new Dictionary<int, string>
    {
        {1, "Unknown error. See .ftracelog.txt for details."},
        {2, "Error selecting pass"},
        {5120, "Can't open lms.bin"},
        {984, "lmlod.bin doesn't match lms.bin"},
        {500, "Can't load geometry data. See .ftracelog.txt for details."},
        {501, "Can't load UVGBuffer smooth position"},
        {502, "Can't load UVGBuffer face normal"},
        {505, "Can't load trimarks.bin"},
        {5005, "Can't load sky.bin"},
        {500599, "Can't load ao.bin"},
        {5005991, "Can't load sss.bin"},
        {507, "Can't load vbtraceUV0.bin"},
        {508, "Can't load UVGBuffer tangent"},
        {550, "Can't load light data. See .ftracelog.txt for details."},
        {557, "Can't load alpha IDs. See .ftracelog.txt for details."},
        {512, "Can't load compositing data. See .ftracelog.txt for details."},
        {51298, "Can't open addao.bin"},
        {875, "Can't load heightmap. See .ftracelog.txt for details."},
        {90, "Can't load normal to compose. See .ftracelog.txt for details."},
        {91, "Can't load lightmap to compose. See .ftracelog.txt for details."},
        {909, "No enabled CUDA devices. See .ftracelog.txt for details."},
        {910, "Can't load direction to compose. See .ftracelog.txt for details."},
        {92, "Can't load lightmap to compose. See .ftracelog.txt for details."},
        {920, "Can't load lightmap to compose. See .ftracelog.txt for details."},
        {921, "Can't load emission. See .ftracelog.txt for details."},
        {93, "Can't load lightmap to compose. See .ftracelog.txt for details."},
        {94, "Can't load lightmap. See .ftracelog.txt for details."},
        {940, "Can't read direction for GI. See .ftracelog.txt for details."},
        {95, "Can't read lightmap for GI. See .ftracelog.txt for details."},
        {510, "Can't write composed lightmap. See .ftracelog.txt for details."},
        {514, "Can't write composed lightmap. See .ftracelog.txt for details."},
        {7500, "Can't load UVGBuffer normal or position"},
        {5090, "Can't decompress UVGBuffer normal"},
        {5091, "Can't decompress UVGBuffer position"},
        {5092, "Can't decompress UVGBuffer smooth position"},
        {5093, "Can't decompress UVGBuffer face normal"},
        {5083, "Can't decompress UVGBuffer tangent"},
        {7007, "Can't load direct.bin"},
        {7771, "Can't read sky texture"},
        {7772, "Can't read light texture"},
        {888, "No texture name for cubemaplight"},
        {8008, "Can't load direct lighting."},
        {1000, "Can't read albedo for GI. See .ftracelog.txt for details."},
        {1001, "Can't read lightmap for GI. See .ftracelog.txt for details."},
        {1007, "Can't read direction for GI. See .ftracelog.txt for details."},
        {1888, "Failed to initialize"},
        {10000, "Can't load gi.bin"},
        {850, "Can't open log file"}
    };

    static Dictionary<int, string> combineMasksMap = new Dictionary<int, string>
    {
        {23, "Can't load texture"},
        {501, "Can't write file. See console for details."},
        {5, "Failed to save TGA file. See console for details."},
        {55, "Failed to save PNG file. See console for details."}
    };

    static Dictionary<int, string> denoiserMap = new Dictionary<int, string>
    {
        {2, "Incorrect arguments"},
        {3, "Incorrect tile size. Must be between 64 and 8192"},
        {500, "Can't load texture. See console for details."},
        {5001, "Can't load texture. See console for details."},
        {5002, "Can't load texture. See console for details."},
        {5003, "Can't load texture. See console for details."},
        {4, "Incorrect tile size. Must be width%tile == height%tile == 0"},
        {501, "Can't write file. See console for details."},
        {505, "Unknown error (old driver?)"}
    };

    static Dictionary<int, string> h2hMap = new Dictionary<int, string>
    {
        {23, "Can't load texture. See console for details."},
        {2, "Failed to get image data from DDS. See console for details."},
        {3, "Failed to init D3D11"},
        {4, "Failed to convert"},
        {45, "Failed to transform pixels"},
        {5, "Failed to save HDR file. See console for details."}
    };

    static Dictionary<int, string> i2tMap = new Dictionary<int, string>
    {
        {1, "Incorrect arguments"},
        {2, "Can't read file. See console for details."},
        {3, "Can't write file. See console for details."},
        {4, "IES file is not valid. See console for details."},
        {5, "IES file uses unknown symmetry mode. See console for details."}
    };

    static Dictionary<int, string> seamfixerMap = new Dictionary<int, string>
    {
        {1, "Incorrect arguments"},
        {2, "Failed to init D3D11"},
        {501, "Can't load vbtraceTex.bin"},
        {10, "Can't load lms.bin"},
        {600, "Can't load lightmap"},
        {22, "Can't create D3D11 resource"},
        {3, "Can't create D3D11 resource"},
        {4, "Can't allocate RAM texture"},
        {8, "Can't save texture. See console for details."}
    };

    static Dictionary<int, string> lmrMap = new Dictionary<int, string>
    {
        {2, "Failed to init D3D11 or create resource"},
        {3, "Can't create D3D11 resource"},
        {601, "Can't load lodmask"},
        {602, "Can't decompress lodmask (unexpected size)"},
        {32, "Can't create mip texture"},
        {33, "Can't create mip render target"},
        {34, "Can't create mip shader resource view"},
        {4, "Can't allocate RAM mip texture"},
        {8, "Can't save texture"}
    };

    static Dictionary<int, string> serverMap = new Dictionary<int, string>
    {
        {ftClient.SERVERERROR_IDLE, "Idle"},
        {ftClient.SERVERERROR_COPY, "File copying failed"},
        {ftClient.SERVERERROR_GIPARAMS, "Failed to generate GI parameters"},
        {ftClient.SERVERERROR_NOTIMPLEMENTED, "Feature is not implemented"},
        {ftClient.SERVERERROR_UNKNOWNTASK, "Unknown task submitted"},
        {ftClient.SERVERERROR_SCENENAMETOOLONG, "Scene name is too long"},
        {ftClient.SERVERERROR_FILENOTFOUND, "File not found"},
        {ftClient.SERVERERROR_FILEHASZEROSIZE, "File has zero size"},
        {ftClient.SERVERERROR_NOMEM, "Out of memory"},
        {ftClient.SERVERERROR_INCORRECT, "Incorrect request"},
        {ftClient.SERVERERROR_INCORRECTFILENAME, "Incorrect filename"},
        {ftClient.SERVERERROR_WRITEFAILED, "write failed"},
        {ftClient.SERVERERROR_INCORRECTARGS, "incorrect arguments"},
        {ftClient.SERVERERROR_FILESIZE, "file size is too large"},
        {ftClient.SERVERERROR_STATUSLIMIT, "status message can't fit filename"}
    };

    static Dictionary<int, string> serverAppMap = new Dictionary<int, string>
    {
        {ftClient.SERVERTASK_FTRACE, "ftrace"},
        {ftClient.SERVERTASK_FTRACERTX, "ftraceRTX"},
        {ftClient.SERVERTASK_COMBINEMASKS, "combineMasks"},

        {ftClient.SERVERTASK_DENOISE5, "denoiserLegacy"},
        {ftClient.SERVERTASK_DENOISE6, "denoiser"},
        {ftClient.SERVERTASK_DENOISE7, "denoiser72"},
        {ftClient.SERVERTASK_DENOISEOIDN, "denoiserOIDN"},
        {ftClient.SERVERTASK_DENOISEOIDN2, "denoiserOIDN2"},

        {ftClient.SERVERTASK_HF2HDR, "halffloat2hdr"},
        {ftClient.SERVERTASK_RGBA2TGA, "rgba2tga"},
        {ftClient.SERVERTASK_SEAMFIX, "seamfixer"}
    };

    public static string TranslateFtrace(int code, bool rtx)
    {
        bool unknown = false;
        string text;
        if (!ftraceMap.TryGetValue(code, out text))
        {
            unknown = true;
            text = "Unknown error";
        }
        text += " (" + code + ")";
        if (unknown || code == 1)
        {
            text += "\n\nPossibly incompatible RTX mode? Try running Bakery -> Utilities -> Detect optimal settings.";
        }
        return text;
    }

    public static string TranslateCombineMasks(int code)
    {
        string text;
        if (!combineMasksMap.TryGetValue(code, out text)) text = "Unknown error";
        return text + " (" + code + ")";
    }

    public static string TranslateDenoiser(int code)
    {
        string text;
        if (!denoiserMap.TryGetValue(code, out text)) text = "Unknown error";
        return text + " (" + code + ")";
    }

    public static string TranslateH2H(int code)
    {
        string text;
        if (!h2hMap.TryGetValue(code, out text)) text = "Unknown error";
        return text + " (" + code + ")";
    }

    public static string TranslateI2T(int code)
    {
        string text;
        if (!i2tMap.TryGetValue(code, out text)) text = "Unknown error";
        return text + " (" + code + ")";
    }

    public static string TranslateSeamfixer(int code)
    {
        string text;
        if (!seamfixerMap.TryGetValue(code, out text)) text = "Unknown error";
        return text + " (" + code + ")";
    }

    public static string TranslateLMRebake(int code)
    {
        string text;
        if (!lmrMap.TryGetValue(code, out text)) text = "Unknown error";
        return text + " (" + code + ")";
    }

    public static string TranslateServerApp(int app)
    {
        string text;
        if (!serverAppMap.TryGetValue(app, out text)) text = "Unknown executable " + " (" + app + ")";
        return text;
    }

    public static string TranslateServer(int code, int app=0, int appCode=0)
    {
        string text;
        if (code == ftClient.SERVERERROR_BUSY)
        {
            text = "Busy (" + app + "/" + appCode + ")";
        }
        else if (code == ftClient.SERVERERROR_APPERR)
        {
            var appName = TranslateServerApp(app);
            text = appName + " error: " + Translate(appName, appCode);
        }
        else if (code == ftClient.SERVERERROR_EXEC)
        {
            text = "Failed to run " + TranslateServerApp(app);
        }
        else
        {
            if (!serverMap.TryGetValue(code, out text)) text = "Unknown error (" + code + ")";
        }
        return text;
    }

    public static string Translate(string app, int code)
    {
        if (app == "ftrace") return TranslateFtrace(code, false);
        if (app == "ftraceRTX") return TranslateFtrace(code, true);
        if (app == "combineMasks") return TranslateCombineMasks(code);
        if (app == "denoiser") return TranslateDenoiser(code);
        if (app == "denoiser72") return TranslateDenoiser(code);
        if (app == "denoiserLegacy") return TranslateDenoiser(code);
        if (app == "denoiserOIDN") return TranslateDenoiser(code);
        if (app == "denoiserOIDN2") return TranslateDenoiser(code);
        if (app == "halffloat2hdr") return TranslateH2H(code);
        if (app == "ies2tex") return TranslateI2T(code);
        if (app == "rgba2tga") return TranslateCombineMasks(code);
        if (app == "seamfixer") return TranslateSeamfixer(code);
        return ""+code;
    }
}

#endif
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftErrorCodes.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftExtendLightmapParameters.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 38b33630a03b6c04e9e30f4d89644c03
# ASMDEF: BakeryEditorAssembly.dll
# ---
using UnityEngine;
using UnityEngine.Rendering;
using UnityEditor;
using UnityEditor.SceneManagement;
using System;
using System.IO;
using System.Text;
using System.Reflection;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;

[CustomEditor(typeof(LightmapParameters), true)]
[CanEditMultipleObjects]
public class ftExtendLightmapParameters : Editor
{
    Editor defaultEditor;
    //LightmapParameters lp;
    SerializedProperty spBakedTag;
    bool tagOverride = false;
    int prevTag = -999;
    int tagDataIndex = -1;

    static bool showBakeryOnly = false;
    static ftGlobalStorage gstorage;

    void ValidateTagOverride()
    {
        tagOverride = false;
        int curTag = spBakedTag.intValue;
        if (gstorage == null) gstorage = ftRenderLightmap.FindGlobalStorage();
        var tagTable = gstorage.tagOverrides;
        if (tagTable == null) tagTable = gstorage.tagOverrides = new List<ftGlobalStorage.TagData>();
        for(int i=0; i<tagTable.Count; i++)
        {
            var tagData = tagTable[i];
            if (tagData.tag != curTag) continue;
            tagOverride = true;
            tagDataIndex = i;
            break;
        }
    }

    void InitSerializedProperties(SerializedObject obj)
    {
        spBakedTag = obj.FindProperty("bakedLightmapTag");
        ValidateTagOverride();
    }

    void OnEnable()
    {
        defaultEditor = Editor.CreateEditor(targets, Type.GetType("UnityEditor.LightmapParametersEditor, UnityEditor"));
        //lp = target as LightmapParameters;
        InitSerializedProperties(serializedObject);
    }

    void OnDisable()
    {
        MethodInfo disableMethod = defaultEditor.GetType().GetMethod("OnDisable", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
        if (disableMethod != null) disableMethod.Invoke(defaultEditor,null);
        DestroyImmediate(defaultEditor);
    }

    public override void OnInspectorGUI()
    {
        if (!showBakeryOnly) defaultEditor.OnInspectorGUI();
        serializedObject.Update();

        EditorGUILayout.Space();
        EditorGUILayout.LabelField("Bakery", EditorStyles.boldLabel);
        showBakeryOnly = false;//EditorGUILayout.Toggle("Show compatible only", showBakeryOnly);
        //if (showBakeryOnly)
        {
            EditorGUILayout.PropertyField(spBakedTag, new GUIContent("Baked Tag", "Objects with different tag will always use separate atlases."));
            serializedObject.ApplyModifiedProperties();
        }

        int curTag = spBakedTag.intValue;
        if (curTag != prevTag) ValidateTagOverride();
        prevTag = curTag;

        if (curTag < 0) GUI.enabled = false;
        bool tagOverridePrev = tagOverride;
        tagOverride = EditorGUILayout.Toggle("Override settings for this tag", tagOverride);
        if (tagOverride != tagOverridePrev)
        {
            if (tagOverride)
            {
                var tagData = gstorage.DefaultTagData();
                tagData.tag = curTag;
                tagDataIndex = gstorage.tagOverrides.Count;
                gstorage.tagOverrides.Add(tagData);
                EditorUtility.SetDirty(gstorage);
            }
            else
            {
                var tagTable = gstorage.tagOverrides;
                for(int i=0; i<tagTable.Count; i++)
                {
                    var tagData = tagTable[i];
                    if (tagData.tag != curTag) continue;
                    tagTable.RemoveAt(i);
                    EditorUtility.SetDirty(gstorage);
                    break;
                }
            }
        }
        GUI.enabled = true;

        if (tagOverride)
        {
            var tagData = gstorage.tagOverrides[tagDataIndex];

            EditorGUILayout.PrefixLabel("Render mode");
            tagData.renderMode = (int)(BakeryLightmapGroup.RenderMode)EditorGUILayout.EnumPopup((BakeryLightmapGroup.RenderMode)tagData.renderMode);
            EditorGUILayout.PrefixLabel("Directional mode");
            tagData.renderDirMode = (int)(BakeryLightmapGroup.RenderDirMode)EditorGUILayout.EnumPopup((BakeryLightmapGroup.RenderDirMode)tagData.renderDirMode);
            tagData.bitmask = EditorGUILayout.MaskField(new GUIContent("Bitmask", "Lights only affect renderers with overlapping bits"), tagData.bitmask, ftLMGroupSelectorInspector.selStrings);
            tagData.transparentSelfShadow = EditorGUILayout.Toggle(new GUIContent("Transparent selfshadow", "Start rays behind the surface so it doesn't cast shadows on self. Might be useful for translucent foliage"), tagData.transparentSelfShadow);
            tagData.computeSSS = EditorGUILayout.Toggle("Subsurface scattering", tagData.computeSSS);
            if (tagData.computeSSS)
            {
                tagData.sssSamples = EditorGUILayout.IntField("Samples", tagData.sssSamples);
                tagData.sssDensity = EditorGUILayout.FloatField("Density", tagData.sssDensity);
                tagData.sssColor = EditorGUILayout.ColorField("Color", tagData.sssColor);
            }

            gstorage.tagOverrides[tagDataIndex] = tagData;
            EditorUtility.SetDirty(gstorage);
        }

        serializedObject.ApplyModifiedProperties();
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftExtendLightmapParameters.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftFixResettingGlobalsOnSave.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: bd16f24f4abb61548aeac9a94c816e3a
# ASMDEF: BakeryEditorAssembly.dll
# ---
#if UNITY_EDITOR

// Disable 'obsolete' warnings
#pragma warning disable 0618

using UnityEngine;
using UnityEditor;
using System.Collections;

// For reasons unknown Unity will reset all shader variables set by Shader.SetGlobal... if you save a scene
// So here is a hack to fix it
public class ftFixResettingsGlobalsOnSave : SaveAssetsProcessor
{
    static void ProcUpdate()
    {
        if (BakeryVolume.globalVolume != null) BakeryVolume.globalVolume.OnEnable(); // set global volume again
        EditorApplication.update -= ProcUpdate; // remove the callback
    }

    static string[] OnWillSaveAssets(string[] paths)
    {
        // Only do anything if there is a global volume in the scene
        if (BakeryVolume.globalVolume != null)
        {
            EditorApplication.update += ProcUpdate; // wait for the next editor update
        }
        return paths;
    }
}

#endif
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftFixResettingGlobalsOnSave.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftLightingDataGen.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 04a9623f45d46d64b8d852e0b0ea9a81
# ASMDEF: BakeryEditorAssembly.dll
# ---
using UnityEditor;
using UnityEngine;
using System;
using System.IO;
using System.Collections.Generic;
using System.Runtime.InteropServices;
#if UNITY_EDITOR

using UnityEngine.Rendering;
using System.Reflection;

public class ftLightingDataGen
{
    // Generates LightingDataAsset for all lights with baked occlusionMaskChannel
    public static bool GenerateShadowmaskLightingData(string outName, ref List<Light> lights, bool subtractive)
    {
        ftRenderLightmap.DebugLogInfo("Generating LightingDataAsset for " + lights.Count + " lights");

        bool success = true;
        try
        {
            PropertyInfo inspectorModeInfo = typeof(SerializedObject).GetProperty("inspectorMode", BindingFlags.NonPublic | BindingFlags.Instance);
            var edPath = ftLightmaps.GetEditorPath();
#if UNITY_2017_1_OR_NEWER
            var bytesP0 = File.ReadAllBytes(edPath + "lightingDataChunks/LightingData_2017_1_part0.bin");
            var bytesP1 = File.ReadAllBytes(edPath + "lightingDataChunks/LightingData_2017_1_part1.bin");
            var bytesP2 = File.ReadAllBytes(edPath + "lightingDataChunks/LightingData_2017_1_part2.bin");
            var bytesP3 = File.ReadAllBytes(edPath + "lightingDataChunks/LightingData_2017_1_part3.bin");
#else
            var bytesP0 = File.ReadAllBytes(edPath + "lightingDataChunks/LightingData_5_6_part0.bin");
            var bytesP1 = File.ReadAllBytes(edPath + "lightingDataChunks/LightingData_5_6_part1.bin");
            var bytesP2 = File.ReadAllBytes(edPath + "lightingDataChunks/LightingData_5_6_part2.bin");
            var bytesP3 = File.ReadAllBytes(edPath + "lightingDataChunks/LightingData_5_6_part3.bin");
#endif
            var f = new BinaryWriter(File.Open(outName, FileMode.Create));
            f.Write(bytesP0);
#if UNITY_2017_1_OR_NEWER
            f.Write(52 + 28 * lights.Count - 28);
            f.Write(bytesP1);
            f.Write(572 + 28 * lights.Count - 28);
#else
            f.Write(160 + 28 * lights.Count - 28);
            f.Write(bytesP1);
            f.Write(552 + 28 * lights.Count - 28);
#endif
            f.Write(bytesP2);
            f.Write(lights.Count);
            for(int i=0; i<lights.Count; i++)
            {
                var so = new SerializedObject(lights[i]);
                inspectorModeInfo.SetValue(so, InspectorMode.Debug, null);
                long fileid = so.FindProperty("m_LocalIdentfierInFile").longValue;
                f.Write(fileid);
                f.Write(0);
                f.Write(0);
            }
            f.Write(lights.Count);
            for(int i=0; i<lights.Count; i++)
            {
                var so = new SerializedObject(lights[i]);
                var channel = so.FindProperty("m_BakingOutput").FindPropertyRelative("occlusionMaskChannel").intValue;

                int val1 = subtractive ? 0 : -1;
                int val2 = subtractive ? 131076 : 131080;

                f.Write(val1);
                f.Write(channel);
                f.Write(val2);
            }
            f.Write(bytesP3);
            f.Close();
        }
        catch
        {
            ftRenderLightmap.DebugLogError("Failed to generate LightingDataAsset");
            success = false;
            throw;
        }
        return success;
    }

#if UNITY_2017_3_OR_NEWER
#else
    // Patches existing LightingDataAsset shadowmask channels
    public static bool PatchShadowmaskLightingData(string inName, string outName, ref Dictionary<long,long> inID2OutID, ref Dictionary<long,int> outIDChannel, bool subtractive)
    {
        try
        {
            var bytesIn = File.ReadAllBytes(inName);

            var lightCount = inID2OutID.Count;
            if (lightCount == 0) return false;

            var inIDsAsBytes = new byte[lightCount][];
            var outIDsAsBytes = new byte[lightCount][];
            var outChannelsAsBytes = new byte[lightCount][];
            var matches = new int[lightCount];
            int counter = 0;
            foreach(var pair in inID2OutID)
            {
                inIDsAsBytes[counter] = BitConverter.GetBytes(pair.Key);
                outIDsAsBytes[counter] = BitConverter.GetBytes(pair.Value);
                outChannelsAsBytes[counter] = BitConverter.GetBytes(outIDChannel[pair.Value]);
                counter++;
            }

            int replaced = 0;
            int firstAddressReplaced = bytesIn.Length;
            var lightsAsWritten = new int[lightCount];
            int lightsAsWrittenCounter = 0;
            for(int i=0; i<bytesIn.Length; i++)
            {
                var val = bytesIn[i];
                for(int j=0; j<lightCount; j++)
                {
                    var expectedVal = matches[j] >= 8 ? 0 : inIDsAsBytes[j][matches[j]];
                    if (val == expectedVal)
                    {
                        matches[j]++;
                        if (matches[j] == 16)
                        {
                            // Matched long + 8 zeros
                            // Replace fileid
                            for(int k=0; k<8; k++)
                            {
                                //Debug.LogError("Matched " + inIDsAsBytes[j][k]+" "+outIDsAsBytes[j][k]);
                                bytesIn[i - 15 + k] = outIDsAsBytes[j][k];
                            }
                            matches[j] = 0;
                            replaced++;

                            int addr = i - 15;
                            if (addr < firstAddressReplaced) firstAddressReplaced = addr;

                            lightsAsWritten[lightsAsWrittenCounter] = j;
                            lightsAsWrittenCounter++;
                        }
                    }
                    else
                    {
                        matches[j] = 0;
                    }
                }
            }

            if (firstAddressReplaced == bytesIn.Length)
            {
                ftRenderLightmap.DebugLogError("Failed to patch LightingDataAsset: unabled to replace light IDs");
                return false;
            }

            if (lightsAsWrittenCounter != lightCount)
            {
                ftRenderLightmap.DebugLogError("Failed to patch LightingDataAsset: light count differs in temp/real scenes (" + lightsAsWrittenCounter + " vs " + lightCount + ")");
                return false;
            }

            // IDs are patched. Now replace channels.

            for(int i=0; i<lightsAsWrittenCounter; i++)
            {
                int id = lightsAsWritten[i];
                var channelBytes = outChannelsAsBytes[id];
                int channelStartAddr = firstAddressReplaced + 16 * lightCount + 4 + 12 * i + 4;
                if (subtractive)
                {
                    for(int j=0; j<4; j++)
                    {
                        bytesIn[channelStartAddr + j - 4] = 0;
                    }
                }
                for(int j=0; j<4; j++)
                {
                    bytesIn[channelStartAddr + j] = channelBytes[j];
                }
                if (subtractive)
                {
                    var val2 = BitConverter.GetBytes(131076);
                    for(int j=0; j<4; j++)
                    {
                        bytesIn[channelStartAddr + j + 4] = val2[j];
                    }
                }
            }

            var f = new BinaryWriter(File.Open(outName, FileMode.Create));
            f.Write(bytesIn);
            f.Close();
            ftRenderLightmap.DebugLogInfo("PatchShadowmaskLightingData: patched " + replaced + " lights");
        }
        catch
        {
            ftRenderLightmap.DebugLogError("Failed to patch LightingDataAsset");
            return false;
        }

        return true;
    }
#endif
}

#endif
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftLightingDataGen.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftLightmappedPrefabInspector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a080b80faca4b9a4fa0a43361585c4be
# ASMDEF: BakeryEditorAssembly.dll
# ---
using UnityEditor;
using UnityEngine;

[CustomEditor(typeof(BakeryLightmappedPrefab))]
[CanEditMultipleObjects]
public class ftLightmappedPrefabInspector : UnityEditor.Editor
{
    bool allPrefabsGood = true;
    SerializedProperty isEnabled;
    SerializedProperty ignoreWarnings;

    void Refresh(BakeryLightmappedPrefab selected)
    {
        allPrefabsGood = selected.IsValid() && allPrefabsGood;
    }

    void OnPrefabInstanceUpdate(GameObject go)
    {
        allPrefabsGood = true;
        foreach(BakeryLightmappedPrefab selected in targets)
        {
            //if (go != selected.gameObject) continue;
            Refresh(selected);
        }
    }

    void OnEnable()
    {
        allPrefabsGood = true;
        foreach(BakeryLightmappedPrefab selected in targets)
        {
            Refresh(selected);
        }
        PrefabUtility.prefabInstanceUpdated += OnPrefabInstanceUpdate;
        isEnabled = serializedObject.FindProperty("enableBaking");
        ignoreWarnings = serializedObject.FindProperty("ignoreWarnings");
    }

    void OnDisable()
    {
        PrefabUtility.prefabInstanceUpdated -= OnPrefabInstanceUpdate;
    }

    public ftLightmapsStorage FindPrefabStorage(BakeryLightmappedPrefab pref)
    {
        var p = pref.gameObject;
        var bdataName = "BakeryPrefabLightmapData";
        var pstoreT = p.transform.Find(bdataName);
        if (pstoreT == null)
        {
            var pstoreG = new GameObject();
            pstoreG.name = bdataName;
            pstoreT = pstoreG.transform;
            pstoreT.parent = p.transform;
        }
        var pstore = pstoreT.gameObject.GetComponent<ftLightmapsStorage>();
        if (pstore == null) pstore = pstoreT.gameObject.AddComponent<ftLightmapsStorage>();
        return pstore;
    }

    public override void OnInspectorGUI() {

        serializedObject.Update();
        var prev = isEnabled.boolValue;
        EditorGUILayout.PropertyField(isEnabled, new GUIContent("Enable baking", "Prefab contents will be patched after baking if this checkbox is on. Patched prefab will be lightmapped when instantiated in any scene."));
        EditorGUILayout.PropertyField(ignoreWarnings, new GUIContent("Ignore warnings", "Still attempt to bake the prefab, even if it has unapplied properties."));
        serializedObject.ApplyModifiedProperties();

        if (isEnabled.boolValue != prev)
        {
            allPrefabsGood = true;
            foreach(BakeryLightmappedPrefab selected in targets)
            {
                selected.enableBaking = isEnabled.boolValue;
                Refresh(selected);
            }
        }

        if (allPrefabsGood)
        {
            EditorGUILayout.LabelField("Prefab connection: OK");
        }
        else
        {
            foreach(BakeryLightmappedPrefab selected in targets)
            {
                if (selected.errorMessage.Length > 0) EditorGUILayout.LabelField("Error: " + selected.errorMessage);
            }
        }

        if (GUILayout.Button("Load render settings from prefab"))
        {
            if (EditorUtility.DisplayDialog("Bakery", "Change current render settings to prefab?", "OK", "Cancel"))
            {
                var storage = ftRenderLightmap.FindRenderSettingsStorage();
                foreach(BakeryLightmappedPrefab pref in targets)
                {
                    var prefabStorage = FindPrefabStorage(pref);
                    ftLightmapsStorage.CopySettings(prefabStorage, storage);
                }
                var instance = (ftRenderLightmap)EditorWindow.GetWindow(typeof(ftRenderLightmap));
                if (instance != null) instance.LoadRenderSettings();
            }
        }

        if (GUILayout.Button("Save current render settings to prefab"))
        {
            if (EditorUtility.DisplayDialog("Bakery", "Save current render settings to prefab?", "OK", "Cancel"))
            {
                var storage = ftRenderLightmap.FindRenderSettingsStorage();
                foreach(BakeryLightmappedPrefab pref in targets)
                {
                    var prefabStorage = FindPrefabStorage(pref);
                    ftLightmapsStorage.CopySettings(storage, prefabStorage);
                    EditorUtility.SetDirty(prefabStorage);
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftLightmappedPrefabInspector.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftLightmapsStorageInspector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 3ebd176ebc8a2304c84bc65c23bbecd6
# ASMDEF: BakeryEditorAssembly.dll
# ---

using UnityEditor;
using UnityEngine;
using System;
using System.IO;
using System.Collections.Generic;
using System.Runtime.InteropServices;

[CustomEditor(typeof(ftLightmapsStorage))]
public class ftLightmapsStorageInspector : UnityEditor.Editor
{
    static bool showDebug = false;

    public override void OnInspectorGUI() {

        EditorGUILayout.LabelField("This object stores Bakery lightmapping data");

        if (showDebug)
        {
            if (GUILayout.Button("Hide debug info")) showDebug = false;
            DrawDefaultInspector();
        }
        else
        {
            if (GUILayout.Button("Show debug info")) showDebug = true;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftLightmapsStorageInspector.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftLightMeshInspector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c2b4c5d630c305d44a44bc6a7fb96344
# ASMDEF: BakeryEditorAssembly.dll
# ---

using UnityEditor;
using UnityEngine;
using System;
using System.IO;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using UnityEngine.Rendering;

[CustomEditor(typeof(BakeryLightMesh))]
[CanEditMultipleObjects]
public class ftLightMeshInspector : UnityEditor.Editor
{
    SerializedProperty ftraceLightColor;
    SerializedProperty ftraceLightIntensity;
    SerializedProperty ftraceLightIndirectIntensity;
    SerializedProperty ftraceLightTexture;
    SerializedProperty ftraceLightCutoff;
    SerializedProperty ftraceLightSamples;
    SerializedProperty ftraceLightSamples2;
    SerializedProperty ftraceLightSamples2_previous;
    SerializedProperty ftraceLightBitmask;
    SerializedProperty ftraceLightSelfShadow;
    SerializedProperty ftraceLightShadowmask;
    SerializedProperty ftraceLightBakeToIndirect;
    SerializedProperty ftraceLightShadowmaskFalloff;

    static string ftLightShaderName = "Bakery/Light";

    ftLightmapsStorage storage;

    int texCached = -1;

    static string[] selStrings = new string[] {"0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16",
                                                "17","18","19","20","21","22","23","24","25","26","27","28","29","30"};//,"31"};

    void InitSerializedProperties(SerializedObject obj)
    {
        ftraceLightColor = obj.FindProperty("color");
        ftraceLightTexture = obj.FindProperty("texture");
        ftraceLightIntensity = obj.FindProperty("intensity");
        ftraceLightIndirectIntensity = obj.FindProperty("indirectIntensity");
        ftraceLightCutoff = obj.FindProperty("cutoff");
        ftraceLightSamples = obj.FindProperty("samples");
        ftraceLightSamples2 = obj.FindProperty("samples2");
        ftraceLightSamples2_previous = obj.FindProperty("samples2_previous");
        ftraceLightBitmask = obj.FindProperty("bitmask");
        ftraceLightSelfShadow = obj.FindProperty("selfShadow");
        ftraceLightShadowmask = obj.FindProperty("shadowmask");
        ftraceLightBakeToIndirect = obj.FindProperty("bakeToIndirect");
        ftraceLightShadowmaskFalloff = obj.FindProperty("shadowmaskFalloff");
    }

    void OnEnable()
    {
        InitSerializedProperties(serializedObject);
    }

    void TestPreviewRefreshProperty(ref int cached, int newVal)
    {
        if (cached >= 0)
        {
            if (cached != newVal)
            {
                BakeryLightMesh.lightsChanged = 2;
            }
        }
        cached = newVal;
    }

    void TestPreviewRefreshProperty(ref int cached, UnityEngine.Object newVal)
    {
        if (newVal == null)
        {
            TestPreviewRefreshProperty(ref cached, 0);
            return;
        }
        TestPreviewRefreshProperty(ref cached, newVal.GetInstanceID());
    }

    void GetLinearLightParameters(Light light, out float lightR, out float lightG, out float lightB, out float lightInt)
    {
        if (PlayerSettings.colorSpace != ColorSpace.Linear)
        {
            lightInt = light.intensity;
            lightR = light.color.r;
            lightG = light.color.g;
            lightB = light.color.b;
            return;
        }

        if (!GraphicsSettings.lightsUseLinearIntensity)
        {
            lightR = Mathf.Pow(light.color.r * light.intensity, 2.2f);
            lightG = Mathf.Pow(light.color.g * light.intensity, 2.2f);
            lightB = Mathf.Pow(light.color.b * light.intensity, 2.2f);
            lightInt = Mathf.Max(Mathf.Max(lightR, lightG), lightB);
            lightR /= lightInt;
            lightG /= lightInt;
            lightB /= lightInt;
        }
        else
        {
            lightInt = light.intensity;
            lightR = light.color.r;
            lightG = light.color.g;
            lightB = light.color.b;

            if (GraphicsSettings.lightsUseColorTemperature)
            {
#if UNITY_2019_3_OR_NEWER
                if (light.useColorTemperature)
#endif
                {
                    var temp = Mathf.CorrelatedColorTemperatureToRGB(light.colorTemperature).gamma;
                    lightR *= temp.r;
                    lightG *= temp.g;
                    lightB *= temp.b;
                }
            }
        }
    }

    public static Vector2 GetAreaLightSize(Light obj)
    {
        Vector2 areaSize = obj.areaSize;

        var hdrpLight = obj.GetComponent("HDAdditionalLightData");
        if (hdrpLight != null)
        {
            var so = new SerializedObject(hdrpLight);
            if (so != null)
            {
                var hdrpLightTypeExtent = so.FindProperty("m_PointlightHDType");
                var hdrpLightTypeExtent2 = so.FindProperty("m_AreaLightShape");
                if (hdrpLightTypeExtent != null && hdrpLightTypeExtent2 != null)
                {
                    int extendedLightType = hdrpLightTypeExtent.intValue;
                    int extendedLightType2 = hdrpLightTypeExtent2.intValue;
                    if (extendedLightType == 1 && // area
                        extendedLightType2 == 0) // rectangle
                    {
                        var hdrpLightShapeWidth = so.FindProperty("m_ShapeWidth");
                        var hdrpLightShapeHeight = so.FindProperty("m_ShapeHeight");
                        areaSize = new Vector2(hdrpLightShapeWidth != null ? hdrpLightShapeWidth.floatValue : 1,
                                               hdrpLightShapeHeight != null ? hdrpLightShapeHeight.floatValue : 1);
                    }
                    else
                    {
                        Debug.LogError(obj.name + " HDRP light type unsupported: " + extendedLightType + ", " + extendedLightType2);
                    }
                }
            }
        }
        return areaSize;
    }

    public static Vector3[] GetAreaLightCorners(Light obj)
    {
        var areaSize = GetAreaLightSize(obj);

        var t = obj.transform;
        var pos = t.position;
        var right = t.right;
        var up = t.up;
        var extents = areaSize * 0.5f;
        var corners = new Vector3[4];
        corners[0] = pos - right * extents.x - up * extents.y;
        corners[1] = pos - right * extents.x + up * extents.y;
        corners[2] = pos + right * extents.x + up * extents.y;
        corners[3] = pos + right * extents.x - up * extents.y;

        return corners;
    }

    public static bool IsArea(Light obj)
    {
        var hdrpLight = obj.GetComponent("HDAdditionalLightData");
        if (hdrpLight != null)
        {
            var so = new SerializedObject(hdrpLight);
            if (so != null)
            {
                var hdrpLightTypeExtent = so.FindProperty("m_PointlightHDType");
                var hdrpLightTypeExtent2 = so.FindProperty("m_AreaLightShape");
                if (hdrpLightTypeExtent != null && hdrpLightTypeExtent2 != null)
                {
                    int extendedLightType = hdrpLightTypeExtent.intValue;
                    int extendedLightType2 = hdrpLightTypeExtent2.intValue;
                    if (extendedLightType == 1 && // area
                        extendedLightType2 == 0) // rectangle
                    {
                        return true;
                    }
                }
            }
        }
        else
        {
            return obj.type == LightType.Rectangle;
        }
        return false;
    }

    public override void OnInspectorGUI() {
        //if (showFtrace)
        {
            OnEnable();
            serializedObject.Update();

            TestPreviewRefreshProperty(ref texCached, ftraceLightTexture.objectReferenceValue);

            EditorGUILayout.PropertyField(ftraceLightColor, new GUIContent("Color", "Color of the light"));
            EditorGUILayout.PropertyField(ftraceLightIntensity, new GUIContent("Intensity", "Color multiplier"));
            EditorGUILayout.PropertyField(ftraceLightTexture, new GUIContent("Texture", "Texture"));
            EditorGUILayout.PropertyField(ftraceLightCutoff, new GUIContent("Cutoff", "Lighting distance limit. For maximum physical corectness set to a very high value. Using smaller values is useful for faster render times and to match real-time lights. Bakery uses Skyforge falloff to maintain balance between correct inverse-squared attenuation and practical limits (https://habr.com/company/mailru/blog/248873/)"));

            if (ftraceLightSelfShadow.boolValue)
            {
                if (ftraceLightSamples2_previous.intValue != ftraceLightSamples2.intValue)
                {
                    ftraceLightSamples2.intValue = ftraceLightSamples2_previous.intValue;
                }
                EditorGUILayout.PropertyField(ftraceLightSamples2, new GUIContent("Samples Near", "The amount of rays traced hemispherically in the proximity of this mesh. Set to 0 to only trace with 'Samples Far'."));
                ftraceLightSamples2_previous.intValue = ftraceLightSamples2.intValue;
            }
            else
            {
                ftraceLightSamples2.intValue = 0;
            }
            EditorGUILayout.PropertyField(ftraceLightSamples, new GUIContent("Samples Far", "The amount of sample points generated on the surface of this mesh. Distant mesh lights are approximated as clouds of directed half-point lights."));

            //ftraceLightBitmask.intValue = EditorGUILayout.MaskField(new GUIContent("Bitmask", "Lights only affect renderers with overlapping bits"), ftraceLightBitmask.intValue, selStrings);
            int prevVal = ftraceLightBitmask.intValue;
            int newVal = EditorGUILayout.MaskField(new GUIContent("Bitmask", "Lights only affect renderers with overlapping bits"), ftraceLightBitmask.intValue, selStrings);
            if (prevVal != newVal) ftraceLightBitmask.intValue = newVal;

            EditorGUILayout.PropertyField(ftraceLightSelfShadow, new GUIContent("Self shadow", "Determines if light mesh itself casts shadows."));

            //EditorGUILayout.PropertyField(ftraceLightBakeToIndirect, new GUIContent("Bake to indirect", "Add direct contribution from this light to indirect-only lightmaps"));

            if (storage == null) storage = ftRenderLightmap.FindRenderSettingsStorage();
            var rmode = storage.renderSettingsUserRenderMode;
            if (rmode != (int)ftRenderLightmap.RenderMode.FullLighting)
            {
                ftDirectLightInspector.BakeWhat contrib;
                if (ftraceLightShadowmask.boolValue)
                {
                    if (ftraceLightBakeToIndirect.boolValue)
                    {
                        contrib = ftDirectLightInspector.BakeWhat.DirectIndirectShadowmask;
                    }
                    else
                    {
                        contrib = ftDirectLightInspector.BakeWhat.IndirectAndShadowmask;
                    }
                }
                else if (ftraceLightBakeToIndirect.boolValue)
                {
                    contrib = ftDirectLightInspector.BakeWhat.DirectAndIndirect;
                }
                else
                {
                    contrib = ftDirectLightInspector.BakeWhat.IndirectOnly;
                }
                var prevContrib = contrib;

                if (rmode == (int)ftRenderLightmap.RenderMode.Indirect)
                {
                    contrib = (ftDirectLightInspector.BakeWhat)EditorGUILayout.Popup("Baked contribution", (int)contrib, ftDirectLightInspector.directContributionIndirectOptions);
                }
                else if (rmode == (int)ftRenderLightmap.RenderMode.Shadowmask)
                {
                    contrib = (ftDirectLightInspector.BakeWhat)EditorGUILayout.Popup("Baked contribution", (int)contrib, ftDirectLightInspector.directContributionOptions);
                }

                if (prevContrib != contrib)
                {
                    if (contrib == ftDirectLightInspector.BakeWhat.IndirectOnly)
                    {
                        ftraceLightShadowmask.boolValue = false;
                        ftraceLightBakeToIndirect.boolValue = false;
                    }
                    else if (contrib == ftDirectLightInspector.BakeWhat.IndirectAndShadowmask)
                    {
                        ftraceLightShadowmask.boolValue = true;
                        ftraceLightBakeToIndirect.boolValue = false;
                    }
                    else if (contrib == ftDirectLightInspector.BakeWhat.DirectIndirectShadowmask)
                    {
                        ftraceLightShadowmask.boolValue = true;
                        ftraceLightBakeToIndirect.boolValue = true;
                    }
                    else
                    {
                        ftraceLightShadowmask.boolValue = false;
                        ftraceLightBakeToIndirect.boolValue = true;
                    }
                }
            }

            EditorGUILayout.PropertyField(ftraceLightIndirectIntensity, new GUIContent("Indirect intensity", "Non-physical GI multiplier for this light"));

            EditorGUILayout.PropertyField(ftraceLightShadowmaskFalloff, new GUIContent("Shadowmask with falloff", "Only useful for custom lighting. Bakes complete light attenuation into the shadowmask."));

            serializedObject.ApplyModifiedProperties();
        }

        bool showError = false;
        string showErrorText = "";
        bool isAreaLight = false;
        bool isMesh = false;

        var materialValid = new bool[targets.Length];
        int iterator = -1;
        int numMaterialValid = targets.Length;

        foreach(BakeryLightMesh selectedLight in targets)
        {
            iterator++;
            var so = new SerializedObject(selectedLight);
            InitSerializedProperties(so);

            var mr = selectedLight.GetComponent<MeshRenderer>();
            var mf = selectedLight.GetComponent<MeshFilter>();
            var areaLight = selectedLight.GetComponent<Light>();
            if (areaLight != null && !IsArea(areaLight)) areaLight = null;

            if (mr == null && areaLight == null)
            {
                showError = true;
                showErrorText = "Error: no mesh renderer";
                continue;
            }

            if (mf == null && areaLight == null)
            {
                showError = true;
                showErrorText = "Error: no mesh filter";
                continue;
            }

            float intensity = ftraceLightIntensity.floatValue;
            var clr = ftraceLightColor.colorValue;

            if (areaLight != null)
            {
                bool match = true;
                string why = "";
                isAreaLight = true;

                float eps = 1.0f / 255.0f;
                float lightR, lightG, lightB, lightInt;
                float fr, fg, fb;
                if (PlayerSettings.colorSpace == ColorSpace.Linear)
                {
                    fr = clr.r;// * fintensity;
                    fg = clr.g;// * fintensity;
                    fb = clr.b;// * fintensity;
                }
                else
                {
                    fr = clr.r;
                    fg = clr.g;
                    fb = clr.b;
                }
                GetLinearLightParameters(areaLight, out lightR, out lightG, out lightB, out lightInt);

                if (GraphicsSettings.lightsUseLinearIntensity || PlayerSettings.colorSpace != ColorSpace.Linear)
                {
                    if (Mathf.Abs(lightR - fr) > eps || Mathf.Abs(lightG - fg) > eps || Mathf.Abs(lightB - fb) > eps)
                    {
                        match = false;
                        why = "color doesn't match";
                    }
                    else if (Mathf.Abs(lightInt - intensity) > eps)
                    {
                        match = false;
                        why = "intensity doesn't match";
                    }
                }
                else
                {
                    eps *= Mathf.Max(lightInt, intensity);
                    if (Mathf.Abs(lightR*lightInt - fr*intensity) > eps ||
                        Mathf.Abs(lightG*lightInt - fg*intensity) > eps ||
                        Mathf.Abs(lightB*lightInt - fb*intensity) > eps)
                    {
                        match = false;
                        why = "intensity doesn't match";
                    }
                }

                if (Mathf.Abs(ftraceLightCutoff.floatValue - areaLight.range * 1.5f) > 0.01f)
                {
                    match = false;
                    why = "range doesn't match";
                }

                if (ftraceLightSelfShadow.boolValue)
                {
                    match = false;
                    why = "area light is not self-shadowed.";
                }

                if (areaLight.bounceIntensity != ftraceLightIndirectIntensity.floatValue)
                {
                    match = false;
                    why = "indirect intensity doesn't match";
                }

                if (!match)
                {
                    //EditorGUILayout.Space();
                    //EditorGUILayout.LabelField("Real-time light doesn't match lightmap: " + why);
                    showError = true;
                    showErrorText = "Area light doesn't match lightmap: " + why;
                }

                continue;
            }

            materialValid[iterator] = true;
            Material singleMat = null;
            var mats = mr.sharedMaterials;

            if (mats.Length == 0 || mats[0] == null)
            {
                showError = true;
                showErrorText = "Error: no materials set";
                continue;
            }

            isMesh = true;

            for(int i=0; i<mats.Length; i++)
            {
                var mat = mats[i];
                if (singleMat == null) singleMat = mat;
                if (mat != null && mat != singleMat)
                {
                    showError = true;
                    showErrorText = "Error: different materials in mesh";
                    //match = false;
                    materialValid[iterator] = false;
                    numMaterialValid--;
                    break;
                }
                if (mat == null)
                {
                    showError = true;
                    showErrorText = "Error: mesh doesn't have all materials set";
                    //match = false;
                    materialValid[iterator] = false;
                    numMaterialValid--;
                    break;
                }
                bool usesftlight = mat.shader.name == ftLightShaderName;
                bool usesUnlitColor = mat.shader.name == "Unlit/Color";
                bool usesUnlitTexture = mat.shader.name == "Unlit/Texture";
                if (!usesftlight && !usesUnlitColor && !usesUnlitTexture)
                {
                    showError = true;
                    showErrorText = "Warning: material should output unlit color";
                    //match = false;
                    materialValid[iterator] = false;
                    numMaterialValid--;
                    break;
                }
                if (intensity > 1 && !usesftlight)
                {
                    showError = true;
                    showErrorText = "Warning: intensity > 1, but not using Bakery Light shader";
                    //match = false;
                    break;
                }
                var mclr = mat.HasProperty("_Color") ? mat.color : Color.white;
                float eps = 0.5f/255.0f;
                if (Mathf.Abs(mclr.r - clr.r) > eps || Mathf.Abs(mclr.g - clr.g) > eps || Mathf.Abs(mclr.b - clr.b) > eps)
                {
                    showError = true;
                    showErrorText = "Error: light color doesn't match material color";
                    //match = false;
                    break;
                }
                if (usesftlight && Mathf.Abs(mat.GetFloat("intensity") - intensity) > 0.001f)
                {
                    showError = true;
                    showErrorText = "Error: light intensity doesn't match material intensity";
                    //match = false;
                    break;
                }
                if (ftraceLightTexture.objectReferenceValue == null && mat.HasProperty("_MainTex") && mat.GetTexture("_MainTex")!=null)
                {
                    showError = true;
                    showErrorText = "Error: textures don't match";
                    //match = false;
                    break;
                }
                if (ftraceLightTexture.objectReferenceValue != null && (!mat.HasProperty("_MainTex") || mat.GetTexture("_MainTex") != ftraceLightTexture.objectReferenceValue))
                {
                    showError = true;
                    showErrorText = "Error: textures don't match";
                    //match = false;
                    break;
                }
            }

            //if (match) return;
        }


        if (showError)
        {
            EditorGUILayout.Space();
            EditorGUILayout.LabelField(showErrorText);
            EditorGUILayout.Space();

            string txt;
            if (numMaterialValid > 0)
            {
                if (isMesh && !isAreaLight)
                {
                    txt = "Match light to material";
                }
                else if (!isMesh && isAreaLight)
                {
                    txt = "Match lightmapped to area light";
                }
                else
                {
                    txt = "Match lights to meshes/area lights";
                }
                if (GUILayout.Button(txt))
                {
                    //iterator = 0;
                    foreach(BakeryLightMesh selectedLight in targets)
                    {
                        //iterator++;
                        var so = new SerializedObject(selectedLight);
                        InitSerializedProperties(so);

                        var mr = selectedLight.GetComponent<MeshRenderer>();
                        var areaLight = selectedLight.GetComponent<Light>();
                        if (mr == null && areaLight == null) continue;

                        if (areaLight != null)
                        {
                            float lightR, lightG, lightB, lightInt;
                            GetLinearLightParameters(areaLight, out lightR, out lightG, out lightB, out lightInt);
                            ftraceLightColor.colorValue = new Color(lightR, lightG, lightB);
                            ftraceLightIntensity.floatValue = lightInt;

                            ftraceLightCutoff.floatValue = areaLight.range * 1.5f;
                            ftraceLightSelfShadow.boolValue = false;
                            ftraceLightIndirectIntensity.floatValue = areaLight.bounceIntensity;
                            so.ApplyModifiedProperties();
                            continue;
                        }

                        var mats = mr.sharedMaterials;
                        if (mats.Length == 0 || mats[0] == null) continue;

                        var mat = mats[0];
                        if (mat.shader.name == ftLightShaderName)
                        {
                            ftraceLightTexture.objectReferenceValue = mat.mainTexture;
                            ftraceLightColor.colorValue = mat.color;
                            ftraceLightIntensity.floatValue = mat.GetFloat("intensity");
                        }
                        else if (mat.shader.name == "Unlit/Color")
                        {
                            ftraceLightTexture.objectReferenceValue = null;
                            ftraceLightColor.colorValue = mat.color;
                            ftraceLightIntensity.floatValue = 1;
                        }
                        else if (mat.shader.name == "Unlit/Texture")
                        {
                            ftraceLightTexture.objectReferenceValue = mat.mainTexture;
                            ftraceLightColor.colorValue = Color.white;//mat.color;
                            ftraceLightIntensity.floatValue = 1;
                        }
                        so.ApplyModifiedProperties();
                    }
                }
            }

            //if (mats.Length == 0) return;
            //if (mats[0] == null) return;

            if (isMesh && !isAreaLight)
            {
                txt = "Match material to light";
            }
            else if (!isMesh && isAreaLight)
            {
                txt = "Match area light to lightmapped";
            }
            else
            {
                txt = "Match meshes/area lights to lightmapped";
            }
            if (GUILayout.Button(txt))
            {
                foreach(BakeryLightMesh selectedLight in targets)
                {
                    //iterator++;
                    var so = new SerializedObject(selectedLight);
                    InitSerializedProperties(so);

                    var mr = selectedLight.GetComponent<MeshRenderer>();
                    var areaLight = selectedLight.GetComponent<Light>();
                    if (mr == null && areaLight == null) continue;

                    if (areaLight != null)
                    {
                        Undo.RecordObject(areaLight, "Change light");
                        if (PlayerSettings.colorSpace != ColorSpace.Linear)
                        {
                            areaLight.color = ftraceLightColor.colorValue;
                            areaLight.intensity = ftraceLightIntensity.floatValue;
                        }
                        else if (!GraphicsSettings.lightsUseLinearIntensity)
                        {
                            var clr = ftraceLightColor.colorValue;
                            float fintensity = ftraceLightIntensity.floatValue;
                            float fr = clr.linear.r;// * fintensity;
                            float fg = clr.linear.g;// * fintensity;
                            float fb = clr.linear.b;// * fintensity;

                            fr = Mathf.Pow(fr * fintensity, 1.0f / 2.2f);
                            fg = Mathf.Pow(fg * fintensity, 1.0f / 2.2f);
                            fb = Mathf.Pow(fb * fintensity, 1.0f / 2.2f);
                            float fint = Mathf.Max(Mathf.Max(fr, fg), fb);
                            fr /= fint;
                            fg /= fint;
                            fb /= fint;
                            areaLight.color = new Color(fr, fg, fb);
                            areaLight.intensity = fint;
                        }
                        else
                        {
                            areaLight.color = ftraceLightColor.colorValue;
                            areaLight.intensity = ftraceLightIntensity.floatValue;
                        }
                        areaLight.bounceIntensity = ftraceLightIndirectIntensity.floatValue;
                        continue;
                    }

                    var mats = mr.sharedMaterials;
                    if (mats.Length == 0 || mats[0] == null) continue;

                    float intensity = ftraceLightIntensity.floatValue;

                    var mat = mats[0];
                    Undo.RecordObject(mat, "Change material");
                    if (intensity > 1)
                    {
                        if (mat.shader.name != ftLightShaderName) mat.shader = Shader.Find(ftLightShaderName);
                        mat.color = ftraceLightColor.colorValue;
                        mat.mainTexture = ftraceLightTexture.objectReferenceValue as Texture2D;
                        mat.SetFloat("intensity", intensity);
                    }
                    else
                    {
                        if (ftraceLightTexture.objectReferenceValue == null)
                        {
                            if (mat.shader.name != ftLightShaderName && mat.shader.name != "Unlit/Color") mat.shader = Shader.Find(ftLightShaderName);
                        }
                        else
                        {
                            if (mat.shader.name != ftLightShaderName && mat.shader.name != "Unlit/Texture") mat.shader = Shader.Find(ftLightShaderName);
                        }
                        mat.mainTexture = ftraceLightTexture.objectReferenceValue as Texture2D;
                        if (mat.shader.name == ftLightShaderName)
                        {
                            mat.color = ftraceLightColor.colorValue;
                            mat.SetFloat("intensity", intensity);
                        }
                        else
                        {
                            mat.color = ftraceLightColor.colorValue * intensity;
                        }
                    }
                }
            }
        }

        if (PlayerSettings.colorSpace == ColorSpace.Linear)
        {
            if (!GraphicsSettings.lightsUseLinearIntensity)
            {
                EditorGUILayout.Space();
                EditorGUILayout.LabelField("Warning: project is not set up to use linear light intensity.");
                EditorGUILayout.LabelField("GraphicsSettings.lightsUseLinearIntensity should be TRUE.");
                if (GUILayout.Button("Fix"))
                {
                    GraphicsSettings.lightsUseLinearIntensity = true;
                }
            }
            else
            {
                EditorGUILayout.Space();
                EditorGUILayout.LabelField("Project is using linear light intensity. This is nice.");
                if (GUILayout.Button("Change to non-linear"))
                {
                    GraphicsSettings.lightsUseLinearIntensity = false;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftLightMeshInspector.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftLMGroupInspector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c93be7cc95a299b4391dc97ea53e9348
# ASMDEF: BakeryEditorAssembly.dll
# ---

using UnityEditor;
using UnityEngine;
using System;
using System.IO;
using System.Collections.Generic;
using System.Runtime.InteropServices;

[CustomEditor(typeof(BakeryLightmapGroup))]
[CanEditMultipleObjects]
public class ftLMGroupInspector : UnityEditor.Editor
{
    SerializedProperty ftraceResolution;
    SerializedProperty ftraceMode;
    SerializedProperty ftraceRenderMode;
    SerializedProperty ftraceRenderDirMode;
    SerializedProperty ftraceAtlasPacker;
    SerializedProperty ftraceHoleFilling;
    SerializedProperty ftraceBitmask;
    SerializedProperty ftraceThickness;
    SerializedProperty ftraceSSS;
    SerializedProperty ftraceSSSSamples;
    SerializedProperty ftraceSSSDensity;
    SerializedProperty ftraceSSSColor;
    SerializedProperty ftraceFakeShadowBias;
    SerializedProperty ftraceTransparentSelfShadow;
    SerializedProperty ftraceFlipNormal;
    SerializedProperty ftraceSSSScale;
    SerializedProperty ftraceAutoResolution;

    static string[] selStrings = new string[] {"0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16",
                                                "17","18","19","20","21","22","23","24","25","26","27","28","29","30"};//,"31"};

    void OnEnable()
    {
        ftraceResolution = serializedObject.FindProperty("resolution");
        ftraceMode = serializedObject.FindProperty("mode");
        ftraceRenderMode = serializedObject.FindProperty("renderMode");
        ftraceRenderDirMode = serializedObject.FindProperty("renderDirMode");
        ftraceAtlasPacker = serializedObject.FindProperty("atlasPacker");
        ftraceHoleFilling = serializedObject.FindProperty("holeFilling");
        ftraceBitmask = serializedObject.FindProperty("bitmask");
        //ftraceThickness = serializedObject.FindProperty("aoIsThickness");
        ftraceSSS = serializedObject.FindProperty("computeSSS");
        ftraceSSSSamples = serializedObject.FindProperty("sssSamples");
        ftraceSSSDensity = serializedObject.FindProperty("sssDensity");
        ftraceSSSColor = serializedObject.FindProperty("sssColor");
        ftraceSSSScale = serializedObject.FindProperty("sssScale");
        ftraceFakeShadowBias = serializedObject.FindProperty("fakeShadowBias");
        ftraceTransparentSelfShadow = serializedObject.FindProperty("transparentSelfShadow");
        ftraceFlipNormal = serializedObject.FindProperty("flipNormal");
        ftraceAutoResolution = serializedObject.FindProperty("autoResolution");
    }

    public override void OnInspectorGUI() {
        serializedObject.Update();

        EditorGUILayout.LabelField("Bakery lightmap group parameters");
        EditorGUILayout.Space();

        if (ftraceMode.intValue != 2)
        {
            EditorGUILayout.PropertyField(ftraceAutoResolution, new GUIContent("Auto resolution", "Use Texels Per Unit to determine closest power-of-two resolution."));
            if (!ftraceAutoResolution.boolValue)
            {
                var prev = ftraceResolution.intValue;
                ftraceResolution.intValue = (int)Mathf.ClosestPowerOfTwo(EditorGUILayout.IntSlider("Resolution", ftraceResolution.intValue, 1, 8192));
                if (ftraceResolution.intValue != prev) EditorUtility.SetDirty(target);
            }
        }

        EditorGUILayout.PropertyField(ftraceMode, new GUIContent("Packing mode", "Determines how lightmaps are packed. In Simple mode they are not packed, and all objects sharing this group are drawn on top of each other. This is desired in case they were all unwrapped together and do not overlap. If UVs of different objects overlap, choose PackAtlas to arrange their lightmaps together into a single packed atlas."));

        EditorGUILayout.PropertyField(ftraceRenderMode, new GUIContent("Render Mode", ""));

        EditorGUILayout.PropertyField(ftraceRenderDirMode, new GUIContent("Directional mode", ""));

        EditorGUILayout.PropertyField(ftraceAtlasPacker, new GUIContent("Atlas packer", ""));

        if (ftraceAtlasPacker.intValue != (int)BakeryLightmapGroup.AtlasPacker.Default)
        {
            EditorGUILayout.PropertyField(ftraceHoleFilling, new GUIContent("Hole filling", ""));
        }

        ftraceBitmask.intValue = EditorGUILayout.MaskField(new GUIContent("Bitmask", "Lights only affect renderers with overlapping bits"), ftraceBitmask.intValue, selStrings);

        //EditorGUILayout.LabelField("");
        //EditorGUILayout.LabelField("Experimental");

        //EditorGUILayout.PropertyField(ftraceThickness, new GUIContent("Calculate AO as thickness", ""));
        EditorGUILayout.PropertyField(ftraceSSS, new GUIContent("Subsurface scattering", ""));
        if (ftraceSSS.boolValue)
        {
            EditorGUILayout.PropertyField(ftraceSSSSamples, new GUIContent("Samples", ""));
            EditorGUILayout.PropertyField(ftraceSSSDensity, new GUIContent("Density", ""));
            EditorGUILayout.PropertyField(ftraceSSSColor, new GUIContent("Color", ""));
            EditorGUILayout.PropertyField(ftraceSSSScale, new GUIContent("Scale", ""));
        }

        EditorGUILayout.PropertyField(ftraceFakeShadowBias, new GUIContent("Normal offset", "Fake normal offset for surface samples. Might be useful when applying very strong normal maps."));
        EditorGUILayout.PropertyField(ftraceTransparentSelfShadow, new GUIContent("Transparent selfshadow", "Start rays behind the surface so it doesn't cast shadows on self. Might be useful for translucent foliage."));
        EditorGUILayout.PropertyField(ftraceFlipNormal, new GUIContent("Flip normal", "Treat faces as flipped."));

        serializedObject.ApplyModifiedProperties();
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftLMGroupInspector.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftLMGroupSelectorInspector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 84f0a0db10ed05349987b7b2a49c345e
# ASMDEF: BakeryEditorAssembly.dll
# ---

using UnityEditor;
using UnityEngine;
using System;
using System.IO;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using UnityEngine.SceneManagement;
using UnityEditor.SceneManagement;

[CustomEditor(typeof(BakeryLightmapGroupSelector))]
[CanEditMultipleObjects]
public class ftLMGroupSelectorInspector : UnityEditor.Editor
{
    SerializedProperty ftraceActive;
    SerializedProperty ftraceAsset;
    SerializedProperty ftraceOverride;
    SerializedProperty ftraceResolution;

    string newName = null;
    int newRes = 512;
    int newMask = 1;
    bool newAutoRes = false;
    BakeryLightmapGroup.ftLMGroupMode newMode = BakeryLightmapGroup.ftLMGroupMode.PackAtlas;
    BakeryLightmapGroup.RenderDirMode newDirMode = BakeryLightmapGroup.RenderDirMode.Auto;

    public static string[] selStrings = new string[] {"0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16",
                                                "17","18","19","20","21","22","23","24","25","26","27","28","29","30"};//,"31"};

    void OnEnable()
    {
        ftraceActive = serializedObject.FindProperty("active");
        ftraceAsset = serializedObject.FindProperty("lmgroupAsset");
        ftraceOverride = serializedObject.FindProperty("instanceResolutionOverride");
        ftraceResolution = serializedObject.FindProperty("instanceResolution");
    }

    void ForceSavePrefabOverride(UnityEngine.Object[] targets)
    {
#if UNITY_2018_3_OR_NEWER
        foreach(BakeryLightmapGroupSelector obj in targets)
        {
            PrefabUtility.RecordPrefabInstancePropertyModifications(obj);
            EditorUtility.SetDirty(obj);
        }
#endif
    }

    public override void OnInspectorGUI() {
        serializedObject.Update();

        //if (!ftraceAsset.hasMultipleDifferentValues)
        {
            EditorGUILayout.LabelField("These lightmap parameters affect the object and its children");

            EditorGUILayout.PropertyField(ftraceActive, new GUIContent("Enabled", "Take this group into account when baking. Objects will be auto-atlased as usual, if this option is not set."));

            EditorGUI.BeginChangeCheck();

            var selectedLMGroup = EditorGUILayout.ObjectField(new GUIContent("Lightmap group", "Select ftrace lightmap group asset"),
                    ftraceAsset.objectReferenceValue, typeof(BakeryLightmapGroup), false);
            var changed = EditorGUI.EndChangeCheck();

            if (ftraceAsset.hasMultipleDifferentValues) EditorGUILayout.LabelField("(Different values in selection)");

            if (changed)
            {
                foreach(BakeryLightmapGroupSelector obj in targets)
                {
                    Undo.RecordObject(obj, "Change LMGroup");
                    obj.lmgroupAsset = selectedLMGroup;
                    ForceSavePrefabOverride(targets);
                }
            }

            if (ftraceAsset.objectReferenceValue != null)
            {
                var group = ftraceAsset.objectReferenceValue as BakeryLightmapGroup;

                if (group.mode != BakeryLightmapGroup.ftLMGroupMode.PackAtlas && ftraceOverride.boolValue)
                {
                    ftraceOverride.boolValue = false;
                    ForceSavePrefabOverride(targets);
                }

                //EditorGUILayout.LabelField("Packed atlas: " + (group.mode == BakeryLightmapGroup.ftLMGroupMode.PackAtlas ? "yes" : "no"));
                var modeString = "Packing: ";
                if (group.mode == BakeryLightmapGroup.ftLMGroupMode.OriginalUV) {
                    modeString += "original UV";
                } else if (group.mode == BakeryLightmapGroup.ftLMGroupMode.PackAtlas) {
                    modeString += "packed atlas";
                } else {
                    modeString += "vertex";
                }
                EditorGUILayout.LabelField(modeString);

                modeString = "Directional: ";
                if (group.renderDirMode == BakeryLightmapGroup.RenderDirMode.Auto) {
                    modeString += "auto";
                } else if (group.renderDirMode == BakeryLightmapGroup.RenderDirMode.None) {
                    modeString += "none";
                } else if (group.renderDirMode == BakeryLightmapGroup.RenderDirMode.BakedNormalMaps) {
                    modeString += "baked normal maps";
                } else if (group.renderDirMode == BakeryLightmapGroup.RenderDirMode.DominantDirection) {
                    modeString += "dominant direction";
                } else if (group.renderDirMode == BakeryLightmapGroup.RenderDirMode.RNM) {
                    modeString += "RNM";
                } else if (group.renderDirMode == BakeryLightmapGroup.RenderDirMode.SH) {
                    modeString += "SH";
                } else if (group.renderDirMode == BakeryLightmapGroup.RenderDirMode.MonoSH) {
                    modeString += "MonoSH";
                }
                EditorGUILayout.LabelField(modeString);

                if (group.mode != BakeryLightmapGroup.ftLMGroupMode.Vertex)
                {
                    if (group.autoResolution)
                    {
                        EditorGUILayout.LabelField("Resolution: " + (ftraceOverride.boolValue ? (ftraceResolution.intValue + " (atlas: auto)") : "auto"));
                    }
                    else
                    {
                        EditorGUILayout.LabelField("Resolution: " + (ftraceOverride.boolValue ? (ftraceResolution.intValue + " (atlas: " + group.resolution + ")") : (group.resolution)+""));
                    }
                }

                if (group.mode == BakeryLightmapGroup.ftLMGroupMode.PackAtlas)
                {
                    EditorGUILayout.PropertyField(ftraceOverride, new GUIContent("Override resolution", "Manually set the resolution of this object in the atlas"));
                    if (ftraceOverride.boolValue)
                    {
                        ftraceResolution.intValue = EditorGUILayout.IntSlider("Resolution", ftraceResolution.intValue, 1, 8192);
                        ForceSavePrefabOverride(targets);
                    }
                }
            }
            else
            {
                EditorGUILayout.Space();
                EditorGUILayout.LabelField("Create new lightmap group:");
                if (newName == null) newName = "LMGroup_" + target.name;
                newName = EditorGUILayout.TextField("Name", newName);
                EditorGUILayout.PrefixLabel("Packing mode");
                newMode = (BakeryLightmapGroup.ftLMGroupMode)EditorGUILayout.EnumPopup(newMode);
                if (newMode != BakeryLightmapGroup.ftLMGroupMode.Vertex)
                {
                    if (!newAutoRes)
                    {
                        newRes = (int)Mathf.ClosestPowerOfTwo(EditorGUILayout.IntSlider("Resolution", newRes, 1, 8192));
                    }
                    EditorGUILayout.BeginHorizontal();
                    EditorGUILayout.PrefixLabel(new GUIContent("Auto resolution", "Use Texels Per Unit to determine closest power-of-two resolution."));
                    GUILayout.FlexibleSpace();
                    newAutoRes = EditorGUILayout.Toggle("              ", newAutoRes);
                    EditorGUILayout.EndHorizontal();
                }
                EditorGUILayout.PrefixLabel("Directional mode");
                newDirMode = (BakeryLightmapGroup.RenderDirMode)EditorGUILayout.EnumPopup(newDirMode);
                newMask = EditorGUILayout.MaskField(new GUIContent("Bitmask", "Lights only affect renderers with overlapping bits"), newMask, selStrings);
                if (GUILayout.Button("Create new"))
                {
                    BakeryLightmapGroup newGroup = ScriptableObject.CreateInstance<BakeryLightmapGroup>();
                    newGroup.resolution = newRes;
                    newGroup.bitmask = newMask;
                    newGroup.mode = newMode;
                    newGroup.renderDirMode = newDirMode;
                    newGroup.autoResolution = newAutoRes;

                    string fname;
                    var activeScene = SceneManager.GetActiveScene();
                    if (activeScene.path.Length > 0)
                    {
                        fname = Path.GetDirectoryName(activeScene.path) + "/" + newName;
                    }
                    else
                    {
                        fname = "Assets/" + newName;
                    }

                    AssetDatabase.CreateAsset(newGroup, fname + ".asset");
                    AssetDatabase.SaveAssets();
                    ftraceAsset.objectReferenceValue = newGroup;
                }
            }
        }

        serializedObject.ApplyModifiedProperties();
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftLMGroupSelectorInspector.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftModelPostProcessor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 958d625f263bc9e468b7ea865c491cef
# ASMDEF: BakeryEditorAssembly.dll
# ---
using UnityEngine;
using UnityEditor;
using UnityEditor.SceneManagement;
using System.IO;
using System.Collections.Generic;

public class ftModelPostProcessorInternal : AssetPostprocessor
{
    public virtual void UnwrapXatlas(Mesh m, UnwrapParam param)
    {
    }
}

public partial class ftModelPostProcessor : ftModelPostProcessorInternal
{
    public static bool unwrapError = false;
    public static string lastUnwrapErrorAsset = "";

    // Deprecated but leave it for now just in case
    public class ftSavedPadding : ScriptableObject
    {
        [SerializeField]
        public ftGlobalStorage.AdjustedMesh data;
    }

    static ftGlobalStorage storage;
    UnwrapParam uparams;
    const int res = 1024;
    static Material mat;
    public static RenderTexture rt;
    public static Texture2D tex;

    static Dictionary<string, bool> assetHasPaddingAdjustment = new Dictionary<string, bool>();
    static Dictionary<string, ftSavedPadding2> assetSavedPaddingAdjustment = new Dictionary<string, ftSavedPadding2>();

#if UNITY_2017_1_OR_NEWER
    bool deserializedSuccess = false;
    ftGlobalStorage.AdjustedMesh deserialized;
#endif

    public static double GetTime()
    {
        return (System.DateTime.Now.Ticks / System.TimeSpan.TicksPerMillisecond) / 1000.0;
    }

    public static void Init()
    {
        storage = ftLightmaps.GetGlobalStorage();

        //ftLightmaps.AddTag("BakeryProcessed");
    }

    void OnPreprocessModel()
    {
        Init();

        assetHasPaddingAdjustment[assetPath] = false;
        assetSavedPaddingAdjustment[assetPath] = null;

        ModelImporter importer = (ModelImporter)assetImporter;

        //if (storage == null) return;
        bool hasGlobalPaddingAdjustment  = (storage != null && storage.modifiedAssetPathList.IndexOf(assetPath) >= 0);
        bool hasGlobalPaddingAdjustment2 = false;
#if UNITY_2017_1_OR_NEWER
        var props = importer.extraUserProperties;
        for(int p=0; p<props.Length; p++)
        {
            if (props[p].Substring(0,7) == "#BAKERY")
            {
                hasGlobalPaddingAdjustment2 = true;
                break;
            }
        }
#endif
        var savedAdjustment = AssetDatabase.LoadAssetAtPath(
            Path.GetDirectoryName(assetPath) + "/" + Path.GetFileNameWithoutExtension(assetPath) + "_padding.asset", typeof(ftSavedPadding2)) as ftSavedPadding2;

        if (!hasGlobalPaddingAdjustment && !hasGlobalPaddingAdjustment2 && savedAdjustment == null) return;

        assetHasPaddingAdjustment[assetPath] = importer.generateSecondaryUV;
        importer.generateSecondaryUV = false; // disable built-in unwrapping for models with padding adjustment
        assetSavedPaddingAdjustment[assetPath] = savedAdjustment;
    }

    void OnPostprocessModel(GameObject g)
    {
        ModelImporter importer = (ModelImporter)assetImporter;
        if (importer.generateSecondaryUV || assetHasPaddingAdjustment[assetPath])
        {
            if (!importer.generateSecondaryUV)
            {
                importer.generateSecondaryUV = true; // set "generate lightmap UVs" checkbox back
                EditorUtility.SetDirty(importer);
            }

            // Auto UVs: Adjust UV padding per mesh
            //if (!storage.modifiedAssetPathList.Contains(assetPath) && g.tag == "BakeryProcessed") return;
            //if (ftLightmaps.IsModelProcessed(assetPath)) return;

            //g.tag = "BakeryProcessed";
            var saved = assetSavedPaddingAdjustment[assetPath];
            if (saved != null)
            {
                Debug.Log("Bakery: processing auto-unwrapped asset (saved UV padding) " + assetPath);
            }
            else
            {
                Debug.Log("Bakery: processing auto-unwrapped asset " + assetPath);
            }
            if (storage != null) ftLightmaps.MarkModelProcessed(assetPath, true);

            uparams = new UnwrapParam();
            UnwrapParam.SetDefaults(out uparams);
            uparams.angleError = importer.secondaryUVAngleDistortion * 0.01f;
            uparams.areaError = importer.secondaryUVAreaDistortion * 0.01f;
            uparams.hardAngle = importer.secondaryUVHardAngle;

#if UNITY_2017_1_OR_NEWER
            deserializedSuccess = false;
            var props = importer.extraUserProperties;
            for(int p=0; p<props.Length; p++)
            {
                if (props[p].Substring(0,7) == "#BAKERY")
                {
                    var json = props[p].Substring(7);
                    deserialized = JsonUtility.FromJson<ftGlobalStorage.AdjustedMesh>(json);
                    deserializedSuccess = true;
                    break;
                }
            }
#endif
            if (storage != null) storage.InitModifiedMeshMap(assetPath);

            var tt = GetTime();
            AdjustUV(g.transform, saved);
            Debug.Log("UV adjustment time: " + (GetTime() - tt));
        }
        else
        {
            if (storage == null) return;

            Debug.Log("Bakery: checking for UV overlaps in " + assetPath);

            //if (g.tag == "BakeryProcessed") g.tag = "";
            ftLightmaps.MarkModelProcessed(assetPath, true);//false);

            // Manual UVs: check if overlapping
            CheckUVOverlap(g, assetPath);
        }

        if (g.tag == "BakeryProcessed") g.tag = ""; // remove legacy mark
    }

    public static bool InitOverlapCheck()
    {
        rt = new RenderTexture(res, res, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
        tex = new Texture2D(res, res, TextureFormat.ARGB32, false, true);
        var shdr = Shader.Find("Hidden/ftOverlapTest");
        if (shdr == null)
        {
            var bakeryRuntimePath = ftLightmaps.GetRuntimePath();
            shdr = AssetDatabase.LoadAssetAtPath(bakeryRuntimePath + "ftOverlapTest.shader", typeof(Shader)) as Shader;
            if (shdr == null)
            {
                Debug.Log("No overlap testing shader present");
                return false;
            }
        }
        mat = new Material(shdr);
        return true;
    }

    // -1 = No UVs
    // 0 = no overlaps
    // > 0 = overlapping pixels count
    public static int DoOverlapCheck(GameObject g, bool deep)
    {
        int overlap = -1;
        int overlapCounter = 0;

        Graphics.SetRenderTarget(rt);
        GL.Clear(false, true, new Color(0,0,0,0));
        mat.SetPass(0);

        bool hasUV1 = RenderMeshes(g.transform, deep);
        if (hasUV1)
        {
            tex.ReadPixels(new Rect(0,0,res,res), 0, 0, false);
            tex.Apply();

            var bytes = tex.GetRawTextureData();
            overlap = 0;
            for(int i=0; i<bytes.Length; i++)
            {
                if (bytes[i] > 1)
                {
                    overlapCounter++;
                    if (overlapCounter > 256) // TODO: better check
                    {
                        overlap = 1;
                        break;
                    }
                }
            }
        }

        Graphics.SetRenderTarget(null);

        return overlap == 1 ? overlapCounter : overlap;
    }

    public static void EndOverlapCheck()
    {
        if (rt != null) rt.Release();
        if (tex != null) Object.DestroyImmediate(tex);
    }

    public static void CheckUVOverlap(GameObject g, string assetPath)
    {
        bool canCheck = InitOverlapCheck();
        if (!canCheck) return;

        int overlap = DoOverlapCheck(g, true);
        EndOverlapCheck();

        if (overlap != 1 && overlap > 0)
        {
            Debug.LogWarning("[Bakery warning] " + overlap + " pixels overlap: " + assetPath);
        }

        //var index = storage.assetList.IndexOf(assetPath);
        var index = storage.assetList.IndexOf(assetPath);
        var prevOverlap = -100;
        if (index < 0)
        {
            //index = storage.assetList.Count;
            //storage.assetList.Add(assetPath);
            index = storage.assetList.Count;
            storage.assetList.Add(assetPath);
            storage.uvOverlapAssetList.Add(overlap);
        }
        else
        {
            prevOverlap = storage.uvOverlapAssetList[index];
            storage.assetList[index] = assetPath;
            storage.uvOverlapAssetList[index] = overlap;
        }

        if (prevOverlap != overlap)
        {
            EditorUtility.SetDirty(storage);
            EditorSceneManager.MarkAllScenesDirty();
        }
    }

    bool ValidateMesh(Mesh m, ftGlobalStorage.Unwrapper unwrapper)
    {
#if UNITY_2017_3_OR_NEWER
    #if UNITY_2018_4_OR_NEWER
        // Bug was fixed in 2018.3.5, but the closest define is for 2018.4
    #else
        if (m.indexFormat == UnityEngine.Rendering.IndexFormat.UInt32 && unwrapper == ftGlobalStorage.Unwrapper.Default)
        {
            Debug.LogError("Can't adjust UV padding for " + m.name + " due to Unity bug. Please set Index Format to 16-bit on the asset or use xatlas.");
            return false;
        }
    #endif
#endif
        return true;
    }

    void AdjustUV(Transform t, ftSavedPadding2 saved = null)
    {
        var mf = t.GetComponent<MeshFilter>();
        if (mf != null && mf.sharedMesh != null)
        {
            var m = mf.sharedMesh;
            var nm = m.name;
            int modifiedMeshID;

            if (saved != null)
            {
                // Get padding from asset
                int mindex = saved.data.meshName.IndexOf(nm);
                if (mindex < 0)
                {
                    //Debug.LogError("Unable to find padding value for mesh " + nm);
                    // This is fine. Apparently caused by parts of models being lightmapped,
                    // while other parts are not baked, yet still a part of the model.
                }
                else
                {
                    var padding = saved.data.padding[mindex];

                    ftGlobalStorage.Unwrapper unwrapper = ftGlobalStorage.Unwrapper.Default;
                    if (saved.data.unwrapper != null && saved.data.unwrapper.Count > mindex)
                        unwrapper = (ftGlobalStorage.Unwrapper)saved.data.unwrapper[mindex];

                    if (!ValidateMesh(m, unwrapper)) return;

                    uparams.packMargin = padding/1024.0f;
                    Unwrap(m, uparams, unwrapper);
                }
            }
#if UNITY_2017_1_OR_NEWER
            else if (deserializedSuccess && deserialized.meshName != null && deserialized.padding != null)
            {
                // Get padding from extraUserProperties (new)
                int mindex = deserialized.meshName.IndexOf(nm);
                if (mindex < 0)
                {
                    //Debug.LogError("Unable to find padding value for mesh " + nm);
                    // This is fine. Apparently caused by parts of models being lightmapped,
                    // while other parts are not baked, yet still a part of the model.
                }
                else
                {
                    var padding = deserialized.padding[mindex];

                    ftGlobalStorage.Unwrapper unwrapper = ftGlobalStorage.Unwrapper.Default;
                    if (deserialized.unwrapper != null && deserialized.unwrapper.Count > mindex)
                        unwrapper = (ftGlobalStorage.Unwrapper)deserialized.unwrapper[mindex];

                    if (!ValidateMesh(m, unwrapper)) return;

                    uparams.packMargin = padding/1024.0f;
                    Unwrap(m, uparams, unwrapper);
                }
            }
            else
            {
                // Get padding from GlobalStorage (old)
                if (storage != null && storage.modifiedMeshMap.TryGetValue(nm, out modifiedMeshID))
                {
                    var padding = storage.modifiedMeshPaddingArray[modifiedMeshID];

                    ftGlobalStorage.Unwrapper unwrapper = ftGlobalStorage.Unwrapper.Default;
                    if (storage.modifiedMeshUnwrapperArray != null && storage.modifiedMeshUnwrapperArray.Count > modifiedMeshID)
                        unwrapper = (ftGlobalStorage.Unwrapper)storage.modifiedMeshUnwrapperArray[modifiedMeshID];

                    if (!ValidateMesh(m, unwrapper)) return;

                    uparams.packMargin = padding/1024.0f;
                    Unwrap(m, uparams, unwrapper);
                }
            }
#else
            else if (storage != null && storage.modifiedMeshMap.TryGetValue(nm, out modifiedMeshID))
            {
                var padding = storage.modifiedMeshPaddingArray[modifiedMeshID];

                ftGlobalStorage.Unwrapper unwrapper = ftGlobalStorage.Unwrapper.Default;
                if (storage.modifiedMeshUnwrapperArray != null && storage.modifiedMeshUnwrapperArray.Count > modifiedMeshID)
                    unwrapper = (ftGlobalStorage.Unwrapper)storage.modifiedMeshUnwrapperArray[modifiedMeshID];

                if (!ValidateMesh(m, unwrapper)) return;

                uparams.packMargin = padding/1024.0f;
                Unwrap(m, uparams, unwrapper);
            }
#endif
        }

        // Recurse
        foreach (Transform child in t)
            AdjustUV(child, saved);
    }

    static bool RenderMeshes(Transform t, bool deep)
    {
        var mf = t.GetComponent<MeshFilter>();
        if (mf != null && mf.sharedMesh != null)
        {
            var m = mf.sharedMesh;
            //var nm = m.name;

            bool noUV2 = (m.uv2 == null || (m.uv2.Length == 0 && m.vertexCount != 0));
            bool noUV1 = (m.uv == null || (m.uv.Length == 0 && m.vertexCount != 0));

            if (noUV1 && noUV2) return false;

            mat.SetFloat("uvSet", noUV2 ? 0.0f : 1.0f);
            mat.SetPass(0);

            Graphics.DrawMeshNow(m, Vector3.zero, Quaternion.identity);
        }

        if (!deep) return true;

        // Recurse
        foreach (Transform child in t)
            RenderMeshes(child, deep);

        return true;
    }

    void Unwrap(Mesh m, UnwrapParam uparams, ftGlobalStorage.Unwrapper unwrapper)
    {
        if (unwrapper == ftGlobalStorage.Unwrapper.xatlas)
        {
            UnwrapXatlas(m, uparams);
        }
        else
        {
            var tt = GetTime();
            Unwrapping.GenerateSecondaryUVSet(m, uparams);
            if (m.uv2 == null || m.uv2.Length == 0)
            {
                Debug.LogError("Unity failed to unwrap mesh. Options: a) Use 32-bit indices and Unity >= 2018.4. b) Split it into multiple chunks. c) Disable 'Adjust UV Padding'.");
                unwrapError = true;
                lastUnwrapErrorAsset = assetPath;
            }
            Debug.Log("Unity unwrap time: " + (GetTime() - tt));
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftModelPostProcessor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftPointLightInspector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d965ed7d9a9a406418fe8b269b3fef30
# ASMDEF: BakeryEditorAssembly.dll
# ---

using UnityEditor;
using UnityEngine;
using System;
using System.IO;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using UnityEngine.Rendering;

[CustomEditor(typeof(BakeryPointLight))]
[CanEditMultipleObjects]
public class ftPointLightInspector : UnityEditor.Editor
{
    SerializedProperty ftraceLightColor;
    SerializedProperty ftraceLightIntensity;
    SerializedProperty ftraceLightShadowSpread;
    SerializedProperty ftraceLightCutoff;
    SerializedProperty ftraceLightSamples;
    SerializedProperty ftraceLightProj;
    SerializedProperty ftraceLightTexture;
    SerializedProperty ftraceLightTexture2D;
    SerializedProperty ftraceLightAngle;
    SerializedProperty ftraceLightIES;
    SerializedProperty ftraceLightBitmask;
    SerializedProperty ftraceLightBakeToIndirect;
    SerializedProperty ftraceLightRealisticFalloff;
    SerializedProperty ftraceLightLegacySampling;
    SerializedProperty ftraceLightShadowmask;
    SerializedProperty ftraceLightShadowmaskFalloff;
    SerializedProperty ftraceLightIndirectIntensity;
    SerializedProperty ftraceLightFalloffMinRadius;
    SerializedProperty ftraceLightInnerAngle;
    SerializedProperty ftraceShadowmaskGroupID;
    SerializedProperty ftraceDirectionMode;

    UnityEngine.Object spotCookieTexture;

    ftLightmapsStorage storage;

    bool isHDRP = false;
    bool isLWRP = false;

    int projModeCached = -1;
    int texCached = -1;
    int tex2DCached = -1;
    int iesCached = -1;

    static string[] selStrings = new string[] {"0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16",
                                                "17","18","19","20","21","22","23","24","25","26","27","28","29","30"};//,"31"};

    void InitSerializedProperties(SerializedObject obj)
    {
        ftraceLightColor = obj.FindProperty("color");
        ftraceLightIntensity = obj.FindProperty("intensity");
        ftraceLightIndirectIntensity = obj.FindProperty("indirectIntensity");
        ftraceLightShadowSpread = obj.FindProperty("shadowSpread");
        ftraceLightCutoff = obj.FindProperty("cutoff");
        ftraceLightAngle = obj.FindProperty("angle");
        ftraceLightInnerAngle = obj.FindProperty("innerAngle");
        ftraceLightSamples = obj.FindProperty("samples");
        ftraceLightProj = obj.FindProperty("projMode");
        ftraceLightTexture = obj.FindProperty("cubemap");
        ftraceLightTexture2D = obj.FindProperty("cookie");
        ftraceLightIES = obj.FindProperty("iesFile");
        ftraceLightBitmask = obj.FindProperty("bitmask");
        ftraceLightBakeToIndirect = obj.FindProperty("bakeToIndirect");
        ftraceLightRealisticFalloff = obj.FindProperty("realisticFalloff");
        ftraceLightLegacySampling = obj.FindProperty("legacySampling");
        ftraceLightShadowmask = obj.FindProperty("shadowmask");
        ftraceLightShadowmaskFalloff = obj.FindProperty("shadowmaskFalloff");
        ftraceLightFalloffMinRadius = obj.FindProperty("falloffMinRadius");
        ftraceShadowmaskGroupID = obj.FindProperty("shadowmaskGroupID");
        ftraceDirectionMode = obj.FindProperty("directionMode");

        var hdrpLight = (target as BakeryPointLight).GetComponent("HDAdditionalLightData");
        isHDRP = hdrpLight != null;

#if UNITY_2018_1_OR_NEWER

#if UNITY_2019_3_OR_NEWER
        var rpipe = GraphicsSettings.currentRenderPipeline;
#else
        var rpipe = GraphicsSettings.renderPipelineAsset;
#endif

        if (rpipe != null && (rpipe.GetType().Name.StartsWith("Lightweight") || rpipe.GetType().Name.StartsWith("Universal")))
        {
            isLWRP = true;
        }
#endif
    }

    void OnEnable()
    {
        InitSerializedProperties(serializedObject);

        if (spotCookieTexture == null)
        {
            var bakeryRuntimePath = ftLightmaps.GetRuntimePath();
            spotCookieTexture = AssetDatabase.LoadAssetAtPath(bakeryRuntimePath + "ftUnitySpotTexture.bmp", typeof(Texture2D));
        }
    }

    void GetLinearLightParameters(Light light, out float lightR, out float lightG, out float lightB, out float lightInt)
    {
        if (PlayerSettings.colorSpace != ColorSpace.Linear)
        {
            lightInt = light.intensity;
            lightR = light.color.r;
            lightG = light.color.g;
            lightB = light.color.b;
            return;
        }

        if (!GraphicsSettings.lightsUseLinearIntensity)
        {
            lightR = Mathf.Pow(light.color.r * light.intensity, 2.2f);
            lightG = Mathf.Pow(light.color.g * light.intensity, 2.2f);
            lightB = Mathf.Pow(light.color.b * light.intensity, 2.2f);
            lightInt = Mathf.Max(Mathf.Max(lightR, lightG), lightB);
            lightR /= lightInt;
            lightG /= lightInt;
            lightB /= lightInt;
        }
        else
        {
            lightInt = light.intensity;
            lightR = light.color.r;
            lightG = light.color.g;
            lightB = light.color.b;

            if (GraphicsSettings.lightsUseColorTemperature)
            {
#if UNITY_2019_3_OR_NEWER
                if (light.useColorTemperature)
#endif
                {
                    var temp = Mathf.CorrelatedColorTemperatureToRGB(light.colorTemperature).gamma;
                    lightR *= temp.r;
                    lightG *= temp.g;
                    lightB *= temp.b;
                }
            }
        }
    }

    bool CompareWithLWRP(Light l, ref string why)
    {
        if (l.type == LightType.Spot)
        {
            var so = new SerializedObject(l);
            if (so == null)
            {
                why = "no SerializedObject";
                return false;
            }
            if (ftraceLightProj.intValue != (int)BakeryPointLight.ftLightProjectionMode.Cone)
            {
                why = "spot shape doesn't match.";
                return false;
            }
            SerializedProperty innerAngle = so.FindProperty("m_InnerSpotAngle");
            if (innerAngle == null)
            {
                why = "no m_InnerSpotAngle";
                return false;
            }
            if (Mathf.Abs(((ftraceLightInnerAngle.floatValue * 0.01f) * ftraceLightAngle.floatValue) - innerAngle.floatValue) > 0.001f)
            {
                why = "inner angle doesn't match.";
                return false;
            }
        }
        return true;
    }

    bool CompareWithHDRP(Light l, ref string why)
    {
        var hdrpLight = l.GetComponent("HDAdditionalLightData");
        if (hdrpLight == null)
        {
            why = "no HDAdditionalLightData";
            return false;
        }
        var so = new SerializedObject(hdrpLight);
        if (so == null)
        {
            why = "no SerializedObject";
            return false;
        }
        SerializedProperty hdrpLightTypeExtent = so.FindProperty("m_PointlightHDType");
        if (hdrpLightTypeExtent == null)
        {
            why = "no m_PointlightHDType";
            return false;
        }

        int extendedLightType = hdrpLightTypeExtent.intValue;
        if (extendedLightType != 0)
        {
            why = "Only punctual sounrces are supported.\nUse rectangle/tube geometry with Light Mesh instead.";
            return false;
        }

        if (l.type == LightType.Spot)
        {
            SerializedProperty hdrpLightSpotShape = so.FindProperty("m_SpotLightShape");
            if (hdrpLightSpotShape == null)
            {
                why = "no m_SpotLightShape";
                return false;
            }
            SerializedProperty hdrpLightInnerAngle = so.FindProperty("m_InnerSpotPercent");
            if (hdrpLightInnerAngle == null)
            {
                why = "no m_InnerSpotPercent";
                return false;
            }

            int spotShape = hdrpLightSpotShape.intValue;
            if (spotShape != 0)
            {
                why = "Only cone spotlights are supported.";
                return false;
            }
            if (ftraceLightProj.intValue != (int)BakeryPointLight.ftLightProjectionMode.Cone)
            {
                why = "spot shape doesn't match.";
                return false;
            }
            if (Mathf.Abs(ftraceLightInnerAngle.floatValue - hdrpLightInnerAngle.floatValue) > 0.001f)
            {
                why = "inner angle doesn't match.";
                return false;
            }
        }

        SerializedProperty hdrpLightRadius = so.FindProperty("m_ShapeRadius");
        if (hdrpLightRadius != null)
        {
            if (hdrpLightRadius.floatValue != 0)
            {
                why = "light radius is not 0.";
                return false;
            }
        }


        return true;
    }

    void MatchToLWRPLight(Light l)
    {
        ftraceLightRealisticFalloff.boolValue = true;
        ftraceLightFalloffMinRadius.floatValue = 0.01f;
        if (l.type == LightType.Spot)
        {
            ftraceLightProj.intValue = (int)BakeryPointLight.ftLightProjectionMode.Cone;

            var so = new SerializedObject(l);
            if (so == null) return;

            SerializedProperty lightInnerAngle = so.FindProperty("m_InnerSpotAngle");
            if (lightInnerAngle == null) return;
            ftraceLightInnerAngle.floatValue = (lightInnerAngle.floatValue / ftraceLightAngle.floatValue) * 100;
        }
    }

    void MatchToHDRPLight(Light l)
    {
        ftraceLightRealisticFalloff.boolValue = true;
        ftraceLightFalloffMinRadius.floatValue = 0.01f;

        ftraceLightIntensity.floatValue /= Mathf.PI;

        var hdrpLight = l.GetComponent("HDAdditionalLightData");
        if (hdrpLight == null) return;

        var so = new SerializedObject(hdrpLight);
        if (so == null) return;

        SerializedProperty hdrpLightTypeExtent = so.FindProperty("m_PointlightHDType");
        if (hdrpLightTypeExtent == null) return;

        int extendedLightType = hdrpLightTypeExtent.intValue;
        if (extendedLightType != 0) return;

        if (l.type == LightType.Spot)
        {
            SerializedProperty hdrpLightSpotShape = so.FindProperty("m_SpotLightShape");
            if (hdrpLightSpotShape == null) return;

            int spotShape = hdrpLightSpotShape.intValue;
            if (spotShape != 0) return;

            ftraceLightProj.intValue = (int)BakeryPointLight.ftLightProjectionMode.Cone;
        }

        SerializedProperty hdrpLightInnerAngle = so.FindProperty("m_InnerSpotPercent");
        if (hdrpLightInnerAngle == null) return;
        ftraceLightInnerAngle.floatValue = hdrpLightInnerAngle.floatValue;
    }

    void SetLWRPLight(Light l)
    {
        if (ftraceLightProj.enumValueIndex == (int)BakeryPointLight.ftLightProjectionMode.Cone)
        {
            var so = new SerializedObject(l);
            if (so == null) return;

            SerializedProperty lightInnerAngle = so.FindProperty("m_InnerSpotAngle");
            if (lightInnerAngle == null) return;

            lightInnerAngle.floatValue = (ftraceLightInnerAngle.floatValue * 0.01f) * ftraceLightAngle.floatValue;

            so.ApplyModifiedProperties();
        }
    }

    void SetHDRPLight(Light l)
    {
#if UNITY_2019_1_OR_NEWER
        l.useBoundingSphereOverride = false;
        l.useShadowMatrixOverride = false;
#endif
        l.intensity *= Mathf.PI;

        var hdrpLight = l.GetComponent("HDAdditionalLightData");
        if (hdrpLight == null) return;

        var so = new SerializedObject(hdrpLight);
        if (so == null) return;

        SerializedProperty hdrpUnits = so.FindProperty("m_LightUnit");
        if (hdrpUnits != null) hdrpUnits.intValue = 1; // candela

        SerializedProperty hdrpInt2 = so.FindProperty("m_Intensity");
        if (hdrpInt2 != null) hdrpInt2.floatValue = l.intensity;

        SerializedProperty hdrpLightTypeExtent = so.FindProperty("m_PointlightHDType");
        if (hdrpLightTypeExtent == null) return;
        hdrpLightTypeExtent.intValue = 0; // punctual

        if (ftraceLightProj.enumValueIndex == (int)BakeryPointLight.ftLightProjectionMode.Cone)
        {
            SerializedProperty hdrpLightSpotShape = so.FindProperty("m_SpotLightShape");
            if (hdrpLightSpotShape == null) return;
            hdrpLightSpotShape.intValue = 0; // cone
        }

        SerializedProperty hdrpLightInnerAngle = so.FindProperty("m_InnerSpotPercent");
        if (hdrpLightInnerAngle == null) return;
        hdrpLightInnerAngle.floatValue = ftraceLightInnerAngle.floatValue;

        SerializedProperty hdrpLightRadius = so.FindProperty("m_ShapeRadius");
        if (hdrpLightRadius != null)
        {
            hdrpLightRadius.floatValue = 0;
        }

        so.ApplyModifiedProperties();
    }

    void TestPreviewRefreshProperty(ref int cached, int newVal)
    {
        if (cached >= 0)
        {
            if (cached != newVal)
            {
                BakeryPointLight.lightsChanged = 2;
            }
        }
        cached = newVal;
    }

    void TestPreviewRefreshProperty(ref int cached, UnityEngine.Object newVal)
    {
        if (newVal == null)
        {
            TestPreviewRefreshProperty(ref cached, 0);
            return;
        }
        TestPreviewRefreshProperty(ref cached, newVal.GetInstanceID());
    }

    public override void OnInspectorGUI() {
        //if (showFtrace)
        {
            OnEnable();

            serializedObject.Update();

            TestPreviewRefreshProperty(ref projModeCached, ftraceLightProj.intValue);
            TestPreviewRefreshProperty(ref texCached, ftraceLightTexture.objectReferenceValue);
            TestPreviewRefreshProperty(ref tex2DCached, ftraceLightTexture2D.objectReferenceValue);
            TestPreviewRefreshProperty(ref iesCached, ftraceLightIES.objectReferenceValue);

            EditorGUILayout.PropertyField(ftraceLightColor, new GUIContent("Color", "Color of the light"));
            EditorGUILayout.PropertyField(ftraceLightIntensity, new GUIContent("Intensity", "Color multiplier (Candela / PI)"));
            EditorGUILayout.PropertyField(ftraceLightShadowSpread, new GUIContent("Shadow spread", "Controls shadow blurriness from 0 to 1"));

            EditorGUILayout.PropertyField(ftraceLightRealisticFalloff, new GUIContent("Physical falloff", "Use inverse-squared falloff instead of Unity falloff"));
            if (ftraceLightRealisticFalloff.boolValue)
            {
                EditorGUILayout.PropertyField(ftraceLightFalloffMinRadius, new GUIContent("Falloff min size", "As point lights don't have area, at zero distance 1/(d*d) will become infinity. This value avoids this issue by assuming the light to have some minimum radius and changing the formula to 1/(d*d+R*R)."));
            }

            EditorGUILayout.PropertyField(ftraceLightCutoff, new GUIContent("Range", "Lighting distance limit. When 'Physical falloff' is on, for maximum corectness set to a very high value. Using smaller values is useful for faster render times and to match real-time lights. Bakery uses Skyforge falloff to maintain balance between correct inverse-squared attenuation and practical limits (https://habr.com/company/mailru/blog/248873/)"));
            EditorGUILayout.PropertyField(ftraceLightSamples, new GUIContent("Samples", "The amount of sample points generated on the surface of this light. Point light shadows are traced towards points on a sphere (with radius = shadowSpread) around the light. "));
            EditorGUILayout.PropertyField(ftraceLightLegacySampling, new GUIContent("Legacy sampling", "Use Bakery's original more biased shadow sampling strategy. Produces noise-free shadows, but wide penumbras can exhibit banding. If disabled, an unbiased, but noisier technique is used."));
            EditorGUILayout.PropertyField(ftraceLightProj, new GUIContent("Projection mask", "Determines additional light masking mode."));

            switch(ftraceLightProj.enumValueIndex)
            {
                case (int)BakeryPointLight.ftLightProjectionMode.Cookie:
                    EditorGUILayout.PropertyField(ftraceLightTexture2D, new GUIContent("Cookie texture", "Texture"));
                    EditorGUILayout.Slider(ftraceLightAngle, 1, 179, new GUIContent("Angle", "Angle of projection (like in spotlights)."));
                    break;
                case (int)BakeryPointLight.ftLightProjectionMode.Cone:
                    EditorGUILayout.Slider(ftraceLightAngle, 1, 180, new GUIContent("Outer angle"));
                    EditorGUILayout.Slider(ftraceLightInnerAngle, 0, 100, new GUIContent("Inner angle percent"));
                    break;
                case (int)BakeryPointLight.ftLightProjectionMode.Cubemap:
                    EditorGUILayout.PropertyField(ftraceLightTexture, new GUIContent("Projected cubemap", "Cubemap"));
                    break;
                case (int)BakeryPointLight.ftLightProjectionMode.IES:
                    ftraceLightIES.objectReferenceValue = EditorGUILayout.ObjectField("IES file", ftraceLightIES.objectReferenceValue, typeof(UnityEngine.Object), false);
                    if (ftraceLightIES.objectReferenceValue != null)
                    {
                        var path = AssetDatabase.GetAssetPath(ftraceLightIES.objectReferenceValue);
                        if (path.Length < 4 || path.Substring(path.Length - 4).ToLower() != ".ies")
                        {
                            EditorUtility.DisplayDialog("Bakery", "File must have IES extension.", "OK");
                            ftraceLightIES.objectReferenceValue = null;
                        }
                    }
                    EditorGUILayout.PropertyField(ftraceDirectionMode, new GUIContent("Orientation", "Defines forward axis for the IES light."));
                    break;
                default:
                    break;
            }

            int prevVal = ftraceLightBitmask.intValue;
            int newVal = EditorGUILayout.MaskField(new GUIContent("Bitmask", "Lights only affect renderers with overlapping bits"), ftraceLightBitmask.intValue, selStrings);
            if (prevVal != newVal) ftraceLightBitmask.intValue = newVal;

            /*
            EditorGUILayout.PropertyField(ftraceLightBakeToIndirect, new GUIContent("Bake to indirect", "Add direct contribution from this light to indirect-only lightmaps"));
            if (ftraceLightBakeToIndirect.boolValue && ftraceLightShadowmask.boolValue) ftraceLightShadowmask.boolValue = false;

            EditorGUILayout.PropertyField(ftraceLightShadowmask, new GUIContent("Shadowmask", "Enable mixed lighting. Static shadows from this light will be baked, and real-time light will cast shadows from dynamic objects."));
            if (ftraceLightBakeToIndirect.boolValue && ftraceLightShadowmask.boolValue) ftraceLightBakeToIndirect.boolValue = false;
            */

            if (storage == null) storage = ftRenderLightmap.FindRenderSettingsStorage();
            var rmode = storage.renderSettingsUserRenderMode;
            if (rmode != (int)ftRenderLightmap.RenderMode.FullLighting)
            {
                ftDirectLightInspector.BakeWhat contrib;
                if (ftraceLightShadowmask.boolValue)
                {
                    if (ftraceLightBakeToIndirect.boolValue)
                    {
                        contrib = ftDirectLightInspector.BakeWhat.DirectIndirectShadowmask;
                    }
                    else
                    {
                        contrib = ftDirectLightInspector.BakeWhat.IndirectAndShadowmask;
                    }
                }
                else if (ftraceLightBakeToIndirect.boolValue)
                {
                    contrib = ftDirectLightInspector.BakeWhat.DirectAndIndirect;
                }
                else
                {
                    contrib = ftDirectLightInspector.BakeWhat.IndirectOnly;
                }
                var prevContrib = contrib;

                if (rmode == (int)ftRenderLightmap.RenderMode.Indirect)
                {
                    contrib = (ftDirectLightInspector.BakeWhat)EditorGUILayout.Popup("Baked contribution", (int)contrib, ftDirectLightInspector.directContributionIndirectOptions);
                }
                else if (rmode == (int)ftRenderLightmap.RenderMode.Shadowmask)
                {
                    contrib = (ftDirectLightInspector.BakeWhat)EditorGUILayout.Popup("Baked contribution", (int)contrib, ftDirectLightInspector.directContributionOptions);
                }

                if (prevContrib != contrib)
                {
                    if (contrib == ftDirectLightInspector.BakeWhat.IndirectOnly)
                    {
                        ftraceLightShadowmask.boolValue = false;
                        ftraceLightBakeToIndirect.boolValue = false;
                    }
                    else if (contrib == ftDirectLightInspector.BakeWhat.IndirectAndShadowmask)
                    {
                        ftraceLightShadowmask.boolValue = true;
                        ftraceLightBakeToIndirect.boolValue = false;
                    }
                    else if (contrib == ftDirectLightInspector.BakeWhat.DirectIndirectShadowmask)
                    {
                        ftraceLightShadowmask.boolValue = true;
                        ftraceLightBakeToIndirect.boolValue = true;
                    }
                    else
                    {
                        ftraceLightShadowmask.boolValue = false;
                        ftraceLightBakeToIndirect.boolValue = true;
                    }
                }
            }

            EditorGUILayout.PropertyField(ftraceLightIndirectIntensity, new GUIContent("Indirect intensity", "Non-physical GI multiplier for this light"));

            if (ftraceLightShadowmask.boolValue)
            {
                EditorGUILayout.PropertyField(ftraceShadowmaskGroupID, new GUIContent("Shadowmask Group ID", "If set to 0, each shadowmasked light will have a separate mask. Lights sharing any other positive value will share the same mask. This is useful to avoid 4 channel limit in cases where light bounds overlap, but the overlapping part is occluded in both anyway."));
                EditorGUILayout.PropertyField(ftraceLightShadowmaskFalloff, new GUIContent("Shadowmask with falloff", "Only useful for custom lighting. Bakes complete light attenuation (except distance) into the shadowmask."));
            }

            serializedObject.ApplyModifiedProperties();
        }


        bool showWarningCant = false;
        bool showError = false;
        string why = "";

        bool shadowmaskNoDynamicLight = false;

        foreach(BakeryPointLight selectedLight in targets)
        {
            bool match = true;
            //string why = "";
            var light = selectedLight.GetComponent<Light>();
            if (light == null)
            {
                if (ftraceLightShadowmask.boolValue) shadowmaskNoDynamicLight = true;
                continue;
            }
            if (!light.enabled)
            {
                if (ftraceLightShadowmask.boolValue) shadowmaskNoDynamicLight = true;
            }

            if (isHDRP)
            {
                if (!ftraceLightRealisticFalloff.boolValue || Mathf.Abs(ftraceLightFalloffMinRadius.floatValue - 0.01f) > 0.0001f)
                {
                    match = false;
                    why = "falloff doesn't match HDRP";
                }
                else
                {
                    match = CompareWithHDRP(light, ref why);
                }
            }

            if (isLWRP)
            {
                if (!ftraceLightRealisticFalloff.boolValue || Mathf.Abs(ftraceLightFalloffMinRadius.floatValue - 0.01f) > 0.0001f)
                {
                    match = false;
                    why = "falloff doesn't match URP";
                }
                else
                {
                    match = CompareWithLWRP(light, ref why);
                }
            }

            var so = new SerializedObject(selectedLight);
            InitSerializedProperties(so);

            if (ftraceLightIndirectIntensity.floatValue != light.bounceIntensity)
            {
                match = false;
                why = "indirect intensity doesn't match";
            }

            if (ftraceLightProj.enumValueIndex == (int)BakeryPointLight.ftLightProjectionMode.IES)
            {
                showWarningCant = true;
            }
            else if (ftraceLightProj.enumValueIndex == (int)BakeryPointLight.ftLightProjectionMode.Omni)
            {
                if (light.type != LightType.Point)
                {
                    match = false;
                    why = "real-time light is not point";
                }
                else if (light.cookie != null)
                {
                    match = false;
                    why = "real-time light has cookie";
                }
            }
            else if (ftraceLightProj.enumValueIndex == (int)BakeryPointLight.ftLightProjectionMode.Cubemap)
            {
                if (light.type != LightType.Point)
                {
                    match = false;
                    why = "real-time light is not point";
                }
                else if (light.cookie == null)
                {
                    match = false;
                    why = "real-time light has no cookie";
                }
            }
            else if (ftraceLightProj.enumValueIndex == (int)BakeryPointLight.ftLightProjectionMode.Cookie)
            {
                if (light.type != LightType.Spot)
                {
                    match = false;
                    why = "real-time light is not spot";
                }
                else if (light.cookie == null && ftraceLightTexture2D.objectReferenceValue != spotCookieTexture)
                {
                    match = false;
                    why = "wrong cookie texture";
                }
                else if (light.cookie != null && ftraceLightTexture2D.objectReferenceValue != light.cookie)
                {
                    match = false;
                    why = "wrong cookie texture";
                }
                else if (light.spotAngle != ftraceLightAngle.floatValue)
                {
                    match = false;
                    why = "spot angle doesn't match";
                }
            }
            else if (ftraceLightProj.enumValueIndex == (int)BakeryPointLight.ftLightProjectionMode.Cone)
            {
                if (light.type != LightType.Spot)
                {
                    match = false;
                    why = "real-time light is not spot";
                }
                else if (light.spotAngle != ftraceLightAngle.floatValue)
                {
                    match = false;
                    why = "outer angle doesn't match";
                }
            }

            var clr = ftraceLightColor.colorValue;
            float eps = 1.0f / 255.0f;
            float lightR, lightG, lightB, lightInt;
            float fr, fg, fb;
            float fintensity = ftraceLightIntensity.floatValue;
            if (isHDRP) fintensity *= Mathf.PI;
            if (PlayerSettings.colorSpace == ColorSpace.Linear)
            {
                fr = clr.r;// * fintensity;
                fg = clr.g;// * fintensity;
                fb = clr.b;// * fintensity;
            }
            else
            {
                fr = clr.r;
                fg = clr.g;
                fb = clr.b;
            }
            GetLinearLightParameters(light, out lightR, out lightG, out lightB, out lightInt);

            if (GraphicsSettings.lightsUseLinearIntensity || PlayerSettings.colorSpace != ColorSpace.Linear)
            {
                if (Mathf.Abs(lightR - fr) > eps || Mathf.Abs(lightG - fg) > eps || Mathf.Abs(lightB - fb) > eps)
                {
                    match = false;
                    why = "color doesn't match";
                }
                else if (Mathf.Abs(lightInt - fintensity) > eps)
                {
                    match = false;
                    why = "intensity doesn't match";
                }
            }
            else
            {
                eps *= Mathf.Max(lightInt, fintensity);
                if (Mathf.Abs(lightR*lightInt - fr*fintensity) > eps ||
                    Mathf.Abs(lightG*lightInt - fg*fintensity) > eps ||
                    Mathf.Abs(lightB*lightInt - fb*fintensity) > eps)
                {
                    match = false;
                    why = "intensity doesn't match";
                }
            }

            if (Mathf.Abs(light.range - ftraceLightCutoff.floatValue) > 0.001f)
            {
                match = false;
                why = "range doesn't match";
            }

            if (!match)
            {
                showError = true;
            }
        }

        if (shadowmaskNoDynamicLight)
        {
            if (!(ftraceLightShadowmask.boolValue && ftraceLightBakeToIndirect.boolValue)) // not applicable to direct/indirect/shadowmask mode
            {
                EditorGUILayout.Space();
                EditorGUILayout.LabelField("Warning: shadowmask needs enabled real-time light to work");
            }
        }

        if (showWarningCant)
        {
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Warning: real-time light can't match baked IES light");
            EditorGUILayout.Space();
        }

        if (showError)
        {
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Real-time light doesn't match lightmap: " + why);

            if (GUILayout.Button("Match lightmapped to real-time"))
            {
                foreach(BakeryPointLight selectedLight in targets)
                {
                    var light = selectedLight.GetComponent<Light>();
                    if (light == null) continue;
                    //if (!light.enabled) continue;
                    var so = new SerializedObject(selectedLight);
                    InitSerializedProperties(so);

                    float lightR, lightG, lightB, lightInt;
                    GetLinearLightParameters(light, out lightR, out lightG, out lightB, out lightInt);
                    ftraceLightColor.colorValue = new Color(lightR, lightG, lightB);
                    ftraceLightIntensity.floatValue = lightInt;

                    ftraceLightCutoff.floatValue = light.range;
                    ftraceLightAngle.floatValue = light.spotAngle;

                    if (light.type == LightType.Point)
                    {
                        if (light.cookie == null)
                        {
                            ftraceLightProj.enumValueIndex = (int)BakeryPointLight.ftLightProjectionMode.Omni;
                            ftraceLightTexture.objectReferenceValue = null;
                        }
                        else
                        {
                            ftraceLightProj.enumValueIndex = (int)BakeryPointLight.ftLightProjectionMode.Cubemap;
                            ftraceLightTexture.objectReferenceValue = light.cookie;
                        }
                    }
                    else if (light.type == LightType.Spot)
                    {
                        ftraceLightProj.enumValueIndex = (int)BakeryPointLight.ftLightProjectionMode.Cookie;
                        if (light.cookie == null)
                        {
                            ftraceLightTexture2D.objectReferenceValue = spotCookieTexture;
                        }
                        else
                        {
                            ftraceLightTexture2D.objectReferenceValue = light.cookie;
                        }
                    }
                    ftraceLightIndirectIntensity.floatValue = light.bounceIntensity;

                    if (isHDRP) MatchToHDRPLight(light);
                    if (isLWRP) MatchToLWRPLight(light);

                    so.ApplyModifiedProperties();
                }
            }
            if (GUILayout.Button("Match real-time to lightmapped"))
            {
                foreach(BakeryPointLight selectedLight in targets)
                {
                    var light = selectedLight.GetComponent<Light>();
                    if (light == null) continue;
                    //if (!light.enabled) continue;
                    var so = new SerializedObject(selectedLight);
                    InitSerializedProperties(so);

                    Undo.RecordObject(light, "Change light");
                    if (PlayerSettings.colorSpace != ColorSpace.Linear)
                    {
                        light.color = ftraceLightColor.colorValue;
                        light.intensity = ftraceLightIntensity.floatValue;
                    }
                    else if (!GraphicsSettings.lightsUseLinearIntensity)
                    {
                        var clr = ftraceLightColor.colorValue;
                        float fintensity = ftraceLightIntensity.floatValue;
                        float fr = clr.linear.r;// * fintensity;
                        float fg = clr.linear.g;// * fintensity;
                        float fb = clr.linear.b;// * fintensity;

                        fr = Mathf.Pow(fr * fintensity, 1.0f / 2.2f);
                        fg = Mathf.Pow(fg * fintensity, 1.0f / 2.2f);
                        fb = Mathf.Pow(fb * fintensity, 1.0f / 2.2f);
                        float fint = Mathf.Max(Mathf.Max(fr, fg), fb);
                        fr /= fint;
                        fg /= fint;
                        fb /= fint;
                        light.color = new Color(fr, fg, fb);
                        light.intensity = fint;
                    }
                    else
                    {
                        light.color = ftraceLightColor.colorValue;
                        light.intensity = ftraceLightIntensity.floatValue;
                    }
                    light.range = ftraceLightCutoff.floatValue;
                    light.spotAngle = ftraceLightAngle.floatValue;

                    if (ftraceLightProj.enumValueIndex == (int)BakeryPointLight.ftLightProjectionMode.Omni)
                    {
                        light.type = LightType.Point;
                        light.cookie = null;
                    }
                    else if (ftraceLightProj.enumValueIndex == (int)BakeryPointLight.ftLightProjectionMode.Cubemap)
                    {
                        light.type = LightType.Point;
                        light.cookie = ftraceLightTexture.objectReferenceValue as Cubemap;
                    }
                    else if (ftraceLightProj.enumValueIndex == (int)BakeryPointLight.ftLightProjectionMode.Cookie)
                    {
                        light.type = LightType.Spot;
                        light.cookie = ftraceLightTexture.objectReferenceValue == spotCookieTexture ? null : (ftraceLightTexture.objectReferenceValue as Texture2D);
                    }
                    else if (ftraceLightProj.enumValueIndex == (int)BakeryPointLight.ftLightProjectionMode.Cone)
                    {
                        light.type = LightType.Spot;
                    }
                    light.bounceIntensity = ftraceLightIndirectIntensity.floatValue;

                    if (isHDRP) SetHDRPLight(light);
                    if (isLWRP) SetLWRPLight(light);
                }
            }
        }

        if (PlayerSettings.colorSpace == ColorSpace.Linear)
        {
            if (!GraphicsSettings.lightsUseLinearIntensity)
            {
                EditorGUILayout.Space();
                EditorGUILayout.LabelField("Warning: project is not set up to use linear light intensity.");
                EditorGUILayout.LabelField("GraphicsSettings.lightsUseLinearIntensity should be TRUE.");
                if (GUILayout.Button("Fix"))
                {
                    GraphicsSettings.lightsUseLinearIntensity = true;
                }
            }
            else
            {
                EditorGUILayout.Space();
                EditorGUILayout.LabelField("Project is using linear light intensity. This is nice.");
                if (GUILayout.Button("Change to non-linear"))
                {
                    GraphicsSettings.lightsUseLinearIntensity = false;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftPointLightInspector.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftRenderLightmap.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: dc64e635488f60747bf5e9025c593285
# ASMDEF: BakeryEditorAssembly.dll
# ---
#if UNITY_EDITOR
#define USE_TERRAINS

// Disable 'obsolete' warnings
#pragma warning disable 0618

// Run Bakery exes via CreateProcess instead of mono. Mono seems to have problems with apostrophes in paths.
// Bonus point: working dir == DLL dir, so moving the folder works.
#define LAUNCH_VIA_DLL
//#define COMPRESS_VOLUME_RGBM

using UnityEngine;
using UnityEngine.Rendering;
using UnityEditor;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using UnityEditor.SceneManagement;
using UnityEngine.SceneManagement;
using System.Text.RegularExpressions;
using System.Reflection;
#if UNITY_2021_2_OR_NEWER
using System.IO.MemoryMappedFiles;
using System.Runtime.Serialization.Formatters.Binary;
#endif

public class ftRenderLightmap : EditorWindow//ScriptableWizard
{
    public static bool ftInitialized = false;
    public static bool ftSceneDirty = true;

    public static ftRenderLightmap instance;

    public enum RenderMode
    {
        FullLighting = 0,
        Indirect = 1,
        Shadowmask = 2,
        Subtractive = 3,
        AmbientOcclusionOnly = 4
    };

    public enum RenderDirMode
    {
        None = 0,
        BakedNormalMaps = 1,
        DominantDirection = 2,
        RNM = 3,
        SH = 4,
        MonoSH = 6
    };

    public enum SettingsMode
    {
        Simple = 0,
        Advanced = 1,
        Experimental = 2
    };

    public enum LightProbeMode
    {
        Legacy = 0,
        L1 = 1
    };

    public enum GILODMode
    {
        Auto = 0,
        ForceOn = 1,
        ForceOff = 2
    };

    class Convex
    {
        public Vector3[] vertices;
        public Plane[] planes;
    };

    class LightBounds
    {
        public float cutoff;
        public int bitmask;
        public int shadowmaskGroupID;
        public Vector3 center;
        public BakeryPointLight point;
        public BakeryLightMesh lightMesh;

        public LightBounds(BakeryPointLight p)
        {
            cutoff = p.cutoff;
            bitmask = p.bitmask;
            shadowmaskGroupID = p.shadowmaskGroupID;
            center = p.transform.position;
            point = p;
        }

        public LightBounds(BakeryLightMesh p)
        {
            cutoff = p.cutoff;
            bitmask = p.bitmask;
            shadowmaskGroupID = 0;
            center = p.transform.position;
            lightMesh = p;
        }
    };

    struct SavedLight
    {
        public Texture2D tex;
        public int bitmask;
        public Color color;
        public float intensity;
        public float cutoff;
        public float indirectIntensity;
        public int samples;
        public int samples2;
        public int accumSamples;
        public bool selfShadow;
        public bool bakeToIndirect;
        public bool shadowmask;
        public bool shadowmaskFalloff;
        public int lmid, lid;
        public string name;
    }

    static bool askedTangentSH = false;

    [DllImport ("simpleProgressBar", CallingConvention=CallingConvention.Cdecl)]
    public static extern int simpleProgressBarShow(string header, string msg, float percent, float step, bool onTop);

    [DllImport ("simpleProgressBar", CallingConvention=CallingConvention.Cdecl)]
    public static extern bool simpleProgressBarCancelled();

    [DllImport ("simpleProgressBar", CallingConvention=CallingConvention.Cdecl)]
    public static extern void simpleProgressBarEnd();

    [DllImport ("halffloat2vb", CallingConvention=CallingConvention.Cdecl)]
    public static extern int halffloat2vb([MarshalAs(UnmanagedType.LPWStr)]string inputFilename, System.IntPtr values, int dataType);

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern System.IntPtr RunLocalProcess([MarshalAs(UnmanagedType.LPWStr)]string commandline, bool setWorkDir);

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern System.IntPtr RunLocalProcessVisible([MarshalAs(UnmanagedType.LPWStr)]string commandline);

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern bool IsProcessFinished(System.IntPtr proc);

    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern int GetProcessReturnValueAndClose(System.IntPtr proc);

#if UNITY_2018_3_OR_NEWER
    [DllImport("user32.dll")]
    static extern System.IntPtr GetForegroundWindow();

    [DllImport("user32.dll")]
    static extern int SetForegroundWindow(System.IntPtr hwnd);

    [DllImport("user32.dll")]
    static extern System.IntPtr GetParent(System.IntPtr hwnd);

    [DllImport("user32.dll")]
    static extern int GetWindowText(System.IntPtr hwnd, StringBuilder text, int count);

#if UNITY_2023_1_OR_NEWER
    [DllImport("user32.dll")]
    static extern int GetClassName(System.IntPtr hwnd, StringBuilder text, int count);
#endif

    System.IntPtr unityEditorHWND;
#endif

#if UNITY_2017_3_OR_NEWER
    const LightmapEditorSettings.Lightmapper BUILTIN_RADIOSITY = LightmapEditorSettings.Lightmapper.ProgressiveCPU;
    const LightmapEditorSettings.Lightmapper BUILTIN_PT = LightmapEditorSettings.Lightmapper.ProgressiveCPU;
#else
    #if UNITY_2017_2_OR_NEWER
        const LightmapEditorSettings.Lightmapper BUILTIN_RADIOSITY = LightmapEditorSettings.Lightmapper.Radiosity;
        const LightmapEditorSettings.Lightmapper BUILTIN_PT = LightmapEditorSettings.Lightmapper.PathTracer;
    #endif
#endif

    public static int bounces = 5;
    public int giSamples = 16;
    static public float giBackFaceWeight = 0;
    public static int tileSize = 512;
    public float priority = 2;
    public float texelsPerUnit = 20;
    public static bool forceRefresh = true;
    bool forceRebuildGeometry = true;
    bool performRendering = true;
    public RenderMode userRenderMode = RenderMode.FullLighting;
    public static bool isDistanceShadowmask;
    public static RenderDirMode renderDirMode;
    public static LightProbeMode lightProbeMode = LightProbeMode.L1;
    public static ftGlobalStorage.Unwrapper unwrapper = ftGlobalStorage.Unwrapper.Default;
    public static ftGlobalStorage.DenoiserType denoiserType = ftGlobalStorage.DenoiserType.OpenImageDenoise;
    public SettingsMode settingsMode = SettingsMode.Simple;
    public static GILODMode giLodMode = GILODMode.ForceOff;
    public static bool giLodModeEnabled = false;
    static bool revertReflProbesValue = false;
    static bool reflProbesValue = true;
    public static bool restoreFromGlobalSector = false;
    public static float hackEmissiveBoost = 1;
    public static float hackIndirectBoost = 1;
    public static float hackAOIntensity = 0;
    public static int hackAOSamples = 16;
    public static float hackAORadius = 1;
    public static bool showAOSettings = false;
    public static bool showTasks = false;
    public static bool showTasks2 = false;
    public static bool showPaths = false;
    public static bool showNet = false;
    public static bool showPerf = true;
    //public static bool showCompression = false;
    //public static bool useUnityForLightProbes = false;
    public static bool useUnityForOcclsusionProbes = false;
    public static bool showDirWarning = true;
    public static bool showCheckerSettings = false;
    public static bool showChecker = false;
    static bool usesRealtimeGI = false;
    static int lastBakeTime;
    public static bool beepOnFinish;
    public static bool useScenePath = true;
    public static bool removeDuplicateLightmaps = false;
    public static bool clientMode = false;
    public static int sampleDivisor = 1;

    public bool exeMode = true;//false;
    public bool deferredMode = true; // defer calls to ftrace and denoiser to unload unity scenes
    public bool unloadScenesInDeferredMode = false;
    public static bool adjustSamples = true;
    public static bool checkOverlaps = false;
    public static bool samplesWarning = true;
    public static bool prefabWarning = true;
    public static bool suppressPopups = false;
    public static bool compressedGBuffer = true;
    public static bool compressedOutput = true;
    static List<System.Diagnostics.ProcessStartInfo> deferredCommands;
    static Dictionary<int, List<string>> deferredCommandsFallback;
    static Dictionary<int, BakeryLightmapGroupPlain> deferredCommandsRebake;
    static Dictionary<int, int> deferredCommandsLODGen;
    static Dictionary<int, Vector3> deferredCommandsGIGen;
    static Dictionary<int, BakeryLightmapGroupPlain> deferredCommandsHalf2VB;
    static Dictionary<int, bool> deferredCommandsUVGB;
    static List<string> deferredFileSrc;
    static List<string> deferredFileDest;
    static List<string> deferredCommandDesc;

    public const string ftraceExe6 = "ftraceRTX.exe";
    public const string ftraceExe1 = "ftrace.exe";
    static string ftraceExe = ftraceExe1;
    static bool rtxMode = false;

    public static BakerySector curSector;
    static string curSectorName;

    public static HashSet<Vector3> sectorProbePosHash = null;

    public static int passedFilterFlag = 0;

    public static bool unityInBatchMode = false;

    public static int batchAreaLightSampleLimit = 4096;

    enum AdjustUVMode
    {
        DontChange,
        Adjust,
        ForceDisableAdjust
    }

    static string[] adjustUVOptions = new string[] {"Don't change", "Adjust UV padding", "Remove UV adjustments"};

    public static event System.EventHandler OnPreFullRender;
    public static event System.EventHandler OnPreReflectionProbeRender;       // AMW
    public static event System.EventHandler<ProbeEventArgs> OnPreRenderProbe;
    public static event System.EventHandler OnFinishedProbes;
    public static event System.EventHandler OnFinishedFullRender;
    public static event System.EventHandler OnFinishedReflectionProbes;
    public static event System.EventHandler<VolumeEventArgs> OnPreVolumesCompress;

    public class ProbeEventArgs : System.EventArgs
    {
        public Vector3 pos { get; set; }
    }

    public class VolumeEventArgs : System.EventArgs
    {
        public float[] L0 { get; set; }
        public float[] L1x { get; set; }
        public float[] L1y { get; set; }
        public float[] L1z { get; set; }
        public BakeryVolume[] volumes { get; set; }
    }

    public static LayerMask forceProbeVisibility;

    // Every LMID -> every channel -> every mask
    static List<List<List<string>>> lightmapMasks;
    static List<List<List<string>>> lightmapMaskLMNames;
    static List<List<List<Light>>> lightmapMaskLights;
    static List<List<List<bool>>> lightmapMaskDenoise;
#if UNITY_2017_3_OR_NEWER
#else
    static List<Light> maskedLights;
    PropertyInfo inspectorModeInfo;
#endif
    static List<bool> lightmapHasColor;
    static List<int> lightmapHasMask; // number of channels used
    static List<bool> lightmapHasDir;
    static List<bool> lightmapHasRNM;
    Scene sceneSavedTestScene;
    bool sceneWasSaved = false;

    public bool fixSeams = true;
    public bool denoise = true;
    public bool denoise2x = false;
    public bool encode = true;

    public int padding = 16;

    public int dilate = 16;

    //public bool bc6h = false;
    int encodeMode = 0;

    public bool selectedOnly = false;
    bool probesOnlyL1 = false;
    public static bool fullSectorRender = false;

    public static bool verbose = true;
    public static bool showProgressBar = true;

    public int lightProbeRenderSize = 128;
    public int lightProbeReadSize = 16;
    public int lightProbeMaxCoeffs = 9;

    public static ftLightmapsStorage storage;
    public static Dictionary<Scene, ftLightmapsStorage> storages;

    static bool tryFixingSceneView = true;

    // set via experimental UI now
    //static bool legacyDenoiser = false;
    //static bool oidnDenoiser = false;
    static bool foundCompatibleSetup = false;

    const bool alternativeDenoiseDir = true;

    const uint deviceMask = 0xFFFFFFFF;

    List<ReflectionProbe> reflectionProbes;

    public ftLightmapsStorage renderSettingsStorage;

    BakeryLightmapGroup currentGroup;
    LightingDataAsset newAssetLData;

    public static bool hasAnyProbes = false;
    public static bool hasAnyVolumes = false;
    public static bool hasAnyShadowmasks = false;
    static int maxSamplesPerPointLightBatch = 1024;

    public static bool compressVolumes = false;

    Vector2 scrollPos;

    public static ftGlobalStorage gstorage;
    static BakeryProjectSettings pstorage;

    public static string scenePath = "";
    public static string scenePathQuoted = "";
#if !LAUNCH_VIA_DLL
    static string dllPath;
#endif
    public static string outputPath = "BakeryLightmaps";
    public static string outputPathFull = "";

    BakeryLightMesh[] All;
    BakeryPointLight[] AllP;
    BakerySkyLight[] All2;
    BakeryDirectLight[] All3;

    List<bool[]> AllAffectsGroups;

    const int PASS_LDR = 1;
    const int PASS_FLOAT = 2;
    const int PASS_HALF = 4;
    const int PASS_MASK = 8;
    const int PASS_SECONDARY_HALF = 16;
    const int PASS_MASK1 = 32;
    const int PASS_DIRECTION = 64;
    const int PASS_RNM0 = 128;
    const int PASS_RNM1 = 256;
    const int PASS_RNM2 = 512;
    const int PASS_RNM3 = 1024;

#if UNITY_2021_2_OR_NEWER
    public const int maxTexSettingsSize = 256 * 1024;
    static System.IO.MemoryMappedFiles.MemoryMappedFile mmfTexProc;
#endif

    [System.Serializable]
    public struct Int2
    {
        public int x, y;

        public Int2(int _x, int _y)
        {
            x = _x;
            y = _y;
        }
    }

    Dictionary<string, bool> lmnameComposed;

    static GUIStyle foldoutStyle;

    static BakeryVolume[] lastFoundBakeableVolumes = null;

    List<BakeryLightmapGroupPlain> groupListPlain;
    List<BakeryLightmapGroupPlain> groupListGIContributingPlain;

    int[] uvBuffOffsets;
    int[] uvBuffLengths;
    float[] uvSrcBuff;
    float[] uvDestBuff;
    int[] lmrIndicesOffsets;
    int[] lmrIndicesLengths;
    int[] lmrIndicesBuff;
    int[] lmGroupLODResFlags;
    int[] lmGroupMinLOD;
    int[] lmGroupLODMatrix;

    public static Material matCubemapToStrip;

    Dictionary<int, int> shadowmaskGroupIDToChannel;

    static List<GameObject> overlappingLights;

    static LightingDataAsset emptyLDataAsset;

#if !LAUNCH_VIA_DLL
    public static void PatchPath()
    {
        string currentPath = System.Environment.GetEnvironmentVariable("PATH", System.EnvironmentVariableTarget.Process);
        dllPath = System.Environment.CurrentDirectory + Path.DirectorySeparatorChar + "Assets" + Path.DirectorySeparatorChar + "Editor" + Path.DirectorySeparatorChar + "x64";
        if(!currentPath.Contains(dllPath))
        {
            System.Environment.SetEnvironmentVariable("PATH", currentPath + Path.PathSeparator + dllPath, System.EnvironmentVariableTarget.Process);
        }
    }

    static ftRenderLightmap()
    {
        PatchPath();
    }
#endif

    void ValidateFileAttribs(string file)
    {
        var attribs = File.GetAttributes(file);
        if ((attribs & FileAttributes.ReadOnly) != 0)
        {
            File.SetAttributes(file, attribs & ~FileAttributes.ReadOnly);
        }
    }

    static List<string> loadedScenes;
    static List<bool> loadedScenesEnabled;
    static List<bool> loadedScenesActive;
    static Scene loadedDummyScene;
    static bool scenesUnloaded = false;
    static public void UnloadScenes()
    {
        EditorSceneManager.MarkAllScenesDirty();
        EditorSceneManager.SaveOpenScenes();

        loadedScenes = new List<string>();
        loadedScenesEnabled = new List<bool>();
        loadedScenesActive = new List<bool>();
        var sceneCount = EditorSceneManager.sceneCount;
        var activeScene = EditorSceneManager.GetActiveScene();
        for(int i=0; i<sceneCount; i++)
        {
            var s = EditorSceneManager.GetSceneAt(i);
            loadedScenes.Add(s.path);
            loadedScenesEnabled.Add(s.isLoaded);
            loadedScenesActive.Add(s == activeScene);
        }

        loadedDummyScene = EditorSceneManager.NewScene(NewSceneSetup.EmptyScene, NewSceneMode.Single);
        SceneManager.SetActiveScene(loadedDummyScene);
        RenderSettings.skybox = null;
        scenesUnloaded = true;
    }

    public bool TestSystemSpecs()
    {
        if (SystemInfo.graphicsShaderLevel < 30)
        {
            DebugLogError("Bakery requires Shader Model 3.0 or higher to work. Make sure you are not currently using graphics emulation of old shader models.");
            return false;
        }

        /*
        if (SystemInfo.graphicsDeviceType != GraphicsDeviceType.Direct3D11)
        {
            DebugLogError("Bakery requires Unity editor to be running in DX11 mode during the bake.");
            return false;
        }
        */

        if (!Directory.Exists(scenePath))
        {
            var defaultPath = System.Environment.GetEnvironmentVariable("TEMP", System.EnvironmentVariableTarget.Process) + "\\frender";

            ProgressBarEnd();
            bool cont = true;
            if (verbose)
            {
                cont = EditorUtility.DisplayDialog("Bakery", "Chosen temp path cannot be found:\n\n" + scenePath + "\n\nYou can cancel and set a different path in Advanced Settings or just use the default one:\n\n" + defaultPath + "\n", "Use default", "Cancel");
            }
            else
            {
                Debug.LogError("Chosen temp path was not found and set to default");
            }
            if (cont)
            {
                scenePath = defaultPath;
                ftBuildGraphics.scenePath = scenePath;
                scenePathQuoted = "\"" + scenePath + "\"";
            }
            else
            {
                return false;
            }
        }

        if (gstorage != null)
        {
            // last optimal settings detection ran on another GPU
            if (gstorage.gpuName != SystemInfo.graphicsDeviceName)
            {
                foundCompatibleSetup = false; // ask again
            }
            else
            {
                if (!rtxMode && !gstorage.runsNonRTX)
                {
                    if (gstorage.alwaysEnableRTX)
                    {
                        DebugLogInfo("Automatically enabled RTX");
                        rtxMode = true;
                        ftraceExe = ftraceExe6;
                        ftBuildGraphics.exportTerrainAsHeightmap = false;
                        SaveRenderSettings();
                    }
                    else
                    {
                        int choice = EditorUtility.DisplayDialogComplex("Bakery", "This scene has RTX disabled. It is recommended to enable it on your GPU.", "Enable", "Always enable", "Don't enable");
                        if (choice < 2)
                        {
                            // Enable or Always Enable
                            rtxMode = true;
                            ftraceExe = ftraceExe6;
                            ftBuildGraphics.exportTerrainAsHeightmap = false;
                            SaveRenderSettings();

                            if (choice == 1)
                            {
                                // Always Enable
                                gstorage.alwaysEnableRTX = true;
                                EditorUtility.SetDirty(gstorage);
                            }
                        }
                    }
                }

                if (denoise)
                {
                    if (denoiserType == ftGlobalStorage.DenoiserType.Optix5 && !gstorage.runsOptix5)
                    {
                        int choice = EditorUtility.DisplayDialogComplex("Bakery", "This scene has denoiser set to OptiX 5, but your GPU does not seem to support it. Please change the denoiser or re-run Bakery -> Utilities -> Detect optimal settings.", "OK", "Ignore", "Ignore forever");
                        if (choice == 0)
                        {
                            return false;
                        }
                        else if (choice == 2)
                        {
                            gstorage.runsOptix5 = true;
                            EditorUtility.SetDirty(gstorage);
                        }
                    }
                    else if (denoiserType == ftGlobalStorage.DenoiserType.Optix6 && !gstorage.runsOptix6)
                    {
                        int choice = EditorUtility.DisplayDialogComplex("Bakery", "This scene has denoiser set to OptiX 6, but your GPU does not seem to support it. Please change the denoiser or re-run Bakery -> Utilities -> Detect optimal settings.", "OK", "Ignore", "Ignore forever");
                        if (choice == 0)
                        {
                            return false;
                        }
                        else if (choice == 2)
                        {
                            gstorage.runsOptix6 = true;
                            EditorUtility.SetDirty(gstorage);
                        }
                    }
                    else if (denoiserType == ftGlobalStorage.DenoiserType.Optix7 && !gstorage.runsOptix7)
                    {
                        int choice = EditorUtility.DisplayDialogComplex("Bakery", "This scene has denoiser set to OptiX 7, but your GPU does not seem to support it. Please change the denoiser or re-run Bakery -> Utilities -> Detect optimal settings.", "OK", "Ignore", "Ignore forever");
                        if (choice == 0)
                        {
                            return false;
                        }
                        else if (choice == 2)
                        {
                            gstorage.runsOptix7 = true;
                            EditorUtility.SetDirty(gstorage);
                        }
                    }
                    else if (denoiserType == ftGlobalStorage.DenoiserType.OpenImageDenoise && !gstorage.runsOIDN)
                    {
                        int choice = EditorUtility.DisplayDialogComplex("Bakery", "This scene has denoiser set to OpenImageDenoise, but you CPU does not seem to support it. Please change the denoiser or re-run Bakery -> Utilities -> Detect optimal settings.", "OK", "Ignore", "Ignore forever");
                        if (choice == 0)
                        {
                            return false;
                        }
                        else if (choice == 2)
                        {
                            gstorage.runsOIDN = true;
                            EditorUtility.SetDirty(gstorage);
                        }
                    }
                    else if (denoiserType == ftGlobalStorage.DenoiserType.OpenImageDenoise2 && !gstorage.runsOIDN2)
                    {
                        int choice = EditorUtility.DisplayDialogComplex("Bakery", "This scene has denoiser set to OpenImageDenoise2 (CUDA), but you GPU does not seem to support it (needs at least 16XX or 20XX NVidia GPU). Please change the denoiser or re-run Bakery -> Utilities -> Detect optimal settings.", "OK", "Ignore", "Ignore forever");
                        if (choice == 0)
                        {
                            return false;
                        }
                        else if (choice == 2)
                        {
                            gstorage.runsOIDN2 = true;
                            EditorUtility.SetDirty(gstorage);
                        }
                    }
                }
            }
        }

        return true;
    }

    void ValidateOutputPath()
    {
        // Remove slashes from the end of the path
        while (outputPath.Length > 0 && (outputPath[outputPath.Length-1] == '/' || outputPath[outputPath.Length-1] == '\\'))
        {
            outputPath = outputPath.Substring(0, outputPath.Length-1);
        }
        var outDir = Application.dataPath + "/" + outputPath;
        if (!Directory.Exists(outDir)) Directory.CreateDirectory(outDir);
        outputPathFull = outputPath;

        if (curSector != null)
        {
            curSectorName = curSector.name;
            outputPathFull += "/" + curSectorName;
            outDir += "/" + curSectorName;
            if (!Directory.Exists(outDir)) Directory.CreateDirectory(outDir);
        }
        else
        {
            curSectorName = "";
        }
    }

    public static double GetTime()
    {
        return (System.DateTime.Now.Ticks / System.TimeSpan.TicksPerMillisecond) / 1000.0;
    }

    public static double GetTimeMs()
    {
        return System.DateTime.Now.Ticks / System.TimeSpan.TicksPerMillisecond;
    }

    static public void LoadScenes()
    {
        var sceneCount = loadedScenes.Count;
        for(int i=0; i<sceneCount; i++)
        {
            EditorSceneManager.OpenScene(loadedScenes[i], loadedScenesEnabled[i] ? OpenSceneMode.Additive : OpenSceneMode.AdditiveWithoutLoading);
        }
        if (loadedDummyScene.isLoaded) EditorSceneManager.UnloadSceneAsync(loadedDummyScene);
        scenesUnloaded = false;
    }

    bool ServerGetData()
    {
        var storageGO = ftLightmaps.FindInScene("!ftraceLightmaps", EditorSceneManager.GetActiveScene());
        if (storageGO == null) return false;
        var storage = storageGO.GetComponent<ftLightmapsStorage>();
        if (storage == null) return false;
        var list = storage.serverGetFileList;
        if (list == null) return false;

        lightmapHasColor = storage.lightmapHasColor;
        lightmapHasMask = storage.lightmapHasMask;
        lightmapHasDir = storage.lightmapHasDir;
        lightmapHasRNM = storage.lightmapHasRNM;

        ftClient.ServerGetData(list);
        return true;
    }

#if LAUNCH_VIA_DLL
    public static int lastReturnValue = 0;
    public static IEnumerator ProcessCoroutine(string app, string args, bool setWorkDir = true)
    {
        var exeProcess = RunLocalProcess(app+" "+args, setWorkDir);
        if (exeProcess == (System.IntPtr)null)
        {
            DebugLogError(app + " launch failed (see console for details)");
            userCanceled = false;
            ProgressBarEnd();
            yield break;
        }
        while(!IsProcessFinished(exeProcess))
        {
            yield return null;
            userCanceled = simpleProgressBarCancelled();
            if (userCanceled)
            {
                ProgressBarEnd();
                yield break;
            }
        }
        lastReturnValue = GetProcessReturnValueAndClose(exeProcess);
    }
#endif

    int GenerateVBTraceTexLOD(int id)
    {
        // Write vbTraceTex for LMGroup
        var vbtraceTexPosNormalArray = ftBuildGraphics.vbtraceTexPosNormalArray;
        var vbtraceTexUVArray = ftBuildGraphics.vbtraceTexUVArray;
        var vbtraceTexUVArrayLOD = ftBuildGraphics.vbtraceTexUVArrayLOD;

        var flodInfo = new BinaryReader(File.Open(scenePath + "/lods" + id + ".bin", FileMode.Open, FileAccess.Read));
        flodInfo.BaseStream.Seek(0, SeekOrigin.End);
        var numLMs = flodInfo.BaseStream.Position;
        flodInfo.BaseStream.Seek(0, SeekOrigin.Begin);
        if (lmGroupLODResFlags == null || lmGroupLODResFlags.Length != numLMs)
        {
            lmGroupLODResFlags = new int[numLMs];
        }
        var lodLevels = new int[numLMs];
        for(int i=0; i<numLMs; i++)
        {
            lodLevels[i] = (int)flodInfo.ReadByte();
            if (lodLevels[i] > 0 && lodLevels[i] < 30)
            {
                //int minLOD = lmGroupMinLOD[id];
                int minLOD = lmGroupMinLOD[i];
                if (lodLevels[i] > minLOD) lodLevels[i] = minLOD;
                lmGroupLODResFlags[i] |= 1 << (lodLevels[i] - 1);
            }
            lmGroupLODMatrix[id * numLMs + i] = lodLevels[i];
            //Debug.LogError("GenerateVBTraceTexLOD: " + id+" to "+i+" = "+lodLevels[i]+" ("+lmGroupLODResFlags[i]+", "+numLMs+")");
        }
        flodInfo.Close();

        var fvbtraceTex2 = new BinaryWriter(File.Open(scenePath + "/vbtraceTex" + id + ".bin", FileMode.Create));
        var numTraceVerts = vbtraceTexUVArray.Count/2;
        for(int k=0; k<numTraceVerts; k++)
        {
            fvbtraceTex2.Write(vbtraceTexPosNormalArray[k * 6]);
            fvbtraceTex2.Write(vbtraceTexPosNormalArray[k * 6 + 1]);
            fvbtraceTex2.Write(vbtraceTexPosNormalArray[k * 6 + 2]);
            fvbtraceTex2.Write(vbtraceTexPosNormalArray[k * 6 + 3]);
            fvbtraceTex2.Write(vbtraceTexPosNormalArray[k * 6 + 4]);
            fvbtraceTex2.Write(vbtraceTexPosNormalArray[k * 6 + 5]);

            int id2 = (int)(vbtraceTexUVArray[k * 2]/10);
            //if ((int)(vbtraceTexUVArray[k * 2]/10) == i)
            if (id2 < 0 || lodLevels[id2] == 0)
            {
                // own lightmap is full resoltion
                fvbtraceTex2.Write(vbtraceTexUVArray[k * 2]);
                fvbtraceTex2.Write(vbtraceTexUVArray[k * 2 + 1]);
            }
            else
            {
                // other lightmaps use LODs
                fvbtraceTex2.Write(vbtraceTexUVArrayLOD[k * 2]);
                fvbtraceTex2.Write(vbtraceTexUVArrayLOD[k * 2 + 1]);
            }
        }
        fvbtraceTex2.Close();
        return 0;
    }

    int SampleCount(int samples)
    {
        if (samples == 0) return 0;
        return System.Math.Max(samples / sampleDivisor,1);
    }

    bool GroupAffectedByGroup(int curSceneLodLevel, int otherSceneLodLevel)
    {
        if (curSceneLodLevel < 0)
        {
            if (otherSceneLodLevel > 0) return false; // non-LOD sees itself and LOD0
        }
        else
        {
            //if (otherSceneLodLevel >= 0 && otherSceneLodLevel != curSceneLodLevel) return false; // LOD sees itself and non-LOD
            // actually LOD sees non-LOD and other affecting objects we previously calculated
            if (otherSceneLodLevel >= 0)
            {
                var visLists = ftBuildGraphics.lodLevelsVisibleInLodLevel;
                if (visLists != null)
                {
                    List<int> visList;
                    if (visLists.TryGetValue(curSceneLodLevel, out visList))
                    {
                        if (visList != null)
                        {
                            if (visList.IndexOf(otherSceneLodLevel) < 0) return false;
                        }
                    }
                }
            }
        }
        return true;
    }

    void GenerateGIParameters(int id, string nm, int bounce, int bounces, bool useDir, int sceneLodLevel)
    {
        var fgi = new BinaryWriter(File.Open(scenePath + (deferredMode ? "/gi_" + nm + bounce + ".bin" : "/gi.bin"), FileMode.Create));
        fgi.Write(SampleCount(giSamples));
        fgi.Write(giBackFaceWeight);
        fgi.Write(bounce == bounces-1 ? "" : "uvalbedo_" + nm + (compressedGBuffer ? ".lz4" : ".dds"));

        int count = 0;
        foreach(var lmgroup2 in groupListGIContributingPlain)
        {
            if (lmgroup2.probes) continue; // nothing is ever affected by probes
            if (!GroupAffectedByGroup(sceneLodLevel, lmgroup2.sceneLodLevel)) continue;
            count++;
        }
        fgi.Write(count);

        foreach(var lmgroup2 in groupListGIContributingPlain)
        {
            if (lmgroup2.probes) continue; // nothing is ever affected by probes
            if (!GroupAffectedByGroup(sceneLodLevel, lmgroup2.sceneLodLevel)) continue;
            fgi.Write(lmgroup2.id);

            /*if (giLodModeEnabled)
            {
                var lod = lmGroupLODMatrix[id * groupListPlain.Count + lmgroup2.id];
                if (lod == 0)
                {
                    fgi.Write(lmgroup2.name + "_diffuse_HDR" + (compressedOutput ? ".lz4" : ".dds"));
                }
                else if (lod > 0 && lod < 127)
                {
                    //Debug.LogError("GenerateGIParameters: " + id+" to "+lmgroup2.id+" = "+lod+" ("+lmGroupLODResFlags[lmgroup2.id]+", "+groupListPlain.Count+")");
                    fgi.Write(lmgroup2.name + "_diffuse_HDR_LOD" + lod + (compressedOutput ? ".lz4" : ".dds"));
                }
                else
                {
                    fgi.Write("");
                }
            }
            else
            {*/
                fgi.Write(lmgroup2.name + "_diffuse_HDR" + (compressedOutput ? ".lz4" : ".dds"));
            //}
        }
        if (useDir) fgi.Write(bounce == bounces - 1 ? (nm + "_lights_Dir" + (compressedOutput ? ".lz4" : ".dds")) : "");
        fgi.Close();
    }

    float Pack4BytesToFloat(int r, int g, int b, int a)
    {
        // 6 bits precision

        // Move to 0-63 range
        r /= 4;
        g /= 4;
        b /= 4;
        a /= 4;

        return (r << 18) | (g << 12) | (b << 6) | a;
    }

    float Pack3BytesToFloat(int r, int g, int b)
    {
        // 8 bits precision
        var packed = (r << 16) | (g << 8) | b;
        return (packed) / (float)(1 << 24);
    }

    void WriteString(BinaryWriter flist, string str)
    {
        flist.Write(str.Length);
        for(int i=0; i<str.Length; i++)
        {
            flist.Write(str[i]);
        }
        byte zeroByte = 0;
        flist.Write(zeroByte);
    }

    Convex GetSpotConvex(Transform lbT, float angle, float range)
    {
        //var lbT = lb.transform;

        // radius computed same way as in BakeryPointLight gizmo drawing code
        //float angle = lb.spotAngle;
        float angle2 = (180 - angle) * Mathf.Deg2Rad * 0.5f;
        float x = 1 / Mathf.Sin(angle2);
        x = Mathf.Sqrt(x * x - 1);
        float radius = x * range;

        var bfar = lbT.position + lbT.forward * range;
        var bright = lbT.right * radius;
        var bup = lbT.up * radius;

        var bvertices = new Vector3[5];
        bvertices[0] = lbT.position;
        bvertices[1] = (bfar - bright) - bup;
        bvertices[2] = (bfar + bright) - bup;
        bvertices[3] = (bfar + bright) + bup;
        bvertices[4] = (bfar - bright) + bup;

        var bplanes = new Plane[5];
        bplanes[0] = new Plane(bvertices[1], bvertices[4], bvertices[3]); // cap
        bplanes[1] = new Plane(bvertices[0], bvertices[1], bvertices[2]);
        bplanes[2] = new Plane(bvertices[0], bvertices[2], bvertices[3]);
        bplanes[3] = new Plane(bvertices[0], bvertices[3], bvertices[4]);
        bplanes[4] = new Plane(bvertices[0], bvertices[4], bvertices[1]);

        var bconvex = new Convex();
        bconvex.vertices = bvertices;
        bconvex.planes = bplanes;

        return bconvex;
    }

    bool ConvexIntersect(Convex a, Convex b)
    {
        // all B verts must be on the same side of at least one plane of A
        for(int p=0; p<a.planes.Length; p++)
        {
            bool outside = true;
            for(int v=0; v<b.vertices.Length; v++)
            {
                outside = !a.planes[p].GetSide(b.vertices[v]);
                if (!outside) break; // intersects or inside
            }
            if (outside) return false;
        }
        return true;
    }

    bool ConvexSphereIntersect(Convex a, Vector3 bpos, float bradius)
    {
        // sphere must be outside of any plane with distance >= radius
        for(int p=0; p<a.planes.Length; p++)
        {
            float d = -a.planes[p].GetDistanceToPoint(bpos);
            if (d > bradius) return false;
        }
        return true;
    }

    int GenerateVertexBakedMeshes(int LMID, string lmname, bool hasShadowMask, bool hasDir, bool hasSH, bool monoSH)
    {
        int errCode = 0;
        int errCode2 = 0;
        int errCode3 = 0;
        int errCode4 = 0;
        int errCode5 = 0;
        int errCode6 = 0;

        //var vertexOffsetLengths = new List<int>();
        int totalVertexCount = 0;
        for(int i=0; i<storage.bakedIDs.Count; i++)
        {
            if (storage.bakedIDs[i] != LMID) continue;
            var mr = storage.bakedRenderers[i];
            //var vertexOffset = storage.bakedVertexOffset[i];

            //vertexOffsetLengths.Add(vertexOffset);
            var sharedMesh = ftBuildGraphics.GetSharedMesh(mr);
            int vertexCount = sharedMesh.vertexCount;
            //vertexOffsetLengths.Add(vertexCount);

            totalVertexCount += vertexCount;
        }

        if (totalVertexCount == 0) return 0;

        AssetDatabase.StartAssetEditing();

        int atlasTexSize = (int)Mathf.Ceil(Mathf.Sqrt((float)totalVertexCount));
        atlasTexSize = (int)Mathf.Ceil(atlasTexSize / (float)tileSize) * tileSize;

        var vertColors = new byte[atlasTexSize * atlasTexSize * 4];
        byte[] vertColorsMask = null;
        byte[] vertColorsDir = null;
        byte[] vertColorsSHL1x = null;
        byte[] vertColorsSHL1y = null;
        byte[] vertColorsSHL1z = null;
        if (hasShadowMask) vertColorsMask = new byte[atlasTexSize * atlasTexSize * 4];
        if (hasDir) vertColorsDir = new byte[atlasTexSize * atlasTexSize * 4];
        if (hasSH)
        {
            vertColorsSHL1x = new byte[atlasTexSize * atlasTexSize * 4];
            vertColorsSHL1y = new byte[atlasTexSize * atlasTexSize * 4];
            vertColorsSHL1z = new byte[atlasTexSize * atlasTexSize * 4];
        }

        var sceneCount = SceneManager.sceneCount;

        GCHandle handle = GCHandle.Alloc(vertColors, GCHandleType.Pinned);
        GCHandle handleMask = new GCHandle();
        GCHandle handleDir = new GCHandle();
        GCHandle handleL1x = new GCHandle();
        GCHandle handleL1y = new GCHandle();
        GCHandle handleL1z = new GCHandle();
        if (hasShadowMask) handleMask = GCHandle.Alloc(vertColorsMask, GCHandleType.Pinned);
        if (hasDir) handleDir = GCHandle.Alloc(vertColorsDir, GCHandleType.Pinned);
        if (hasSH)
        {
            handleL1x = GCHandle.Alloc(vertColorsSHL1x, GCHandleType.Pinned);
            handleL1y = GCHandle.Alloc(vertColorsSHL1y, GCHandleType.Pinned);
            handleL1z = GCHandle.Alloc(vertColorsSHL1z, GCHandleType.Pinned);
        }
        try
        {
            System.IntPtr pointer = handle.AddrOfPinnedObject();
            System.IntPtr pointerMask = (System.IntPtr)0;
            System.IntPtr pointerDir = (System.IntPtr)0;
            System.IntPtr pointerL1x = (System.IntPtr)0;
            System.IntPtr pointerL1y = (System.IntPtr)0;
            System.IntPtr pointerL1z = (System.IntPtr)0;
            if (hasShadowMask) pointerMask = handleMask.AddrOfPinnedObject();
            if (hasDir) pointerDir = handleDir.AddrOfPinnedObject();
            if (hasSH)
            {
                pointerL1x = handleL1x.AddrOfPinnedObject();
                pointerL1y = handleL1y.AddrOfPinnedObject();
                pointerL1z = handleL1z.AddrOfPinnedObject();
            }

            errCode = halffloat2vb(scenePath + "\\" + lmname + (hasSH ? "_final_L0" : "_final_HDR") + (compressedOutput ? ".lz4" : ".dds"), pointer, 0);

            if (hasShadowMask)
                errCode2 = halffloat2vb(scenePath + "\\" + lmname + "_Mask" + (compressedOutput ? ".lz4" : ".dds"), pointerMask, 1);
            if (hasDir)
                errCode3 = halffloat2vb(scenePath + "\\" + lmname + "_final_Dir" + (compressedOutput ? ".lz4" : ".dds"), pointerDir, 1);

            if (hasSH)
            {
                errCode4 = halffloat2vb(scenePath + "\\" + lmname + "_final_L1x" + (compressedOutput ? ".lz4" : ".dds"), pointerL1x, 1);
                errCode5 = halffloat2vb(scenePath + "\\" + lmname + "_final_L1y" + (compressedOutput ? ".lz4" : ".dds"), pointerL1y, 1);
                errCode6 = halffloat2vb(scenePath + "\\" + lmname + "_final_L1z" + (compressedOutput ? ".lz4" : ".dds"), pointerL1z, 1);
            }

            if (errCode == 0 && errCode2 == 0 && errCode3 == 0 && errCode4 == 0 && errCode5 == 0 && errCode6 == 0)
            {
                for(int i=0; i<storage.bakedIDs.Count; i++)
                {
                    if (storage.bakedIDs[i] != LMID) continue;
                    var mr = storage.bakedRenderers[i];
                    var vertexOffset = storage.bakedVertexOffset[i];

                    var mesh = ftBuildGraphics.GetSharedMesh(mr);
                    int vertexCount = mesh.vertexCount;

                    var colorBuff = new Color32[vertexCount];
                    for(int j=0; j<vertexCount; j++)
                    {
                        colorBuff[j] = new Color32(vertColors[(vertexOffset + j) * 4],
                                                   vertColors[(vertexOffset + j) * 4 + 1],
                                                   vertColors[(vertexOffset + j) * 4 + 2],
                                                   vertColors[(vertexOffset + j) * 4 + 3]);
                    }

                    var newMesh = new Mesh();
                    newMesh.vertices = mesh.vertices;
                    newMesh.colors32 = colorBuff;

                    //float packScale = 254.0f / 255.0f;
                    //maskBuff[j] = new Vector2(r+(g/255.0f)*packScale, b+(a/255.0f)*packScale);

                    /*
                    uv2
                        x: shadowmask
                        y: dir/L1x
                    uv3
                        x: L1y
                        y: L1z
                    */

                    if (hasShadowMask || hasDir || hasSH)
                    {
                        var buff = new Vector2[vertexCount];
                        byte sr = 0, sg = 0, sb = 0, sa = 0;
                        byte dr = 0, dg = 0, db = 0;//, da = 0;
                        for(int j=0; j<vertexCount; j++)
                        {
                            if (hasShadowMask)
                            {
                                sr = vertColorsMask[(vertexOffset + j) * 4];
                                sg = vertColorsMask[(vertexOffset + j) * 4 + 1];
                                sb = vertColorsMask[(vertexOffset + j) * 4 + 2];
                                sa = vertColorsMask[(vertexOffset + j) * 4 + 3];
                            }
                            if (hasDir)
                            {
                                dr = vertColorsDir[(vertexOffset + j) * 4];
                                dg = vertColorsDir[(vertexOffset + j) * 4 + 1];
                                db = vertColorsDir[(vertexOffset + j) * 4 + 2];
                                //da = vertColorsDir[(vertexOffset + j) * 4 + 3];
                            }
                            else if (hasSH && monoSH)
                            {
                                const float rweight = 0.33333f;//0.2125f;
                                const float gweight = 0.33333f;//0.7154f;
                                const float bweight = 0.33333f;//0.0721f;
                                dr = (byte)(vertColorsSHL1x[(vertexOffset + j) * 4] * rweight + vertColorsSHL1x[(vertexOffset + j) * 4 + 1] * gweight + vertColorsSHL1x[(vertexOffset + j) * 4 + 2] * bweight);
                                dg = (byte)(vertColorsSHL1y[(vertexOffset + j) * 4] * rweight + vertColorsSHL1y[(vertexOffset + j) * 4 + 1] * gweight + vertColorsSHL1y[(vertexOffset + j) * 4 + 2] * bweight);
                                db = (byte)(vertColorsSHL1z[(vertexOffset + j) * 4] * rweight + vertColorsSHL1z[(vertexOffset + j) * 4 + 1] * gweight + vertColorsSHL1z[(vertexOffset + j) * 4 + 2] * bweight);
                            }
                            else if (hasSH)
                            {
                                dr = vertColorsSHL1x[(vertexOffset + j) * 4];
                                dg = vertColorsSHL1x[(vertexOffset + j) * 4 + 1];
                                db = vertColorsSHL1x[(vertexOffset + j) * 4 + 2];
                            }
                            buff[j] = new Vector2(Pack4BytesToFloat(sr,sg,sb,sa), Pack3BytesToFloat(dr,dg,db));
                        }
                        newMesh.uv2 = buff;
                    }

                    if (hasSH && !monoSH)
                    {
                        var buff = new Vector2[vertexCount];
                        byte r1,g1,b1;
                        byte r2,g2,b2;
                        for(int j=0; j<vertexCount; j++)
                        {
                            r1 = vertColorsSHL1y[(vertexOffset + j) * 4];
                            g1 = vertColorsSHL1y[(vertexOffset + j) * 4 + 1];
                            b1 = vertColorsSHL1y[(vertexOffset + j) * 4 + 2];

                            r2 = vertColorsSHL1z[(vertexOffset + j) * 4];
                            g2 = vertColorsSHL1z[(vertexOffset + j) * 4 + 1];
                            b2 = vertColorsSHL1z[(vertexOffset + j) * 4 + 2];

                            buff[j] = new Vector2(Pack3BytesToFloat(r1,g1,b1), Pack3BytesToFloat(r2,g2,b2));
                        }
                        newMesh.uv3 = buff;
                    }

                    //newMesh.triangles = mesh.triangles; // debug only!

                    for(int s=0; s<sceneCount; s++)
                    {
                        var scene = EditorSceneManager.GetSceneAt(s);
                        if (!scene.isLoaded) continue;
                        var st = storages[scene];
                        st.bakedVertexColorMesh[i] = newMesh;
                    }

                    var outPath = "Assets/" + outputPathFull + "/" + lmname + i + ".asset";
                    if (File.Exists(outPath)) ValidateFileAttribs(outPath);
                    AssetDatabase.CreateAsset(newMesh, outPath);
                }
                AssetDatabase.SaveAssets();
            }
            else
            {
                Debug.LogError("hf2vb: " + errCode + " " + errCode2 + " " + errCode3 + " " + errCode4 + " " + errCode5 + " " + errCode6);
            }
        }
        finally
        {
            if (handle.IsAllocated) handle.Free();
            if (handleMask.IsAllocated) handleMask.Free();
            if (handleDir.IsAllocated) handleDir.Free();
            if (handleL1x.IsAllocated) handleL1x.Free();
            if (handleL1y.IsAllocated) handleL1y.Free();
            if (handleL1z.IsAllocated) handleL1z.Free();
        }

        AssetDatabase.StopAssetEditing();

        return errCode;
    }

    public void RenderReflectionProbesButton(bool showMsgWindows = true)
    {
        ValidateOutputPath();
        restoreFromGlobalSector = false;
        userCanceled = false;
        if (Application.isPlaying) return;
        progressFunc = RenderReflProbesFunc();
        EditorApplication.update += RenderReflProbesUpdate;
        verbose = showMsgWindows;
        bakeInProgress = true;
        showProgressBar = true;
    }

    public void RenderLightProbesButton(bool showMsgWindows = true)
    {
        ValidateOutputPath();
        restoreFromGlobalSector = false; // changes to true after global sector is initialized
        userCanceled = false;
        fullSectorRender = false;
        if (Application.isPlaying) return;
        if (!TestSystemSpecs()) return;
        if (lightProbeMode == LightProbeMode.Legacy)
        {
            progressFunc = RenderLightProbesFunc();
            EditorApplication.update += RenderLightProbesUpdate;
            verbose = showMsgWindows;
            bakeInProgress = true;
        }
        else if (lightProbeMode == LightProbeMode.L1)
        {
            selectedOnly = false;
            probesOnlyL1 = true;
            progressFunc = RenderLightmapFunc();
            EditorApplication.update += RenderLightmapUpdate;
            verbose = showMsgWindows;
            bakeInProgress = true;
        }
        showProgressBar = true;
    }

    public bool TestNeedsBenchmark()
    {
        if (!foundCompatibleSetup && verbose)
        {
            if (gstorage != null) gstorage.foundCompatibleSetup = true;
            foundCompatibleSetup = true;
            int answer = EditorUtility.DisplayDialogComplex("Bakery", "Would you like to automatically detect optimal settings for your hardware? You can also do it later via Bakery/Utilities/Detect optimal settings", "Yes", "No", "Never");
            if (answer == 0)
            {
                ftDetectSettings.DetectCompatSettings();
                return true;
            }
            else if (answer == 2)
            {
                gstorage.foundCompatibleSetup = foundCompatibleSetup = true;
                gstorage.gpuName = SystemInfo.graphicsDeviceName;
                EditorUtility.SetDirty(gstorage);
            }
        }
        return false;
    }

    public void RenderButton(bool showMsgWindows = true)
    {
        ValidateOutputPath();

        restoreFromGlobalSector = true;
        userCanceled = false;
        if (Application.isPlaying) return;
        if (!TestSystemSpecs()) return;
        verbose = showMsgWindows;

        if (clientMode)
        {
            if (!ftClient.connectedToServer)
            {
                DebugLogError("Network rendering is enabled, but the server is disconnected.");
                return;
            }
            if (ftClient.lastServerErrorCode == ftClient.SERVERERROR_BUSY)
            {
                DebugLogError("Server is busy.");
                return;
            }
        }
        else
        {
            if (TestNeedsBenchmark()) return;
        }

        if (pstorage == null) pstorage = ftLightmaps.GetProjectSettings();

        if (pstorage.deletePreviousLightmapsBeforeBake)
        {
            ftClearMenu.ClearBakedData(ftClearMenu.SceneClearingMode.nothing, true);
        }

        if (OnPreFullRender != null)
        {
            OnPreFullRender.Invoke(this, null);
        }

#if UNITY_2018_3_OR_NEWER
        unityEditorHWND = GetForegroundWindow();
        var wnd = GetParent(unityEditorHWND);
        while(wnd != (System.IntPtr)0)
        {
            unityEditorHWND = wnd;
            wnd = GetParent(unityEditorHWND);
        }

        var titleBuff = new StringBuilder(256);
        if (GetWindowText(unityEditorHWND, titleBuff, 256) > 0)
        {
            DebugLogInfo("Editor window: " + titleBuff.ToString());
        }
        else
        {
            DebugLogInfo("Unable to get Editor window name");
        }
#endif

        selectedOnly = false;
        probesOnlyL1 = false;
        fullSectorRender = curSector != null;
        hasAnyVolumes = true; // possibly - ftBuildGraphics will figure it out
        hasAnyShadowmasks = false;
        progressFunc = RenderLightmapFunc();
        EditorApplication.update += RenderLightmapUpdate;
        bakeInProgress = true;
        showProgressBar = true;
    }

    string Float2String(float val)
    {
        return ("" + val).Replace(",", "."); // newer Unity versions can break float formatting by incorrectly applying regional settings
    }

    public static string progressBarText;
    public static float progressBarPercent = 0;
    float progressBarStep = 0;
    public static bool progressBarEnabled = false;
    public static bool userCanceled = false; // can be used externally to check if the bake progress was cancelled
    int progressSteps, progressStepsDone;
    IEnumerator progressFunc;
    public static bool bakeInProgress = false;
    void ProgressBarInit(string startText)
    {
        ProgressBarSetStep(0);
        progressBarText = startText;
        progressBarEnabled = true;
        if (showProgressBar) simpleProgressBarShow("Bakery", progressBarText, progressBarPercent, progressBarStep, false);
    }
    void ProgressBarSetStep(float step)
    {
        progressBarStep = step;
    }
    void ProgressBarShow(string text, float percent, bool onTop)
    {
        progressBarText = text;
        progressBarPercent = percent;
        if (showProgressBar) simpleProgressBarShow("Bakery", progressBarText, progressBarPercent, progressBarStep, onTop);
        userCanceled = simpleProgressBarCancelled();
    }
    public static void ProgressBarEnd(bool freeAreas = true)
    {
        if (freeAreas) ftBuildGraphics.FreeTemporaryAreaLightMeshes();
        if (scenesUnloaded) LoadScenes();

        if (revertReflProbesValue)
        {
            QualitySettings.realtimeReflectionProbes = reflProbesValue;
            revertReflProbesValue = false;
        }

        if (userCanceled && restoreFromGlobalSector && ftRenderLightmap.instance != null)
        {
            if (ftRenderLightmap.instance.unloadScenesInDeferredMode)
            {
                MergeSectorsDeferred();
            }
            else
            {
                MergeSectors();
            }
        }

        progressBarEnabled = false;
        if (showProgressBar) simpleProgressBarEnd();
    }
    void OnInspectorUpdate()
    {
        Repaint();
    }
    string twoChars(int i)
    {
        if (i < 10) return "0" + i;
        return "" + i;
    }
    void OnGUI()
    {
        if (progressBarEnabled)
        {
            return;
        }

        #if UNITY_2018_2_OR_NEWER && !UNITY_2019_1_OR_NEWER
                // Jittery window fix by farfelu
                if (EditorGUIUtility.pixelsPerPoint == 1.25f)
                {
                    this.minSize = new Vector2(252, this.minSize.y);
                }
        #endif

        if (tryFixingSceneView)
        {
            FindGlobalStorage();
            if (gstorage != null)
            {
                // Fix checker preview being incorrectly set for scene view
                if (gstorage.checkerPreviewOn && !showChecker)
                {
                    var sceneView = SceneView.lastActiveSceneView;
                    if (sceneView != null)
                    {
                        sceneView.SetSceneViewShaderReplace(null, null);
                        gstorage.checkerPreviewOn = false;
                        if (ftAtlasPreview.instance != null) ftAtlasPreview.instance.OnGUI();
                        EditorUtility.SetDirty(gstorage);
                    }
                }

                if (gstorage.rtSceneViewPreviewOn)
                {
                    var sceneView = SceneView.lastActiveSceneView;
                    if (sceneView != null)
                    {
                        sceneView.SetSceneViewShaderReplace(null, null);
                        gstorage.rtSceneViewPreviewOn = false;
                        if (ftAtlasPreview.instance != null) ftAtlasPreview.instance.OnGUI();
                        EditorUtility.SetDirty(gstorage);
                    }
                }
            }
            tryFixingSceneView = false;
        }

        int y = 0;

        var headerStyle = EditorStyles.label;
        var numberBoxStyle = EditorStyles.numberField;
        var textBoxStyle = EditorStyles.textField;

#if UNITY_2019_3_OR_NEWER
        if (EditorGUIUtility.isProSkin)
        {
            headerStyle = new GUIStyle(EditorStyles.whiteLabel);
        }
        else
        {
            headerStyle = new GUIStyle(EditorStyles.label);
        }
        headerStyle.alignment = TextAnchor.UpperLeft;
        headerStyle.padding = new RectOffset(0,0,5,0);

        numberBoxStyle = new GUIStyle(numberBoxStyle);
        numberBoxStyle.alignment = TextAnchor.MiddleLeft;
        numberBoxStyle.contentOffset = new Vector2(0, -1);

        textBoxStyle = new GUIStyle(textBoxStyle);
        textBoxStyle.alignment = TextAnchor.MiddleLeft;
        textBoxStyle.contentOffset = new Vector2(0, -1);
#endif

        if (foldoutStyle == null)
        {
            foldoutStyle = new GUIStyle(EditorStyles.foldout);
            //foldoutStyle.fontStyle = FontStyle.Bold;
        }

        if (PlayerSettings.colorSpace != ColorSpace.Linear)
        {
            y += 15;
            GUI.BeginGroup(new Rect(10, y, 300, 120), "[Gamma color space detected]", headerStyle); y += 30;
#if UNITY_2019_3_OR_NEWER
            int by = 20;
#else
            int by = 15;
#endif
            if (GUI.Button(new Rect(15, by, 200, 20), "Switch project to linear"))
            {
                if (EditorUtility.DisplayDialog("Bakery", "Linear color space is essential for getting realistic results. Switching the project may force Unity to reimport assets. It can take some time, depending on project size. Continue?", "OK", "Cancel"))
                {
                    PlayerSettings.colorSpace = ColorSpace.Linear;
                }
            }
            GUI.EndGroup();
            y += 10;
        }

        var aboutRect = new Rect(10, y+5, 250, 20);
        var linkStyle = new GUIStyle();
        linkStyle.richText = true;
        var clr = GUI.contentColor;
        GUI.contentColor = Color.blue;
        GUI.Label(aboutRect, new GUIContent("<color=#5073c9ff><b>Bakery - GPU Lightmapper by Mr F</b></color>", "Version 1.96. Click to go to Bakery Wiki"), linkStyle);
        GUI.Label(aboutRect, new GUIContent("<color=#5073c9ff><b>____________________________</b></color>", "Go to Bakery Wiki"), linkStyle);
        if (Event.current.type == EventType.MouseUp && aboutRect.Contains(Event.current.mousePosition))
        {
            Application.OpenURL("https://geom.io/bakery/wiki/");
        }
        GUI.contentColor = clr;
        y += 15;

        bool simpleWindowIsTooSmall = position.height < 300;

        float scrollHeight = 0;
        if (settingsMode >= SettingsMode.Advanced || simpleWindowIsTooSmall)
        {
            scrollHeight = 620+y+(showAOSettings ? 65 : 15)+(showPaths ? 70 : 0) + (userRenderMode==RenderMode.Shadowmask ? 20 : 0) + 40;
            if (showPerf) scrollHeight += 160;
#if UNITY_2019_3_OR_NEWER
            scrollHeight += 30;
#endif
            scrollHeight += 40;// + (showCompression ? 25*3 : 0);
            scrollHeight += 60;
            scrollHeight += showTasks2 ? 55+30 : 5;
            scrollHeight += showTasks ? (settingsMode == SettingsMode.Experimental ? 140 : 100) : 0;
            scrollHeight += 20;
            scrollHeight += ftBuildGraphics.texelsPerUnitPerMap ? 120 : 0;
            scrollHeight += showCheckerSettings ? 30+20 : 30;
            scrollHeight += (showCheckerSettings && showChecker) ? 20 : 0;
            scrollHeight += (renderDirMode == RenderDirMode.RNM || renderDirMode == RenderDirMode.SH || renderDirMode == RenderDirMode.MonoSH) ? (showDirWarning ? 60 : 10) : 0;
            if (ftBuildGraphics.unwrapUVs) scrollHeight += 20;
            if (settingsMode == SettingsMode.Advanced) scrollHeight += 100;
            if (settingsMode == SettingsMode.Simple) scrollHeight = this.minSize.y - 30;
            if (settingsMode == SettingsMode.Experimental)
            {
                scrollHeight += 240;
                if (ftBuildGraphics.atlasPacker == ftGlobalStorage.AtlasPacker.xatlas) scrollHeight += 60;
                if (ftBuildGraphics.unwrapUVs) scrollHeight += 30;
                if (denoise) scrollHeight += 20;
                if (showNet) scrollHeight += clientMode ? 120 : 30;
            }
            scrollPos = GUI.BeginScrollView(new Rect(0, 10+y, 270, position.height-20), scrollPos, new Rect(0,10+y,200,scrollHeight));
        }

        if (settingsMode >= SettingsMode.Advanced)
        {
            this.minSize = new Vector2(position.height >= scrollHeight ? 250 : 270, 700);
        }
        this.maxSize = new Vector2(this.minSize.x, settingsMode >= SettingsMode.Advanced ? 820 : this.minSize.y + 1);

        GUI.contentColor = new Color(clr.r, clr.g, clr.b, 0.5f);
        int hours = lastBakeTime / (60*60);
        int minutes = (lastBakeTime / 60) % 60;
        int seconds = lastBakeTime % 60;
        GUI.Label(new Rect(105, y+10, 130, 20), "Last bake: "+twoChars(hours)+"h "+twoChars(minutes)+"m "+twoChars(seconds)+"s", EditorStyles.miniLabel);
        GUI.contentColor = clr;

        GUI.BeginGroup(new Rect(10, 10+y, 300, 340), "Settings mode", headerStyle);
        EditorGUILayout.Space();
        EditorGUILayout.Space();
        EditorGUILayout.Space();
        var opts = new GUILayoutOption[1];
        opts[0] = GUILayout.Width(225);
        settingsMode = (SettingsMode)EditorGUILayout.EnumPopup(settingsMode, opts);
        y += 40;
        //EditorGUILayout.Space();
        //EditorGUILayout.Space();
        EditorGUILayout.Space();
        EditorGUILayout.Space();
        EditorGUILayout.Space();
        userRenderMode = (RenderMode)EditorGUILayout.EnumPopup(userRenderMode, opts);
        EditorGUILayout.Space();
        EditorGUILayout.Space();
        EditorGUILayout.Space();
        renderDirMode = (RenderDirMode)EditorGUILayout.EnumPopup(renderDirMode, opts);

        if (settingsMode >= SettingsMode.Advanced)
        {
            EditorGUILayout.Space();
            EditorGUILayout.Space();
            EditorGUILayout.Space();
            //EditorGUILayout.Space();
            lightProbeMode = (LightProbeMode)EditorGUILayout.EnumPopup(lightProbeMode, opts);
        }

        if (settingsMode == SettingsMode.Experimental)
        {
            EditorGUILayout.Space();
            EditorGUILayout.Space();
            EditorGUILayout.Space();
            ftBuildGraphics.atlasPacker = (ftGlobalStorage.AtlasPacker)EditorGUILayout.EnumPopup(ftBuildGraphics.atlasPacker, opts);
        }

        if (settingsMode >= SettingsMode.Advanced)
        {
            EditorGUILayout.Space();
            EditorGUILayout.Space();
            EditorGUILayout.Space();

            var uvMode = AdjustUVMode.DontChange;
            if (ftBuildGraphics.unwrapUVs)
            {
                uvMode = AdjustUVMode.Adjust;
            }
            else if (ftBuildGraphics.forceDisableUnwrapUVs)
            {
                uvMode = AdjustUVMode.ForceDisableAdjust;
            }

            uvMode = (AdjustUVMode)EditorGUILayout.Popup((int)uvMode, adjustUVOptions, opts);

            if (uvMode == AdjustUVMode.DontChange)
            {
                ftBuildGraphics.unwrapUVs = false;
                ftBuildGraphics.forceDisableUnwrapUVs = false;
            }
            else if (uvMode == AdjustUVMode.Adjust)
            {
                ftBuildGraphics.unwrapUVs = true;
                ftBuildGraphics.forceDisableUnwrapUVs = false;
            }
            else
            {
                ftBuildGraphics.unwrapUVs = false;
                ftBuildGraphics.forceDisableUnwrapUVs = true;
            }
        }

        if (settingsMode == SettingsMode.Experimental && ftBuildGraphics.unwrapUVs)
        {
            EditorGUILayout.Space();
            EditorGUILayout.Space();
            EditorGUILayout.Space();
            //EditorGUILayout.Space();
            var prev = unwrapper;
            unwrapper = (ftGlobalStorage.Unwrapper)EditorGUILayout.EnumPopup(unwrapper, opts);
            if (unwrapper != prev)
            {
                if (unwrapper == ftGlobalStorage.Unwrapper.xatlas)
                {
                    FindGlobalStorage();
                    if (gstorage != null && !gstorage.xatlasWarningShown)
                    {
                        gstorage.xatlasWarningShown = true;
                        EditorUtility.SetDirty(gstorage);
                        if (!EditorUtility.DisplayDialog("Bakery", "xatlas may provide better UV unwrapping for models with 'Generate lightmap UVs' if 'Adjust UV padding' is enabled in Bakery.\nBut there are several limitations:\n\nTo share a baked scene unwrapped with xatlas, Editor/x64/Bakery/scripts/xatlas folder must be included.\n\nxatlas is native library, so currently any PC opening a baked scene in Unity editor must be on x64 Windows.\n", "Use xatlas", "Cancel"))
                        {
                            unwrapper = ftGlobalStorage.Unwrapper.Default;
                        }
                    }
                }
            }
        }

        if (settingsMode >= SettingsMode.Advanced)
        {
            EditorGUILayout.Space();
            EditorGUILayout.Space();
            EditorGUILayout.Space();
            denoiserType = (ftGlobalStorage.DenoiserType)EditorGUILayout.EnumPopup(denoiserType, opts);
        }

        GUI.EndGroup();

        GUI.BeginGroup(new Rect(10, 10+y, 300, 120), "Render mode", headerStyle);
        y += 40;

        //bool prevVal = bakeWithNormalMaps;
        //bakeWithNormalMaps = GUI.Toggle(new Rect(2, 40, 200, 20), bakeWithNormalMaps, new GUIContent("Bake with normal maps", "Bake normal map effect into lightmaps"));
        //y += 20;

        GUI.EndGroup();

        GUI.BeginGroup(new Rect(10, 10+y, 300, 120), "Directional mode", headerStyle);
        y += 40;

        GUI.EndGroup();

        if (settingsMode >= SettingsMode.Advanced)
        {
#if UNITY_2019_3_OR_NEWER
#else
            y -= 4;
#endif
            GUI.BeginGroup(new Rect(10, 10+y, 300, 120), "Light probe mode", headerStyle);
            y += 40;
            GUI.EndGroup();
        }

        if (settingsMode == SettingsMode.Experimental)
        {
#if UNITY_2019_3_OR_NEWER
#else
            y -= 3;
#endif
            GUI.BeginGroup(new Rect(10, 10+y, 300, 120), "Atlas packer", headerStyle);
            y += 40;
            GUI.EndGroup();
        }

        if (settingsMode >= SettingsMode.Advanced)
        {
#if UNITY_2019_3_OR_NEWER
#else
            if (settingsMode == SettingsMode.Advanced) y -= 3;
#endif
            GUI.BeginGroup(new Rect(10, 10+y, 300, 120), "Asset UV processing", headerStyle);
            y += 40;
            GUI.EndGroup();
        }

        if (settingsMode == SettingsMode.Experimental && ftBuildGraphics.unwrapUVs)
        {
#if UNITY_2019_3_OR_NEWER
#else
            y -= 3;
#endif
            GUI.BeginGroup(new Rect(10, 10+y, 300, 120), "Unwrapper", headerStyle);
            y += 40;
            GUI.EndGroup();
        }

        if (settingsMode >= SettingsMode.Advanced)
        {
#if UNITY_2019_3_OR_NEWER
#else
            y -= 3;
#endif
            GUI.BeginGroup(new Rect(10, 10+y, 300, 120), "Denoiser", headerStyle);
            y += 40;
#if UNITY_2019_3_OR_NEWER
            y += 3;
#endif
            GUI.EndGroup();
        }

#if UNITY_2017_1_OR_NEWER
        if (userRenderMode == RenderMode.Shadowmask)
        {
            GUI.BeginGroup(new Rect(10, 10+y, 300, 120), "", headerStyle);
            var prevVal = isDistanceShadowmask;
            isDistanceShadowmask = GUI.Toggle(new Rect(2, 0, 200, 20), isDistanceShadowmask, new GUIContent("Distance shadowmask", "Use complete real-time shadows close to camera."));
            if (isDistanceShadowmask != prevVal)
            {
                QualitySettings.shadowmaskMode = isDistanceShadowmask ? ShadowmaskMode.DistanceShadowmask : ShadowmaskMode.Shadowmask;
            }
            y += 25;
            GUI.EndGroup();
        }
#endif

        if (renderDirMode == RenderDirMode.RNM || renderDirMode == RenderDirMode.SH || renderDirMode == RenderDirMode.MonoSH)
        {
            showDirWarning = EditorGUI.Foldout(new Rect(10,y+10,220,20), showDirWarning, "Directional mode info", foldoutStyle);
            if (showDirWarning)
            {
                var str = renderDirMode + " maps require special shader";
                EditorGUI.HelpBox(new Rect(15,y+30,220,40), str, MessageType.Info);
                y += 45;
            }
            y += 20;
        }

        if (settingsMode < SettingsMode.Advanced)
        {
            this.minSize = new Vector2(250, 310+20-40 + y + 45 + 40 + 20 + (showTasks2 ? 40+50 : 0) +
                (userRenderMode == RenderMode.AmbientOcclusionOnly ? (showAOSettings ? 20 : -40) : 0));
        }

        y += 10;
        if (settingsMode >= SettingsMode.Advanced)
        {
            showTasks = EditorGUI.Foldout(new Rect(10, y, 300, 20), showTasks, "Lightmapping tasks", foldoutStyle);
            y += 20;

            if (showTasks)
            {
                int xx = 20;
                int yy = y;// - 20;
                //GUI.BeginGroup(new Rect(10, y, 300, 160+20), "Lightmapping tasks", headerStyle);
                if (settingsMode == SettingsMode.Experimental)
                {
                    forceRebuildGeometry = GUI.Toggle(new Rect(xx, yy, 200, 20), forceRebuildGeometry, new GUIContent("Export geometry and maps", "Exports geometry, textures and lightmap properties to Bakery format. This is required, but if you already rendered the scene, and if no changes to meshes/maps/lightmap resolution took place, you may disable this checkbox to skip this step."));
                    yy += 20;
                }
                //ftBuildGraphics.unwrapUVs = GUI.Toggle(new Rect(xx, yy, 200, 20), ftBuildGraphics.unwrapUVs, new GUIContent("Adjust UV padding", "For meshes with 'Generate lightmap UVs' checkbox enabled, adjusts UVs further to have proper padding between UV islands for each mesh. Model-wide Pack Margin in importer settings is ignored."));
                //yy += 20;
                y -= 20;

                adjustSamples = GUI.Toggle(new Rect(xx, yy, 200, 20), adjustSamples, new GUIContent("Adjust sample positions", "Find the best sample positions to prevent lighting leaks."));
                yy += 20;
                unloadScenesInDeferredMode = GUI.Toggle(new Rect(xx, yy, 200, 20), unloadScenesInDeferredMode, new GUIContent("Unload scenes before render", "Unloads Unity scenes before baking to free up video memory."));
                yy += 20;
                if (settingsMode == SettingsMode.Experimental)
                {
                    forceRefresh = GUI.Toggle(new Rect(xx, yy, 200, 20), forceRefresh, new GUIContent("Update unmodified lights", "Update lights that didn't change since last rendering. You can disable this checkbox to skip these lights. Note that it only tracks changes to light objects. If scene geometry changed, then you still need to update all lights."));
                    yy += 20;
                    performRendering = GUI.Toggle(new Rect(xx, yy, 200, 20), performRendering, new GUIContent("Update modified lights and GI", "Update lights that did change since last rendering, plus GI."));
                    yy += 20;
                }
                denoise = GUI.Toggle(new Rect(xx, yy, 200, 20), denoise, new GUIContent("Denoise", "Apply denoising algorithm to lightmaps."));
                yy += 20;
                if (settingsMode == SettingsMode.Experimental && denoise)
                {
                    denoise2x = GUI.Toggle(new Rect(xx, yy, 200, 20), denoise2x, new GUIContent("Denoise: fix bright edges", "Sometimes the neural net used for denoising may produce bright edges around shadows, like if a sharpening effect was applied. If this option is enabled, Bakery will try to filter them away."));
                    yy += 20;
                    y += 20;
                }
                fixSeams = GUI.Toggle(new Rect(xx, yy, 200, 20), fixSeams, new GUIContent("Fix UV seams", "If enabled, will attempt to blend seams on lightmaps created by UV discontinuities. Useful for smooth geometry, including Unity's default sphere."));
                //GUI.EndGroup();
                y += (settingsMode == SettingsMode.Experimental ? (135 + 5) : (135 + 30) - 80);
                y += 20;
            }
        }

        GUI.BeginGroup(new Rect(10, y, 300, 450), "Auto-atlasing", headerStyle);

        int ay = 20;

        if (settingsMode >= SettingsMode.Advanced)
        {
            ftBuildGraphics.splitByTag = GUI.Toggle(new Rect(10, ay, 200, 20), ftBuildGraphics.splitByTag, new GUIContent("Split by baked tag", "Respect 'Baked Tag' in Lightmap Parameters assigned to each mesh renderer. Objects with different tags will always use separate atlases."));
            ay += 20;
            y += 20;
            ftBuildGraphics.splitByScene = GUI.Toggle(new Rect(10, ay, 200, 20), ftBuildGraphics.splitByScene, new GUIContent("Split by scene", "Bake separate lightmap atlases for every scene. Useful to limit the amount of textures loaded when scenes are streamed."));
            ay += 20;
            y += 20;
            if (settingsMode >= SettingsMode.Experimental)
            {
                if (ftBuildGraphics.atlasPacker == ftGlobalStorage.AtlasPacker.xatlas)
                {
                    ftBuildGraphics.postPacking = GUI.Toggle(new Rect(10, ay, 200, 20), ftBuildGraphics.postPacking, new GUIContent("Post-packing", "Try to minimize final atlas count by combining different LODs, terrains and regular meshes in one texture."));
                    ay += 20;
                    y += 20;
                }
            }

            if (settingsMode >= SettingsMode.Advanced)
            {
                if (ftBuildGraphics.atlasPacker == ftGlobalStorage.AtlasPacker.xatlas)
                {
                    ftBuildGraphics.holeFilling = GUI.Toggle(new Rect(10, ay, 200, 20), ftBuildGraphics.holeFilling, new GUIContent("Hole filling", "Fill holes while packing UV layouts to optimize atlas usage. If disabled, layouts are packed as bounding rectangles."));
                    ay += 20;
                    y += 20;
                }
            }

            if (settingsMode >= SettingsMode.Experimental)
            {
                if (ftBuildGraphics.unwrapUVs)
                {
                    ftBuildGraphics.uvPaddingMax = GUI.Toggle(new Rect(10, ay, 200, 20), ftBuildGraphics.uvPaddingMax, new GUIContent("UV padding: increase only", "When finding optimal UV padding for given resolution, the value will never get smaller comparing to previously baked scenes. This is useful when the same model is used across multiple scenes with different lightmap resolution."));
                    ay += 20;
                    y += 20;
                }
            }
        }

        GUI.Label(new Rect(10, ay, 100, 15), new GUIContent("Texels per unit:", "Approximate amount of lightmap texels per unit allocated for lightmapped objects (without Bakery LMGroup component). Affects the amount and resolution of generated lightmaps.\n\nExample values:\n- Large outdoor area (e.g. a city): 1-5\n- Medium outdoor area (e.g. a few alleys): 10-20\n- High quality interior: 100"));
        texelsPerUnit = EditorGUI.FloatField(new Rect(110, ay, 110, 15), texelsPerUnit, numberBoxStyle);
        ftBuildGraphics.texelsPerUnit = texelsPerUnit;
        ay += 20;

        GUI.Label(new Rect(10, ay, 100, 15), new GUIContent("Max resolution:"));
        ay += 20;
        GUI.Label(new Rect(10, ay, 100, 15), ""+ftBuildGraphics.maxAutoResolution);
        ftBuildGraphics.maxAutoResolution = 1 << (int)GUI.HorizontalSlider(new Rect(50, ay, 170, 15), Mathf.Ceil(Mathf.Log(ftBuildGraphics.maxAutoResolution)/Mathf.Log(2)), 8, 12);
        ay += 20;

        if (settingsMode >= SettingsMode.Advanced)
        {
            GUI.Label(new Rect(10, ay, 100, 15), new GUIContent("Min resolution:"));
            ay += 20;
            GUI.Label(new Rect(10, ay, 100, 15), ""+ftBuildGraphics.minAutoResolution);
            ftBuildGraphics.minAutoResolution = 1 << (int)GUI.HorizontalSlider(new Rect(50, ay, 170, 15), Mathf.Log(ftBuildGraphics.minAutoResolution)/Mathf.Log(2), 4, 12);
            y += 40;
            ay += 20;
        }

        if (settingsMode >= SettingsMode.Advanced)
        {
            ftBuildGraphics.texelsPerUnitPerMap = EditorGUI.Foldout(new Rect(0, ay, 230, 20), ftBuildGraphics.texelsPerUnitPerMap, "Scale per map type", foldoutStyle);
            ay += 20;
            if (ftBuildGraphics.texelsPerUnitPerMap)
            {
                GUI.Label(new Rect(10, ay, 150, 20), new GUIContent("Main lightmap scale:"));
                ay += 20;
                float actualDiv = 1 << (int)((1.0f - ftBuildGraphics.mainLightmapScale) * 6);
                GUI.Label(new Rect(10, ay, 85, 15), "1/"+ actualDiv);
                ftBuildGraphics.mainLightmapScale = GUI.HorizontalSlider(new Rect(50, ay, 170, 15), ftBuildGraphics.mainLightmapScale, 0, 1);
                ay += 20;

                GUI.Label(new Rect(10, ay, 150, 20), new GUIContent("Shadowmask scale:"));
                ay += 20;
                actualDiv = 1 << (int)((1.0f - ftBuildGraphics.maskLightmapScale) * 6);
                GUI.Label(new Rect(10, ay, 85, 15), "1/"+ actualDiv);
                ftBuildGraphics.maskLightmapScale = GUI.HorizontalSlider(new Rect(50, ay, 170, 15), ftBuildGraphics.maskLightmapScale, 0, 1);
                ay += 20;

                GUI.Label(new Rect(10, ay, 150, 20), new GUIContent("Direction scale:"));
                ay += 20;
                actualDiv = 1 << (int)((1.0f - ftBuildGraphics.dirLightmapScale) * 6);
                GUI.Label(new Rect(10, ay, 85, 15), "1/"+ actualDiv);
                ftBuildGraphics.dirLightmapScale = GUI.HorizontalSlider(new Rect(50, ay, 170, 15), ftBuildGraphics.dirLightmapScale, 0, 1);
                ay += 20;

                y += 120;
            }
            y += 20;

            showCheckerSettings = EditorGUI.Foldout(new Rect(0, ay, 230, 20), showCheckerSettings, "Checker preview", foldoutStyle);
            ay += 20;
            if (showCheckerSettings)
            {
                var prevValue = ftSceneView.enabled;
                showChecker = GUI.Toggle(new Rect(10, ay, 230, 20), ftSceneView.enabled, new GUIContent("Show checker", "Renders a checkerboard pattern on top of visible objects to demonstrate lightmap texel size in the Scene view. Useful for making sure that you are using adequate values for 'Texels per unit' and other resolution-affecting settings before you bake.\n\nNote: Does not currently show correct texel sizes for Terrains."));
                if (showChecker != prevValue)
                {
                    ftSceneView.ToggleChecker();
                    if (ftAtlasPreview.instance != null) ftAtlasPreview.instance.OnGUI();
                }
                ay += 20;
                y += 20;
                if (showChecker)
                {
                    if (GUI.Button(new Rect(10, ay, 220/2, 20), "Refresh checker"))
                    {
                        ftSceneView.RefreshChecker();
                        if (ftAtlasPreview.instance != null)
                        {
                            ftAtlasPreview.instance.update = true;
                            ftAtlasPreview.instance.OnGUI();
                            ftAtlasPreview.instance.Repaint();
                        }
                    }
                    //ay += 20;
                    //y += 20;
                    if (GUI.Button(new Rect(10+220/2, ay, 220/2, 20), "Atlas preview"))
                    {
                        if (ftAtlasPreview.instance == null)
                        {
                            GetWindow<ftAtlasPreview>();
                        }
                        else
                        {
                            ftAtlasPreview.instance.Close();
                        }
                    }
                    ay += 20;
                    y += 20;
                }
            }
            y += 20;
        }

        GUI.EndGroup();
        y += 45 + 40;

        if (userRenderMode != RenderMode.AmbientOcclusionOnly)
        {
            y += 5;
            GUI.BeginGroup(new Rect(10, y, 300, 300), "Global Illumination", headerStyle);

            GUI.Label(new Rect(10, 20, 70, 15), new GUIContent("Bounces:", "How many times light ray bounces off surfaces. Lower values are faster to render, while higher values ensure light reaches highly occluded places like interiors, caves, etc."));
            var textBounces = GUI.TextField(new Rect(70, 20, 25, 15), "" + bounces, textBoxStyle);
            textBounces = Regex.Replace(textBounces, "[^0-9]", "");
            System.Int32.TryParse(textBounces, out bounces);
            bounces = (int)GUI.HorizontalSlider(new Rect(100, 20, 120, 15), bounces, 0, 5);

            GUI.Label(new Rect(10, 20+20, 70, 15), new GUIContent("Samples:", "Quality of GI. More samples produce cleaner lighting with less noise."));
            var textGISamples = GUI.TextField(new Rect(70, 20+20, 25, 15), "" + giSamples, textBoxStyle);
            textGISamples = Regex.Replace(textGISamples, "[^0-9]", "");
            System.Int32.TryParse(textGISamples, out giSamples);
            giSamples = (int)GUI.HorizontalSlider(new Rect(100, 20+20, 120, 15), giSamples, 1, 64);
        }
        else
        {
            GUI.BeginGroup(new Rect(10, y-60, 300, 300), "", headerStyle);
        }

        GUI.EndGroup();
        if (userRenderMode != RenderMode.AmbientOcclusionOnly) y += 60;

        if (settingsMode == SettingsMode.Simple && userRenderMode == RenderMode.AmbientOcclusionOnly)
        {
            showAOSettings = true;
            showAOSettings = EditorGUI.Foldout(new Rect(10, y, 300, 20), showAOSettings, "Ambient occlusion");
            if (showAOSettings)
            {
                int xx = 15;
                int yy = y + 10;
                int ww = 110;

                GUI.Label(new Rect(10+xx, 15+yy, 100, 15), new GUIContent("Intensity:", "AO visibility. Disabled if set to 0."));
                hackAOIntensity = EditorGUI.FloatField(new Rect(95+xx, 15+yy, ww, 15), hackAOIntensity, numberBoxStyle);

                GUI.Label(new Rect(10+xx, 30+yy, 100, 15), new GUIContent("Radius:", "AO radius."));
                hackAORadius = EditorGUI.FloatField(new Rect(95+xx, 30+yy, ww, 15), hackAORadius, numberBoxStyle);

                GUI.Label(new Rect(10+xx, 45+yy, 100, 15), new GUIContent("Samples:", "Affects the quality of AO."));
                hackAOSamples = EditorGUI.IntField(new Rect(95+xx, 45+yy, ww, 15), hackAOSamples, numberBoxStyle);

                y += 60;
            }
            y += 20;
        }
        else if (settingsMode >= SettingsMode.Advanced)
        {
            //showHacks = EditorGUI.Foldout(new Rect(10, y, 300, 300), showHacks, "Hacks");
            //y += 20;
            //if (showHacks)
            {
                GUI.BeginGroup(new Rect(10, y, 300, 300), "Hacks", headerStyle);

                int yy = 20;
                GUI.Label(new Rect(10, yy, 100, 15), new GUIContent("Emissive boost:", "Multiplies light from emissive surfaces."));
                hackEmissiveBoost = EditorGUI.FloatField(new Rect(110, yy, 110, 15), hackEmissiveBoost, numberBoxStyle);
                yy += 20;

                GUI.Label(new Rect(10, yy, 100, 15), new GUIContent("Indirect boost:", "Multiplies indirect intensity for all lights."));
                hackIndirectBoost = EditorGUI.FloatField(new Rect(110, yy, 110, 15), hackIndirectBoost, numberBoxStyle);
                yy += 20;

                GUI.Label(new Rect(10, yy, 120, 20), new GUIContent("Backface GI:", "How much light is emitted via back faces from 0 (black) to 1 (equals to front face)."));
                giBackFaceWeight = EditorGUI.FloatField(new Rect(110, yy, 110, 15), giBackFaceWeight, numberBoxStyle);
                yy += 20;

                showAOSettings = EditorGUI.Foldout(new Rect(10, yy, 300, 20), showAOSettings, "Ambient occlusion");
                yy += 20;
                y += 15+40;
                if (showAOSettings)
                {
                    int xx = 15;
                    yy = 45+40;
                    int ww = 110;

                    GUI.Label(new Rect(10+xx, 15+yy, 100, 15), new GUIContent("Intensity:", "AO visibility. Disabled if set to 0."));
                    hackAOIntensity = EditorGUI.FloatField(new Rect(95+xx, 15+yy, ww, 15), hackAOIntensity, numberBoxStyle);

                    GUI.Label(new Rect(10+xx, 30+yy, 100, 15), new GUIContent("Radius:", "AO radius."));
                    hackAORadius = EditorGUI.FloatField(new Rect(95+xx, 30+yy, ww, 15), hackAORadius, numberBoxStyle);

                    GUI.Label(new Rect(10+xx, 45+yy, 100, 15), new GUIContent("Samples:", "Affects the quality of AO."));
                    hackAOSamples = EditorGUI.IntField(new Rect(95+xx, 45+yy, ww, 15), hackAOSamples, numberBoxStyle);

                    y += 50;
                }

                GUI.EndGroup();
                y += 50;
            }

            showPerf = EditorGUI.Foldout(new Rect(10, y, 300, 20), showPerf, "Performance", foldoutStyle);
            y += 20;
            if (showPerf)
            {
                int xx = 10;

                var prev = rtxMode;
                rtxMode =
                    GUI.Toggle(new Rect(xx, y, 200, 20), rtxMode,
                        new GUIContent(" RTX mode", "Enables RTX hardware acceleration. Requires supported hardware.\n\nNote:\n- Minimum supported driver version is 418.\n- Drivers can emulate RTX mode on most non-RTX cards, but the result will be slower.\n- RTX mode must be enabled on Ampere (3xxx) cards."));
                if (prev != rtxMode)
                {
                    ftraceExe = rtxMode ? ftraceExe6 : ftraceExe1;
                    if (rtxMode) ftBuildGraphics.exportTerrainAsHeightmap = false;
                }
                y += 20;

                ftBuildGraphics.exportTerrainTrees =
                    GUI.Toggle(new Rect(xx, y, 200, 20), ftBuildGraphics.exportTerrainTrees,
                        new GUIContent(" Export terrain trees", "If enabled, painted terrain trees will affect lighting. Trees themselves will not be baked.\n\nNote that the highest possible LOD level is used for every tree during baking. It is not recommended to use this option for rendering multi-kilometer forests with highly detailed models."));
                y += 20;

                prev = ftBuildGraphics.exportTerrainAsHeightmap;
                //if (settingsMode >= SettingsMode.Experimental)
                //{
                    ftBuildGraphics.exportTerrainAsHeightmap =
                        GUI.Toggle(new Rect(xx, y, 200, 20), ftBuildGraphics.exportTerrainAsHeightmap,
                            new GUIContent(" Terrain optimization", "If enabled, terrains use a separate ray tracing technique to take advantage of their heightfield geometry. If disabled, they are treated like any other mesh.\n\nNote: This is currently incompatible with painted terrain holes. Disable it to make them work."));
                    if (prev != ftBuildGraphics.exportTerrainAsHeightmap)
                    {
                        if (ftBuildGraphics.exportTerrainAsHeightmap)
                        {
                            rtxMode = false;
                            ftraceExe = ftraceExe1;
                        }
                    }
                    y += 20;
                //}

                if (settingsMode >= SettingsMode.Experimental)
                {
                    GUI.BeginGroup(new Rect(xx, y, 300, 300), "Light Mesh batch limit", headerStyle);
                    GUI.Label(new Rect(10, 20, 70, 15), new GUIContent("" + batchAreaLightSampleLimit, "If this value is above 0, combines many Light Meshes into one, given they have identical settings and affect the same LMGroups, but limiting their total sample count to this value (I.e. if the limit is 64, it can combine 2 lights with samples=32 or 4 lights with samples=16, etc). This will increase performance in scenes with many Light Meshes. Be careful setting this value too high, as the GPU may hit the OS driver timeout while processing too many samples at once."));
                    batchAreaLightSampleLimit = 1 << (int)GUI.HorizontalSlider(new Rect(50, 20, 170, 15), Mathf.Max(Mathf.Log(batchAreaLightSampleLimit)/Mathf.Log(2),7.0f), 7, 14);
                    if (batchAreaLightSampleLimit <= 128) batchAreaLightSampleLimit = 0;
                    GUI.EndGroup();

                    y += 40;

#if UNITY_2020_1_OR_NEWER
                    compressVolumes =
                        GUI.Toggle(new Rect(xx, y, 200, 20), compressVolumes,
                            new GUIContent(" Compress volumes", "Apply texture compression to volume 3D textures and switch Bakery shaders to a corresponding sampling mode. Not recommended for very low resolution volumes. Volume size may be increased to be a multiple of 4."));
#else
                    GUI.enabled = false;
                    compressVolumes =
                        GUI.Toggle(new Rect(xx, y, 200, 20), compressVolumes,
                            new GUIContent(" Compress volumes", "(Requires Unity 2020.1 or newer) Apply texture compression to volume 3D textures and switch Bakery shaders to a corresponding sampling mode. Not recommended for very low resolution volumes. Volume size may be increased to be a multiple of 4."));
                    GUI.enabled = true;
#endif
                    y += 20;
                }

                GUI.Label(new Rect(10, y, 150, 20), new GUIContent("Samples multiplier", "Multiplies all shadow and GI samples by the specified factor. Use this to quickly change between draft and final quality."));
                y += 20;
                GUI.Label(new Rect(10, y, 85, 15), "1/"+ sampleDivisor);
                const int maxSampleDivisor = 8;
                sampleDivisor = (int)GUI.HorizontalSlider(new Rect(50, y, 170, 15), (float)(maxSampleDivisor - (sampleDivisor-1)), 1, maxSampleDivisor);
                sampleDivisor = maxSampleDivisor - (sampleDivisor-1);
                y += 20;

                /*GUI.BeginGroup(new Rect(xx, y, 300, 120), "GI VRAM optimization", headerStyle);
                y += 20;
                GUI.EndGroup();
                giLodMode = (GILODMode)EditorGUI.EnumPopup(new Rect(xx, y, 225, 25), giLodMode);
                y += 20;*/

                GUI.BeginGroup(new Rect(xx, y, 300, 300), "Tile size", headerStyle);
                GUI.Label(new Rect(10, 20, 70, 15), new GUIContent("" + tileSize, "Lightmaps are split into smaller tiles and each tile is processed by the GPU without interruputions. Changing the tile size therefore balances between system responsiveness and baking speed. Because the GPU is shared by all running processes, baking with a big tile size can make everything slow, but also gets the job done faster."));
                tileSize = 1 << (int)GUI.HorizontalSlider(new Rect(50, 20, 170, 15), Mathf.Log(tileSize)/Mathf.Log(2), 5, 12);
                GUI.EndGroup();
                y += 45;
            }
        }


        if (settingsMode >= SettingsMode.Advanced)
        {

        }
        else
        {
            GUI.BeginGroup(new Rect(10, y, 300, 300), "GPU priority", headerStyle);
            string priorityName = "";
            if (tileSize > 512)
            {
                if ((int)priority!=3) priority = 3; // >= 1024 very high
                priorityName = "Very high";
            }
            else if (tileSize > 256)
            {
                if ((int)priority!=2) priority = 2; // >= 512 high
                priorityName = "High";
            }
            else if (tileSize > 64)
            {
                if ((int)priority!=1) priority = 1; // >= 128 low
                priorityName = "Low";
            }
            else
            {
                if ((int)priority!=0) priority = 0; // == 32 very low
                priorityName = "Very low";
            }
            GUI.Label(new Rect(10, 20, 75, 20), new GUIContent("" + priorityName, "Balance between system responsiveness and baking speed. Because the GPU is shared by all running processes, baking on high priority can make everything slow, but also gets the job done faster."));
            priority = GUI.HorizontalSlider(new Rect(80, 20, 140, 15), priority, 0, 3);
            if ((int)priority == 0)
            {
                tileSize = 32;
            }
            else if ((int)priority == 1)
            {
                tileSize = 128;
            }
            else if ((int)priority == 2)
            {
                tileSize = 512;
            }
            else
            {
                tileSize = 1024;
            }
            GUI.EndGroup();
            y += 50;
        }

        if (scenePath == "") scenePath = System.Environment.GetEnvironmentVariable("TEMP", System.EnvironmentVariableTarget.Process) + "\\frender";
        if (settingsMode >= SettingsMode.Advanced)
        {
            showPaths = EditorGUI.Foldout(new Rect(10, y, 230, 20), showPaths, "Output options", foldoutStyle);
            y += 20;

            if (showPaths)
            {
                if (GUI.Button(new Rect(10, y, 230, 40), new GUIContent("Temp path:\n" + scenePath, "Specify a folder where temporary data will be stored. Using a SSD can speed up rendering a bit comparing to HDD.")))
                {
                    scenePath = EditorUtility.OpenFolderPanel("Select temp folder", scenePath, "frender");
                }
                y += 50;

                useScenePath = EditorGUI.ToggleLeft( new Rect( 10, y, 230, 20 ), new GUIContent( "Use scene named output path", "Create the lightmaps in a subfolder named the same as the scene" ), useScenePath );
                y += 25;
                if ( !useScenePath ) {
                    GUI.Label(new Rect(10, y, 100, 16), new GUIContent("Output path:", "Specify a folder where lightmaps data will be stored (relative to Assets)."));
                    outputPath = EditorGUI.TextField(new Rect(85, y, 155, 18), outputPath, textBoxStyle);
                    y += 25;
                } else {
                    // AMW - don't override the outputPath if we currently have the temp scene open.
                    // this seemed to happen during lightprobe bakes and the lightprobes would end up in the _tempScene path
                    string currentScenePath = EditorSceneManager.GetActiveScene().path;
                    if ( currentScenePath.ToLower().Contains( "_tempscene.unity" ) == false ) {
                        outputPath = currentScenePath;
                        if ( string.IsNullOrEmpty( outputPath ) ) {
                            outputPath = "BakeryLightmaps";
                        } else {
                            // strip "Assets/" and the file extension
                            if (outputPath.Length > 7 && outputPath.Substring(0,7).ToLower() == "assets/") outputPath = outputPath.Substring(7);
                            if (outputPath.Length > 6 && outputPath.Substring(outputPath.Length-6).ToLower() == ".unity")
                                                                                        outputPath = outputPath.Substring(0, outputPath.Length-6);
                        }
                    }
                }
            }
        }

        if (settingsMode >= SettingsMode.Experimental)
        {
            showNet = EditorGUI.Foldout(new Rect(10, y, 230, 20), showNet, "Network baking", foldoutStyle);
            y += 20;

            if (showNet)
            {
                clientMode = EditorGUI.ToggleLeft( new Rect( 10, y, 230, 20 ), new GUIContent( "Bake on remote server", "Enable network baking" ), clientMode );
                y += 20;
                if (clientMode)
                {
                    GUI.Label(new Rect(10, y, 100, 16), new GUIContent("IP address:", "Server address where ftServer.exe is launched."));
                    ftClient.serverAddress = EditorGUI.TextField(new Rect(85, y, 155, 18), ftClient.serverAddress, textBoxStyle);
                    y += 20;

                    if (ftClient.lastServerMsgIsError) ftClient.Disconnect();

                    if (!ftClient.connectedToServer)
                    {
                        if (GUI.Button(new Rect(10, y, 230, 30), "Connect to server"))
                        {
                            ftClient.ConnectToServer();
                        }
                    }
                    else
                    {
                        ftClient.Update();
                        if (GUI.Button(new Rect(10, y, ftClient.serverGetDataMode ? 230 : (230/2), 30), "Disconnect"))
                        {
                            ftClient.Disconnect();
                            ftClient.lastServerMsg = "Server: no data";
                            ftClient.lastServerMsgIsError = false;
                            ftClient.lastServerErrorCode = 0;
                        }
                        if (!ftClient.serverGetDataMode)
                        {
                            if (ftClient.serverMustRefreshData)
                            {
                                CollectStorages();
                                var groupList = new List<BakeryLightmapGroup>();
                                var groupListGIContributing = new List<BakeryLightmapGroup>();
                                CollectGroups(groupList, groupListGIContributing, false);
                                ftClient.serverMustRefreshData = false;
                                var apply = ApplyBakedData();
                                while(apply.MoveNext()) {}
                            }
                            if (GUI.Button(new Rect(230/2+10, y, 230/2, 30), "Get data"))
                            {
                                if (ftClient.lastServerScene.Length == 0)
                                {
                                    DebugLogError("No baked scene was found on the server.");
                                }
                                else if (ftClient.lastServerScene != EditorSceneManager.GetActiveScene().name)
                                {
                                    DebugLogError("Current active scene doesn't match the one on the server.");
                                }
                                else if (ftClient.serverGetDataMode)
                                {
                                    DebugLogInfo("Data is being downloaded");
                                }
                                else
                                {
                                    if (!ServerGetData())
                                    {
                                        DebugLogError("Failed to find the list of files to download.");
                                    }
                                }
                            }
                        }
                    }

                    y += 30;

                    var msg = ftClient.lastServerMsg;
                    if (ftClient.lastServerScene.Length > 0) msg += "\nScene: "+ftClient.lastServerScene;
                    if (ftClient.serverGetDataMode) msg += "\nDownloading: " + System.Math.Min(ftClient.serverGetFileIterator+1, ftClient.serverGetFileList.Count) + "/" + ftClient.serverGetFileList.Count;
                    EditorGUI.HelpBox(new Rect(15,y+5,220,40), msg, ftClient.lastServerMsgIsError ? MessageType.Error : MessageType.Info);
                    y += 40;
                }
                y += 10;
            }
        }

        ftBuildGraphics.scenePath = scenePath;
        scenePathQuoted = "\"" + scenePath + "\"";

        /*if (settingsMode >= SettingsMode.Advanced)
        {
            showCompression = EditorGUI.Foldout(new Rect(10, y, 230, 20), showCompression, "Compression", foldoutStyle);
            y += 20;
            if (showCompression)
            {
                int xx = 10;
                float prevWidth = EditorGUIUtility.labelWidth;
                EditorGUIUtility.labelWidth = 45f;
                lightmapCompressionColor = (TextureImporterFormat)EditorGUI.EnumPopup( new Rect( xx, y, 240-xx, 20 ), new GUIContent( "Color:", "Set the default compression for the lightmap textures" ), lightmapCompressionColor );
                y += 25;
                //EditorGUIUtility.labelWidth = 85f;
                lightmapCompressionMask = (TextureImporterFormat)EditorGUI.EnumPopup( new Rect( xx, y, 240-xx, 20 ), new GUIContent( "Mask:", "Set the default compression for the lightmap textures" ), lightmapCompressionMask );
                y += 25;
                //EditorGUIUtility.labelWidth = 65f;
                lightmapCompressionDir = (TextureImporterFormat)EditorGUI.EnumPopup( new Rect( xx, y, 240-xx, 20 ), new GUIContent( "Dir:", "Set the default compression for the lightmap textures" ), lightmapCompressionDir );
                EditorGUIUtility.labelWidth = prevWidth;
                y += 25;
            }
        }*/

        /*if (settingsMode == SettingsMode.Experimental)
        {
            GUI.BeginGroup(new Rect(10, y, 300, 300), "Output texture type", headerStyle);
            encodeMode = GUI.SelectionGrid(new Rect(10, 20, 210, 20), encodeMode,  selStrings, 2);
            GUI.EndGroup();
            y += 50;
        }*/
        ftBuildGraphics.overwriteExtensionCheck = ".hdr";//bc6h ? ".asset" : ".hdr";

        if (settingsMode >= SettingsMode.Advanced)
        {
            curSector = EditorGUI.ObjectField(new Rect(10, y, 230, 16), curSector, typeof(BakerySector), true) as BakerySector;
            y += 25;
        }


        if (GUI.Button(new Rect(10, y, 230, 30), "Render"))
        {
            RenderButton(!suppressPopups);
        }
        y += 35;

        if (settingsMode >= SettingsMode.Experimental)
        {
            if (GUI.Button(new Rect(10, y, 230, 30), "Render Selected Groups"))
            {
                if (!Application.isPlaying)
                {
                    ValidateOutputPath();
                    if (!TestSystemSpecs()) return;
                    selectedOnly = true;
                    probesOnlyL1 = false;
                    fullSectorRender = false;
                    hasAnyVolumes = true; // possibly - ftBuildGraphics will figure it out
                    hasAnyShadowmasks = false;
                    progressFunc = RenderLightmapFunc();
                    EditorApplication.update += RenderLightmapUpdate;
                    bakeInProgress = true;
                }
            }
            y += 35;
        }

        if (GUI.Button(new Rect(10, y, 230, 30), "Render Light Probes"))
        {
            RenderLightProbesButton();
        }
        y += 35;

        if (GUI.Button(new Rect(10, y, 230, 30), "Render Reflection Probes"))
        {
            RenderReflectionProbesButton();
        }
        y += 35;

        if (GUI.Button(new Rect(10, y, 230, 30), "Update Skybox Probe"))
        {
            if (!Application.isPlaying)
            {

                bool isHDRP = false;
#if UNITY_2019_1_OR_NEWER
                if (GraphicsSettings.defaultRenderPipeline != null)
                {
                     var srpType = GraphicsSettings.defaultRenderPipeline.GetType().ToString();
                     if (srpType.Contains("HDRenderPipelineAsset"))
                     {
                        isHDRP = true;
                     }
                }
#endif

                ValidateOutputPath();
                DynamicGI.UpdateEnvironment();

                var rgo = new GameObject();
                var r = rgo.AddComponent<ReflectionProbe>();
                r.resolution = 256;
                r.clearFlags = UnityEngine.Rendering.ReflectionProbeClearFlags.Skybox;
                if (isHDRP)
                {
                    // HDRP sky is on Default layer, so can't use the culling mask
                    // Just move the probe far away...
                    rgo.transform.position = new Vector3(-100000, 0, -100000);
                }
                else
                {
                    r.cullingMask = 0;
                }
                r.mode = UnityEngine.Rendering.ReflectionProbeMode.Custom;

                var assetName = GenerateLightingDataAssetName();
                var outName = "Assets/" + outputPath + "/" + assetName + "_sky.exr";
                if (File.Exists(outName)) ValidateFileAttribs(outName);
                Lightmapping.BakeReflectionProbe(r, outName);

                AssetDatabase.Refresh();
                RenderSettings.customReflection = AssetDatabase.LoadAssetAtPath(outName, typeof(Cubemap)) as Cubemap;
                RenderSettings.defaultReflectionMode = UnityEngine.Rendering.DefaultReflectionMode.Custom;
                DestroyImmediate(rgo);
            }
        }
        y += 30;

        if (settingsMode >= SettingsMode.Experimental)
        {
            //showTasks2 = EditorGUI.Foldout(new Rect(10, y-5, 300, 20), showTasks2, "Light probe tasks", foldoutStyle);
            //y += 20 - (showTasks2 ? 10 : 5);
            //if (showTasks2)
            {
                var prevValue = usesRealtimeGI;
                usesRealtimeGI = GUI.Toggle(new Rect(10, y+5, 230, 20), usesRealtimeGI, new GUIContent("Combine with Enlighten real-time GI", "When the 'Render' button is pressed, Enlighten real-time GI will be calculated first. Bakery will bake regular lightmaps afterwards. Both static and real-time GI will be combined."));
                if (prevValue != usesRealtimeGI)
                {
                    //Lightmapping.realtimeGI = usesRealtimeGI;
                }
                y += 20;
            }
        }

        //if (settingsMode >= SettingsMode.Advanced)
        {
            useUnityForOcclsusionProbes = GUI.Toggle(new Rect(10, y+5, 230, 20), useUnityForOcclsusionProbes, new GUIContent("Occlusion probes", "When the 'Render Light Probes' button is pressed, lets Unity bake occlusion probes using its own (currently selected) built-in lightmapper. Occlusion probes prevent dynamic objects from getting lit in shadowed areas. There is currently no way to use custom occlusion probes in Unity, so it has to call its own lightmappers to do the job."));
            y += 25;
        }

        if (settingsMode >= SettingsMode.Advanced)
        {
            beepOnFinish = GUI.Toggle(new Rect(10, y, 230, 20), beepOnFinish, new GUIContent("Beep on finish", "Play a sound when the bake has finished."));
            y += 25;
        }

        showTasks2 = EditorGUI.Foldout(new Rect(10, y, 300, 20), showTasks2, "Warnings", foldoutStyle);
        y += 12+2;
        if (showTasks2)
        {
            suppressPopups = GUI.Toggle(new Rect(10, y, 200, 20), suppressPopups, new GUIContent("Suppress all popups", "Don't show any dialog boxes after pressing Render."));
            if (suppressPopups) GUI.enabled = false;
            y += 15;
            checkOverlaps = GUI.Toggle(new Rect(10, y, 200, 20), checkOverlaps, new GUIContent("UV validation", "Checks for any incorrect, missing or overlapping UVs."));
            y += 15;
            ftBuildGraphics.memoryWarning = GUI.Toggle(new Rect(10, y, 200, 20), ftBuildGraphics.memoryWarning, new GUIContent("Video memory check", "Calculates the approximate amount of required video memory (VRAM) and asks to continue."));
            y += 15;
            ftBuildGraphics.overwriteWarning = GUI.Toggle(new Rect(10, y, 200, 20), ftBuildGraphics.overwriteWarning, new GUIContent("Overwrite check", "Checks and asks if any existing lightmaps are going to be overwritten."));
            y += 15;
            samplesWarning = GUI.Toggle(new Rect(10, y, 200, 20), samplesWarning, new GUIContent("Sample count check", "Checks if the sample values for lights/GI/AO are within a reasonable range."));
            y += 15;
            prefabWarning = GUI.Toggle(new Rect(10, y, 200, 20), prefabWarning, new GUIContent("Lightmapped prefab validation", "Checks if any prefabs are going to be overwritten and if there is anything preventing from baking them."));
            if (suppressPopups) GUI.enabled = true;
        }

        if (settingsMode >= SettingsMode.Advanced || simpleWindowIsTooSmall)
        {
            GUI.EndScrollView();
        }

        if (ftLightmaps.mustReloadRenderSettings)
        {
            ftLightmaps.mustReloadRenderSettings = false;
            OnEnable();
            if (showChecker)
            {
                ftSceneView.ToggleChecker();
            }
        }

        SaveRenderSettings();
    }

    public void SaveRenderSettings()
    {
        var scenePathToSave = scenePath;
        if (scenePathToSave == System.Environment.GetEnvironmentVariable("TEMP", System.EnvironmentVariableTarget.Process) + "\\frender")
        {
            scenePathToSave = "";
        }

        if (renderSettingsStorage == null)
        {
            renderSettingsStorage = FindRenderSettingsStorage();
            if (renderSettingsStorage == null) return;
        }

        FindGlobalStorage();
        if (gstorage != null)
        {
            if (gstorage.renderSettingsTempPath != scenePathToSave)
            {
                gstorage.renderSettingsTempPath = scenePathToSave;
                EditorUtility.SetDirty(gstorage);
            }
        }

        if (
            renderSettingsStorage.renderSettingsBounces != bounces ||
            renderSettingsStorage.renderSettingsGISamples != giSamples ||
            renderSettingsStorage.renderSettingsGIBackFaceWeight != giBackFaceWeight ||
            renderSettingsStorage.renderSettingsTileSize != tileSize ||
            renderSettingsStorage.renderSettingsPriority != priority ||
            renderSettingsStorage.renderSettingsTexelsPerUnit != texelsPerUnit ||
            renderSettingsStorage.renderSettingsForceRefresh != forceRefresh ||
            renderSettingsStorage.renderSettingsForceRebuildGeometry != forceRebuildGeometry ||
            renderSettingsStorage.renderSettingsPerformRendering != performRendering ||
            renderSettingsStorage.renderSettingsUserRenderMode != (int)userRenderMode ||
            renderSettingsStorage.renderSettingsSettingsMode != (int)settingsMode ||
            renderSettingsStorage.renderSettingsFixSeams != fixSeams ||
            renderSettingsStorage.renderSettingsDenoise != denoise ||
            renderSettingsStorage.renderSettingsDenoise2x != denoise2x ||
            renderSettingsStorage.renderSettingsEncode != encode ||
            renderSettingsStorage.renderSettingsEncodeMode != encodeMode ||
            renderSettingsStorage.renderSettingsOverwriteWarning != ftBuildGraphics.overwriteWarning ||
            renderSettingsStorage.renderSettingsAutoAtlas != ftBuildGraphics.autoAtlas ||
            renderSettingsStorage.renderSettingsUnwrapUVs != ftBuildGraphics.unwrapUVs ||
            renderSettingsStorage.renderSettingsForceDisableUnwrapUVs != ftBuildGraphics.forceDisableUnwrapUVs ||
            renderSettingsStorage.renderSettingsMaxAutoResolution != ftBuildGraphics.maxAutoResolution ||
            renderSettingsStorage.renderSettingsMinAutoResolution != ftBuildGraphics.minAutoResolution ||
            renderSettingsStorage.renderSettingsUnloadScenes != unloadScenesInDeferredMode ||
            renderSettingsStorage.renderSettingsAdjustSamples != adjustSamples ||
            renderSettingsStorage.renderSettingsGILODMode != (int)giLodMode ||
            renderSettingsStorage.renderSettingsGILODModeEnabled != giLodModeEnabled ||
            renderSettingsStorage.renderSettingsCheckOverlaps != checkOverlaps ||
            renderSettingsStorage.renderSettingsOutPath != outputPath ||
            renderSettingsStorage.renderSettingsUseScenePath != useScenePath ||
            //renderSettingsStorage.renderSettingsTempPath != scenePathToSave ||
            renderSettingsStorage.renderSettingsHackEmissiveBoost != hackEmissiveBoost ||
            renderSettingsStorage.renderSettingsHackIndirectBoost != hackIndirectBoost ||
            renderSettingsStorage.renderSettingsHackAOIntensity != hackAOIntensity ||
            renderSettingsStorage.renderSettingsHackAORadius != hackAORadius ||
            renderSettingsStorage.renderSettingsHackAOSamples != hackAOSamples ||
            renderSettingsStorage.renderSettingsShowAOSettings != showAOSettings ||
            renderSettingsStorage.renderSettingsShowTasks != showTasks ||
            renderSettingsStorage.renderSettingsShowTasks2 != showTasks2 ||
            renderSettingsStorage.renderSettingsShowPaths != showPaths ||
            renderSettingsStorage.renderSettingsShowNet != showNet ||
            renderSettingsStorage.renderSettingsShowPerf != showPerf ||
            //renderSettingsStorage.renderSettingsShowCompression != showCompression ||
            renderSettingsStorage.renderSettingsTexelsPerMap != ftBuildGraphics.texelsPerUnitPerMap ||
            renderSettingsStorage.renderSettingsTexelsColor != ftBuildGraphics.mainLightmapScale ||
            renderSettingsStorage.renderSettingsTexelsMask != ftBuildGraphics.maskLightmapScale ||
            renderSettingsStorage.renderSettingsTexelsDir != ftBuildGraphics.dirLightmapScale ||
            renderSettingsStorage.renderSettingsOcclusionProbes != useUnityForOcclsusionProbes ||
            renderSettingsStorage.renderSettingsBeepOnFinish != beepOnFinish ||
            renderSettingsStorage.renderSettingsDistanceShadowmask != isDistanceShadowmask ||
            renderSettingsStorage.renderSettingsShowDirWarning != showDirWarning ||
            renderSettingsStorage.renderSettingsRenderDirMode != (int)renderDirMode ||
            renderSettingsStorage.renderSettingsShowCheckerSettings != showCheckerSettings ||
            renderSettingsStorage.usesRealtimeGI != usesRealtimeGI ||
            renderSettingsStorage.renderSettingsSamplesWarning != samplesWarning ||
            renderSettingsStorage.renderSettingsSuppressPopups != suppressPopups ||
            renderSettingsStorage.renderSettingsPrefabWarning != prefabWarning ||
            renderSettingsStorage.renderSettingsSplitByScene != ftBuildGraphics.splitByScene ||
            renderSettingsStorage.renderSettingsSplitByTag != ftBuildGraphics.splitByTag ||
            renderSettingsStorage.renderSettingsExportTerrainAsHeightmap != ftBuildGraphics.exportTerrainAsHeightmap ||
            renderSettingsStorage.renderSettingsExportTerrainTrees != ftBuildGraphics.exportTerrainTrees ||
            renderSettingsStorage.renderSettingsRTXMode != rtxMode ||
            renderSettingsStorage.renderSettingsLightProbeMode != (int)lightProbeMode ||
            renderSettingsStorage.renderSettingsClientMode != clientMode ||
            renderSettingsStorage.renderSettingsServerAddress != ftClient.serverAddress ||
            renderSettingsStorage.renderSettingsUVPaddingMax != ftBuildGraphics.uvPaddingMax ||
            renderSettingsStorage.renderSettingsPostPacking != ftBuildGraphics.postPacking ||
            renderSettingsStorage.renderSettingsHoleFilling != ftBuildGraphics.holeFilling ||
            renderSettingsStorage.renderSettingsSampleDiv != sampleDivisor ||
            renderSettingsStorage.renderSettingsUnwrapper != (int)unwrapper ||
            renderSettingsStorage.renderSettingsDenoiserType != (int)denoiserType ||
            //renderSettingsStorage.renderSettingsLegacyDenoiser != legacyDenoiser ||
            renderSettingsStorage.renderSettingsAtlasPacker != ftBuildGraphics.atlasPacker ||
            renderSettingsStorage.renderSettingsCompressVolumes != compressVolumes ||
            renderSettingsStorage.renderSettingsBatchAreaLightSampleLimit != batchAreaLightSampleLimit ||
            renderSettingsStorage.renderSettingsSector != curSector
            )
        {
            Undo.RecordObject(renderSettingsStorage, "Change Bakery settings");
            renderSettingsStorage.renderSettingsBounces = bounces;
            renderSettingsStorage.renderSettingsGISamples = giSamples;
            renderSettingsStorage.renderSettingsGIBackFaceWeight = giBackFaceWeight;
            renderSettingsStorage.renderSettingsTileSize = tileSize;
            renderSettingsStorage.renderSettingsPriority = priority;
            renderSettingsStorage.renderSettingsTexelsPerUnit = texelsPerUnit;
            renderSettingsStorage.renderSettingsForceRefresh = forceRefresh;
            renderSettingsStorage.renderSettingsForceRebuildGeometry = forceRebuildGeometry;
            renderSettingsStorage.renderSettingsPerformRendering = performRendering;
            renderSettingsStorage.renderSettingsUserRenderMode = (int)userRenderMode;
            renderSettingsStorage.renderSettingsSettingsMode = (int)settingsMode;
            renderSettingsStorage.renderSettingsFixSeams = fixSeams;
            renderSettingsStorage.renderSettingsDenoise = denoise;
            renderSettingsStorage.renderSettingsDenoise2x = denoise2x;
            renderSettingsStorage.renderSettingsEncode = encode;
            renderSettingsStorage.renderSettingsEncodeMode = encodeMode;
            renderSettingsStorage.renderSettingsOverwriteWarning = ftBuildGraphics.overwriteWarning;
            renderSettingsStorage.renderSettingsAutoAtlas = ftBuildGraphics.autoAtlas;
            renderSettingsStorage.renderSettingsUnwrapUVs = ftBuildGraphics.unwrapUVs;
            renderSettingsStorage.renderSettingsForceDisableUnwrapUVs = ftBuildGraphics.forceDisableUnwrapUVs;
            renderSettingsStorage.renderSettingsMaxAutoResolution = ftBuildGraphics.maxAutoResolution;
            renderSettingsStorage.renderSettingsMinAutoResolution = ftBuildGraphics.minAutoResolution;
            renderSettingsStorage.renderSettingsUnloadScenes = unloadScenesInDeferredMode;
            renderSettingsStorage.renderSettingsAdjustSamples = adjustSamples;
            renderSettingsStorage.renderSettingsGILODMode = (int)giLodMode;
            renderSettingsStorage.renderSettingsGILODModeEnabled = giLodModeEnabled;
            renderSettingsStorage.renderSettingsCheckOverlaps = checkOverlaps;
            renderSettingsStorage.renderSettingsOutPath = outputPath;
            renderSettingsStorage.renderSettingsUseScenePath = useScenePath;
            //renderSettingsStorage.renderSettingsTempPath = scenePathToSave;
            renderSettingsStorage.renderSettingsHackEmissiveBoost = hackEmissiveBoost;
            renderSettingsStorage.renderSettingsHackIndirectBoost = hackIndirectBoost;
            renderSettingsStorage.renderSettingsHackAOIntensity = hackAOIntensity;
            renderSettingsStorage.renderSettingsHackAORadius = hackAORadius;
            renderSettingsStorage.renderSettingsHackAOSamples = hackAOSamples;
            renderSettingsStorage.renderSettingsShowAOSettings = showAOSettings;
            renderSettingsStorage.renderSettingsShowTasks = showTasks;
            renderSettingsStorage.renderSettingsShowTasks2 = showTasks2;
            renderSettingsStorage.renderSettingsShowPaths = showPaths;
            renderSettingsStorage.renderSettingsShowNet = showNet;
            renderSettingsStorage.renderSettingsShowPerf = showPerf;
            //renderSettingsStorage.renderSettingsShowCompression = showCompression;
            renderSettingsStorage.renderSettingsTexelsPerMap = ftBuildGraphics.texelsPerUnitPerMap;
            renderSettingsStorage.renderSettingsTexelsColor = ftBuildGraphics.mainLightmapScale;
            renderSettingsStorage.renderSettingsTexelsMask = ftBuildGraphics.maskLightmapScale;
            renderSettingsStorage.renderSettingsTexelsDir = ftBuildGraphics.dirLightmapScale;
            renderSettingsStorage.renderSettingsOcclusionProbes = useUnityForOcclsusionProbes;
            renderSettingsStorage.renderSettingsBeepOnFinish = beepOnFinish;
            renderSettingsStorage.renderSettingsDistanceShadowmask = isDistanceShadowmask;
            renderSettingsStorage.renderSettingsShowDirWarning = showDirWarning;
            renderSettingsStorage.renderSettingsRenderDirMode = (int)renderDirMode;
            renderSettingsStorage.renderSettingsShowCheckerSettings = showCheckerSettings;
            renderSettingsStorage.usesRealtimeGI = usesRealtimeGI;
            renderSettingsStorage.renderSettingsSamplesWarning = samplesWarning;
            renderSettingsStorage.renderSettingsSuppressPopups = suppressPopups;
            renderSettingsStorage.renderSettingsPrefabWarning = prefabWarning;
            renderSettingsStorage.renderSettingsSplitByScene = ftBuildGraphics.splitByScene;
            renderSettingsStorage.renderSettingsSplitByTag = ftBuildGraphics.splitByTag;
            renderSettingsStorage.renderSettingsExportTerrainAsHeightmap = ftBuildGraphics.exportTerrainAsHeightmap;
            renderSettingsStorage.renderSettingsExportTerrainTrees = ftBuildGraphics.exportTerrainTrees;
            renderSettingsStorage.renderSettingsRTXMode = rtxMode;
            renderSettingsStorage.renderSettingsLightProbeMode = (int)lightProbeMode;
            renderSettingsStorage.renderSettingsServerAddress = ftClient.serverAddress;
            renderSettingsStorage.renderSettingsClientMode = clientMode;
            renderSettingsStorage.renderSettingsUVPaddingMax = ftBuildGraphics.uvPaddingMax;
            renderSettingsStorage.renderSettingsPostPacking = ftBuildGraphics.postPacking;
            renderSettingsStorage.renderSettingsHoleFilling = ftBuildGraphics.holeFilling;
            renderSettingsStorage.renderSettingsSampleDiv = sampleDivisor;
            renderSettingsStorage.renderSettingsUnwrapper = (int)unwrapper;
            renderSettingsStorage.renderSettingsDenoiserType = (int)denoiserType;
            //renderSettingsStorage.renderSettingsLegacyDenoiser = (denoiserType == ftGlobalStorage.DenoiserType.Optix5);//legacyDenoiser;
            renderSettingsStorage.renderSettingsAtlasPacker = ftBuildGraphics.atlasPacker;
            renderSettingsStorage.renderSettingsCompressVolumes = compressVolumes;
            renderSettingsStorage.renderSettingsBatchAreaLightSampleLimit = batchAreaLightSampleLimit;
            renderSettingsStorage.renderSettingsSector = curSector;
        }
    }

    void RenderLightProbesUpdate()
    {
        if (!progressFunc.MoveNext())
        {
            EditorApplication.update -= RenderLightProbesUpdate;
        }

    }

    void RenderReflProbesUpdate()
    {
        if (!progressFunc.MoveNext())
        {
            EditorApplication.update -= RenderReflProbesUpdate;
        }

    }

    static float AreaElement(float x, float y)
    {
        return Mathf.Atan2(x * y, Mathf.Sqrt(x * x + y * y + 1));
    }

    const float inv2SqrtPI = 0.28209479177387814347403972578039f; // 1.0f / (2.0f * Mathf.Sqrt(Mathf.PI))
    const float sqrt3Div2SqrtPI = 0.48860251190291992158638462283835f; // Mathf.Sqrt(3.0f) / (2.0f * Mathf.Sqrt(Mathf.PI))
    const float sqrt15Div2SqrtPI = 1.0925484305920790705433857058027f; // Mathf.Sqrt(15.0f) / (2 * Mathf.Sqrt(Mathf.PI))
    const float threeSqrt5Div4SqrtPI = 0.94617469575756001809268107088713f; // 3 * Mathf.Sqrt(5.0f) / (4*Mathf.Sqrt(Mathf.PI))
    const float sqrt15Div4SqrtPI = 0.54627421529603953527169285290135f; // Mathf.Sqrt(15.0f) / (4 * Mathf.Sqrt(Mathf.PI))
    const float oneThird = 1.0f / 3.0f;

    static void EvalSHBasis9(Vector3 dir, ref float[] basis)
    {
        float dx = -dir.x;
        float dy = -dir.y;
        float dz = dir.z;
        basis[0] = inv2SqrtPI *                                 (pstorage.removeRinging ? ftAdditionalConfig.rr_irradianceConvolutionL0 :         ftAdditionalConfig.irradianceConvolutionL0);
        basis[1] = - dy * sqrt3Div2SqrtPI *                     (pstorage.removeRinging ? ftAdditionalConfig.rr_irradianceConvolutionL1 :         ftAdditionalConfig.irradianceConvolutionL1);
        basis[2] =   dz * sqrt3Div2SqrtPI *                     (pstorage.removeRinging ? ftAdditionalConfig.rr_irradianceConvolutionL1 :         ftAdditionalConfig.irradianceConvolutionL1);
        basis[3] = - dx * sqrt3Div2SqrtPI *                     (pstorage.removeRinging ? ftAdditionalConfig.rr_irradianceConvolutionL1 :         ftAdditionalConfig.irradianceConvolutionL1);
        basis[4] =   dx * dy * sqrt15Div2SqrtPI *               (pstorage.removeRinging ? ftAdditionalConfig.rr_irradianceConvolutionL2_4_5_7 :   ftAdditionalConfig.irradianceConvolutionL2_4_5_7);
        basis[5] = - dy * dz * sqrt15Div2SqrtPI *               (pstorage.removeRinging ? ftAdditionalConfig.rr_irradianceConvolutionL2_4_5_7 :   ftAdditionalConfig.irradianceConvolutionL2_4_5_7);
        basis[6] =  (dz*dz-oneThird) * threeSqrt5Div4SqrtPI *   (pstorage.removeRinging ? ftAdditionalConfig.rr_irradianceConvolutionL2_6 :       ftAdditionalConfig.irradianceConvolutionL2_6);
        basis[7] = - dx * dz * sqrt15Div2SqrtPI *               (pstorage.removeRinging ? ftAdditionalConfig.rr_irradianceConvolutionL2_4_5_7 :   ftAdditionalConfig.irradianceConvolutionL2_4_5_7);
        basis[8] =  (dx*dx-dy*dy) * sqrt15Div4SqrtPI *          (pstorage.removeRinging ? ftAdditionalConfig.rr_irradianceConvolutionL2_8 :       ftAdditionalConfig.irradianceConvolutionL2_8);
    }

    public static BakeryVolume[] FindBakeableVolumes()
    {
        var vols = FindObjectsOfType<BakeryVolume>();
        var vols2 = new List<BakeryVolume>();
        Transform sectorTform = null;
        if (curSector != null) sectorTform = curSector.transform;
        for(int v=0; v<vols.Length; v++)
        {
            if (vols[v].enableBaking)
            {
                if (fullSectorRender)
                {
                    var parent = vols[v].transform.parent;
                    while(parent != null)
                    {
                        if (parent == sectorTform) vols2.Add(vols[v]); // only use volumes parented to current sector
                        parent = parent.parent;
                    }
                }
                else
                {
                    vols2.Add(vols[v]);
                }
            }
        }
        lastFoundBakeableVolumes = vols2.ToArray();
        return lastFoundBakeableVolumes;
    }

    public static int VolumeDimension(int x)
    {
        const float blockSize = 4.0f;
        if (ftRenderLightmap.compressVolumes) return (int)(Mathf.Ceil(x/blockSize)*blockSize);
        return x;
    }

    void LoadVolumes()
    {
        var vols = FindBakeableVolumes();
        if (vols.Length == 0) return;

        int numTotalProbes = 0;
        for(int v=0; v<vols.Length; v++)
        {
            numTotalProbes += VolumeDimension(vols[v].resolutionX) * VolumeDimension(vols[v].resolutionY) * VolumeDimension(vols[v].resolutionZ);
        }

        int atlasTexSize = (int)Mathf.Ceil(Mathf.Sqrt((float)numTotalProbes));
        atlasTexSize = (int)Mathf.Ceil(atlasTexSize / (float)tileSize) * tileSize;

        BakeryLightmapGroup.RenderMode pVolumeMode = (BakeryLightmapGroup.RenderMode)pstorage.volumeRenderMode;
        bool shadowmask = (pVolumeMode == BakeryLightmapGroup.RenderMode.Auto && userRenderMode == RenderMode.Shadowmask)
                        || pVolumeMode == BakeryLightmapGroup.RenderMode.Shadowmask;
        if (!hasAnyShadowmasks) shadowmask = false;

        var l0 = new float[atlasTexSize * atlasTexSize * 4];
        var l1x = new float[atlasTexSize * atlasTexSize * 4];
        var l1y = new float[atlasTexSize * atlasTexSize * 4];
        var l1z = new float[atlasTexSize * atlasTexSize * 4];
        byte[] lshadows = null;
        if (shadowmask) lshadows = new byte[atlasTexSize * atlasTexSize * 4];
        var handle = GCHandle.Alloc(l0, GCHandleType.Pinned);
        var handleL1x = GCHandle.Alloc(l1x, GCHandleType.Pinned);
        var handleL1y = GCHandle.Alloc(l1y, GCHandleType.Pinned);
        var handleL1z = GCHandle.Alloc(l1z, GCHandleType.Pinned);
        GCHandle handleShadows = new GCHandle();
        if (shadowmask) handleShadows = GCHandle.Alloc(lshadows, GCHandleType.Pinned);
        var errCodes = new int[5];
        try
        {
            var pointer = handle.AddrOfPinnedObject();
            var pointerL1x = handleL1x.AddrOfPinnedObject();
            var pointerL1y = handleL1y.AddrOfPinnedObject();
            var pointerL1z = handleL1z.AddrOfPinnedObject();
            System.IntPtr pointerShadows = (System.IntPtr)0;
            if (shadowmask) pointerShadows = handleShadows.AddrOfPinnedObject();
            errCodes[0] = halffloat2vb(scenePath + "\\volumes_final_L0" + (compressedOutput ? ".lz4" : ".dds"), pointer, 2);
            errCodes[1] = halffloat2vb(scenePath + "\\volumes_final_L1x" + (compressedOutput ? ".lz4" : ".dds"), pointerL1x, 2);
            errCodes[2] = halffloat2vb(scenePath + "\\volumes_final_L1y" + (compressedOutput ? ".lz4" : ".dds"), pointerL1y, 2);
            errCodes[3] = halffloat2vb(scenePath + "\\volumes_final_L1z" + (compressedOutput ? ".lz4" : ".dds"), pointerL1z, 2);
            if (shadowmask)
            {
                errCodes[4] = halffloat2vb(scenePath + "\\volumes_mask" + (compressedOutput ? ".lz4" : ".dds"), pointerShadows, 1);
            }
            bool ok = true;
            for(int i=0; i<5; i++)
            {
                if (errCodes[i] != 0)
                {
                    Debug.LogError("hf2vb (" + i + "): " + errCodes[i]);
                    ok = false;
                }
            }
            if (ok)
            {
                var eventArgs = new VolumeEventArgs();
                if (OnPreVolumesCompress != null)
                {
                    eventArgs.L0 = l0;
                    eventArgs.L1x = l1x;
                    eventArgs.L1y = l1y;
                    eventArgs.L1z = l1z;
                    eventArgs.volumes = vols;
                    OnPreVolumesCompress.Invoke(this, eventArgs);
                }

                int i = 0;
                int maskI = 0;
                bool actuallyCompressVolumes = false;
#if UNITY_2020_1_OR_NEWER
                actuallyCompressVolumes = compressVolumes;
#endif
                for(int v=0; v<vols.Length; v++)
                {
                    var vol = vols[v];
                    int rx = VolumeDimension(vol.resolutionX);
                    int ry = VolumeDimension(vol.resolutionY);
                    int rz = VolumeDimension(vol.resolutionZ);
                    int numProbes = rx*ry*rz;
                    int numProbesInSlice = rx*ry;
                    int lastProbeInSlice = numProbesInSlice - 1;
                    int compressedSliceSizeHDR = 0;
                    int compressedSliceSizeLDR = 0;
                    Color[] texData0 = null;
                    Color[] texData1 = null;
                    Color[] texData2 = null;
                    Color[] texData3 = null;
                    Texture2D texSliceHDR = null;
                    Texture2D texSliceLDR = null;
                    byte[] compressedTexData0 = null;
                    byte[] compressedTexData1 = null;
                    byte[] compressedTexData2 = null;
                    byte[] compressedTexData3 = null;
                    if (actuallyCompressVolumes)
                    {
                        // Per slice arrays
                        texData0 = new Color[numProbesInSlice];
                        texData1 = new Color[numProbesInSlice];
                        texData2 = new Color[numProbesInSlice];
                        texData3 = new Color[numProbesInSlice];
                    }
                    else
                    {
                        // Full 3D arrays
                        texData0 = new Color[numProbes];
                        texData1 = new Color[numProbes];
                        texData2 = new Color[numProbes];
                    }
                    #if COMPRESS_VOLUME_RGBM
                        TextureFormat compressedHDRFormat = TextureFormat.BC7;
                        TextureFormat uncompressedHDRFormat = TextureFormat.ARGB32;
                    #else
                        TextureFormat compressedHDRFormat = TextureFormat.BC6H;
                        TextureFormat uncompressedHDRFormat = TextureFormat.RGBAHalf;
                    #endif
                    for(int z=0; z<rz; z++)
                    {
                        for(int y=0; y<ry; y++)
                        {
                            for(int x=0; x<rx; x++)
                            {
                                float l0r = l0[i*4+0] * 2;
                                float l0g = l0[i*4+1] * 2;
                                float l0b = l0[i*4+2] * 2;

                                const float convL0 = ftAdditionalConfig.convL0;
                                const float convL1 = ftAdditionalConfig.convL1;

                                float l1xr;
                                float l1xg;
                                float l1xb;
                                float l1yr;
                                float l1yg;
                                float l1yb;
                                float l1zr;
                                float l1zg;
                                float l1zb;
                                // read as BGR (2,1,0)
                                if (vol.encoding == BakeryVolume.Encoding.RGBA8 || vol.encoding == BakeryVolume.Encoding.RGBA8Mono)
                                {
                                    l1xr = ((l1x[i*4+2] * 2.0f - 1.0f) * convL1) * 0.5f + 0.5f;
                                    l1xg = ((l1x[i*4+1] * 2.0f - 1.0f) * convL1) * 0.5f + 0.5f;
                                    l1xb = ((l1x[i*4+0] * 2.0f - 1.0f) * convL1) * 0.5f + 0.5f;

                                    l1yr = ((l1y[i*4+2] * 2.0f - 1.0f) * convL1) * 0.5f + 0.5f;
                                    l1yg = ((l1y[i*4+1] * 2.0f - 1.0f) * convL1) * 0.5f + 0.5f;
                                    l1yb = ((l1y[i*4+0] * 2.0f - 1.0f) * convL1) * 0.5f + 0.5f;

                                    l1zr = ((l1z[i*4+2] * 2.0f - 1.0f) * convL1) * 0.5f + 0.5f;
                                    l1zg = ((l1z[i*4+1] * 2.0f - 1.0f) * convL1) * 0.5f + 0.5f;
                                    l1zb = ((l1z[i*4+0] * 2.0f - 1.0f) * convL1) * 0.5f + 0.5f;

                                    if (vol.encoding == BakeryVolume.Encoding.RGBA8Mono)
                                    {
                                        // Single direction packed to tex1
                                        l1xr = (l1xr + l1xg + l1xb) * 0.3333333333f;
                                        l1xg = (l1yr + l1yg + l1yb) * 0.3333333333f;
                                        l1xb = (l1zr + l1zg + l1zb) * 0.3333333333f;

                                        l1yr = l1yg = l1yb = 0;
                                        l1zr = l1zg = l1zb = 0;
                                    }
                                }
                                else
                                {
                                    l1xr = (l1x[i*4+2] * 2.0f - 1.0f) * l0r*2 * convL1;
                                    l1xg = (l1x[i*4+1] * 2.0f - 1.0f) * l0g*2 * convL1;
                                    l1xb = (l1x[i*4+0] * 2.0f - 1.0f) * l0b*2 * convL1;

                                    l1yr = (l1y[i*4+2] * 2.0f - 1.0f) * l0r*2 * convL1;
                                    l1yg = (l1y[i*4+1] * 2.0f - 1.0f) * l0g*2 * convL1;
                                    l1yb = (l1y[i*4+0] * 2.0f - 1.0f) * l0b*2 * convL1;

                                    l1zr = (l1z[i*4+2] * 2.0f - 1.0f) * l0r*2 * convL1;
                                    l1zg = (l1z[i*4+1] * 2.0f - 1.0f) * l0g*2 * convL1;
                                    l1zb = (l1z[i*4+0] * 2.0f - 1.0f) * l0b*2 * convL1;

                                    if (actuallyCompressVolumes)
                                    {
                                        float il0r = 0.5f / l0r;
                                        float il0g = 0.5f / l0g;
                                        float il0b = 0.5f / l0b;

                                        l1xr = (l1xr * il0r) * 0.5f + 0.5f;
                                        l1xg = (l1xg * il0g) * 0.5f + 0.5f;
                                        l1xb = (l1xb * il0b) * 0.5f + 0.5f;

                                        l1yr = (l1yr * il0r) * 0.5f + 0.5f;
                                        l1yg = (l1yg * il0g) * 0.5f + 0.5f;
                                        l1yb = (l1yb * il0b) * 0.5f + 0.5f;

                                        l1zr = (l1zr * il0r) * 0.5f + 0.5f;
                                        l1zg = (l1zg * il0g) * 0.5f + 0.5f;
                                        l1zb = (l1zb * il0b) * 0.5f + 0.5f;
                                    }
                                }
                                l0r *= convL0;
                                l0g *= convL0;
                                l0b *= convL0;


                                if (actuallyCompressVolumes)
                                {
                                    int index = y*rx + x;
                                    #if COMPRESS_VOLUME_RGBM
                                        const float rgbmMul = 1.0f / 8.0f;
                                        l0r = Mathf.Sqrt(l0r) * rgbmMul;
                                        l0g = Mathf.Sqrt(l0g) * rgbmMul;
                                        l0b = Mathf.Sqrt(l0b) * rgbmMul;
                                        float a = Mathf.Max(Mathf.Max(Mathf.Max(l0r, l0g), l0b), 1.0f / 255);
                                        if (a > 1.0f) a = 1.0f;
                                        a = Mathf.Ceil(a * 255.0f) / 255.0f;
                                        float invA = 1.0f / a;
                                        l0r *= invA;
                                        l0g *= invA;
                                        l0b *= invA;
                                        texData0[index] = new Color(l0r, l0g, l0b, a);
                                    #else
                                        texData0[index] = new Color(l0r, l0g, l0b, 1.0f);
                                    #endif
                                    texData1[index] = new Color(l1xr, l1xg, l1xb, 1.0f);
                                    texData2[index] = new Color(l1yr, l1yg, l1yb, 1.0f);
                                    texData3[index] = new Color(l1zr, l1zg, l1zb, 1.0f);
                                    if (index == lastProbeInSlice)
                                    {
                                        // Would be nice if CompressTexture had separate src/dest args and we could reuse the textures...
                                        texSliceHDR = new Texture2D(rx, ry, uncompressedHDRFormat, false);

                                        // L0
                                        texSliceHDR.SetPixels(texData0);
                                        texSliceHDR.Apply();
                                        EditorUtility.CompressTexture(texSliceHDR, compressedHDRFormat,
#if UNITY_2019_3_OR_NEWER
                                            UnityEditor.TextureCompressionQuality.Best);
#else
                                            (int)UnityEngine.TextureCompressionQuality.Best);
#endif
                                        var sliceBytes = texSliceHDR.GetRawTextureData();
                                        if (compressedSliceSizeHDR == 0)
                                        {
                                            compressedTexData0 = new byte[sliceBytes.Length * rz];
                                            compressedSliceSizeHDR = sliceBytes.Length;
                                        }
                                        int coffset = compressedSliceSizeHDR * z;
                                        for(int c=0; c<compressedSliceSizeHDR; c++) compressedTexData0[coffset + c] = sliceBytes[c];
                                        DestroyImmediate(texSliceHDR);

                                        // L1x
                                        texSliceLDR = new Texture2D(rx, ry, TextureFormat.ARGB32, false);
                                        texSliceLDR.SetPixels(texData1);
                                        texSliceLDR.Apply();
                                        EditorUtility.CompressTexture(texSliceLDR, TextureFormat.BC7,
#if UNITY_2019_3_OR_NEWER
                                            UnityEditor.TextureCompressionQuality.Best);
#else
                                            (int)UnityEngine.TextureCompressionQuality.Best);
#endif
                                        sliceBytes = texSliceLDR.GetRawTextureData();
                                        if (compressedSliceSizeLDR == 0)
                                        {
                                            compressedTexData1 = new byte[sliceBytes.Length * rz];
                                            compressedTexData2 = new byte[sliceBytes.Length * rz];
                                            compressedTexData3 = new byte[sliceBytes.Length * rz];
                                            compressedSliceSizeLDR = sliceBytes.Length;
                                        }
                                        coffset = compressedSliceSizeLDR * z;
                                        for(int c=0; c<compressedSliceSizeLDR; c++) compressedTexData1[coffset + c] = sliceBytes[c];
                                        DestroyImmediate(texSliceLDR);

                                        // L1y
                                        texSliceLDR = new Texture2D(rx, ry, TextureFormat.ARGB32, false);
                                        texSliceLDR.SetPixels(texData2);
                                        texSliceLDR.Apply();
                                        EditorUtility.CompressTexture(texSliceLDR, TextureFormat.BC7,
#if UNITY_2019_3_OR_NEWER
                                            UnityEditor.TextureCompressionQuality.Best);
#else
                                            (int)UnityEngine.TextureCompressionQuality.Best);
#endif
                                        sliceBytes = texSliceLDR.GetRawTextureData();
                                        for(int c=0; c<compressedSliceSizeLDR; c++) compressedTexData2[coffset + c] = sliceBytes[c];
                                        DestroyImmediate(texSliceLDR);

                                        // L1z
                                        texSliceLDR = new Texture2D(rx, ry, TextureFormat.ARGB32, false);
                                        texSliceLDR.SetPixels(texData3);
                                        texSliceLDR.Apply();
                                        EditorUtility.CompressTexture(texSliceLDR, TextureFormat.BC7,
#if UNITY_2019_3_OR_NEWER
                                            UnityEditor.TextureCompressionQuality.Best);
#else
                                            (int)UnityEngine.TextureCompressionQuality.Best);
#endif
                                        sliceBytes = texSliceLDR.GetRawTextureData();
                                        for(int c=0; c<compressedSliceSizeLDR; c++) compressedTexData3[coffset + c] = sliceBytes[c];
                                        DestroyImmediate(texSliceLDR);
                                    }
                                }
                                else
                                {
                                    int index = z*ry*rx + y*rx + x;
                                    texData0[index] = new Color(l0r, l0g, l0b, l1zr);
                                    texData1[index] = new Color(l1xr, l1xg, l1xb, l1zg);
                                    texData2[index] = new Color(l1yr, l1yg, l1yb, l1zb);
                                }
                                i++;
                            }
                        }
                    }

                    // AMW - name volume based on the lightmapped prefab (if it exists) vs the scene
                    var lightmappedPrefab = vol.gameObject.GetComponentInParent<BakeryLightmappedPrefab>();
                    var volNamePrefix = ( lightmappedPrefab != null ) ? lightmappedPrefab.name : vol.gameObject.scene.name;
                    var outNameBase = "Assets/" + outputPath + "/" + volNamePrefix + "_" + vol.name;

                    //var outNameBase = "Assets/" + outputPath + "/" + vol.gameObject.scene.name + "_" + vol.name;

                    TextureFormat vformatHDR;
                    TextureFormat vformatLDR = TextureFormat.BC7;
                    if (actuallyCompressVolumes)
                    {
                        vformatHDR = vol.encoding == BakeryVolume.Encoding.Half4 ? compressedHDRFormat : TextureFormat.BC7;
                    }
                    else
                    {
                        vformatHDR = vol.encoding == BakeryVolume.Encoding.Half4 ? TextureFormat.RGBAHalf : TextureFormat.ARGB32;
                    }

                    var outName = outNameBase + "0.asset";
                    if (File.Exists(outName)) ValidateFileAttribs(outName);
                    var tex = new Texture3D(rx, ry, rz, vformatHDR, false);
                    tex.filterMode = FilterMode.Bilinear;
                    tex.wrapMode = TextureWrapMode.Clamp;
                    if (actuallyCompressVolumes)
                    {
#if UNITY_2020_1_OR_NEWER
                        tex.SetPixelData(compressedTexData0, 0, 0);
#endif
                    }
                    else
                    {
                        tex.SetPixels(texData0);
                    }
                    tex.Apply();
                    tex = CreateOrReplaceAsset(tex, outName);
                    vol.bakedTexture0 = tex;

                    outName = outNameBase + "1.asset";
                    if (File.Exists(outName)) ValidateFileAttribs(outName);
                    tex = new Texture3D(rx, ry, rz, actuallyCompressVolumes ? vformatLDR : vformatHDR, false);
                    tex.filterMode = FilterMode.Bilinear;
                    tex.wrapMode = TextureWrapMode.Clamp;
                    if (actuallyCompressVolumes)
                    {
#if UNITY_2020_1_OR_NEWER
                        tex.SetPixelData(compressedTexData1, 0, 0);
#endif
                    }
                    else
                    {
                        tex.SetPixels(texData1);
                    }
                    tex.Apply();
                    tex = CreateOrReplaceAsset(tex, outName);
                    vol.bakedTexture1 = tex;

                    outName = outNameBase + "2.asset";
                    if (File.Exists(outName)) ValidateFileAttribs(outName);
                    tex = new Texture3D(rx, ry, rz, actuallyCompressVolumes ? vformatLDR : vformatHDR, false);
                    tex.filterMode = FilterMode.Bilinear;
                    tex.wrapMode = TextureWrapMode.Clamp;
                    if (actuallyCompressVolumes)
                    {
#if UNITY_2020_1_OR_NEWER
                        tex.SetPixelData(compressedTexData2, 0, 0);
#endif
                    }
                    else
                    {
                        tex.SetPixels(texData2);
                    }
                    tex.Apply();
                    tex = CreateOrReplaceAsset(tex, outName);
                    vol.bakedTexture2 = tex;

                    if (actuallyCompressVolumes)
                    {
#if UNITY_2020_1_OR_NEWER
                        outName = outNameBase + "3.asset";
                        if (File.Exists(outName)) ValidateFileAttribs(outName);
                        tex = new Texture3D(rx, ry, rz, actuallyCompressVolumes ? vformatLDR : vformatHDR, false);
                        tex.filterMode = FilterMode.Bilinear;
                        tex.wrapMode = TextureWrapMode.Clamp;
                        tex.SetPixelData(compressedTexData3, 0, 0);
                        tex.Apply();
                        tex = CreateOrReplaceAsset(tex, outName);
                        vol.bakedTexture3 = tex;
#endif
                    }
                    else
                    {
                        vol.bakedTexture3 = null;
                    }

                    if (shadowmask)
                    {
                        var texData = new Color32[numProbes];
                        for(int z=0; z<rz; z++)
                        {
                            for(int y=0; y<ry; y++)
                            {
                                for(int x=0; x<rx; x++)
                                {
                                    int index = z*ry*rx + y*rx + x;
                                    if (vol.shadowmaskEncoding == BakeryVolume.ShadowmaskEncoding.A8)
                                    {
                                        byte sr = lshadows[maskI*4+0];
                                        texData[index] = new Color32(sr,sr,sr,sr);
                                    }
                                    else
                                    {
                                        byte sr = lshadows[maskI*4+0];
                                        byte sg = lshadows[maskI*4+1];
                                        byte sb = lshadows[maskI*4+2];
                                        byte sa = lshadows[maskI*4+3];
                                        if (vol.firstLightIsAlwaysAlpha)
                                        {
                                            texData[index] = new Color32(sg,sb,sa,sr);
                                        }
                                        else
                                        {
                                            texData[index] = new Color32(sr,sg,sb,sa);
                                        }
                                    }
                                    maskI++;
                                }
                            }
                        }


                        var vformat = (vol.shadowmaskEncoding == BakeryVolume.ShadowmaskEncoding.A8) ? TextureFormat.Alpha8 : TextureFormat.ARGB32;
                        outName = outNameBase + "_mask.asset";
                        if (File.Exists(outName)) ValidateFileAttribs(outName);
                        tex = new Texture3D(rx, ry, rz, vformat, false);
                        tex.filterMode = FilterMode.Bilinear;
                        tex.wrapMode = TextureWrapMode.Clamp;
                        tex.SetPixels32(texData);
                        tex.Apply();
                        tex = CreateOrReplaceAsset(tex, outName);
                        vol.bakedMask = tex;
                    }

                    AssetDatabase.SaveAssets();

                    if (vol.isGlobal) vol.OnEnable();

                    EditorUtility.SetDirty(vol);
                }
            }
        }
        finally
        {
            handle.Free();
            handleL1x.Free();
            handleL1y.Free();
            handleL1z.Free();
            if (shadowmask) handleShadows.Free();
        }
    }

    static Texture3D CreateOrReplaceAsset(Texture3D src, string path)
    {
        var dest = AssetDatabase.LoadAssetAtPath<Texture3D>(path);
        if (dest == null)
        {
            AssetDatabase.CreateAsset(src, path);
            dest = src;
        }
        else
        {
            EditorUtility.CopySerialized(src, dest);
            EditorUtility.SetDirty(dest);
        }
        return dest;
    }

    static Texture2D CreateOrReplaceAsset(Texture2D src, string path)
    {
        var dest = AssetDatabase.LoadAssetAtPath<Texture2D>(path);
        if (dest == null)
        {
            AssetDatabase.CreateAsset(src, path);
            dest = src;
        }
        else
        {
            EditorUtility.CopySerialized(src, dest);
            EditorUtility.SetDirty(dest);
        }
        return dest;
    }

    public static void RestoreSceneManagerSetup(SceneSetup[] sceneSetups)
    {
        EditorSceneManager.RestoreSceneManagerSetup(sceneSetups);
    }

    static public void DebugLogError(string text)
    {
        userCanceled = true;
        ProgressBarEnd();
        if (verbose)
        {
            EditorUtility.DisplayDialog("Bakery error", text, "OK");
        }
        else
        {
            Debug.LogError(text);
        }
    }

    public static void DebugLogInfo(string info)
    {
        if (pstorage == null) pstorage = ftLightmaps.GetProjectSettings();
        if ((pstorage.logLevel & (int)BakeryProjectSettings.LogLevel.Info) != 0) Debug.Log(info);
    }

    public static void DebugLogWarning(string info)
    {
        if (pstorage == null) pstorage = ftLightmaps.GetProjectSettings();
        if ((pstorage.logLevel & (int)BakeryProjectSettings.LogLevel.Warning) != 0) Debug.LogWarning(info);
    }

    IEnumerator RenderReflProbesFunc()
    {
        ProgressBarInit("Rendering reflection probes...");

        // AMW
        if ( OnPreReflectionProbeRender != null )
        {
            OnPreReflectionProbeRender.Invoke( this, null );
        }

        // Put empty lighting data asset to scenes to prevent reflection probes bake trying to re-render everything
        int sceneCount = SceneManager.sceneCount;
        var bakeryRuntimePath = ftLightmaps.GetRuntimePath();
        for(int s=0; s<sceneCount; s++)
        {
            var scene = EditorSceneManager.GetSceneAt(s);
            LightingDataAsset copiedAsset = null;
            string assetName;
            if (!scene.isLoaded) continue;
            if (Lightmapping.lightingDataAsset == null)
            {
                if (emptyLDataAsset == null) emptyLDataAsset =
                    AssetDatabase.LoadAssetAtPath(bakeryRuntimePath + "emptyLightingData.asset", typeof(LightingDataAsset)) as LightingDataAsset;

                if (emptyLDataAsset == null)
                {
                    Debug.LogError("Can't load emptyLightingData.asset");
                    continue;
                }

                if (copiedAsset == null)
                {
                    assetName = GenerateLightingDataAssetName();
                    var outName = "Assets/" + outputPath + "/" + assetName + "_probes.asset";
                    if (File.Exists(outName)) ValidateFileAttribs(outName);
                    if (AssetDatabase.CopyAsset(bakeryRuntimePath + "emptyLightingData.asset",  outName))
                    {
                        AssetDatabase.Refresh();
                        copiedAsset = AssetDatabase.LoadAssetAtPath(outName, typeof(LightingDataAsset)) as LightingDataAsset;
                        if (copiedAsset == null)
                        {
                            Debug.LogError("Can't load " + outName);
                            continue;
                        }
                    }
                    else
                    {
                        Debug.LogError("Can't copy emptyLightingData.asset");
                        continue;
                    }
                }

                Lightmapping.lightingDataAsset = copiedAsset;
                ftLightmaps.RefreshFull();
            }
        }

        var bakeFunc = typeof(Lightmapping).GetMethod("BakeAllReflectionProbesSnapshots",
            BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static);
        if (bakeFunc == null)
        {
            ProgressBarEnd();
            DebugLogError("Can't get BakeAllReflectionProbesSnapshots function");
            bakeInProgress = false;
            yield break;
        }
        bakeFunc.Invoke(null, null);

        // Revert lighting data assets
        /*for(int s=0; s<sceneCount; s++)
        {
            var scene = EditorSceneManager.GetSceneAt(s);
            if (!scene.isLoaded) continue;
            if (Lightmapping.lightingDataAsset == emptyLDataAsset)
            {
                Lightmapping.lightingDataAsset = null;
            }
        }*/

        EditorSceneManager.MarkAllScenesDirty();

        ProgressBarEnd();

        if (OnFinishedReflectionProbes != null)
        {
            OnFinishedReflectionProbes.Invoke(this, null);
        }

        bakeInProgress = false;
    }

    static string GetSunRenderMode(BakeryDirectLight light, bool allowSupersample)
    {
        if (allowSupersample && light.supersample) return "sunsupersample";
        return light.cloudShadow != null ? "suncloudshadow" : "sun"; // anyone uses cloudshadow? not supporting it with supersample for now
    }

    static string GetPointLightRenderMode(BakeryPointLight light)
    {
        string renderMode;
        if (light.projMode == BakeryPointLight.ftLightProjectionMode.Cone)
        {
            renderMode = "conelight";
        }
        else if (light.projMode == BakeryPointLight.ftLightProjectionMode.Cookie)
        {
            if (light.cookie == null)
            {
                Debug.LogError("No cookie texture is set for light " + light.name);
                renderMode = "pointlight";
            }
            else
            {
                renderMode = "cookielight";
            }
        }
        else if (light.projMode == BakeryPointLight.ftLightProjectionMode.Cubemap || light.projMode == BakeryPointLight.ftLightProjectionMode.IES)
        {
            if (light.projMode == BakeryPointLight.ftLightProjectionMode.Cubemap && light.cubemap == null)
            {
                Debug.LogError("No cubemap set for light " + light.name);
                renderMode = "pointlight";
            }
            else if (light.projMode == BakeryPointLight.ftLightProjectionMode.IES && light.iesFile == null)
            {
                Debug.LogError("No IES file is set for light " + light.name);
                renderMode = "pointlight";
            }
            else
            {
                renderMode = "cubemaplight";
            }
        }
        else
        {
            renderMode = "pointlight";
        }
        return renderMode;
    }

    static bool _ValidateCurrentScene()
    {
        var fname = scenePath + "/lastscene.txt";
        if (!File.Exists(fname)) return false;
        var cur = ftRenderLightmap.GenerateLightingDataAssetName();
        var last = File.ReadAllText(fname);
        return cur == last;
    }

    public static bool ValidateCurrentScene()
    {
        if (!_ValidateCurrentScene())
        {
            DebugLogError("Current scenes don't match last exported scenes. Make sure 'Export geometry and maps' is enabled.");
            userCanceled = true;
            return false;
        }
        return true;
    }

    public static string GenerateLightingDataAssetName()
    {
        var sceneCount = SceneManager.sceneCount;
        var assetName = "";
        var assetNameHashPart = "";
        for(int i=0; i<sceneCount; i++)
        {
            var s = EditorSceneManager.GetSceneAt(i);
            if (!s.isLoaded) continue;
            if (i == 0)
            {
                assetName += s.name;
            }
            else
            {
                assetNameHashPart += s.name;
                if (i < sceneCount - 1) assetNameHashPart += "__";
            }
        }
        assetName += "_" + assetNameHashPart.GetHashCode();
        return assetName;
    }

    LightingDataAsset ApplyLightingDataAsset(string newPath)
    {
        var newAsset = AssetDatabase.LoadAssetAtPath(newPath, typeof(LightingDataAsset)) as LightingDataAsset;
        int sceneCount = SceneManager.sceneCount;
        for(int i=0; i<sceneCount; i++)
        {
            var s = EditorSceneManager.GetSceneAt(i);
            if (!s.isLoaded) continue;
            SceneManager.SetActiveScene(s);
            Lightmapping.lightingDataAsset = newAsset;
        }
        return newAsset;
    }

#if UNITY_2017_3_OR_NEWER
#else
    Light AddTempShadowmaskLight(Light light, Scene scene)
    {
        var g = new GameObject();
        SceneManager.MoveGameObjectToScene(g, scene);
        var ulht2 = g.AddComponent<Light>();
        ulht2.type = light.type;
        ulht2.lightmapBakeType = LightmapBakeType.Mixed;
        ulht2.shadows = LightShadows.Soft;
        ulht2.range = light.range;
        ulht2.transform.position = light.transform.position;
        GameObjectUtility.SetStaticEditorFlags(g, StaticEditorFlags.LightmapStatic);
        return ulht2;
    }

    bool GetLightDataForPatching(Light lightTemp, Light lightReal, ref Dictionary<long,long> idMap, ref Dictionary<long,int> realID2Channel)
    {
        if (inspectorModeInfo == null)
            inspectorModeInfo = typeof(SerializedObject).GetProperty("inspectorMode", BindingFlags.NonPublic | BindingFlags.Instance);

        var so = new SerializedObject(lightReal);
        inspectorModeInfo.SetValue(so, InspectorMode.Debug, null);
        long realID = so.FindProperty("m_LocalIdentfierInFile").longValue;
        realID2Channel[realID] = so.FindProperty("m_BakingOutput").FindPropertyRelative("occlusionMaskChannel").intValue;

        so = new SerializedObject(lightTemp);
        inspectorModeInfo.SetValue(so, InspectorMode.Debug, null);
        long tempID = so.FindProperty("m_LocalIdentfierInFile").longValue;

        if (tempID == 0)
        {
            DebugLogError("tempID == 0");
            return false;
        }

        if (realID == 0)
        {
            DebugLogError("realID == 0");
            return false;
        }

        idMap[tempID] = realID;

        return true;
    }
#endif

    bool IsLightCompletelyBaked(bool bakeToIndirect, bool shadowmask, RenderMode rmode)
    {
        bool isBaked = ((rmode == RenderMode.FullLighting) ||
                        (rmode == RenderMode.Indirect && bakeToIndirect) ||
                        (rmode == RenderMode.Shadowmask && bakeToIndirect && !shadowmask));
        return isBaked;
    }

    void MarkLightAsCompletelyBaked(Light ulht)
    {
        var st = storages[ulht.gameObject.scene];
        if (!st.bakedLights.Contains(ulht))
        {
            st.bakedLights.Add(ulht);
            st.bakedLightChannels.Add(-1);
        }

#if UNITY_2017_3_OR_NEWER
        var output = new LightBakingOutput();
        output.isBaked = true;
        output.lightmapBakeType = LightmapBakeType.Baked;
        ulht.bakingOutput = output;
#endif
    }

    bool IsLightRealtime(bool bakeToIndirect, RenderMode rmode)
    {
        bool isRealtime = ((rmode == RenderMode.Indirect && !bakeToIndirect) ||
                           (rmode == RenderMode.Shadowmask && !bakeToIndirect));
        return isRealtime;
    }

    void MarkLightAsRealtime(Light ulht)
    {
#if UNITY_2017_3_OR_NEWER
        var output = new LightBakingOutput();
        output.isBaked = false;
        output.lightmapBakeType = LightmapBakeType.Realtime;
        output.mixedLightingMode = MixedLightingMode.IndirectOnly;
        output.occlusionMaskChannel = -1;
        output.probeOcclusionLightIndex = -1;
        ulht.bakingOutput = output;
#endif
    }

    bool IsLightSubtractive(bool bakeToIndirect, RenderMode rmode)
    {
        return rmode == RenderMode.Subtractive;
    }

    void MarkLightAsSubtractive(Light ulht)
    {
        var st = storages[ulht.gameObject.scene];
        if (!st.bakedLights.Contains(ulht))
        {
            st.bakedLights.Add(ulht);
            st.bakedLightChannels.Add(101);
        }

#if UNITY_2017_3_OR_NEWER
        var output = new LightBakingOutput();
        output.isBaked = true;
        output.lightmapBakeType = LightmapBakeType.Mixed;
        output.mixedLightingMode = MixedLightingMode.Subtractive;
        output.occlusionMaskChannel = -1;
        output.probeOcclusionLightIndex = -1;
        ulht.bakingOutput = output;
#else
        ulht.alreadyLightmapped = true;
        ulht.lightmapBakeType = LightmapBakeType.Mixed;
        var so = new SerializedObject(ulht);
        var sp = so.FindProperty("m_BakingOutput");
        sp.FindPropertyRelative("occlusionMaskChannel").intValue = 0;
        sp.FindPropertyRelative("lightmappingMask").intValue = 131076;
        so.ApplyModifiedProperties();

        if (!maskedLights.Contains(ulht)) maskedLights.Add(ulht);
#endif
    }

    void SceneSavedTest(Scene scene)
    {
        if (sceneSavedTestScene == scene) sceneWasSaved = true;
    }

    static int GetShadowmaskChannel(BakeryPointLight a)
    {
        int channelA = -1;
        if (!a.shadowmask) return channelA;
        var uA = a.GetComponent<Light>();
        if (uA != null)
        {
            var stA = storages[a.gameObject.scene];
            int indexA = stA.bakedLights.IndexOf(uA);
            if (indexA >= 0 && indexA < stA.bakedLightChannels.Count)
            {
                channelA = stA.bakedLightChannels[indexA];
            }
        }
        else if (a.shadowmask && a.bakeToIndirect) // full+shadowmask mode
        {
            channelA = a.maskChannel;
        }
        return channelA;
    }

    static int GetShadowmaskChannel(BakeryLightMesh a)
    {
        int channelA = -1;
        if (!a.shadowmask) return channelA;
        var uA = a.GetComponent<Light>();
        if (uA != null)
        {
            var stA = storages[a.gameObject.scene];
            int indexA = stA.bakedLights.IndexOf(uA);
            if (indexA >= 0 && indexA < stA.bakedLightChannels.Count)
            {
                channelA = stA.bakedLightChannels[indexA];
            }
        }
        else if (a.shadowmask && a.bakeToIndirect) // full+shadowmask mode
        {
            channelA = a.maskChannel;
        }
        return channelA;
    }

    static int ComparePointLights(BakeryPointLight a, BakeryPointLight b)
    {
        int channelA = GetShadowmaskChannel(a);
        float compA = channelA * 10000 + ((a.bakeToIndirect && !a.shadowmask) ? 1000 : 0) + (a.legacySampling ? 100 : 0) + a.indirectIntensity;

        int channelB = GetShadowmaskChannel(b);
        float compB = channelB * 10000 + ((b.bakeToIndirect && !b.shadowmask) ? 1000 : 0) + (b.legacySampling ? 100 : 0) + b.indirectIntensity;

        return compB.CompareTo(compA);
    }

    static int CompareAreaLights(BakeryLightMesh a, BakeryLightMesh b)
    {
        int channelA = GetShadowmaskChannel(a);
        float compA = (a.texture != null ? 100000 : 0) + channelA * 10000 + ((a.bakeToIndirect && !a.shadowmask) ? 1000 : 0) + (a.selfShadow ? 100 : 0) + a.indirectIntensity;

        int channelB = GetShadowmaskChannel(b);
        float compB = (b.texture != null ? 100000 : 0) + channelB * 10000 + ((b.bakeToIndirect && !b.shadowmask) ? 1000 : 0) + (b.selfShadow ? 100 : 0) + b.indirectIntensity;

        return compB.CompareTo(compA);
    }

    public IEnumerator InitializeLightProbes(bool optional)
    {
        hasAnyProbes = true;
        var probeGroups = FindObjectsOfType(typeof(LightProbeGroup)) as LightProbeGroup[];
        if (probeGroups.Length == 0)
        {
            if (!optional) DebugLogError("Add at least one LightProbeGroup");
            hasAnyProbes = false;
            yield break;
        }
        else
        {
            int totalProbes = 0;
            for(int i=0; i<probeGroups.Length; i++)
            {
                totalProbes += probeGroups[i].probePositions.Length;
            }
            if (totalProbes == 0)
            {
                if (!optional) DebugLogError("Add at least one light probe");
                hasAnyProbes = false;
                yield break;
            }
        }

        ftBuildLights.InitMaps(true);
        if (useUnityForOcclsusionProbes)
        {
            var fgo = GameObject.Find("!ftraceLightmaps");
            if (fgo == null) {
                fgo = new GameObject();
                fgo.name = "!ftraceLightmaps";
                fgo.hideFlags = HideFlags.HideInHierarchy;
            }
            var store = fgo.GetComponent<ftLightmapsStorage>();
            if (store == null) {
                store = fgo.AddComponent<ftLightmapsStorage>();
            }

#if UNITY_2017_2_OR_NEWER
            if (LightmapEditorSettings.lightmapper == BUILTIN_RADIOSITY)
            {
                bool cont = true;
                if (verbose)
                {
                    cont = EditorUtility.DisplayDialog("Bakery", "Unity does not currently support external occlusion probes. You are going to generate them using Enlighten. This process can take an eternity of time. It is recommended to use Progressive to generate them instead.", "Use Progressive", "Continue anyway");
                }
                else
                {
                    Debug.LogError("Enlighten used to generate occlusion probes");
                }
                if (cont)
                {
                    LightmapEditorSettings.lightmapper = BUILTIN_PT;
                }
            }
            else
            {
                if (!store.enlightenWarningShown)
                {
                    if (verbose)
                    {
                        if (!EditorUtility.DisplayDialog("Bakery", "Unity does not currently support external occlusion probes. You are going to generate them using Progressive.\n", "Continue anyway", "Cancel"))
                        {
                            hasAnyProbes = false;
                            yield break;
                        }
                    }
                    else
                    {
                        Debug.LogError("Enlighten used to generate occlusion probes");
                    }
                }
            }
            if (!store.enlightenWarningShown)
            {
                store.enlightenWarningShown = true;
                EditorUtility.SetDirty(store);
            }
#else
            if (!store.enlightenWarningShown)
            {
                if (verbose)
                {
                    if (!EditorUtility.DisplayDialog("Bakery", "Unity does not currently support external occlusion probes. You are going to generate them using Enlighten or Progressive - whichever is enabled in the Lighting window.\nMake sure you have selected Progressive, as Enlighten can take an eternity of time.", "Continue anyway", "Cancel"))
                    {
                        hasAnyProbes = false;
                        yield break;
                    }
                    store.enlightenWarningShown = true;
                    EditorUtility.SetDirty(store);
                }
                else
                {
                    Debug.LogError("Enlighten used to generate occlusion probes");
                }
            }
#endif

            var staticObjects = new List<Renderer>();
            var staticObjectsScale = new List<float>();
#if USE_TERRAINS
            var staticObjectsTerrain = new List<Terrain>();
            var staticObjectsScaleTerrain = new List<float>();
#endif
            try
            {
                // Temporarily zero scale in lightmap to prevent Unity from generating its lightmaps
                // terrains?
                var objs = Resources.FindObjectsOfTypeAll(typeof(GameObject));
                foreach(GameObject obj in objs)
                {
                    if (obj == null) continue;
                    if (!obj.activeInHierarchy) continue;
                    var path = AssetDatabase.GetAssetPath(obj);
                    if (path != "") continue; // must belond to scene
                    //if ((obj.hideFlags & (HideFlags.DontSave|HideFlags.HideAndDontSave)) != 0) continue; // skip temp objects
                    //if (obj.tag == "EditorOnly") continue; // skip temp objects
                    //var areaLight = obj.GetComponent<BakeryLightMesh>();
                    //if (areaLight != null && !areaLight.selfShadow) continue;
                    var mr = ftBuildGraphics.GetValidRenderer(obj);
                    var mf = obj.GetComponent<MeshFilter>();
#if USE_TERRAINS
                    var tr = obj.GetComponent<Terrain>();
#endif
                    //if (((GameObjectUtility.GetStaticEditorFlags(obj) & StaticEditorFlags.LightmapStatic) == 0) && areaLight==null) continue; // skip dynamic
                    if ((GameObjectUtility.GetStaticEditorFlags(obj) & StaticEditorFlags.ContributeGI) == 0) continue; // skip dynamic

                    var sharedMesh = ftBuildGraphics.GetSharedMesh(mr);

                    if (mr != null && mr.enabled && mf != null && sharedMesh != null)
                    {
                        var so = new SerializedObject(mr);
                        var prop = so.FindProperty("m_ScaleInLightmap");
                        var scaleInLm = prop.floatValue;
                        if (scaleInLm == 0) continue;
                        staticObjectsScale.Add(scaleInLm);
                        prop.floatValue = 0;
                        so.ApplyModifiedProperties();
                        staticObjects.Add(mr);
                    }

#if USE_TERRAINS
                    if (tr != null && tr.enabled)
                    {
                        var so = new SerializedObject(tr);
                        var prop = so.FindProperty("m_ScaleInLightmap");
                        var scaleInLm = prop.floatValue;
                        if (scaleInLm == 0) continue;
                        staticObjectsScaleTerrain.Add(scaleInLm);
                        prop.floatValue = 0;
                        so.ApplyModifiedProperties();
                        staticObjectsTerrain.Add(tr);
                    }
#endif
                }
            }
            catch
            {
                Debug.LogError("Failed rendering light probes");
                throw;
            }

            var lms = LightmapSettings.lightmaps;
            Texture2D firstLM = null;
            if (lms.Length > 0) firstLM = lms[0].lightmapColor;

            Lightmapping.BakeAsync();
            ProgressBarInit("Waiting for Unity to initialize the probes...");
            while(Lightmapping.isRunning)
            {
                userCanceled = simpleProgressBarCancelled();
                if (userCanceled)
                {
                    Lightmapping.Cancel();
                    ProgressBarEnd();
                    break;
                }
                yield return null;
            }
            ProgressBarEnd();

            lms = LightmapSettings.lightmaps;
            if (lms.Length == 1 && lms[0].lightmapColor != firstLM)
            {
                // During occlusion probe rendering Unity also generated useless tiny LMs - delete them to prevent lightmap array pollution
                if (lms[0].lightmapColor != null) AssetDatabase.DeleteAsset(AssetDatabase.GetAssetPath(lms[0].lightmapColor));
                if (lms[0].lightmapDir != null) AssetDatabase.DeleteAsset(AssetDatabase.GetAssetPath(lms[0].lightmapDir));
            }

            for(int i=0; i<staticObjects.Count; i++)
            {
                var so = new SerializedObject(staticObjects[i]);
                so.FindProperty("m_ScaleInLightmap").floatValue = staticObjectsScale[i];
                so.ApplyModifiedProperties();
            }
#if USE_TERRAINS
            for(int i=0; i<staticObjectsTerrain.Count; i++)
            {
                var so = new SerializedObject(staticObjectsTerrain[i]);
                so.FindProperty("m_ScaleInLightmap").floatValue = staticObjectsScaleTerrain[i];
                so.ApplyModifiedProperties();
            }
#endif
            ftLightmaps.RefreshFull();

            if (userCanceled) yield break;
        }

        int sceneCount = SceneManager.sceneCount;
        SceneSetup[] setup = null;
        Scene scene;
        string lmdataPath = null;
        string newPath = null;
        newAssetLData = null;
#if UNITY_2017_3_OR_NEWER
#else
        Dictionary<long,long> tempID2RealID = null;
        Dictionary<long,int> realID2Channel = null;
#endif

        reflProbesValue = QualitySettings.realtimeReflectionProbes;
        QualitySettings.realtimeReflectionProbes = true;
        revertReflProbesValue = true;

        if (!useUnityForOcclsusionProbes)
        {
            setup = EditorSceneManager.GetSceneManagerSetup();
        }

        if (!useUnityForOcclsusionProbes)
        {
            if (verbose)
            {
                if (!EditorSceneManager.EnsureUntitledSceneHasBeenSaved("Please save all scenes before rendering"))
                {
                    yield break;
                }
            }
            else
            {
                EditorSceneManager.SaveOpenScenes();
            }
            var assetName = GenerateLightingDataAssetName();

            scene = EditorSceneManager.NewScene(NewSceneSetup.EmptyScene, NewSceneMode.Additive);
            SceneManager.SetActiveScene(scene);
            RenderSettings.skybox = null;
            LightmapSettings.lightmapsMode = LightmapsMode.NonDirectional;

            var probeGroupClones = new GameObject[probeGroups.Length];
            for(int i=0; i<probeGroups.Length; i++)
            {
                var g = new GameObject();
                g.transform.position = probeGroups[i].transform.position;
                g.transform.rotation = probeGroups[i].transform.rotation;
                g.transform.localScale = probeGroups[i].transform.lossyScale;
                var p = g.AddComponent<LightProbeGroup>();
                p.probePositions = probeGroups[i].probePositions;
                SceneManager.MoveGameObjectToScene(g, scene);
                probeGroupClones[i] = g;
            }

#if UNITY_2017_3_OR_NEWER
#else
            // Make sure shadowmask lights are present in LightingDataAsset together with probes
            // Occlusion channel needs to be patched later
            List<Light> maskedLightsTemp = null;
            List<Light> maskedLightsReal = null;
            if (userRenderMode == RenderMode.Shadowmask || userRenderMode == RenderMode.Subtractive)
            {
                maskedLightsTemp = new List<Light>();
                maskedLightsReal = new List<Light>();
                AllP = FindObjectsOfType(typeof(BakeryPointLight)) as BakeryPointLight[];
                All3 = FindObjectsOfType(typeof(BakeryDirectLight)) as BakeryDirectLight[];
                for(int i=0; i<All3.Length; i++)
                {
                    var obj = All3[i] as BakeryDirectLight;
                    if (!obj.enabled) continue;
                    if (!obj.shadowmask && userRenderMode == RenderMode.Shadowmask) continue;
                    var ulht = obj.GetComponent<Light>();
                    if (ulht == null) continue;
                    maskedLightsTemp.Add(AddTempShadowmaskLight(ulht, scene));
                    maskedLightsReal.Add(ulht);
                }
                for(int i=0; i<AllP.Length; i++)
                {
                    var obj = AllP[i] as BakeryPointLight;
                    if (!obj.enabled) continue;
                    if (!obj.shadowmask && userRenderMode == RenderMode.Shadowmask) continue;
                    var ulht = obj.GetComponent<Light>();
                    if (ulht == null) continue;
                    maskedLightsTemp.Add(AddTempShadowmaskLight(ulht, scene));
                    maskedLightsReal.Add(ulht);
                }
            }
            //var tempQuad = GameObject.CreatePrimitive(PrimitiveType.Quad);
            //SceneManager.MoveGameObjectToScene(tempQuad, scene);
            //GameObjectUtility.SetStaticEditorFlags(tempQuad, StaticEditorFlags.LightmapStatic);

#endif
            var bakeryRuntimePath = ftLightmaps.GetRuntimePath();
            var tempScenePath = bakeryRuntimePath + "_tempScene.unity";
            sceneSavedTestScene = scene;
			tempScenePath = "Assets/_tempScene.unity";
            sceneWasSaved = false;
            EditorSceneManager.sceneSaved += SceneSavedTest;
            var saved = EditorSceneManager.SaveScene(scene, tempScenePath);
            if (!saved)
            {
                hasAnyProbes = false;
                DebugLogError("RenderLightProbes error: can't save temporary scene");
                RestoreSceneManagerSetup(setup);
                yield break;
            }
            while(!sceneWasSaved)
            {
                yield return null;
            }
            EditorSceneManager.sceneSaved -= SceneSavedTest;

#if UNITY_2017_3_OR_NEWER
#else
            if (userRenderMode == RenderMode.Shadowmask || userRenderMode == RenderMode.Subtractive)
            {
                tempID2RealID = new Dictionary<long,long>();
                realID2Channel = new Dictionary<long,int>();
                for(int i=0; i<maskedLightsTemp.Count; i++)
                {
                    var lightTemp = maskedLightsTemp[i];
                    var lightReal = maskedLightsReal[i];
                    if (!GetLightDataForPatching(lightTemp, lightReal, ref tempID2RealID, ref realID2Channel))
                    {
                        hasAnyProbes = false;
                        DebugLogError("RenderLightProbes error: can't get light IDs");
                        RestoreSceneManagerSetup(setup);
                        yield break;
                    }
                }
            }

#endif
            var paths = new string[1];
            paths[0] = tempScenePath;
            if (!EditorApplication.SaveCurrentSceneIfUserWantsTo())
            {
                userCanceled = true;
                hasAnyProbes = false;
                RestoreSceneManagerSetup(setup);
                yield break;
            }

            Lightmapping.BakeMultipleScenes(paths);
            while(Lightmapping.isRunning) yield return null;

            var lightingDataAsset = Lightmapping.lightingDataAsset;
            if (lightingDataAsset == null)
            {
                hasAnyProbes = false;
                DebugLogError("RenderLightProbes error: lightingDataAsset was not generated");
                RestoreSceneManagerSetup(setup);
                ftLightmaps.RefreshFull();
                yield break;
            }
            lmdataPath = AssetDatabase.GetAssetPath(lightingDataAsset);
            newPath = "Assets/" + outputPath + "/" + assetName + "_probes.asset";

            // Try writing the file. If it's locked, write a copy
            bool locked = false;
            BinaryWriter ftest = null;
            try
            {
                ftest = new BinaryWriter(File.Open(newPath, FileMode.Create));
            }
            catch
            {
                var index = assetName.IndexOf("_copy");
                if (index >= 0)
                {
                    assetName = assetName.Substring(0, index);
                }
                else
                {
                    assetName += "_copy";
                }
                newPath = "Assets/" + outputPath + "/" + assetName + ".asset";
                locked = true;
            }
            if (!locked) ftest.Close();
        }

#if UNITY_2017_3_OR_NEWER
#else
        if (userRenderMode == RenderMode.Shadowmask || userRenderMode == RenderMode.Subtractive)
        {
            if (!useUnityForOcclsusionProbes)
            {
                if (!ftLightingDataGen.PatchShadowmaskLightingData(lmdataPath, newPath, ref tempID2RealID, ref realID2Channel, userRenderMode == RenderMode.Subtractive))
                {
                    try
                    {
                        File.Copy(lmdataPath, newPath, true);
                    }
                    catch
                    {
                        //success = false;
                        Debug.LogError("Failed copying LightingDataAsset");
                    }
                }
            }
        }
        else
        {
#endif
            if (!useUnityForOcclsusionProbes)
            {
            //for(int i=0; i<3; i++)
            //{
                //bool success = true;
                try
                {
                    File.Copy(lmdataPath, newPath, true);
                }
                catch
                {
                    //success = false;
                    Debug.LogError("Failed copying LightingDataAsset");
                }
                //if (success) break;
                //yield return new WaitForSeconds(1);
            //}
            }
#if UNITY_2017_3_OR_NEWER
#else
        }
#endif

        if (!useUnityForOcclsusionProbes)
        {
            AssetDatabase.Refresh();
            newAssetLData = ApplyLightingDataAsset(newPath);
            EditorSceneManager.MarkAllScenesDirty();

            EditorSceneManager.SaveOpenScenes();
            RestoreSceneManagerSetup(setup);

            //var sanityTimeout = GetTime() + 5;
            while( (sceneCount > EditorSceneManager.sceneCount || EditorSceneManager.GetSceneAt(0).path.Length == 0))// && GetTime() < sanityTimeout )
            {
                yield return null;
            }

            LoadRenderSettings(); // prevent curSector reference from unloading
            ftLightmaps.RefreshFull();
        }
    }

    IEnumerator RenderLightProbesFunc()
    {
        int maxThreads = Mathf.Max(2, System.Environment.ProcessorCount * 2);
        DebugLogInfo("Multi-threading to " + maxThreads + " threads.");
        lightProbeRenderSize = 64;
        lightProbeReadSize = 8;
        var proc = InitializeLightProbes(false);
        while (proc.MoveNext()) yield return null;
        if (!hasAnyProbes) yield break;

        var activeScene = EditorSceneManager.GetActiveScene();

        LightingDataAsset newAsset = newAssetLData;
        List<Renderer> dynamicObjects = null;
        GameObject[] go = new GameObject[maxThreads];
        ReflectionProbe[] probe = new ReflectionProbe[maxThreads];
        RenderTexture[] rt = new RenderTexture[maxThreads];
        Material mat = null;
        Texture2D[] tex = new Texture2D[maxThreads];

        Material origSkybox = RenderSettings.skybox;
        Material tempSkybox;
        string ftSkyboxShaderName = "Bakery/Skybox";

        //if (!useUnityForLightProbes)
        {
            // Disable all dynamic objects
            //var objects = UnityEngine.Object.FindObjectsOfTypeAll(typeof(GameObject));
            var objects = Resources.FindObjectsOfTypeAll(typeof(GameObject));
            dynamicObjects = new List<Renderer>();
            var dynAllowMask = forceProbeVisibility.value;
            ftBuildGraphics.InitTemporaryAreaLightArray();
            foreach (GameObject obj in objects)
            {
                if (!obj.activeInHierarchy) continue;
                var path = AssetDatabase.GetAssetPath(obj);
                if (path != "") continue; // must belond to scene
                //if ((obj.hideFlags & (HideFlags.DontSave|HideFlags.HideAndDontSave)) != 0) continue; // skip temp objects
                //if (obj.tag == "EditorOnly") continue; // skip temp objects
                ftBuildGraphics.ConvertUnityAreaLight(obj); // convert area light if it exists instead
                if ((GameObjectUtility.GetStaticEditorFlags(obj) & StaticEditorFlags.ContributeGI) != 0) continue; // skip static
                var mr = ftBuildGraphics.GetValidRenderer(obj);
                if (mr == null) continue; // must have visible mesh
                if (!mr.enabled) continue; // renderer must be on
                if ((obj.layer & dynAllowMask) != 0) continue; // don't hide renderers with forceProbeVisibility mask
                mr.enabled = false;
                dynamicObjects.Add(mr);
            }

            // Change skybox to first Skylight
            var skyLights = FindObjectsOfType(typeof(BakerySkyLight)) as BakerySkyLight[];
            BakerySkyLight firstSkyLight = null;
            for (int i = 0; i < skyLights.Length; i++)
            {
                if (skyLights[i].enabled)
                {
                    firstSkyLight = skyLights[i];
                    break;
                }
            }

            tempSkybox = new Material(Shader.Find(ftSkyboxShaderName));
            if (firstSkyLight != null)
            {
                tempSkybox.SetTexture("_Tex", firstSkyLight.cubemap as Cubemap);
                tempSkybox.SetFloat("_NoTexture", firstSkyLight.cubemap == null ? 1 : 0);
                tempSkybox.SetFloat("_Hemispherical", firstSkyLight.hemispherical ? 1 : 0);
                tempSkybox.SetFloat("_Exposure", firstSkyLight.intensity);
                tempSkybox.SetColor("_Tint", PlayerSettings.colorSpace == ColorSpace.Linear ? firstSkyLight.color : firstSkyLight.color.linear);
                tempSkybox.SetVector("_MatrixRight", firstSkyLight.transform.right);
                tempSkybox.SetVector("_MatrixUp", firstSkyLight.transform.up);
                tempSkybox.SetVector("_MatrixForward", firstSkyLight.transform.forward);
            }
            else
            {
                tempSkybox.SetFloat("_NoTexture", 1);
                tempSkybox.SetColor("_Tint", Color.black);
            }
            RenderSettings.skybox = tempSkybox;
            yield return null; // atomicjoe 2021 LTS fix?

            for (int i = 0; i < maxThreads; i++)
            {
                go[i] = new GameObject();
                probe[i] = go[i].AddComponent<ReflectionProbe>() as ReflectionProbe;
                probe[i].resolution = lightProbeRenderSize;
                probe[i].hdr = true;
                probe[i].refreshMode = ReflectionProbeRefreshMode.ViaScripting;
                probe[i].timeSlicingMode = ReflectionProbeTimeSlicingMode.NoTimeSlicing;
                probe[i].mode = ReflectionProbeMode.Realtime;
                probe[i].intensity = 0;
                probe[i].nearClipPlane = 0.0001f; // this isn't good but works so far

                rt[i] = new RenderTexture(lightProbeReadSize * 6, lightProbeReadSize, 0, RenderTextureFormat.ARGBFloat, RenderTextureReadWrite.Linear);
                tex[i] = new Texture2D(lightProbeReadSize * 6, lightProbeReadSize, TextureFormat.RGBAFloat, false, true);
            }
            if (matCubemapToStrip == null)  matCubemapToStrip = new Material(Shader.Find("Hidden/ftCubemap2Strip"));
            mat = matCubemapToStrip;
        }

        var directions = new Vector3[lightProbeReadSize * lightProbeReadSize];
        var solidAngles = new float[lightProbeReadSize * lightProbeReadSize];
        float readTexelSize = 1.0f / lightProbeReadSize;
        float weightAccum = 0;
        for (int y = 0; y < lightProbeReadSize; y++)
        {
            for (int x = 0; x < lightProbeReadSize; x++)
            {
                float u = (x / (float)(lightProbeReadSize - 1)) * 2 - 1;
                float v = (y / (float)(lightProbeReadSize - 1)) * 2 - 1;
                directions[y * lightProbeReadSize + x] = (new Vector3(u, v, 1.0f)).normalized;


                float x0 = u - readTexelSize;
                float y0 = v - readTexelSize;
                float x1 = u + readTexelSize;
                float y1 = v + readTexelSize;
                float solidAngle = AreaElement(x0, y0) - AreaElement(x0, y1) - AreaElement(x1, y0) + AreaElement(x1, y1);
                weightAccum += solidAngle;
                solidAngles[y * lightProbeReadSize + x] = solidAngle;
            }
        }
        weightAccum *= 6;
        weightAccum *= Mathf.PI;

        var probes = LightmapSettings.lightProbes;
        if (probes == null)
        {
            DebugLogError("RenderLightProbes error: no probes in LightingDataAsset");
            foreach (var d in dynamicObjects) d.enabled = true;
            RenderSettings.skybox = origSkybox;
            //RestoreSceneManagerSetup(setup);
            foreach (GameObject g in go) DestroyImmediate(g);
            //userCanceled = true;
            //ProgressBarEnd();
            bakeInProgress = false;
            yield break;
        }
        SphericalHarmonicsL2[] shs;
        //if (!useUnityForLightProbes)
        {
            shs = new SphericalHarmonicsL2[probes.count];
        }
        //else
        {
            //shs = probes.bakedProbes;
        }

        var positions = probes.positions;

        var directLights = FindObjectsOfType(typeof(BakeryDirectLight)) as BakeryDirectLight[];
        var pointLights = FindObjectsOfType(typeof(BakeryPointLight)) as BakeryPointLight[];

        if (userRenderMode == RenderMode.Indirect || userRenderMode == RenderMode.Shadowmask)
        {
            var filteredDirectLights = new List<BakeryDirectLight>();
            var filteredPointLights = new List<BakeryPointLight>();
            for (int i = 0; i < directLights.Length; i++) if (directLights[i].enabled && directLights[i].bakeToIndirect) filteredDirectLights.Add(directLights[i]);
            for (int i = 0; i < pointLights.Length; i++) if (pointLights[i].enabled && pointLights[i].bakeToIndirect) filteredPointLights.Add(pointLights[i]);
            directLights = filteredDirectLights.ToArray();
            pointLights = filteredPointLights.ToArray();
        }
        else
        {
            var filteredDirectLights = new List<BakeryDirectLight>();
            var filteredPointLights = new List<BakeryPointLight>();
            for (int i = 0; i < directLights.Length; i++) if (directLights[i].enabled) filteredDirectLights.Add(directLights[i]);
            for (int i = 0; i < pointLights.Length; i++) if (pointLights[i].enabled) filteredPointLights.Add(pointLights[i]);
            directLights = filteredDirectLights.ToArray();
            pointLights = filteredPointLights.ToArray();
        }

        bool anyDirectLightToBake = (directLights.Length > 0 || pointLights.Length > 0);// && userRenderMode == RenderMode.FullLighting;
        float[] uvpos = null;
        byte[] uvnormal = null;
        int atlasTexSize = 0;
        List<Vector3>[] dirsPerProbe = new List<Vector3>[probes.count];
        List<Vector3>[] dirColorsPerProbe = new List<Vector3>[probes.count];
        if (anyDirectLightToBake)
        {
            atlasTexSize = (int)Mathf.Ceil(Mathf.Sqrt((float)probes.count));
            atlasTexSize = (int)Mathf.Ceil(atlasTexSize / (float)tileSize) * tileSize;
            uvpos = new float[atlasTexSize * atlasTexSize * 4];
            uvnormal = new byte[atlasTexSize * atlasTexSize * 4];
        }

        userCanceled = false;
        ProgressBarInit("Rendering lightprobes...");
        yield return null;

        ftBuildGraphics.CreateSceneFolder();

        if (anyDirectLightToBake)
        {
            ProgressBarShow("Rendering lightprobes - direct...", 0, true);
            if (userCanceled)
            {
                ProgressBarEnd();
                foreach (GameObject g in go) DestroyImmediate(g);
                foreach (var d in dynamicObjects) d.enabled = true;
                RenderSettings.skybox = origSkybox;
                bakeInProgress = false;
                yield break;
            }

            for (int i = 0; i < probes.count; i++)
            {
                int x = i % atlasTexSize;
                int y = i / atlasTexSize;
                int index = y * atlasTexSize + x;
                uvpos[index * 4] = positions[i].x;
                uvpos[index * 4 + 1] = positions[i].y;
                uvpos[index * 4 + 2] = positions[i].z;
                uvpos[index * 4 + 3] = 1.0f;
                uvnormal[index * 4 + 1] = 255;
                uvnormal[index * 4 + 3] = 255;
            }

            var fpos = new BinaryWriter(File.Open(scenePath + "/uvpos_probes.dds", FileMode.Create));
            fpos.Write(ftDDS.ddsHeaderFloat4);
            var posbytes = new byte[uvpos.Length * 4];
            System.Buffer.BlockCopy(uvpos, 0, posbytes, 0, posbytes.Length);
            fpos.Write(posbytes);
            fpos.BaseStream.Seek(12, SeekOrigin.Begin);
            fpos.Write(atlasTexSize);
            fpos.Write(atlasTexSize);
            fpos.Close();

            var fnorm = new BinaryWriter(File.Open(scenePath + "/uvnormal_probes.dds", FileMode.Create));
            fnorm.Write(ftDDS.ddsHeaderRGBA8);
            fnorm.Write(uvnormal);
            fnorm.BaseStream.Seek(12, SeekOrigin.Begin);
            fnorm.Write(atlasTexSize);
            fnorm.Write(atlasTexSize);
            fnorm.Close();

            if (!ftInitialized)
            {
                ftInitialized = true;
                ftSceneDirty = true;
            }
            if (forceRebuildGeometry)
            {
                ftBuildGraphics.modifyLightmapStorage = false;
                ftBuildGraphics.forceAllAreaLightsSelfshadow = false;
                ftBuildGraphics.validateLightmapStorageImmutability = false;
                ftBuildGraphics.autosetAreaLightLMID = true;
                var exportSceneFunc = ftBuildGraphics.ExportScene((ftRenderLightmap)EditorWindow.GetWindow(typeof(ftRenderLightmap)), false);
                progressBarEnabled = true;
                while (exportSceneFunc.MoveNext())
                {
                    progressBarText = ftBuildGraphics.progressBarText;
                    progressBarPercent = ftBuildGraphics.progressBarPercent;
                    if (ftBuildGraphics.userCanceled)
                    {
                        ProgressBarEnd();
                        foreach (GameObject g in go) DestroyImmediate(g);
                        foreach (var d in dynamicObjects) d.enabled = true;
                        RenderSettings.skybox = origSkybox;
                        bakeInProgress = false;
                        yield break;
                    }
                    yield return null;
                }
                ftSceneDirty = true;
                if (ftBuildGraphics.userCanceled)
                {
                    userCanceled = ftBuildGraphics.userCanceled;
                    ProgressBarEnd();
                    foreach (GameObject g in go) DestroyImmediate(g);
                    foreach (var d in dynamicObjects)
                    {
                        if (d != null) d.enabled = true;
                    }
                    RenderSettings.skybox = origSkybox;
                    bakeInProgress = false;
                    yield break;
                }
                EditorSceneManager.MarkAllScenesDirty();
            }
            else
            {
                ValidateCurrentScene();
            }

            ftLightmaps.RefreshFull();

            CollectStorages();
            var sceneCount = SceneManager.sceneCount;
            for (int s = 0; s < sceneCount; s++)
            {
                var scene = EditorSceneManager.GetSceneAt(s);
                if (!scene.isLoaded) continue;
                storage = storages[scene];

                // Clear temp data from storage
                storage.uvBuffOffsets = new int[0];
                storage.uvBuffLengths = new int[0];
                storage.uvSrcBuff = new float[0];
                storage.uvDestBuff = new float[0];
                storage.lmrIndicesOffsets = new int[0];
                storage.lmrIndicesLengths = new int[0];
                storage.lmrIndicesBuff = new int[0];

                storage.lmGroupLODResFlags = new int[0];
                storage.lmGroupMinLOD = new int[0];
                storage.lmGroupLODMatrix = new int[0];
            }


            int LMID = 0;
            var flms = new BinaryWriter(File.Open(scenePath + "/lms.bin", FileMode.Create));
            flms.Write("probes");
            flms.Write(atlasTexSize);
            flms.Close();

            var flmlod = new BinaryWriter(File.Open(scenePath + "/lmlod.bin", FileMode.Create));
            flmlod.Write(ftBuildGraphics.sceneLodsUsed > 0 ? 0 : -1);
            flmlod.Close();

            var fsettings = new BinaryWriter(File.Open(scenePath + "/settings.bin", FileMode.Create));
            fsettings.Write(tileSize);
            fsettings.Write(false);
            fsettings.Write(false);
            fsettings.Write(deviceMask);
            fsettings.Close();

            int errCode = 0;
            for (int i = 0; i < directLights.Length; i++)
            {
                ProgressBarShow("Rendering lightprobes - direct...", i / (float)(directLights.Length + pointLights.Length), true);
                if (userCanceled)
                {
                    ProgressBarEnd();
                    foreach (GameObject g in go) DestroyImmediate(g);
                    foreach (var d in dynamicObjects) d.enabled = true;
                    RenderSettings.skybox = origSkybox;
                    bakeInProgress = false;
                    yield break;
                }
                yield return null;

                var light = directLights[i] as BakeryDirectLight;
                ftBuildLights.BuildDirectLight(light, SampleCount(light.samples), true);

                if (exeMode)
                {
                    var startInfo = new System.Diagnostics.ProcessStartInfo();
                    startInfo.Arguments = GetSunRenderMode(light, false) + " " + scenePathQuoted + " probes.dds " + PASS_HALF + " " + 0 + " " + LMID;
                    DebugLogInfo("Running ftrace " + startInfo.Arguments);
#if LAUNCH_VIA_DLL
                    var crt = ProcessCoroutine(ftraceExe, startInfo.Arguments);
                    while (crt.MoveNext())
                    {
                        if (userCanceled)
                        {
                            ProgressBarEnd();
                            foreach (GameObject g in go) DestroyImmediate(g);
                            foreach (var d in dynamicObjects) d.enabled = true;
                            RenderSettings.skybox = origSkybox;
                            bakeInProgress = false;
                            yield break;
                        }
                        yield return null;
                    }
                    if (userCanceled)
                    {
                        ProgressBarEnd();
                        foreach (GameObject g in go) DestroyImmediate(g);
                        foreach (var d in dynamicObjects) d.enabled = true;
                        RenderSettings.skybox = origSkybox;
                        bakeInProgress = false;
                        yield break;
                    }
                    errCode = lastReturnValue;
#else
                    startInfo.CreateNoWindow  = false;
                    startInfo.UseShellExecute = false;
                    startInfo.WorkingDirectory = dllPath + "/Bakery";
                    startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
                    startInfo.CreateNoWindow = true;
                    var exeProcess = System.Diagnostics.Process.Start(startInfo);
                    exeProcess.WaitForExit();
                    errCode = exeProcess.ExitCode;
#endif
                }

                if (errCode != 0)
                {
                    DebugLogError("ftrace error: " + ftErrorCodes.TranslateFtrace(errCode, rtxMode));
                    userCanceled = true;
                    foreach (GameObject g in go) DestroyImmediate(g);

                    foreach (var d in dynamicObjects) d.enabled = true;
                    RenderSettings.skybox = origSkybox;
                    bakeInProgress = false;
                    yield break;
                }

                var halfs = new ushort[atlasTexSize * atlasTexSize * 4];
                var halfBytes = new byte[halfs.Length * 2];
                var fprobes = new BinaryReader(File.Open(scenePath + "/probes.dds", FileMode.Open, FileAccess.Read));
                fprobes.BaseStream.Seek(128, SeekOrigin.Begin);
                halfBytes = fprobes.ReadBytes(halfBytes.Length);
                System.Buffer.BlockCopy(halfBytes, 0, halfs, 0, halfBytes.Length);
                fprobes.Close();

                var dir = light.transform.forward;
                float cr = 0.0f;
                float cg = 0.0f;
                float cb = 0.0f;
                for (int p = 0; p < probes.count; p++)
                {
                    cr = Mathf.HalfToFloat(halfs[p * 4]);
                    cg = Mathf.HalfToFloat(halfs[p * 4 + 1]);
                    cb = Mathf.HalfToFloat(halfs[p * 4 + 2]);
                    if (cr + cg + cb <= 0) continue;

                    if (dirsPerProbe[p] == null)
                    {
                        dirsPerProbe[p] = new List<Vector3>();
                        dirColorsPerProbe[p] = new List<Vector3>();
                    }
                    dirsPerProbe[p].Add(dir);
                    dirColorsPerProbe[p].Add(new Vector3(cr, cg, cb));
                }
            }

            for (int i = 0; i < pointLights.Length; i++)
            {
                ProgressBarShow("Rendering lightprobes - direct...", (i + directLights.Length) / (float)(directLights.Length + pointLights.Length), true);
                if (userCanceled)
                {
                    ProgressBarEnd();
                    foreach (GameObject g in go) DestroyImmediate(g);
                    foreach (var d in dynamicObjects) d.enabled = true;
                    RenderSettings.skybox = origSkybox;
                    bakeInProgress = false;
                    yield break;
                }
                yield return null;

                var light = pointLights[i] as BakeryPointLight;
                bool isError = ftBuildLights.BuildLight(light, SampleCount(light.samples), true, true); // TODO: dirty tex detection!!
                if (isError)
                {
                    ProgressBarEnd();
                    DebugLogError("BuildLight error");
                    userCanceled = true;
                    foreach (GameObject g in go) DestroyImmediate(g);

                    foreach (var d in dynamicObjects) d.enabled = true;
                    RenderSettings.skybox = origSkybox;
                    bakeInProgress = false;
                    yield break;
                }
                yield return null;

                string renderMode = GetPointLightRenderMode(light);

                if (exeMode)
                {
                    var startInfo = new System.Diagnostics.ProcessStartInfo();
                    startInfo.Arguments = renderMode + " " + scenePathQuoted + " probes.dds " + PASS_HALF + " " + 0 + " " + LMID;
                    DebugLogInfo("Running ftrace " + startInfo.Arguments);
#if LAUNCH_VIA_DLL
                    var crt = ProcessCoroutine(ftraceExe, startInfo.Arguments);
                    while (crt.MoveNext())
                    {
                        if (userCanceled)
                        {
                            ProgressBarEnd();
                            foreach (GameObject g in go) DestroyImmediate(g);
                            foreach (var d in dynamicObjects) d.enabled = true;
                            RenderSettings.skybox = origSkybox;
                            bakeInProgress = false;
                            yield break;
                        }
                        yield return null;
                    }
                    if (userCanceled)
                    {
                        ProgressBarEnd();
                        foreach (GameObject g in go) DestroyImmediate(g);
                        foreach (var d in dynamicObjects) d.enabled = true;
                        RenderSettings.skybox = origSkybox;
                        bakeInProgress = false;
                        yield break;
                    }
                    errCode = lastReturnValue;
#else
                    startInfo.CreateNoWindow  = false;
                    startInfo.UseShellExecute = false;
                    startInfo.WorkingDirectory = dllPath + "/Bakery";
                    startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
                    startInfo.CreateNoWindow = true;
                    var exeProcess = System.Diagnostics.Process.Start(startInfo);
                    exeProcess.WaitForExit();
                    errCode = exeProcess.ExitCode;
#endif
                }

                if (errCode != 0)
                {
                    ProgressBarEnd();
                    DebugLogError("ftrace error: " + ftErrorCodes.TranslateFtrace(errCode, rtxMode));
                    userCanceled = true;
                    foreach (GameObject g in go) DestroyImmediate(g);

                    foreach (var d in dynamicObjects) d.enabled = true;
                    RenderSettings.skybox = origSkybox;
                    bakeInProgress = false;
                    yield break;
                }

                var halfs = new ushort[atlasTexSize * atlasTexSize * 4];
                var halfBytes = new byte[halfs.Length * 2];
                var fprobes = new BinaryReader(File.Open(scenePath + "/probes.dds", FileMode.Open));
                fprobes.BaseStream.Seek(128, SeekOrigin.Begin);
                halfBytes = fprobes.ReadBytes(halfBytes.Length);
                System.Buffer.BlockCopy(halfBytes, 0, halfs, 0, halfBytes.Length);
                fprobes.Close();

                for (int p = 0; p < probes.count; p++)
                {
                    var dir = (positions[p] - light.transform.position).normalized;

                    float cr = Mathf.HalfToFloat(halfs[p * 4]);
                    float cg = Mathf.HalfToFloat(halfs[p * 4 + 1]);
                    float cb = Mathf.HalfToFloat(halfs[p * 4 + 2]);
                    if (cr + cg + cb <= 0) continue;

                    if (dirsPerProbe[p] == null)
                    {
                        dirsPerProbe[p] = new List<Vector3>();
                        dirColorsPerProbe[p] = new List<Vector3>();
                    }
                    dirsPerProbe[p].Add(dir);
                    dirColorsPerProbe[p].Add(new Vector3(cr, cg, cb));
                }
            }
        }

        //float numPixels = lightProbeReadSize * lightProbeReadSize * 6;

        mat.SetFloat("gammaMode", PlayerSettings.colorSpace == ColorSpace.Linear ? 0 : 1);

        var eventArgs = new ProbeEventArgs();
        System.Threading.Thread[] thread = new System.Threading.Thread[maxThreads];

        int currentThreadsCount = maxThreads;
        int lastThreadsCount;
        for (int i = 0; i < shs.Length + maxThreads; i = i + maxThreads)
        {
            lastThreadsCount = currentThreadsCount;
            currentThreadsCount = Mathf.Min(shs.Length - i, maxThreads);
            if (currentThreadsCount <= 0) {
                if (i>0) for (int th = 0; th < lastThreadsCount; th++) thread[th].Join();
                break;
            }
            for (int ip = 0; ip < currentThreadsCount; ip++)
            {
                probe[ip].transform.position = positions[i + ip];
            }

            if (OnPreRenderProbe != null)
            {
                eventArgs.pos = positions[i];
                OnPreRenderProbe.Invoke(this, eventArgs);
            }

            int[] handle = new int[currentThreadsCount];
            for (int ip = 0; ip < currentThreadsCount; ip++)
            {
                handle[ip] = probe[ip].RenderProbe();
            }
            yield return null;

            for (int ip = 0; ip < currentThreadsCount; ip++)
            {
                while (!probe[ip].IsFinishedRendering(handle[ip]))
                {
                    yield return null;
                }

                var cubemap = probe[ip].texture as RenderTexture;
                Graphics.Blit(cubemap, rt[ip], mat);
                Graphics.SetRenderTarget(rt[ip]);
                tex[ip].ReadPixels(new Rect(0, 0, lightProbeReadSize * 6, lightProbeReadSize), 0, 0, false);
                tex[ip].Apply();
            }



            for (int ip = 0; ip < currentThreadsCount; ip++)
            {
                int ii = i + ip;
                var bytes = tex[ip].GetRawTextureData();
                SphericalHarmonicsL2 sh;
                sh = new SphericalHarmonicsL2();
                sh.Clear();

                if (i > 0) for (int th = 0; th < lastThreadsCount; th++) thread[th].Join();

                thread[ip] = new System.Threading.Thread(() =>
                {
                    float[] basis = new float[9];
                    float[] pixels = new float[bytes.Length / 4];
                    System.Buffer.BlockCopy(bytes, 0, pixels, 0, bytes.Length);

                    var probeDirLights = dirsPerProbe[ii];
                    var probeDirLightColors = dirColorsPerProbe[ii];


                    for (int face = 0; face < 6; face++)
                    {
                        for (int y = 0; y < lightProbeReadSize; y++)
                        {
                            for (int x = 0; x < lightProbeReadSize; x++)
                            {
                                var dir = directions[y * lightProbeReadSize + x];
                                //Vector3 dirL;

                                var solidAngle = solidAngles[y * lightProbeReadSize + x];

                                float stx = x / (float)(lightProbeReadSize - 1);
                                stx = stx * 2 - 1;
                                float sty = y / (float)(lightProbeReadSize - 1);
                                sty = sty * 2 - 1;
                                if (face == 0)
                                {
                                    dir = new Vector3(-1, -sty, stx);
                                }
                                else if (face == 1)
                                {
                                    dir = new Vector3(1, -sty, -stx);
                                }
                                else if (face == 2)
                                {
                                    dir = new Vector3(-sty, -1, -stx);
                                }
                                else if (face == 3)
                                {
                                    dir = new Vector3(-sty, 1, stx);
                                }
                                else if (face == 4)
                                {
                                    dir = new Vector3(-stx, -sty, -1);
                                }
                                else
                                {
                                    dir = new Vector3(stx, -sty, 1);
                                }
                                dir = dir.normalized;

                                float cr = 0.0f;
                                float cg = 0.0f;
                                float cb = 0.0f;
                                int pixelAddr = y * lightProbeReadSize * 6 + x + face * lightProbeReadSize;
                                cr = pixels[pixelAddr * 4];
                                cg = pixels[pixelAddr * 4 + 1];
                                cb = pixels[pixelAddr * 4 + 2];

                                if (cr + cg + cb > 0)
                                {
                                    EvalSHBasis9(dir, ref basis);
                                    for (int b = 0; b < 9; b++)
                                    {
                                        if (b == lightProbeMaxCoeffs) break;

                                        // solidAngle is a weight for texels to account for cube shape of the cubemap (we need sphere)
                                        sh[0, b] += cr * basis[b] * solidAngle;
                                        sh[1, b] += cg * basis[b] * solidAngle;
                                        sh[2, b] += cb * basis[b] * solidAngle;
                                    }
                                }

                            }
                        }
                    }

                    if (probeDirLights != null)
                    {
                        const float norm = 2.9567930857315701067858823529412f;
                        for (int d = 0; d < probeDirLights.Count; d++)
                        {
                            var clr = probeDirLightColors[d];
                            EvalSHBasis9(-probeDirLights[d], ref basis);
                            for (int b = 0; b < 9; b++)
                            {
                                if (b == lightProbeMaxCoeffs) break;
                                sh[0, b] += clr.x * basis[b] * norm;
                                sh[1, b] += clr.y * basis[b] * norm;
                                sh[2, b] += clr.z * basis[b] * norm;
                            }
                        }
                    }

                    shs[ii] = sh;
                });

                thread[ip].IsBackground = true;
                thread[ip].Start();
            }

            ProgressBarShow("Rendering lightprobes - GI...", (i / (float)probes.count), true);
            if (userCanceled)
            {
                ProgressBarEnd();
                foreach (GameObject g in go) DestroyImmediate(g);
                foreach (var d in dynamicObjects) d.enabled = true;
                RenderSettings.skybox = origSkybox;
                bakeInProgress = false;
                yield break;
            }
            yield return null;

        }

        foreach (GameObject g in go) DestroyImmediate(g);
        foreach (var d in dynamicObjects) d.enabled = true;
        RenderSettings.skybox = origSkybox;
        if (newAsset != null) EditorUtility.SetDirty(newAsset);

        probes.bakedProbes = shs;
        EditorUtility.SetDirty(probes);

        SceneManager.SetActiveScene(activeScene);

        if (OnFinishedProbes != null)
        {
            OnFinishedProbes.Invoke(this, null);
        }

        ProgressBarEnd();

        bakeInProgress = false;
        DebugLogInfo("Finished rendering Light Probes.");
        yield break;
    }

    // Normally called within EditorApplication.update; Only use it yourself if you know what you're doing.
    public void RenderLightmapUpdate()
    {
        if (!exeMode)
        {
            while(progressFunc.MoveNext()) {}
            EditorApplication.update -= RenderLightmapUpdate;
            bakeInProgress = false;
        }
        else
        {
            if (!progressFunc.MoveNext())
            {
                EditorApplication.update -= RenderLightmapUpdate;
                bakeInProgress = false;
            }
        }
    }

    int SetupLightShadowmaskUsingBitmask(Light ulht, int bitmask, int shadowmaskGroupID, int[] channelBitsPerLayer)
    {
        int foundChannel = -1;
        if (shadowmaskGroupID > 0)
        {
            shadowmaskGroupIDToChannel.TryGetValue(shadowmaskGroupID, out foundChannel);
        }

        if (foundChannel < 0)
        {
            // Find common available channels in affected layers
            const int fourBits = 1|2|4|8;
            int commonFreeBits = 0;
            for(int layer=0; layer<32; layer++)
            {
                if ((bitmask & (1<<layer))!=0) commonFreeBits |= channelBitsPerLayer[layer];
                if (commonFreeBits == fourBits)
                {
                    if (ulht != null)
                    {
                        DebugLogWarning("Light " + ulht.name + " can't generate shadow mask (out of channels).");
                        overlappingLights.Add(ulht.gameObject);
                    }
                    return -1;
                }
            }

            // Get the first available common channel
            int firstFreeBit = -1;
            for(int bit=0; bit<4; bit++)
            {
                if ((commonFreeBits & (1<<bit)) == 0)
                {
                    firstFreeBit = bit;
                    break;
                }
            }

            foundChannel = firstFreeBit;
        }

        // Setup the light
        if (ulht != null)
        {
            if (!SetupLightShadowmask(ulht, foundChannel)) return -1;
        }

        // Mark the channel as unavailable for affected layers
        for(int layer=0; layer<32; layer++)
        {
            if ((bitmask & (1<<layer))!=0)
            {
                channelBitsPerLayer[layer] |= 1<<foundChannel;
            }
        }

        if (shadowmaskGroupID > 0)
        {
            shadowmaskGroupIDToChannel[shadowmaskGroupID] = foundChannel;
        }

        return foundChannel;
    }

    static void CollectStorages()
    {
        var sceneCount = SceneManager.sceneCount;
        storages = new Dictionary<Scene, ftLightmapsStorage>();
        for(int i=0; i<sceneCount; i++)
        {
            var scene = EditorSceneManager.GetSceneAt(i);
            if (!scene.isLoaded) continue;
            SceneManager.SetActiveScene(scene);
            var go = ftLightmaps.FindInScene("!ftraceLightmaps", scene);
            if (go == null) {
                go = new GameObject();
                go.name = "!ftraceLightmaps";
                go.hideFlags = HideFlags.HideInHierarchy;
            }
            storage = go.GetComponent<ftLightmapsStorage>();
            if (storage == null) {
                storage = go.AddComponent<ftLightmapsStorage>();
            }
            storages[scene] = storage;
        }
    }

    bool CollectGroups(List<BakeryLightmapGroup> groupList, List<BakeryLightmapGroup> groupListGIContributing, bool selected, bool probes=false)
    {
        // 1: Collect
        var sceneCount = SceneManager.sceneCount;
        var groups = new List<BakeryLightmapGroup>();

        // Find explicit LMGroups
        var groupsSelectors = FindObjectsOfType(typeof(BakeryLightmapGroupSelector)) as BakeryLightmapGroupSelector[];
        for(int i=0; i<groupsSelectors.Length; i++)
        {
            if (!groupsSelectors[i].active) continue;
            var grp = groupsSelectors[i].lmgroupAsset;
            if (grp != null && fullSectorRender && (grp as BakeryLightmapGroup).passedFilter != passedFilterFlag) continue;
            groups.Add(grp as BakeryLightmapGroup);
        }

        // Find implicit LMGroups
        for(int s=0; s<sceneCount; s++)
        {
            var scene = EditorSceneManager.GetSceneAt(s);
            if (!scene.isLoaded) continue;
            for(int i=0; i<storages[scene].implicitGroups.Count; i++)
            {
                var grp = storages[scene].implicitGroups[i] as BakeryLightmapGroup;
                groups.Add(grp);
            }
        }

        if (groups==null || groups.Count==0)
        {
            DebugLogError("Add at least one LMGroup");
            ProgressBarEnd();
            return false;
        }

        // 2: Filter
        groupListPlain = new List<BakeryLightmapGroupPlain>();
        groupListGIContributingPlain = new List<BakeryLightmapGroupPlain>();
        Object[] selObjs = null;
        if (selected)
        {
            // Selected only
            selObjs = Selection.objects;
            if (selObjs.Length == 0)
            {
                DebugLogError("No objects selected");
                ProgressBarEnd();
                return false;
            }
            for(int o=0; o<selObjs.Length; o++)
            {
                if (selObjs[o] as GameObject == null) continue;
                var selGroup = ftBuildGraphics.GetLMGroupFromObject(selObjs[o] as GameObject);
                if (selGroup == null) continue;
                if (!groupList.Contains(selGroup))
                {
                    groupList.Add(selGroup);
                    groupListPlain.Add(selGroup.GetPlainStruct());
                }
            }
            for(int i=0; i<groups.Count; i++)
            {
                var lmgroup = groups[i];
                if (lmgroup == null) continue;
                if (!groupListGIContributing.Contains(lmgroup))
                {
                    var outfile = "Assets/" + outputPathFull + "/"+lmgroup.name+"_final.hdr";
                    bool exists = File.Exists(outfile);
                    if ((!exists && lmgroup.mode != BakeryLightmapGroup.ftLMGroupMode.Vertex) && !groupList.Contains(lmgroup)) continue;
                    groupListGIContributing.Add(lmgroup);
                    groupListGIContributingPlain.Add(lmgroup.GetPlainStruct());
                }
            }
        }
        else if (probes)
        {
            // Probes only
            for(int i=0; i<groups.Count; i++)
            {
                var lmgroup = groups[i];
                if (lmgroup == null) continue;
                if (groupList.Count == 0 && lmgroup.probes)
                {
                    groupList.Add(lmgroup);
                    groupListPlain.Add(lmgroup.GetPlainStruct());
                }
                if (!groupListGIContributing.Contains(lmgroup))
                {
                    var outfile = "Assets/" + outputPathFull + "/"+lmgroup.name;
                    var dirMode = (int)lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.Auto ? (int)renderDirMode : (int)lmgroup.renderDirMode;
                    if (dirMode == (int)RenderDirMode.RNM)
                    {
                        outfile += "_RNM0.hdr";
                    }
                    else if (dirMode == (int)RenderDirMode.SH || dirMode == (int)RenderDirMode.MonoSH)
                    {
                        outfile += "_L0.hdr";
                    }
                    else
                    {
                        outfile += "_final.hdr";
                    }
                    bool exists = File.Exists(outfile);
                    if ((!exists && lmgroup.mode != BakeryLightmapGroup.ftLMGroupMode.Vertex) && !groupList.Contains(lmgroup)) continue;
                    groupListGIContributing.Add(lmgroup);
                    groupListGIContributingPlain.Add(lmgroup.GetPlainStruct());
                }
            }
            if (groupList.Count == 0)
            {
                DebugLogError("Add at least one LightProbeGroup (L1)");
                ProgressBarEnd();
                return false;
            }
        }
        else
        {
            // Full render
            for(int i=0; i<groups.Count; i++)
            {
                var lmgroup = groups[i];
                if (lmgroup == null) continue;
                if (!groupList.Contains(lmgroup))
                {
                    groupList.Add(lmgroup);
                    groupListPlain.Add(lmgroup.GetPlainStruct());
                    groupListGIContributing.Add(lmgroup);
                    groupListGIContributingPlain.Add(lmgroup.GetPlainStruct());
                }
            }
        }

        return true;
    }

    bool ValidateSamples()
    {
        int warnCount = 0;
        int warnLimit = 32;
        string warns = "";

        if (giSamples > 64 && bounces > 0)
        {
            var warn = "GI uses more than 64 samples.";
            if (warnCount < warnLimit) warns += warn + "\n";
            DebugLogWarning(warn);
            warnCount++;
        }

        if (hackAOSamples > 64 && hackAOIntensity > 0)
        {
            var warn = "AO uses more than 64 samples.";
            if (warnCount < warnLimit) warns += warn + "\n";
            DebugLogWarning(warn);
            warnCount++;
        }

        for(int i=0; i<All.Length; i++)
        {
            if (All[i].samples2 > 64 && All[i].selfShadow)
            {
                var warn = "Light " + All[i].name + " uses more than 64 near samples.";
                if (warnCount < warnLimit) warns += warn + "\n";
                DebugLogWarning(warn);
                warnCount++;
            }
            if (All[i].samples > 4096)
            {
                var warn = "Light " + All[i].name + " uses more than 4096 far samples.";
                if (warnCount < warnLimit) warns += warn + "\n";
                DebugLogWarning(warn);
                warnCount++;
            }
        }
        for(int i=0; i<AllP.Length; i++)
        {
            if (AllP[i].samples > 4096)
            {
                var warn = "Light " + AllP[i].name + " uses more than 4096 samples.";
                if (warnCount < warnLimit) warns += warn + "\n";
                DebugLogWarning(warn);
                warnCount++;
            }
        }
        for(int i=0; i<All2.Length; i++)
        {
            if (All2[i].samples > 64)
            {
                var warn = "Light " + All2[i].name + " uses more than 64 samples.";
                if (warnCount < warnLimit) warns += warn + "\n";
                DebugLogWarning(warn);
                warnCount++;
            }
        }
        for(int i=0; i<All3.Length; i++)
        {
            if (All3[i].samples > 64)
            {
                var warn = "Light " + All3[i].name + " uses more than 64 samples.";
                if (warnCount < warnLimit) warns += warn + "\n";
                DebugLogWarning(warn);
                warnCount++;
            }
        }
        if (warnCount > 0)
        {
            if (verbose)
            {
                var warnText = "Some sample count values might be out of reasonable range. Extremely high values may cause GPU go out of available resources. This validation can be disabled.\n\n";
                warnText += warns;
                if (warnCount >= warnLimit) warnText += "(See more warnings in console)";
                if (!EditorUtility.DisplayDialog("Bakery", warnText, "Continue", "Cancel"))
                {
                    return false;
                }
            }
            else
            {
                Debug.LogError("Some sample count values might be out of reasonable range");
            }
        }
        return true;
    }

    bool ValidatePrefabs()
    {
        var lmprefabs2 = FindObjectsOfType(typeof(BakeryLightmappedPrefab)) as BakeryLightmappedPrefab[];
        var lmprefabsList = new List<BakeryLightmappedPrefab>();
        int pwarnCount = 0;
        int pwarnLimit = 32;
        string pwarns = "";
        string pwarns2 = "";
        for(int i=0; i<lmprefabs2.Length; i++)
        {
            var p = lmprefabs2[i];
            if (!p.gameObject.activeInHierarchy) continue;
            if (!p.enableBaking) continue;
            if (!p.IsValid())
            {
                //if (prefabWarning)
                {
                    var warn = p.name + ": " + p.errorMessage;
                    if (pwarnCount < pwarnLimit) pwarns += warn + "\n";
                    DebugLogWarning(warn);
                    pwarnCount++;
                }
            }
            else
            {
                lmprefabsList.Add(p);
                //if (prefabWarning)
                {
                    if (pwarnCount < pwarnLimit) pwarns2 += p.name + "\n";
                    pwarnCount++;
                }
            }
        }
        if (pwarnCount > 0)
        {
            string warnText = "";
            if (pwarns2.Length > 0)
            {
                warnText += "These prefabs are going to be overwritten:\n\n" + pwarns2;
            }
            if (pwarns.Length > 0)
            {
                if (pwarns2.Length > 0) warnText += "\n\n";
                warnText += "These prefabs have baking enabled, but NOT going to be overwritten:\n\n" + pwarns;
            }
            if (warnText.Length > 0)
            {
                if (verbose)
                {
                    if (!EditorUtility.DisplayDialog("Bakery", warnText, "Continue", "Cancel"))
                    {
                        return false;
                    }
                }
                else
                {
                    Debug.LogError(warnText);
                }
            }
        }
        return true;
    }

    // Coroutine. Normally called from RenderLightmapUpdate via EditorApplication.update. Only use it yourself if you know what you're doing.
	public IEnumerator RenderLightmapFunc()
	{
        // Basic validation
        if (userRenderMode == RenderMode.Indirect && bounces < 1)
        {
            DebugLogError("Can't render indirect lightmaps, if bounces < 1");
            yield break;
        }

        if (userRenderMode == RenderMode.AmbientOcclusionOnly)
        {
            if (hackAOIntensity <= 0 || hackAOSamples <= 0)
            {
                DebugLogError("AO intensity and samples must be > 0 to render AO-only map");
                yield break;
            }

            if (renderDirMode != RenderDirMode.None && renderDirMode != RenderDirMode.DominantDirection && renderDirMode != RenderDirMode.BakedNormalMaps)
            {
                DebugLogError("AO-only mode does not support RNM or SH.");
                yield break;
            }
        }

        if (!exeMode && userRenderMode == RenderMode.Indirect)
        {
            DebugLogError("Selective baked direct lighting is not implemented in DLL mode");
            yield break;
        }

        if (verbose)
        {
            if (!EditorSceneManager.EnsureUntitledSceneHasBeenSaved("Please save all scenes before rendering"))
            {
                yield break;
            }
        }
        else
        {
            EditorSceneManager.SaveOpenScenes();
        }

        // Init probes
        bool renderProbesNow = lightProbeMode == LightProbeMode.L1 && !selectedOnly;
        if (renderProbesNow && fullSectorRender && curSector != null)
        {
            renderProbesNow = curSector.bakeChildLightProbeGroups;
        }
        if (renderProbesNow)
        {
            userCanceled = false;
            var proc = InitializeLightProbes(!probesOnlyL1);
            while(proc.MoveNext()) yield return null;
            if (probesOnlyL1 && !hasAnyProbes) yield break;
            if (userCanceled) yield break;
        }

        // Alloc new data
        if (clientMode)
        {
            ftClient.serverFileList = new List<string>();
            ftClient.serverGetFileList = new List<string>();
        }

        // Get base scene data
        var activeScene = EditorSceneManager.GetActiveScene();
        var sceneCount = SceneManager.sceneCount;

        All = FindObjectsOfType(typeof(BakeryLightMesh)) as BakeryLightMesh[];
        AllP = FindObjectsOfType(typeof(BakeryPointLight)) as BakeryPointLight[];
        All2 = FindObjectsOfType(typeof(BakerySkyLight)) as BakerySkyLight[];
        All3 = FindObjectsOfType(typeof(BakeryDirectLight)) as BakeryDirectLight[];

        if (userRenderMode == RenderMode.Shadowmask && bounces < 1)
        {
            bool anyDirect = false;
            for(int i=0; i<All3.Length; i++)
            {
                if (All3[i].bakeToIndirect)
                {
                    anyDirect = true;
                    break;
                }
            }
            if (!anyDirect)
            {
                for(int i=0; i<All2.Length; i++)
                {
                    if (All2[i].bakeToIndirect)
                    {
                        anyDirect = true;
                        break;
                    }
                }
            }
            if (!anyDirect)
            {
                for(int i=0; i<AllP.Length; i++)
                {
                    if (AllP[i].bakeToIndirect)
                    {
                        anyDirect = true;
                        break;
                    }
                }
            }
            if (!anyDirect)
            {
                for(int i=0; i<All.Length; i++)
                {
                    if (All[i].bakeToIndirect)
                    {
                        anyDirect = true;
                        break;
                    }
                }
            }
            if (!anyDirect)
            {
                DebugLogError("Can't render shadowmask lightmaps, if bounces < 1 and there are no lights contributing to directional lighting");
                yield break;
            }
        }

        // Scene data validation
        if (samplesWarning)
        {
            if (!ValidateSamples()) yield break;
        }
        if (prefabWarning)
        {
            if (!ValidatePrefabs()) yield break;
        }

        var sectors = FindObjectsOfType(typeof(BakerySector)) as BakerySector[];

        // Unused (yet?)
        if (!ftInitialized)
        {
            ftInitialized = true;
            ftSceneDirty = true;
        }

        // Create output dir
        var outDir = Application.dataPath + "/" + outputPathFull;
        if (!Directory.Exists(outDir)) Directory.CreateDirectory(outDir);

        // Init storages
        storages = new Dictionary<Scene, ftLightmapsStorage>();
        for(int i=0; i<sceneCount; i++)
        {
            var scene = EditorSceneManager.GetSceneAt(i);

#if UNITY_2017_3_OR_NEWER
            bool mustGenerateLightingDataAsset = false;
#else
            bool mustGenerateLightingDataAsset = ((userRenderMode == RenderMode.Shadowmask || userRenderMode == RenderMode.Subtractive) && scene.isDirty);
#endif
            if ((unloadScenesInDeferredMode && deferredMode && scene.isDirty) || mustGenerateLightingDataAsset)
            {
                bool cont = true;
                if (verbose)
                {
                    cont = EditorUtility.DisplayDialog("Bakery", "All open scenes must be saved. Save now?", "OK", "Cancel");
                }
                if (cont)
                {
                    EditorSceneManager.SaveOpenScenes();
                }
                else
                {
                    yield break;
                }
            }

            if (!scene.isLoaded) continue;
            SceneManager.SetActiveScene(scene);
            var go = ftLightmaps.FindInScene("!ftraceLightmaps", scene);
            if (go == null) {
                go = new GameObject();
                go.name = "!ftraceLightmaps";
                go.hideFlags = HideFlags.HideInHierarchy;
            }
            storage = go.GetComponent<ftLightmapsStorage>();
            if (storage == null) {
                storage = go.AddComponent<ftLightmapsStorage>();
            }

            // delete unused sectors from storages
            var stSectors = storage.sectors;
            if (stSectors == null) stSectors = storage.sectors = new List<ftLightmapsStorage.SectorData>();

            var newStSectors = new List<ftLightmapsStorage.SectorData>();
            ftLightmapsStorage.SectorData globalSector = null;
            for(int st=0; st<stSectors.Count; st++)
            {
                var stSectorName = stSectors[st].name;
                bool isGlobalSector = stSectorName == "$G";
                if (isGlobalSector) globalSector = stSectors[st];
                bool add = false;
                if (!isGlobalSector)
                {
                    for(int j=0; j<sectors.Length; j++)
                    {
                        if (sectors[j].name == stSectorName)
                        {
                            add = true;
                            break;
                        }
                    }
                }
                if (add) newStSectors.Add(stSectors[st]);
            }
            if (globalSector == null)
            {
                globalSector = new ftLightmapsStorage.SectorData();
                globalSector.name = "$G";
            }
            newStSectors.Insert(0, globalSector);

            // Cache global bake data as sector for merging
            globalSector.maps = storage.maps;
            globalSector.masks = storage.masks;
            globalSector.dirMaps = storage.dirMaps;
            globalSector.rnmMaps0 = storage.rnmMaps0;
            globalSector.rnmMaps1 = storage.rnmMaps1;
            globalSector.rnmMaps2 = storage.rnmMaps2;
            globalSector.mapsMode = storage.mapsMode;
            globalSector.bakedRenderers = storage.bakedRenderers;
#if USE_TERRAINS
            globalSector.bakedRenderersTerrain = storage.bakedRenderersTerrain;
            globalSector.bakedIDsTerrain = storage.bakedIDsTerrain;
            globalSector.bakedScaleOffsetTerrain = storage.bakedScaleOffsetTerrain;
#endif
            globalSector.bakedIDs = storage.bakedIDs;
            globalSector.bakedScaleOffset = storage.bakedScaleOffset;
            globalSector.bakedVertexColorMesh = storage.bakedVertexColorMesh;
            globalSector.nonBakedRenderers = storage.nonBakedRenderers;

            storage.sectors = newStSectors;

            if (renderProbesNow) restoreFromGlobalSector = true;

            storage.maps = new List<Texture2D>();
            storage.masks = new List<Texture2D>();
            storage.dirMaps = new List<Texture2D>();
            storage.rnmMaps0 = new List<Texture2D>();
            storage.rnmMaps1 = new List<Texture2D>();
            storage.rnmMaps2 = new List<Texture2D>();
            storage.mapsMode = new List<int>();
            storage.bakedLights = new List<Light>();
            storage.bakedLightChannels = new List<int>();
            storage.compressedVolumes = false;
            storage.anyVolumes = false;

            //if (forceRefresh) // removed condition to make "Export" option work in isolation
            {
                storage.serverGetFileList = new List<string>();
                storage.lightmapHasColor = new List<bool>();
                storage.lightmapHasMask = new List<int>();
                storage.lightmapHasDir = new List<bool>();
                storage.lightmapHasRNM = new List<bool>();
            }

            storage.Init(forceRefresh);

            //ftBuildGraphics.storage = storage;
            storages[scene] = storage;
        }
        SceneManager.SetActiveScene(activeScene);

        // Prepare realtime GI if needed
        if (usesRealtimeGI && !probesOnlyL1)
        {
            var store = storages[activeScene];
#if UNITY_2017_2_OR_NEWER
            if (LightmapEditorSettings.lightmapper != BUILTIN_RADIOSITY)
            {
                if (verbose)
                {
                    EditorUtility.DisplayDialog("Bakery", "'Combine with Enlighten real-time GI' is enabled, but Unity lightmapper is not set to Enlighten. Please go to Lighting settings and select it.", "OK");
                    yield break;
                }
                else
                {
                    Debug.LogError("'Combine with Enlighten real-time GI' is enabled, but Unity lightmapper is not set to Enlighten");
                }
            }
#else
            if (!store.enlightenWarningShown2)
            {
                if (verbose)
                {
                    if (!EditorUtility.DisplayDialog("Bakery", "'Combine with Enlighten real-time GI' is enabled. Make sure Unity lightmapper is set to Enlighten in the Lighting window.", "I'm sure", "Cancel"))
                    {
                        yield break;
                    }
                    store.enlightenWarningShown2 = true;
                    EditorUtility.SetDirty(store);
                }
                else
                {
                    Debug.LogError("'Combine with Enlighten real-time GI' is enabled, but Unity lightmapper is not set to Enlighten");
                }
            }
#endif

            reflectionProbes = new List<ReflectionProbe>();

            //Disable Refl probes, and Baked GI so all that we bake is Realtime GI
            Lightmapping.bakedGI = false;
            Lightmapping.realtimeGI = true;
            FindAllReflectionProbesAndDisable();

            //Bake to get the Realtime GI maps
            //Lightmapping.Bake();

            Lightmapping.BakeAsync();
            ProgressBarInit("Waiting for Enlighten...");
            while(Lightmapping.isRunning)
            {
                userCanceled = simpleProgressBarCancelled();
                if (userCanceled)
                {
                    Lightmapping.Cancel();
                    ProgressBarEnd();
                    break;
                }
                yield return null;
            }
            ProgressBarEnd();

            //Re enable probes before bakery bakes, and bakedGI
            Lightmapping.bakedGI = true;
            ReEnableReflectionProbes();
        }

        // Export scene
        if (forceRebuildGeometry)
        {
            passedFilterFlag++;

            renderSettingsStorage = FindRenderSettingsStorage();
            SaveRenderSettings();

            ftBuildGraphics.overwriteWarningSelectedOnly = selectedOnly;
            ftBuildGraphics.modifyLightmapStorage = true;
            ftBuildGraphics.forceAllAreaLightsSelfshadow = false;
            ftBuildGraphics.validateLightmapStorageImmutability = selectedOnly || probesOnlyL1;
            ftBuildGraphics.sceneNeedsToBeRebuilt = false;
            ftBuildGraphics.autosetAreaLightLMID = batchAreaLightSampleLimit == 0;
            var exportSceneFunc = ftBuildGraphics.ExportScene((ftRenderLightmap)EditorWindow.GetWindow(typeof(ftRenderLightmap)), true);
            progressBarEnabled = true;

            var estartMs = GetTimeMs();
            while(exportSceneFunc.MoveNext())
            {
                progressBarText = ftBuildGraphics.progressBarText;
                progressBarPercent = ftBuildGraphics.progressBarPercent;
                if (ftBuildGraphics.userCanceled)
                {
                    ftBuildGraphics.ProgressBarEnd(true);
                    ProgressBarEnd();
                    yield break;
                }
                yield return null;
            }

            if (ftBuildGraphics.sceneNeedsToBeRebuilt)
            {
                ftBuildGraphics.ProgressBarEnd(true);
                DebugLogError("Scene geometry/layout changed since last full bake. Use Render button instead.");
                yield break;
            }

            var ems = GetTimeMs();
            double exportTime = (ems - estartMs) / 1000.0;
            DebugLogInfo("Scene export time: " + exportTime);

            userCanceled = ftBuildGraphics.userCanceled;
            ProgressBarEnd(false);
            ftSceneDirty = true;
            if (ftBuildGraphics.userCanceled) yield break;
            SaveRenderSettings();
            EditorSceneManager.MarkAllScenesDirty();
        }
        else
        {
            if (!ValidateCurrentScene())
            {
                ProgressBarEnd();
                yield break;
            }
        }

        lmnameComposed = new Dictionary<string, bool>();

        uvBuffOffsets = storage.uvBuffOffsets;
        uvBuffLengths = storage.uvBuffLengths;
        uvSrcBuff = storage.uvSrcBuff;
        uvDestBuff = storage.uvDestBuff;
        lmrIndicesOffsets = storage.lmrIndicesOffsets;
        lmrIndicesLengths = storage.lmrIndicesLengths;
        lmrIndicesBuff = storage.lmrIndicesBuff;
        lmGroupMinLOD = storage.lmGroupMinLOD;
        lmGroupLODResFlags = storage.lmGroupLODResFlags;
        lmGroupLODMatrix = storage.lmGroupLODMatrix;

        userCanceled = false;
        ProgressBarInit("Rendering lightmaps - preparing...");
        yield return null;

        Debug.Log("Start");

        var groupList = new List<BakeryLightmapGroup>();
        var groupListGIContributing = new List<BakeryLightmapGroup>();
        if (!CollectGroups(groupList, groupListGIContributing, selectedOnly, probesOnlyL1)) yield break;

        // Prepare rendering lightmaps
        var startMs = GetTimeMs();

        var fsettings = new BinaryWriter(File.Open(scenePath + "/settings.bin", FileMode.Create));
        fsettings.Write(tileSize);
        fsettings.Write(compressedGBuffer);
        fsettings.Write(compressedOutput);
        fsettings.Write(deviceMask);
        fsettings.Close();

        if (clientMode) ftClient.serverFileList.Add("settings.bin");

        progressSteps = groupList.Count * (All.Length + AllP.Length + All2.Length + All3.Length) + // direct
                            1 + // compositing
                            bounces * groupList.Count + // GI
                            groupList.Count * 3; // denoise + fixSeams + encode
        progressStepsDone = 0;

        if (deferredMode)
        {
            deferredCommands = new List<System.Diagnostics.ProcessStartInfo>();
            deferredCommandsFallback = new Dictionary<int, List<string>>();
            deferredCommandsRebake = new Dictionary<int, BakeryLightmapGroupPlain>();
            deferredCommandsLODGen = new Dictionary<int, int>();
            deferredCommandsGIGen = new Dictionary<int, Vector3>();
            deferredCommandsHalf2VB = new Dictionary<int, BakeryLightmapGroupPlain>();
            deferredCommandsUVGB = new Dictionary<int, bool>();
            deferredFileSrc = new List<string>();
            deferredFileDest = new List<string>();
            deferredCommandDesc = new List<string>();
        }

        //if (forceRefresh) // removed condition to make "Export" option work in isolation
        {
            lightmapMasks = new List<List<List<string>>>();
            lightmapMaskLMNames = new List<List<List<string>>>();
            lightmapMaskLights = new List<List<List<Light>>>();
            lightmapMaskDenoise = new List<List<List<bool>>>();
    #if UNITY_2017_3_OR_NEWER
    #else
            maskedLights = new List<Light>();
    #endif
            lightmapHasColor = new List<bool>();
            lightmapHasMask = new List<int>();
            lightmapHasDir = new List<bool>();
            lightmapHasRNM = new List<bool>();

            foreach(var lmgroup in groupListGIContributingPlain)
            {
                var rmode = lmgroup.renderMode == (int)BakeryLightmapGroup.RenderMode.Auto ? (int)userRenderMode : (int)lmgroup.renderMode;
                var dirMode = lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.Auto ? (int)renderDirMode : (int)lmgroup.renderDirMode;
                var dominantDirMode = dirMode == (int)ftRenderLightmap.RenderDirMode.DominantDirection;
                while(lightmapMasks.Count <= lmgroup.id)
                {
                    lightmapMasks.Add(new List<List<string>>());
                    lightmapMaskLMNames.Add(new List<List<string>>());
                    lightmapMaskLights.Add(new List<List<Light>>());
                    lightmapMaskDenoise.Add(new List<List<bool>>());
                    lightmapHasColor.Add(true);
                    lightmapHasMask.Add(rmode == (int)RenderMode.Shadowmask ? 3 : 0);
                    lightmapHasDir.Add(dominantDirMode);
                    lightmapHasRNM.Add(false);
                }
            }
        }

        // Fix starting ray positions
        if (forceRebuildGeometry)
        {
            if (ftBuildGraphics.exportShaderColors)
            {
                deferredFileSrc.Add("");
                deferredFileDest.Add("");
                deferredCommands.Add(null);
                deferredCommandDesc.Add("Exporting scene - generating UV GBuffer...");
                deferredCommandsUVGB[deferredCommands.Count - 1] = true;
            }

            foreach(var lmgroup in groupList)
            {
                var nm = lmgroup.name;
                int LMID = lmgroup.id;
                if (lmgroup.mode != BakeryLightmapGroup.ftLMGroupMode.Vertex || lmgroup.fixPos3D) // skip vertex colored
                {
                    if (!adjustSamples) continue;

                    if (!pstorage.generateSmoothPos)
                    {
                        // further passes still require smooth pos, copy from pos
                        deferredFileSrc.Add(scenePath + "/uvpos_" + lmgroup.name + (ftRenderLightmap.compressedGBuffer ? ".lz4" : ".dds"));
                        deferredFileDest.Add(scenePath + "/uvsmoothpos_" + lmgroup.name + (ftRenderLightmap.compressedGBuffer ? ".lz4" : ".dds"));
                        deferredCommands.Add(null);
                        deferredCommandDesc.Add("Adjusting sample points for " + nm + " (2)...");
                    }

                    var startInfo = new System.Diagnostics.ProcessStartInfo();
                    startInfo.CreateNoWindow  = false;
                    startInfo.UseShellExecute = false;
#if !LAUNCH_VIA_DLL
                    startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
                    startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
                    startInfo.CreateNoWindow = true;
                    int fixPosPasses = PASS_FLOAT;
                    if (lmgroup.fixPos3D)
                    {
                        var mfilename = "fixPos3D_" + LMID + ".bin";
                        var mf = new BinaryWriter(File.Open(scenePath + "/" + mfilename, FileMode.Create));
                        mf.Write(lmgroup.voxelSize.x);
                        mf.Write(lmgroup.voxelSize.y);
                        mf.Write(lmgroup.voxelSize.z);
                        mf.Close();
                        startInfo.Arguments       = "fixpos3D " + scenePathQuoted + " \"" + "uvpos_" + nm +(compressedGBuffer ? ".lz4" : ".dds") + "\" " + fixPosPasses + " " + 0 + " " + LMID + " " + mfilename;
                        if (clientMode) ftClient.serverFileList.Add(mfilename);
                    }
                    else
                    {
                        startInfo.Arguments       = (pstorage.perTriangleSmoothPos ? "fixpos12 " : "fixpos12_notrimark ") + scenePathQuoted + " \"" + "uvpos_" + nm +(compressedGBuffer ? ".lz4" : ".dds") + "\" " + fixPosPasses + " " + 0 + " " + LMID + " " + Float2String(lmgroup.fakeShadowBias);
                    }

                    deferredFileSrc.Add("");
                    deferredFileDest.Add("");
                    deferredCommands.Add(startInfo);
                    deferredCommandDesc.Add("Adjusting sample points for " + nm + "...");
                }
            }
        }
        else
        {
            ValidateCurrentScene();
        }

        // Render AO if needed
        if (hackAOIntensity > 0 && hackAOSamples > 0)
        {
            foreach(var lmgroup in groupList)
            {
                var nm = lmgroup.name;
                currentGroup = lmgroup;
                bool doRender = true;

                if (doRender) {
                    DebugLogInfo("Preparing AO " + nm + " (" + (lmgroup.id+1) + "/" + groupList.Count + ")");

                    progressStepsDone++;
                    if (userCanceled)
                    {
                        ProgressBarEnd();
                        yield break;
                    }
                    yield return null;

                    if (lmgroup.probes) continue;
                    if (!RenderLMAO(lmgroup.id, nm))
                    {
                        ProgressBarEnd();
                        yield break;
                    }
                }
            }
        }

        // Mark completely baked lights
        for(int i=0; i<All3.Length; i++)
        {
            var obj = All3[i] as BakeryDirectLight;
            if (!obj.enabled) continue;
            var ulht = obj.GetComponent<Light>();
            if (ulht == null) continue;
            if (IsLightCompletelyBaked(obj.bakeToIndirect, obj.shadowmask, userRenderMode))
            {
                MarkLightAsCompletelyBaked(ulht);
            }
            else if (IsLightSubtractive(obj.bakeToIndirect, userRenderMode))
            {
                MarkLightAsSubtractive(ulht);
            }
            else if (IsLightRealtime(obj.bakeToIndirect, userRenderMode))
            {
                MarkLightAsRealtime(ulht);
            }
        }
        for(int i=0; i<AllP.Length; i++)
        {
            var obj = AllP[i] as BakeryPointLight;
            if (!obj.enabled) continue;
            var ulht = obj.GetComponent<Light>();
            //if (ulht == null) continue;
            if (IsLightCompletelyBaked(obj.bakeToIndirect, obj.shadowmask, userRenderMode))
            {
                if (ulht != null) MarkLightAsCompletelyBaked(ulht);
                obj.maskChannel = -1;
            }
            else if (IsLightSubtractive(obj.bakeToIndirect, userRenderMode))
            {
                if (ulht != null) MarkLightAsSubtractive(ulht);
                obj.maskChannel = -1;
            }
            else if (IsLightRealtime(obj.bakeToIndirect, userRenderMode))
            {
                if (ulht != null) MarkLightAsRealtime(ulht);
                obj.maskChannel = -1;
            }
        }
        for(int i=0; i<All.Length; i++)
        {
            var obj = All[i] as BakeryLightMesh;
            if (!obj.enabled) continue;
            var ulht = obj.GetComponent<Light>();
            if (ulht == null) continue;
            if (IsLightCompletelyBaked(obj.bakeToIndirect, obj.shadowmask, userRenderMode))
            {
                MarkLightAsCompletelyBaked(ulht);
                obj.maskChannel = -1;
            }
            else if (IsLightSubtractive(obj.bakeToIndirect, userRenderMode))
            {
                MarkLightAsSubtractive(ulht);
                obj.maskChannel = -1;
            }
            else if (IsLightRealtime(obj.bakeToIndirect, userRenderMode))
            {
                MarkLightAsRealtime(ulht);
                obj.maskChannel = -1;
            }
        }

        // Find intersecting light groups for shadowmask
        bool someLightsCantBeMasked = false;
        shadowmaskGroupIDToChannel = new Dictionary<int, int>();
        if (userRenderMode == RenderMode.Shadowmask)
        {
            overlappingLights = new List<GameObject>();

            //int channel = 0;
            var channelBitsPerLayer = new int[32];

            for(int i=0; i<All3.Length; i++)
            {
                var obj = All3[i] as BakeryDirectLight;
                if (!obj.enabled) continue;
                if (!obj.shadowmask) continue;
                var ulht = obj.GetComponent<Light>();
                if (ulht == null) continue;
                if (SetupLightShadowmaskUsingBitmask(ulht, obj.bitmask, 0, channelBitsPerLayer) < 0) someLightsCantBeMasked = true;
            }

            var lightsRemaining = new List<Light>();
            var lightsRemainingB = new List<LightBounds>();
            var lightChannels = new List<int>();
            var lightArrayIndices = new List<int>();
            var lightIntersections = new List<int>();
            for(int i=0; i<AllP.Length; i++)
            {
                var obj = AllP[i] as BakeryPointLight;
                if (!obj.enabled) continue;
                if (!obj.shadowmask) continue;
                var ulht = obj.GetComponent<Light>();
                if (ulht == null)
                {
                    if (!(obj.shadowmask && obj.bakeToIndirect)) continue; // when set to mask/direct/indirect, add null as light
                }
                lightsRemaining.Add(ulht);
                lightsRemainingB.Add(new LightBounds(obj));
                lightChannels.Add(-1);
                lightArrayIndices.Add(lightArrayIndices.Count);
                lightIntersections.Add(0);
            }
            for(int i=0; i<All.Length; i++)
            {
                var obj = All[i] as BakeryLightMesh;
                if (!obj.enabled) continue;
                if (!obj.shadowmask) continue;
                var ulht = obj.GetComponent<Light>();
                if (ulht == null) continue;
                lightsRemaining.Add(ulht);
                lightsRemainingB.Add(new LightBounds(obj));
                lightChannels.Add(-1);
                lightArrayIndices.Add(lightArrayIndices.Count);
                lightIntersections.Add(0);
            }

            // Sort by the intersection count
            for(int i=0; i<lightsRemaining.Count; i++)
            {
                lightIntersections[i] = 0;
                var la = lightsRemaining[i];
                var laRange = lightsRemainingB[i].cutoff;// * 2;
                //var laBounds = new Bounds(la.transform.position, new Vector3(laRange, laRange, laRange));
                var laPos = lightsRemainingB[i].center;// la.transform.position
                var laBitmask = lightsRemainingB[i].bitmask;
                for(int j=0; j<lightsRemaining.Count; j++)
                {
                    if (i == j) continue;
                    var lb = lightsRemaining[j];
                    var lbRange = lightsRemainingB[j].cutoff;// * 2;
                    var lbPos = lightsRemainingB[j].center;// lb.transform.position;
                    var lbBitmask = lightsRemainingB[j].bitmask;
                    if ((laBitmask & lbBitmask) == 0) continue;
                    if ((lbPos - laPos).sqrMagnitude < (laRange+lbRange)*(laRange+lbRange)) lightIntersections[i]++;
                    //var lbBounds = new Bounds(lb.transform.position, new Vector3(lbRange, lbRange, lbRange));
                    //if (laBounds.Intersects(lbBounds)) lightIntersections[i]++;
                }
            }
            lightArrayIndices.Sort(delegate(int a, int b)
            {
                return lightIntersections[b].CompareTo( lightIntersections[a] );
            });

            for(int i=0; i<lightsRemaining.Count; i++)
            {
                int idA = lightArrayIndices[i];
                if (lightChannels[idA] != -1) continue;

                var la = lightsRemaining[idA];
                var laRange = lightsRemainingB[idA].cutoff;// * 2;
                var laPos = lightsRemainingB[idA].center;//la.transform.position;
                //var laBounds = new Bounds(la.transform.position, new Vector3(laRange, laRange, laRange));
                var laBitmask = lightsRemainingB[idA].bitmask;

                var channelBoundsTypeAndOffset = new List<int>(); // sign is type, offset is to relevant array (+1)
                // Spherical
                var channelBoundsPos = new List<Vector3>();
                var channelBoundsRadius = new List<float>();
                // Convex
                var channelBoundsConvex = new List<Convex>();

                if (la != null && la.type == LightType.Spot)
                {
                    // Add spot geometry as pyramid
                    channelBoundsTypeAndOffset.Add(-(channelBoundsConvex.Count+1));
                    channelBoundsConvex.Add(GetSpotConvex(la.transform, la.spotAngle, la.range));
                }
                else
                {
                    // Add point geometry as sphere
                    channelBoundsTypeAndOffset.Add(channelBoundsPos.Count+1);
                    channelBoundsPos.Add(laPos);
                    channelBoundsRadius.Add(laRange);
                }

                //channelBoundsPos.Add(laPos);
                //channelBoundsRadius.Add(laRange);

                int channelSet = SetupLightShadowmaskUsingBitmask(la, laBitmask, lightsRemainingB[idA].shadowmaskGroupID, channelBitsPerLayer);
                if (channelSet < 0) someLightsCantBeMasked = true;
                if (lightsRemainingB[idA].point != null)
                {
                    lightsRemainingB[idA].point.maskChannel = channelSet;
                }
                else if (lightsRemainingB[idA].lightMesh != null)
                {
                    lightsRemainingB[idA].lightMesh.maskChannel = channelSet;
                }

                lightChannels[idA] = channelSet;
                if (la != null) DebugLogInfo("* Light " + la.name + " set to channel " + channelSet);
                //SetupLightShadowmask(la, channel);

                // Find all non-overlapping
                //for(int j=i+1; j<lightsRemaining.Count; j++)
                for(int j=0; j<lightsRemaining.Count; j++)
                {
                    int idB = lightArrayIndices[j];
                    if (lightChannels[idB] != -1) continue;
                    var lbBitmask = lightsRemainingB[idB].bitmask;
                    if ((laBitmask & lbBitmask) == 0) continue;
                    var lb = lightsRemaining[idB];
                    var lbRange = lightsRemainingB[idB].cutoff;// * 2;
                    //var lbBounds = new Bounds(lb.transform.position, new Vector3(lbRange, lbRange, lbRange));
                    var lbPos = lightsRemainingB[idB].center;// lbT.position;
                    Convex lbConvex = null;
                    var lbType = LightType.Point;
                    if (lb != null)
                    {
                        lbType = lb.type;
                        var lbT = lb.transform;
                        if (lb.type == LightType.Spot) lbConvex = GetSpotConvex(lbT, lb.spotAngle, lb.range);
                    }

                    bool intersects = false;
                    int boffset;
                    for(int k=0; k<channelBoundsTypeAndOffset.Count; k++)
                    {
                        boffset = channelBoundsTypeAndOffset[k];
                        LightType ctype = LightType.Point;
                        if (boffset < 0)
                        {
                            boffset = -boffset;
                            ctype = LightType.Spot;
                        }
                        boffset--;

                        if (lbType == LightType.Point && ctype == LightType.Point)
                        {
                            // sphere vs sphere
                            //if (channelBounds[k].Intersects(lbBounds))
                            float dist = channelBoundsRadius[boffset] + lbRange;
                            if ((channelBoundsPos[boffset] - lbPos).sqrMagnitude < dist*dist)
                            {
                                intersects = true;
                                break;
                            }
                        }
                        else if (lbType == LightType.Spot && ctype == LightType.Spot)
                        {
                            // convex vs convex
                            //Debug.Log("testing " + lb.name+" with "+channelBoundsConvex[boffset].vertices[0]);
                            if (ConvexIntersect(lbConvex, channelBoundsConvex[boffset]) && ConvexIntersect(channelBoundsConvex[boffset], lbConvex))
                            {
                                //Debug.LogError(lb.name+" intersects with "+channelBoundsConvex[boffset].vertices[0]);
                                intersects = true;
                                break;
                            }
                        }
                        else if (lbType == LightType.Spot && ctype == LightType.Point)
                        {
                            // convex vs sphere
                            if (ConvexSphereIntersect(lbConvex, channelBoundsPos[boffset], channelBoundsRadius[boffset]))
                            {
                                intersects = true;
                                break;
                            }
                        }
                        else if (lbType == LightType.Point && ctype == LightType.Spot)
                        {
                            // sphere vs convex
                            if (ConvexSphereIntersect(channelBoundsConvex[boffset], lbPos, lbRange))
                            {
                                intersects = true;
                                break;
                            }
                        }
                    }
                    if (intersects) continue;

                    if (lbType == LightType.Spot)
                    {
                        channelBoundsTypeAndOffset.Add(-(channelBoundsConvex.Count+1));
                        channelBoundsConvex.Add(lbConvex);
                    }
                    else
                    {
                        // Add point geometry as sphere
                        channelBoundsTypeAndOffset.Add(channelBoundsPos.Count+1);
                        channelBoundsPos.Add(lbPos);
                        channelBoundsRadius.Add(lbRange);
                    }
                    //channelBounds.Add(lbBounds);
                    lightChannels[idB] = channelSet;
                    if (lb != null)
                    {
                        DebugLogInfo("Light " + lb.name + " set to channel " + channelSet);
                        if (!SetupLightShadowmask(lb, channelSet)) someLightsCantBeMasked = true;
                    }
                    if (lightsRemainingB[idB].point != null)
                    {
                        lightsRemainingB[idB].point.maskChannel = channelSet;
                    }
                    else if (lightsRemainingB[idB].lightMesh != null)
                    {
                        lightsRemainingB[idB].lightMesh.maskChannel = channelSet;
                    }
                }

                //channel++;
            }
        }

        if (ftAdditionalConfig.batchPointLights)
        {
            System.Array.Sort(AllP, ComparePointLights);
        }
        if (ftAdditionalConfig.batchAreaLights)
        {
            System.Array.Sort(All, CompareAreaLights);
        }

        if (someLightsCantBeMasked)
        {
            ProgressBarEnd();
            if (verbose)
            {
                int ch = EditorUtility.DisplayDialogComplex("Bakery", "Some shadow masks can't be baked due to more than 4 masked lights overlapping. See console warnings for details. Press 'Stop and select' to select overlapping lights.", "Continue anyway", "Stop", "Stop and select");
                if (ch > 0)
                {
                    if (ch == 2)
                    {
                        Selection.objects = overlappingLights.ToArray();
                    }
                    yield break;
                }
            }
            else
            {
                Debug.LogError("Some shadow masks can't be baked due to more than 4 masked lights overlapping");
            }
        }

        ftBuildLights.InitMaps(false);

        // Render directional lighting for every lightmap (prepare)
        foreach(var lmgroup in groupList)
        {
            var nm = lmgroup.name;
            currentGroup = lmgroup;

            DebugLogInfo("Preparing (direct) lightmap " + nm + " (" + (lmgroup.id+1) + "/" + groupList.Count + ")");

            progressStepsDone++;
            if (userCanceled)
            {
                ProgressBarEnd();
                yield break;
            }
            yield return null;

            var routine = RenderLMDirect(lmgroup.id, nm, lmgroup.resolution);
            while(routine.MoveNext())
            {
                if (userCanceled)
                {
                    ProgressBarEnd();
                    yield break;
                }
                yield return null;
            }
        }

        // Save rendered light properties
        for(int i=0; i<All.Length; i++)
        {
            var obj = All[i] as BakeryLightMesh;
            if (!obj.enabled) continue;
            //if ((obj.bitmask & currentGroup.bitmask) == 0) continue;
            StoreLight(obj);
        }
        for(int i=0; i<AllP.Length; i++)
        {
            var obj = AllP[i] as BakeryPointLight;
            if (!obj.enabled) continue;
            //if ((obj.bitmask & currentGroup.bitmask) == 0) continue;
            StoreLight(obj);
        }
        for(int i=0; i<All2.Length; i++)
        {
            var obj = All2[i] as BakerySkyLight;
            if (!obj.enabled) continue;
            //if ((obj.bitmask & currentGroup.bitmask) == 0) continue;
            StoreLight(obj);
        }
        for(int i=0; i<All3.Length; i++)
        {
            var obj = All3[i] as BakeryDirectLight;
            if (!obj.enabled) continue;
            //if ((obj.bitmask & currentGroup.bitmask) == 0) continue;
            StoreLight(obj);
        }

        foreach(var lmgroup in groupList)
        {
            // Optionally compute SSS after direct lighting
            if (!lmgroup.computeSSS) continue;
            RenderLMSSS(lmgroup, bounces == 0, true);
        }

        // Render GI for every lightmap
        for(int i=0; i<bounces; i++)
        {
            foreach(var lmgroup in groupList)
            {
                var nm = lmgroup.name;
                currentGroup = lmgroup;
                bool doRender = true;

                if (doRender) {
                    DebugLogInfo("Preparing (bounce " + i + ") lightmap " + nm + " (" + (lmgroup.id+1) + "/" + groupList.Count + ")");

                    progressStepsDone++;
                    if (userCanceled)
                    {
                        ProgressBarEnd();
                        yield break;
                    }
                    yield return null;

                    var rmode = lmgroup.renderMode == BakeryLightmapGroup.RenderMode.Auto ? (int)userRenderMode : (int)lmgroup.renderMode;

                    if (rmode == (int)RenderMode.AmbientOcclusionOnly) continue;

                    bool lastPass = i == bounces - 1;
                    bool needsGIPass = (lastPass && (rmode == (int)RenderMode.Indirect || rmode == (int)RenderMode.Shadowmask));

                    var dirMode = lmgroup.renderDirMode == BakeryLightmapGroup.RenderDirMode.Auto ? (int)renderDirMode : (int)lmgroup.renderDirMode;
                    var dominantDirMode = dirMode == (int)ftRenderLightmap.RenderDirMode.DominantDirection && lightmapHasDir[lmgroup.id];

                    if (lmgroup.probes && !lastPass) continue; // probes only need final GI pass

                    if (performRendering)
                    {
                        deferredFileSrc.Add("");
                        deferredFileDest.Add("");
                        deferredCommands.Add(null);
                        deferredCommandDesc.Add("Generating GI parameters for " + lmgroup.name + "...");
                        deferredCommandsGIGen[deferredCommands.Count - 1] = new Vector3(lmgroup.id, i, dominantDirMode?1:0);

                        if (!RenderLMGI(lmgroup.id, nm, i, needsGIPass, lastPass))
                        {
                            ProgressBarEnd();
                            yield break;
                        }

                        // Optionally compute SSS after bounce
                        if (!lmgroup.computeSSS) continue;
                        RenderLMSSS(lmgroup, i == bounces - 1, false);
                    }
                }
            }
        }

        // Add directional contribution from selected lights to indirect
        //if ((userRenderMode == RenderMode.Indirect || userRenderMode == RenderMode.Shadowmask)  && performRendering)
        {
            //Debug.Log("Compositing bakeToIndirect lights with GI...");
            foreach(var lmgroup in groupListPlain)
            {
                string nm = lmgroup.name;
                try
                {
                    nm = lmgroup.name;
                }
                catch
                {
                    DebugLogError("Error postprocessing lightmaps. See console for details");
                    ProgressBarEnd();
                    throw;
                }

                var rmode = lmgroup.renderMode == (int)BakeryLightmapGroup.RenderMode.Auto ? (int)userRenderMode : (int)lmgroup.renderMode;
                if ((rmode == (int)RenderMode.Indirect || rmode == (int)RenderMode.Shadowmask) && performRendering)
                {
                    if (lmgroup.probes && bounces == 0 && rmode == (int)RenderMode.Shadowmask) continue; // special case

                    //int errCode2 = 0;
                    bool skip = false;
                    // Don't combine non-directional lightmap when baking RNM/SH with 0 bounces (won't be used)
                    if (rmode == (int)RenderMode.Shadowmask && bounces == 0)
                    {
                        bool hasRNM =  lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.RNM  ||
                                      (lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.Auto && renderDirMode == RenderDirMode.RNM);

                        bool hasSH = lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.SH || lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.MonoSH ||
                                    (lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.Auto && renderDirMode == RenderDirMode.SH) ||
                                    (lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.Auto && renderDirMode == RenderDirMode.MonoSH);

                        if (hasRNM || hasSH)
                        {
                            skip = true;
                        }
                    }

                    if (!skip)
                    {
                        if (exeMode)
                        {
                            var startInfo = new System.Diagnostics.ProcessStartInfo();
                            startInfo.CreateNoWindow  = false;
                            startInfo.UseShellExecute = false;
#if !LAUNCH_VIA_DLL
                            startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
                            startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
                            startInfo.CreateNoWindow = true;
                            startInfo.Arguments       =  "add " + scenePathQuoted + " \"" + nm + "_final_HDR" + (compressedOutput ? ".lz4" : ".dds")
                            + "\"" + " " + PASS_HALF + " " + 0 + " " + lmgroup.id + " comp_indirect" + lmgroup.id + ".bin";

                            if (deferredMode)
                            {
                                deferredFileSrc.Add("");//scenePath + "/comp_indirect" + lmgroup.id + ".bin");
                                deferredFileDest.Add("");//scenePath + "/comp.bin");
                                deferredCommands.Add(startInfo);
                                deferredCommandDesc.Add("Compositing baked lights with GI for " + lmgroup.name + "...");
                            }
                            else
                            {
                                /*File.Copy(scenePath + "/comp_indirect" + lmgroup.id + ".bin", scenePath + "/comp.bin", true);
                                Debug.Log("Running ftrace " + startInfo.Arguments);
                                var exeProcess = System.Diagnostics.Process.Start(startInfo);
                                exeProcess.WaitForExit();
                                errCode2 = exeProcess.ExitCode;*/
                            }
                        }
                    }

                    var dirMode = lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.Auto ? (int)renderDirMode : (int)lmgroup.renderDirMode;
                    var dominantDirMode = dirMode == (int)ftRenderLightmap.RenderDirMode.DominantDirection && lightmapHasDir[lmgroup.id];

                    if (dominantDirMode)
                    {
                        var startInfo = new System.Diagnostics.ProcessStartInfo();
                        startInfo.CreateNoWindow  = false;
                        startInfo.UseShellExecute = false;
#if !LAUNCH_VIA_DLL
                        startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
                        startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
                        startInfo.CreateNoWindow = true;
                        startInfo.Arguments       =  "diradd " + scenePathQuoted + " \"" + nm + "_final_Dir" + (compressedOutput ? ".lz4" : ".dds")
                        + "\"" + " " + PASS_DIRECTION + " " + 0 + " " + lmgroup.id + " dircomp_indirect" + lmgroup.id + ".bin";

                        if (deferredMode)
                        {
                            deferredFileSrc.Add("");//scenePath + "/dircomp_indirect" + lmgroup.id + ".bin");
                            deferredFileDest.Add("");//scenePath + "/dircomp.bin");
                            deferredCommands.Add(startInfo);
                            deferredCommandDesc.Add("Compositing baked direction for " + lmgroup.name + "...");
                        }
                    }
                }
            }
        }

        PrepareAssetImporting();

        // Finalize lightmaps
        foreach(var lmgroup in groupListPlain)
        {
            if (lmgroup.vertexBake && lmgroup.isImplicit && !lmgroup.probes) continue; // skip objects with scaleImLm == 0
            string nm;
            try
            {
                nm = lmgroup.name;
            }
            catch
            {
                DebugLogError("Error postprocessing lightmaps. See console for details");
                ProgressBarEnd();
                throw;
            }
            bool doRender = true;

            if (doRender) {
                //if (lmgroup.vertexBake) continue; // do it after the scene is loaded back
                DebugLogInfo("Preparing (finalize) lightmap " + nm + " (" + (lmgroup.id+1) + "/" + groupList.Count + ")");

                var routine = RenderLMFinalize(lmgroup.id, nm, lmgroup.resolution, lmgroup.vertexBake, lmgroup.renderDirMode, lmgroup.renderMode, lmgroup);
                while(routine.MoveNext())
                {
                    if (userCanceled)
                    {
                        ProgressBarEnd();
                        yield break;
                    }
                    yield return null;
                }

                if (lmgroup.probes && lmgroup.name == "volumes" && lastFoundBakeableVolumes != null && lastFoundBakeableVolumes.Length > 0)
                {
                    var vols = lastFoundBakeableVolumes;
                    int voffset = 0;

                    var denoiseMod = GetDenoiseMode();
                    var ext = (compressedOutput ? ".lz4" : ".dds");
                    for(int v=0; v<vols.Length; v++)
                    {
                        var vol = vols[v];
                        int rx = VolumeDimension(vol.resolutionX);
                        int ry = VolumeDimension(vol.resolutionY);
                        int rz = VolumeDimension(vol.resolutionZ);
                        if (vol.denoise)
                        {
                            var progressText = "Denoising volume " + vol.name + "...";
                            var startInfo = new System.Diagnostics.ProcessStartInfo();
                            startInfo.CreateNoWindow  = false;
                            startInfo.UseShellExecute = false;
                            startInfo.WorkingDirectory = "Assets/Editor/x64/Bakery";
                            startInfo.FileName        = Application.dataPath + "/Editor/x64/Bakery/denoiser"+denoiseMod+".exe";
                            startInfo.CreateNoWindow = true;
                            startInfo.Arguments      = "v ";
                            startInfo.Arguments      += "\"" + scenePath + "/volumes_final_L0" + ext +
                                                     "\" \"" + scenePath + "/volumes_final_L1x" + ext +
                                                     "\" \"" + scenePath + "/volumes_final_L1y" + ext +
                                                     "\" \"" + scenePath + "/volumes_final_L1z" + ext +
                                                     "\" " +
                                                     voffset + " " + rx + " " + ry + " " + rz + " 32 0";
                            deferredFileSrc.Add("");
                            deferredFileDest.Add("");
                            deferredCommands.Add(startInfo);
                            deferredCommandDesc.Add(progressText);
                        }

                        voffset += rx * ry * rz;
                    }

                    if (clientMode)
                    {
                        ftClient.serverGetFileList.Add("volumes_final_L0" + ext);
                        ftClient.serverGetFileList.Add("volumes_final_L1x" + ext);
                        ftClient.serverGetFileList.Add("volumes_final_L1y" + ext);
                        ftClient.serverGetFileList.Add("volumes_final_L1z" + ext);
                    }
                }
            }
        }

        // Add lightmaps split by buckets
        if (ftBuildGraphics.postPacking)
        {
            foreach(var lmgroup in groupListPlain)
            {
                //if (lmgroup.parentID != -2) continue; // parent lightmap mark
                if (lmgroup.parentName != "|") continue; // parent lightmap mark
                var nm = lmgroup.name;

                // actually have anything to pack?
                bool anything = false;
                foreach(var lmgroup2 in groupListPlain)
                {
                    if (lmgroup2.parentName == lmgroup.name)
                    {
                        anything = true;
                        break;
                    }
                }
                if (!anything) continue;

                DebugLogInfo("Preparing (add buckets) lightmap " + nm + " (" + (lmgroup.id+1) + "/" + groupList.Count + ")");

                var routine = RenderLMAddBuckets(lmgroup.id, nm, lmgroup.resolution, lmgroup.vertexBake, lmgroup.renderDirMode, lmgroup.renderMode);
                while(routine.MoveNext())
                {
                    if (userCanceled)
                    {
                        ProgressBarEnd();
                        yield break;
                    }
                    yield return null;
                }
            }
        }

        // Combine masks
        foreach(var lmgroup in groupListPlain)
        {
            if (lmgroup.vertexBake && lmgroup.isImplicit && !lmgroup.probes) continue; // skip objects with scaleImLm == 0
            string nm;
            try
            {
                nm = lmgroup.name;
            }
            catch
            {
                DebugLogError("Error postprocessing lightmaps. See console for details");
                ProgressBarEnd();
                throw;
            }
            bool doRender = true;

            if (doRender)
            {
                //if (lmgroup.vertexBake) continue; // do it after the scene is loaded back
                DebugLogInfo("Preparing (combine masks) lightmap " + nm + " (" + (lmgroup.id+1) + "/" + groupList.Count + ")");

                var routine = RenderLMCombineMasks(lmgroup.id, nm, lmgroup.resolution, lmgroup.vertexBake, lmgroup.renderMode, lmgroup);
                while(routine.MoveNext())
                {
                    if (userCanceled)
                    {
                        ProgressBarEnd();
                        yield break;
                    }
                    yield return null;
                }
            }
        }

        // Encode lightmaps
        foreach(var lmgroup in groupListPlain)
        {
            if (lmgroup.vertexBake && lmgroup.isImplicit && !lmgroup.probes) continue; // skip objects with scaleImLm == 0
            var nm = lmgroup.name;
            bool doRender = true;

            if (lmgroup.parentName != null && lmgroup.parentName.Length > 0 && lmgroup.parentName != "|")
            {
                doRender = false;
            }

            if (doRender) {
                DebugLogInfo("Preparing (encode) lightmap " + nm + " (" + (lmgroup.id+1) + "/" + groupList.Count + ")");

                var routine = RenderLMEncode(lmgroup.id, nm, lmgroup.resolution, lmgroup.vertexBake, lmgroup.renderDirMode, lmgroup.renderMode);
                while(routine.MoveNext())
                {
                    if (userCanceled)
                    {
                        ProgressBarEnd();
                        yield break;
                    }
                    yield return null;
                }
            }
        }

        ftBuildGraphics.FreeTemporaryAreaLightMeshes();

#if UNITY_2017_3_OR_NEWER
#else
        if ((userRenderMode == RenderMode.Shadowmask || userRenderMode == RenderMode.Subtractive) && (lightProbeMode != LightProbeMode.L1) || !hasAnyProbes)
        {
            // Generate lighting data asset
            var assetName = GenerateLightingDataAssetName();
            var newPath = "Assets/" + outputPath + "/" + assetName + ".asset";

            // Try writing the file. If it's locked, write a copy
            bool locked = false;
            BinaryWriter ftest = null;
            try
            {
                ftest = new BinaryWriter(File.Open(newPath, FileMode.Create));
            }
            catch
            {
                var index = assetName.IndexOf("_copy");
                if (index >= 0)
                {
                    assetName = assetName.Substring(0, index);
                }
                else
                {
                    assetName += "_copy";
                }
                newPath = "Assets/" + outputPath + "/" + assetName + ".asset";
                locked = true;
            }
            if (!locked) ftest.Close();

            if (!ftLightingDataGen.GenerateShadowmaskLightingData(newPath, ref maskedLights, userRenderMode == RenderMode.Subtractive))
            {
                DebugLogError("Failed to generate LightingDataAsset");
                userCanceled = true;
                yield break;
            }
            AssetDatabase.Refresh();
            ApplyLightingDataAsset(newPath);
            EditorSceneManager.MarkAllScenesDirty();
            EditorSceneManager.SaveOpenScenes();
        }
#endif

        // Store lightmap flags
        for(int s=0; s<sceneCount; s++)
        {
            var scene = EditorSceneManager.GetSceneAt(s);
            if (!scene.isLoaded) continue;
            storage = storages[scene];
            //if (forceRefresh) // removed condition to make "Export" option work in isolation
            {
                storage.lightmapHasColor = lightmapHasColor;
                storage.lightmapHasMask = lightmapHasMask;
                storage.lightmapHasDir = lightmapHasDir;
                storage.lightmapHasRNM = lightmapHasRNM;
                storage.serverGetFileList = ftClient.serverGetFileList;
            }
        }
        EditorSceneManager.MarkAllScenesDirty();

        // Run commands
        if (clientMode)
        {
            // Add vertex LM data to the list of requested files
            var ext = (compressedOutput ? ".lz4" : ".dds");
            foreach(var lmgroup in groupListPlain)
            {
                if (!lmgroup.vertexBake) continue;
                if (lmgroup.isImplicit) continue;

                bool hasShadowMask = lmgroup.renderMode == (int)BakeryLightmapGroup.RenderMode.Shadowmask ||
                    (lmgroup.renderMode == (int)BakeryLightmapGroup.RenderMode.Auto && userRenderMode == RenderMode.Shadowmask);

                bool hasDir = lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.DominantDirection ||
                    (lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.Auto && renderDirMode == RenderDirMode.DominantDirection);

                bool hasSH = lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.SH || lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.MonoSH ||
                    (lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.Auto && renderDirMode == RenderDirMode.SH) ||
                    (lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.Auto && renderDirMode == RenderDirMode.MonoSH);

                var lmname = lmgroup.name;

                ftClient.serverGetFileList.Add(lmname + (hasSH ? "_final_L0" : "_final_HDR") + ext);
                if (hasShadowMask) ftClient.serverGetFileList.Add(lmname + "_Mask" + ext);
                if (hasDir) ftClient.serverGetFileList.Add(lmname + "_final_Dir" + ext);
                if (hasSH)
                {
                    ftClient.serverGetFileList.Add(lmname + "_final_L1x" + ext);
                    ftClient.serverGetFileList.Add(lmname + "_final_L1y" + ext);
                    ftClient.serverGetFileList.Add(lmname + "_final_L1z" + ext);
                }
            }

            // Add probe data to requested list
            if (lightProbeMode == LightProbeMode.L1 && hasAnyProbes)
            {
                ftClient.serverGetFileList.Add("probes_final_L0" + ext);
                ftClient.serverGetFileList.Add("probes_final_L1x" + ext);
                ftClient.serverGetFileList.Add("probes_final_L1y" + ext);
                ftClient.serverGetFileList.Add("probes_final_L1z" + ext);
            }

            var flist = new BinaryWriter(File.Open(scenePath + "/renderSequence.bin", FileMode.Create));
            byte task;
            int tasks = 0;

            flist.Write(tasks);

            tasks++;
            flist.Write(ftClient.SERVERTASK_SETSCENENAME);
            WriteString(flist, EditorSceneManager.GetActiveScene().name);

            if (deferredCommandsLODGen.Count > 0)
            {
                var vbtraceTexPosNormalArray = ftBuildGraphics.vbtraceTexPosNormalArray;
                var vbtraceTexUVArray = ftBuildGraphics.vbtraceTexUVArray;
                var vbtraceTexUVArrayLOD = ftBuildGraphics.vbtraceTexUVArrayLOD;

                tasks++;
                flist.Write(ftClient.SERVERTASK_LODGENINIT);
                flist.Write(lmGroupMinLOD.Length);
                for(int j=0; j<lmGroupMinLOD.Length; j++) flist.Write(lmGroupMinLOD[j]);
                flist.Write(vbtraceTexPosNormalArray.Count);
                for(int j=0; j<vbtraceTexPosNormalArray.Count; j++) flist.Write(vbtraceTexPosNormalArray[j]);
                flist.Write(vbtraceTexUVArray.Count);
                for(int j=0; j<vbtraceTexUVArray.Count; j++) flist.Write(vbtraceTexUVArray[j]);
                flist.Write(vbtraceTexUVArrayLOD.Length);
                for(int j=0; j<vbtraceTexUVArrayLOD.Length; j++) flist.Write(vbtraceTexUVArrayLOD[j]);
            }

            for(int i=0; i<deferredCommands.Count; i++)
            {
                if (deferredFileSrc[i].Length > 0)
                {
                    tasks++;
                    flist.Write(ftClient.SERVERTASK_COPY);
                    WriteString(flist, deferredFileSrc[i].Replace(scenePath, "%SCENEPATH%"));
                    WriteString(flist, deferredFileDest[i].Replace(scenePath, "%SCENEPATH%"));
                }

                var startInfo = deferredCommands[i];
                if (startInfo != null)
                {
                    var app = Path.GetFileNameWithoutExtension(deferredCommands[i].FileName);
                    if (!ftClient.app2serverTask.TryGetValue(app, out task))
                    {
                        DebugLogError("Server doesn't support the task: " + app);
                        userCanceled = true;
                        yield break;
                    }
                    tasks++;
                    flist.Write(task);
                    WriteString(flist, startInfo.Arguments.Replace(scenePath, "%SCENEPATH%").
                        Replace(Application.dataPath + "/" + outputPathFull, "%SCENEPATH%"));
                }

                if (deferredCommandsUVGB.ContainsKey(i))
                {
                    GL.IssuePluginEvent(7); // render UVGBuffer
                    int uerr = 0;
                    while(uerr == 0)
                    {
                        uerr = ftBuildGraphics.GetUVGBErrorCode();
                        yield return null;
                    }

                    if (uerr != 0 && uerr != 99999)
                    {
                        DebugLogError("ftRenderUVGBuffer error: " + uerr);
                        userCanceled = true;
                        yield break;
                    }

                    ftBuildGraphics.FreeAlbedoCopies();
                }

                if (deferredCommandsRebake.ContainsKey(i))
                {
                    var lmgroup2 = deferredCommandsRebake[i];
                    if (lmgroup2.containsTerrains)
                    {
                        tasks++;
                        flist.Write(ftClient.SERVERTASK_LMREBAKESIMPLE);
                        WriteString(flist, lmgroup2.name + "_diffuse_HDR" + (compressedOutput ? ".lz4" : ".dds"));
                        WriteString(flist, lmgroup2.name + "_diffuse_HDR_LOD");
                        flist.Write(lmgroup2.resolution/2);
                        flist.Write(lmgroup2.resolution/2);
                        flist.Write(lmgroup2.id);
                    }
                    else
                    {
                        if (lmrIndicesLengths[lmgroup2.id] == 0)
                        {
                            Debug.LogError("lmrIndicesLengths == 0 for " + lmgroup2.name);
                        }
                        else
                        {
                            tasks++;
                            flist.Write(ftClient.SERVERTASK_LMREBAKE);
                            WriteString(flist, lmgroup2.name + "_diffuse_HDR" + (compressedOutput ? ".lz4" : ".dds"));
                            WriteString(flist, lmgroup2.name + "_diffuse_HDR_LOD");
                            WriteString(flist, "lodmask_uvpos_" + lmgroup2.name + (compressedGBuffer ? ".lz4" : ".dds"));
                            flist.Write(uvSrcBuff.Length);
                            for(int j=0; j<uvSrcBuff.Length; j++) flist.Write(uvSrcBuff[j]);
                            flist.Write(uvDestBuff.Length);
                            for(int j=0; j<uvDestBuff.Length; j++) flist.Write(uvDestBuff[j]);
                            flist.Write(uvBuffOffsets[lmgroup2.id]);
                            flist.Write(uvBuffLengths[lmgroup2.id]);
                            flist.Write(lmrIndicesBuff.Length);
                            for(int j=0; j<lmrIndicesBuff.Length; j++) flist.Write(lmrIndicesBuff[j]);
                            flist.Write(lmrIndicesOffsets[lmgroup2.id]);
                            flist.Write(lmrIndicesLengths[lmgroup2.id]);
                            flist.Write(lmgroup2.resolution/2);
                            flist.Write(lmgroup2.resolution/2);
                            flist.Write(lmgroup2.id);
                        }
                    }
                }

                if (deferredCommandsLODGen.ContainsKey(i))
                {
                    int id = deferredCommandsLODGen[i];
                    tasks++;
                    flist.Write(ftClient.SERVERTASK_LODGEN);
                    flist.Write(id);
                }

                if (deferredCommandsGIGen.ContainsKey(i))
                {
                    Vector3 paramz = deferredCommandsGIGen[i];
                    int id = (int)paramz.x;
                    int bounce = (int)paramz.y;
                    string nm = "";
                    for(int j=0; j<groupListPlain.Count; j++)
                    {
                        if (groupListPlain[j].id == id)
                        {
                            nm = groupListPlain[j].name;
                        }
                    }
                    if (nm.Length == 0)
                    {
                        DebugLogError("Error generating GI parameters for ID " + id);
                        userCanceled = true;
                        yield break;
                    }
                    tasks++;
                    flist.Write(ftClient.SERVERTASK_GIPARAMS);
                    WriteString(flist, "gi_" + nm + bounce + ".bin");
                    flist.Write(SampleCount(giSamples));
                    flist.Write(giBackFaceWeight);
                    WriteString(flist, bounce == bounces-1 ? "" : "uvalbedo_" + nm + (compressedGBuffer ? ".lz4" : ".dds"));
                    flist.Write(groupListGIContributingPlain.Count);
                    flist.Write((byte)0);// giLodModeEnabled ? (byte)1 : (byte)0);
                    flist.Write(id);
                    foreach(var lmgroup2 in groupListGIContributingPlain)
                    {
                        flist.Write(lmgroup2.id);
                        WriteString(flist, lmgroup2.name);
                        flist.Write(compressedOutput ? (byte)1 : (byte)0);
                    }
                    WriteString(flist, bounce == bounces - 1 ? (nm + "_lights_Dir" + (compressedOutput ? ".lz4" : ".dds")) : "");
                }
            }

            flist.BaseStream.Seek(0, SeekOrigin.Begin);
            flist.Write(tasks);
            flist.Close();

            var renderSequence = File.ReadAllBytes(scenePath + "/renderSequence.bin");

            try
            {
                if (!ftClient.SendRenderSequence(renderSequence))
                {
                    DebugLogError("Can't connect to server");
                    ProgressBarEnd();
                }
            }
            catch
            {
                DebugLogError("Error sending data to server");
                ProgressBarEnd();
                throw;
            }
        }
        else if (deferredMode)
        {
            DebugLogInfo("Unloading scenes...");
            if (unloadScenesInDeferredMode) UnloadScenes();
            if (unityInBatchMode)
            {
                // No WaitForEndOfFrame in batch mode
                yield return new WaitForSeconds(1);
            }
            else
            {
                yield return new WaitForEndOfFrame();
            }
            DebugLogInfo("Unloading scenes - done.");

            if (deferredCommands.Count != deferredFileSrc.Count || deferredFileSrc.Count != deferredFileDest.Count || deferredCommands.Count != deferredCommandDesc.Count)
            {
                DebugLogError("Deferred execution error");
                userCanceled = true;
                yield break;
            }

            ProgressBarSetStep(1.0f / deferredCommands.Count);
            for(int i=0; i<deferredCommands.Count; i++)
            {
                if (deferredFileSrc[i].Length > 0) File.Copy(deferredFileSrc[i], deferredFileDest[i], true);

                var startInfo = deferredCommands[i];

                if (startInfo != null)
                {
                    var app = Path.GetFileNameWithoutExtension(deferredCommands[i].FileName);
                    DebugLogInfo("Running " + app + " " + startInfo.Arguments);
                    ProgressBarShow(deferredCommandDesc[i], i / (float)deferredCommands.Count, true);
                    if (userCanceled)
                    {
                        ProgressBarEnd();
                        yield break;
                    }
                    yield return null;

                    int errCode2 = -1;
                    int fallbackCtr = 0;
                    while(errCode2 != 0)
                    {
#if LAUNCH_VIA_DLL
                        var crt = ProcessCoroutine(app, startInfo.Arguments);
                        while(crt.MoveNext()) yield return null;
                        if (userCanceled) yield break;
                        errCode2 = lastReturnValue;
#else
                        var exeProcess = System.Diagnostics.Process.Start(startInfo);

                        //exeProcess.WaitForExit();
                        while(!exeProcess.HasExited)
                        {
                            yield return null;
                            userCanceled = simpleProgressBarCancelled();
                            if (userCanceled)
                            {
                                ProgressBarEnd();
                                yield break;
                            }
                        }

                        errCode2 = exeProcess.ExitCode;
#endif

                        if (errCode2 != 0)
                        {
                            DebugLogInfo("Error: " + ftErrorCodes.Translate(app, errCode2));
                            if (deferredCommandsFallback.ContainsKey(i))
                            {
                                DebugLogInfo("Trying fallback " +fallbackCtr);
                                var fallbackList = deferredCommandsFallback[i];
                                if (fallbackCtr >= fallbackList.Count) break;
                                startInfo.Arguments = fallbackList[fallbackCtr];
                                fallbackCtr++;
                            }
                            else
                            {
                                break;
                            }
                        }
                    }

                    if (errCode2 != 0)
                    {
                        DebugLogError(app + " error: " + ftErrorCodes.Translate(app, errCode2));
                        userCanceled = true;
                        yield break;
                    }
                }

                if (deferredCommandsLODGen.ContainsKey(i))
                {
                    int id = deferredCommandsLODGen[i];
                    DebugLogInfo("Generating LOD vbTraceTex for " + id);

                    ProgressBarShow(deferredCommandDesc[i], i / (float)deferredCommands.Count, true);
                    if (userCanceled)
                    {
                        ProgressBarEnd();
                        yield break;
                    }
                    yield return null;

                    int errCode2 = GenerateVBTraceTexLOD(id);
                    if (errCode2 != 0)
                    {
                        DebugLogError("Error generating tracing mesh for ID " + id);
                        userCanceled = true;
                        yield break;
                    }
                }

                if (deferredCommandsGIGen.ContainsKey(i))
                {
                    Vector3 paramz = deferredCommandsGIGen[i];
                    int id = (int)paramz.x;
                    int bounce = (int)paramz.y;
                    bool useDir = paramz.z > 0;
                    DebugLogInfo("Generating GI parameters for " + id+" "+bounce);

                    ProgressBarShow(deferredCommandDesc[i], i / (float)deferredCommands.Count, true);
                    if (userCanceled)
                    {
                        ProgressBarEnd();
                        yield break;
                    }
                    yield return null;

                    string nm = "";
                    int sceneLodLevel = -1;
                    for(int j=0; j<groupListPlain.Count; j++)
                    {
                        if (groupListPlain[j].id == id)
                        {
                            nm = groupListPlain[j].name;
                            sceneLodLevel = groupListPlain[j].sceneLodLevel;
                        }
                    }
                    if (nm.Length == 0)
                    {
                        DebugLogError("Error generating GI parameters for ID " + id);
                        userCanceled = true;
                        yield break;
                    }
                    GenerateGIParameters(id, nm, bounce, bounces, useDir, sceneLodLevel);
                }

                if (deferredCommandsHalf2VB.ContainsKey(i))
                {
                    var gr = deferredCommandsHalf2VB[i];

                    bool hasShadowMask = gr.renderMode == (int)BakeryLightmapGroup.RenderMode.Shadowmask ||
                        (gr.renderMode == (int)BakeryLightmapGroup.RenderMode.Auto && userRenderMode == RenderMode.Shadowmask);

                    bool hasDir = gr.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.DominantDirection ||
                        (gr.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.Auto && renderDirMode == RenderDirMode.DominantDirection);

                    bool hasSH = gr.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.SH ||
                        (gr.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.Auto && renderDirMode == RenderDirMode.SH);

                    bool monoSH = gr.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.MonoSH ||
                        (gr.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.Auto && renderDirMode == RenderDirMode.MonoSH);

                    int err = GenerateVertexBakedMeshes(gr.id, gr.name, hasShadowMask, hasDir, hasSH || monoSH, monoSH);
                    if (err != 0)
                    {
                        DebugLogError("Error generating vertex color data for " + gr.name);
                        userCanceled = true;
                        yield break;
                    }
                }

                if (deferredCommandsUVGB.ContainsKey(i))
                {
                    GL.IssuePluginEvent(7); // render UVGBuffer
                    int uerr = 0;
                    while(uerr == 0)
                    {
                        uerr = ftBuildGraphics.GetUVGBErrorCode();
                        yield return null;
                    }

                    if (uerr != 0 && uerr != 99999)
                    {
                        DebugLogError("ftRenderUVGBuffer error: " + uerr);
                        userCanceled = true;
                        yield break;
                    }

                    ftBuildGraphics.FreeAlbedoCopies();
                }
            }

            ProgressBarShow("Finished rendering", 1, true);

            if (unloadScenesInDeferredMode)
            {
                LoadScenes();
                storages = new Dictionary<Scene, ftLightmapsStorage>();
                //var sanityTimeout = GetTime() + 5;
                while( (sceneCount > EditorSceneManager.sceneCount || EditorSceneManager.GetSceneAt(0).path.Length == 0))// && GetTime() < sanityTimeout )
                {
                    yield return null;
                }
                for(int i=0; i<sceneCount; i++)
                {
                    var scene = EditorSceneManager.GetSceneAt(i);
                    if (!scene.isLoaded) continue;
                    var go = ftLightmaps.FindInScene("!ftraceLightmaps", scene);
                    storage = go.GetComponent<ftLightmapsStorage>();
                    storages[scene] = storage;

                    /*if (giLodModeEnabled)
                    {
                        storage.lmGroupLODResFlags = lmGroupLODResFlags;
                        storage.lmGroupLODMatrix = lmGroupLODMatrix;
                        EditorUtility.SetDirty(storage);
                    }*/

                    if (loadedScenesActive[i]) EditorSceneManager.SetActiveScene(scene);
                }
            }
            progressStepsDone = 0;
            progressSteps = groupList.Count * 3;
            ProgressBarSetStep(0);
        }

        if (clientMode)
        {
            ProgressBarEnd();
        }
        else
        {
            LoadRenderSettings();

            var apply = ApplyBakedData();
            while(apply.MoveNext()) yield return null;

#if UNITY_2021_2_OR_NEWER
            mmfTexProc?.Dispose();
            mmfTexProc = null;
#endif

            var ms = GetTimeMs();
            double bakeTime = (ms - startMs) / 1000.0;
            DebugLogInfo("Rendering finished in " + bakeTime + " seconds");

            lastBakeTime = (int)bakeTime;
            if (renderSettingsStorage == null) renderSettingsStorage = FindRenderSettingsStorage();
            if (renderSettingsStorage != null) renderSettingsStorage.lastBakeTime = lastBakeTime;

            try
            {
                var bakeTimeLog = new StreamWriter(File.Open("bakery_times.log", FileMode.Append));
                if (bakeTimeLog != null)
                {
                    int hours = lastBakeTime / (60*60);
                    int minutes = (lastBakeTime / 60) % 60;
                    int seconds = lastBakeTime % 60;
                    bakeTimeLog.Write(System.DateTime.Now.ToString("MM/dd/yyyy HH:mm") +  " | " + EditorSceneManager.GetActiveScene().name + " | " + hours+"h "+minutes+"m "+seconds+"s\n");
                }
                bakeTimeLog.Close();
            }
            catch
            {
                Debug.LogError("Failed writing bakery_times.log");
            }

            ProgressBarEnd();

            if (beepOnFinish) System.Media.SystemSounds.Beep.Play();

            if (OnFinishedFullRender != null)
            {
                OnFinishedFullRender.Invoke(this, null);
            }
        }
    }

    Texture2D ConvertTexToAsset(Texture2D lm)
    {
        if (lm == null) return null;

        var path = AssetDatabase.GetAssetPath(lm);
        var ti = (TextureImporter)TextureImporter.GetAtPath(path);

        Texture2D lm2 = null;
        int resultingMipCount = 0;

        if (ti.mipmapEnabled && pstorage.maxAssetMip < lm.mipmapCount)
        {
            #if UNITY_2019_3_OR_NEWER
                lm2 = new Texture2D(lm.width, lm.width, lm.format, pstorage.maxAssetMip, !ti.sRGBTexture);
                resultingMipCount = pstorage.maxAssetMip;
            #else
                Debug.LogError("Textures can't be converted to mipmap-limited .asset in this Unity version. The exact threshold version is unknown, but it definitely works on >= 2019.3.");
                return lm;
            #endif
        }
        else
        {
            lm2 = new Texture2D(lm.width, lm.width, lm.format, ti.mipmapEnabled, !ti.sRGBTexture);
            resultingMipCount = lm.mipmapCount;
        }

        for(int i=0; i<resultingMipCount; i++)
        {
            Graphics.CopyTexture(lm, 0, i, lm2, 0, i);
        }

        lm2.anisoLevel = lm.anisoLevel;
        lm2.filterMode = lm.filterMode;
        lm2.wrapMode = lm.wrapMode;

        var newPath = Path.ChangeExtension(path, "asset");
        lm2 = CreateOrReplaceAsset(lm2, newPath);

        var so = new SerializedObject(lm);
        var lmFormat = so.FindProperty("m_LightmapFormat").intValue;

        so = new SerializedObject(lm2);
        so.FindProperty("m_LightmapFormat").intValue = lmFormat;
        so.ApplyModifiedProperties();

        AssetDatabase.SaveAssets();
        return AssetDatabase.LoadAssetAtPath<Texture2D>(newPath);
    }

    static public Vector3 SnapProbePos(Vector3 lpos)
    {
        const float posPrecision = 10.0f;
        const float posEpsilon = 0.0001f;
        return new Vector3((int)(lpos.x * posPrecision + (lpos.x > 0 ? posEpsilon : -posEpsilon)), (int)(lpos.y * posPrecision + (lpos.y > 0 ? posEpsilon : -posEpsilon)), (int)(lpos.z * posPrecision + (lpos.z > 0 ? posEpsilon : -posEpsilon)));
    }

    IEnumerator ApplyBakedData()
    {
        var sceneCount = EditorSceneManager.sceneCount;
        var bdataName = "BakeryPrefabLightmapData";

        // Load vertex colors
        try
        {
            foreach(var lmgroup in groupListGIContributingPlain)
            {
                if (!lmgroup.vertexBake) continue;
                if (lmgroup.isImplicit) continue;

                bool hasShadowMask = lmgroup.renderMode == (int)BakeryLightmapGroup.RenderMode.Shadowmask ||
                    (lmgroup.renderMode == (int)BakeryLightmapGroup.RenderMode.Auto && userRenderMode == RenderMode.Shadowmask);

                bool hasDir = lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.DominantDirection ||
                    (lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.Auto && renderDirMode == RenderDirMode.DominantDirection);

                bool hasSH = lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.SH ||
                    (lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.Auto && renderDirMode == RenderDirMode.SH);

                bool monoSH = lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.MonoSH ||
                    (lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.Auto && renderDirMode == RenderDirMode.MonoSH);

                GenerateVertexBakedMeshes(lmgroup.id, lmgroup.name, hasShadowMask, hasDir, hasSH || monoSH, monoSH);
            }
        }
        catch
        {
            DebugLogError("Error loading vertex colors. See console for details");
            ProgressBarEnd();
            throw;
        }

        // Set probe colors
        bool renderProbesNow = lightProbeMode == LightProbeMode.L1 && !selectedOnly;
        bool sectorOnly = false;
        if (renderProbesNow && fullSectorRender && curSector != null)
        {
            renderProbesNow = sectorOnly = curSector.bakeChildLightProbeGroups;
        }
        if (renderProbesNow && hasAnyProbes)
        {
            var probes = LightmapSettings.lightProbes;
            if (probes == null)
            {
                DebugLogError("No probes in LightingDataAsset");
                yield break;
            }
            var positions = probes.positions;
            int atlasTexSize = (int)Mathf.Ceil(Mathf.Sqrt((float)probes.count));
            atlasTexSize = (int)Mathf.Ceil(atlasTexSize / (float)tileSize) * tileSize;

            var shs = new SphericalHarmonicsL2[probes.count];

            if (sectorOnly)
            {
                // Set previous values
                Vector3 lpos;
                var origShs = storage.prevBakedProbes;
                var origShPos = storage.prevBakedProbePos;
                if (origShs != null && origShPos != null && origShs.Length == origShPos.Length && origShs.Length > 0)
                {
                    var posToSH = new Dictionary<Vector3, SphericalHarmonicsL2>();
                    int numPrevProbes = origShPos.Length;
                    for(int i=0; i<numPrevProbes; i++)
                    {
                        lpos = origShPos[i];
                        posToSH[SnapProbePos(lpos)] = origShs[i].GetSH();
                    }
                    int numPos = positions.Length;
                    SphericalHarmonicsL2 sh;
                    for(int i=0; i<numPos; i++)
                    {
                        lpos = positions[i];
                        if (posToSH.TryGetValue(SnapProbePos(lpos), out sh))
                        {
                            shs[i] = sh;
                        }
                    }
                }
            }

            int r = 0;
            int g = 1;
            int b = 2;

            var l0 = new float[atlasTexSize * atlasTexSize * 4];
            var l1x = new float[atlasTexSize * atlasTexSize * 4];
            var l1y = new float[atlasTexSize * atlasTexSize * 4];
            var l1z = new float[atlasTexSize * atlasTexSize * 4];
            var handle = GCHandle.Alloc(l0, GCHandleType.Pinned);
            var handleL1x = GCHandle.Alloc(l1x, GCHandleType.Pinned);
            var handleL1y = GCHandle.Alloc(l1y, GCHandleType.Pinned);
            var handleL1z = GCHandle.Alloc(l1z, GCHandleType.Pinned);
            var errCodes = new int[4];
            try
            {
                var pointer = handle.AddrOfPinnedObject();
                var pointerL1x = handleL1x.AddrOfPinnedObject();
                var pointerL1y = handleL1y.AddrOfPinnedObject();
                var pointerL1z = handleL1z.AddrOfPinnedObject();
                errCodes[0] = halffloat2vb(scenePath + "\\probes_final_L0" + (compressedOutput ? ".lz4" : ".dds"), pointer, 2);
                errCodes[1] = halffloat2vb(scenePath + "\\probes_final_L1x" + (compressedOutput ? ".lz4" : ".dds"), pointerL1x, 2);
                errCodes[2] = halffloat2vb(scenePath + "\\probes_final_L1y" + (compressedOutput ? ".lz4" : ".dds"), pointerL1y, 2);
                errCodes[3] = halffloat2vb(scenePath + "\\probes_final_L1z" + (compressedOutput ? ".lz4" : ".dds"), pointerL1z, 2);
                bool ok = true;
                for(int i=0; i<4; i++)
                {
                    if (errCodes[i] != 0)
                    {
                        Debug.LogError("hf2vb (" + i + "): " + errCodes[i]);
                        ok = false;
                    }
                }
                if (ok)
                {
                    for(int i=0; i<probes.count; i++)
                    {
                        if (sectorOnly)
                        {
                            var lpos = positions[i];

                            //var go = GameObject.CreatePrimitive(PrimitiveType.Sphere);
                            //go.transform.position = lpos;
                            //var lpos2 = SnapProbePos(lpos);
                            //go.name = "2 " + lpos2.x+" "+lpos2.y+" "+lpos2.z;

                            if (!sectorProbePosHash.Contains(SnapProbePos(lpos))) continue;
                        }

                        var sh = new SphericalHarmonicsL2();

                        sh[r,0] = l0[i*4+0] * 2;
                        sh[g,0] = l0[i*4+1] * 2;
                        sh[b,0] = l0[i*4+2] * 2;

                        const float convL0 = ftAdditionalConfig.convL0;
                        const float convL1 = ftAdditionalConfig.convL1;

                        // read as BGR (2,1,0)
                        sh[r,3] = (l1x[i*4+2] * 2.0f - 1.0f) * sh[r,0]*2 * convL1;
                        sh[g,3] = (l1x[i*4+1] * 2.0f - 1.0f) * sh[g,0]*2 * convL1;
                        sh[b,3] = (l1x[i*4+0] * 2.0f - 1.0f) * sh[b,0]*2 * convL1;

                        sh[r,1] = (l1y[i*4+2] * 2.0f - 1.0f) * sh[r,0]*2 * convL1;
                        sh[g,1] = (l1y[i*4+1] * 2.0f - 1.0f) * sh[g,0]*2 * convL1;
                        sh[b,1] = (l1y[i*4+0] * 2.0f - 1.0f) * sh[b,0]*2 * convL1;

                        sh[r,2] = (l1z[i*4+2] * 2.0f - 1.0f) * sh[r,0]*2 * convL1;
                        sh[g,2] = (l1z[i*4+1] * 2.0f - 1.0f) * sh[g,0]*2 * convL1;
                        sh[b,2] = (l1z[i*4+0] * 2.0f - 1.0f) * sh[b,0]*2 * convL1;

                        sh[r,0] *= convL0;
                        sh[g,0] *= convL0;
                        sh[b,0] *= convL0;

                        shs[i] = sh;
                    }
                }
            }
            finally
            {
                handle.Free();
                handleL1x.Free();
                handleL1y.Free();
                handleL1z.Free();
            }

#if UNITY_2019_3_OR_NEWER
            if (useUnityForOcclsusionProbes)
            {
                // Reload scenes or changes to LightingDataAsset are not applied (?!)
                EditorSceneManager.SaveOpenScenes();
                var setup = EditorSceneManager.GetSceneManagerSetup();
                RestoreSceneManagerSetup(setup);
                storages = new Dictionary<Scene, ftLightmapsStorage>();
                while( (sceneCount > EditorSceneManager.sceneCount || EditorSceneManager.GetSceneAt(0).path.Length == 0))// && GetTime() < sanityTimeout )
                {
                    yield return null;
                }
                for(int i=0; i<sceneCount; i++)
                {
                    var scene = EditorSceneManager.GetSceneAt(i);
                    if (!scene.isLoaded) continue;
                    var go = ftLightmaps.FindInScene("!ftraceLightmaps", scene);
                    storage = go.GetComponent<ftLightmapsStorage>();
                    storages[scene] = storage;
                }
            }
#endif

            probes.bakedProbes = shs;
            EditorUtility.SetDirty(Lightmapping.lightingDataAsset);

            var shs2 = new ftLightmapsStorage.L2[shs.Length];
            for(int i=0; i<shs.Length; i++)
            {
                shs2[i] = new ftLightmapsStorage.L2();
                shs2[i].SetSH(shs[i]);
            }
            storage.prevBakedProbes = shs2;
            storage.prevBakedProbePos = positions;
        }

        LoadVolumes();

        //EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
        EditorSceneManager.MarkAllScenesDirty();

        // Asset importing stage 1: set AssetPostprocessor settings -> moved

        // Asset importing stage 2: actual import
        AssetDatabase.Refresh();
        ftTextureProcessor.texSettings = new Dictionary<string, Int2>();

        // Asset importing stage 3: load and assign imported assets
        foreach(var lmgroup in groupListGIContributingPlain)
        {
            if (lmgroup.vertexBake) continue;
            if (lmgroup.parentName != null && lmgroup.parentName.Length > 0 && lmgroup.parentName != "|") continue;
            var nm = lmgroup.name;

            var dirMode = lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.Auto ? (int)renderDirMode : (int)lmgroup.renderDirMode;
            var dominantDirMode = dirMode == (int)ftRenderLightmap.RenderDirMode.DominantDirection && lightmapHasDir[lmgroup.id];
            var rnmMode = dirMode == (int)ftRenderLightmap.RenderDirMode.RNM && lightmapHasRNM[lmgroup.id];
            var shMode = (dirMode == (int)ftRenderLightmap.RenderDirMode.SH || dirMode == (int)ftRenderLightmap.RenderDirMode.MonoSH) && lightmapHasRNM[lmgroup.id];
            var monoSH = dirMode == (int)ftRenderLightmap.RenderDirMode.MonoSH;
            var shModeProbe = dirMode == (int)BakeryLightmapGroup.RenderDirMode.ProbeSH && lightmapHasRNM[lmgroup.id];
            if (shModeProbe) shMode = true;

            Texture2D lm = null;
            var outfile = "Assets/" + outputPathFull + "/"+nm+"_final.hdr";
            if (rnmMode) outfile = "Assets/" + outputPathFull + "/"+nm+"_RNM0.hdr";
            if (lightmapHasColor[lmgroup.id] && File.Exists(outfile))
            {
                lm = AssetDatabase.LoadAssetAtPath(outfile, typeof(Texture2D)) as Texture2D;
                if (pstorage.formatHDR == BakeryProjectSettings.FileFormatHDR.Asset)
                {
                    lm = ConvertTexToAsset(lm);
                }
            }

            Texture2D mask = null;
            if (lightmapHasMask[lmgroup.id] > 0)
            {
                outfile = "Assets/" + outputPathFull + "/"+nm+"_mask" + (pstorage.format8bit == BakeryProjectSettings.FileFormat.PNG ? ".png" : ".tga");
                if (File.Exists(outfile))
                {
                    mask = AssetDatabase.LoadAssetAtPath(outfile, typeof(Texture2D)) as Texture2D;
                    if (pstorage.format8bit == BakeryProjectSettings.FileFormat.Asset)
                    {
                        mask = ConvertTexToAsset(mask);
                    }
                }
            }

            Texture2D dirLightmap = null;
            if (dominantDirMode)
            {
                outfile = "Assets/" + outputPathFull + "/"+nm+"_dir" + (pstorage.format8bit == BakeryProjectSettings.FileFormat.PNG ? ".png" : ".tga");
                if (File.Exists(outfile))
                {
                    dirLightmap = AssetDatabase.LoadAssetAtPath(outfile, typeof(Texture2D)) as Texture2D;
                    if (pstorage.format8bit == BakeryProjectSettings.FileFormat.Asset)
                    {
                        dirLightmap = ConvertTexToAsset(dirLightmap);
                    }
                }
            }

            if (monoSH)
            {
                outfile = "Assets/" + outputPathFull + "/"+nm+"_L1" + (pstorage.format8bit == BakeryProjectSettings.FileFormat.PNG ? ".png" : ".tga");
                if (File.Exists(outfile))
                {
                    dirLightmap = AssetDatabase.LoadAssetAtPath(outfile, typeof(Texture2D)) as Texture2D;
                    if (pstorage.format8bit == BakeryProjectSettings.FileFormat.Asset)
                    {
                        dirLightmap = ConvertTexToAsset(dirLightmap);
                    }
                }
            }

            Texture2D rnmLightmap0 = null;
            Texture2D rnmLightmap1 = null;
            Texture2D rnmLightmap2 = null;
            if (rnmMode)
            {
                for(int c=0; c<3; c++)
                {
                    outfile = "Assets/" + outputPathFull + "/"+nm+"_RNM" + c + ".hdr";
                    if (c == 0)
                    {
                        rnmLightmap0 = AssetDatabase.LoadAssetAtPath(outfile, typeof(Texture2D)) as Texture2D;
                        if (pstorage.formatHDR == BakeryProjectSettings.FileFormatHDR.Asset) rnmLightmap0 = ConvertTexToAsset(rnmLightmap0);
                    }
                    if (c == 1)
                    {
                        rnmLightmap1 = AssetDatabase.LoadAssetAtPath(outfile, typeof(Texture2D)) as Texture2D;
                        if (pstorage.formatHDR == BakeryProjectSettings.FileFormatHDR.Asset) rnmLightmap1 = ConvertTexToAsset(rnmLightmap1);
                    }
                    if (c == 2)
                    {
                        rnmLightmap2 = AssetDatabase.LoadAssetAtPath(outfile, typeof(Texture2D)) as Texture2D;
                        if (pstorage.formatHDR == BakeryProjectSettings.FileFormatHDR.Asset) rnmLightmap2 = ConvertTexToAsset(rnmLightmap2);
                    }
                }
            }

            if (shMode)
            {
                outfile = "Assets/" + outputPathFull + "/"+nm+"_L0.hdr";
                lm = AssetDatabase.LoadAssetAtPath(outfile, typeof(Texture2D)) as Texture2D;
                if (pstorage.formatHDR == BakeryProjectSettings.FileFormatHDR.Asset)
                {
                    lm = ConvertTexToAsset(lm);
                }
                for(int c=0; c<3; c++)
                {
                    string comp;
                    if (c==0)
                    {
                        comp = "x";
                    }
                    else if (c==1)
                    {
                        comp = "y";
                    }
                    else
                    {
                        comp = "z";
                    }
                    outfile = "Assets/" + outputPathFull + "/"+nm+"_L1" + comp + (pstorage.format8bit == BakeryProjectSettings.FileFormat.PNG ? ".png" : ".tga");
                    if (c == 0)
                    {
                        rnmLightmap0 = AssetDatabase.LoadAssetAtPath(outfile, typeof(Texture2D)) as Texture2D;
                        if (pstorage.formatHDR == BakeryProjectSettings.FileFormatHDR.Asset) rnmLightmap0 = ConvertTexToAsset(rnmLightmap0);
                    }
                    if (c == 1)
                    {
                        rnmLightmap1 = AssetDatabase.LoadAssetAtPath(outfile, typeof(Texture2D)) as Texture2D;
                        if (pstorage.formatHDR == BakeryProjectSettings.FileFormatHDR.Asset) rnmLightmap1 = ConvertTexToAsset(rnmLightmap1);
                    }
                    if (c == 2)
                    {
                        rnmLightmap2 = AssetDatabase.LoadAssetAtPath(outfile, typeof(Texture2D)) as Texture2D;
                        if (pstorage.formatHDR == BakeryProjectSettings.FileFormatHDR.Asset) rnmLightmap2 = ConvertTexToAsset(rnmLightmap2);
                    }
                }
            }

            for(int s=0; s<sceneCount; s++)
            {
                var scene = EditorSceneManager.GetSceneAt(s);
                if (!scene.isLoaded) continue;
                if (!storages.TryGetValue(scene, out storage))
                {
                    Debug.LogError("Scene " + scene.name + " is not in the storage map (wasn't loaded before rendering?)");
                    continue;
                }

                storage.anyVolumes = hasAnyVolumes;
                storage.compressedVolumes = compressVolumes;

                while(storage.maps.Count <= lmgroup.id)
                {
                    storage.maps.Add(null);
                }
                storage.maps[lmgroup.id] = lm;

                if (userRenderMode == RenderMode.Shadowmask)
                {
                    while(storage.masks.Count <= lmgroup.id)
                    {
                        storage.masks.Add(null);
                    }
                    storage.masks[lmgroup.id] = mask;
                }

                if (dominantDirMode || monoSH)
                {
                    while(storage.dirMaps.Count <= lmgroup.id)
                    {
                        storage.dirMaps.Add(null);
                    }
                    storage.dirMaps[lmgroup.id] = dirLightmap;
                }

                if (rnmMode || (shMode && !monoSH))
                {
                    while(storage.rnmMaps0.Count <= lmgroup.id)
                    {
                        storage.rnmMaps0.Add(null);
                    }
                    storage.rnmMaps0[lmgroup.id] = rnmLightmap0;

                    while(storage.rnmMaps1.Count <= lmgroup.id)
                    {
                        storage.rnmMaps1.Add(null);
                    }
                    storage.rnmMaps1[lmgroup.id] = rnmLightmap1;

                    while(storage.rnmMaps2.Count <= lmgroup.id)
                    {
                        storage.rnmMaps2.Add(null);
                    }
                    storage.rnmMaps2[lmgroup.id] = rnmLightmap2;

                    while(storage.mapsMode.Count <= lmgroup.id)
                    {
                        storage.mapsMode.Add(0);
                    }
                    storage.mapsMode[lmgroup.id] = rnmMode ? 2 : 3;
                }

                // Clear temp data from storage
                storage.uvBuffOffsets = new int[0];
                storage.uvBuffLengths = new int[0];
                storage.uvSrcBuff = new float[0];
                storage.uvDestBuff = new float[0];
                storage.lmrIndicesOffsets = new int[0];
                storage.lmrIndicesLengths = new int[0];
                storage.lmrIndicesBuff = new int[0];

                storage.lmGroupLODResFlags = new int[0];
                storage.lmGroupMinLOD = new int[0];
                storage.lmGroupLODMatrix = new int[0];
            }
        }

        if (curSector != null && curSectorName.Length > 0)
        {
            for(int s=0; s<sceneCount; s++)
            {
                var scene = EditorSceneManager.GetSceneAt(s);
                if (!scene.isLoaded) continue;
                storage = storages[scene];

                // Copy lightmap mappings to sector data
                if (storage.sectors == null) storage.sectors = new List<ftLightmapsStorage.SectorData>();
                ftLightmapsStorage.SectorData sect = null;
                for(int sc=0; sc<storage.sectors.Count; sc++)
                {
                    if (storage.sectors[sc].name == curSectorName)
                    {
                        sect = storage.sectors[sc];
                        break;
                    }
                }
                if (sect == null)
                {
                    sect = new ftLightmapsStorage.SectorData();
                    sect.name = curSectorName;
                    storage.sectors.Add(sect);
                }
                sect.maps = storage.maps;
                sect.masks = storage.masks;
                sect.dirMaps = storage.dirMaps;
                sect.rnmMaps0 = storage.rnmMaps0;
                sect.rnmMaps1 = storage.rnmMaps1;
                sect.rnmMaps2 = storage.rnmMaps2;
                sect.mapsMode = storage.mapsMode;
                sect.bakedRenderers = storage.bakedRenderers;
#if USE_TERRAINS
                sect.bakedRenderersTerrain = storage.bakedRenderersTerrain;
                sect.bakedIDsTerrain = storage.bakedIDsTerrain;
                sect.bakedScaleOffsetTerrain = storage.bakedScaleOffsetTerrain;
#endif
                sect.bakedIDs = storage.bakedIDs;
                sect.bakedScaleOffset = storage.bakedScaleOffset;
                sect.bakedVertexColorMesh = storage.bakedVertexColorMesh;
                sect.nonBakedRenderers = storage.nonBakedRenderers;
            }
        }

        if (fullSectorRender || selectedOnly || probesOnlyL1)
        {
            MergeSectors();
        }

        // Remove unused lightmaps and remap IDs
        if (sceneCount > 1 && removeDuplicateLightmaps)
        {
            for(int s=0; s<sceneCount; s++)
            {
                var scene = EditorSceneManager.GetSceneAt(s);
                if (!scene.isLoaded) continue;
                storage = storages[scene];
                var usedIDs = new Dictionary<int, bool>();
                var origID2New = new Dictionary<int, int>();
                for(int i=0; i<storage.bakedIDs.Count; i++)
                {
                    if (storage.bakedIDs[i] < 0 || storage.bakedIDs[i] > storage.maps.Count) continue;
                    usedIDs[storage.bakedIDs[i]] = true;
                }
#if USE_TERRAINS
                for(int i=0; i<storage.bakedIDsTerrain.Count; i++)
                {
                    if (storage.bakedIDsTerrain[i] < 0 || storage.bakedIDsTerrain[i] > storage.maps.Count) continue;
                    usedIDs[storage.bakedIDsTerrain[i]] = true;
                }
#endif
                var newMaps = new List<Texture2D>();
                var newMasks = new List<Texture2D>();
                var newDirMaps = new List<Texture2D>();
                var newRNM0Maps = new List<Texture2D>();
                var newRNM1Maps = new List<Texture2D>();
                var newRNM2Maps = new List<Texture2D>();
                var newMapsMode = new List<int>();
                foreach(var pair in usedIDs)
                {
                    int origID = pair.Key;
                    int newID = newMaps.Count;
                    origID2New[origID] = newID;

                    newMaps.Add(storage.maps[origID]);
                    if (storage.masks.Count > origID) newMasks.Add(storage.masks[origID]);
                    if (storage.dirMaps.Count > origID) newDirMaps.Add(storage.dirMaps[origID]);
                    if (storage.rnmMaps0.Count > origID)
                    {
                        newRNM0Maps.Add(storage.rnmMaps0[origID]);
                        newRNM1Maps.Add(storage.rnmMaps1[origID]);
                        newRNM2Maps.Add(storage.rnmMaps2[origID]);
                        newMapsMode.Add(storage.mapsMode[origID]);
                    }
                }
                storage.maps = newMaps;
                storage.masks = newMasks;
                storage.dirMaps = newDirMaps;
                storage.rnmMaps0 = newRNM0Maps;
                storage.rnmMaps1 = newRNM1Maps;
                storage.rnmMaps2 = newRNM2Maps;
                storage.mapsMode = newMapsMode;

                for(int i=0; i<storage.bakedIDs.Count; i++)
                {
                    int newID = origID2New[storage.bakedIDs[i]];
                    if (newID < 0 || newID > storage.maps.Count) continue;
                    storage.bakedIDs[i] = newID;
                }
#if USE_TERRAINS
                for(int i=0; i<storage.bakedIDsTerrain.Count; i++)
                {
                    int newID = origID2New[storage.bakedIDsTerrain[i]];
                    if (newID < 0 || newID > storage.maps.Count) continue;
                    storage.bakedIDsTerrain[i] = newID;
                }
#endif
            }
        }

        // Patch lightmapped prefabs
        //var bdataName = "BakeryPrefabLightmapData";
        var lmprefabs = FindObjectsOfType(typeof(BakeryLightmappedPrefab)) as BakeryLightmappedPrefab[];
        for(int i=0; i<lmprefabs.Length; i++)
        {
            var p = lmprefabs[i];
            if (!p.gameObject.activeInHierarchy) continue;
            if (!p.IsValid()) continue;

            var pstoreT = p.transform.Find(bdataName);
            if (pstoreT == null)
            {
                var pstoreG = new GameObject();
                pstoreG.name = bdataName;
                pstoreT = pstoreG.transform;
                pstoreT.parent = p.transform;
            }
            var pstore = pstoreT.gameObject.GetComponent<ftLightmapsStorage>();
            if (pstore == null) pstore = pstoreT.gameObject.AddComponent<ftLightmapsStorage>();

            var prenderers = p.GetComponentsInChildren<Renderer>();
#if USE_TERRAINS
            var pterrains = p.GetComponentsInChildren<Terrain>();
#endif
            var plights = p.GetComponentsInChildren<Light>();

            var storage = storages[p.gameObject.scene];

            pstore.bakedRenderers = new List<Renderer>();
            pstore.bakedIDs = new List<int>();
            pstore.bakedScaleOffset = new List<Vector4>();
            pstore.bakedVertexColorMesh = new List<Mesh>();

#if USE_TERRAINS
            pstore.bakedRenderersTerrain = new List<Terrain>();
            pstore.bakedIDsTerrain = new List<int>();
            pstore.bakedScaleOffsetTerrain = new List<Vector4>();
#endif

            pstore.bakedLights = new List<Light>();
            pstore.bakedLightChannels = new List<int>();
            var usedIDs = new Dictionary<int, bool>();
            usedIDs[0] = true; // have to include ID 0 because Unity judges lightmap compression by it

            for(int j=0; j<prenderers.Length; j++)
            {
                var r = prenderers[j];
                int idx = storage.bakedRenderers.IndexOf(r);
                if (idx < 0) continue;
                pstore.bakedRenderers.Add(r);
                pstore.bakedIDs.Add(storage.bakedIDs[idx]);
                pstore.bakedScaleOffset.Add(storage.bakedScaleOffset[idx]);
                pstore.bakedVertexColorMesh.Add(storage.bakedVertexColorMesh[idx]);
                usedIDs[storage.bakedIDs[idx]] = true;
            }

#if USE_TERRAINS
            for(int j=0; j<pterrains.Length; j++)
            {
                var r = pterrains[j];
                int idx = storage.bakedRenderersTerrain.IndexOf(r);
                if (idx < 0) continue;
                pstore.bakedRenderersTerrain.Add(r);
                pstore.bakedIDsTerrain.Add(storage.bakedIDsTerrain[idx]);
                pstore.bakedScaleOffsetTerrain.Add(storage.bakedScaleOffsetTerrain[idx]);
                usedIDs[storage.bakedIDsTerrain[idx]] = true;
            }
#endif

            for(int j=0; j<plights.Length; j++)
            {
                var r = plights[j];
                int idx = storage.bakedLights.IndexOf(r);
                if (idx < 0) continue;
                pstore.bakedLights.Add(r);
                pstore.bakedLightChannels.Add(storage.bakedLightChannels[idx]);
            }

            pstore.maps = new List<Texture2D>();
            pstore.masks = new List<Texture2D>();
            pstore.dirMaps = new List<Texture2D>();
            pstore.rnmMaps0 = new List<Texture2D>();
            pstore.rnmMaps1 = new List<Texture2D>();
            pstore.rnmMaps2 = new List<Texture2D>();
            pstore.mapsMode = new List<int>();
            foreach(var pair in usedIDs)
            {
                int id = pair.Key;
                if (id < 0) continue;
                while(pstore.maps.Count <= id)
                {
                    pstore.maps.Add(null);
                    if (storage.masks.Count > pstore.masks.Count) pstore.masks.Add(null);
                    if (storage.dirMaps.Count > pstore.dirMaps.Count) pstore.dirMaps.Add(null);
                    if (storage.rnmMaps0.Count > pstore.rnmMaps0.Count)
                    {
                        pstore.rnmMaps0.Add(null);
                        pstore.rnmMaps1.Add(null);
                        pstore.rnmMaps2.Add(null);
                        pstore.mapsMode.Add(0);
                    }
                }
                if (storage.maps.Count > id)
                {
                    pstore.maps[id] = storage.maps[id];
                    if (pstore.masks.Count > id) pstore.masks[id] = storage.masks[id];
                    if (pstore.dirMaps.Count > id) pstore.dirMaps[id] = storage.dirMaps[id];
                    if (pstore.rnmMaps0.Count > id)
                    {
                        pstore.rnmMaps0[id] = storage.rnmMaps0[id];
                        pstore.rnmMaps1[id] = storage.rnmMaps1[id];
                        pstore.rnmMaps2[id] = storage.rnmMaps2[id];
                        pstore.mapsMode[id] = storage.mapsMode[id];
                    }
                }
            }

#if UNITY_2018_3_OR_NEWER
            // Unity 2018.3 incorrectly sets lightmap IDs when applying prefabs, UNLESS editor is focused

            if (!verbose) SetForegroundWindow(unityEditorHWND);

            DebugLogInfo("Waiting for Unity editor focus...");
            bool focused = false;
#if UNITY_2023_1_OR_NEWER
            var titleBuff = new StringBuilder(256);
#endif
            while(!focused)
            {
                var wnd = GetForegroundWindow();

#if UNITY_2023_1_OR_NEWER
                if (GetClassName(wnd, titleBuff, 256) > 0)
                {
                    if (titleBuff.ToString() == "UnityContainerWndClass")
                    {
                        break;
                    }
                }
                else
                {
                    DebugLogInfo("Unable to get Editor class name");
                }
#endif

                while(wnd != (System.IntPtr)0)
                {
                    if (wnd == unityEditorHWND)
                    {
                        focused = true;
                        break;
                    }
                    wnd = GetParent(wnd);
                }
                yield return null;
            }
#endif

            PrefabUtility.ReplacePrefab(p.gameObject, PrefabUtility.GetPrefabParent(p.gameObject), ReplacePrefabOptions.ConnectToPrefab);
            DebugLogInfo("Patched prefab " + p.name);
        }

        ftLightmaps.RefreshFull();
    }

    static void MergeSectorsUpdate()
    {
        if (loadedScenes != null)
        {
            if ( (loadedScenes.Count > EditorSceneManager.sceneCount || EditorSceneManager.GetSceneAt(0).path.Length == 0))
            {
                DebugLogInfo("MergeSectors: waiting for scenes...");
                return;
            }
            MergeSectors();
            DebugLogInfo("MergeSectors: done");
        }
        EditorApplication.update -= MergeSectorsUpdate;
    }

    static void MergeSectorsDeferred()
    {
        EditorApplication.update += MergeSectorsUpdate;
    }

    static public void MergeSectors()
    {
        int sceneCount = EditorSceneManager.sceneCount;
        CollectStorages();

        for(int s=0; s<sceneCount; s++)
        {
            var scene = EditorSceneManager.GetSceneAt(s);
            if (!scene.isLoaded) continue;
            storage = storages[scene];

            // Merge all sectors
            var newMaps = new List<Texture2D>();
            var newMasks = new List<Texture2D>();
            var newDirMaps = new List<Texture2D>();
            var newRNM0Maps = new List<Texture2D>();
            var newRNM1Maps = new List<Texture2D>();
            var newRNM2Maps = new List<Texture2D>();
            var newMapsMode = new List<int>();
            var newBakedRenderers = new List<Renderer>();
#if USE_TERRAINS
            var newBakedRenderersTerrain = new List<Terrain>();
            var newBakedIDsTerrain = new List<int>();
            var newBakedScaleOffsetTerrain = new List<Vector4>();
#endif
            var newBakedIDs = new List<int>();
            var newBakedScaleOffset = new List<Vector4>();
            var newBakedVertexColorMesh = new List<Mesh>();
            HashSet<Renderer> nonBakedSet = null;
            var usedIDs = new HashSet<int>();
            bool anyMasks = false;
            bool anyDirMaps = false;
            bool anyRNMMaps = false;
            int maxMapCount = 0;
            for(int sc=0; sc<storage.sectors.Count; sc++)
            {
                var sect = storage.sectors[sc];
                if (sect.masks != null && sect.masks.Count > 0) anyMasks = true;
                if (sect.dirMaps != null && sect.dirMaps.Count > 0) anyDirMaps = true;
                if (sect.rnmMaps0 != null && sect.rnmMaps0.Count > 0) anyRNMMaps = true;

                if (sect.maps != null) maxMapCount = System.Math.Max(maxMapCount, sect.maps.Count);
            }

            var idRemap = new int[maxMapCount];

            var rendererSet = new HashSet<Renderer>();
#if USE_TERRAINS
            var terrainSet = new HashSet<Terrain>();
#endif
            for(int sc=storage.sectors.Count-1; sc>=0; sc--) // revert order because newest sectors have priority over the global sector
            //for(int sc=0; sc<storage.sectors.Count; sc++)
            {
                var sect = storage.sectors[sc];
                bool hasMasks = (sect.masks != null && sect.masks.Count > 0);
                bool hasDirMaps = (sect.dirMaps != null && sect.dirMaps.Count > 0);
                bool hasRNMMaps = (sect.rnmMaps0 != null && sect.rnmMaps0.Count > 0);
                for(int j=0; j<sect.maps.Count; j++)
                {
                    int exists = newMaps.IndexOf(sect.maps[j]);
                    if (exists >= 0)
                    {
                        idRemap[j] = exists;
                        continue;
                    }

                    idRemap[j] = newMaps.Count;
                    newMaps.Add(sect.maps[j]);

                    bool has = hasMasks && sect.masks.Count > j;
                    if (anyMasks) newMasks.Add(has ? sect.masks[j] : null);

                    has = hasDirMaps && sect.dirMaps.Count > j;
                    if (anyDirMaps)
                    {
                        newDirMaps.Add(has ? sect.dirMaps[j] : null);
                    }

                    if (anyRNMMaps)
                    {
                        has = hasRNMMaps && sect.rnmMaps0.Count > j;
                        newRNM0Maps.Add(has ? sect.rnmMaps0[j] : null);
                        newRNM1Maps.Add(has ? sect.rnmMaps1[j] : null);
                        newRNM2Maps.Add(has ? sect.rnmMaps2[j] : null);
                        newMapsMode.Add(has ? sect.mapsMode[j] : 0);
                    }
                }

                for(int j=0; j<sect.bakedRenderers.Count; j++)
                {
                    var renderer = sect.bakedRenderers[j];
                    if (rendererSet.Contains(renderer)) continue;
                    if (renderer != null)
                    {
                        if ((GameObjectUtility.GetStaticEditorFlags(renderer.gameObject) & StaticEditorFlags.ContributeGI) == 0)
                        {
                            renderer.lightmapIndex = -1;
                            continue; // skip dynamic
                        }
                        var so = new SerializedObject(renderer);
                        var prop = so.FindProperty("m_ScaleInLightmap");
                        var scaleInLm = prop.floatValue;
                        if (scaleInLm == 0)
                        {
                            renderer.lightmapIndex = -1;
                            continue; // skip scaleInLm=0
                        }
                    }
                    rendererSet.Add(renderer);

                    newBakedRenderers.Add(renderer);
                    newBakedScaleOffset.Add(sect.bakedScaleOffset[j]);
                    newBakedVertexColorMesh.Add(sect.bakedVertexColorMesh.Count > j ? sect.bakedVertexColorMesh[j] : null);

                    int id = sect.bakedIDs[j];
                    if (id >= 0 && id != 0xFFFF)
                    {
                        if (idRemap.Length > id) id = idRemap[id];
                    }
                    newBakedIDs.Add(id);
                    usedIDs.Add(id);
                }

#if USE_TERRAINS
                for(int j=0; j<sect.bakedRenderersTerrain.Count; j++)
                {
                    var terrain = sect.bakedRenderersTerrain[j];
                    if (terrainSet.Contains(terrain)) continue;
                    if (terrain != null)
                    {
                        if ((GameObjectUtility.GetStaticEditorFlags(terrain.gameObject) & StaticEditorFlags.ContributeGI) == 0) continue; // skip dynamic
                        var so = new SerializedObject(terrain);
                        var prop = so.FindProperty("m_ScaleInLightmap");
                        var scaleInLm = prop.floatValue;
                        if (scaleInLm == 0) continue; // skip scaleInLm=0
                    }
                    terrainSet.Add(terrain);

                    newBakedRenderersTerrain.Add(terrain);
                    newBakedScaleOffsetTerrain.Add(sect.bakedScaleOffsetTerrain[j]);

                    int id = sect.bakedIDsTerrain[j];
                    if (id >= 0 && id != 0xFFFF)
                    {
                        if (idRemap.Length > id) id = idRemap[id];
                    }
                    newBakedIDsTerrain.Add(id);
                    usedIDs.Add(id);
                }
#endif

                if (nonBakedSet == null)
                {
                    nonBakedSet = new HashSet<Renderer>(sect.nonBakedRenderers);
                }
                else
                {
                    nonBakedSet.IntersectWith(sect.nonBakedRenderers);
                }
            }

            // Strip unused
            for(int i=0; i<newMaps.Count; i++)
            {
                if (!usedIDs.Contains(i))
                {
                    newMaps[i] = null;
                    if (newMasks != null && newMasks.Count > i) newMasks[i] = null;
                    if (newDirMaps != null && newDirMaps.Count > i) newDirMaps[i] = null;
                    if (newRNM0Maps != null && newRNM0Maps.Count > i) newRNM0Maps[i] = null;
                    if (newRNM1Maps != null && newRNM1Maps.Count > i) newRNM1Maps[i] = null;
                    if (newRNM2Maps != null && newRNM2Maps.Count > i) newRNM2Maps[i] = null;
                }
            }

            storage.maps = newMaps;
            storage.masks = newMasks;
            storage.dirMaps = newDirMaps;
            storage.rnmMaps0 = newRNM0Maps;
            storage.rnmMaps1 = newRNM1Maps;
            storage.rnmMaps2 = newRNM2Maps;
            storage.mapsMode = newMapsMode;
            storage.bakedRenderers = newBakedRenderers;
#if USE_TERRAINS
            storage.bakedRenderersTerrain = newBakedRenderersTerrain;
            storage.bakedIDsTerrain = newBakedIDsTerrain;
            storage.bakedScaleOffsetTerrain = newBakedScaleOffsetTerrain;
#endif
            storage.bakedIDs = newBakedIDs;
            storage.bakedScaleOffset = newBakedScaleOffset;
            storage.bakedVertexColorMesh = newBakedVertexColorMesh;
            storage.nonBakedRenderers = new List<Renderer>(nonBakedSet);

            EditorUtility.SetDirty(storage);
            EditorSceneManager.MarkAllScenesDirty();

            ftLightmaps.RefreshFull();
        }
    }

    void FindAllReflectionProbesAndDisable()
    {
        var found = FindObjectsOfType(typeof(ReflectionProbe))as ReflectionProbe[];
        for(int i = 0; i < found.Length; i++)
        {
            reflectionProbes.Add(found[i]);
            found[i].enabled = false;
        }
    }

    void ReEnableReflectionProbes()
    {
        for(int i = 0; i < reflectionProbes.Count; i++)
        {
            if (reflectionProbes[i] != null) reflectionProbes[i].enabled = true;
        }
    }

    public static int GetID(GameObject obj, ftLightmapsStorage storage)
    {
        ftLightmapsStorage.LightData data;
        if (storage.lightsDict != null)
        {
            if (storage.lightsDict.TryGetValue(obj, out data)) // try to get stored data
            {
                if (data.UID != 0) return data.UID; // data exists, UID filled, return
                if (storage.uniqueLights != null)
                {
                    data.UID = storage.uniqueLights.IndexOf(obj) + 1; // data exists, no UID (legacy), fill it
                    if (data.UID > 0) return data.UID;
                }
            }
            else
            {
                data = new ftLightmapsStorage.LightData();
                storage.StoreLight(obj, data); // no data, no UID, add, but don't fill everything else so IsLightDirty works
                return data.UID;
            }
        }
        Debug.LogError("No UID for " + obj.name); // no Init called on storage? no uniqueLights?
        return 0;
    }

    string GetLightName(GameObject obj, ftLightmapsStorage storage, int lmid)
    {
        return "light_" + GetID(obj, storage) + "_" + lmid;
    }

    bool IsLightDirty(BakeryLightMesh light)
    {
        if (forceRefresh) return true;

        storage = storages[light.gameObject.scene];
        ftLightmapsStorage.LightData data;
        if (!storage.lightsDict.TryGetValue(light.gameObject, out data)) {
            return true; // not stored
        }

        if (light.color != data.color) {
            return true;
        }
        if (light.intensity != data.intensity) {
            return true;
        }
        if (light.cutoff != data.range) {
            return true;
        }
        if (light.samples != data.samples) {
            return true;
        }
        if (light.samples2 != data.samples2) {
            return true;
        }
        if (light.selfShadow != data.selfShadow) {
            return true;
        }
        if (light.bakeToIndirect != data.bakeToIndirect) {
            return true;
        }

        var tform1 = light.GetComponent<Transform>().localToWorldMatrix;
        var tform2 = data.tform;
        for(int y=0; y<4; y++) {
            for(int x=0; x<4; x++) {
                if (tform1[x,y] != tform2[x,y]) {
                    return true;
                }
            }
        }

        return false;
    }

    bool IsLightDirty(BakeryPointLight light)
    {
        if (forceRefresh) return true;

        storage = storages[light.gameObject.scene];
        ftLightmapsStorage.LightData data;
        if (!storage.lightsDict.TryGetValue(light.gameObject, out data)) {
            return true; // not stored
        }

        if (light.color != data.color) {
            return true;
        }
        if (light.intensity != data.intensity) {
            return true;
        }
        if (light.cutoff != data.range) {
            return true;
        }
        if (light.shadowSpread != data.radius) {
            return true;
        }
        if (light.samples != data.samples) {
            return true;
        }
        if (light.realisticFalloff != data.realisticFalloff)
        {
            return true;
        }
        if ((int)light.projMode != data.projMode)
        {
            return true;
        }
        Object cookie = null;
        if (light.projMode == BakeryPointLight.ftLightProjectionMode.Cubemap)
        {
            cookie = light.cubemap;
        } else if (light.projMode == BakeryPointLight.ftLightProjectionMode.Cookie)
        {
            cookie = light.cookie;
        } else if (light.projMode == BakeryPointLight.ftLightProjectionMode.IES)
        {
            cookie = light.iesFile;
        }
        if (cookie != data.cookie) return true;

        if (light.angle != data.angle) return true;

        if (light.bakeToIndirect != data.bakeToIndirect) {
            return true;
        }

        //if (light.texName != data.texName) return true;

        var tform1 = light.GetComponent<Transform>().localToWorldMatrix;
        var tform2 = data.tform;
        for(int y=0; y<4; y++) {
            for(int x=0; x<4; x++) {
                if (tform1[x,y] != tform2[x,y]) {
                    return true;
                }
            }
        }

        return false;
    }

    public static bool IsLightDirty(BakeryDirectLight light)
    {
        if (forceRefresh) return true;

        storage = storages[light.gameObject.scene];
        ftLightmapsStorage.LightData data;
        if (!storage.lightsDict.TryGetValue(light.gameObject, out data)) return true; // not stored

        if (light.color != data.color) {
            return true;
        }
        if (light.intensity != data.intensity) {
            return true;
        }
        if (light.shadowSpread != data.radius) {
            return true;
        }
        if (light.samples != data.samples) {
            return true;
        }

        if (light.bakeToIndirect != data.bakeToIndirect) {
            return true;
        }

        var tform1 = light.GetComponent<Transform>().localToWorldMatrix;
        var tform2 = data.tform;
        for(int y=0; y<4; y++) {
            for(int x=0; x<4; x++) {
                if (tform1[x,y] != tform2[x,y]) {
                    return true;
                }
            }
        }

        return false;
    }

    bool IsLightDirty(BakerySkyLight light)
    {
        if (forceRefresh) return true;

        storage = storages[light.gameObject.scene];
        ftLightmapsStorage.LightData data;
        if (!storage.lightsDict.TryGetValue(light.gameObject, out data)) return true; // not stored

        if (light.color != data.color) return true;
        if (light.intensity != data.intensity) return true;
        //if (light.texName != data.texName) return true;
        if (light.samples != data.samples) {
            return true;
        }
        if (light.bakeToIndirect != data.bakeToIndirect) {
            return true;
        }
        if (light.cubemap != data.cookie)
        {
            return true;
        }

        return false;
    }

    void StoreLight(BakeryLightMesh light)
    {
        storage = storages[light.gameObject.scene];
        ftLightmapsStorage.LightData data;
        if (!storage.lightsDict.TryGetValue(light.gameObject, out data) || data == null)
        {
            data = new ftLightmapsStorage.LightData();
            storage.StoreLight(light.gameObject, data);
        }
        data.color = light.color;
        data.intensity = light.intensity;
        data.range = light.cutoff;
        data.samples = light.samples;
        data.samples2 = light.samples2;
        data.selfShadow = light.selfShadow;
        data.bakeToIndirect = light.bakeToIndirect;
        data.tform = light.GetComponent<Transform>().localToWorldMatrix;
    }

    void StoreLight(BakeryPointLight light)
    {
        storage = storages[light.gameObject.scene];
        ftLightmapsStorage.LightData data;
        if (!storage.lightsDict.TryGetValue(light.gameObject, out data) || data == null)
        {
            data = new ftLightmapsStorage.LightData();
            storage.StoreLight(light.gameObject, data);
        }
        //var unityLight = light.GetComponent<Light>();
        data.color = light.color;
        data.intensity = light.intensity;
        data.radius = light.shadowSpread;
        data.range = light.cutoff;
        data.samples = light.samples;
        data.bakeToIndirect = light.bakeToIndirect;

        data.realisticFalloff = light.realisticFalloff;
        data.projMode = (int)light.projMode;
        if (light.projMode == BakeryPointLight.ftLightProjectionMode.Cubemap)
        {
            data.cookie = light.cubemap;
        } else if (light.projMode == BakeryPointLight.ftLightProjectionMode.Cookie)
        {
            data.cookie = light.cookie;
        } else if (light.projMode == BakeryPointLight.ftLightProjectionMode.IES)
        {
            data.cookie = light.iesFile;
        }
        data.angle = light.angle;

        //data.texName = light.texName; // TODO: check for cubemap! (and sky too)
        data.tform = light.GetComponent<Transform>().localToWorldMatrix;
    }

    void StoreLight(BakeryDirectLight light)
    {
        storage = storages[light.gameObject.scene];
        ftLightmapsStorage.LightData data;
        if (!storage.lightsDict.TryGetValue(light.gameObject, out data) || data == null)
        {
            data = new ftLightmapsStorage.LightData();
            storage.StoreLight(light.gameObject, data);
        }
        data.color = light.color;
        data.intensity = light.intensity;
        data.radius = light.shadowSpread;
        data.samples = light.samples;
        data.bakeToIndirect = light.bakeToIndirect;
        data.tform = light.GetComponent<Transform>().localToWorldMatrix;
    }

    void StoreLight(BakerySkyLight light)
    {
        storage = storages[light.gameObject.scene];
        ftLightmapsStorage.LightData data;
        if (!storage.lightsDict.TryGetValue(light.gameObject, out data) || data == null)
        {
            data = new ftLightmapsStorage.LightData();
            storage.StoreLight(light.gameObject, data);
        }
        data.color = light.color;
        data.intensity = light.intensity;
        data.range = 0;
        data.samples = light.samples;
        data.bakeToIndirect = light.bakeToIndirect;
        data.tform = Matrix4x4.identity;
        //data.texName = light.texName;
        data.cookie = light.cubemap;
    }

    void UpdateLightmapShadowmaskFromPointLight(BakeryPointLight obj, int LMID, string lname, string lmname)
    {
        var rmode = currentGroup.renderMode == BakeryLightmapGroup.RenderMode.Auto ? (int)userRenderMode : (int)currentGroup.renderMode;
        if (rmode == (int)RenderMode.Shadowmask && obj.shadowmask)
        {
            var ulht = obj.GetComponent<Light>();
            if (ulht == null && !(obj.shadowmask && obj.bakeToIndirect))
            {
                DebugLogWarning("Light " + obj.name + " set to shadowmask, but doesn't have real-time light");;
            }
            else
            {
                UpdateMaskArray(LMID, lname, lmname, ulht, obj, false);
            }
        }
    }

    void UpdateLightmapShadowmaskFromAreaLight(BakeryLightMesh obj, int LMID, string lname, string lmname)
    {
        if (userRenderMode == RenderMode.Shadowmask && obj.shadowmask)
        {
            var ulht = obj.GetComponent<Light>();
            if (ulht == null)
            {
                DebugLogWarning("Light " + obj.name + " set to shadowmask, but doesn't have real-time light");;
            }
            else
            {
                UpdateMaskArray(LMID, lname, lmname, ulht, null, false);
            }
        }
    }

    bool WriteCompFiles(BakeryPointLight obj, ComposeInstructionFiles cif, string lname, int rmode, bool dominantDirMode, bool rnmMode, bool shMode, bool shModeProbe)
    {
        bool usesIndirectIntensity = false;

        cif.fcomp.Write(lname + "_HDR" + (compressedOutput ? ".lz4" : ".dds"));
        if (bounces > 0)
        {
            cif.fcomp.Write(obj.indirectIntensity * hackIndirectBoost);
            if (Mathf.Abs(obj.indirectIntensity - 1.0f) > 0.01f) usesIndirectIntensity = true;
        }

        if ((rmode == (int)RenderMode.Indirect || rmode == (int)RenderMode.Shadowmask)
                && obj.bakeToIndirect)
        {
            cif.fcompIndirect.Write(lname + "_HDR" + (compressedOutput ? ".lz4" : ".dds"));
            if (cif.fcompDirIndirect != null)
            {
                cif.fcompDirIndirect.Write(lname + "_HDR" + (compressedOutput ? ".lz4" : ".dds"));
                cif.fcompDirIndirect.Write(lname + "_Dir" + (compressedOutput ? ".lz4" : ".dds"));
            }
        }

        bool rmodeFullLight = (rmode == (int)RenderMode.FullLighting || rmode == (int)RenderMode.Subtractive);

        if (dominantDirMode && (rmodeFullLight || obj.bakeToIndirect))
        {
            cif.fcompDir.Write(lname + "_HDR" + (compressedOutput ? ".lz4" : ".dds"));
            cif.fcompDir.Write(lname + "_Dir" + (compressedOutput ? ".lz4" : ".dds"));
        }
        else if (rnmMode && (rmodeFullLight || obj.bakeToIndirect))
        {
            cif.fcompRNM0.Write(lname + "_RNM0" + (compressedOutput ? ".lz4" : ".dds"));
            cif.fcompRNM1.Write(lname + "_RNM1" + (compressedOutput ? ".lz4" : ".dds"));
            cif.fcompRNM2.Write(lname + "_RNM2" + (compressedOutput ? ".lz4" : ".dds"));
        }
        else if (shMode && (rmodeFullLight || obj.bakeToIndirect))
        {
            cif.fcompSH.Write(lname + "_RNM0" + (compressedOutput ? ".lz4" : ".dds"));
            cif.fcompSH.Write(lname + "_RNM1" + (compressedOutput ? ".lz4" : ".dds"));
            cif.fcompSH.Write(lname + "_RNM2" + (compressedOutput ? ".lz4" : ".dds"));
            cif.fcompSH.Write(lname + "_RNM3" + (compressedOutput ? ".lz4" : ".dds"));
        }

        return usesIndirectIntensity;
    }

    void AddPointLightCommandLine(string renderMode, string lname, string settingsFile, string progressText, int LMID, BakeryPointLight obj,
                                                int rmode, bool dominantDirMode, bool rnmMode, bool shMode, bool shModeProbe, bool legacySampling)
    {
        var startInfo = new System.Diagnostics.ProcessStartInfo();
        startInfo.CreateNoWindow  = false;
        startInfo.UseShellExecute = false;
#if !LAUNCH_VIA_DLL
        startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
        startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
        startInfo.CreateNoWindow = true;

        bool rmodeFullLight = (rmode == (int)RenderMode.FullLighting || rmode == (int)RenderMode.Subtractive);

        int passes = PASS_HALF;
        if (dominantDirMode && (rmodeFullLight || obj.bakeToIndirect))
        {
            passes |= PASS_DIRECTION;
        }
        else if (rnmMode && (rmodeFullLight || obj.bakeToIndirect))
        {
            renderMode += "rnm";
            if (bounces == 0) passes = 0;
            passes |= PASS_RNM0 | PASS_RNM1 | PASS_RNM2;
        }
        else if (shMode && (rmodeFullLight || obj.bakeToIndirect || shModeProbe))
        {
            renderMode += shModeProbe ? "probesh" : "sh";
            if (bounces == 0) passes = 0;
            passes |= PASS_RNM0 | PASS_RNM1 | PASS_RNM2 | PASS_RNM3;
        }
        if (userRenderMode == RenderMode.Shadowmask && obj.shadowmask)
        {
            passes |= PASS_MASK;
            if (currentGroup.transparentSelfShadow) passes |= PASS_MASK1;
            hasAnyShadowmasks = true;
        }
        if (legacySampling)
        {
            renderMode += "legacy";
        }

        startInfo.Arguments       = renderMode + " " + scenePathQuoted + " \"" + lname + "\" " + passes + " " + 0 + " " + LMID + " " + settingsFile;

        deferredFileSrc.Add("");//scenePath + "/pointlight" + i + ".bin");
        deferredFileDest.Add("");//scenePath + "/pointlight.bin");
        deferredCommands.Add(startInfo);
        deferredCommandDesc.Add(progressText);
    }

    string PrepareBatchPointLight(int start, int end, int LMID, bool[] skipLight, ComposeInstructionFiles cif, int rmode, bool dominantDirMode, bool rnmMode, bool shMode, bool shModeProbe, ref bool usesIndirectIntensity)
    {
        string lname = "PointBatch_" + LMID + "_" + start + "_" + end;
        bool first = true;
        //Debug.LogError("----- Group:");
        for(int j=start; j<=end; j++)
        {
            if (skipLight[j]) continue;

            //Debug.LogError(AllP[j]);

            // For every light in a batch
            UpdateLightmapShadowmaskFromPointLight(AllP[j], LMID, lname, currentGroup.name);
            if (first)
            {
                // Once for the whole batch
                if (WriteCompFiles(AllP[j], cif, lname, rmode, dominantDirMode, rnmMode, shMode, shModeProbe)) usesIndirectIntensity = true;
                first = false;
            }
        }
        return lname;
    }

    class ComposeInstructionFiles
    {
        public BinaryWriter fcomp = null;
        public BinaryWriter fcompIndirect = null;
        public BinaryWriter fcompDir = null;
        public BinaryWriter fcompDirIndirect = null;
        public BinaryWriter fcompRNM0 = null;
        public BinaryWriter fcompRNM1 = null;
        public BinaryWriter fcompRNM2 = null;
        public BinaryWriter fcompSH = null;

        public void Close()
        {
            if (fcomp != null) fcomp.Close();
            if (fcompIndirect != null) fcompIndirect.Close();
            if (fcompDirIndirect != null) fcompDirIndirect.Close();
            if (fcompDir != null) fcompDir.Close();
            if (fcompRNM0 != null) fcompRNM0.Close();
            if (fcompRNM1 != null) fcompRNM1.Close();
            if (fcompRNM2 != null) fcompRNM2.Close();
            if (fcompSH != null) fcompSH.Close();
        }
    }

    internal void ComputeAreaLightLMGroupIntersections(List<BakeryLightmapGroup> groupList)
    {
        AllAffectsGroups = new List<bool[]>();
        for(int i=0; i<All.Length; i++)
        {
            var obj = All[i] as BakeryLightMesh;
            if (!obj.enabled)
            {
                AllAffectsGroups.Add(null);
                continue;
            }

            var lmr = ftBuildGraphics.GetValidRenderer(obj.gameObject);
            var lma = obj.GetComponent<Light>();
            if (lmr == null && lma == null)
            {
                AllAffectsGroups.Add(null);
                continue;
            }

            AllAffectsGroups.Add(new bool[groupList.Count]);
            foreach(var lmgroup in groupList)
            {
                currentGroup = lmgroup;
                int LMID = lmgroup.id;
                if ((obj.bitmask & currentGroup.bitmask) == 0) continue;

                bool isArea = lma != null && ftLightMeshInspector.IsArea(lma);

                if (isArea)
                {
                    lmr = null;
                }
                else if (ftBuildGraphics.GetSharedMesh(obj.gameObject) != null)
                {
                    lma = null;
                }
                else
                {
                    Debug.LogError("Light mesh " + obj.name + " must have either a mesh or an area light");
                    continue;
                }

                Bounds lBounds;
                Vector3[] corners = null;
                if (lma != null)
                {
                    corners = ftLightMeshInspector.GetAreaLightCorners(lma);
                    lBounds = new Bounds(corners[0], Vector3.zero);
                    lBounds.Encapsulate(corners[1]);
                    lBounds.Encapsulate(corners[2]);
                    lBounds.Encapsulate(corners[3]);
                }
                else
                {
                    var lmrState = lmr.enabled;
                    lmr.enabled = true;
                    lBounds = lmr.bounds;
                    lmr.enabled = lmrState;
                }

                lBounds.Expand(new Vector3(obj.cutoff, obj.cutoff, obj.cutoff));
                if (!lBounds.Intersects(storage.bounds[LMID])) continue;

                AllAffectsGroups[i][LMID] = true;
            }
        }
    }

    internal void SetAreaLightLMID()
    {
        int areaLightOffset = -2;
        var savedLights = new List<SavedLight>();
        int totalCount = 0;
        int batchedCount = 0;
        for(int lid=0; lid<All.Length; lid++)
        {
            var obj = All[lid];
            if (!obj.enabled) continue;
            totalCount++;
            bool append = false;
            bool canAppend = !obj.shadowmask; // don't combine shadowmasked area lights
            if (canAppend)
            {
                var maskA = AllAffectsGroups[lid];
                int maskLen = maskA.Length;
                for(int i=0; i<savedLights.Count; i++)
                {
                    if (obj.texture != savedLights[i].tex) continue;
                    if (obj.color != savedLights[i].color) continue;
                    if (obj.intensity != savedLights[i].intensity) continue;
                    if (obj.bitmask != savedLights[i].bitmask) continue;
                    if (obj.cutoff != savedLights[i].cutoff) continue;
                    if (obj.indirectIntensity != savedLights[i].indirectIntensity) continue;
                    if (obj.samples != savedLights[i].samples) continue;
                    if (obj.samples2 != savedLights[i].samples2) continue;
                    if (obj.selfShadow != savedLights[i].selfShadow) continue;
                    if (obj.bakeToIndirect != savedLights[i].bakeToIndirect) continue;
                    if (obj.shadowmask != savedLights[i].shadowmask) continue;
                    if (obj.shadowmaskFalloff != savedLights[i].shadowmaskFalloff) continue;

                    if (savedLights[i].accumSamples + obj.samples > batchAreaLightSampleLimit) continue;

                    bool maskEquals = true;
                    var maskB = AllAffectsGroups[savedLights[i].lid];
                    for(int k=0; k<maskLen; k++)
                    {
                        if (maskA[k] != maskB[k])
                        {
                            maskEquals = false;
                            break;
                        }
                    }
                    if (!maskEquals) continue;

                    append = true;
                    int newSamples = savedLights[i].accumSamples + obj.samples;

                    var sl = savedLights[i];
                    sl.accumSamples = newSamples;
                    savedLights[i] = sl;

                    obj.lmid = savedLights[i].lmid;

                    //Debug.LogError("[1] Append "+obj.name+" to "+savedLights[i].name + " (" + obj.lmid + ")");
                }

                if (!append)
                {
                    var sl = new SavedLight();
                    sl.tex = obj.texture;
                    sl.bitmask = obj.bitmask;
                    sl.color = obj.color;
                    sl.intensity = obj.intensity;
                    sl.cutoff = obj.cutoff;
                    sl.indirectIntensity = obj.indirectIntensity;
                    sl.samples = obj.samples;
                    sl.samples2 = obj.samples2;
                    sl.selfShadow = obj.selfShadow;
                    sl.bakeToIndirect = obj.bakeToIndirect;
                    sl.shadowmask = obj.shadowmask;
                    sl.shadowmaskFalloff = obj.shadowmaskFalloff;
                    sl.name = obj.name;
                    sl.lid = lid;
                    
                    obj.lmid = sl.lmid = -lid + areaLightOffset;
                    
                    savedLights.Add(sl);

                    batchedCount++;

                    //Debug.LogError("[1] Add "+obj.name +" (" + sl.lmid + ")");
                }
            }
            else
            {
                obj.lmid = -lid + areaLightOffset;
                batchedCount++;
            }
        }
        DebugLogInfo("Total area light count: " + totalCount + ", batched: " + batchedCount);
    }

    IEnumerator RenderLMDirect(int LMID, string lmname, int resolution)
    {
        System.Diagnostics.ProcessStartInfo startInfo;
        //System.Diagnostics.Process exeProcess;

        bool doCompose = exeMode;

        var cif = new ComposeInstructionFiles();

        long fcompStartPos = 0;
        bool usesIndirectIntensity = Mathf.Abs(hackIndirectBoost - 1.0f) > 0.001f;
        var rmode = currentGroup.renderMode == BakeryLightmapGroup.RenderMode.Auto ? (int)userRenderMode : (int)currentGroup.renderMode;
        var dirMode = currentGroup.renderDirMode == BakeryLightmapGroup.RenderDirMode.Auto ? (int)renderDirMode : (int)currentGroup.renderDirMode;
        var dominantDirMode = dirMode == (int)ftRenderLightmap.RenderDirMode.DominantDirection;
        var rnmMode = dirMode == (int)ftRenderLightmap.RenderDirMode.RNM;
        var shMode = dirMode == (int)ftRenderLightmap.RenderDirMode.SH || dirMode == (int)ftRenderLightmap.RenderDirMode.MonoSH;
        var shModeProbe = dirMode == (int)BakeryLightmapGroup.RenderDirMode.ProbeSH;
        if (shModeProbe) shMode = true;

        if (rmode == (int)RenderMode.AmbientOcclusionOnly)
        {
            if (dominantDirMode) lightmapHasDir[LMID] = true;
            yield break;
        }

        bool rmodeFullLight = (rmode == (int)RenderMode.FullLighting || rmode == (int)RenderMode.Subtractive);

        lightmapHasMask[LMID] = 0;

        if (doCompose)
        {
            var fcompName = "comp_" + LMID + ".bin";
            cif.fcomp = new BinaryWriter(File.Open(scenePath + "/" + fcompName, FileMode.Create));
            if (clientMode) ftClient.serverFileList.Add(fcompName);
            if (bounces > 0)
            {
                cif.fcomp.Write(false);
                cif.fcomp.Write("uvalbedo_" + lmname + (compressedGBuffer ? ".lz4" : ".dds"));

                if (storage.hasEmissive.Count > LMID && storage.hasEmissive[LMID])
                {
                    cif.fcomp.Write("uvemissive_" + lmname + (compressedGBuffer ? ".lz4" : ".dds"));
                }
                else
                {
                    cif.fcomp.Write("");
                }
            }

            if (rmode == (int)RenderMode.Indirect || rmode == (int)RenderMode.Shadowmask)
            {
                cif.fcompIndirect = new BinaryWriter(File.Open(scenePath + "/comp_indirect" + LMID + ".bin", FileMode.Create));
                if (clientMode) ftClient.serverFileList.Add("comp_indirect" + LMID + ".bin");
                if (bounces > 0)
                {
                    cif.fcompIndirect.Write(lmname + "_final_HDR2" + (compressedOutput ? ".lz4" : ".dds"));
                }
                if (currentGroup.computeSSS && !rnmMode && !shMode)
                {
                    cif.fcompIndirect.Write(lmname + "_SSS_HDR" + (compressedOutput ? ".lz4" : ".dds"));
                }
                if (dominantDirMode)
                {
                    cif.fcompDirIndirect = new BinaryWriter(File.Open(scenePath + "/dircomp_indirect" + LMID + ".bin", FileMode.Create));
                    if (clientMode) ftClient.serverFileList.Add("dircomp_indirect" + LMID + ".bin");
                    cif.fcompDirIndirect.Write("uvnormal_" + lmname + (compressedGBuffer ? ".lz4" : ".dds"));
                    if (bounces > 0)
                    {
                        cif.fcompDirIndirect.Write(lmname + "_final_HDR2" + (compressedOutput ? ".lz4" : ".dds"));
                        cif.fcompDirIndirect.Write(lmname + "_final_Dir" + (compressedOutput ? ".lz4" : ".dds"));
                    }
                }
            }
            if (dominantDirMode)
            {
                cif.fcompDir = new BinaryWriter(File.Open(scenePath + (deferredMode ? "/dircomp_" + LMID + ".bin" : "/dircomp.bin"), FileMode.Create));
                cif.fcompDir.Write("uvnormal_" + lmname + (compressedGBuffer ? ".lz4" : ".dds"));
                if (clientMode) ftClient.serverFileList.Add("dircomp_" + LMID + ".bin");
            }
            if (rnmMode)
            {
                cif.fcompRNM0 = new BinaryWriter(File.Open(scenePath + (deferredMode ? "/rnm0comp_" + LMID + ".bin" : "/rnm0comp.bin"), FileMode.Create));
                cif.fcompRNM1 = new BinaryWriter(File.Open(scenePath + (deferredMode ? "/rnm1comp_" + LMID + ".bin" : "/rnm1comp.bin"), FileMode.Create));
                cif.fcompRNM2 = new BinaryWriter(File.Open(scenePath + (deferredMode ? "/rnm2comp_" + LMID + ".bin" : "/rnm2comp.bin"), FileMode.Create));

                if (clientMode)
                {
                    ftClient.serverFileList.Add("rnm0comp_" + LMID + ".bin");
                    ftClient.serverFileList.Add("rnm1comp_" + LMID + ".bin");
                    ftClient.serverFileList.Add("rnm2comp_" + LMID + ".bin");
                }

                if (bounces > 0)
                {
                    cif.fcompRNM0.Write(lmname + "_final_RNM0" + (compressedOutput ? ".lz4" : ".dds"));
                    cif.fcompRNM1.Write(lmname + "_final_RNM1" + (compressedOutput ? ".lz4" : ".dds"));
                    cif.fcompRNM2.Write(lmname + "_final_RNM2" + (compressedOutput ? ".lz4" : ".dds"));
                }
            }
            if (shMode)
            {
                cif.fcompSH = new BinaryWriter(File.Open(scenePath + (deferredMode ? "/shcomp_" + LMID + ".bin" : "/shcomp.bin"), FileMode.Create));
                if (clientMode) ftClient.serverFileList.Add("shcomp_" + LMID + ".bin");
                if (bounces > 0)
                {
                    cif.fcompSH.Write(lmname + "_final_RNM0" + (compressedOutput ? ".lz4" : ".dds"));
                    cif.fcompSH.Write(lmname + "_final_RNM1" + (compressedOutput ? ".lz4" : ".dds"));
                    cif.fcompSH.Write(lmname + "_final_RNM2" + (compressedOutput ? ".lz4" : ".dds"));
                    cif.fcompSH.Write(lmname + "_final_RNM3" + (compressedOutput ? ".lz4" : ".dds"));
                }
                if (currentGroup.computeSSS)
                {
                    cif.fcompSH.Write(lmname + "_SSS_RNM0" + (compressedOutput ? ".lz4" : ".dds"));
                    cif.fcompSH.Write(lmname + "_SSS_RNM1" + (compressedOutput ? ".lz4" : ".dds"));
                    cif.fcompSH.Write(lmname + "_SSS_RNM2" + (compressedOutput ? ".lz4" : ".dds"));
                    cif.fcompSH.Write(lmname + "_SSS_RNM3" + (compressedOutput ? ".lz4" : ".dds"));
                }
            }
        }
        fcompStartPos = cif.fcomp.BaseStream.Position;

        // Area lights
        for(int i=0; i<All.Length; i++)
        {
            progressStepsDone++;

            var obj = All[i] as BakeryLightMesh;
            if (!obj.enabled) continue;
            if ((obj.bitmask & currentGroup.bitmask) == 0) continue;

            var lmr = ftBuildGraphics.GetValidRenderer(obj.gameObject);
            var lma = obj.GetComponent<Light>();
            if (lmr == null && lma == null) continue;

            bool isArea = lma != null && ftLightMeshInspector.IsArea(lma);

            if (isArea)
            {
                lmr = null;
            }
            else if (ftBuildGraphics.GetSharedMesh(obj.gameObject) != null)
            {
                lma = null;
            }
            else
            {
                Debug.LogError("Light mesh " + obj.name + " must have either a mesh or an area light");
                continue;
            }

            Bounds lBounds;
            Vector3[] corners = null;
            if (lma != null)
            {
                corners = ftLightMeshInspector.GetAreaLightCorners(lma);
                lBounds = new Bounds(corners[0], Vector3.zero);
                lBounds.Encapsulate(corners[1]);
                lBounds.Encapsulate(corners[2]);
                lBounds.Encapsulate(corners[3]);
            }
            else
            {
                var lmrState = lmr.enabled;
                lmr.enabled = true;
                lBounds = lmr.bounds;
                lmr.enabled = lmrState;
            }

            lBounds.Expand(new Vector3(obj.cutoff, obj.cutoff, obj.cutoff));
            if (!lBounds.Intersects(storage.bounds[LMID])) continue;

            ftBuildLights.BuildLight(obj, SampleCount(obj.samples), corners, deferredMode ? ("lights" + i + ".bin") : "lights.bin");
            if (ftBuildLights.appended.Contains(obj)) continue;

            var lname = GetLightName(obj.gameObject, storage, LMID);
            UpdateLightmapShadowmaskFromAreaLight(obj, LMID, lname, lmname);

            if (doCompose)
            {
                cif.fcomp.Write(lname + "_HDR" + (compressedOutput ? ".lz4" : ".dds"));
                if (bounces > 0)
                {
                    cif.fcomp.Write(obj.indirectIntensity * hackIndirectBoost);
                    if (Mathf.Abs(obj.indirectIntensity - 1.0f) > 0.01f) usesIndirectIntensity = true;
                }

                if ((rmode == (int)RenderMode.Indirect || rmode == (int)RenderMode.Shadowmask)
                        && obj.bakeToIndirect)
                {
                    cif.fcompIndirect.Write(lname + "_HDR" + (compressedOutput ? ".lz4" : ".dds"));
                    if (cif.fcompDirIndirect != null)
                    {
                        cif.fcompDirIndirect.Write(lname + "_HDR" + (compressedOutput ? ".lz4" : ".dds"));
                        cif.fcompDirIndirect.Write(lname + "_Dir" + (compressedOutput ? ".lz4" : ".dds"));
                    }
                }
            }

            string renderMode;
            int passes = PASS_HALF;
            if (dominantDirMode && (rmodeFullLight || obj.bakeToIndirect))
            {
                renderMode = obj.texture == null ? "arealightdir" : "texarealightdir";
                passes |= PASS_DIRECTION;

                cif.fcompDir.Write(lname + "_HDR" + (compressedOutput ? ".lz4" : ".dds"));
                cif.fcompDir.Write(lname + "_Dir" + (compressedOutput ? ".lz4" : ".dds"));
            }
            else if (rnmMode && (rmodeFullLight || obj.bakeToIndirect))
            {
                renderMode = obj.texture == null ? "arealightrnm" : "texarealightrnm";
                if (bounces == 0) passes = 0;
                passes |= PASS_RNM0 | PASS_RNM1 | PASS_RNM2;

                cif.fcompRNM0.Write(lname + "_RNM0" + (compressedOutput ? ".lz4" : ".dds"));
                cif.fcompRNM1.Write(lname + "_RNM1" + (compressedOutput ? ".lz4" : ".dds"));
                cif.fcompRNM2.Write(lname + "_RNM2" + (compressedOutput ? ".lz4" : ".dds"));
            }
            else if (shMode && (rmodeFullLight || obj.bakeToIndirect || shModeProbe))
            {
                if (shModeProbe) {
                    renderMode = obj.texture == null ? "arealightprobesh" : "texarealightprobesh";
                } else {
                    renderMode = obj.texture == null ? "arealightsh" : "texarealightsh";
                }
                if (bounces == 0) passes = 0;
                passes |= PASS_RNM0 | PASS_RNM1 | PASS_RNM2 | PASS_RNM3;

                cif.fcompSH.Write(lname + "_RNM0" + (compressedOutput ? ".lz4" : ".dds"));
                cif.fcompSH.Write(lname + "_RNM1" + (compressedOutput ? ".lz4" : ".dds"));
                cif.fcompSH.Write(lname + "_RNM2" + (compressedOutput ? ".lz4" : ".dds"));
                cif.fcompSH.Write(lname + "_RNM3" + (compressedOutput ? ".lz4" : ".dds"));
            }
            else
            {
                renderMode = obj.texture == null ? "arealight" : "texarealight";
            }

            if (rmode == (int)RenderMode.Shadowmask && obj.shadowmask)
            {
                passes |= PASS_MASK;
                hasAnyShadowmasks = true;
            }

            if (!performRendering) continue;

            var pth = scenePath + "/" + lname + "_HDR" + (compressedOutput ? ".lz4" : ".dds");
            if (!IsLightDirty(obj) && File.Exists(pth)) continue;// && new FileInfo(pth).Length == 128+size*size*8) continue;

            string progressText = "Rendering area light " + obj.name + " for " + lmname + "...";
            if (!deferredMode) ProgressBarShow(progressText, (progressStepsDone / (float)progressSteps), true);
            if (userCanceled)
            {
                if (doCompose)
                {
                    cif.fcomp.Close();
                    if (cif.fcompIndirect != null) cif.fcompIndirect.Close();
                    if (cif.fcompDirIndirect != null) cif.fcompDirIndirect.Close();
                    if (cif.fcompDir != null) cif.fcompDir.Close();
                    if (cif.fcompRNM0 != null) cif.fcompRNM0.Close();
                    if (cif.fcompRNM1 != null) cif.fcompRNM1.Close();
                    if (cif.fcompRNM2 != null) cif.fcompRNM2.Close();
                    if (cif.fcompSH != null) cif.fcompSH.Close();
                }
                yield break;
            }
            yield return null;

            DebugLogInfo("Preparing light " + obj.name + "...");

            int errCode = 0;
            if (exeMode)
            {
                startInfo = new System.Diagnostics.ProcessStartInfo();
                startInfo.CreateNoWindow  = false;
                startInfo.UseShellExecute = false;
#if !LAUNCH_VIA_DLL
                startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
                startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
                startInfo.CreateNoWindow = true;
                /*if (userRenderMode == RenderMode.Shadowmask && obj.shadowmask)
                {
                    passes |= PASS_MASK;
                }*/
                startInfo.Arguments       = renderMode + " " + scenePathQuoted + " \"" + lname + "\" " + passes + " " + 0 + " " + LMID + " lights" + i + ".bin";

                if (deferredMode)
                {
                    deferredFileSrc.Add("");//scenePath + "/lights" + i + ".bin");
                    deferredFileDest.Add("");//scenePath + "/lights.bin");
                    deferredCommands.Add(startInfo);
                    deferredCommandDesc.Add(progressText);
                }
                else
                {
                    /*Debug.Log("Running ftrace " + startInfo.Arguments);
                    exeProcess = System.Diagnostics.Process.Start(startInfo);
                    exeProcess.WaitForExit();
                    errCode = exeProcess.ExitCode;*/
                }
            }
            if (errCode != 0)
            {
                DebugLogError("ftrace error: " + ftErrorCodes.TranslateFtrace(errCode, rtxMode));
                userCanceled = true;
                if (doCompose)
                {
                    cif.fcomp.Close();
                    if (cif.fcompIndirect != null) cif.fcompIndirect.Close();
                    if (cif.fcompDirIndirect != null) cif.fcompDirIndirect.Close();
                    if (cif.fcompDir != null) cif.fcompDir.Close();
                    if (cif.fcompRNM0 != null) cif.fcompRNM0.Close();
                    if (cif.fcompRNM1 != null) cif.fcompRNM1.Close();
                    if (cif.fcompRNM2 != null) cif.fcompRNM2.Close();
                    if (cif.fcompSH != null) cif.fcompSH.Close();
                }
                yield break;//return false;
            }

            //StoreLight(obj);
        }

        // Point lights
        int start = 0;
        int end = 0;
        int sampleCounter = 0;
        int channel = -1;
        bool bakeToIndirect = false;
        bool legacySampling = true;
        float indirectIntensity = 1.0f;
        bool[] skipLight = null;
        int addedLights = 0;
        if (ftAdditionalConfig.batchPointLights)
        {
            if (AllP.Length > 0)
            {
                channel = GetShadowmaskChannel(AllP[0]);
                bakeToIndirect = AllP[0].bakeToIndirect;
                indirectIntensity = AllP[0].indirectIntensity;
                legacySampling = AllP[0].legacySampling;
            }
            skipLight = new bool[AllP.Length];
        }
        for(int i=0; i<AllP.Length; i++)
        {
            progressStepsDone++;
            if (ftAdditionalConfig.batchPointLights) skipLight[i] = true;

            // Cull the light
            var obj = AllP[i] as BakeryPointLight;
            if (!obj.enabled) continue;
            if ((obj.bitmask & currentGroup.bitmask) == 0) continue;

            var boundsRange = obj.cutoff * 2;//obj.GetComponent<Light>().range * 2;
            var lBounds = new Bounds(obj.transform.position, new Vector3(boundsRange, boundsRange, boundsRange));
            if (!lBounds.Intersects(storage.bounds[LMID])) continue;

            string lname = "";
            string settingsFile = "";

            // Split in batches if needed
            bool bakeBatch = false;
            if (ftAdditionalConfig.batchPointLights)
            {
                skipLight[i] = false;
                addedLights++;
                bool split = false;

                // Split by bakeToIndirect
                if (AllP[i].bakeToIndirect != bakeToIndirect)
                {
                    split = true;
                    bakeToIndirect = AllP[i].bakeToIndirect;
                }

                // Split by indirectIntensity
                if (AllP[i].indirectIntensity != indirectIntensity)
                {
                    split = true;
                    indirectIntensity = AllP[i].indirectIntensity;
                }

                // Split by shadowmask channel
                var objChannel = GetShadowmaskChannel(AllP[i]);
                if (objChannel != channel)
                {
                    split = true;
                    channel = objChannel;
                }

                // Split by count
                int newSampleCount = sampleCounter + AllP[i].samples;
                if (newSampleCount > maxSamplesPerPointLightBatch)
                {
                    split = true;
                    sampleCounter = 0;
                }

                // Split by legacySampling
                if (AllP[i].legacySampling != legacySampling)
                {
                    split = true;
                    legacySampling = AllP[i].legacySampling;
                }

                sampleCounter += AllP[i].samples;

                if (split)
                {
                    end = i-1;
                    lname = PrepareBatchPointLight(start, end, LMID, skipLight, cif, rmode, dominantDirMode, rnmMode, shMode, shModeProbe, ref usesIndirectIntensity);
                    settingsFile = "batchpointlight_" + LMID + "_" + start + "_" + end + ".bin";
                    bakeBatch = true;
                }
            }
            else
            {
                // Update shadowmask settings for LMGroup
                lname = GetLightName(obj.gameObject, storage, LMID);
                UpdateLightmapShadowmaskFromPointLight(obj, LMID, lname, lmname);

                // Update composing instructions
                if (WriteCompFiles(obj, cif, lname, rmode, dominantDirMode, rnmMode, shMode, shModeProbe)) usesIndirectIntensity = true;

                settingsFile = "pointlight" + i + ".bin";
            }

            if (!performRendering) continue;

            if (ftAdditionalConfig.batchPointLights)
            {
                if (bakeBatch)
                {
                    // Export batch light data and textures
                    bool isError = ftBuildLights.BuildLights(AllP, start, end, skipLight, sampleDivisor, shModeProbe, settingsFile); // TODO: dirty tex detection!!
                    if (isError)
                    {
                        userCanceled = true;
                        cif.Close();
                        yield break;
                    }

                    // Cancel
                    if (userCanceled)
                    {
                        cif.Close();
                        yield break;
                    }
                    yield return null;

                    // Generate batch command line
                    string renderMode = "batchpointlight";
                    string progressText = "Rendering point light batch (" + (start) + "-" + (end) + ") for " + lmname + "...";
                    AddPointLightCommandLine(renderMode, lname, settingsFile, progressText, LMID, AllP[start], rmode, dominantDirMode, rnmMode, shMode, shModeProbe, AllP[start].legacySampling);

                    start = i;
                }
            }
            else
            {
                // Export light data and textures
                bool isError = ftBuildLights.BuildLight(obj, SampleCount(obj.samples), true, false, settingsFile); // TODO: dirty tex detection!!
                if (isError)
                {
                    userCanceled = true;
                    cif.Close();
                    yield break;
                }
                if (obj.projMode != 0)
                {
                    yield return null;
                }

                // Check if "update unmodified lights" is off, and this light was modified
                var pth = scenePath + "/" + lname + "_HDR" + (compressedOutput ? ".lz4" : ".dds");
                if (!IsLightDirty(obj) && File.Exists(pth)) continue;// && new FileInfo(pth).Length == 128+size*size*8) continue;

                // Get ftrace rendermode
                string renderMode = GetPointLightRenderMode(obj);

                // Progressbar
                string progressText = "Rendering point light " + obj.name + " for " + lmname + "...";

                // Cancel
                if (userCanceled)
                {
                    cif.Close();
                    yield break;
                }
                yield return null;

                // Generate command line
                AddPointLightCommandLine(renderMode, lname, settingsFile, progressText, LMID, AllP[i], rmode, dominantDirMode, rnmMode, shMode, shModeProbe, true);
            }
        }
        if (ftAdditionalConfig.batchPointLights && addedLights > 0)
        {
            end = AllP.Length-1;
            string lname = PrepareBatchPointLight(start, end, LMID, skipLight, cif, rmode, dominantDirMode, rnmMode, shMode, shModeProbe, ref usesIndirectIntensity);
            string settingsFile = "batchpointlight_" + LMID + "_" + start + "_" + end + ".bin";
            string renderMode = "batchpointlight";
            string progressText = "Rendering point light batch (" + (start) + "-" + (end) + ") for " + lmname + "...";
            bool isError = ftBuildLights.BuildLights(AllP, start, end, skipLight, sampleDivisor, shModeProbe, settingsFile); // TODO: dirty tex detection!!
            if (isError)
            {
                userCanceled = true;
                cif.Close();
                yield break;
            }
            AddPointLightCommandLine(renderMode, lname, settingsFile, progressText, LMID, AllP[start], rmode, dominantDirMode, rnmMode, shMode, shModeProbe, AllP[start].legacySampling);
        }

        // Skylight
        for(int i=0; i<All2.Length; i++)
        {
            progressStepsDone++;

            var obj = All2[i] as BakerySkyLight;
            if (!obj.enabled) continue;
            if ((obj.bitmask & currentGroup.bitmask) == 0) continue;

            if (obj.tangentSH && verbose && !askedTangentSH)
            {
                if (!EditorUtility.DisplayDialog("Bakery", "Skylight '"+obj.name+"' has Tangent-space SH enabled. This is an advanced mode generally useful for dynamic object occlusion baking, requiring special shaders. Are you sure you want to continue?", "OK", "Cancel"))
                {
                    userCanceled = true;
                    ProgressBarEnd();
                }
                askedTangentSH = true;
            }

            var lname = GetLightName(obj.gameObject, storage, LMID);
            if (doCompose)
            {
                cif.fcomp.Write(lname + "_HDR" + (compressedOutput ? ".lz4" : ".dds"));
                if (bounces > 0)
                {
                    cif.fcomp.Write(obj.indirectIntensity * hackIndirectBoost);
                    if (Mathf.Abs(obj.indirectIntensity - 1.0f) > 0.01f) usesIndirectIntensity = true;
                }

                if ((rmode == (int)RenderMode.Indirect || rmode == (int)RenderMode.Shadowmask)
                        && obj.bakeToIndirect)
                {
                    cif.fcompIndirect.Write(lname + "_HDR" + (compressedOutput ? ".lz4" : ".dds"));
                    if (cif.fcompDirIndirect != null)
                    {
                        cif.fcompDirIndirect.Write(lname + "_HDR" + (compressedOutput ? ".lz4" : ".dds"));
                        cif.fcompDirIndirect.Write(lname + "_Dir" + (compressedOutput ? ".lz4" : ".dds"));
                    }
                }

                if (dominantDirMode && (rmodeFullLight || obj.bakeToIndirect))
                {
                    cif.fcompDir.Write(lname + "_HDR" + (compressedOutput ? ".lz4" : ".dds"));
                    cif.fcompDir.Write(lname + "_Dir" + (compressedOutput ? ".lz4" : ".dds"));
                }
                else if (rnmMode && (rmodeFullLight || obj.bakeToIndirect))
                {
                    cif.fcompRNM0.Write(lname + "_RNM0" + (compressedOutput ? ".lz4" : ".dds"));
                    cif.fcompRNM1.Write(lname + "_RNM1" + (compressedOutput ? ".lz4" : ".dds"));
                    cif.fcompRNM2.Write(lname + "_RNM2" + (compressedOutput ? ".lz4" : ".dds"));
                }
                else if (shMode && (rmodeFullLight || obj.bakeToIndirect))
                {
                    cif.fcompSH.Write(lname + "_RNM0" + (compressedOutput ? ".lz4" : ".dds"));
                    cif.fcompSH.Write(lname + "_RNM1" + (compressedOutput ? ".lz4" : ".dds"));
                    cif.fcompSH.Write(lname + "_RNM2" + (compressedOutput ? ".lz4" : ".dds"));
                    cif.fcompSH.Write(lname + "_RNM3" + (compressedOutput ? ".lz4" : ".dds"));
                }
            }

            if (!performRendering) continue;

            /*
            if (!storage.skylights.Contains(obj))
            {
                storage.skylights.Add(obj);
                storage.skylightsDirty.Add(true);
            }
            var skylightIndex = storage.skylights.IndexOf(obj);
            */
            var texDirty = obj.cubemap != null;//true;//storage.skylightsDirty[skylightIndex];

            ftBuildLights.BuildSkyLight(obj, SampleCount(obj.samples), texDirty, deferredMode ? "sky" + i + ".bin" : "sky.bin");

            if (texDirty)
            {
                yield return new WaitForSeconds(1);
            }

            //storage.skylightsDirty[skylightIndex] = false;

            var pth = scenePath + "/" + lname + "_HDR" + (compressedOutput ? ".lz4" : ".dds");
            if (!IsLightDirty(obj) && File.Exists(pth)) continue;// && new FileInfo(pth).Length == 128+size*size*8) continue;

            string progressText = "Rendering sky light " + obj.name + " for " + lmname + "...";
            if (!deferredMode) ProgressBarShow(progressText, (progressStepsDone / (float)progressSteps), true);
            if (userCanceled)
            {
                if (doCompose)
                {
                    cif.fcomp.Close();
                    if (cif.fcompIndirect != null) cif.fcompIndirect.Close();
                    if (cif.fcompDirIndirect != null) cif.fcompDirIndirect.Close();
                    if (cif.fcompDir != null) cif.fcompDir.Close();
                    if (cif.fcompRNM0 != null) cif.fcompRNM0.Close();
                    if (cif.fcompRNM1 != null) cif.fcompRNM1.Close();
                    if (cif.fcompRNM2 != null) cif.fcompRNM2.Close();
                    if (cif.fcompSH != null) cif.fcompSH.Close();
                }
                yield break;
            }
            yield return null;

            var bakeDir = (dominantDirMode && (rmodeFullLight || obj.bakeToIndirect));
            var bakeRNM = (rnmMode && (rmodeFullLight || obj.bakeToIndirect));
            var bakeSH = (shMode && (rmodeFullLight || obj.bakeToIndirect || shModeProbe));
            string renderMode;
            if (obj.cubemap != null)
            {
                if (bakeDir)
                {
                    renderMode = "skycubemapdir";
                }
                else if (bakeRNM)
                {
                    renderMode = "skycubemaprnm";
                }
                else if (bakeSH)
                {
                    renderMode = shModeProbe ? "skycubemapprobesh" : "skycubemapsh";
                }
                else
                {
                    renderMode = "skycubemap";
                }
            }
            else
            {
                if (bakeDir)
                {
                    renderMode = "skydir";
                }
                else if (bakeRNM)
                {
                    renderMode = "skyrnm";
                }
                else if (bakeSH)
                {
                    renderMode = (obj.tangentSH && !shModeProbe) ? "skytangentsh" : (shModeProbe ? "skyprobesh" : "skysh");
                }
                else
                {
                    renderMode = "sky";
                }
            }

            int errCode = 0;
            if (exeMode)
            {
                startInfo = new System.Diagnostics.ProcessStartInfo();
                startInfo.CreateNoWindow  = false;
                startInfo.UseShellExecute = false;
#if !LAUNCH_VIA_DLL
                startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
                startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
                startInfo.CreateNoWindow = true;
                int passes = PASS_HALF;
                if (bakeDir) passes |= PASS_DIRECTION;
                if ((bakeRNM || bakeSH) && bounces == 0) passes = 0;
                if (bakeRNM) passes |= PASS_RNM0 | PASS_RNM1 | PASS_RNM2;
                if (bakeSH) passes |= PASS_RNM0 | PASS_RNM1 | PASS_RNM2 | PASS_RNM3;
                startInfo.Arguments       =  renderMode + " " + scenePathQuoted + " \"" + lname + "\" " + passes + " " + 0 + " " + LMID + " sky" + i + ".bin";

                if (deferredMode)
                {
                    deferredFileSrc.Add("");//scenePath + "/sky" + i + ".bin");
                    deferredFileDest.Add("");//scenePath + "/sky.bin");
                    deferredCommands.Add(startInfo);
                    deferredCommandDesc.Add(progressText);
                }
                else
                {
                    /*Debug.Log("Running ftrace " + startInfo.Arguments);
                    exeProcess = System.Diagnostics.Process.Start(startInfo);
                    exeProcess.WaitForExit();
                    errCode = exeProcess.ExitCode;*/
                }
            }

            if (errCode != 0)
            {
                DebugLogError("ftrace error: "+ftErrorCodes.TranslateFtrace(errCode, rtxMode));
                userCanceled = true;
                if (doCompose)
                {
                    cif.fcomp.Close();
                    if (cif.fcompIndirect != null) cif.fcompIndirect.Close();
                    if (cif.fcompDirIndirect != null) cif.fcompDirIndirect.Close();
                    if (cif.fcompDir != null) cif.fcompDir.Close();
                    if (cif.fcompRNM0 != null) cif.fcompRNM0.Close();
                    if (cif.fcompRNM1 != null) cif.fcompRNM1.Close();
                    if (cif.fcompRNM2 != null) cif.fcompRNM2.Close();
                    if (cif.fcompSH != null) cif.fcompSH.Close();
                }
                yield break;
            }
            //StoreLight(obj);
        }

        // Directional light
        for(int i=0; i<All3.Length; i++)
        {
            progressStepsDone++;

            var obj = All3[i] as BakeryDirectLight;
            if (!obj.enabled) continue;
            if ((obj.bitmask & currentGroup.bitmask) == 0) continue;

            var lname = GetLightName(obj.gameObject, storage, LMID);
            if (doCompose && rmode == (int)RenderMode.Shadowmask && obj.shadowmask)
            {
                var ulht = obj.GetComponent<Light>();
                if (ulht == null)
                {
                    DebugLogWarning("Light " + obj.name + " set to shadowmask, but doesn't have real-time light");;
                }
                else
                {
                    UpdateMaskArray(currentGroup.id, lname, lmname, ulht, null, obj.shadowmaskDenoise);
                }
            }

            if (doCompose)
            {
                var texName = lname + "_HDR" + (compressedOutput ? ".lz4" : ".dds");
                cif.fcomp.Write(texName);
                if (bounces > 0)
                {
                    cif.fcomp.Write(obj.indirectIntensity * hackIndirectBoost);
                    if (Mathf.Abs(obj.indirectIntensity - 1.0f) > 0.01f) usesIndirectIntensity = true;
                }

                if ((rmode == (int)RenderMode.Indirect || rmode == (int)RenderMode.Shadowmask)
                        && obj.bakeToIndirect)
                {
                    cif.fcompIndirect.Write(texName);
                    if (cif.fcompDirIndirect != null)
                    {
                        cif.fcompDirIndirect.Write(lname + "_HDR" + (compressedOutput ? ".lz4" : ".dds"));
                        cif.fcompDirIndirect.Write(lname + "_Dir" + (compressedOutput ? ".lz4" : ".dds"));
                    }
                }

                if (dominantDirMode && (rmodeFullLight || obj.bakeToIndirect))
                {
                    cif.fcompDir.Write(lname + "_HDR" + (compressedOutput ? ".lz4" : ".dds"));
                    cif.fcompDir.Write(lname + "_Dir" + (compressedOutput ? ".lz4" : ".dds"));
                }
                else if (rnmMode && (rmodeFullLight || obj.bakeToIndirect))
                {
                    cif.fcompRNM0.Write(lname + "_RNM0" + (compressedOutput ? ".lz4" : ".dds"));
                    cif.fcompRNM1.Write(lname + "_RNM1" + (compressedOutput ? ".lz4" : ".dds"));
                    cif.fcompRNM2.Write(lname + "_RNM2" + (compressedOutput ? ".lz4" : ".dds"));
                }
                else if (shMode && (rmodeFullLight || obj.bakeToIndirect))
                {
                    cif.fcompSH.Write(lname + "_RNM0" + (compressedOutput ? ".lz4" : ".dds"));
                    cif.fcompSH.Write(lname + "_RNM1" + (compressedOutput ? ".lz4" : ".dds"));
                    cif.fcompSH.Write(lname + "_RNM2" + (compressedOutput ? ".lz4" : ".dds"));
                    cif.fcompSH.Write(lname + "_RNM3" + (compressedOutput ? ".lz4" : ".dds"));
                }
            }

            if (!performRendering) continue;

            ftBuildLights.BuildDirectLight(obj, SampleCount(obj.samples), false, deferredMode ? "direct" + i + ".bin" : "direct.bin");

            if (hasAnyVolumes)
            {
                ftBuildLights.BuildDirectLight(obj, SampleCount(obj.samples), true, deferredMode ? "direct" + i + "_volumes.bin" : "direct.bin");
            }

            var pth = scenePath + "/" + lname + "_HDR" + (compressedOutput ? ".lz4" : ".dds");
            if (!IsLightDirty(obj) && File.Exists(pth)) continue;// && new FileInfo(pth).Length == 128+size*size*8) continue;
            //Debug.Log(IsLightDirty(obj)+" "+File.Exists(pth)+" "+(new FileInfo(pth).Length == 128+size*size*8));

            string progressText = "Rendering direct light " + obj.name + " for " + lmname + "...";
            if (!deferredMode) ProgressBarShow(progressText, (progressStepsDone / (float)progressSteps), true);
            if (userCanceled)
            {
                if (doCompose)
                {
                    cif.fcomp.Close();
                    if (cif.fcompIndirect != null) cif.fcompIndirect.Close();
                    if (cif.fcompDirIndirect != null) cif.fcompDirIndirect.Close();
                    if (cif.fcompDir != null) cif.fcompDir.Close();
                    if (cif.fcompRNM0 != null) cif.fcompRNM0.Close();
                    if (cif.fcompRNM1 != null) cif.fcompRNM1.Close();
                    if (cif.fcompRNM2 != null) cif.fcompRNM2.Close();
                    if (cif.fcompSH != null) cif.fcompSH.Close();
                }
                yield break;
            }
            yield return null;

            int errCode = 0;
            if (exeMode)
            {
                startInfo = new System.Diagnostics.ProcessStartInfo();
                startInfo.CreateNoWindow  = false;
                startInfo.UseShellExecute = false;
#if !LAUNCH_VIA_DLL
                startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
                startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
                startInfo.CreateNoWindow = true;

                int passes = PASS_HALF;
                bool allowSupersample = !shModeProbe;
                if (currentGroup != null && currentGroup.mode == BakeryLightmapGroup.ftLMGroupMode.Vertex) allowSupersample = false;
                string rrmode = GetSunRenderMode(obj, allowSupersample); // no SHProbe mode for supersample
                if (dominantDirMode && (rmodeFullLight || obj.bakeToIndirect))
                {
                    passes |= PASS_DIRECTION;
                }
                else if (rnmMode && (rmodeFullLight || obj.bakeToIndirect))
                {
                    rrmode += "rnm";
                    if (bounces == 0) passes = 0;
                    passes |= PASS_RNM0 | PASS_RNM1 | PASS_RNM2;
                }
                else if (shMode && (rmodeFullLight || obj.bakeToIndirect))
                {
                    rrmode += shModeProbe ? "probesh" : "sh";
                    if (bounces == 0) passes = 0;
                    passes |= PASS_RNM0 | PASS_RNM1 | PASS_RNM2 | PASS_RNM3;
                }
                if (userRenderMode == RenderMode.Shadowmask && obj.shadowmask)
                {
                    passes |= PASS_MASK;
                    if (currentGroup.transparentSelfShadow) passes |= PASS_MASK1;
                    hasAnyShadowmasks = true;
                }

                startInfo.Arguments       =  rrmode + " " + scenePathQuoted + " \"" + lname + "\" " + passes + " " + 0 + " " + LMID +
                    " direct" + i + ((currentGroup.probes && currentGroup.name == "volumes") ? "_volumes" : "") + ".bin";

                deferredFileSrc.Add("");//scenePath + "/direct" + i + ".bin");
                deferredFileDest.Add("");//scenePath + "/direct.bin");
                deferredCommands.Add(startInfo);
                deferredCommandDesc.Add(progressText);
            }

            if (errCode != 0)
            {
                DebugLogError("ftrace error: "+ftErrorCodes.TranslateFtrace(errCode, rtxMode));
                userCanceled = true;
                if (doCompose)
                {
                    cif.fcomp.Close();
                    if (cif.fcompIndirect != null) cif.fcompIndirect.Close();
                    if (cif.fcompDirIndirect != null) cif.fcompDirIndirect.Close();
                    if (cif.fcompDir != null) cif.fcompDir.Close();
                    if (cif.fcompRNM0 != null) cif.fcompRNM0.Close();
                    if (cif.fcompRNM1 != null) cif.fcompRNM1.Close();
                    if (cif.fcompRNM2 != null) cif.fcompRNM2.Close();
                    if (cif.fcompSH != null) cif.fcompSH.Close();
                }
                yield break;//return false;
            }
            //StoreLight(obj);
        }

        lmnameComposed[lmname] = true;

        if (dominantDirMode && cif.fcompDir.BaseStream.Position > 0)
        {
            lightmapHasDir[LMID] = true;
        }

        if (rnmMode && cif.fcompRNM0.BaseStream.Position > 0)
        {
            lightmapHasRNM[LMID] = true;
        }

        if (shMode && cif.fcompSH.BaseStream.Position > 0)
        {
            lightmapHasRNM[LMID] = true;
        }

        if (cif.fcomp.BaseStream.Position == fcompStartPos)
        {
            cif.fcomp.Write(lmname + "_lights_HDR.dds");

            /*cif.fcomp.Close();
            if (cif.fcompIndirect != null) cif.fcompIndirect.Close();*/
            DebugLogInfo("No lights for " + lmname);

            var fpos = new BinaryWriter(File.Open(scenePath + "/" + lmname + "_lights_HDR.dds", FileMode.Create));
            if (clientMode) ftClient.serverFileList.Add(lmname + "_lights_HDR.dds");
            //var fpos = new BinaryWriter(File.Open(scenePath + "/" + lmname + "_diffuse_HDR" + (compressedOutput ? ".lz4" : ".dds"), FileMode.Create));
            fpos.Write(ftDDS.ddsHeaderHalf4);

            int atlasTexSize = resolution;
            if (currentGroup.mode == BakeryLightmapGroup.ftLMGroupMode.Vertex)
            {
                atlasTexSize = (int)Mathf.Ceil(Mathf.Sqrt((float)currentGroup.totalVertexCount));
                atlasTexSize = (int)Mathf.Ceil(atlasTexSize / (float)ftRenderLightmap.tileSize) * ftRenderLightmap.tileSize;
            }

            var halfs = new ushort[atlasTexSize*atlasTexSize*4];
            for(int f=0; f<atlasTexSize*atlasTexSize*4; f+=4)
            {
                halfs[f+3] = 15360; // 1.0f in halffloat
            }
            var posbytes = new byte[atlasTexSize * atlasTexSize * 8];
            System.Buffer.BlockCopy(halfs, 0, posbytes, 0, posbytes.Length);
            fpos.Write(posbytes);
            fpos.BaseStream.Seek(12, SeekOrigin.Begin);
            fpos.Write(atlasTexSize);
            fpos.Write(atlasTexSize);
            fpos.Close();

            //yield break;
        }
        else if (usesIndirectIntensity)
        {
            cif.fcomp.Seek(0, SeekOrigin.Begin);
            cif.fcomp.Write(true);
        }

        if (rmode == (int)RenderMode.Shadowmask && cif.fcompIndirect.BaseStream.Position == 0)
        {
            lightmapHasColor[LMID] = false;
        }

        if (!doCompose)
        {
            progressStepsDone++;
            yield break;
        }

        progressStepsDone++;
        string progressText2 = "Compositing lighting for " + lmname + "...";
        if (!deferredMode) ProgressBarShow(progressText2 , (progressStepsDone / (float)progressSteps), true);
        if (userCanceled)
        {
            cif.fcomp.Close();
            if (cif.fcompIndirect != null) cif.fcompIndirect.Close();
            if (cif.fcompDirIndirect != null) cif.fcompDirIndirect.Close();
            if (cif.fcompDir != null) cif.fcompDir.Close();
            if (cif.fcompRNM0 != null) cif.fcompRNM0.Close();
            if (cif.fcompRNM1 != null) cif.fcompRNM1.Close();
            if (cif.fcompRNM2 != null) cif.fcompRNM2.Close();
            if (cif.fcompSH != null) cif.fcompSH.Close();
            yield break;
        }
        yield return null;

        // Compose
        cif.fcomp.Close();
        if (cif.fcompIndirect != null) cif.fcompIndirect.Close();
        if (cif.fcompDirIndirect != null) cif.fcompDirIndirect.Close();
        if (cif.fcompDir != null) cif.fcompDir.Close();
        if (cif.fcompRNM0 != null) cif.fcompRNM0.Close();
        if (cif.fcompRNM1 != null) cif.fcompRNM1.Close();
        if (cif.fcompRNM2 != null) cif.fcompRNM2.Close();
        if (cif.fcompSH != null) cif.fcompSH.Close();
        if (!performRendering) yield break;
        DebugLogInfo("Compositing...");

        int errCode2 = 0;
        if (exeMode)
        {
            startInfo = new System.Diagnostics.ProcessStartInfo();
            startInfo.CreateNoWindow  = false;
            startInfo.UseShellExecute = false;
#if !LAUNCH_VIA_DLL
            startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
            startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
            startInfo.CreateNoWindow = true;

            bool shouldAddLights = !(bounces == 0 && (shMode || rnmMode));

            if (shouldAddLights)
            {
                if (bounces == 0)
                {
                    startInfo.Arguments       =  "add " + scenePathQuoted + " \"" + lmname + "_final_HDR" + (compressedOutput ? ".lz4" : ".dds")
                    + "\" " + PASS_HALF + " " + 0 + " " + LMID + " comp_" + LMID + ".bin";
                }
                else
                {
                    startInfo.Arguments       =  "addmul " + scenePathQuoted + " \"" + lmname + "\" " + PASS_HALF + " " + 0 + " " + LMID + " comp_" + LMID + ".bin";;
                }

                deferredFileSrc.Add("");//scenePath + "/comp_" + LMID + ".bin");
                deferredFileDest.Add("");//scenePath + "/comp.bin");
                deferredCommands.Add(startInfo);
                deferredCommandDesc.Add(progressText2);
            }

            if (dominantDirMode)// && rmode == (int)RenderMode.FullLighting)
            {
                progressText2 = "Compositing direction for " + lmname + "...";
                startInfo = new System.Diagnostics.ProcessStartInfo();
                startInfo.CreateNoWindow  = false;
                startInfo.UseShellExecute = false;
#if !LAUNCH_VIA_DLL
                startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
                startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
                startInfo.CreateNoWindow = true;

                startInfo.Arguments       =  "diradd " + scenePathQuoted + " \"" + lmname + (bounces > 0 ? "_lights_Dir" : "_final_Dir") + (compressedOutput ? ".lz4" : ".dds")
                + "\" " + PASS_DIRECTION + " " + 0 + " " + LMID + " dircomp_" + LMID + ".bin";

                if (deferredMode)
                {
                    deferredFileSrc.Add("");//scenePath + "/dircomp_" + LMID + ".bin");
                    deferredFileDest.Add("");//scenePath + "/dircomp.bin");
                    deferredCommands.Add(startInfo);
                    deferredCommandDesc.Add(progressText2);
                }
                else
                {
                    Debug.LogError("Not supported");
                }
            }
        }

        if (errCode2 != 0)
        {
            DebugLogError("ftrace error: "+ftErrorCodes.TranslateFtrace(errCode2, rtxMode));
            userCanceled = true;
            yield break;
        }
    }

    bool RenderLMAO(int LMID, string lmname)
    {
        string progressText = "Rendering AO for " + lmname + "...";
        if (!deferredMode) ProgressBarShow(progressText, (progressStepsDone / (float)progressSteps), true);

        var rmode = currentGroup.renderMode == BakeryLightmapGroup.RenderMode.Auto ? (int)userRenderMode : (int)currentGroup.renderMode;

        int passes = rmode == (int)RenderMode.AmbientOcclusionOnly ? PASS_HALF : PASS_MASK;

        // There is no realistic weight for AO to mix with other light directions
        var dirMode = currentGroup.renderDirMode == BakeryLightmapGroup.RenderDirMode.Auto ? (int)renderDirMode : (int)currentGroup.renderDirMode;
        var dominantDirMode = dirMode == (int)ftRenderLightmap.RenderDirMode.DominantDirection;
        if (dominantDirMode && rmode == (int)RenderMode.AmbientOcclusionOnly) passes |= PASS_DIRECTION;

        var fao = new BinaryWriter(File.Open(scenePath + "/ao.bin", FileMode.Create));
        if (clientMode) ftClient.serverFileList.Add("ao.bin");
        fao.Write(SampleCount(hackAOSamples));
        fao.Write(hackAORadius);
        fao.Write(rmode == (int)RenderMode.AmbientOcclusionOnly ? hackAOIntensity : 1.0f);
        fao.Close();

        System.Diagnostics.ProcessStartInfo startInfo;
        //System.Diagnostics.Process exeProcess;

        int errCode = 0;
        if (exeMode)
        {
            startInfo = new System.Diagnostics.ProcessStartInfo();
            startInfo.CreateNoWindow  = false;
            startInfo.UseShellExecute = false;
#if !LAUNCH_VIA_DLL
            startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
            startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
            startInfo.CreateNoWindow = true;
            string renderMode;
            if (dominantDirMode && rmode == (int)RenderMode.AmbientOcclusionOnly)
            {
                renderMode = "aodir";
            }
            else
            {
                renderMode = "ao";//currentGroup.aoIsThickness ? "thickness" : "ao";
            }

            if (rmode ==  (int)RenderMode.AmbientOcclusionOnly)
            {
                startInfo.Arguments       =  renderMode + " " + scenePathQuoted + " \"" + lmname + "_final" +  "\" " + passes + " " + dilate + " " + LMID;
            }
            else
            {
                startInfo.Arguments       =  renderMode + " " + scenePathQuoted + " \"" + lmname + "_ao" +  "\" " + passes + " " + dilate + " " + LMID;
            }

            deferredFileSrc.Add("");
            deferredFileDest.Add("");
            deferredCommands.Add(startInfo);
            deferredCommandDesc.Add(progressText);
        }

        if (errCode != 0)
        {
            DebugLogError("ftrace error: "+ftErrorCodes.TranslateFtrace(errCode, rtxMode));
            userCanceled = true;
            return false;
        }
        return true;
    }

    void RenderLMSSS(BakeryLightmapGroup lmgroup, bool lastPass, bool firstPass)
    {
        int LMID = lmgroup.id;

        //var rmode = lmgroup.renderMode == BakeryLightmapGroup.RenderMode.Auto ? (int)userRenderMode : (int)lmgroup.renderMode;

        var dirMode = lmgroup.renderDirMode == BakeryLightmapGroup.RenderDirMode.Auto ? (int)renderDirMode : (int)lmgroup.renderDirMode;
        var dominantDirMode = dirMode == (int)ftRenderLightmap.RenderDirMode.DominantDirection && lightmapHasDir[lmgroup.id];
        var rnmMode = dirMode == (int)ftRenderLightmap.RenderDirMode.RNM && lightmapHasRNM[LMID];
        var shMode = (dirMode == (int)ftRenderLightmap.RenderDirMode.SH || dirMode == (int)ftRenderLightmap.RenderDirMode.MonoSH) && lightmapHasRNM[LMID];

        int passes = PASS_HALF;
        //if (dominantDirMode && lastPass) passes |= PASS_DIRECTION;
        if (rnmMode && lastPass) passes |= PASS_RNM0 | PASS_RNM1 | PASS_RNM2;
        if (shMode && lastPass) passes |= PASS_RNM0 | PASS_RNM1 | PASS_RNM2 | PASS_RNM3;

        var remode = "sss";
        if (dominantDirMode)
        {
            //rmode = "sss";
            Debug.LogError("SSS does not output its own direction, thus unlit SSS-only parts can look too bright (Group: " + lmgroup.name + ")");
        }
        else if (rnmMode)
        {
            //remode = "sssrnm";
            Debug.LogError("SSS is not currently supported in RNM mode (Group: " + lmgroup.name + ")");
        }
        else if (shMode && lastPass)
        {
            remode = "ssssh";
        }

        var fname = "sss" + LMID + "_"+(lastPass?1:0)+".bin";
        var fsss = new BinaryWriter(File.Open(scenePath + "/" + fname, FileMode.Create));
        if (clientMode) ftClient.serverFileList.Add(fname);

        var rmode = (int)lmgroup.renderMode == (int)BakeryLightmapGroup.RenderMode.Auto ? (int)userRenderMode : (int)lmgroup.renderMode;
        bool indirectRMode = rmode == (int)RenderMode.Indirect || rmode == (int)RenderMode.Shadowmask;

        if (bounces == 0 && shMode && indirectRMode) Debug.LogError("SSS won't work in Shadowmask mode with SH directional mode and 0 bounces (Group: " + lmgroup.name + ")");

        var inputTex = lmgroup.name + (lastPass ? "_final" : "_diffuse") + "_HDR" + (compressedOutput ? ".lz4" : ".dds");

        fsss.Write(SampleCount(lmgroup.sssSamples));
        fsss.Write(lmgroup.sssDensity);
        fsss.Write(Mathf.Pow(lmgroup.sssColor.r,2.2f) * lmgroup.sssScale);
        fsss.Write(Mathf.Pow(lmgroup.sssColor.g,2.2f) * lmgroup.sssScale);
        fsss.Write(Mathf.Pow(lmgroup.sssColor.b,2.2f) * lmgroup.sssScale);
        if (lastPass)
        {
            fsss.Write(indirectRMode ? 0 : 1); // only add SSS to GI in full lighting
        }
        else
        {
            fsss.Write(1); // always add SSS to _diffuse direct lighting
        }
        fsss.Write(inputTex);
        fsss.Close();

        var startInfo = new System.Diagnostics.ProcessStartInfo();
        startInfo.CreateNoWindow  = false;
        startInfo.UseShellExecute = false;
#if !LAUNCH_VIA_DLL
        startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
        startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
        startInfo.CreateNoWindow = true;
        startInfo.Arguments       =  remode + " " + scenePathQuoted + " \"" + lmgroup.name + (lastPass ? ((shMode || indirectRMode) ? "_SSS" : "_final") : "_diffuse")
        + "\"" + " " + passes + " " + 16 + " " + lmgroup.id
        + " " + fname
        + " \"" + inputTex + "\""; // full lighting passed as direct

        deferredFileSrc.Add("");//scenePath + "/sss" + LMID + ".bin");
        deferredFileDest.Add("");//scenePath + "/sss.bin");
        deferredCommands.Add(startInfo);
        deferredCommandDesc.Add("Computing subsurface scattering for " + lmgroup.name + "...");

        if (firstPass && bounces > 0)
        {
            deferredFileSrc.Add(scenePath + "/" + lmgroup.name + "_diffuse_HDR" + (compressedOutput ? ".lz4" : ".dds"));
            deferredFileDest.Add(scenePath + "/" + lmgroup.name + "_diffuse0_HDR" + (compressedOutput ? ".lz4" : ".dds"));
            deferredCommands.Add(null);
            deferredCommandDesc.Add("Computing subsurface scattering for " + lmgroup.name + " (2) ...");
        }
    }

    bool RenderLMGI(int LMID, string lmname, int i, bool needsGIPass, bool lastPass)
    {
        string progressText = "Rendering GI bounce " + i + " for " + lmname + "...";
        if (!deferredMode) ProgressBarShow(progressText, (progressStepsDone / (float)progressSteps), true);

        var dirMode = currentGroup.renderDirMode == BakeryLightmapGroup.RenderDirMode.Auto ? (int)renderDirMode : (int)currentGroup.renderDirMode;
        var dominantDirMode = dirMode == (int)ftRenderLightmap.RenderDirMode.DominantDirection && lightmapHasDir[LMID];
        var rnmMode = dirMode == (int)ftRenderLightmap.RenderDirMode.RNM && lightmapHasRNM[LMID];
        var shMode = (dirMode == (int)ftRenderLightmap.RenderDirMode.SH || dirMode == (int)ftRenderLightmap.RenderDirMode.MonoSH) && lightmapHasRNM[LMID];
        var shModeProbe = dirMode == (int)BakeryLightmapGroup.RenderDirMode.ProbeSH && lightmapHasRNM[LMID];
        if (shModeProbe) shMode = true;

        // Needs both HALF and SECONDARY_HALF because of multiple lightmaps reading each other's lighting
        int passes = needsGIPass ? (PASS_HALF|PASS_SECONDARY_HALF) : PASS_HALF;

        if (dominantDirMode && lastPass) passes |= PASS_DIRECTION;
        if (rnmMode && lastPass) passes |= PASS_RNM0 | PASS_RNM1 | PASS_RNM2;
        if (shMode && lastPass) passes |= PASS_RNM0 | PASS_RNM1 | PASS_RNM2 | PASS_RNM3;

        System.Diagnostics.ProcessStartInfo startInfo;
        //System.Diagnostics.Process exeProcess;

        int errCode = 0;
        if (exeMode)
        {
            startInfo = new System.Diagnostics.ProcessStartInfo();
            startInfo.CreateNoWindow  = false;
            startInfo.UseShellExecute = false;
#if !LAUNCH_VIA_DLL
            startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
            startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
            startInfo.CreateNoWindow = true;
            string rmode = "texgi";
            if (dominantDirMode && lastPass)
            {
                rmode = "texgidir";
            }
            else if (rnmMode && lastPass)
            {
                rmode = "texgirnm";
            }
            else if (shMode && lastPass)
            {
                rmode = shModeProbe ? "texgiprobesh" : "texgish";
            }
            startInfo.Arguments       =  rmode + " " + scenePathQuoted + " \"" + lmname + (i==bounces-1 ? "_final" : "_diffuse") +  "\" " + passes + " " + dilate + " " + LMID;
            startInfo.Arguments += " \"gi_" + lmname + i + ".bin\"";
            if (i == bounces-1)
            {
                // add direct lighting on top of GI
                startInfo.Arguments += " \"" + lmname + "_lights_HDR" + (compressedOutput ? ".lz4" : ".dds") + "\""; // direct lighting
            }
            else
            {
                // add direct*albedo+emissive on top of GI
                startInfo.Arguments += " \"" + lmname + "_diffuse0_HDR" + (compressedOutput ? ".lz4" : ".dds") + "\""; // direct lighting
            }

            /*if (giLodModeEnabled)
            {
                startInfo.Arguments += " vbTraceTex" + LMID + ".bin";
            }
            else
            {*/
                startInfo.Arguments += " vbTraceTex.bin";
            //}

            deferredFileSrc.Add("");//scenePath + "/gi_" + lmname + i + ".bin");
            deferredFileDest.Add("");//scenePath + "/gi.bin");
            deferredCommands.Add(startInfo);
            deferredCommandDesc.Add(progressText);
        }

        if (errCode != 0)
        {
            DebugLogError("ftrace error: "+ftErrorCodes.TranslateFtrace(errCode, rtxMode));
            userCanceled = true;
            return false;
        }
        return true;
    }

    void UpdateMaskArray(int LMID, string lname, string lmname, Light ulht, BakeryPointLight lht, bool denoise)
    {
        int maskChannel = -1;
        if (ulht != null)
        {
#if UNITY_2017_3_OR_NEWER
            maskChannel = ulht.bakingOutput.occlusionMaskChannel;
#else
            var so = new SerializedObject(ulht);
            maskChannel = so.FindProperty("m_BakingOutput").FindPropertyRelative("occlusionMaskChannel").intValue;
#endif
        }
        else if (lht != null)
        {
            maskChannel = lht.maskChannel;
        }

        if (maskChannel >=0 && maskChannel <= 3)
        {
            var maskArray = lightmapMasks[LMID];
            var maskArrayLMNames = lightmapMaskLMNames[LMID];
            var maskArrayLights = lightmapMaskLights[LMID];
            var maskArrayDenoise = lightmapMaskDenoise[LMID];
            while(maskArray.Count < maskChannel + 1)
            {
                maskArray.Add(new List<string>());
                maskArrayLMNames.Add(new List<string>());
                maskArrayLights.Add(new List<Light>());
                maskArrayDenoise.Add(new List<bool>());
            }
            maskArray[maskChannel].Add(lname + "_Mask" + (compressedOutput ? ".lz4" : ".dds"));
            maskArrayLMNames[maskChannel].Add(lmname);
            maskArrayLights[maskChannel].Add(ulht);
            maskArrayDenoise[maskChannel].Add(denoise);
            lightmapHasMask[LMID]++;// = true;
        }
    }

    bool SetupLightShadowmask(Light light, int channel)
    {
        bool success = true;
        if (channel > 3)
        {
            success = false;
            DebugLogWarning("Light " + light.name + " can't generate shadow mask (out of channels).");
            overlappingLights.Add(light.gameObject);
        }

        int occlusionMaskChannel = channel > 3 ? -1 : channel;

#if UNITY_2017_3_OR_NEWER
        var output = new LightBakingOutput();
        output.isBaked = true;
        output.lightmapBakeType = LightmapBakeType.Mixed;
        output.mixedLightingMode = userRenderMode == RenderMode.Shadowmask ? MixedLightingMode.Shadowmask : MixedLightingMode.Subtractive;
        output.occlusionMaskChannel = occlusionMaskChannel;
        output.probeOcclusionLightIndex  = light.bakingOutput.probeOcclusionLightIndex;
        light.bakingOutput = output;
#else
        light.alreadyLightmapped = true;
        light.lightmapBakeType = LightmapBakeType.Mixed;
        var so = new SerializedObject(light);
        var sp = so.FindProperty("m_BakingOutput");
        sp.FindPropertyRelative("occlusionMaskChannel").intValue = occlusionMaskChannel;
        //sp.FindPropertyRelative("probeOcclusionLightIndex").intValue = -1;
        sp.FindPropertyRelative("lightmappingMask").intValue = -1;
        so.ApplyModifiedProperties();

        if (!maskedLights.Contains(light)) maskedLights.Add(light);

#endif

        var st = storages[light.gameObject.scene];
        if (!st.bakedLights.Contains(light))
        {
            st.bakedLights.Add(light);
            st.bakedLightChannels.Add(occlusionMaskChannel);
        }

        return success;
    }

    void PrepareAssetImporting()
    {
        var outputPathCompat = outputPathFull.Replace("\\", "/");

        // Prepare asset importing: set AssetPostprocessor settings
        ftTextureProcessor.texSettings = new Dictionary<string, Int2>();
        foreach(var lmgroup in groupListGIContributingPlain)
        {
            if (lmgroup.vertexBake) continue;
            var nm = lmgroup.name;

            int colorSize = lmgroup.resolution / (1 << (int)((1.0f - ftBuildGraphics.mainLightmapScale) * 6));
            int maskSize = lmgroup.resolution / (1 << (int)((1.0f - ftBuildGraphics.maskLightmapScale) * 6));
            int dirSize = lmgroup.resolution / (1 << (int)((1.0f - ftBuildGraphics.dirLightmapScale) * 6));

            var dirMode = lmgroup.renderDirMode == (int)BakeryLightmapGroup.RenderDirMode.Auto ? (int)renderDirMode : (int)lmgroup.renderDirMode;
            var dominantDirMode = dirMode == (int)ftRenderLightmap.RenderDirMode.DominantDirection && lightmapHasDir[lmgroup.id];
            var rnmMode = dirMode == (int)ftRenderLightmap.RenderDirMode.RNM && lightmapHasRNM[lmgroup.id];
            var shMode = (dirMode == (int)ftRenderLightmap.RenderDirMode.SH || dirMode == (int)ftRenderLightmap.RenderDirMode.MonoSH) && lightmapHasRNM[lmgroup.id];
            var shModeProbe = dirMode == (int)BakeryLightmapGroup.RenderDirMode.ProbeSH && lightmapHasRNM[lmgroup.id];
            var shModeMono = dirMode == (int)BakeryLightmapGroup.RenderDirMode.MonoSH;
            if (shModeProbe) shMode = true;

            //if (!bc6h)
            {
                //if (File.Exists(folder + "../Assets/" + nm + "_final.hdr"))
                {
                    //var outfile = "Assets/"+nm+"_final_RGBM.dds";
                    //Texture2D lm = null;
                    var outfile = "Assets/" + outputPathCompat + "/"+nm+"_final.hdr";
                    if (rnmMode) outfile = "Assets/" + outputPathCompat + "/"+nm+"_RNM0.hdr";
                    var desiredTextureType = encodeMode == 0 ? ftTextureProcessor.TEX_LM : ftTextureProcessor.TEX_LMDEFAULT;
                    if (lightmapHasColor[lmgroup.id])// && File.Exists(outfile))
                    {
                        ftTextureProcessor.texSettings[outfile] = new Int2(colorSize, desiredTextureType);
                    }

                    //Texture2D mask = null;
                    //if (userRenderMode == RenderMode.Shadowmask && lightmapMasks[lmgroup.id].Count > 0)
                    if (lightmapHasMask[lmgroup.id] > 0)
                    {
                        outfile = "Assets/" + outputPathCompat + "/"+nm+"_mask" + (pstorage.format8bit == BakeryProjectSettings.FileFormat.PNG ? ".png" : ".tga");
                        desiredTextureType = lightmapHasMask[lmgroup.id] >= 4 ? ftTextureProcessor.TEX_MASK : ftTextureProcessor.TEX_MASK_NO_ALPHA;
                        ftTextureProcessor.texSettings[outfile] = new Int2(maskSize, desiredTextureType);
                    }

                    //Texture2D dirLightmap = null;
                    if (dominantDirMode)
                    {
                        outfile = "Assets/" + outputPathCompat + "/"+nm+"_dir" + (pstorage.format8bit == BakeryProjectSettings.FileFormat.PNG ? ".png" : ".tga");
                        desiredTextureType = ftTextureProcessor.TEX_DIR;// TextureImporterType.Default;
                        ftTextureProcessor.texSettings[outfile] = new Int2(dirSize, desiredTextureType);
                    }

                    //Texture2D rnmLightmap0 = null;
                    //Texture2D rnmLightmap1 = null;
                    //Texture2D rnmLightmap2 = null;
                    if (rnmMode)
                    {
                        desiredTextureType = encodeMode == 0 ? ftTextureProcessor.TEX_LM : ftTextureProcessor.TEX_LMDEFAULT;
                        //TextureImporterType.Lightmap : TextureImporterType.Default;
                        for(int c=0; c<3; c++)
                        {
                            outfile = "Assets/" + outputPathCompat + "/"+nm+"_RNM" + c + ".hdr";
                            ftTextureProcessor.texSettings[outfile] = new Int2(dirSize, desiredTextureType);
                        }
                    }

                    if (shMode)
                    {
                        outfile = "Assets/" + outputPathCompat + "/"+nm+"_L0.hdr";
                        desiredTextureType = encodeMode == 0 ? ftTextureProcessor.TEX_LM : ftTextureProcessor.TEX_LMDEFAULT;
                        ftTextureProcessor.texSettings[outfile] = new Int2(colorSize, desiredTextureType);

                        desiredTextureType = ftTextureProcessor.TEX_DIR;// TextureImporterType.Default;
                        if (shModeMono)
                        {
                            desiredTextureType = ftTextureProcessor.TEX_DIR_NO_ALPHA;
                            outfile = "Assets/" + outputPathCompat + "/"+nm+"_L1" + (pstorage.format8bit == BakeryProjectSettings.FileFormat.PNG ? ".png" : ".tga");
                            ftTextureProcessor.texSettings[outfile] = new Int2(dirSize, desiredTextureType);
                        }
                        else
                        {
                            for(int c=0; c<3; c++)
                            {
                                string comp;
                                if (c==0)
                                {
                                    comp = "x";
                                }
                                else if (c==1)
                                {
                                    comp = "y";
                                }
                                else
                                {
                                    comp = "z";
                                }
                                outfile = "Assets/" + outputPathCompat + "/"+nm+"_L1" + comp + (pstorage.format8bit == BakeryProjectSettings.FileFormat.PNG ? ".png" : ".tga");
                                ftTextureProcessor.texSettings[outfile] = new Int2(dirSize, desiredTextureType);
                            }
                        }
                    }
                }
            }
        }

#if UNITY_2021_2_OR_NEWER

        // For parallel import
        if (UnityEditor.EditorSettings.refreshImportMode == AssetDatabase.RefreshImportMode.OutOfProcessPerQueue)
        {
            /*gstorage.texSettingsKey = new List<string>();
            gstorage.texSettingsVal = new List<Vector2>();
            foreach(var pair in ftTextureProcessor.texSettings)
            {
                gstorage.texSettingsKey.Add(pair.Key);
                gstorage.texSettingsVal.Add(pair.Value);
            }*/
            mmfTexProc = MemoryMappedFile.CreateOrOpen("FTEXPROC", maxTexSettingsSize, MemoryMappedFileAccess.ReadWrite);
            var stream = mmfTexProc.CreateViewStream(0, maxTexSettingsSize);
            var formatter = new BinaryFormatter();
            formatter.Serialize(stream, ftTextureProcessor.texSettings);
            stream.Flush();
        }
#endif
    }

    IEnumerator RenderLMAddBuckets(int LMID, string lmname, int resolution, bool vertexBake, int lmgroupRenderDirMode, int lmgroupRenderMode)
    {
        var dirMode = lmgroupRenderDirMode == (int)BakeryLightmapGroup.RenderDirMode.Auto ? (int)renderDirMode : (int)lmgroupRenderDirMode;
        var dominantDirMode = dirMode == (int)ftRenderLightmap.RenderDirMode.DominantDirection;
        var rnmMode = dirMode == (int)ftRenderLightmap.RenderDirMode.RNM && lightmapHasRNM[LMID];
        var shMode = (dirMode == (int)ftRenderLightmap.RenderDirMode.SH || dirMode == (int)ftRenderLightmap.RenderDirMode.MonoSH) && lightmapHasRNM[LMID];
        var shModeProbe = dirMode == (int)BakeryLightmapGroup.RenderDirMode.ProbeSH && lightmapHasRNM[LMID];
        if (shModeProbe) shMode = true;
        var shadowmask = (userRenderMode == RenderMode.Shadowmask);

        if (rnmMode)
        {
            for(int c=0; c<3; c++)
            {
                var startInfo = new System.Diagnostics.ProcessStartInfo();
                startInfo.CreateNoWindow  = false;
                startInfo.UseShellExecute = false;
        #if !LAUNCH_VIA_DLL
                startInfo.WorkingDirectory = dllPath + "/Bakery";
        #endif
                startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
                startInfo.CreateNoWindow = true;
                startInfo.Arguments       =  "postadd " + scenePathQuoted + " \"" + lmname + "_final_RNM" + c + (compressedOutput ? ".lz4" : ".dds")
                + "\"" + " " + PASS_HALF + " " + 0 + " " + LMID + " comp_addbuckets" + c + "_" + LMID + ".bin";

                deferredFileSrc.Add("");
                deferredFileDest.Add("");
                deferredCommands.Add(startInfo);
                deferredCommandDesc.Add("Compositing lightmaps for " + lmname + "...");

                var fcomp = new BinaryWriter(File.Open(scenePath + "/comp_addbuckets" + c + "_" + LMID + ".bin", FileMode.Create));
                if (clientMode) ftClient.serverFileList.Add("comp_addbuckets" + c + "_" + LMID + ".bin");
                fcomp.Write(lmname + "_final_RNM" + c + (compressedOutput ? ".lz4" : ".dds"));
                fcomp.Write("uvnormal_" + lmname + (compressedGBuffer ? ".lz4" : ".dds"));
                foreach(var lmgroup in groupListPlain)
                {
                    if (lmgroup.parentName != lmname) continue;
                    fcomp.Write(lmgroup.name + "_final_RNM" + c + (compressedOutput ? ".lz4" : ".dds"));
                    fcomp.Write("uvnormal_" + lmgroup.name + (compressedGBuffer ? ".lz4" : ".dds"));
                }
                fcomp.Close();
            }
        }
        else if (shMode)
        {
            var startInfo = new System.Diagnostics.ProcessStartInfo();
            startInfo.CreateNoWindow  = false;
            startInfo.UseShellExecute = false;
    #if !LAUNCH_VIA_DLL
            startInfo.WorkingDirectory = dllPath + "/Bakery";
    #endif
            startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
            startInfo.CreateNoWindow = true;
            startInfo.Arguments       =  "postadd " + scenePathQuoted + " \"" + lmname + "_final_L0" + (compressedOutput ? ".lz4" : ".dds")
            + "\"" + " " + PASS_HALF + " " + 0 + " " + LMID + " comp_addbucketsL0_" + LMID + ".bin";

            deferredFileSrc.Add("");
            deferredFileDest.Add("");
            deferredCommands.Add(startInfo);
            deferredCommandDesc.Add("Compositing lightmaps for " + lmname + "...");

            var fcomp = new BinaryWriter(File.Open(scenePath + "/comp_addbucketsL0_" + LMID + ".bin", FileMode.Create));
            if (clientMode) ftClient.serverFileList.Add("comp_addbucketsL0_" + LMID + ".bin");
            fcomp.Write(lmname + "_final_L0" + (compressedOutput ? ".lz4" : ".dds"));
            fcomp.Write("uvnormal_" + lmname + (compressedGBuffer ? ".lz4" : ".dds"));
            foreach(var lmgroup in groupListPlain)
            {
                if (lmgroup.parentName != lmname) continue;
                fcomp.Write(lmgroup.name + "_final_L0" + (compressedOutput ? ".lz4" : ".dds"));
                fcomp.Write("uvnormal_" + lmgroup.name + (compressedGBuffer ? ".lz4" : ".dds"));
            }
            fcomp.Close();

            for(int c=0; c<3; c++)
            {
                string cname;
                switch(c)
                {
                    case 0:
                        cname = "L1x";
                        break;
                    case 1:
                        cname = "L1y";
                        break;
                    default:
                        cname = "L1z";
                        break;
                }

                startInfo = new System.Diagnostics.ProcessStartInfo();
                startInfo.CreateNoWindow  = false;
                startInfo.UseShellExecute = false;
    #if !LAUNCH_VIA_DLL
                startInfo.WorkingDirectory = dllPath + "/Bakery";
    #endif
                startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
                startInfo.CreateNoWindow = true;
                startInfo.Arguments       =  "postdiradd " + scenePathQuoted + " \"" + lmname + "_final_" + cname + (compressedOutput ? ".lz4" : ".dds")
                + "\"" + " " + PASS_DIRECTION + " " + 0 + " " + LMID + " dircomp_addbuckets" + c + "_" + LMID + ".bin";

                deferredFileSrc.Add("");
                deferredFileDest.Add("");
                deferredCommands.Add(startInfo);
                deferredCommandDesc.Add("Compositing directions for " + lmname + "...");

                fcomp = new BinaryWriter(File.Open(scenePath + "/dircomp_addbuckets" + c + "_" + LMID + ".bin", FileMode.Create));
                if (clientMode) ftClient.serverFileList.Add("dircomp_addbuckets" + c + "_" + LMID + ".bin");
                fcomp.Write(lmname + "_final_" + cname + (compressedOutput ? ".lz4" : ".dds"));
                fcomp.Write("uvnormal_" + lmname + (compressedGBuffer ? ".lz4" : ".dds"));
                foreach(var lmgroup in groupListPlain)
                {
                    if (lmgroup.parentName != lmname) continue;
                    fcomp.Write(lmgroup.name + "_final_" +  cname + (compressedOutput ? ".lz4" : ".dds"));
                    fcomp.Write("uvnormal_" + lmgroup.name + (compressedGBuffer ? ".lz4" : ".dds"));
                }
                fcomp.Close();
            }
        }
        else
        {
            var startInfo = new System.Diagnostics.ProcessStartInfo();
            startInfo.CreateNoWindow  = false;
            startInfo.UseShellExecute = false;
    #if !LAUNCH_VIA_DLL
            startInfo.WorkingDirectory = dllPath + "/Bakery";
    #endif
            startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
            startInfo.CreateNoWindow = true;
            startInfo.Arguments       =  "postadd " + scenePathQuoted + " \"" + lmname + "_final_HDR" + (compressedOutput ? ".lz4" : ".dds")
            + "\"" + " " + PASS_HALF + " " + 0 + " " + LMID + " comp_addbuckets" + LMID + ".bin";

            deferredFileSrc.Add("");
            deferredFileDest.Add("");
            deferredCommands.Add(startInfo);
            deferredCommandDesc.Add("Compositing lightmaps for " + lmname + "...");

            var fcomp = new BinaryWriter(File.Open(scenePath + "/comp_addbuckets" + LMID + ".bin", FileMode.Create));
            if (clientMode) ftClient.serverFileList.Add("comp_addbuckets" + LMID + ".bin");
            fcomp.Write(lmname + "_final_HDR" + (compressedOutput ? ".lz4" : ".dds"));
            fcomp.Write("uvnormal_" + lmname + (compressedGBuffer ? ".lz4" : ".dds"));
            foreach(var lmgroup in groupListPlain)
            {
                //Debug.LogError("Cur: "+lmname+", "+LMID+", this parent: " + lmgroup.name+", "+lmgroup.parentID);
                //if (lmgroup.parentID != LMID) continue;
                if (lmgroup.parentName != lmname) continue;
                fcomp.Write(lmgroup.name + "_final_HDR" + (compressedOutput ? ".lz4" : ".dds"));
                fcomp.Write("uvnormal_" + lmgroup.name + (compressedGBuffer ? ".lz4" : ".dds"));
            }
            fcomp.Close();
        }

        if (dominantDirMode)
        {
            var startInfo = new System.Diagnostics.ProcessStartInfo();
            startInfo.CreateNoWindow  = false;
            startInfo.UseShellExecute = false;
#if !LAUNCH_VIA_DLL
            startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
            startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
            startInfo.CreateNoWindow = true;
            startInfo.Arguments       =  "postdiradd " + scenePathQuoted + " \"" + lmname + "_final_Dir" + (compressedOutput ? ".lz4" : ".dds")
            + "\"" + " " + PASS_DIRECTION + " " + 0 + " " + LMID + " dircomp_addbuckets" + LMID + ".bin";

            deferredFileSrc.Add("");
            deferredFileDest.Add("");
            deferredCommands.Add(startInfo);
            deferredCommandDesc.Add("Compositing directions for " + lmname + "...");

            var fcomp = new BinaryWriter(File.Open(scenePath + "/dircomp_addbuckets" + LMID + ".bin", FileMode.Create));
            if (clientMode) ftClient.serverFileList.Add("dircomp_addbuckets" + LMID + ".bin");
            fcomp.Write(lmname + "_final_Dir" + (compressedOutput ? ".lz4" : ".dds"));
            fcomp.Write("uvnormal_" + lmname + (compressedGBuffer ? ".lz4" : ".dds"));
            foreach(var lmgroup in groupListPlain)
            {
                if (lmgroup.parentName != lmname) continue;
                fcomp.Write(lmgroup.name + "_final_Dir" + (compressedOutput ? ".lz4" : ".dds"));
                fcomp.Write("uvnormal_" + lmgroup.name + (compressedGBuffer ? ".lz4" : ".dds"));
            }
            fcomp.Close();
        }

        if (shadowmask)
        {
            var maskNames = lightmapMasks[LMID];
            var maskLights = lightmapMaskLights[LMID];
            if (maskNames != null)
            {
                for(int c=0; c<maskNames.Count; c++)
                {
                    var maskNamesOnChannel = maskNames[c];
                    var maskLightsOnChannel = maskLights[c];

                    for(int i=0; i<maskNamesOnChannel.Count; i++)
                    {
                        var uid = LMID + "_" + c + "_" + i;

                        var startInfo = new System.Diagnostics.ProcessStartInfo();
                        startInfo.CreateNoWindow  = false;
                        startInfo.UseShellExecute = false;
            #if !LAUNCH_VIA_DLL
                        startInfo.WorkingDirectory = dllPath + "/Bakery";
            #endif
                        startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
                        startInfo.CreateNoWindow = true;
                        startInfo.Arguments       =  "postmaskadd " + scenePathQuoted + " \"" + maskNamesOnChannel[i]
                        + "\"" + " " + PASS_MASK + " " + 0 + " " + LMID + " maskcomp_addbuckets" + uid + ".bin";

                        deferredFileSrc.Add("");
                        deferredFileDest.Add("");
                        deferredCommands.Add(startInfo);
                        deferredCommandDesc.Add("Compositing masks for " + lmname + "...");

                        var fcomp = new BinaryWriter(File.Open(scenePath + "/maskcomp_addbuckets" + uid + ".bin", FileMode.Create));
                        if (clientMode) ftClient.serverFileList.Add("maskcomp_addbuckets" + uid + ".bin");
                        fcomp.Write(maskNamesOnChannel[i]);
                        fcomp.Write("uvnormal_" + lmname + (compressedGBuffer ? ".lz4" : ".dds"));
                        foreach(var lmgroup2 in groupListPlain)
                        {
                            if (lmgroup2.parentName != lmname) continue;

                            var maskNames2 = lightmapMasks[lmgroup2.id];
                            var maskLMNames2 = lightmapMaskLMNames[lmgroup2.id];
                            var maskLights2 = lightmapMaskLights[lmgroup2.id];
                            int channels2 = maskNames2.Count;
                            if (channels2 <= c) continue;

                            var names2 = maskNames2[c];
                            var lmnames2 = maskLMNames2[c];
                            var lights2 = maskLights2[c];
                            for(int k=0; k<names2.Count; k++)
                            {
                                if (lights2[k] != maskLightsOnChannel[i]) continue;
                                fcomp.Write(names2[k]);
                                fcomp.Write("uvnormal_" + lmnames2[k] + (compressedGBuffer ? ".lz4" : ".dds"));
                            }
                        }
                        fcomp.Close();
                    }
                }
            }
        }

        yield break;
    }

    static int GetDenoiseStartTileSize(int resolution)
    {
        return System.Math.Min(resolution, 2048); // workaround for the new NV driver bug
    }

    string GetDenoiseMode()
    {
        string denoiseMod;
        switch(denoiserType)
        {
            case ftGlobalStorage.DenoiserType.OpenImageDenoise2:
                denoiseMod = "OIDN2";
                break;
            case ftGlobalStorage.DenoiserType.OpenImageDenoise:
                denoiseMod = "OIDN";
                break;
            case ftGlobalStorage.DenoiserType.Optix5:
                denoiseMod = "Legacy";
                break;
            case ftGlobalStorage.DenoiserType.Optix7:
                denoiseMod = "72";
                break;
            default:
                denoiseMod = "";
                break;
        }
        return denoiseMod;
    }

    IEnumerator RenderLMCombineMasks(int LMID, string lmname, int resolution, bool vertexBake, int lmgroupRenderMode, BakeryLightmapGroupPlain lmgroup)
    {
        System.Diagnostics.ProcessStartInfo startInfo;
        string progressText;

        //var rmode = lmgroupRenderMode == (int)BakeryLightmapGroup.RenderMode.Auto ? (int)userRenderMode : (int)lmgroupRenderMode;
        var denoiseMod = GetDenoiseMode();

        // Combine shadow masks
        if (userRenderMode == RenderMode.Shadowmask)
        {
            var maskNames = lightmapMasks[LMID];
            var maskLights = lightmapMaskLights[LMID];
            var maskDenoise = lightmapMaskDenoise[LMID];

            bool process = true;
            if (ftBuildGraphics.postPacking)
            {
                if (lmgroup.parentName != null && lmgroup.parentName.Length > 0 && lmgroup.parentName != "|")
                {
                    process = false;
                }
                /*else if (lmgroup.parentName == "|")
                {
                    foreach(var lmgroup2 in groupListPlain)
                    {
                        if (lmgroup2.parentName == lmgroup.name)
                        {
                            var maskNames2 = lightmapMasks[lmgroup2.id];
                            var maskLights2 = lightmapMaskLights[lmgroup2.id];
                            var maskDenoise2 = lightmapMaskDenoise[lmgroup2.id];
                            int channels2 = maskNames2.Count;
                            for(int j=0; j<channels2; j++)
                            {
                                var names2 = maskNames2[j];
                                var lights2 = maskLights2[j];
                                var denoise2 = maskDenoise2[j];
                                for(int k=0; k<names2.Count; k++)
                                {
                                    maskNames[j].Add(names2[k]);
                                    maskLights[j].Add(lights2[k]);
                                    maskDenoise[j].Add(denoise2[k]);
                                }
                            }
                        }
                    }
                }*/
            }

            if (maskNames.Count > 0 && process)
            {
                var fcomp = new BinaryWriter(File.Open(scenePath + ("/masks_" + LMID + ".bin"), FileMode.Create));
                if (clientMode) ftClient.serverFileList.Add("masks_" + LMID + ".bin");
                fcomp.Write(maskNames[0].Count);
                fcomp.Write(maskNames.Count > 1 ? maskNames[1].Count : 0);
                fcomp.Write(maskNames.Count > 2 ? maskNames[2].Count : 0);
                fcomp.Write(maskNames.Count > 3 ? maskNames[3].Count : 0);
                for(int channel=0; channel<maskNames.Count; channel++)
                {
                    for(int i=0; i<maskNames[channel].Count; i++)
                    {
                        fcomp.Write(maskNames[channel][i]);
                        if (vertexBake) continue;
                        if (!maskDenoise[channel][i]) continue;
                        if (maskLights[channel][i] == null) continue;

                        progressText = "Denoising light " + maskLights[channel][i].name + " for shadowmask " + lmname + "...";
                        if (userCanceled) yield break;
                        yield return null;

                        startInfo = new System.Diagnostics.ProcessStartInfo();
                        startInfo.CreateNoWindow  = false;
                        startInfo.UseShellExecute = false;
                        startInfo.WorkingDirectory = "Assets/Editor/x64/Bakery";
                        startInfo.FileName        = Application.dataPath + "/Editor/x64/Bakery/denoiser"+denoiseMod+".exe";
                        startInfo.CreateNoWindow = true;
                        startInfo.Arguments       = "m \"" + scenePath +  "/" + maskNames[channel][i] + "\" \"" + scenePath +  "/" + maskNames[channel][i] + "\"";
                        string firstArgs = startInfo.Arguments;
                        startInfo.Arguments += " " + GetDenoiseStartTileSize(resolution) + " 0";

                        if (deferredMode)
                        {
                            deferredFileSrc.Add("");
                            deferredFileDest.Add("");
                            deferredCommands.Add(startInfo);
                            deferredCommandDesc.Add(progressText);
                            List<string> list;
                            deferredCommandsFallback[deferredCommands.Count - 1] = list = new List<string>();

                            int denoiseRes = GetDenoiseStartTileSize(resolution);
                            while(denoiseRes > 64)
                            {
                                denoiseRes /= 2;
                                list.Add(firstArgs + " " + denoiseRes + " 0");
                            }
                        }
                        else
                        {
                            // unsupported
                        }
                    }
                }
                fcomp.Close();

                progressText = "Creating shadow masks for " + lmname + "...";
                if (!deferredMode) ProgressBarShow(progressText, (progressStepsDone / (float)progressSteps), true);
                if (userCanceled) yield break;
                yield return null;

                var outPath = Application.dataPath + "/" + outputPathFull + "/" + lmname + "_mask" + (pstorage.format8bit == BakeryProjectSettings.FileFormat.PNG ? ".png" : ".tga");
                if (File.Exists(outPath)) ValidateFileAttribs(outPath);

                startInfo = new System.Diagnostics.ProcessStartInfo();
                startInfo.CreateNoWindow  = false;
                startInfo.UseShellExecute = false;
                startInfo.WorkingDirectory = "Assets/Editor/x64/Bakery";
                startInfo.FileName        = Application.dataPath + "/Editor/x64/Bakery/combineMasks.exe";
                startInfo.CreateNoWindow = true;
                if (vertexBake)
                {
                    startInfo.Arguments       = "\"" + scenePath + "/" + lmname + "_mask.lz4\" ";
                }
                else
                {
                    startInfo.Arguments       = "\"" + outPath + "\" ";
                }
                                                                /*maskNames[0] + " ";
                if (maskNames.Count > 1) startInfo.Arguments += maskNames[1] + " ";
                if (maskNames.Count > 2) startInfo.Arguments += maskNames[2] + " ";
                if (maskNames.Count > 3) startInfo.Arguments += maskNames[3] + " ";*/
                startInfo.Arguments +=
                "\"" + scenePath + ("/masks_" + LMID + ".bin") + "\" " +
                "\"" + scenePath + "/\"";

                //for(int i=0; i<maskLights.Count; i++) SetupLightShadowmask(maskLights[i], i);

                if (deferredMode)
                {
                    deferredFileSrc.Add("");
                    deferredFileDest.Add("");
                    deferredCommands.Add(startInfo);
                    deferredCommandDesc.Add(progressText);
                    if (clientMode && !vertexBake) ftClient.serverGetFileList.Add(lmname + "_mask" + (pstorage.format8bit == BakeryProjectSettings.FileFormat.PNG ? ".png" : ".tga"));
                }
                else
                {
                    Debug.LogError("Doesn't work in non-deferred mode");
                }
            }
        }
    }

    IEnumerator RenderLMFinalize(int LMID, string lmname, int resolution, bool vertexBake, int lmgroupRenderDirMode, int lmgroupRenderMode, BakeryLightmapGroupPlain lmgroup)
    {
        System.Diagnostics.ProcessStartInfo startInfo;
        //System.Diagnostics.Process exeProcess;
        string progressText;

        var dirMode = lmgroupRenderDirMode == (int)BakeryLightmapGroup.RenderDirMode.Auto ? (int)renderDirMode : (int)lmgroupRenderDirMode;
        var dominantDirMode = dirMode == (int)ftRenderLightmap.RenderDirMode.DominantDirection;
        var rnmMode = dirMode == (int)ftRenderLightmap.RenderDirMode.RNM && lightmapHasRNM[LMID];
        var shMode = (dirMode == (int)ftRenderLightmap.RenderDirMode.SH || dirMode == (int)ftRenderLightmap.RenderDirMode.MonoSH) && lightmapHasRNM[LMID];
        var shModeProbe = dirMode == (int)BakeryLightmapGroup.RenderDirMode.ProbeSH && lightmapHasRNM[LMID];
        if (shModeProbe) shMode = true;

        var rmode = lmgroupRenderMode == (int)BakeryLightmapGroup.RenderMode.Auto ? (int)userRenderMode : (int)lmgroupRenderMode;

        var denoiseMod = GetDenoiseMode();

        // Denoise directions
        if (dominantDirMode && denoise && !vertexBake && lightmapHasDir[LMID])
        {
            progressText = "Denoising direction for " + lmname + "...";
            //if (userCanceled) yield break;
            //yield return null;

            startInfo = new System.Diagnostics.ProcessStartInfo();
            startInfo.CreateNoWindow  = false;
            startInfo.UseShellExecute = false;
            startInfo.WorkingDirectory = "Assets/Editor/x64/Bakery";
            startInfo.FileName        = Application.dataPath + "/Editor/x64/Bakery/denoiser"+denoiseMod+".exe";
            startInfo.CreateNoWindow = true;
            startInfo.Arguments       = (alternativeDenoiseDir?"D":"d") + " \"" + scenePath + "/" + lmname + "_final_Dir" + (compressedOutput ? ".lz4" : ".dds") + "\" \"" + scenePath + "/" + lmname + "_final_Dir"  + (compressedOutput ? ".lz4" : ".dds") + "\"";
            string firstArgs = startInfo.Arguments;
            startInfo.Arguments += " " + GetDenoiseStartTileSize(resolution) + " 0";

            if (deferredMode)
            {
                deferredFileSrc.Add("");
                deferredFileDest.Add("");
                deferredCommands.Add(startInfo);
                deferredCommandDesc.Add(progressText);
                List<string> list;
                deferredCommandsFallback[deferredCommands.Count - 1] = list = new List<string>();

                int denoiseRes = GetDenoiseStartTileSize(resolution);
                while(denoiseRes > 64)
                {
                    denoiseRes /= 2;
                    list.Add(firstArgs + " " + denoiseRes + " 0");
                }
            }
            else
            {
                // unsupported
            }
        }

        if (!lightmapHasColor[LMID]) yield break;

        // Apply AO if needed
        if (hackAOIntensity > 0 && hackAOSamples > 0 && !rnmMode && !shMode && !lmgroup.probes && rmode != (int)RenderMode.AmbientOcclusionOnly)
        {
            progressText = "Applying AO to " + lmname + "...";
            if (userCanceled) yield break;//return false;

            var fcomp = new BinaryWriter(File.Open(scenePath + "/addao_" + LMID + ".bin", FileMode.Create));
            if (clientMode) ftClient.serverFileList.Add("addao_" + LMID + ".bin");
            fcomp.Write(lmname + (shMode ? "_final_L0" : "_final_HDR") + (compressedOutput ? ".lz4" : ".dds"));
            fcomp.Write(lmname + "_ao_Mask" + (compressedOutput ? ".lz4" : ".dds"));
            fcomp.Write(hackAOIntensity);
            fcomp.Close();

            startInfo = new System.Diagnostics.ProcessStartInfo();
            startInfo.CreateNoWindow  = false;
            startInfo.UseShellExecute = false;
#if !LAUNCH_VIA_DLL
            startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
            startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
            startInfo.CreateNoWindow = true;
            startInfo.Arguments       =  "addao " + scenePathQuoted + " \"" + lmname + (shMode ? "_final_L0" : "_final_HDR") + (compressedOutput ? ".lz4" : ".dds")
            + "\"" + " " + PASS_HALF + " " + 0 + " " + LMID + " addao_" + LMID + ".bin";

            deferredFileSrc.Add("");//scenePath + "/addao_" + LMID + ".bin");
            deferredFileDest.Add("");//scenePath + "/addao.bin");
            deferredCommands.Add(startInfo);
            deferredCommandDesc.Add(progressText);
        }

        // Denoise
        if (denoise && !vertexBake)
        {
            if (!shMode && !rnmMode)
            {
                progressText = "Denoising " + lmname + "...";
                if (userCanceled) yield break;//return false;
                yield return null;

                startInfo = new System.Diagnostics.ProcessStartInfo();
                startInfo.CreateNoWindow  = false;
                startInfo.UseShellExecute = false;
                startInfo.WorkingDirectory = "Assets/Editor/x64/Bakery";
                startInfo.FileName        = Application.dataPath + "/Editor/x64/Bakery/denoiser"+denoiseMod+".exe";
                startInfo.CreateNoWindow = true;
                startInfo.Arguments       = "c \"" + scenePath + "/" + lmname + "_final_HDR" + (compressedOutput ? ".lz4" : ".dds") + "\" \"" + scenePath + "/" + lmname + "_final_HDR"  + (compressedOutput ? ".lz4" : ".dds") + "\"";
                string firstArgs = startInfo.Arguments;
                startInfo.Arguments += " " + GetDenoiseStartTileSize(resolution) + " " + (denoise2x ? 1 : 0);

                if (deferredMode)
                {
                    deferredFileSrc.Add("");
                    deferredFileDest.Add("");
                    deferredCommands.Add(startInfo);
                    deferredCommandDesc.Add(progressText);
                    List<string> list;
                    deferredCommandsFallback[deferredCommands.Count - 1] = list = new List<string>();

                    int denoiseRes = GetDenoiseStartTileSize(resolution);
                    while(denoiseRes > 64)
                    {
                        denoiseRes /= 2;
                        list.Add(firstArgs + " " + denoiseRes + " " + (denoise2x ? 1 : 0));
                    }
                }
            }
        }
        progressStepsDone++;

        string progressText2;

        if (rnmMode && lightmapHasRNM[LMID])
        {
            for(int c=0; c<3; c++)
            {
                // Compose RNM
                progressText2 = "Composing RNM" + c + " for " + lmname + "...";
                startInfo = new System.Diagnostics.ProcessStartInfo();
                startInfo.CreateNoWindow  = false;
                startInfo.UseShellExecute = false;
#if !LAUNCH_VIA_DLL
                startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
                startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
                startInfo.CreateNoWindow = true;
                startInfo.Arguments       =  "add " + scenePathQuoted + " \"" + lmname + "_final_RNM" + c + (compressedOutput ? ".lz4" : ".dds")
                + "\" " + PASS_HALF + " " + 0 + " " + LMID + " rnm" + c +"comp_" + LMID + ".bin";
                if (deferredMode)
                {
                    deferredFileSrc.Add("");//scenePath + "/rnm" + c +"comp_" + LMID + ".bin");
                    deferredFileDest.Add("");//scenePath + "/comp.bin");
                    deferredCommands.Add(startInfo);
                    deferredCommandDesc.Add(progressText2);
                }
                else
                {
                    Debug.LogError("Not supported");
                }

                if (hackAOIntensity > 0 && hackAOSamples > 0)
                {
                    progressText = "Applying AO to " + lmname + "...";
                    //for(int c=0; c<3; c++)
                    {
                        var fcomp = new BinaryWriter(File.Open(scenePath + "/addao_" + LMID + "_" + c + ".bin", FileMode.Create));
                        if (clientMode) ftClient.serverFileList.Add("addao_" + LMID + "_" + c + ".bin");
                        fcomp.Write(lmname + "_final_RNM" + c + (compressedOutput ? ".lz4" : ".dds"));
                        fcomp.Write(lmname + "_ao_Mask" + (compressedOutput ? ".lz4" : ".dds"));
                        fcomp.Write(hackAOIntensity);
                        fcomp.Close();

                        startInfo = new System.Diagnostics.ProcessStartInfo();
                        startInfo.CreateNoWindow  = false;
                        startInfo.UseShellExecute = false;
#if !LAUNCH_VIA_DLL
                        startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
                        startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
                        startInfo.CreateNoWindow = true;
                        startInfo.Arguments       =  "addao " + scenePathQuoted + " \"" + lmname + "_final_RNM" + c + (compressedOutput ? ".lz4" : ".dds")
                        + "\"" + " " + PASS_HALF + " " + 0 + " " + LMID + " addao_" + LMID + "_" + c + ".bin";

                        if (deferredMode)
                        {
                            deferredFileSrc.Add("");//scenePath + "/addao_" + LMID + "_" + c + ".bin");
                            deferredFileDest.Add("");//scenePath + "/addao.bin");
                            deferredCommands.Add(startInfo);
                            deferredCommandDesc.Add(progressText);
                        }
                    }
                }

                if (denoise && !vertexBake)
                {
                    progressText = "Denoising RNM" + c + " for " + lmname + "...";
                    if (userCanceled) yield break;
                    yield return null;
                    startInfo = new System.Diagnostics.ProcessStartInfo();
                    startInfo.CreateNoWindow  = false;
                    startInfo.UseShellExecute = false;
                    startInfo.WorkingDirectory = "Assets/Editor/x64/Bakery";
                    startInfo.FileName        = Application.dataPath + "/Editor/x64/Bakery/denoiser"+denoiseMod+".exe";
                    startInfo.CreateNoWindow = true;
                    startInfo.Arguments       = "c \"" + scenePath + "/" + lmname + "_final_RNM" + c + (compressedOutput ? ".lz4" : ".dds") + "\" \"" + scenePath + "/" + lmname + "_final_RNM" + c + (compressedOutput ? ".lz4" : ".dds") + "\"";
                    string firstArgs = startInfo.Arguments;
                    startInfo.Arguments += " " + GetDenoiseStartTileSize(resolution) + " " + (denoise2x ? 1 : 0);
                    if (deferredMode)
                    {
                        deferredFileSrc.Add("");
                        deferredFileDest.Add("");
                        deferredCommands.Add(startInfo);
                        deferredCommandDesc.Add(progressText);
                        List<string> list;
                        deferredCommandsFallback[deferredCommands.Count - 1] = list = new List<string>();

                        int denoiseRes = GetDenoiseStartTileSize(resolution);
                        while(denoiseRes > 64)
                        {
                            denoiseRes /= 2;
                            list.Add(firstArgs + " " + denoiseRes + " " + (denoise2x ? 1 : 0));
                        }
                    }
                    else
                    {
                        Debug.LogError("Not supported");
                    }
                }
            }
        }

        if (shMode && lightmapHasRNM[LMID])
        {
            // Compose SH
            progressText2 = "Composing SH " + " for " + lmname + "...";
            startInfo = new System.Diagnostics.ProcessStartInfo();
            startInfo.CreateNoWindow  = false;
            startInfo.UseShellExecute = false;
#if !LAUNCH_VIA_DLL
            startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
            startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
            startInfo.CreateNoWindow = true;
            startInfo.Arguments       =  "addsh " + scenePathQuoted + " \"" + lmname + "_final_"
            + "\" " + PASS_HALF + " " + 0 + " " + LMID + " shcomp_" + LMID + ".bin";
            if (deferredMode)
            {
                deferredFileSrc.Add("");//scenePath + "/shcomp_" + LMID + ".bin");
                deferredFileDest.Add("");//scenePath + "/shcomp.bin");
                deferredCommands.Add(startInfo);
                deferredCommandDesc.Add(progressText2);
            }
            else
            {
                Debug.LogError("Not supported");
            }

            if (hackAOIntensity > 0 && hackAOSamples > 0 && !lmgroup.probes)
            {
                progressText = "Applying AO to " + lmname + "...";
                var fcomp = new BinaryWriter(File.Open(scenePath + "/addao_" + LMID + ".bin", FileMode.Create));
                if (clientMode) ftClient.serverFileList.Add("addao_" + LMID + ".bin");
                fcomp.Write(lmname + (shMode ? "_final_L0" : "_final_HDR") + (compressedOutput ? ".lz4" : ".dds"));
                fcomp.Write(lmname + "_ao_Mask" + (compressedOutput ? ".lz4" : ".dds"));
                fcomp.Write(hackAOIntensity);
                fcomp.Close();

                startInfo = new System.Diagnostics.ProcessStartInfo();
                startInfo.CreateNoWindow  = false;
                startInfo.UseShellExecute = false;
#if !LAUNCH_VIA_DLL
                startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
                startInfo.FileName        = startInfo.WorkingDirectory + "/" + ftraceExe;
                startInfo.CreateNoWindow = true;
                startInfo.Arguments       =  "addao " + scenePathQuoted + " \"" + lmname + (shMode ? "_final_L0" : "_final_HDR") + (compressedOutput ? ".lz4" : ".dds")
                + "\"" + " " + PASS_HALF + " " + 0 + " " + LMID + " addao_" + LMID + ".bin";

                deferredFileSrc.Add("");//scenePath + "/addao_" + LMID + ".bin");
                deferredFileDest.Add("");//scenePath + "/addao.bin");
                deferredCommands.Add(startInfo);
                deferredCommandDesc.Add(progressText);
            }

            if (denoise && !vertexBake)
            {
                progressText = "Denoising SH for " + lmname + "...";
                if (userCanceled) yield break;
                yield return null;
                startInfo = new System.Diagnostics.ProcessStartInfo();
                startInfo.CreateNoWindow  = false;
                startInfo.UseShellExecute = false;
                startInfo.WorkingDirectory = "Assets/Editor/x64/Bakery";
                startInfo.FileName        = Application.dataPath + "/Editor/x64/Bakery/denoiser"+denoiseMod+".exe";
                startInfo.CreateNoWindow = true;
                startInfo.Arguments      = "s ";
                startInfo.Arguments      += "\"" + scenePath + "/" + lmname + "_final_L0" + (compressedOutput ? ".lz4" : ".dds") +
                                         "\" \"" + scenePath + "/" + lmname + "_final_L1x" + (compressedOutput ? ".lz4" : ".dds") +
                                         "\" \"" + scenePath + "/" + lmname + "_final_L1y" + (compressedOutput ? ".lz4" : ".dds") +
                                         "\" \"" + scenePath + "/" + lmname + "_final_L1z" + (compressedOutput ? ".lz4" : ".dds") +
                                         "\"";
                string firstArgs = startInfo.Arguments;
                startInfo.Arguments += " " + GetDenoiseStartTileSize(resolution) + " " + (denoise2x ? 1 : 0);
                deferredFileSrc.Add("");
                deferredFileDest.Add("");
                deferredCommands.Add(startInfo);
                deferredCommandDesc.Add(progressText);
                List<string> list;
                deferredCommandsFallback[deferredCommands.Count - 1] = list = new List<string>();

                int denoiseRes = GetDenoiseStartTileSize(resolution);
                while(denoiseRes > 64)
                {
                    denoiseRes /= 2;
                    list.Add(firstArgs + " " + denoiseRes + " 0");
                }
            }


        }

        // Fix seams
        if (fixSeams && !vertexBake)
        {
            progressText = "Fixing seams " + lmname + "...";
            if (userCanceled) yield break;//return false;
            yield return null;

            startInfo = new System.Diagnostics.ProcessStartInfo();
            startInfo.CreateNoWindow  = false;
            startInfo.UseShellExecute = false;
            startInfo.WorkingDirectory = "Assets/Editor/x64/Bakery";
            startInfo.FileName        = Application.dataPath + "/Editor/x64/Bakery/seamfixer.exe";
            startInfo.CreateNoWindow = true;
            startInfo.Arguments       = "\"" + scenePath + "\" \"" +
                                               LMID + "\" \"";
            if (shMode)
            {
                startInfo.Arguments += lmname + "_final_L0" + (compressedOutput ? ".lz4" : ".dds") + "\" \"" +
                                       lmname + "_final_L1x" + (compressedOutput ? ".lz4" : ".dds") + "\" \"" +
                                       lmname + "_final_L1y" + (compressedOutput ? ".lz4" : ".dds") + "\" \"" +
                                       lmname + "_final_L1z" + (compressedOutput ? ".lz4" : ".dds") + "\"";
            }
            else if (rnmMode)
            {
                startInfo.Arguments += lmname + "_final_RNM0" + (compressedOutput ? ".lz4" : ".dds") + "\" \"" +
                                       lmname + "_final_RNM1" + (compressedOutput ? ".lz4" : ".dds") + "\" \"" +
                                       lmname + "_final_RNM2" + (compressedOutput ? ".lz4" : ".dds") + "\"";
            }
            else if (dominantDirMode)
            {
                startInfo.Arguments += lmname + "_final_HDR" + (compressedOutput ? ".lz4" : ".dds") + "\" \"" +
                                       lmname + "_final_Dir" + (compressedOutput ? ".lz4" : ".dds");
            }
            else
            {
                startInfo.Arguments += lmname + "_final_HDR" + (compressedOutput ? ".lz4" : ".dds") + "\"";
            }

            deferredFileSrc.Add("");
            deferredFileDest.Add("");
            deferredCommands.Add(startInfo);
            deferredCommandDesc.Add(progressText);
        }
        progressStepsDone++;
    }

    IEnumerator RenderLMEncode(int LMID, string lmname, int resolution, bool vertexBake, int lmgroupRenderDirMode, int lmgroupRenderMode)
    {
        if (vertexBake) yield break;

        System.Diagnostics.ProcessStartInfo startInfo;

        var dirMode = lmgroupRenderDirMode == (int)BakeryLightmapGroup.RenderDirMode.Auto ? (int)renderDirMode : (int)lmgroupRenderDirMode;
        var dominantDirMode = dirMode == (int)ftRenderLightmap.RenderDirMode.DominantDirection;
        var rnmMode = dirMode == (int)ftRenderLightmap.RenderDirMode.RNM && lightmapHasRNM[LMID];
        var shMode = dirMode == (int)ftRenderLightmap.RenderDirMode.SH && lightmapHasRNM[LMID];
        var shModeProbe = dirMode == (int)BakeryLightmapGroup.RenderDirMode.ProbeSH && lightmapHasRNM[LMID];
        var shModeMono = dirMode == (int)BakeryLightmapGroup.RenderDirMode.MonoSH && lightmapHasRNM[LMID];
        if (shModeProbe || shModeMono) shMode = true;

        var progressText2 = "Encoding " + lmname + "...";
        if (userCanceled) yield break;//return false;
        progressStepsDone++;
        yield return null;

        int maxValue = 1024;
#if UNITY_2019_1_OR_NEWER
        if (GraphicsSettings.defaultRenderPipeline != null)
        {
             var srpType = GraphicsSettings.defaultRenderPipeline.GetType().ToString();
             if (srpType.Contains("HDRenderPipelineAsset"))
             {
                maxValue = 64000;
             }
        }
#endif

        if (encode)// && !vertexBake)// && File.Exists(scenePath + "/" + lmname + "_final_HDR.dds"))
        {
            if (vertexBake)
            {
                if (deferredMode)
                {
                    deferredFileSrc.Add("");
                    deferredFileDest.Add("");
                    deferredCommands.Add(null);
                    deferredCommandDesc.Add(progressText2);

                    var gr = new BakeryLightmapGroupPlain();
                    gr.id = LMID;
                    gr.name = lmname;
                    deferredCommandsHalf2VB[deferredCommands.Count - 1] = gr;
                }
                else
                {
                    //GenerateVertexBakedMeshes(LMID, lmname);
                }
            }
            else// if (!bc6h)
            {
                if (!shMode && !rnmMode)
                {
                    var outPath = Application.dataPath + "/" + outputPathFull + "/" + lmname + "_final.hdr";
                    if (File.Exists(outPath)) ValidateFileAttribs(outPath);

                    startInfo = new System.Diagnostics.ProcessStartInfo();
                    startInfo.CreateNoWindow  = false;
                    startInfo.UseShellExecute = false;
                    //startInfo.WorkingDirectory = scenePath;
#if !LAUNCH_VIA_DLL
                    startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
                    startInfo.FileName        = Application.dataPath + "/Editor/x64/Bakery/halffloat2hdr.exe";
                    startInfo.CreateNoWindow = true;
                    startInfo.Arguments       = "\"" + scenePath + "/" + lmname + "_final_HDR" + (compressedOutput ? ".lz4" : ".dds") + "\" \"" + outPath + "\" " + maxValue;

                    deferredFileSrc.Add("");
                    deferredFileDest.Add("");
                    deferredCommands.Add(startInfo);
                    deferredCommandDesc.Add(progressText2);
                    if (clientMode) ftClient.serverGetFileList.Add(lmname + "_final.hdr");
                }
            }
        }

        // Encode directions
        if (dominantDirMode && !vertexBake && lightmapHasDir[LMID])
        {
            var outPath = Application.dataPath + "/" + outputPathFull + "/" + lmname + "_dir" + (pstorage.format8bit == BakeryProjectSettings.FileFormat.PNG ? ".png" : ".tga");
            if (File.Exists(outPath)) ValidateFileAttribs(outPath);

            progressText2 = "Encoding direction for " + lmname + "...";
            startInfo = new System.Diagnostics.ProcessStartInfo();
            startInfo.CreateNoWindow  = false;
            startInfo.UseShellExecute = false;
            //startInfo.WorkingDirectory = scenePath;
#if !LAUNCH_VIA_DLL
            startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
            startInfo.FileName        = Application.dataPath + "/Editor/x64/Bakery/rgba2tga.exe";
            startInfo.CreateNoWindow = true;
            startInfo.Arguments       = "\"" + scenePath + "/" + lmname + "_final_Dir" + (compressedOutput ? ".lz4" : ".dds") + "\" \"" + outPath + "\" " + (pstorage.format8bit == BakeryProjectSettings.FileFormat.PNG ? "p" : "");

            if (deferredMode)
            {
                deferredFileSrc.Add("");
                deferredFileDest.Add("");
                deferredCommands.Add(startInfo);
                deferredCommandDesc.Add(progressText2);
                if (clientMode) ftClient.serverGetFileList.Add(lmname + "_dir" + (pstorage.format8bit == BakeryProjectSettings.FileFormat.PNG ? ".png" : ".tga"));
            }
            else
            {
                Debug.LogError("Not supported");
            }
        }

        if (rnmMode && !vertexBake && lightmapHasRNM[LMID])
        {
            for(int c=0; c<3; c++)
            {
                var outPath = Application.dataPath + "/" + outputPathFull + "/" + lmname + "_RNM" + c + ".hdr";
                if (File.Exists(outPath)) ValidateFileAttribs(outPath);

                // Encode RNM
                progressText2 = "Encoding RNM" + c + " for " + lmname + "...";
                startInfo = new System.Diagnostics.ProcessStartInfo();
                startInfo.CreateNoWindow  = false;
                startInfo.UseShellExecute = false;
                //startInfo.WorkingDirectory = scenePath;
#if !LAUNCH_VIA_DLL
                startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
                startInfo.FileName        = Application.dataPath + "/Editor/x64/Bakery/halffloat2hdr.exe";
                startInfo.CreateNoWindow = true;
                startInfo.Arguments       = "\"" + scenePath + "/" + lmname + "_final_RNM" + c + (compressedOutput ? ".lz4" : ".dds") + "\" \"" + outPath + "\" " + maxValue;
                if (deferredMode)
                {
                    deferredFileSrc.Add("");
                    deferredFileDest.Add("");
                    deferredCommands.Add(startInfo);
                    deferredCommandDesc.Add(progressText2);
                    if (clientMode) ftClient.serverGetFileList.Add(lmname + "_RNM" + c + ".hdr");
                }
                else
                {
                    Debug.LogError("Not supported");
                }
            }
        }

        if (shMode && !vertexBake && lightmapHasRNM[LMID])
        {
            var outPath = Application.dataPath + "/" + outputPathFull + "/" + lmname + "_L0.hdr";
            if (File.Exists(outPath)) ValidateFileAttribs(outPath);

            progressText2 = "Encoding SH L0 for " + lmname + "...";
            startInfo = new System.Diagnostics.ProcessStartInfo();
            startInfo.CreateNoWindow  = false;
            startInfo.UseShellExecute = false;
            //startInfo.WorkingDirectory = scenePath;
#if !LAUNCH_VIA_DLL
            startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
            startInfo.FileName        = Application.dataPath + "/Editor/x64/Bakery/halffloat2hdr.exe";
            startInfo.CreateNoWindow = true;
            startInfo.Arguments       = "\"" + scenePath + "/" + lmname + "_final_L0" + (compressedOutput ? ".lz4" : ".dds") + "\" \"" + outPath + "\" " + maxValue;
            if (deferredMode)
            {
                deferredFileSrc.Add("");
                deferredFileDest.Add("");
                deferredCommands.Add(startInfo);
                deferredCommandDesc.Add(progressText2);
                if (clientMode) ftClient.serverGetFileList.Add(lmname + "_L0.hdr");
            }
            else
            {
                Debug.LogError("Not supported");
            }

            progressText2 = "Encoding SH L1 for " + lmname + "...";
            if (shModeMono)
            {
                startInfo = new System.Diagnostics.ProcessStartInfo();
                startInfo.CreateNoWindow  = false;
                startInfo.UseShellExecute = false;
                //startInfo.WorkingDirectory = scenePath;
#if !LAUNCH_VIA_DLL
                startInfo.WorkingDirectory = dllPath + "/Bakery";
#endif
                startInfo.FileName        = Application.dataPath + "/Editor/x64/Bakery/combineSH.exe";
                startInfo.CreateNoWindow = true;

                var outPath1 = Application.dataPath + "/" + outputPathFull + "/" + lmname + "_L1" + (pstorage.format8bit == BakeryProjectSettings.FileFormat.PNG ? ".png" : ".tga");
                if (File.Exists(outPath1)) ValidateFileAttribs(outPath1);

                startInfo.Arguments       = " \"" + outPath1 + "\"" + 
                                            " \"" + scenePath + "/" + lmname + "_final_L1x" + (compressedOutput ? ".lz4" : ".dds") + "\"" +
                                            " \"" + scenePath + "/" + lmname + "_final_L1y" + (compressedOutput ? ".lz4" : ".dds") + "\"" +
                                            " \"" + scenePath + "/" + lmname + "_final_L1z" + (compressedOutput ? ".lz4" : ".dds") + "\"";

                if (deferredMode)
                {
                    deferredFileSrc.Add("");
                    deferredFileDest.Add("");
                    deferredCommands.Add(startInfo);
                    deferredCommandDesc.Add(progressText2);
                    if (clientMode) ftClient.serverGetFileList.Add(lmname + "_L1" + (pstorage.format8bit == BakeryProjectSettings.FileFormat.PNG ? ".png" : ".tga"));
                }
                else
                {
                    Debug.LogError("Not supported");
                }
            }
            else
            {
                for(int i=0; i<3; i++)
                {
                    startInfo = new System.Diagnostics.ProcessStartInfo();
                    startInfo.CreateNoWindow  = false;
                    startInfo.UseShellExecute = false;
                    //startInfo.WorkingDirectory = scenePath;
    #if !LAUNCH_VIA_DLL
                    startInfo.WorkingDirectory = dllPath + "/Bakery";
    #endif
                    startInfo.FileName        = Application.dataPath + "/Editor/x64/Bakery/rgba2tga.exe";
                    startInfo.CreateNoWindow = true;
                    string comp;
                    if (i==0)
                    {
                        comp = "x";
                    }
                    else if (i==1)
                    {
                        comp = "y";
                    }
                    else
                    {
                        comp = "z";
                    }

                    var outPath1 = Application.dataPath + "/" + outputPathFull + "/" + lmname + "_L1" + comp + (pstorage.format8bit == BakeryProjectSettings.FileFormat.PNG ? ".png" : ".tga");
                    if (File.Exists(outPath1)) ValidateFileAttribs(outPath1);

                    startInfo.Arguments       = "\"" + scenePath + "/" + lmname + "_final_L1" + comp + (compressedOutput ? ".lz4" : ".dds") + "\" \"" + outPath1 + "\" " + (pstorage.format8bit == BakeryProjectSettings.FileFormat.PNG ? "p" : "");

                    if (deferredMode)
                    {
                        deferredFileSrc.Add("");
                        deferredFileDest.Add("");
                        deferredCommands.Add(startInfo);
                        deferredCommandDesc.Add(progressText2);
                        if (clientMode) ftClient.serverGetFileList.Add(lmname + "_L1" + comp + (pstorage.format8bit == BakeryProjectSettings.FileFormat.PNG ? ".png" : ".tga"));
                    }
                    else
                    {
                        Debug.LogError("Not supported");
                    }
                }
            }
        }
    }

    public static System.IntPtr RunFTrace(string args, bool visible = false)
    {
        DebugLogInfo("Running ftrace " + args);
#if LAUNCH_VIA_DLL
        System.IntPtr exeProcess;

        if (visible)
        {
            exeProcess = RunLocalProcessVisible(ftraceExe+" "+args);
        }
        else
        {
            exeProcess = RunLocalProcess(ftraceExe+" "+args, true);
        }

        if (exeProcess == (System.IntPtr)null)
        {
            Debug.LogError(ftraceExe + " launch failed (see console for details)");
            return (System.IntPtr)0;
        }
        return exeProcess;
#else
        Debug.LogError("Not supported");
        return (System.IntPtr)0;
#endif
    }

    public static ftGlobalStorage FindGlobalStorage()
    {
        if (gstorage == null)
        {
            var bakeryRuntimePath = ftLightmaps.GetRuntimePath();
            gstorage = AssetDatabase.LoadAssetAtPath(bakeryRuntimePath + "ftGlobalStorage.asset", typeof(ftGlobalStorage)) as ftGlobalStorage;
        }
        return gstorage;
    }

    public static void LoadDefaultSettings(ftLightmapsStorage storage)
    {
        FindGlobalStorage();
        if (gstorage == null) return;
        ftLightmapsStorage.CopySettings(gstorage, storage);
    }

    static List<GameObject> roots;
    public static ftLightmapsStorage FindRenderSettingsStorage()
    {
        // Load saved settings
        GameObject go = null;
        if (roots == null) roots = new List<GameObject>();

        try
        {
            SceneManager.GetActiveScene().GetRootGameObjects(roots);
        }
        catch
        {
            // scene is not loaded, oops
            return null;
        }

        go = roots.Find( g => g.name == "!ftraceLightmaps" );

        if (go == null) go = GameObject.Find("!ftraceLightmaps");
        if (go == null) {
            go = new GameObject();
            go.name = "!ftraceLightmaps";
            go.hideFlags = HideFlags.HideInHierarchy;
        }
        var storage = go.GetComponent<ftLightmapsStorage>();
        if (storage == null) {
            storage = go.AddComponent<ftLightmapsStorage>();
            LoadDefaultSettings(storage);
        }
        return storage;
    }

    public static void LoadStaticAtlasingSettings()
    {
        var storage = FindRenderSettingsStorage();
        ftRenderLightmap.tileSize = storage.renderSettingsTileSize;
        ftBuildGraphics.texelsPerUnit = storage.renderSettingsTexelsPerUnit;
        ftBuildGraphics.autoAtlas = storage.renderSettingsAutoAtlas;
        ftBuildGraphics.unwrapUVs = storage.renderSettingsUnwrapUVs;
        ftBuildGraphics.forceDisableUnwrapUVs = storage.renderSettingsForceDisableUnwrapUVs;
        ftBuildGraphics.maxAutoResolution = storage.renderSettingsMaxAutoResolution;
        ftBuildGraphics.minAutoResolution = storage.renderSettingsMinAutoResolution;
        ftRenderLightmap.checkOverlaps = storage.renderSettingsCheckOverlaps;
        ftBuildGraphics.texelsPerUnitPerMap = storage.renderSettingsTexelsPerMap;
        ftBuildGraphics.mainLightmapScale = storage.renderSettingsTexelsColor;
        ftBuildGraphics.maskLightmapScale = storage.renderSettingsTexelsMask;
        ftBuildGraphics.dirLightmapScale = storage.renderSettingsTexelsDir;
        ftBuildGraphics.splitByScene = storage.renderSettingsSplitByScene;
        ftBuildGraphics.splitByTag = storage.renderSettingsSplitByTag;
        ftBuildGraphics.uvPaddingMax = storage.renderSettingsUVPaddingMax;
        ftBuildGraphics.postPacking = storage.renderSettingsPostPacking;
        ftBuildGraphics.holeFilling = storage.renderSettingsHoleFilling;
        ftBuildGraphics.atlasPacker = storage.renderSettingsAtlasPacker;
    }

    public void LoadRenderSettings()
    {
        FindGlobalStorage();
        if (gstorage != null)
        {
            foundCompatibleSetup = gstorage.foundCompatibleSetup;
            scenePath = gstorage.renderSettingsTempPath;
        }

        instance = this;
        var storage = instance.renderSettingsStorage = FindRenderSettingsStorage();
        if (storage == null) return;
        bounces = storage.renderSettingsBounces;
        instance.giSamples = storage.renderSettingsGISamples;
        giBackFaceWeight = storage.renderSettingsGIBackFaceWeight;
        ftRenderLightmap.tileSize = storage.renderSettingsTileSize;
        instance.priority = storage.renderSettingsPriority;
        instance.texelsPerUnit = ftBuildGraphics.texelsPerUnit = storage.renderSettingsTexelsPerUnit;
        ftRenderLightmap.forceRefresh = storage.renderSettingsForceRefresh;
        instance.forceRebuildGeometry = storage.renderSettingsForceRebuildGeometry;
        instance.performRendering = storage.renderSettingsPerformRendering;
        instance.userRenderMode = (RenderMode)storage.renderSettingsUserRenderMode;
        instance.settingsMode = (SettingsMode)storage.renderSettingsSettingsMode;
        instance.fixSeams = storage.renderSettingsFixSeams;
        instance.denoise = storage.renderSettingsDenoise;
        instance.denoise2x = storage.renderSettingsDenoise2x;
        instance.encode = storage.renderSettingsEncode;
        instance.encodeMode = storage.renderSettingsEncodeMode;
        ftBuildGraphics.overwriteWarning = storage.renderSettingsOverwriteWarning;
        ftBuildGraphics.autoAtlas = storage.renderSettingsAutoAtlas;
        ftBuildGraphics.unwrapUVs = storage.renderSettingsUnwrapUVs;
        ftBuildGraphics.forceDisableUnwrapUVs = storage.renderSettingsForceDisableUnwrapUVs;
        ftBuildGraphics.maxAutoResolution = storage.renderSettingsMaxAutoResolution;
        ftBuildGraphics.minAutoResolution = storage.renderSettingsMinAutoResolution;
        instance.unloadScenesInDeferredMode = storage.renderSettingsUnloadScenes;
        ftRenderLightmap.adjustSamples = storage.renderSettingsAdjustSamples;
        ftRenderLightmap.giLodMode = (GILODMode)storage.renderSettingsGILODMode;
        ftRenderLightmap.giLodModeEnabled = storage.renderSettingsGILODModeEnabled;
        ftRenderLightmap.checkOverlaps = storage.renderSettingsCheckOverlaps;
        ftRenderLightmap.outputPath = storage.renderSettingsOutPath == "" ? "BakeryLightmaps" : storage.renderSettingsOutPath;
        ftRenderLightmap.useScenePath = storage.renderSettingsUseScenePath;
        hackEmissiveBoost = storage.renderSettingsHackEmissiveBoost;
        hackIndirectBoost = storage.renderSettingsHackIndirectBoost;
        hackAOIntensity = renderSettingsStorage.renderSettingsHackAOIntensity;
        hackAORadius = renderSettingsStorage.renderSettingsHackAORadius;
        hackAOSamples = renderSettingsStorage.renderSettingsHackAOSamples;
        showAOSettings = renderSettingsStorage.renderSettingsShowAOSettings;
        showTasks = renderSettingsStorage.renderSettingsShowTasks;
        showTasks2 = renderSettingsStorage.renderSettingsShowTasks2;
        showPaths = renderSettingsStorage.renderSettingsShowPaths;
        showNet = renderSettingsStorage.renderSettingsShowNet;
        showPerf = renderSettingsStorage.renderSettingsShowPerf;
        //showCompression = renderSettingsStorage.renderSettingsShowCompression;
        ftBuildGraphics.texelsPerUnitPerMap = renderSettingsStorage.renderSettingsTexelsPerMap;
        ftBuildGraphics.mainLightmapScale = renderSettingsStorage.renderSettingsTexelsColor;
        ftBuildGraphics.maskLightmapScale = renderSettingsStorage.renderSettingsTexelsMask;
        ftBuildGraphics.dirLightmapScale = renderSettingsStorage.renderSettingsTexelsDir;
        useUnityForOcclsusionProbes = renderSettingsStorage.renderSettingsOcclusionProbes;
        lastBakeTime = renderSettingsStorage.lastBakeTime;
        beepOnFinish = renderSettingsStorage.renderSettingsBeepOnFinish;
        ftBuildGraphics.exportTerrainAsHeightmap = renderSettingsStorage.renderSettingsExportTerrainAsHeightmap;
        ftBuildGraphics.exportTerrainTrees = renderSettingsStorage.renderSettingsExportTerrainTrees;
        rtxMode = renderSettingsStorage.renderSettingsRTXMode;
        lightProbeMode = (LightProbeMode)renderSettingsStorage.renderSettingsLightProbeMode;
        clientMode = renderSettingsStorage.renderSettingsClientMode;
        ftClient.serverAddress = renderSettingsStorage.renderSettingsServerAddress;
        unwrapper = (ftGlobalStorage.Unwrapper)renderSettingsStorage.renderSettingsUnwrapper;
        denoiserType = (ftGlobalStorage.DenoiserType)renderSettingsStorage.renderSettingsDenoiserType;
        //legacyDenoiser = renderSettingsStorage.renderSettingsLegacyDenoiser;
        ftBuildGraphics.atlasPacker = renderSettingsStorage.renderSettingsAtlasPacker;
        sampleDivisor = storage.renderSettingsSampleDiv;
        if (storage.renderSettingsSector != null) curSector = (BakerySector)storage.renderSettingsSector;

        ftraceExe = rtxMode ? ftraceExe6 : ftraceExe1;
        //scenePath = storage.renderSettingsTempPath;

        if (scenePath == "") scenePath = System.Environment.GetEnvironmentVariable("TEMP", System.EnvironmentVariableTarget.Process) + "\\frender";
        ftBuildGraphics.scenePath = scenePath;
        scenePathQuoted = "\"" + scenePath + "\"";

#if UNITY_2017_1_OR_NEWER
        isDistanceShadowmask = QualitySettings.shadowmaskMode == ShadowmaskMode.DistanceShadowmask;
#else
        isDistanceShadowmask = storage.renderSettingsDistanceShadowmask;
#endif
        showDirWarning = storage.renderSettingsShowDirWarning;
        renderDirMode = (RenderDirMode)storage.renderSettingsRenderDirMode;
        showCheckerSettings = storage.renderSettingsShowCheckerSettings;
        usesRealtimeGI = storage.usesRealtimeGI;
        samplesWarning = storage.renderSettingsSamplesWarning;
        suppressPopups = storage.renderSettingsSuppressPopups;
        prefabWarning = storage.renderSettingsPrefabWarning;
        ftBuildGraphics.splitByScene = storage.renderSettingsSplitByScene;
        ftBuildGraphics.splitByTag = storage.renderSettingsSplitByTag;
        ftBuildGraphics.uvPaddingMax = storage.renderSettingsUVPaddingMax;
        ftBuildGraphics.postPacking = storage.renderSettingsPostPacking;
        ftBuildGraphics.holeFilling = storage.renderSettingsHoleFilling;
        compressVolumes = storage.renderSettingsCompressVolumes;
        batchAreaLightSampleLimit = storage.renderSettingsBatchAreaLightSampleLimit;
    }

    void OnEnable()
    {
        LoadRenderSettings();
    }

	[MenuItem ("Bakery/Render lightmap...", false, 0)]
	public static void RenderLightmap ()
    {
        instance = (ftRenderLightmap)GetWindow(typeof(ftRenderLightmap));
        instance.titleContent.text = "Bakery";
        var edPath = ftLightmaps.GetEditorPath();
        var icon = EditorGUIUtility.Load(edPath + "icon.png") as Texture2D;
        instance.titleContent.image = icon;
        instance.Show();
        ftLightmaps.GetRuntimePath();
	}

    public static int GetRTPreviewCompatibilityVersion()
    {
        return 20230703;
    }
}

#endif
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftRenderLightmap.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftRestorePaddingMenu.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1acbda60094b1b14fa803d9ce4fb88d3
# ASMDEF: BakeryEditorAssembly.dll
# ---
using UnityEngine;
using UnityEditor;
using UnityEngine.SceneManagement;

public class ftRestorePaddingMenu
{
    [MenuItem("Bakery/Utilities/Re-adjust UV padding", false, 43)]
    private static void RestorePadding()
    {
        var bakeryRuntimePath = ftLightmaps.GetRuntimePath();
        var gstorage = AssetDatabase.LoadAssetAtPath(bakeryRuntimePath + "ftGlobalStorage.asset", typeof(ftGlobalStorage)) as ftGlobalStorage;

        if (gstorage == null)
        {
            Debug.Log("Bakery is not initalized");
            return;
        }

        if (EditorUtility.DisplayDialog("Bakery", "Re-unwrap and reimport lightmapped scene models to match last bake?", "OK", "Cancel"))
        {
            var sceneCount = SceneManager.sceneCount;
            int reimported = 0;
            for(int i=0; i<sceneCount; i++)
            {
                var scene = SceneManager.GetSceneAt(i);
                if (!scene.isLoaded) continue;
                var go = ftLightmaps.FindInScene("!ftraceLightmaps", scene);
                if (go == null) continue;
                var store = go.GetComponent<ftLightmapsStorage>();
                if (store == null) continue;

                for(int j=0; j<store.modifiedAssetPathList.Count; j++)
                {
                    bool updated = false;
                    var path = store.modifiedAssetPathList[j];
                    var data = store.modifiedAssets[j];
                    int mstoreIndex = gstorage.modifiedAssetPathList.IndexOf(path);
                    if (mstoreIndex < 0)
                    {
                        mstoreIndex = gstorage.modifiedAssetPathList.Count;
                        gstorage.modifiedAssetPathList.Add(path);
                        gstorage.modifiedAssets.Add(data);
                        updated = true;
                    }
                    else
                    {
                        var dataExisting = gstorage.modifiedAssets[mstoreIndex];
                        for(int k=0; k<data.meshName.Count; k++)
                        {
                            int ind = dataExisting.meshName.IndexOf( data.meshName[k] );
                            if (ind >= 0)
                            {
                                if (dataExisting.padding[ind] != data.padding[k])
                                {
                                    dataExisting.padding[ind] = data.padding[k];
                                    updated = true;
                                }
                                if (dataExisting.unwrapper[ind] != data.unwrapper[k])
                                {
                                    dataExisting.unwrapper[ind] = data.unwrapper[k];
                                    updated = true;
                                }
                            }
                            else
                            {
                                dataExisting.meshName.Add( data.meshName[k] );
                                dataExisting.padding.Add( data.padding[k] );
                                dataExisting.unwrapper.Add( data.unwrapper[k] );
                                updated = true;
                            }
                        }
                    }
                    if (updated)
                    {
#if UNITY_2017_1_OR_NEWER
                        gstorage.SyncModifiedAsset(mstoreIndex);
#endif
                        EditorUtility.SetDirty(gstorage);
                        (AssetImporter.GetAtPath(path) as ModelImporter).SaveAndReimport();
                        reimported++;
                    }
                }
            }
            Debug.Log(reimported > 0 ? ("Updated " + reimported + " models") : "No changes detected");
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftRestorePaddingMenu.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftSavedPadding2.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f1b283dcb6cb8fb4e984405825d17555
# ASMDEF: BakeryEditorAssembly.dll
# ---
using UnityEngine;
using UnityEditor;

public class ftSavedPadding2 : ScriptableObject
{
    [SerializeField]
    public ftGlobalStorage.AdjustedMesh data;
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftSavedPadding2.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftSavePadding.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1b9bbae7393eaa04db704d80e254be86
# ASMDEF: BakeryEditorAssembly.dll
# ---
#if UNITY_EDITOR

using UnityEngine;
using UnityEditor;
using UnityEngine.SceneManagement;
using System.IO;
using System.Collections.Generic;

public class ftSavePaddingMenu
{
    [MenuItem("Bakery/Utilities/Save UV padding to asset", false, 60)]
    private static void RestorePadding()
    {
        var bakeryRuntimePath = ftLightmaps.GetRuntimePath();
        var gstorage = AssetDatabase.LoadAssetAtPath(bakeryRuntimePath + "ftGlobalStorage.asset", typeof(ftGlobalStorage)) as ftGlobalStorage;

        if (gstorage == null)
        {
            Debug.Log("Bakery is not initalized");
            return;
        }

        var sel = Selection.objects;
        var pathList = new List<string>();

        for(int i=0; i<sel.Length; i++)
        {
            var path = AssetDatabase.GetAssetPath(sel[i]);
            if (path == "") continue;
            if (!pathList.Contains(path)) pathList.Add(path);
        }

        int ctr = 0;
        for(int i=0; i<pathList.Count; i++)
        {
            var index = gstorage.modifiedAssetPathList.IndexOf(pathList[i]);
            if (index < 0)
            {
                Debug.Log("UV padding wasn't generated yet, skipping " + pathList[i]);
                continue;
            }
            var mod = gstorage.modifiedAssets[index];
            var asset = ScriptableObject.CreateInstance<ftSavedPadding2>();
            asset.data = mod;
            AssetDatabase.CreateAsset(asset, Path.GetDirectoryName(pathList[i]) + "/" + Path.GetFileNameWithoutExtension(pathList[i]) + "_padding.asset");
            Debug.Log("Created padding asset for " + pathList[i]);
            ctr++;
        }

        AssetDatabase.SaveAssets();
        Debug.Log("Created " + ctr + " UV padding assets");
    }
}

#endif
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftSavePadding.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftSaveSettingsMenu.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6977f7d9b2482ea4cbd5535e0046efab
# ASMDEF: BakeryEditorAssembly.dll
# ---
using UnityEngine;
using UnityEditor;
using UnityEngine.SceneManagement;

public class ftSaveSettingsMenu
{
    [MenuItem("Bakery/Utilities/Save settings as default", false, 41)]
    private static void SaveSettings()
    {
        var bakeryRuntimePath = ftLightmaps.GetRuntimePath();
        var gstorage = AssetDatabase.LoadAssetAtPath(bakeryRuntimePath + "ftGlobalStorage.asset", typeof(ftGlobalStorage)) as ftGlobalStorage;

        if (gstorage == null)
        {
            Debug.Log("Bakery is not initalized");
            return;
        }

        if (EditorUtility.DisplayDialog("Bakery", "Save current scene settings as global defaults?", "OK", "Cancel"))
        {
            var storage = ftRenderLightmap.FindRenderSettingsStorage();
            ftRenderLightmap bakery = ftRenderLightmap.instance != null ? ftRenderLightmap.instance : new ftRenderLightmap();
            bakery.LoadRenderSettings();
            ftLightmapsStorage.CopySettings(storage, gstorage);
            EditorUtility.SetDirty(gstorage);
            Debug.Log("Default settings saved");
        }
    }

    [MenuItem("Bakery/Utilities/Load default settings", false, 42)]
    private static void LoadSettings()
    {
        var bakeryRuntimePath = ftLightmaps.GetRuntimePath();
        var gstorage = AssetDatabase.LoadAssetAtPath(bakeryRuntimePath + "ftGlobalStorage.asset", typeof(ftGlobalStorage)) as ftGlobalStorage;

        if (gstorage == null)
        {
            Debug.Log("Bakery is not initalized");
            return;
        }

        if (EditorUtility.DisplayDialog("Bakery", "Set default baking settings for the current scene?", "OK", "Cancel"))
        {
            var storage = ftRenderLightmap.FindRenderSettingsStorage();
            ftRenderLightmap bakery = ftRenderLightmap.instance != null ? ftRenderLightmap.instance : new ftRenderLightmap();
            ftLightmapsStorage.CopySettings(gstorage, storage);
            EditorUtility.SetDirty(storage);
            bakery.LoadRenderSettings();
            Debug.Log("Default settings loaded");
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftSaveSettingsMenu.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftSceneView.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 875c029f22e4efd438030561aaaf38b3
# ASMDEF: BakeryEditorAssembly.dll
# ---
#if UNITY_EDITOR
//#if UNITY_2018_2_OR_NEWER

using UnityEngine;
using UnityEditor;
using System;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Linq;

/*
public class ftSceneView
{
    public static void Init()
    {
        var mode = SceneView.AddCameraMode("Bakery lightmap checker", "Bakery");
    }
}
*/

public class ftSceneView
{
    static Shader checkerShader, projShader;
    public static bool enabled;
    static List<Texture2D> tempTextures;

    static void Atlas()
    {
        var fgo = GameObject.Find("!ftraceLightmaps");
        if (fgo == null) {
            fgo = new GameObject();
            fgo.name = "!ftraceLightmaps";
            fgo.hideFlags = HideFlags.HideInHierarchy;
        }
        var store = fgo.GetComponent<ftLightmapsStorage>();
        if (store == null) {
            store = fgo.AddComponent<ftLightmapsStorage>();
        }
        ftRenderLightmap.LoadStaticAtlasingSettings();

        Debug.Log("Atlasing...");
        ftBuildGraphics.modifyLightmapStorage = false;
        ftBuildGraphics.validateLightmapStorageImmutability = false;
        var exportSceneFunc = ftBuildGraphics.ExportScene(null, false, true);
        while(exportSceneFunc.MoveNext())
        {
            //progressBarText = ftBuildGraphics.progressBarText;
            //progressBarPercent = ftBuildGraphics.progressBarPercent;
            /*if (ftBuildGraphics.userCanceled)
            {
                ProgressBarEnd();
                DestroyImmediate(go);
                foreach(var d in dynamicObjects) d.enabled = true;
                yield break;
            }*/
            //yield return null;
        }
        Debug.Log("Atlasing done");
        //ftRenderLightmap.simpleProgressBarEnd();
        ftBuildGraphics.ProgressBarEnd(true);
    }

    static void ApplyNewProperties()
    {
        var objs = ftBuildGraphics.atlasOnlyObj;
        if (objs == null) return;
        var scaleOffset = ftBuildGraphics.atlasOnlyScaleOffset;
        var size = ftBuildGraphics.atlasOnlySize;
        var ids = ftBuildGraphics.atlasOnlyID;
        var existingLmaps = LightmapSettings.lightmaps.ToList();
        tempTextures = new List<Texture2D>();
        var usedLMIDs = new HashSet<int>();
        for(int i=0; i<objs.Count; i++)
        {
            if (objs[i] == null) continue;
            objs[i].lightmapScaleOffset = scaleOffset[i];
            if (objs[i].lightmapIndex < 0 || objs[i].lightmapIndex >= existingLmaps.Count ||
                existingLmaps[objs[i].lightmapIndex] == null ||
                existingLmaps[objs[i].lightmapIndex].lightmapColor == null || existingLmaps[objs[i].lightmapIndex].lightmapColor.width != size[i])
            {
                int s = 1;//Math.Max(size[i],1);
                var tex = new Texture2D(s, s);
                tempTextures.Add(tex);
                tex.SetPixels32(new Color32[s*s]);
                tex.Apply();
                var ldata = new LightmapData();
                ldata.lightmapColor = tex;
                existingLmaps.Add(ldata);
                objs[i].lightmapIndex = existingLmaps.Count - 1;
            }

            var prop = new MaterialPropertyBlock();
            objs[i].GetPropertyBlock(prop);
            prop.SetFloat("bakeryLightmapSize", size[i]);
            int lmid = ids[i];
            if (lmid < 1000)
            {
                usedLMIDs.Add(lmid);
            }
            UnityEngine.Random.InitState(lmid);
            prop.SetVector("bakeryLightmapID", UnityEngine.Random.ColorHSV(0, 1, 0.3f, 0.3f, 1, 1));
            objs[i].SetPropertyBlock(prop);
        }

        Debug.Log("Lightmap count with current settings: " + usedLMIDs.Count);

        LightmapSettings.lightmaps = existingLmaps.ToArray();
    }

    //[MenuItem("Bakery/Checker/Toggle")]
    public static void ToggleChecker()
    {
        var sceneView = SceneView.lastActiveSceneView;
        if (sceneView == null)
        {
            Debug.LogError("Can't get SceneView");
            return;
        }
        if (enabled)
        {
            tempTextures = null;
            //var sceneCameras = SceneView.GetAllSceneCameras();
            //for(int i=0; i<sceneCameras.Length; i++) sceneCameras[i].renderingPath = RenderingPath.UsePlayerSettings;
            sceneView.SetSceneViewShaderReplace(null, null);
            ftLightmaps.RefreshFull();
            enabled = false;

            var gstorage = ftLightmaps.GetGlobalStorage();
            gstorage.checkerPreviewOn = false;
            EditorUtility.SetDirty(gstorage);
        }
        else
        {
            //if (checkerShader == null)
            {
                checkerShader = Shader.Find("Hidden/ftChecker");
                if (checkerShader == null)
                {
                    Debug.LogError("Can't load checker shader");
                    return;
                }
            }
            sceneView.SetSceneViewShaderReplace(checkerShader, null);
            //var sceneCameras = SceneView.GetAllSceneCameras();
            //for(int i=0; i<sceneCameras.Length; i++) sceneCameras[i].renderingPath = RenderingPath.Forward;
            enabled = true;

            var gstorage = ftLightmaps.GetGlobalStorage();
            gstorage.checkerPreviewOn = true;
            EditorUtility.SetDirty(gstorage);

            Atlas();
            ApplyNewProperties();
        }
        sceneView.Repaint();
    }

    public static void ToggleProjMode()
    {
        if (enabled)
        {
            ToggleChecker(); // same code for turning it off
            return;
        }

        // Different code for turning it on

        var sceneView = SceneView.lastActiveSceneView;
        if (sceneView == null)
        {
            Debug.LogError("Can't get SceneView");
            return;
        }

        //if (projShader == null)
        {
            projShader = Shader.Find("Hidden/ftProjection");
            if (projShader == null)
            {
                Debug.LogError("Can't load projection shader");
                return;
            }
        }
        sceneView.SetSceneViewShaderReplace(projShader, null);
        enabled = true;

        var gstorage = ftLightmaps.GetGlobalStorage();
        gstorage.checkerPreviewOn = true;
        EditorUtility.SetDirty(gstorage);

        sceneView.Repaint();
    }

    //[MenuItem("Bakery/Checker/Refresh")]
    public static void RefreshChecker()
    {
        if (!enabled) return;
        Atlas();
        ApplyNewProperties();
    }
}

//#endif
#endif
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftSceneView.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftSectorInspector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: adbe9477f3f37ce4b9269e796a502ed0
# ASMDEF: BakeryEditorAssembly.dll
# ---
// Disable 'obsolete' warnings
#pragma warning disable 0618

using System.Collections;
using System.Collections.Generic;
using UnityEngine.SceneManagement;
using UnityEngine;
using System.IO;
#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.IMGUI.Controls;
using UnityEditor.SceneManagement;
#endif

#if UNITY_EDITOR
[CustomEditor(typeof(BakerySector))]
public class BakerySectorInspector : Editor
{
    BoxBoundsHandle boundsHandle = new BoxBoundsHandle(typeof(BakerySectorInspector).GetHashCode());
    SerializedProperty ftraceCaptureMode, ftraceCaptureAssetName, ftraceCaptureAsset, ftraceAllowUV, ftraceBakeLightProbes;
    int curSelectedB = -1;
    int curSelectedC = -1;
    Tool lastTool = Tool.None;

    static GUIStyle ToggleButtonStyleNormal = null;
    static GUIStyle ToggleButtonStyleNormalBig = null;
    static GUIStyle CButtonStyle = null;
    static GUIStyle XButtonStyle = null;
    static GUIStyle LabelStyle = null;

    GameObject objToRemove;
    EditorApplication.CallbackFunction remFunc;

    ftLightmapsStorage storage;

    void OnEnable()
    {
        ftraceCaptureMode = serializedObject.FindProperty("captureMode");
        ftraceCaptureAssetName = serializedObject.FindProperty("captureAssetName");
        ftraceCaptureAsset = serializedObject.FindProperty("captureAsset");
        ftraceAllowUV = serializedObject.FindProperty("allowUVPaddingAdjustment");
        ftraceBakeLightProbes = serializedObject.FindProperty("bakeChildLightProbeGroups");
    }

    void RemoveWithUndo()
    {
        EditorApplication.delayCall -= remFunc;
        if (objToRemove == null) return;
        Undo.DestroyObjectImmediate(objToRemove);
    }

    public static void DisablePreview(BakerySector vol)
    {
        var outRend = vol.previewDisabledRenderers;
        if (outRend != null)
        {
            for(int i=0; i<outRend.Count; i++)
            {
                if (outRend[i] != null) outRend[i].enabled = true;
            }
        }
        vol.previewDisabledRenderers = null;

        ftRenderLightmap.showProgressBar = false;
        ftBuildGraphics.ProgressBarEnd(true);
        ftRenderLightmap.showProgressBar = true;

        var temp = vol.previewTempObjects;
        if (temp != null)
        {
            for(int i=0; i<temp.Count; i++)
            {
                if (temp[i] != null) DestroyImmediate(temp[i]);
            }
        }
        vol.previewTempObjects = null;

        vol.previewEnabled = false;
        EditorUtility.SetDirty(vol);

        EditorSceneManager.MarkAllScenesDirty();
    }

    public override void OnInspectorGUI()
    {
        serializedObject.Update();
        var vol = target as BakerySector;

        if ( ToggleButtonStyleNormal == null )
        {
            ToggleButtonStyleNormal = "Button";
        }

        if ( ToggleButtonStyleNormalBig == null )
        {
            ToggleButtonStyleNormalBig = new GUIStyle("Button");
            ToggleButtonStyleNormalBig.fixedHeight = 32;
        }

        if (CButtonStyle == null)
        {
            CButtonStyle = new GUIStyle("Button");
            CButtonStyle.fixedWidth = 48;
        }

        if (XButtonStyle == null)
        {
            XButtonStyle = new GUIStyle("Button");
            XButtonStyle.fixedWidth = 32;
        }

        if (LabelStyle == null)
        {
            LabelStyle = new GUIStyle("Label");
            LabelStyle.fontSize = 18;
            LabelStyle.fontStyle = FontStyle.Bold;
        }

        if (remFunc == null) remFunc = new EditorApplication.CallbackFunction(RemoveWithUndo);

        EditorGUILayout.PropertyField(ftraceAllowUV, new GUIContent("Allow UV adjustment", "Allow UV padding adjustment when baking this sector? Disable when having multiple sectors affecting instances of the same mesh to prevent one sector from breaking UVs on another sector."));

        EditorGUILayout.PropertyField(ftraceBakeLightProbes, new GUIContent("Bake light probes", "Bakes child LightProbeGroups."));

        if (vol.previewEnabled) GUI.enabled = false;
        EditorGUILayout.PropertyField(ftraceCaptureMode, new GUIContent("Capture mode", "'Capture In Place' will generate outside geometry approximation every time 'Render' is pressed or RTPreview is open. It is a good option for exterior scenes where all sectors are loaded together and visible in the Editor.\n'Capture To Asset' will save approximated outside geometry into a file which can be used in another scene using 'Load Captured'."));

        if (ftraceCaptureMode.intValue == (int)BakerySector.CaptureMode.CaptureToAsset)
        {
            EditorGUILayout.Space();
            var assetName = ftraceCaptureAssetName.stringValue;
            if (assetName.Length == 0) assetName = "SectorCapture_" + target.name;
            assetName = EditorGUILayout.TextField("Asset name", assetName);
            bool guiPrev = GUI.enabled;
            GUI.enabled = false;
            EditorGUILayout.PropertyField(ftraceCaptureAsset, new GUIContent("Captured asset", ""));
            GUI.enabled = guiPrev;
            EditorGUILayout.Space();
            if (GUILayout.Button("Capture", GUILayout.Height(32)))
            {
                if (storage == null) storage = ftRenderLightmap.FindRenderSettingsStorage();

                var asset = ScriptableObject.CreateInstance<BakerySectorCapture>();
                asset.write = true;

                ftRenderLightmap.fullSectorRender = true;
                ftBuildGraphics.modifyLightmapStorage = false;
                ftBuildGraphics.validateLightmapStorageImmutability = false;
                var exportSceneFunc = ftBuildGraphics.ExportScene(null, false, true, asset);
                var prevSector = storage.renderSettingsSector as BakerySector;
                storage.renderSettingsSector = ftRenderLightmap.curSector = vol;
                while(exportSceneFunc.MoveNext())
                {
                }
                storage.renderSettingsSector = ftRenderLightmap.curSector = prevSector;

                if (asset.meshes != null && asset.meshes.Count > 0)
                {
                    string fname;
                    var activeScene = SceneManager.GetActiveScene();
                    if (activeScene.path.Length > 0)
                    {
                        fname = Path.GetDirectoryName(activeScene.path) + "/" + assetName;
                    }
                    else
                    {
                        fname = "Assets/" + assetName;
                    }

                    var tform = (target as BakerySector).transform;
                    asset.sectorPos = tform.position;
                    asset.sectorRot = tform.rotation;

                    var apath = fname + ".asset";
                    AssetDatabase.CreateAsset(asset, apath);

                    for(int i=0; i<asset.meshes.Count; i++)
                    {
                        if (asset.meshes[i] == null)
                        {
                            Debug.LogError("Mesh " + i + " is null");
                            continue;
                        }
                        AssetDatabase.AddObjectToAsset(asset.meshes[i], apath);
                        AssetDatabase.AddObjectToAsset(asset.textures[i], apath);
                    }

                    AssetDatabase.SaveAssets();
                    ftraceCaptureAsset.objectReferenceValue = asset;
                }
                else
                {
                    Debug.LogError("SectorCapture wasn't generated");
                }
                ftBuildGraphics.ProgressBarEnd(true);
            }
            EditorGUILayout.Space();
        }
        else if (ftraceCaptureMode.intValue == (int)BakerySector.CaptureMode.LoadCaptured)
        {
            EditorGUILayout.Space();
            EditorGUILayout.PropertyField(ftraceCaptureAsset, new GUIContent("Captured asset", ""));
        }

        if (vol.previewEnabled) GUI.enabled = true;

        EditorGUILayout.Space();

        bool loadNothing = (ftraceCaptureMode.intValue == (int)BakerySector.CaptureMode.LoadCaptured && ftraceCaptureAsset.objectReferenceValue == null);
        if (loadNothing) GUI.enabled = false;

        bool previewEnabled = GUILayout.Toggle(vol.previewEnabled, "Preview", ToggleButtonStyleNormalBig);
        if (!vol.previewEnabled && previewEnabled)
        {
            vol.previewEnabled = true;

            if (storage == null) storage = ftRenderLightmap.FindRenderSettingsStorage();

            BakerySectorCapture asset = null;
            bool loadedAsset = (ftraceCaptureMode.intValue == (int)BakerySector.CaptureMode.LoadCaptured);

            if (loadedAsset)
            {
                asset = vol.captureAsset;
                asset.write = false;
            }
            else
            {
                asset = ScriptableObject.CreateInstance<BakerySectorCapture>();
                asset.write = true;
            }

            ftRenderLightmap.showProgressBar = false;
            ftRenderLightmap.fullSectorRender = true;
            ftBuildGraphics.modifyLightmapStorage = false;
            ftBuildGraphics.validateLightmapStorageImmutability = false;
            var exportSceneFunc = ftBuildGraphics.ExportScene(null, false, true, asset);
            var prevSector = storage.renderSettingsSector as BakerySector;
            storage.renderSettingsSector = ftRenderLightmap.curSector = vol;
            while(exportSceneFunc.MoveNext())
            {
            }
            storage.renderSettingsSector = ftRenderLightmap.curSector = prevSector;
            ftRenderLightmap.showProgressBar = true;

            var outRend = asset.outsideRenderers;
            vol.previewDisabledRenderers = outRend;
            if (outRend != null)
            {
                for(int i=0; i<outRend.Count; i++)
                {
                    if (outRend[i] != null) outRend[i].enabled = false;
                }
            }

            vol.previewTempObjects = ftBuildGraphics.temporaryGameObjects;

            EditorUtility.SetDirty(vol);
            if (!loadedAsset) DestroyImmediate(asset);

            EditorSceneManager.MarkAllScenesDirty();
        }
        else if (vol.previewEnabled && !previewEnabled)
        {
            DisablePreview(vol);
        }
        if (loadNothing) GUI.enabled = true;

        EditorGUILayout.Space();
        EditorGUILayout.BeginVertical("box");

        if (previewEnabled) GUI.enabled = false;

        if (GUILayout.Button(new GUIContent("Add capture point", "Adds a new capture point to this sector. Points will appear as dummy objects parented to this object. When baking the scene (or clicking 'Capture'), each point will generate a simplified scene representation as seen from it. Points can approximate parts of the outside scene geometry and provide shadows/bounces from that geometry without loading the whole world in memory.")))
        {
            var g = new GameObject();
            Undo.RegisterCreatedObjectUndo(g, "Create capture point");
            g.name = vol.name + "_C_" + vol.tforms.Count;
            var t = g.transform;
            t.localPosition = vol.transform.position;
            t.parent = vol.transform;
            t.localScale = Vector3.one * 4;
            vol.cpoints.Add(t);
        }

        EditorGUILayout.Space();

        if (vol.cpoints.Count > 0)
        {
            GUILayout.Label("Edit capture points:");
        }

        for(int i=0; i<vol.cpoints.Count; i++)
        {
            if (vol.cpoints[i] == null)
            {
                vol.cpoints.RemoveAt(i);
                curSelectedC = -1;
                break;
            }

            GUILayout.BeginHorizontal("box");

            bool wasSelected = i == curSelectedC;
            bool selected = GUILayout.Toggle(i == curSelectedC, new GUIContent("" + i, "Select this capture point. Switch to the Move tool to manipulate it."), ToggleButtonStyleNormal);
            if (selected)
            {
                curSelectedC = i;
                curSelectedB = -1;
            }
            else if (wasSelected != selected)
            {
                curSelectedC = -1;
            }

            if (GUILayout.Button("Clone", CButtonStyle))
            {
                var g = new GameObject();
                Undo.RegisterCreatedObjectUndo(g, "Clone capture point");
                g.name = vol.name + "_C_" + vol.cpoints.Count;
                var t = g.transform;
                t.localPosition = vol.cpoints[i].position;
                t.parent = vol.transform;
                t.localScale = Vector3.one * 4;
                vol.cpoints.Add(t);
            }

            if (GUILayout.Button(new GUIContent("X", "Delete this capture point"), XButtonStyle))
            {
                objToRemove = vol.cpoints[i].gameObject;

                Undo.RecordObject(vol, "Remove capture point");
                vol.cpoints.RemoveAt(i);
                curSelectedC = -1;

                EditorApplication.delayCall += remFunc;

                break;
            }
            GUILayout.EndHorizontal();
        }

        EditorGUILayout.EndVertical();

        if (previewEnabled) GUI.enabled = true;

        serializedObject.ApplyModifiedProperties();
    }

    protected virtual void OnSceneGUI()
    {
        var vol = (BakerySector)target;

        var origHMatrix = Handles.matrix;
        boundsHandle.center = Vector3.zero;
        boundsHandle.size = Vector3.one;

        var solid = new Color(0.3f, 0.6f, 0.95f) * 2;
        //var semiTransparent = new Color(1, 1, 1, 0.2f);
        Handles.color = solid;

        bool cull = false;
        Plane[] frustum = null;
        var curView = SceneView.currentDrawingSceneView;
        if (curView != null)
        {
            var cam = curView.camera;
            if (cam != null)
            {
                cull = true;
                frustum = GeometryUtility.CalculateFrustumPlanes(cam);
            }
        }

        if (Tools.current != lastTool && Tools.current != Tool.None)
        {
            lastTool = Tools.current;
        }
        if (curSelectedB >= 0 || curSelectedC >= 0) Tools.current = Tool.None;

        for(int i=0; i<vol.tforms.Count; i++)
        {
            if (vol.tforms[i] == null) continue;

            Handles.matrix = origHMatrix;
            //Handles.color = solid;

            Handles.zTest = UnityEngine.Rendering.CompareFunction.Less;
            Handles.matrix = Matrix4x4.TRS(vol.tforms[i].position, vol.tforms[i].rotation, Vector3.one);
            boundsHandle.size = vol.tforms[i].localScale;

            if (!vol.previewEnabled)
            {
                EditorGUI.BeginChangeCheck();
                boundsHandle.DrawHandle();
                if (EditorGUI.EndChangeCheck())
                {
                    Undo.RecordObject(vol.tforms[i], "Change Bounds");
                    vol.tforms[i].localScale = boundsHandle.size;
                    vol.tforms[i].position = Handles.matrix.MultiplyPoint(boundsHandle.center);
                }
            }

            if (cull)
            {
                if(!GeometryUtility.TestPlanesAABB(frustum, new Bounds(vol.tforms[i].position, Vector3.one)))
                {
                    continue;
                }
            }
            Handles.Label(Vector3.zero, "" + i, LabelStyle);


            //Handles.color = semiTransparent;
            //Handles.DrawWireCube(boundsHandle.center, boundsHandle.size + Vector3.one * vol.nearDistance);
        }

        if (curSelectedB >= 0)
        {
            Handles.matrix = origHMatrix;
            int i = curSelectedB;
            Handles.zTest = UnityEngine.Rendering.CompareFunction.Always;
            var pos = vol.tforms[i].position;
            var rot = vol.tforms[i].rotation;
            var scl = vol.tforms[i].localScale;

            if (!vol.previewEnabled)
            {
                EditorGUI.BeginChangeCheck();
                if (lastTool == Tool.Move)
                {
                    pos = Handles.PositionHandle(pos, Quaternion.identity);
                }
                else if (lastTool == Tool.Rotate)
                {
                    rot = Handles.RotationHandle(rot, pos);
                }
                else if (lastTool == Tool.Scale)
                {
                    scl = Handles.ScaleHandle(scl, pos, rot, HandleUtility.GetHandleSize(pos));
                }
                if (EditorGUI.EndChangeCheck())
                {
                    Undo.RecordObject(vol.tforms[i], "Change Bounds");
                    vol.tforms[i].position = pos;
                    vol.tforms[i].rotation = rot;
                    vol.tforms[i].localScale = scl;
                }
            }
        }

        Handles.matrix = Matrix4x4.identity;
        Handles.color = Color.green;

        for(int i=0; i<vol.cpoints.Count; i++)
        {
            if (vol.cpoints[i] == null) continue;

            Handles.zTest = UnityEngine.Rendering.CompareFunction.Less;

            if (cull)
            {
                if(!GeometryUtility.TestPlanesAABB(frustum, new Bounds(vol.cpoints[i].position, Vector3.one)))
                {
                    continue;
                }
            }

            try
            {
                Handles.Label(vol.cpoints[i].position, "" + i, LabelStyle);
            }
            catch
            {
                // Unity can throw nullrefs when Handles.Label uses larger font
            }
        }

        if (curSelectedC >= 0)
        {
            int i = curSelectedC;
            Handles.zTest = UnityEngine.Rendering.CompareFunction.Always;

            if (vol.cpoints[i] != null)
            {
                var pos = vol.cpoints[i].position;

                if (!vol.previewEnabled)
                {
                    EditorGUI.BeginChangeCheck();
                    if (lastTool == Tool.Move)
                    {
                        pos = Handles.PositionHandle(pos, Quaternion.identity);
                    }

                    if (EditorGUI.EndChangeCheck())
                    {
                        Undo.RecordObject(vol.cpoints[i], "Change capture point");
                        vol.cpoints[i].position = pos;
                    }
                }
            }
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftSectorInspector.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftSettingsProvider.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a23d6b5064fb9a9408669cb173b201a8
# ASMDEF: BakeryEditorAssembly.dll
# ---
using UnityEditor;
using UnityEngine;

public class ftSettingsProvider
{
    static BakeryProjectSettings pstorage;

    static void GUIHandler(string searchContext)
    {
        if (pstorage == null) pstorage = ftLightmaps.GetProjectSettings();
        if (pstorage == null) return;

        var so = new SerializedObject(pstorage);

        var prev = EditorGUIUtility.labelWidth;
        EditorGUIUtility.labelWidth = 280;

        var fhdr = so.FindProperty("formatHDR");
        var f8bit = so.FindProperty("format8bit");

        EditorGUILayout.PropertyField(so.FindProperty("mipmapLightmaps"), new GUIContent("Mipmap Lightmaps", "Enable mipmapping on lightmap assets. Can cause leaks across UV charts as atlases get smaller."));
        EditorGUILayout.PropertyField(fhdr, new GUIContent("Color file format", ""));
        EditorGUILayout.PropertyField(f8bit, new GUIContent("Mask/Direction file format", ""));
        EditorGUILayout.PropertyField(so.FindProperty("lightmapCompression"), new GUIContent("Compress lightmaps", "Apply texture compression to lightmaps?"));
        EditorGUILayout.PropertyField(so.FindProperty("dirHighQuality"), new GUIContent("High quality direction", "Use high quality compression for directional and SH L1 maps? (on desktop, high = BC7, not high = DXT1)"));
        if (fhdr.intValue == 1 || f8bit.intValue == 2)
        {
            EditorGUILayout.PropertyField(so.FindProperty("maxAssetMip"), new GUIContent("Maximum mipmap count", "Limit mipmap count for Asset files."));
        }
        EditorGUILayout.PropertyField(so.FindProperty("texelPaddingForDefaultAtlasPacker"), new GUIContent("Texel padding (Default atlas packer)", "How many empty texels to add between objects' UV layouts in lightmap atlases."), GUILayout.ExpandWidth(true));
        EditorGUILayout.PropertyField(so.FindProperty("texelPaddingForXatlasAtlasPacker"), new GUIContent("Texel padding (xatlas packer)", "How many empty texels to add between objects' UV layouts in lightmap atlases."));
        EditorGUILayout.PropertyField(so.FindProperty("alphaMetaPassResolutionMultiplier"), new GUIContent("Alpha Meta Pass resolution multiplier", "Scales resolution for alpha Meta Pass maps."));
        //EditorGUILayout.PropertyField(so.FindProperty("volumeRenderMode"), new GUIContent("Volume render mode", "Render mode for volumes."));

        var volMode = (BakeryLightmapGroup.RenderMode)so.FindProperty("volumeRenderMode").intValue;
        var newVolMode = (BakeryLightmapGroup.RenderMode)EditorGUILayout.EnumPopup(new GUIContent("Volume render mode", "Render mode for volumes."), volMode);
        if (volMode != newVolMode) so.FindProperty("volumeRenderMode").intValue = (int)newVolMode;

        EditorGUILayout.PropertyField(so.FindProperty("deletePreviousLightmapsBeforeBake"), new GUIContent("Delete previous lightmaps before bake", "Should previously rendered Bakery lightmaps be deleted before the new bake?"));
        EditorGUILayout.PropertyField(so.FindProperty("logLevel"), new GUIContent("Log level", "Print information about the bake process to console? 0 = don't. 1 = info only; 2 = warnings only; 3 = everything."));
        EditorGUILayout.PropertyField(so.FindProperty("alternativeScaleInLightmap"), new GUIContent("Alternative Scale in Lightmap", "Make 'Scale in Lightmap' renderer property act more similar to built-in Unity behaviour."));
        EditorGUILayout.PropertyField(so.FindProperty("alignToTextureBlocksWithXatlas"), new GUIContent("Align to texture compression blocks with xatlas", "Make xatlas align charts to 4x4 block boundaries to make texture compression happy."));
        EditorGUILayout.PropertyField(so.FindProperty("generateSmoothPos"), new GUIContent("Generate smooth positions", "Should we adjust sample positions to prevent incorrect shadowing on very low-poly meshes with smooth normals?"));
        bool smoothPos = so.FindProperty("generateSmoothPos").boolValue;
        if (!smoothPos) GUI.enabled = false;
        EditorGUILayout.PropertyField(so.FindProperty("perTriangleSmoothPos"), new GUIContent("Smooth positions per-triangle", "Should smooth/flat position be decided per-triangle?"));
        if (!smoothPos) GUI.enabled = true;
        EditorGUILayout.PropertyField(so.FindProperty("takeReceiveGIIntoAccount"), new GUIContent("Use 'Receive GI' values", "Take 'Receive Global Illumination' values into account on renderers. Originally Bakery ignored it."));
        EditorGUILayout.PropertyField(so.FindProperty("removeRinging"), new GUIContent("Remove ringing in Legacy light probes", "Use softer light probe convolution in Legacy mode to prevent artifacts in high-contrast areas."));

        EditorGUIUtility.labelWidth = prev;

        EditorGUILayout.Space();
        EditorGUILayout.Space();

        if (GUILayout.Button("Revert to defaults"))
        {
            if (EditorUtility.DisplayDialog("Bakery", "Revert Bskery project settings to default?", "Yes", "No"))
            {
                so.FindProperty("mipmapLightmaps").boolValue = false;
                so.FindProperty("format8bit").intValue = 0;
                so.FindProperty("texelPaddingForDefaultAtlasPacker").intValue = 3;
                so.FindProperty("texelPaddingForXatlasAtlasPacker").intValue = 1;
                so.FindProperty("alphaMetaPassResolutionMultiplier").intValue = 2;
                so.FindProperty("volumeRenderMode").intValue = 1000;
                so.FindProperty("deletePreviousLightmapsBeforeBake").boolValue = false;
                so.FindProperty("logLevel").intValue = 3;
                so.FindProperty("alternativeScaleInLightmap").boolValue = false;
                so.FindProperty("alignToTextureBlocksWithXatlas").boolValue = true;
                so.FindProperty("generateSmoothPos").boolValue = true;
                so.FindProperty("perTriangleSmoothPos").boolValue = true;
                so.FindProperty("takeReceiveGIIntoAccount").boolValue = true;
                so.FindProperty("removeRinging").boolValue = false;
            }
        }

        so.ApplyModifiedPropertiesWithoutUndo();
    }

#if UNITY_2018_3_OR_NEWER
    [SettingsProvider]
    public static SettingsProvider CreateSettingsProvider()
    {
        var provider = new SettingsProvider("Project/BakeryGlobalSettings", SettingsScope.Project);
        provider.label = "Bakery GPU Lightmapper";
        provider.guiHandler = GUIHandler;
        return provider;
    }
#endif
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftSettingsProvider.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftShaderTweaks.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 482c0edd4bdba214f93b66b9cf3c0f3e
# ASMDEF: BakeryEditorAssembly.dll
# ---
#if UNITY_EDITOR

using UnityEngine;
using UnityEngine.Rendering;
using UnityEditor;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using UnityEditor.SceneManagement;
using UnityEngine.SceneManagement;
using System.Diagnostics;
using System.Linq;

public class ftShaderTweaks : ScriptableWizard
{
    public bool bicubic;
    public bool bicubicShadow;
    public bool shadowBlend;
    public bool falloff;
    public bool falloffDeferred;
    bool initialized = false;
    //bool agree = false;
    string includeGIPath;
    string includeShadowPath;
    string includeLightPath;
    string includeDeferredPath;
    string shadersDir;

    string ftSignatureBegin = "//<FTRACEV1.0>";
    string ftSignatureBicubic = "//<FTRACE_BICUBIC>";
    string ftSignatureShadowmask = "//<FTRACE_SHADOWMASK>";
    string ftSignatureEnd = "//</FTRACEV1.0>";
    string unityLightmapReadCode = "half3 bakedColor = DecodeLightmap(bakedColorTex);";
    //string unityLightMatrixDecl = "unityShadowCoord4x4 unity_WorldToLight;";
    string unityDefineLightAtten = "#define UNITY_LIGHT_ATTENUATION(destName, input, worldPos) ";
    string unityGetShadowCoord = "unityShadowCoord3 lightCoord = mul(unity_WorldToLight, unityShadowCoord4(worldPos, 1)).xyz;";
    string unityGetShadowCoord4 = "unityShadowCoord4 lightCoord = mul(unity_WorldToLight, unityShadowCoord4(worldPos, 1));";
    string unityGetShadow = "fixed shadow = UNITY_SHADOW_ATTENUATION(input, worldPos);";
    string ftLightFalloff = "fixed destName = ftLightFalloff(unity_WorldToLight, worldPos)";
    //string unityLightFalloffNew = "UnitySpotAttenuate(lightCoord.xyz)";
    //string ftLightFalloffNew = "ftLightFalloff(unity_WorldToLight, worldPos)";
    //string unityLightFalloffNew2 = "UnitySpotAttenuate(worldPos)";
    //string ftLightFalloffNew2 = "ftLightFalloff(unity_WorldToLight, worldPos)";
    string unitySpotFalloffDeferred = "atten *= tex2D (_LightTextureB0,";
    string ftSpotFalloffDeferred = "atten *= ftLightFalloff(_LightPos, wpos);";
    string unityPointFalloffDeferred = "float atten = tex2D (_LightTextureB0, ";
    string ftPointFalloffDeferred = "float atten = ftLightFalloff(_LightPos, wpos);";
    string unityShadowMaskRead = "UNITY_SAMPLE_TEX2D(unity_ShadowMask";
    string ftShadowMaskRead = "ftBicubicSampleShadow(unity_ShadowMask";
    string unityShadowMaskRead2 = "UNITY_SAMPLE_TEX2D_SAMPLER(unity_ShadowMask";
    string ftShadowMaskRead2 = "ftBicubicSampleShadow2(unity_ShadowMask";
    string unityShadowMaskBlend = "min(realtimeShadowAttenuation, bakedShadowAttenuation)";
    string ftShadowMaskBlend = "(realtimeShadowAttenuation * bakedShadowAttenuation)";

    //string ftLightFalloffDeferred = "#define LIGHT_ATTENUATION ftLightFalloff(unity_WorldToLight, worldPos) * SHADOW_ATTENUATION(a))";

    void OnInspectorUpdate()
    {
        Repaint();
    }

    void CopyInclude(string shadersDir)
    {
        var edPath = ftLightmaps.GetEditorPath();
        File.Copy(edPath + "shaderSrc/ftrace.cginc", shadersDir + "/ftrace.cginc", true);
    }

    bool RevertFile(string fname)
    {
        var reader = new StreamReader(fname);
        if (reader == null)
        {
            UnityEngine.Debug.LogError("Can't open " + fname);
            return false;
        }
        var lines = new List<string>();
        bool inBlock = false;
        while (!reader.EndOfStream)
        {
            var line = reader.ReadLine();
            if (line.StartsWith(ftSignatureBegin))
            {
                inBlock = true;
            }
            else if (line.StartsWith(ftSignatureEnd))
            {
                inBlock = false;
            }
            else if (!inBlock)
            {
                lines.Add(line);
            }
        }
        reader.Close();

        var writer = new StreamWriter(fname, false);
        if (writer == null)
        {
            UnityEngine.Debug.LogError("Can't open " + fname);
            return false;
        }
        for(int i=0; i<lines.Count; i++)
        {
            writer.WriteLine(lines[i]);
        }
        writer.Close();
        //EditorUtility.DisplayDialog("Bakery", "Restart Editor to apply changes", "OK");
        return true;
    }

    void OnGUI()
    {
        if (!initialized)
        {
            try
            {
                bicubic = false;
                var entryAssembly = new StackTrace().GetFrames().Last().GetMethod().Module.Assembly;
                var managedDir = System.IO.Path.GetDirectoryName(entryAssembly.Location);
                shadersDir = managedDir + "/../CGIncludes/";
                if (!Directory.Exists(shadersDir)) shadersDir = managedDir + "/../../CGIncludes/";
                if (!Directory.Exists(shadersDir))
                {
                    UnityEngine.Debug.LogError("Can't find directory: " + shadersDir);
                    return;
                }

                includeGIPath = shadersDir + "UnityGlobalIllumination.cginc";
                if (File.Exists(includeGIPath))
                {
                    var reader = new StreamReader(includeGIPath);
                    if (reader == null)
                    {
                        UnityEngine.Debug.LogError("Can't open " + includeGIPath);
                        bicubic = false;
                        return;
                    }
                    //bool patched = false;
                    while (!reader.EndOfStream)
                    {
                        var line = reader.ReadLine();
                        if (line.StartsWith(ftSignatureBegin))
                        {
                            UnityEngine.Debug.Log("Bicubic: already patched");
                            //patched = true;
                            bicubic = true;
                            break;
                        }
                    }
                    reader.Close();
                }

                shadowBlend = false;
                includeShadowPath = shadersDir + "UnityShadowLibrary.cginc";
                if (File.Exists(includeShadowPath))
                {
                    var reader = new StreamReader(includeShadowPath);
                    if (reader == null)
                    {
                        UnityEngine.Debug.LogError("Can't open " + includeShadowPath);
                        bicubicShadow = false;
                        return;
                    }
                    //bool patched = false;
                    while (!reader.EndOfStream)
                    {
                        var line = reader.ReadLine();
                        if (line.StartsWith(ftSignatureShadowmask))
                        {
                            UnityEngine.Debug.Log("Shadowmask: already patched");
                            //patched = true;
                            shadowBlend = true;
                            break;
                        }
                    }
                    reader.Close();
                }

                falloff = false;
                includeLightPath = shadersDir + "AutoLight.cginc";
                if (File.Exists(includeLightPath))
                {
                    var reader = new StreamReader(includeLightPath);
                    if (reader == null)
                    {
                        UnityEngine.Debug.LogError("Can't open " + includeLightPath);
                        falloff = false;
                        return;
                    }
                    //bool patched = false;
                    while (!reader.EndOfStream)
                    {
                        var line = reader.ReadLine();
                        if (line.StartsWith(ftSignatureBegin))
                        {
                            UnityEngine.Debug.Log("Lights: already patched");
                            //patched = true;
                            falloff = true;
                            break;
                        }
                    }
                    reader.Close();
                }
                falloffDeferred = false;
                includeDeferredPath = shadersDir + "UnityDeferredLibrary.cginc";
                if (File.Exists(includeDeferredPath))
                {
                    var reader = new StreamReader(includeDeferredPath);
                    if (reader == null)
                    {
                        UnityEngine.Debug.LogError("Can't open " + includeDeferredPath);
                        falloffDeferred = false;
                        return;
                    }
                    //bool patched = false;
                    while (!reader.EndOfStream)
                    {
                        var line = reader.ReadLine();
                        if (line.StartsWith(ftSignatureBegin))
                        {
                            UnityEngine.Debug.Log("Lights: already patched");
                            //patched = true;
                            falloffDeferred = true;
                            break;
                        }
                    }
                    reader.Close();
                }
                initialized = true;
            }
            catch//(System.UnauthorizedAccessException err)
            {
                GUI.Label(new Rect(10, 20, 320, 60), "Can't access Unity shader include files,\ntry running Unity as admin.");
                return;
            }
        }

        bool wasBicubic = bicubic;
        //bool wasBicubicShadow = bicubicShadow;
        bool wasShadowBlend = shadowBlend;
        bool wasFalloff = falloff;
        bool wasFalloffDeferred = falloffDeferred;

        this.minSize = new Vector2(320, 290+60);

        GUI.Label(new Rect(10, 20, 320, 60), "These settings will modify base Unity shaders.\nAll projects opened with this version of Editor\nwill use modified shaders.");
        //agree = GUI.Toggle(new Rect(10, 65, 200, 15), agree, "I understand");

        GUI.BeginGroup(new Rect(10, 80, 300, 260), "Options");
        if (initialized)
        {
            bicubic = GUI.Toggle(new Rect(10, 20, 280, 50), bicubic, "Use bicubic interpolation for lightmaps", "Button");
            shadowBlend = GUI.Toggle(new Rect(10, 80, 280, 50), shadowBlend, "Use multiplication for shadowmask", "Button");
            falloff = GUI.Toggle(new Rect(10, 140, 280, 50), falloff, "Use physical light falloff (Forward)", "Button");
            falloffDeferred = GUI.Toggle(new Rect(10, 200, 280, 50), falloffDeferred, "Use physical light falloff (Deferred)", "Button");

            if (!wasBicubic && bicubic)
            {
                CopyInclude(shadersDir);
                var reader = new StreamReader(includeGIPath);
                if (reader == null)
                {
                    UnityEngine.Debug.LogError("Can't open " + includeGIPath);
                    bicubic = false;
                    return;
                }
                bool patched = false;

                var lines = new List<string>();
                lines.Add(ftSignatureBegin);
                lines.Add(ftSignatureBicubic);
                lines.Add("#define USEFTRACE\n");
                lines.Add("#ifdef USEFTRACE");
                lines.Add("#include \"ftrace.cginc\"");
                lines.Add("#endif");
                lines.Add(ftSignatureEnd);

                while (!reader.EndOfStream)
                {
                    var line = reader.ReadLine();
                    if (line.StartsWith(ftSignatureBicubic))
                    {
                        UnityEngine.Debug.Log("Already patched");
                        patched = true;
                        break;
                    }
                    else if (line.Trim() == unityLightmapReadCode)
                    {
                        lines.Add(ftSignatureBegin);
                        lines.Add("#ifdef USEFTRACE");
                        lines.Add("        half3 bakedColor = ftLightmapBicubic(data.lightmapUV.xy);");
                        lines.Add("#else");
                        lines.Add(ftSignatureEnd);

                        lines.Add(unityLightmapReadCode);

                        lines.Add(ftSignatureBegin);
                        lines.Add("#endif");
                        lines.Add(ftSignatureEnd);
                    }
                    else
                    {
                        lines.Add(line);
                    }
                }
                reader.Close();

                if (!patched)
                {
                    if (!File.Exists(includeGIPath + "_backup")) File.Copy(includeGIPath, includeGIPath + "_backup");
                    var writer = new StreamWriter(includeGIPath, false);

                    if (writer == null)
                    {
                        UnityEngine.Debug.LogError("Can't open " + includeGIPath);
                        bicubic = false;
                        return;
                    }

                    for(int i=0; i<lines.Count; i++)
                    {
                        writer.WriteLine(lines[i]);
                    }
                    writer.Close();
                    //EditorUtility.DisplayDialog("Bakery", "Restart Editor to apply changes", "OK");
                }

                reader = new StreamReader(includeShadowPath);
                if (reader == null)
                {
                    UnityEngine.Debug.LogError("Can't open " + includeShadowPath);
                    bicubic = false;
                    return;
                }
                patched = false;

                lines = new List<string>();
                lines.Add(ftSignatureBegin);
                lines.Add(ftSignatureBicubic);
                lines.Add("#define USEFTRACE\n");
                lines.Add("#ifdef USEFTRACE");
                lines.Add("#include \"ftrace.cginc\"");
                lines.Add("#endif");
                lines.Add(ftSignatureEnd);

                while (!reader.EndOfStream)
                {
                    var line = reader.ReadLine();
                    if (line.StartsWith(ftSignatureBicubic))
                    {
                        UnityEngine.Debug.Log("Already patched");
                        patched = true;
                        break;
                    }
                    else if (line.IndexOf(unityShadowMaskRead) >= 0)
                    {
                        lines.Add(ftSignatureBegin);
                        lines.Add("#ifdef USEFTRACE");
                        lines.Add(line.Replace(unityShadowMaskRead, ftShadowMaskRead));
                        lines.Add("#else");
                        lines.Add(ftSignatureEnd);

                        lines.Add(line);

                        lines.Add(ftSignatureBegin);
                        lines.Add("#endif");
                        lines.Add(ftSignatureEnd);
                    }
                    else if (line.IndexOf(unityShadowMaskRead2) >= 0)
                    {
                        lines.Add(ftSignatureBegin);
                        lines.Add("#ifdef USEFTRACE");
                        lines.Add(line.Replace(unityShadowMaskRead2, ftShadowMaskRead2));
                        lines.Add("#else");
                        lines.Add(ftSignatureEnd);

                        lines.Add(line);

                        lines.Add(ftSignatureBegin);
                        lines.Add("#endif");
                        lines.Add(ftSignatureEnd);
                    }
                    else
                    {
                        lines.Add(line);
                    }
                }
                reader.Close();

                if (!patched)
                {
                    if (!File.Exists(includeShadowPath + "_backup")) File.Copy(includeShadowPath, includeShadowPath + "_backup");
                    var writer = new StreamWriter(includeShadowPath, false);

                    if (writer == null)
                    {
                        UnityEngine.Debug.LogError("Can't open " + includeShadowPath);
                        bicubicShadow = false;
                        return;
                    }

                    for(int i=0; i<lines.Count; i++)
                    {
                        writer.WriteLine(lines[i]);
                    }
                    writer.Close();
                    EditorUtility.DisplayDialog("Bakery", "Restart Editor to apply changes", "OK");
                }
            }

            if (wasBicubic && !bicubic)
            {
                bicubic = true;
                if (RevertFile(includeGIPath)) bicubic = false;
                bicubicShadow = true;
                if (RevertFile(includeShadowPath))
                {
                    bicubicShadow = false;
                    shadowBlend = false;
                }
                EditorUtility.DisplayDialog("Bakery", "Restart Editor to apply changes", "OK");
            }

            if (!wasShadowBlend && shadowBlend)
            {
                CopyInclude(shadersDir);
                var reader = new StreamReader(includeShadowPath);
                if (reader == null)
                {
                    UnityEngine.Debug.LogError("Can't open " + includeShadowPath);
                    shadowBlend = false;
                    return;
                }
                bool patched = false;

                var lines = new List<string>();
                lines.Add(ftSignatureBegin);
                lines.Add(ftSignatureShadowmask);
                lines.Add("#define USEFTRACE\n");
                lines.Add("#ifdef USEFTRACE");
                lines.Add("#include \"ftrace.cginc\"");
                lines.Add("#endif");
                lines.Add(ftSignatureEnd);

                while (!reader.EndOfStream)
                {
                    var line = reader.ReadLine();
                    if (line.StartsWith(ftSignatureShadowmask))
                    {
                        UnityEngine.Debug.Log("Already patched");
                        patched = true;
                        break;
                    }
                    else if (line.IndexOf(unityShadowMaskBlend) >= 0)
                    {
                        lines.Add(ftSignatureBegin);
                        lines.Add("#ifdef USEFTRACE");
                        lines.Add(line.Replace(unityShadowMaskBlend, ftShadowMaskBlend));
                        lines.Add("#else");
                        lines.Add(ftSignatureEnd);

                        lines.Add(line);

                        lines.Add(ftSignatureBegin);
                        lines.Add("#endif");
                        lines.Add(ftSignatureEnd);
                    }
                    else
                    {
                        lines.Add(line);
                    }
                }
                reader.Close();

                if (!patched)
                {
                    if (!File.Exists(includeShadowPath + "_backup")) File.Copy(includeShadowPath, includeShadowPath + "_backup");
                    var writer = new StreamWriter(includeShadowPath, false);

                    if (writer == null)
                    {
                        UnityEngine.Debug.LogError("Can't open " + includeShadowPath);
                        shadowBlend = false;
                        return;
                    }

                    for(int i=0; i<lines.Count; i++)
                    {
                        writer.WriteLine(lines[i]);
                    }
                    writer.Close();
                    EditorUtility.DisplayDialog("Bakery", "Restart Editor to apply changes", "OK");
                }
            }

            if (wasShadowBlend && !shadowBlend)
            {
                shadowBlend = true;
                if (RevertFile(includeShadowPath)) shadowBlend = false;

                bicubic = true;
                if (RevertFile(includeGIPath)) bicubic = false;

                EditorUtility.DisplayDialog("Bakery", "Restart Editor to apply changes", "OK");
            }

            if (!wasFalloff && falloff)
            {
                CopyInclude(shadersDir);
                var reader = new StreamReader(includeLightPath);
                if (reader == null)
                {
                    UnityEngine.Debug.LogError("Can't open " + includeLightPath);
                    falloff = false;
                    return;
                }
                bool patched = false;

                var lines = new List<string>();
                lines.Add(ftSignatureBegin);
                lines.Add("#define USEFTRACE\n");
                lines.Add("#ifdef USEFTRACE");
                lines.Add("#include \"ftrace.cginc\"");
                lines.Add("#endif");
                lines.Add(ftSignatureEnd);
                int lastIfdef = 0;
                int lastEndif = 0;
                int lastDefine = 0;

                while (!reader.EndOfStream)
                {
                    var line = reader.ReadLine();

                    //if (line.IndexOf(unityLightFalloffNew) >= 0)
                    //{
                    //    lines.Add(ftSignatureBegin);
                    //    lines.Add("/*");
                    //    lines.Add(ftSignatureEnd);
//
                    //    lines.Add(line);
//
                    //    lines.Add(ftSignatureBegin);
                    //    lines.Add("*/");
                    //    lines.Add(line.Replace(unityLightFalloffNew, ftLightFalloffNew));
                    //    lines.Add(ftSignatureEnd);
                    //    continue;
                    //}
                    //else if (line.IndexOf(unityLightFalloffNew2) >= 0)
                    //{
                    //    lines.Add(ftSignatureBegin);
                    //    lines.Add("/*");
                    //    lines.Add(ftSignatureEnd);
//
                    //    lines.Add(line);
//
                    //    lines.Add(ftSignatureBegin);
                    //    lines.Add("*/");
                    //    lines.Add(line.Replace(unityLightFalloffNew2, ftLightFalloffNew2));
                    //    lines.Add(ftSignatureEnd);
                    //    continue;
                    //}

                    if (line.IndexOf("#if") >= 0) lastIfdef = lines.Count;
                    if (line.IndexOf("define UNITY_LIGHT_ATTENUATION") >= 0 || line.IndexOf("define LIGHT_ATTENUATION") >= 0)
                    {
                       lastDefine = lines.Count;
                    }
                    if (line.IndexOf("#endif") >= 0) lastEndif = lines.Count;

                    if (line.StartsWith(ftSignatureBegin))
                    {
                        UnityEngine.Debug.Log("Already patched");
                        patched = true;
                        break;
                    }
                    else
                    {
                        if (lastEndif == lines.Count && lastDefine > lastIfdef) // we should be at the endif of light atten declaration
                        {
                            string ifdefLine = lines[lastIfdef];
                            string defineLine = lines[lastDefine];

                            if (defineLine.IndexOf("define UNITY_LIGHT_ATTENUATION") >= 0)
                            {
                                if ((ifdefLine.IndexOf("POINT") >= 0 || ifdefLine.IndexOf("SPOT") >= 0) &&
                                    ifdefLine.IndexOf("POINT_COOKIE") < 0 && ifdefLine.IndexOf("SPOT_COOKIE") < 0)
                                {
                                    // Forward point light
                                    lines.Insert(lastDefine, ftSignatureBegin);
                                    lines.Insert(lastDefine + 1, "/*");
                                    lines.Insert(lastDefine + 2, ftSignatureEnd);

                                    lines.Add(ftSignatureBegin);
                                    lines.Add("*/");

                                    if (ifdefLine.IndexOf("POINT") >= 0)
                                    {
                                        //lines.Add(unityLightMatrixDecl);
                                        lines.Add(unityDefineLightAtten + "\\");
                                        lines.Add(unityGetShadowCoord + "\\");
                                        lines.Add(unityGetShadow + "\\");
                                        lines.Add(ftLightFalloff + " * shadow;");
                                    }
                                    else if (ifdefLine.IndexOf("SPOT") >= 0)
                                    {
                                        lines.Add(unityDefineLightAtten + "\\");
                                        lines.Add(unityGetShadowCoord4 + "\\");
                                        lines.Add(unityGetShadow + "\\");
                                        lines.Add(ftLightFalloff + " * (lightCoord.z > 0) * UnitySpotCookie(lightCoord) * shadow;");
                                    }

                                    lines.Add(ftSignatureEnd);
                                }
                            }
                            //else if (defineLine.IndexOf("define LIGHT_ATTENUATION") >= 0)
                           // {
                           //     if (ifdefLine.IndexOf("POINT") >= 0)
                           //     {
                           //         // Deferred point light
                           //         lines.Insert(lastDefine, ftSignatureBegin);
                           //         lines.Insert(lastDefine + 1, "/*");
                           //         lines.Insert(lastDefine + 2, ftSignatureEnd);

                           //         lines.Insert(lastDefine + 4, ftSignatureBegin);
                           //         lines.Insert(lastDefine + 5, "*/");

                           //         if (ifdefLine.IndexOf("POINT") >= 0)
                           //         {
                           //             lines.Add(ftLightFalloffDeferred);
                           //         }

                           //         lines.Add(ftSignatureEnd);
                           //     }
                           // }
                        }
                        lines.Add(line);
                    }
                }
                reader.Close();

                if (!patched)
                {
                    if (!File.Exists(includeLightPath + "_backup")) File.Copy(includeLightPath, includeLightPath + "_backup");
                    var writer = new StreamWriter(includeLightPath, false);

                    if (writer == null)
                    {
                        UnityEngine.Debug.LogError("Can't open " + includeLightPath);
                        falloff = false;
                        return;
                    }

                    for(int i=0; i<lines.Count; i++)
                    {
                        writer.WriteLine(lines[i]);
                    }
                    writer.Close();
                    EditorUtility.DisplayDialog("Bakery", "Restart Editor to apply changes", "OK");
                }
            }

            if (wasFalloff && !falloff)
            {
                falloff = true;
                if (RevertFile(includeLightPath)) falloff = false;
                EditorUtility.DisplayDialog("Bakery", "Restart Editor to apply changes", "OK");
            }


            if (!wasFalloffDeferred && falloffDeferred)
            {
                CopyInclude(shadersDir);
                var reader = new StreamReader(includeDeferredPath);
                if (reader == null)
                {
                    UnityEngine.Debug.LogError("Can't open " + includeDeferredPath);
                    falloff = false;
                    return;
                }
                bool patched = false;

                var lines = new List<string>();
                lines.Add(ftSignatureBegin);
                lines.Add("#define USEFTRACE\n");
                lines.Add("#ifdef USEFTRACE");
                lines.Add("#include \"ftrace.cginc\"");
                lines.Add("#endif");
                lines.Add(ftSignatureEnd);

                while (!reader.EndOfStream)
                {
                    var line = reader.ReadLine();
                    if (line.StartsWith(ftSignatureBegin))
                    {
                        UnityEngine.Debug.Log("Already patched");
                        patched = true;
                        break;
                    }
                    else if (line.IndexOf(unitySpotFalloffDeferred) >= 0)
                    {
                        lines.Add(ftSignatureBegin);
                        lines.Add("/*");
                        lines.Add(ftSignatureEnd);

                        lines.Add(line);

                        lines.Add(ftSignatureBegin);
                        lines.Add("*/");
                        lines.Add(ftSpotFalloffDeferred);
                        lines.Add(ftSignatureEnd);
                    }
                    else if (line.IndexOf(unityPointFalloffDeferred) >= 0)
                    {
                        lines.Add(ftSignatureBegin);
                        lines.Add("/*");
                        lines.Add(ftSignatureEnd);

                        lines.Add(line);

                        lines.Add(ftSignatureBegin);
                        lines.Add("*/");
                        lines.Add(ftPointFalloffDeferred);
                        lines.Add(ftSignatureEnd);
                    }
                    else
                    {
                        lines.Add(line);
                    }
                }
                reader.Close();

                if (!patched)
                {
                    if (!File.Exists(includeDeferredPath + "_backup")) File.Copy(includeDeferredPath, includeDeferredPath + "_backup");
                    var writer = new StreamWriter(includeDeferredPath, false);

                    if (writer == null)
                    {
                        UnityEngine.Debug.LogError("Can't open " + includeDeferredPath);
                        falloffDeferred = false;
                        return;
                    }

                    for(int i=0; i<lines.Count; i++)
                    {
                        writer.WriteLine(lines[i]);
                    }
                    writer.Close();
                    EditorUtility.DisplayDialog("Bakery", "Restart Editor to apply changes", "OK");
                }
            }

            if (wasFalloffDeferred && !falloffDeferred)
            {
                falloffDeferred = true;
                if (RevertFile(includeDeferredPath)) falloffDeferred = false;
                EditorUtility.DisplayDialog("Bakery", "Restart Editor to apply changes", "OK");
            }


        }
        else
        {
            GUI.Label(new Rect(10, 20, 250, 30), "Can't find Unity include at path: \n" + includeGIPath + ".");
        }
        GUI.EndGroup();
    }

    [MenuItem ("Bakery/Global shader tweaks", false, 60)]
    public static void RenderLightmap () {
        ScriptableWizard.DisplayWizard("Bakery - shader tweaks", typeof(ftShaderTweaks), "RenderLightmap");
    }
}

#endif
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftShaderTweaks.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftSkyLightInspector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 43b464df539471c47880a0cc39cd4861
# ASMDEF: BakeryEditorAssembly.dll
# ---

using UnityEditor;
using UnityEngine;
using System;
using System.IO;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using UnityEditor.SceneManagement;
using UnityEngine.SceneManagement;

[CustomEditor(typeof(BakerySkyLight))]
[CanEditMultipleObjects]
public class ftSkyLightInspector : UnityEditor.Editor
{
    public static Quaternion QuaternionFromMatrix(Matrix4x4 m) {
        Quaternion q = new Quaternion();
        q.w = Mathf.Sqrt( Mathf.Max( 0, 1 + m[0,0] + m[1,1] + m[2,2] ) ) / 2;
        q.x = Mathf.Sqrt( Mathf.Max( 0, 1 + m[0,0] - m[1,1] - m[2,2] ) ) / 2;
        q.y = Mathf.Sqrt( Mathf.Max( 0, 1 - m[0,0] + m[1,1] - m[2,2] ) ) / 2;
        q.z = Mathf.Sqrt( Mathf.Max( 0, 1 - m[0,0] - m[1,1] + m[2,2] ) ) / 2;
        q.x *= Mathf.Sign( q.x * ( m[2,1] - m[1,2] ) );
        q.y *= Mathf.Sign( q.y * ( m[0,2] - m[2,0] ) );
        q.z *= Mathf.Sign( q.z * ( m[1,0] - m[0,1] ) );
        return q;
    }

    SerializedProperty ftraceLightColor;
    SerializedProperty ftraceLightIntensity;
    SerializedProperty ftraceLightTexture;
    SerializedProperty ftraceLightSamples;
    SerializedProperty ftraceLightHemi;
    SerializedProperty ftraceLightCorrectRot;
    SerializedProperty ftraceLightBitmask;
    SerializedProperty ftraceLightBakeToIndirect;
    SerializedProperty ftraceLightIndirectIntensity;
    SerializedProperty ftraceTangentSH;

    int texCached = -1;

    void TestPreviewRefreshProperty(ref int cached, int newVal)
    {
        if (cached >= 0)
        {
            if (cached != newVal)
            {
                BakerySkyLight.lightsChanged = 2;
            }
        }
        cached = newVal;
    }

    void TestPreviewRefreshProperty(ref int cached, UnityEngine.Object newVal)
    {
        if (newVal == null)
        {
            TestPreviewRefreshProperty(ref cached, 0);
            return;
        }
        TestPreviewRefreshProperty(ref cached, newVal.GetInstanceID());
    }

    static string ftSkyboxShaderName = "Bakery/Skybox";

    ftLightmapsStorage storage;

    static string[] selStrings = new string[] {"0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16",
                                                "17","18","19","20","21","22","23","24","25","26","27","28","29","30"};//,"31"};

    static public string[] directContributionOptions = new string[] {"Direct And Indirect (recommended)", "Indirect only"};

    bool showExperimental = false;

    void OnEnable()
    {
        ftraceLightColor = serializedObject.FindProperty("color");
        ftraceLightIntensity = serializedObject.FindProperty("intensity");
        ftraceLightIndirectIntensity = serializedObject.FindProperty("indirectIntensity");
        ftraceLightTexture = serializedObject.FindProperty("cubemap");
        ftraceLightSamples = serializedObject.FindProperty("samples");
        ftraceLightHemi = serializedObject.FindProperty("hemispherical");
        ftraceLightCorrectRot = serializedObject.FindProperty("correctRotation");
        ftraceLightBitmask = serializedObject.FindProperty("bitmask");
        ftraceLightBakeToIndirect = serializedObject.FindProperty("bakeToIndirect");
        ftraceTangentSH = serializedObject.FindProperty("tangentSH");
    }

    public override void OnInspectorGUI() {
        {
            serializedObject.Update();

            TestPreviewRefreshProperty(ref texCached, ftraceLightTexture.objectReferenceValue);

            EditorGUILayout.PropertyField(ftraceLightColor, new GUIContent("Color", "Sky color. Multiplies texture color."));
            EditorGUILayout.PropertyField(ftraceLightIntensity, new GUIContent("Intensity", "Color multiplier"));
            EditorGUILayout.PropertyField(ftraceLightTexture, new GUIContent("Sky texture", "Cubemap"));
            if (ftraceLightTexture.objectReferenceValue != null)
            {
                EditorGUILayout.PropertyField(ftraceLightCorrectRot, new GUIContent("Correct rotation", "Enable to have a proper match between GameObject rotation and HDRI rotation. Disabled by default for backwards compatibility."));
                var angles = (target as BakerySkyLight).transform.eulerAngles;
                EditorGUILayout.LabelField("Cubemap angles: " + angles.x + ", " + angles.y + ", " + angles.z);
                EditorGUILayout.LabelField("Rotate this GameObject to change cubemap angles.");
                EditorGUILayout.Space();
            }
            EditorGUILayout.PropertyField(ftraceLightSamples, new GUIContent("Samples", "The amount of rays tested for this light. Rays are emitted hemispherically."));

            EditorGUILayout.PropertyField(ftraceLightHemi, new GUIContent("Hemispherical", "Only emit light from upper hemisphere"));

            //ftraceLightBitmask.intValue = EditorGUILayout.MaskField(new GUIContent("Bitmask", "Lights only affect renderers with overlapping bits"), ftraceLightBitmask.intValue, selStrings);
            int prevVal = ftraceLightBitmask.intValue;
            int newVal = EditorGUILayout.MaskField(new GUIContent("Bitmask", "Lights only affect renderers with overlapping bits"), ftraceLightBitmask.intValue, selStrings);
            if (prevVal != newVal) ftraceLightBitmask.intValue = newVal;

            //EditorGUILayout.PropertyField(ftraceLightBakeToIndirect, new GUIContent("Bake to indirect", "Add direct contribution from this light to indirect-only lightmaps"));

            if (storage == null) storage = ftRenderLightmap.FindRenderSettingsStorage();
            var rmode = storage.renderSettingsUserRenderMode;
            if (rmode != (int)ftRenderLightmap.RenderMode.FullLighting)
            {
                ftDirectLightInspector.BakeWhat contrib;
                if (ftraceLightBakeToIndirect.boolValue)
                {
                    contrib = ftDirectLightInspector.BakeWhat.DirectAndIndirect;
                }
                else
                {
                    contrib = ftDirectLightInspector.BakeWhat.IndirectOnly;
                }
                var prevContrib = contrib;

                contrib = (ftDirectLightInspector.BakeWhat)EditorGUILayout.Popup("Baked contribution", (int)contrib, directContributionOptions);

                if (prevContrib != contrib)
                {
                    if (contrib == ftDirectLightInspector.BakeWhat.IndirectOnly)
                    {
                        ftraceLightBakeToIndirect.boolValue = false;
                    }
                    else
                    {
                        ftraceLightBakeToIndirect.boolValue = true;
                    }
                }
            }

            EditorGUILayout.PropertyField(ftraceLightIndirectIntensity, new GUIContent("Indirect intensity", "Non-physical GI multiplier for this light"));

            showExperimental = EditorGUILayout.Foldout(showExperimental, "Experimental", EditorStyles.foldout);
            if (showExperimental)
            {
                EditorGUILayout.PropertyField(ftraceTangentSH, new GUIContent("Tangent-space SH", "Only affects single-color skylights. When baking in SH mode, harmonics will be in tangent space. Can be useful for implementing skinned model specular occlusion in custom shaders."));
            }

            serializedObject.ApplyModifiedProperties();
        }

        var skyMat = RenderSettings.skybox;
        bool match = false;
        bool skyboxValid = true;
        string why = "";
        if (skyMat != null)
        {
            if (skyMat.HasProperty("_Tex") && skyMat.HasProperty("_Exposure") && skyMat.HasProperty("_Tint"))
            {
                if (skyMat.GetTexture("_Tex") == ftraceLightTexture.objectReferenceValue)
                {
                    float exposure = skyMat.GetFloat("_Exposure");
                    bool exposureSRGB = skyMat.shader.name == "Skybox/Cubemap";
                    if (exposureSRGB)
                    {
                        exposure = Mathf.Pow(exposure, 2.2f); // can't detect [Gamma] keyword...
                        exposure *= PlayerSettings.colorSpace == ColorSpace.Linear ? 4.59f : 2; // weird unity constant
                    }
                    if (Mathf.Abs(exposure - ftraceLightIntensity.floatValue) < 0.0001f)
                    {
                        if (skyMat.GetColor("_Tint") == ftraceLightColor.colorValue)
                        {
                            bool anglesMatch = true;
                            var angles = (target as BakerySkyLight).transform.eulerAngles;
                            Vector3 matMatrixX = Vector3.right;
                            Vector3 matMatrixY = Vector3.up;
                            Vector3 matMatrixZ = Vector3.forward;
                            float matAngleY = 0;
                            bool hasYAngle = skyMat.HasProperty("_Rotation");
                            bool hasXZAngles = skyMat.HasProperty("_MatrixRight");
                            if (hasYAngle) matAngleY = skyMat.GetFloat("_Rotation");
                            if (hasXZAngles)
                            {
                                matMatrixX = skyMat.GetVector("_MatrixRight");
                                matMatrixY = skyMat.GetVector("_MatrixUp");
                                matMatrixZ = skyMat.GetVector("_MatrixForward");
                            }

                            if (angles.y != 0 && !hasYAngle)
                            {
                                anglesMatch = false;
                                why = "no _Rotation property, but light is rotated";
                            }
                            else if ((angles.x != 0 || angles.z != 0) && !hasXZAngles)
                            {
                                anglesMatch = false;
                                why = "shader doesn't allow XZ rotation";
                            }
                            else
                            {
                                var lightQuat = (target as BakerySkyLight).transform.rotation;
                                Quaternion matQuat;
                                if (hasXZAngles)
                                {
                                    var mtx = new Matrix4x4();
                                    mtx.SetColumn(0, new Vector4(matMatrixX.x, matMatrixX.y, matMatrixX.z, 0));
                                    mtx.SetColumn(1, new Vector4(matMatrixY.x, matMatrixY.y, matMatrixY.z, 0));
                                    mtx.SetColumn(2, new Vector4(matMatrixZ.x, matMatrixZ.y, matMatrixZ.z, 0));
                                    matQuat = QuaternionFromMatrix(mtx);
                                }
                                else
                                {
                                    matQuat = Quaternion.Euler(0, matAngleY, 0);
                                }

                                float diff = Quaternion.Angle(matQuat, lightQuat);
                                //Debug.Log("d " + diff);
                                if (Mathf.Abs(diff) > 0.01f)
                                {
                                    anglesMatch = false;
                                    why = "angles don't match";
                                }
                            }
                            if (anglesMatch) match = true;
                        }
                        else
                        {
                            why = "color doesn't match";
                        }
                    }
                    else
                    {
                        why = "exposure doesn't match";
                    }
                }
                else
                {
                    why = "texture doesn't match";
                }
            }
            else
            {
                if (!skyMat.HasProperty("_Tex")) why += "_Tex ";
                if (!skyMat.HasProperty("_Exposure")) why += "_Exposure ";
                if (!skyMat.HasProperty("_Tint")) why += "_Tint ";
                why += "not defined";
                skyboxValid = false;
            }
        }
        else
        {
            why = "no skybox set";
            skyboxValid = false;
        }

        if (!match)
        {
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Skylight doesn't match skybox: " + why);
            EditorGUILayout.Space();

            if (skyboxValid)
            {
                if (GUILayout.Button("Match this light to scene skybox"))
                {
                    ftraceLightTexture.objectReferenceValue = skyMat.GetTexture("_Tex");

                    float exposure = skyMat.GetFloat("_Exposure");
                    bool exposureSRGB = skyMat.shader.name == "Skybox/Cubemap";
                    if (exposureSRGB)
                    {
                        exposure = Mathf.Pow(exposure, 2.2f); // can't detect [Gamma] keyword...
                        exposure *= PlayerSettings.colorSpace == ColorSpace.Linear ? 4.59f : 2; // weird unity constant
                    }
                    ftraceLightIntensity.floatValue = exposure;

                    ftraceLightColor.colorValue = skyMat.GetColor("_Tint");

                    float matAngle = 0;
                    if (skyMat.HasProperty("_Rotation")) matAngle = skyMat.GetFloat("_Rotation");
                    var matQuat = Quaternion.Euler(0, matAngle, 0);
                    Undo.RecordObject((target as BakerySkyLight).transform, "Rotate skylight");
                    (target as BakerySkyLight).transform.rotation = matQuat;

                    serializedObject.ApplyModifiedProperties();
                }
            }

            if (GUILayout.Button("Match scene skybox to this light"))
            {
                if (skyMat != null)
                {
                    Undo.RecordObject(skyMat, "Change skybox");
                }
                var tform = (target as BakerySkyLight).transform;
                var angles = tform.eulerAngles;
                if (angles.x !=0 || angles.z !=0)
                {
                    if (skyboxValid && !skyMat.HasProperty("_MatrixRight")) skyboxValid = false; // only ftrace skybox can handle xz rotation for now
                }

                if (angles.y != 0 && skyboxValid && !skyMat.HasProperty("_Rotation")) skyboxValid = false; // needs _Rotation for Y angle

                if (!skyboxValid)
                {
                    var outputPath = ftRenderLightmap.outputPath;
                    skyMat = new Material(Shader.Find(ftSkyboxShaderName));
                    if (!Directory.Exists("Assets/" + outputPath))
                    {
                        Directory.CreateDirectory("Assets/" + outputPath);
                    }
                    AssetDatabase.CreateAsset(skyMat, "Assets/" + outputPath + "/" + SceneManager.GetActiveScene().name + "_skybox.asset");
                    AssetDatabase.SaveAssets();
                    AssetDatabase.Refresh();
                }
                skyMat.SetTexture("_Tex", ftraceLightTexture.objectReferenceValue as Cubemap);
                skyMat.SetFloat("_NoTexture", ftraceLightTexture.objectReferenceValue == null ? 1 : 0);

                float exposure = ftraceLightIntensity.floatValue;
                bool exposureSRGB = skyMat.shader.name == "Skybox/Cubemap";
                if (exposureSRGB)
                {
                    exposure /= PlayerSettings.colorSpace == ColorSpace.Linear ? 4.59f : 2; // weird unity constant
                    exposure = Mathf.Pow(exposure, 1.0f / 2.2f); // can't detect [Gamma] keyword...
                }
                skyMat.SetFloat("_Exposure", exposure);

                skyMat.SetColor("_Tint", ftraceLightColor.colorValue);

                if (skyMat.HasProperty("_Rotation")) skyMat.SetFloat("_Rotation", angles.y);

                if ((target as BakerySkyLight).correctRotation)
                {
                    // transpose
                    var r = tform.right;
                    var u = tform.up;
                    var f = tform.forward;
                    if (skyMat.HasProperty("_MatrixRight")) skyMat.SetVector("_MatrixRight",  new Vector3(r.x, u.x, f.x));
                    if (skyMat.HasProperty("_MatrixUp")) skyMat.SetVector("_MatrixUp", new Vector3(r.y, u.y, f.y));
                    if (skyMat.HasProperty("_MatrixForward")) skyMat.SetVector("_MatrixForward", new Vector3(r.z, u.z, f.z));
                }
                else
                {
                    if (skyMat.HasProperty("_MatrixRight")) skyMat.SetVector("_MatrixRight",  tform.right);
                    if (skyMat.HasProperty("_MatrixUp")) skyMat.SetVector("_MatrixUp", tform.up);
                    if (skyMat.HasProperty("_MatrixForward")) skyMat.SetVector("_MatrixForward", tform.forward);
                }

                RenderSettings.skybox = skyMat;
                EditorUtility.SetDirty(skyMat);
                EditorSceneManager.MarkAllScenesDirty();
            }

            EditorGUILayout.Space();
            EditorGUILayout.Space();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftSkyLightInspector.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftTextureProcessor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 68d2ca0e99ca9604fa09956f75773620
# ASMDEF: BakeryEditorAssembly.dll
# ---
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
#if UNITY_2021_2_OR_NEWER
using System.IO;
using System.IO.MemoryMappedFiles;
using System.Runtime.Serialization.Formatters.Binary;
#endif

public class ftTextureProcessor : AssetPostprocessor
{
    public static Dictionary<string, ftRenderLightmap.Int2> texSettings = new Dictionary<string, ftRenderLightmap.Int2>();
    static BakeryProjectSettings pstorage;
    //static ftGlobalStorage gstorage;

    public const int TEX_LM = 0;
    public const int TEX_LMDEFAULT = 1;
    public const int TEX_MASK = 2;
    public const int TEX_DIR = 3;
    public const int TEX_MASK_NO_ALPHA = 4;
    public const int TEX_DIR_NO_ALPHA = 5;

#if (!UNITY_2020_2_OR_NEWER)
    // Pre-broken Unity
    void OnPreprocessTexture()
#else
    // Do not use OnPreprocessTexture on >= 2020.2.2 due to it forcing full project reimport!
    // https://forum.unity.com/threads/unity-made-full-project-reimport-on-every-small-change.1066844/
    #if (!BAKERY_INCLUDED || BAKERY_NOREIMPORT)
        // First package import OR the new define is set
        void OnPreprocessAsset()
    #else
        // Existing project - don't change the method, or the preprocessor hash (?) will change and trigger the full reimport again!
        void OnPreprocessTexture()
    #endif
#endif
    {
        TextureImporter importer = assetImporter as TextureImporter;
        if (importer == null) return;

        var settings = new ftRenderLightmap.Int2();

        bool loadFromAsset = false;
#if UNITY_2021_2_OR_NEWER
        // For parallel import
        if (UnityEditor.EditorSettings.refreshImportMode == AssetDatabase.RefreshImportMode.OutOfProcessPerQueue)
        {
            loadFromAsset = true;

            try
            {
                using (var mmf = MemoryMappedFile.OpenExisting("FTEXPROC"))
                {
                    using (var stream = mmf.CreateViewStream(0, ftRenderLightmap.maxTexSettingsSize))
                    {
                        var formatter = new BinaryFormatter();
                        var buffer = new byte[ftRenderLightmap.maxTexSettingsSize];
                        if (!stream.CanRead)
                        {
                            Debug.LogError("Can't read texture settings from memory mapped file");
                            return;
                        }
                        stream.Read(buffer, 0, ftRenderLightmap.maxTexSettingsSize);
                        var texS = formatter.Deserialize(new MemoryStream(buffer)) as Dictionary<string, ftRenderLightmap.Int2>;

                        if (!texS.TryGetValue(importer.assetPath, out settings)) return;
                    }
                }
            }
            catch(FileNotFoundException)
            {
                return;
            }
            catch(System.Exception)
            {
                throw;
            }
        }
#endif

        if (!loadFromAsset)
        {
            if (!texSettings.TryGetValue(importer.assetPath, out settings)) return;
        }

        if (pstorage == null) pstorage = ftLightmaps.GetProjectSettings();

        importer.maxTextureSize = (int)settings.x;
        importer.mipmapEnabled = pstorage.mipmapLightmaps;
        importer.wrapMode = TextureWrapMode.Clamp;

        int texType = (int)settings.y;
        switch(texType)
        {
            case TEX_LM:
            {
                importer.textureType = TextureImporterType.Lightmap;
                if (pstorage.lightmapCompression != BakeryProjectSettings.Compression.CompressButAllowOverridingAsset)
                {
                    importer.textureCompression = pstorage.lightmapCompression == BakeryProjectSettings.Compression.ForceCompress ?
                        TextureImporterCompression.Compressed : TextureImporterCompression.Uncompressed;
                }
                break;
            }
            case TEX_LMDEFAULT:
            {
                importer.textureType = TextureImporterType.Default;
                if (pstorage.lightmapCompression != BakeryProjectSettings.Compression.CompressButAllowOverridingAsset)
                {
                    importer.textureCompression = pstorage.lightmapCompression == BakeryProjectSettings.Compression.ForceCompress ?
                        TextureImporterCompression.Compressed : TextureImporterCompression.Uncompressed;
                }
                break;
            }
            case TEX_MASK:
            {
                importer.textureType = TextureImporterType.Default;
                importer.textureCompression = pstorage.lightmapCompression != BakeryProjectSettings.Compression.ForceNoCompress ? TextureImporterCompression.CompressedHQ : TextureImporterCompression.Uncompressed;
                importer.alphaSource = TextureImporterAlphaSource.FromInput;
                break;
            }
            case TEX_MASK_NO_ALPHA:
            {
                importer.textureType = TextureImporterType.Default;
                importer.textureCompression = pstorage.lightmapCompression != BakeryProjectSettings.Compression.ForceNoCompress ? TextureImporterCompression.Compressed : TextureImporterCompression.Uncompressed;
                importer.alphaSource = TextureImporterAlphaSource.None;
                break;
            }
            case TEX_DIR:
            {
                importer.textureType = TextureImporterType.Default;
                importer.textureCompression =  pstorage.lightmapCompression != BakeryProjectSettings.Compression.ForceNoCompress ? (pstorage.dirHighQuality ? TextureImporterCompression.CompressedHQ : TextureImporterCompression.Compressed) : TextureImporterCompression.Uncompressed;
                importer.sRGBTexture = (pstorage.format8bit == BakeryProjectSettings.FileFormat.PNG);
                break;
            }
            case TEX_DIR_NO_ALPHA:
            {
                importer.textureType = TextureImporterType.Default;
                importer.textureCompression = pstorage.lightmapCompression != BakeryProjectSettings.Compression.ForceNoCompress ? TextureImporterCompression.Compressed : TextureImporterCompression.Uncompressed;
                importer.alphaSource = TextureImporterAlphaSource.None;
                importer.sRGBTexture = false;//(pstorage.format8bit == BakeryProjectSettings.FileFormat.PNG);
                break;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftTextureProcessor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftUpdater.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7150afb8f1312c144ab37ad7b22c6e7a
# ASMDEF: BakeryEditorAssembly.dll
# ---
// Disable 'obsolete' warnings
#pragma warning disable 0618

#if UNITY_EDITOR

using UnityEngine;
using UnityEditor;
using UnityEditor.Callbacks;
using System;
using System.IO;
using System.Text;
using System.Net;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.Networking;
using System.Runtime.InteropServices;

[InitializeOnLoad]
public class ftUpdater : EditorWindow
{
    [DllImport ("frender", CallingConvention=CallingConvention.Cdecl)]
    public static extern int ExtractZIP([MarshalAs(UnmanagedType.LPWStr)]string zipFilename, int skipInnerFolders, string onlyFolder, [MarshalAs(UnmanagedType.LPWStr)]string outPath);

    IEnumerator progressFunc;
    float progress = 0.0f;
    string curItem = "";
    bool isError = false;

    string inLM = "IN000000000000";
    string inRT = "IN000000000000";
    string username = "";
    string errMsg = "";
    string lastVer = "";
    bool init = false;

    bool anythingDownloaded = false;

	[MenuItem ("Bakery/Utilities/Check for patches", false, 1000)]
	public static void Check()
    {
        var instance = (ftUpdater)GetWindow(typeof(ftUpdater));
        instance.titleContent.text = "Bakery patch";
        instance.minSize = new Vector2(320, 110);
        instance.maxSize = new Vector2(instance.minSize.x, instance.minSize.y + 1);
        instance.Show();
    }

    void DebugLogError(string str)
    {
        Debug.LogError(str);
        errMsg = str;
        progressFunc = null;
        isError = true;
        Repaint();
    }

    IEnumerator DownloadItem(string url)
    {
        var req = UnityWebRequest.Get(url + curItem);
        yield return req.Send();
        while(!req.isDone)
        {
            progress = req.downloadProgress;
            Repaint();
            yield return null;
        }

        if (req.isError)
        {
            DebugLogError("Download error (" + curItem + ")");
            yield break;
        }
        else
        {
            if (req.downloadHandler.data.Length < 100)
            {
                DebugLogError(req.downloadHandler.text);
                yield break;
            }
            else
            {
                File.WriteAllBytes(curItem + ".zip", req.downloadHandler.data);
            }
        }
    }

    IEnumerator GetLastVer(string url)
    {
        lastVer = "";
        var req = UnityWebRequest.Get(url + curItem + "&getLastVer");
        yield return req.Send();
        while(!req.isDone)
        {
            progress = req.downloadProgress;
            Repaint();
            yield return null;
        }

        if (req.isError)
        {
            DebugLogError("Request error (" + curItem + ")");
            yield break;
        }
        else
        {
            if (req.downloadHandler.data.Length != 40)
            {
                DebugLogError(req.downloadHandler.text);
                yield break;
            }
            else
            {
                lastVer = req.downloadHandler.text;
            }
        }
    }

    IEnumerator DownloadItemIfNewer(string url)
    {
        var dw = GetLastVer(url);
        while(dw.MoveNext()) yield return null;
        if (isError) yield break;

        var fname = curItem + "-cver.txt"; // currently installed
        if (File.Exists(fname))
        {
            var curVer = File.ReadAllText(fname);
            if (lastVer == curVer)
            {
                Debug.Log(curItem + ": already latest");
                yield break;
            }
        }

        dw = DownloadItem(url);
        while(dw.MoveNext()) yield return null;
        anythingDownloaded = true;

        File.WriteAllText(curItem + "-dver.txt", lastVer); // downloaded
    }

    IEnumerator CheckProc()
    {
        //var runtimePath = ftLightmaps.GetRuntimePath();
        //var editorPath =  ftLightmaps.GetEditorPath();

        isError = false;

        bool downloadLM = inLM.Length > 0 && inLM != "IN000000000000";
        bool downloadRT = inRT.Length > 0 && inRT != "IN000000000000";

        if (!downloadLM && !downloadRT)
        {
            DebugLogError("No invoices set");
            yield break;
        }

        anythingDownloaded = false;

        if (downloadLM)
        {
            // Download bakery-csharp
            curItem = "bakery-csharp";
            var dw = DownloadItemIfNewer("https://geom.io/bakery/github-download.php?name=" + username + "&invoice=" + inLM + "&repo=");
            while(dw.MoveNext()) yield return null;
            if (isError) yield break;

            // Download bakery-compiled
            curItem = "bakery-compiled";
            dw = DownloadItemIfNewer("https://geom.io/bakery/github-download.php?name=" + username + "&invoice=" + inLM + "&repo=");
            while(dw.MoveNext()) yield return null;
            if (isError) yield break;
        }

        if (downloadRT)
        {
            // Download bakery-rtpreview-csharp
            curItem = "bakery-rtpreview-csharp";
            var dw = DownloadItemIfNewer("https://geom.io/bakery/github-download.php?name=" + username + "&invoice=" + inRT + "&repo=");
            while(dw.MoveNext()) yield return null;
            if (isError) yield break;
        }

        if (!anythingDownloaded)
        {
            if (EditorUtility.DisplayDialog("Bakery", "There are no new patches. Re-apply previous patch?", "Yes", "No"))
            {
                anythingDownloaded = true;
            }
        }

        if (anythingDownloaded)
        {
            var cachePath = Directory.GetCurrentDirectory() + "/BakeryPatchCache";
            if (!Directory.Exists(cachePath)) Directory.CreateDirectory(cachePath);

            var runtimePath = cachePath + "/Runtime";
            if (!Directory.Exists(runtimePath)) Directory.CreateDirectory(runtimePath);

            var editorPath =  cachePath + "/Editor";
            if (!Directory.Exists(editorPath)) Directory.CreateDirectory(editorPath);

            if (downloadLM)
            {
                // Extract runtime files
                int err = ExtractZIP("bakery-csharp.zip", 1, "Bakery", runtimePath);
                if (err != 0)
                {
                    DebugLogError("ExtractZIP: " + err);
                    yield break;
                }

                // Extract editor files
                err = ExtractZIP("bakery-csharp.zip", 3, "Bakery", editorPath);
                if (err != 0)
                {
                    DebugLogError("ExtractZIP: " + err);
                    yield break;
                }

                Debug.Log("Extracted bakery-csharp");

                // Extract binaries
                err = ExtractZIP("bakery-compiled.zip", 1, "", editorPath);
                if (err != 0)
                {
                    DebugLogError("ExtractZIP: " + err);
                    yield break;
                }

                Debug.Log("Extracted bakery-compiled");
            }

            if (downloadRT)
            {
                // Extract RTPreview files
                int err = ExtractZIP("bakery-rtpreview-csharp.zip", 1, "", editorPath);
                if (err != 0)
                {
                    DebugLogError("ExtractZIP: " + err);
                    yield break;
                }

                Debug.Log("Extracted bakery-rtpreview-csharp");
            }
        }

        Debug.Log("Done");

        progressFunc = null;
        Repaint();

        if (anythingDownloaded) EditorUtility.DisplayDialog("Bakery", "Restart Editor to apply the patch", "OK");
    }

    void CheckUpdate()
    {
        if (!progressFunc.MoveNext())
        {
            EditorApplication.update -= CheckUpdate;
        }
    }

    void OnGUI()
    {
        if (!init)
        {
            if (PlayerPrefs.HasKey("BakeryInvLM")) inLM = PlayerPrefs.GetString("BakeryInvLM");
            if (PlayerPrefs.HasKey("BakeryInvRT")) inRT = PlayerPrefs.GetString("BakeryInvRT");
            if (PlayerPrefs.HasKey("BakeryGHUsername")) username = PlayerPrefs.GetString("BakeryGHUsername");
            init = true;
        }

        int y = 10;

        if (progressFunc != null) GUI.enabled = false;

        GUI.Label(new Rect(5, y, 130, 18), "Lightmapper invoice:");
        var prev = inLM;
        inLM = EditorGUI.TextField(new Rect(140, y, 170, 18), inLM);
        if (inLM != prev && (inLM.Length == 14 || inLM.Length == 0 || inLM.Length == 20)) // 14 is invoice, 20 is HB code
        {
            PlayerPrefs.SetString("BakeryInvLM", inLM);
        }
        y += 18;

        GUI.Label(new Rect(5, y, 120, 18), "RTPreview invoice:");
        prev = inRT;
        inRT = EditorGUI.TextField(new Rect(140, y, 170, 18), inRT);
        if (inRT != prev && (inRT.Length == 14 || inRT.Length == 0))
        {
            PlayerPrefs.SetString("BakeryInvRT", inRT);
        }
        y += 18;

        GUI.Label(new Rect(5, y, 130, 18), "GitHub username:");
        prev = username;
        username = EditorGUI.TextField(new Rect(140, y, 170, 18), username);
        if (username != prev && username.Length <= 255)
        {
            PlayerPrefs.SetString("BakeryGHUsername", username);
        }
        y += 18*2;

        if (GUI.Button(new Rect(0, y, 320, 18), "Check"))
        {
            SessionState.SetBool("BakeryPatchWaitForRestart", true);
            progressFunc = CheckProc();
            EditorApplication.update += CheckUpdate;
        }
        y += 20;

        GUI.enabled = true;

        minSize = new Vector2(320, isError ? 160 : (progressFunc == null ? 110 : 160));

        if (progressFunc != null)
        {
            GUI.Label(new Rect(0, y, 320, 24), curItem);
            y += 24;
            EditorGUI.ProgressBar(new Rect(0, y, 320, 24), progress, progress > 0 ? ("Downloading: " + (int)(progress * 100) + "%") : "Waiting for server...");
        }
        else if (isError)
        {
            EditorGUI.HelpBox(new Rect(0, y, 320, 40), errMsg, MessageType.Error);
        }
	}

    private static void Copy(string srcFolder, string destFolder)
    {
        var dir = new DirectoryInfo(srcFolder);
        if (!dir.Exists)
        {
            Debug.LogError("Can't find " + srcFolder);
            return;
        }

        Directory.CreateDirectory(destFolder);

        var files = dir.GetFiles();
        foreach (FileInfo file in files)
        {
            string tempPath = Path.Combine(destFolder, file.Name);
            file.CopyTo(tempPath, true);
        }

        var dirs = dir.GetDirectories();
        foreach (DirectoryInfo subdir in dirs)
        {
            string tempPath = Path.Combine(destFolder, subdir.Name);
            Copy(subdir.FullName, tempPath);

            Debug.Log("Copying " + tempPath);
        }
    }

    static void PatchAsk()
    {
        EditorApplication.update -= PatchAsk;

        if (Application.isPlaying) return;

        // Run only once when opening the editor (not when reloading scripts, changing between modes, etc)
        if (SessionState.GetBool("BakeryPatchWaitForRestart", false)) return;

        var cachePath = Directory.GetCurrentDirectory() + "/BakeryPatchCache";

        if (EditorUtility.DisplayDialog("Bakery", "Bakery patch was downloaded. Apply patch?", "Yes", "No"))
        {
            Copy(cachePath + "/Runtime", ftLightmaps.GetRuntimePath());
            Copy(cachePath + "/Editor", ftLightmaps.GetEditorPath());

            // Downloaded version -> current version
            if (File.Exists("bakery-csharp-dver.txt")) File.Copy("bakery-csharp-dver.txt", "bakery-csharp-cver.txt", true);
            if (File.Exists("bakery-compiled-dver.txt")) File.Copy("bakery-compiled-dver.txt", "bakery-compiled-cver.txt", true);
            if (File.Exists("bakery-rtpreview-csharp-dver.txt")) File.Copy("bakery-rtpreview-csharp-dver.txt", "bakery-rtpreview-csharp-cver.txt", true);
        }

        Directory.Delete(cachePath, true);

        AssetDatabase.Refresh();
    }

    static ftUpdater()
    {
        // Was the patch downloaded?
        var cachePath = Directory.GetCurrentDirectory() + "/BakeryPatchCache";
        if (!Directory.Exists(cachePath)) return;

        // Can't call everything in the constructor, continue there
        EditorApplication.update += PatchAsk;
    }
}

#endif
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftUpdater.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftUVGBufferGen.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 5d93843fab7110948a9eba95e82ced39
# ASMDEF: BakeryEditorAssembly.dll
# ---
#if UNITY_EDITOR

using UnityEngine;
using UnityEditor;
using System.IO;

public class ftUVGBufferGen
{
    static RenderTexture rtAlbedo, rtEmissive, rtNormal, rtAlpha;
    public static Texture2D texAlbedo, texEmissive, texNormal, texBestFit, texAlpha;
    //static GameObject dummyCamGO;
    //static Camera dummyCam;
    static float texelSize;
    //static Vector4 shaBlack, shaWhite;
    static Material matFromRGBM;
    static Material matDilate, matMultiply;
    static bool emissiveEnabled = false;
    static bool normalEnabled = false;
    static bool alphaEnabled = false;
    static Vector4 metaControl, metaControlAlbedo, metaControlEmission, metaControlNormal, metaControlAlpha;
    static Material fallbackMat, normalMat, blackMat;
    static int fallbackMatMetaPass;
    static BakeryProjectSettings pstorage;

    const int PASS_ALBEDO = 0;
    const int PASS_EMISSIVE = 1;
    const int PASS_NORMAL = 2;
    const int PASS_ALPHA = 3;
    const int PASS_COUNT = 4; // just a marker

    public static float[] uvOffset =
    {
        -2, -2,
        2, -2,
        -2, 2,
        2, 2,

        -1, -2,
        1, -2,
        -2, -1,
        2, -1,
        -2, 1,
        2, 1,
        -1, 2,
        1, 2,

        -2, 0,
        2, 0,
        0, -2,
        0, 2,

        -1, -1,
        1, -1,
        -1, 0,
        1, 0,
        -1, 1,
        1, 1,
        0, -1,
        0, 1,

        0, 0
    };

    static public void UpdateMatrix(Matrix4x4 worldMatrix, float offsetX, float offsetY)//Matrix4x4 worldMatrix)
    {
        // Generate a projection matrix similar to LoadOrtho
        /*var dummyCamGO = new GameObject();
        dummyCamGO.name = "dummyCam";
        var dummyCam = dummyCamGO.AddComponent<Camera>();
        dummyCam.cullingMask = 0;
        dummyCam.orthographic = true;
        dummyCam.orthographicSize = 0.5f;
        dummyCam.nearClipPlane = -10;
        dummyCam.aspect = 1;
        var proj = dummyCam.projectionMatrix;
        var c3 = proj.GetColumn(3);
        proj.SetColumn(3, new Vector4(-1, -1, c3.z, c3.w));
        Debug.Log(proj);*/

        var proj = new Matrix4x4();
        proj.SetRow(0, new Vector4(2.00000f,  0.00000f, 0.00000f, -1.00000f + offsetX));
        proj.SetRow(1, new Vector4(0.00000f,  2.00000f, 0.00000f, -1.00000f + offsetY));
        proj.SetRow(2, new Vector4(0.00000f,  0.00000f, -0.00198f,    -0.98f));
        proj.SetRow(3, new Vector4(0.00000f,  0.00000f, 0.00000f, 1.00000f));

        //if (ftBuildGraphics.unityVersionMajor < 2018) // Unity 2018 stopped multiplying vertices by world matrix in meta pass
        //{
#if UNITY_2018_1_OR_NEWER
#else
            proj = proj * worldMatrix.inverse;
#endif
        //}

        // If Camera.current is set, multiply our matrix by the inverse of its view matrix
        if (Camera.current != null)
        {
            proj = proj * Camera.current.worldToCameraMatrix.inverse;
        }

        GL.LoadProjectionMatrix(proj);
    }

    static public void StartUVGBuffer(int size, bool hasEmissive, bool hasNormal)
    {
        emissiveEnabled = hasEmissive;
        normalEnabled = hasNormal;
        alphaEnabled = false;

        rtAlbedo = new RenderTexture(size, size, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.sRGB);
        texAlbedo = new Texture2D(size, size, TextureFormat.RGBA32, false, false);

        Graphics.SetRenderTarget(rtAlbedo);
        GL.Clear(true, true, new Color(0,0,0,0));

        if (hasEmissive)
        {
            rtEmissive = new RenderTexture(size, size, 0, RenderTextureFormat.ARGBHalf, RenderTextureReadWrite.Linear);
            texEmissive = new Texture2D(size, size, TextureFormat.RGBAHalf, false, true);
            Graphics.SetRenderTarget(rtEmissive);
            GL.Clear(true, true, new Color(0,0,0,0));
        }

        if (hasNormal)
        {
            rtNormal = new RenderTexture(size, size, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
            texNormal = new Texture2D(size, size, TextureFormat.RGBA32, false, true);
            Graphics.SetRenderTarget(rtNormal);
            GL.Clear(true, true, new Color(0,0,0,0));
        }

        //GL.sRGBWrite = true;//!hasEmissive;
        GL.invertCulling = false;
        GL.PushMatrix();
        //GL.LoadOrtho();
        //UpdateMatrix();
        /*float ambR, ambG, ambB;
        //ambR = ambG = ambB = emissiveOnly ? 0 : 1;
        Shader.SetGlobalVector("unity_SHBr", Vector4.zero);
        Shader.SetGlobalVector("unity_SHBg", Vector4.zero);
        Shader.SetGlobalVector("unity_SHBb", Vector4.zero);
        Shader.SetGlobalVector("unity_SHC", Vector4.zero);*/
        texelSize = (1.0f / size) / 5;
        //shaBlack = new Vector4(0,0,0,0);
        //shaWhite = new Vector4(0,0,0,1);
        metaControl = new Vector4(1,0,0,0);
        metaControlAlbedo = new Vector4(1,0,0,0);
        metaControlEmission = new Vector4(0,1,0,0);
        metaControlNormal = new Vector4(0,0,1,0);
        metaControlAlpha = new Vector4(0,0,0,1);
        Shader.SetGlobalVector("unity_MetaVertexControl", metaControl);
        Shader.SetGlobalFloat("unity_OneOverOutputBoost", 1.0f);
        Shader.SetGlobalFloat("unity_MaxOutputValue", 10000000.0f);
        Shader.SetGlobalFloat("unity_UseLinearSpace", PlayerSettings.colorSpace == ColorSpace.Linear ? 1.0f : 0.0f);
    }

    static public void InitAlphaBuffer(int size)
    {
        alphaEnabled = true;
        rtAlpha = new RenderTexture(size, size, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
        rtAlpha.name = "BakeryRTAlpha";
        texAlpha = new Texture2D(size, size, TextureFormat.RGBA32, false, true);
        texAlpha.name = "BakeryTexAlpha";
        Graphics.SetRenderTarget(rtAlpha);
        GL.Clear(true, true, new Color(0,0,0,0));
    }

    static public void RenderUVGBuffer(Mesh mesh, Renderer renderer, Vector4 scaleOffset, Transform worldTransform, bool vertexBake,
        Vector2[] uvOverride, bool terrainNormals = false, bool metaAlpha = false)
    {
        var worldMatrix = worldTransform.localToWorldMatrix;

        if (pstorage == null) pstorage = ftLightmaps.GetProjectSettings();

        if (metaAlpha && !alphaEnabled)
        {
            int res = rtAlbedo.width * pstorage.alphaMetaPassResolutionMultiplier;
            if (res > 8192) res = 8192;
            InitAlphaBuffer(res);
        }

        Material[] materials = renderer.sharedMaterials;
#if SUPPORT_MBLOCKS
        var mb = new MaterialPropertyBlock();
#endif

        var m = mesh;
        if (uvOverride != null)
        {
            m = Mesh.Instantiate(mesh);
            //var uvs = m.uv2;
            //if (uvs.Length == 0) uvs = m.uv;
            //var pos = new Vector3[uvs.Length];
            /*for(int i=0; i<uvs.Length; i++)
            {
                pos[i] = new Vector3(uvs[i].x * scaleOffset.x + scaleOffset.z, uvs[i].y * scaleOffset.y + scaleOffset.w, 0.0f);
            }
            m.vertices = pos;*/

            m.uv2 = uvOverride;

            if (vertexBake)
            {
                for(int i=0; i<mesh.subMeshCount; i++)
                {
                    var indices = m.GetIndices(i);
                    m.SetIndices(indices, MeshTopology.Points, i, false);
                }
            }
        }

        //var scaleOffsetFlipped = new Vector4(scaleOffset.x, -scaleOffset.y, scaleOffset.z, 1.0f - scaleOffset.w);

        //UpdateMatrix(worldMatrix);

        for(int pass=0; pass<PASS_COUNT; pass++)
        {
            if (pass == PASS_EMISSIVE && !emissiveEnabled) continue;
            if (pass == PASS_NORMAL && !normalEnabled) continue;
            if (pass == PASS_ALPHA && !alphaEnabled) continue; // per Start-End
            if (pass == PASS_ALPHA && !metaAlpha) continue; // per this object

            if (pass == PASS_ALBEDO)
            {
                Graphics.SetRenderTarget(rtAlbedo);
            }
            else if (pass == PASS_EMISSIVE)
            {
                Graphics.SetRenderTarget(rtEmissive);
            }
            else if (pass == PASS_NORMAL)
            {
                Graphics.SetRenderTarget(rtNormal);
            }
            else if (pass == PASS_ALPHA)
            {
                Graphics.SetRenderTarget(rtAlpha);
            }

            for(int i=0; i<mesh.subMeshCount; i++)
            {
                if (materials.Length <= i) break;
                if (materials[i] ==  null) continue;
                if (materials[i].shader ==  null) continue;

                // Optionally skip emission
                bool passAsBlack = (pass == PASS_EMISSIVE && materials[i].globalIlluminationFlags != MaterialGlobalIlluminationFlags.BakedEmissive);

                var rpTag = materials[i].GetTag("RenderPipeline", true, "");
                bool isHDRP = rpTag == "HDRenderPipeline";
                if (pass >= PASS_NORMAL) isHDRP = false; // custom meta shaders are not affected
                int bakeryPass = -1;

                if (pass < PASS_NORMAL)
                {
                    int metaPass = -1;
                    if (!materials[i].HasProperty("BAKERY_FORCE_NO_META"))
                    {
                        if (!passAsBlack)
                        {
                            metaPass = materials[i].FindPass("META");
                            if (metaPass < 0)
                            {
                                // Try finding another pass pass with "META" in it
                                for(int mpass=0; mpass<materials[i].passCount; mpass++)
                                {
                                    if (materials[i].GetPassName(mpass).IndexOf("META") >= 0)
                                    {
                                        metaPass = mpass;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    Shader.SetGlobalVector("unity_LightmapST", scaleOffset);//(isHDRP) ? scaleOffsetFlipped : scaleOffset);
                    Shader.SetGlobalVector("unity_MetaFragmentControl", pass == PASS_ALBEDO ? metaControlAlbedo : metaControlEmission);

                    if (metaPass >= 0)
                    {
                        materials[i].SetPass(metaPass);
                    }
                    else
                    {
                        if (passAsBlack)
                        {
                            if (blackMat == null)
                            {
                                blackMat = new Material(Shader.Find("Hidden/ftBlack"));
                            }
                            Shader.SetGlobalVector("unity_LightmapST", scaleOffset);
                            blackMat.SetPass(0);
                        }
                        else
                        {
                            if (fallbackMat == null)
                            {
                                fallbackMat = new Material(Shader.Find("Standard"));
                                fallbackMat.EnableKeyword("_EMISSION");
                                fallbackMatMetaPass = fallbackMat.FindPass("META");
                            }
                            if ((pstorage.logLevel & (int)BakeryProjectSettings.LogLevel.Warning) != 0)
                            {
                                if (materials[i].name != "Hidden/ftFarSphere")
                                {
                                    Debug.LogWarning("Material " + materials[i].name + " doesn't have meta pass - maps are taken by name");
                                }
                            }
                            if (materials[i].HasProperty("_MainTex"))
                            {
                                fallbackMat.mainTexture = materials[i].GetTexture("_MainTex");
                            }
                            else if (materials[i].HasProperty("_BaseColorMap"))
                            {
                                // HDRP
                                fallbackMat.mainTexture = materials[i].GetTexture("_BaseColorMap");
                            }
                            else if (materials[i].HasProperty("_BaseMap"))
                            {
                                // URP
                                fallbackMat.mainTexture = materials[i].GetTexture("_BaseMap");
                            }
                            if (materials[i].HasProperty("_Color"))
                            {
                                fallbackMat.SetVector("_Color", materials[i].GetVector("_Color"));
                            }
                            else
                            {
                                fallbackMat.SetVector("_Color", Color.white);
                            }
                            if (materials[i].HasProperty("_EmissionMap"))
                            {
                                fallbackMat.SetTexture("_EmissionMap", materials[i].GetTexture("_EmissionMap"));
                            }
                            else
                            {
                                fallbackMat.SetTexture("_EmissionMap", null);
                            }
                            if (materials[i].HasProperty("_EmissionColor"))
                            {
                                fallbackMat.SetVector("_EmissionColor", materials[i].GetVector("_EmissionColor"));
                            }
                            else
                            {
                                fallbackMat.SetVector("_EmissionColor", Color.black);
                            }
                            fallbackMat.SetPass(fallbackMatMetaPass);
                        }
                    }
                }
                else if (pass == PASS_NORMAL)
                {
                    bool isURP = rpTag == "UniversalPipeline";

                    var metaPass = materials[i].FindPass("META_BAKERY");
                    bakeryPass = metaPass;

                    if (normalMat == null && metaPass < 0)
                    {
                        normalMat = new Material(Shader.Find("Hidden/ftUVNormalMap"));
                    }
                    if (texBestFit == null)
                    {
                        texBestFit = new Texture2D(1024, 1024, TextureFormat.RGBA32, false, true);
                        var edPath = ftLightmaps.GetEditorPath();
                        var fbestfit = new BinaryReader(File.Open(edPath + "NormalsFittingTexture_dds", FileMode.Open, FileAccess.Read));
                        fbestfit.BaseStream.Seek(128, SeekOrigin.Begin);
                        var bytes = fbestfit.ReadBytes(1024 * 1024 * 4);
                        fbestfit.Close();
                        texBestFit.LoadRawTextureData(bytes);
                        texBestFit.Apply();
                    }

                    if (metaPass < 0)
                    {
                        if (materials[i].HasProperty("_BumpMap"))
                        {
                            normalMat.SetTexture("_BumpMap", materials[i].GetTexture("_BumpMap"));
                            if (materials[i].HasProperty("_MainTex_ST"))
                            {
                                normalMat.SetVector("_BumpMap_scaleOffset", materials[i].GetVector("_MainTex_ST"));
                                //Debug.LogError(materials[i].GetVector("_MainTex_ST"));
                            }
                            else
                            {
                                normalMat.SetVector("_BumpMap_scaleOffset", new Vector4(1,1,0,0));
                            }
                        }
                        else if (materials[i].HasProperty("_NormalMap"))
                        {
                            normalMat.SetTexture("_BumpMap", materials[i].GetTexture("_NormalMap"));
                            normalMat.SetVector("_BumpMap_scaleOffset", new Vector4(1,1,0,0));
                        }
                        else
                        {
                            normalMat.SetTexture("_BumpMap", null);
                        }
                        normalMat.SetFloat("_IsTerrain", terrainNormals ? 1.0f : 0.0f);
                        normalMat.SetTexture("bestFitNormalMap", texBestFit);
                        normalMat.SetFloat("_IsPerPixel", (isURP||isHDRP) ? 1.0f : 0.0f);
                        normalMat.SetPass(0);
                    }
                    else
                    {
                        materials[i].SetTexture("bestFitNormalMap", texBestFit);
                        materials[i].SetFloat("_IsPerPixel", (isURP||isHDRP) ? 1.0f : 0.0f);
                        materials[i].SetPass(metaPass);
                    }
                    Shader.SetGlobalVector("unity_MetaFragmentControl", metaControlNormal);
                }
                else if (pass == PASS_ALPHA)
                {
                    // Unity does not output alpha in its meta pass, so only custom shaders are supported
                    var metaPass = materials[i].FindPass("META_BAKERY");
                    if (metaPass < 0)
                    {
                        Debug.LogError("BAKERY_META_ALPHA_ENABLE is set, but there is no META_BAKERY pass in " + materials[i].name);
                        continue;
                    }
                    bakeryPass = metaPass;
                    materials[i].SetPass(metaPass);
                    Shader.SetGlobalVector("unity_MetaFragmentControl", metaControlAlpha);
                }

                GL.sRGBWrite = pass == PASS_ALBEDO;

                if (!vertexBake)
                {
                    for(int j=0; j<uvOffset.Length/2; j++)
                    {
                        if (pass < PASS_NORMAL)
                        {
                            UpdateMatrix(worldMatrix, uvOffset[j*2] * texelSize, uvOffset[j*2+1] * texelSize);
                        }
                        else
                        {
                            // TODO: use in HDRP as well
                            var srcVec = scaleOffset;//(isHDRP) ? scaleOffsetFlipped : scaleOffset;
                            var vec = new Vector4(srcVec.x, srcVec.y, srcVec.z + uvOffset[j*2] * texelSize, srcVec.w + uvOffset[j*2+1] * texelSize);
                            Shader.SetGlobalVector("unity_LightmapST", vec);
                            if (bakeryPass >= 0)
                            {
                                materials[i].SetPass(bakeryPass);
                            }
                            else
                            {
                                var s = worldTransform.lossyScale;
                                bool isFlipped = Mathf.Sign(s.x*s.y*s.z) < 0;
                                normalMat.SetFloat("_IsFlipped", isFlipped ? -1.0f : 1.0f);
                                normalMat.SetPass(0);
                            }
                        }
                        Graphics.DrawMeshNow(m, worldMatrix, i);
                    }
                }
                else
                {
                    UpdateMatrix(worldMatrix, 0, 0);
#if SUPPORT_MBLOCKS
    #if UNITY_2018_1_OR_NEWER
                    renderer.GetPropertyBlock(mb, i);
    #else
                    renderer.GetPropertyBlock(mb);
    #endif
                    Graphics.DrawMesh(m, worldMatrix, materials[i], 0, null, i, mb, false, false, false);
#else
                    Graphics.DrawMeshNow(m, worldMatrix, i);
#endif
                }
            }
        }
    }

    static public void EndUVGBuffer()
    {
        GL.PopMatrix();

        Graphics.SetRenderTarget(rtAlbedo);
        texAlbedo.ReadPixels(new Rect(0,0,rtAlbedo.width,rtAlbedo.height), 0, 0, false);
        texAlbedo.Apply();
        Graphics.SetRenderTarget(null);
        rtAlbedo.Release();

        if (emissiveEnabled)
        {
            Graphics.SetRenderTarget(rtEmissive);
            texEmissive.ReadPixels(new Rect(0,0,rtEmissive.width,rtEmissive.height), 0, 0, false);
            texEmissive.Apply();
            Graphics.SetRenderTarget(null);
            rtEmissive.Release();
        }

        if (normalEnabled)
        {
            Graphics.SetRenderTarget(rtNormal);
            texNormal.ReadPixels(new Rect(0,0,rtNormal.width,rtNormal.height), 0, 0, false);
            texNormal.Apply();
            Graphics.SetRenderTarget(null);
            rtNormal.Release();
        }

        if (alphaEnabled)
        {
            Graphics.SetRenderTarget(rtAlpha);
            texAlpha.ReadPixels(new Rect(0,0,rtAlpha.width,rtAlpha.height), 0, 0, false);
            texAlpha.Apply();
            Graphics.SetRenderTarget(null);
            rtAlpha.Release();
            rtAlpha = null;
        }
    }

    static public Texture2D DecodeFromRGBM(Texture2D emissive)
    {
        var rt = new RenderTexture(emissive.width, emissive.height, 0, RenderTextureFormat.ARGBHalf, RenderTextureReadWrite.Linear);
        var tex = new Texture2D(emissive.width, emissive.height, TextureFormat.RGBAHalf, false, true);

        if (matFromRGBM == null) matFromRGBM = new Material(Shader.Find("Hidden/ftRGBM2Half"));

        Graphics.SetRenderTarget(rt);
        GL.sRGBWrite = false;

        matFromRGBM.SetTexture("_MainTex", emissive);

        Graphics.Blit(emissive, rt, matFromRGBM);

        tex.ReadPixels(new Rect(0,0,rt.width,rt.height), 0, 0, false);
        tex.Apply();

        Graphics.SetRenderTarget(null);
        rt.Release();
        Object.DestroyImmediate(emissive);

        return tex;
    }

    static public void Dilate(Texture2D albedo, int pass = 0)
    {
        if (matDilate == null) matDilate = new Material(Shader.Find("Hidden/ftDilate"));

        RenderTexture rt, rt2;
        if (albedo.format == TextureFormat.RGBA32)
        {
            rt = new RenderTexture(albedo.width, albedo.height, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.sRGB);
            rt2 = new RenderTexture(albedo.width, albedo.height, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.sRGB);
        }
        else
        {
            rt = new RenderTexture(albedo.width, albedo.height, 0, RenderTextureFormat.ARGBHalf, RenderTextureReadWrite.Linear);
            rt2 = new RenderTexture(albedo.width, albedo.height, 0, RenderTextureFormat.ARGBHalf, RenderTextureReadWrite.Linear);
        }

        GL.sRGBWrite = albedo.format == TextureFormat.RGBA32;
        Graphics.Blit(albedo, rt, matDilate, pass);

        for(int i=0; i<8; i++)
        {
            Graphics.Blit(rt, rt2, matDilate, pass);
            Graphics.Blit(rt2, rt, matDilate, pass);
        }

        Graphics.SetRenderTarget(rt);
        albedo.ReadPixels(new Rect(0,0,rt.width,rt.height), 0, 0, false);
        albedo.Apply();

        Graphics.SetRenderTarget(null);
        rt.Release();
        rt2.Release();
    }

    static public void Multiply(Texture2D albedo, float val)
    {
        if (matMultiply == null) matMultiply = new Material(Shader.Find("Hidden/ftMultiply"));

        RenderTexture rt;
        if (albedo.format == TextureFormat.RGBA32)
        {
            rt = new RenderTexture(albedo.width, albedo.height, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.sRGB);
        }
        else
        {
            rt = new RenderTexture(albedo.width, albedo.height, 0, RenderTextureFormat.ARGBHalf, RenderTextureReadWrite.Linear);
        }

        GL.sRGBWrite = albedo.format == TextureFormat.RGBA32;
        matMultiply.SetFloat("multiplier", val);
        Graphics.Blit(albedo, rt, matMultiply);

        Graphics.SetRenderTarget(rt);
        albedo.ReadPixels(new Rect(0,0,rt.width,rt.height), 0, 0, false);
        albedo.Apply();

        Graphics.SetRenderTarget(null);
        rt.Release();
    }
}

#endif
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftUVGBufferGen.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftVolumeInspector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 96725c7b01d15304c92894c9b78b76d4
# ASMDEF: BakeryEditorAssembly.dll
# ---
// Disable 'obsolete' warnings
#pragma warning disable 0618

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.IMGUI.Controls;
#endif

#if UNITY_EDITOR
[CustomEditor(typeof(BakeryVolume))]
public class BakeryVolumeInspector : Editor
{
    BoxBoundsHandle boundsHandle = new BoxBoundsHandle(typeof(BakeryVolumeInspector).GetHashCode());

    SerializedProperty ftraceAdaptiveRes, ftraceResX, ftraceResY, ftraceResZ, ftraceVoxelsPerUnit, ftraceAdjustSamples, ftraceEnableBaking, ftraceEncoding, ftraceShadowmaskEncoding, ftraceShadowmaskFirstLightIsAlwaysAlpha, ftraceDenoise, ftraceGlobal, ftraceRotation;

    bool showExperimental = false;

    ftLightmapsStorage storage;

    static BakeryProjectSettings pstorage;

    void OnEnable()
    {
        ftraceAdaptiveRes = serializedObject.FindProperty("adaptiveRes");
        ftraceVoxelsPerUnit = serializedObject.FindProperty("voxelsPerUnit");
        ftraceResX = serializedObject.FindProperty("resolutionX");
        ftraceResY = serializedObject.FindProperty("resolutionY");
        ftraceResZ = serializedObject.FindProperty("resolutionZ");
        ftraceEnableBaking = serializedObject.FindProperty("enableBaking");
        ftraceEncoding = serializedObject.FindProperty("encoding");
        ftraceShadowmaskEncoding = serializedObject.FindProperty("shadowmaskEncoding");
        ftraceShadowmaskFirstLightIsAlwaysAlpha = serializedObject.FindProperty("firstLightIsAlwaysAlpha");
        ftraceDenoise = serializedObject.FindProperty("denoise");
        ftraceGlobal = serializedObject.FindProperty("isGlobal");
        ftraceRotation = serializedObject.FindProperty("supportRotationAfterBake");
        //ftraceAdjustSamples = serializedObject.FindProperty("adjustSamples");
    }

    string F(float f)
    {
        // Unity keeps using comma for float printing on some systems since ~2018, even if system-wide decimal symbol is "."
        return (f + "").Replace(",", ".");
    }

    string FormatSize(int b)
    {
        float mb = b / (float)(1024*1024);
        return mb.ToString("0.0");
    }

    public override void OnInspectorGUI()
    {
        serializedObject.Update();
        var vol = target as BakeryVolume;

        if (pstorage == null) pstorage = ftLightmaps.GetProjectSettings();

        EditorGUILayout.PropertyField(ftraceEnableBaking, new GUIContent("Enable baking", "Should the volume be (re)computed? Disable to prevent overwriting existing data."));
        bool wasGlobal = ftraceGlobal.boolValue;
        EditorGUILayout.PropertyField(ftraceGlobal, new GUIContent("Global", "Automatically assign this volume to all volume-compatible shaders, unless they have overrides."));
        if (!wasGlobal && ftraceGlobal.boolValue)
        {
            (target as BakeryVolume).SetGlobalParams();
        }
        EditorGUILayout.PropertyField(ftraceDenoise, new GUIContent("Denoise", "Apply denoising after baking the volume."));
        EditorGUILayout.Space();

        EditorGUILayout.PropertyField(ftraceAdaptiveRes, new GUIContent("Adaptive resolution", "Calculate voxel resolution based on size?"));
        if (ftraceAdaptiveRes.boolValue)
        {
            EditorGUILayout.PropertyField(ftraceVoxelsPerUnit, new GUIContent("Voxels per unit"));

            GUI.enabled = false;
            var size = vol.bounds.size;
            ftraceResX.intValue = System.Math.Max((int)(size.x * vol.voxelsPerUnit), 1);
            ftraceResY.intValue = System.Math.Max((int)(size.y * vol.voxelsPerUnit), 1);
            ftraceResZ.intValue = System.Math.Max((int)(size.z * vol.voxelsPerUnit), 1);
        }
        EditorGUILayout.PropertyField(ftraceResX, new GUIContent("Resolution X"));
        EditorGUILayout.PropertyField(ftraceResY, new GUIContent("Resolution Y"));
        EditorGUILayout.PropertyField(ftraceResZ, new GUIContent("Resolution Z"));
        if (ftraceResX.intValue < 1) ftraceResX.intValue = 1;
        if (ftraceResY.intValue < 1) ftraceResY.intValue = 1;
        if (ftraceResZ.intValue < 1) ftraceResZ.intValue = 1;
        GUI.enabled = true;

        EditorGUILayout.Space();
        if (storage == null) storage = ftRenderLightmap.FindRenderSettingsStorage();
        var rmode = storage.renderSettingsUserRenderMode;
        int sizeX = ftRenderLightmap.VolumeDimension(ftraceResX.intValue);
        int sizeY = ftRenderLightmap.VolumeDimension(ftraceResY.intValue);
        int sizeZ = ftRenderLightmap.VolumeDimension(ftraceResZ.intValue);
        int vSize = 0;
        if (storage.renderSettingsCompressVolumes)
        {
            const int blockDimension = 4;
            const int blockByteSize = 16; // both BC6H and BC7
            int numBlocks = (sizeX/blockDimension) * (sizeY/blockDimension);
            vSize = numBlocks * blockByteSize * sizeZ * 4;
        }
        else
        {
            vSize = sizeX*sizeY*sizeZ*8*3;
        }
        string note = "VRAM: " + FormatSize(vSize) + " MB " + (storage.renderSettingsCompressVolumes ? "(compressed color)" : "(color)");
        if (rmode == (int)ftRenderLightmap.RenderMode.Shadowmask || pstorage.volumeRenderMode == (int)BakeryLightmapGroup.RenderMode.Shadowmask)
        {
            note += ", " + FormatSize(sizeX*sizeY*sizeZ * (ftraceShadowmaskEncoding.intValue == 0 ? 4 : 1)) + " MB (mask)";
        }
        EditorGUILayout.LabelField(note);

        //EditorGUILayout.PropertyField(ftraceAdjustSamples, new GUIContent("Adjust sample positions", "Fixes light leaking from inside surfaces"));

        EditorGUILayout.Space();

        showExperimental = EditorGUILayout.Foldout(showExperimental, "Experimental", EditorStyles.foldout);
        if (showExperimental)
        {
            EditorGUILayout.PropertyField(ftraceEncoding, new GUIContent("Encoding"));
            EditorGUILayout.PropertyField(ftraceShadowmaskEncoding, new GUIContent("Shadowmask Encoding"));
            EditorGUILayout.PropertyField(ftraceShadowmaskFirstLightIsAlwaysAlpha, new GUIContent("First light uses Alpha", "In RGBA8 mode, the first light will always be in the alpha channel. This is useful when unifying RGBA8 and A8 volumes, as the main/first light is always in the same channel."));

            bool wasSet = ftraceRotation.boolValue;
            EditorGUILayout.PropertyField(ftraceRotation, new GUIContent("Support rotation after bake", "Normally volumes can only be repositioned or rescaled at runtime. With this checkbox volume's rotation matrix will also be sent to shaders. Shaders must have a similar checkbox enabled."));
            if (wasSet != ftraceRotation.boolValue)
            {
                (target as BakeryVolume).SetGlobalParams();
            }
        }

        EditorGUILayout.Space();

        if (vol.bakedTexture0 == null)
        {
            EditorGUILayout.LabelField("Baked texture: none");
        }
        else
        {
            EditorGUILayout.LabelField("Baked texture: " + vol.bakedTexture0.name);
        }

        EditorGUILayout.Space();

        var wrapObj = EditorGUILayout.ObjectField("Wrap to object", null, typeof(GameObject), true) as GameObject;
        if (wrapObj != null)
        {
            var mrs = wrapObj.GetComponentsInChildren<MeshRenderer>() as MeshRenderer[];
            if (mrs.Length > 0)
            {
                var b = mrs[0].bounds;
                for(int i=1; i<mrs.Length; i++)
                {
                    b.Encapsulate(mrs[i].bounds);
                }
                Undo.RecordObject(vol, "Change Bounds");
                Undo.RecordObject(vol.transform, "Change Bounds");
                vol.transform.position = b.center;
                vol.bounds = b;
                Debug.Log("Bounds set");
            }
            else
            {
                Debug.LogError("No mesh renderers to wrap to");
            }
        }

        var boxCol = vol.GetComponent<BoxCollider>();
        if (boxCol != null)
        {
            if (GUILayout.Button("Set from box collider"))
            {
                Undo.RecordObject(vol, "Change Bounds");
                vol.bounds = boxCol.bounds;
            }
            if (GUILayout.Button("Set to box collider"))
            {
                boxCol.center = Vector3.zero;
                boxCol.size = vol.bounds.size;
            }
        }

        var bmin = vol.bounds.min;
        var bmax = vol.bounds.max;
        var bsize = vol.bounds.size;
        EditorGUILayout.LabelField("Min: " + bmin.x+", "+bmin.y+", "+bmin.z);
        EditorGUILayout.LabelField("Max: " + bmax.x+", "+bmax.y+", "+bmax.z);

        if (GUILayout.Button("Copy bounds to clipboard"))
        {
            GUIUtility.systemCopyBuffer = "float3 bmin = float3(" + F(bmin.x)+", "+F(bmin.y)+", "+F(bmin.z) + "); float3 bmax = float3(" + F(bmax.x)+", "+F(bmax.y)+", "+F(bmax.z) + "); float3 binvsize = float3(" + F(1.0f/bsize.x)+", "+F(1.0f/bsize.y)+", "+F(1.0f/bsize.z) + ");";
        }

        serializedObject.ApplyModifiedProperties();
    }

    protected virtual void OnSceneGUI()
    {
        var vol = (BakeryVolume)target;

        boundsHandle.center = vol.transform.position;
        boundsHandle.size = vol.bounds.size;
        Handles.zTest = UnityEngine.Rendering.CompareFunction.Less;

        EditorGUI.BeginChangeCheck();
        boundsHandle.DrawHandle();
        if (EditorGUI.EndChangeCheck())
        {
            Undo.RecordObject(vol, "Change Bounds");
            Undo.RecordObject(vol.transform, "Change Bounds");

            Bounds newBounds = new Bounds();
            newBounds.center = boundsHandle.center;
            newBounds.size = boundsHandle.size;
            vol.bounds = newBounds;
            vol.transform.position = boundsHandle.center;
        }
        else if ((vol.bounds.center - boundsHandle.center).sqrMagnitude > 0.0001f)
        {
            Bounds newBounds = new Bounds();
            newBounds.center = boundsHandle.center;
            newBounds.size = boundsHandle.size;
            vol.bounds = newBounds;
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/ftVolumeInspector.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/xatlas/xatlas.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 144aa3fbdb8360b4aaa4051032c25680
# ASMDEF: BakeryEditorAssembly.dll
# ---
using UnityEngine;
using UnityEditor;
using UnityEditor.SceneManagement;
using System.Collections.Generic;
using System.Runtime.InteropServices;

public class xatlas
{
    //#define UV_HINT

    public static List<Vector2> newUVBuffer;
    public static List<int> newXrefBuffer;

    [DllImport ("xatlasLib", CallingConvention=CallingConvention.Cdecl)]
    public static extern System.IntPtr xatlasCreateAtlas();

    [DllImport ("xatlasLib", CallingConvention=CallingConvention.Cdecl)]
    public static extern int xatlasAddMesh(System.IntPtr atlas, int vertexCount, System.IntPtr positions, System.IntPtr normals, System.IntPtr uv, int indexCount, int[] indices32);

    [DllImport ("xatlasLib", CallingConvention=CallingConvention.Cdecl)]
    public static extern int xatlasAddUVMesh(System.IntPtr atlas, int vertexCount, System.IntPtr uv, int indexCount, int[] indices32, bool allowRotate);

    [DllImport ("xatlasLib", CallingConvention=CallingConvention.Cdecl)]
    public static extern void xatlasParametrize(System.IntPtr atlas);

    [DllImport ("xatlasLib", CallingConvention=CallingConvention.Cdecl)]
    public static extern void xatlasPack(System.IntPtr atlas, int attempts, float texelsPerUnit, int resolution, int maxChartSize, int padding, bool bruteForce, bool blockAlign);//, bool allowRotate);

    [DllImport ("xatlasLib", CallingConvention=CallingConvention.Cdecl)]
    public static extern void xatlasNormalize(System.IntPtr atlas, int[] atlasSizes, bool preferDensity);

    [DllImport ("xatlasLib", CallingConvention=CallingConvention.Cdecl)]
    public static extern int xatlasGetAtlasCount(System.IntPtr atlas);

    [DllImport ("xatlasLib", CallingConvention=CallingConvention.Cdecl)]
    public static extern int xatlasGetAtlasIndex(System.IntPtr atlas, int meshIndex, int chartIndex);

    [DllImport ("xatlasLib", CallingConvention=CallingConvention.Cdecl)]
    public static extern int xatlasGetVertexCount(System.IntPtr atlas, int meshIndex);

    [DllImport ("xatlasLib", CallingConvention=CallingConvention.Cdecl)]
    public static extern int xatlasGetIndexCount(System.IntPtr atlas, int meshIndex);

    [DllImport ("xatlasLib", CallingConvention=CallingConvention.Cdecl)]
    public static extern void xatlasGetData(System.IntPtr atlas, int meshIndex, System.IntPtr outUV, System.IntPtr outRef, System.IntPtr outIndices);

    [DllImport ("xatlasLib", CallingConvention=CallingConvention.Cdecl)]
    public static extern int xatlasClear(System.IntPtr atlas);

    static T[] FillAtrribute<T>(List<int> xrefArray, T[] origArray)
    {
        if (origArray == null || origArray.Length == 0) return origArray;

        var arr = new T[xrefArray.Count];
        for(int i=0; i<xrefArray.Count; i++)
        {
            int xref = xrefArray[i];
            arr[i] = origArray[xref];
        }
        return arr;

        /*
        var finalAttr = new T[vertCount + xrefCount];
        for(int i=0; i<vertCount; i++) finalAttr[i] = origArray[i];
        for(int i=0; i<xrefCount; i++) finalAttr[i + vertCount] = origArray[ xrefArray[i] ];
        return finalAttr;
        */
    }

    public static double GetTime()
    {
        return (System.DateTime.Now.Ticks / System.TimeSpan.TicksPerMillisecond) / 1000.0;
    }

    public static void Unwrap(Mesh m, UnwrapParam uparams)
    {
        //EditorUtility.DisplayDialog("Bakery", "xatlas start", "OK");
        int padding = (int)(uparams.packMargin*1024);
        //Debug.Log("xatlas! " + padding);

        newUVBuffer = null;
        newXrefBuffer = null;

        var t = GetTime();

        var positions = m.vertices;
        var normals = m.normals;
        var existingUV = m.uv;
        var handlePos = GCHandle.Alloc(positions, GCHandleType.Pinned);
        var handleNorm = GCHandle.Alloc(normals, GCHandleType.Pinned);
        var handleUV = GCHandle.Alloc(existingUV, GCHandleType.Pinned);
        int err = 0;

        var atlas = xatlasCreateAtlas();

        //EditorUtility.DisplayDialog("Bakery", "xatlas created", "OK");

        try
        {
            var pointerPos = handlePos.AddrOfPinnedObject();
            var pointerNorm = handleNorm.AddrOfPinnedObject();

#if UV_HINT
            var pointerUV = handleUV.AddrOfPinnedObject();
#else
            var pointerUV = (System.IntPtr)0;
#endif

            for(int i=0; i<m.subMeshCount; i++)
            {
                err = xatlasAddMesh(atlas, m.vertexCount, pointerPos, pointerNorm, pointerUV, (int)m.GetIndexCount(i), m.GetIndices(i));
                if (err == 1)
                {
                    Debug.LogError("xatlas::AddMesh: indices are out of range");
                }
                else if (err == 2)
                {
                    Debug.LogError("xatlas::AddMesh: index count is incorrect");
                }
                else if (err != 0)
                {
                    Debug.LogError("xatlas::AddMesh: unknown error");
                }
                if (err != 0) break;
            }
            //EditorUtility.DisplayDialog("Bakery", "xatlas added", "OK");
            if (err == 0)
            {
                xatlasParametrize(atlas);
                //EditorUtility.DisplayDialog("Bakery", "xatlas param done", "OK");

                xatlasPack(atlas, 4096, 0, 0, 1024, padding, false, true);//, true);
                //EditorUtility.DisplayDialog("Bakery", "xatlas pack done", "OK");
            }
        }
        finally
        {
            if (handlePos.IsAllocated) handlePos.Free();
            if (handleNorm.IsAllocated) handleNorm.Free();
            if (handleUV.IsAllocated) handleUV.Free();
        }
        if (err != 0)
        {
            //EditorUtility.DisplayDialog("Bakery", "xatlas cancel", "OK");
            xatlasClear(atlas);
            return;
        }

        Debug.Log("xatlas time: " + (GetTime() - t));
        t = GetTime();

        //EditorUtility.DisplayDialog("Bakery", "xatlas unwrap start", "OK");
        //var uv2 = new Vector2[m.vertexCount];
        //int vertexOffset = m.vertexCount;
        //var newUV2 = new List<Vector2>();
        //var newXref = new List<int>();
        var indexBuffers = new List<int[]>();

        newUVBuffer = new List<Vector2>();
        newXrefBuffer = new List<int>();
        while(newUVBuffer.Count < m.vertexCount)
        {
            newUVBuffer.Add(new Vector2(-100, -100));
            newXrefBuffer.Add(0);
        }

        xatlasNormalize(atlas, null, false);

        // Collect UVs/xrefs/indices
        for(int i=0; i<m.subMeshCount; i++)
        {
            // Get data from xatlas
            int newVertCount = xatlasGetVertexCount(atlas, i);
            int indexCount = xatlasGetIndexCount(atlas, i); // should be unchanged

            var uvBuffer = new Vector2[newVertCount];
            var xrefBuffer = new int[newVertCount];
            var indexBuffer = new int[indexCount];

            var handleT = GCHandle.Alloc(uvBuffer, GCHandleType.Pinned);
            var handleX = GCHandle.Alloc(xrefBuffer, GCHandleType.Pinned);
            var handleI = GCHandle.Alloc(indexBuffer, GCHandleType.Pinned);

            try
            {
                var pointerT = handleT.AddrOfPinnedObject();
                var pointerX = handleX.AddrOfPinnedObject();
                var pointerI = handleI.AddrOfPinnedObject();

                xatlasGetData(atlas, i, pointerT, pointerX, pointerI);
            }
            finally
            {
                if (handleT.IsAllocated) handleT.Free();
                if (handleX.IsAllocated) handleX.Free();
                if (handleI.IsAllocated) handleI.Free();
            }

            // Generate new UV buffer and xatlas->final index mappings
            var xatlasIndexToNewIndex = new int[newVertCount];
            for(int j=0; j<newVertCount; j++)
            {
                int xref = xrefBuffer[j];
                Vector2 uv = uvBuffer[j];

                if (newUVBuffer[xref].x < 0)
                {
                    // first xref encounter gets UV
                    xatlasIndexToNewIndex[j] = xref;
                    newUVBuffer[xref] = uv;
                    newXrefBuffer[xref] = xref;
                }
                else if (newUVBuffer[xref].x == uv.x && newUVBuffer[xref].y == uv.y)
                {
                    // vertex already added
                    xatlasIndexToNewIndex[j] = xref;
                }
                else
                {
                    // duplicate vertex
                    xatlasIndexToNewIndex[j] = newUVBuffer.Count;
                    newUVBuffer.Add(uv);
                    newXrefBuffer.Add(xref);
                }
            }

            // Generate final index buffer
            for(int j=0; j<indexCount; j++)
            {
                indexBuffer[j] = xatlasIndexToNewIndex[ indexBuffer[j] ];
            }
            indexBuffers.Add(indexBuffer);
        }

        //EditorUtility.DisplayDialog("Bakery", "xatlas unwrap end", "OK");

        int vertCount = m.vertexCount;

        bool origIs16bit = true;
#if UNITY_2017_3_OR_NEWER
        origIs16bit = m.indexFormat == UnityEngine.Rendering.IndexFormat.UInt16;
#endif
        bool is32bit = newUVBuffer.Count >= 65000;//0xFFFF;
        if (is32bit && origIs16bit)
        {
            Debug.LogError("Unwrap failed: original mesh (" + m.name + ") has 16 bit indices, but unwrapped requires 32 bit.");
            return;
        }

        // Duplicate attributes
        //if (newXrefBuffer.Count > m.vertexCount) // commented because can be also swapped around
        {
            m.vertices = FillAtrribute<Vector3>(newXrefBuffer, positions);
            m.normals =  FillAtrribute<Vector3>(newXrefBuffer, normals);
            m.boneWeights =  FillAtrribute<BoneWeight>(newXrefBuffer, m.boneWeights);
            m.colors32 =  FillAtrribute<Color32>(newXrefBuffer, m.colors32);
            m.tangents =  FillAtrribute<Vector4>(newXrefBuffer, m.tangents);
            m.uv =  FillAtrribute<Vector2>(newXrefBuffer, m.uv);
            m.uv3 =  FillAtrribute<Vector2>(newXrefBuffer, m.uv3);
            m.uv4 =  FillAtrribute<Vector2>(newXrefBuffer, m.uv4);
#if UNITY_2018_2_OR_NEWER
            m.uv5 =  FillAtrribute<Vector2>(newXrefBuffer, m.uv5);
            m.uv6 =  FillAtrribute<Vector2>(newXrefBuffer, m.uv6);
            m.uv7 =  FillAtrribute<Vector2>(newXrefBuffer, m.uv7);
            m.uv8 =  FillAtrribute<Vector2>(newXrefBuffer, m.uv8);
#endif
        }

        m.uv2 = newUVBuffer.ToArray();

/*

        // Set new UV2
        var finalUV2 = new Vector2[vertCount + newUV2.Count];
        for(int i=0; i<vertCount; i++) finalUV2[i] = uv2[i];
        for(int i=0; i<newUV2.Count; i++) finalUV2[i + vertCount] = newUV2[i];
        m.uv2 = finalUV2;
*/
        // Set indices
        for(int i=0; i<m.subMeshCount; i++)
        {
            m.SetTriangles(indexBuffers[i], i);
        }

        //Debug.Log("post-xatlas mesh building time: " + GetTime() - t));

        xatlasClear(atlas);
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/xatlas/xatlas.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/xatlas/xatlasEnable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: deadc446e4efea944b443c59b6aed3f8
# ASMDEF: BakeryEditorAssembly.dll
# ---
using UnityEngine;
using UnityEditor;
using UnityEditor.SceneManagement;
using System.Collections.Generic;

public partial class ftModelPostProcessor : ftModelPostProcessorInternal
{
    public override void UnwrapXatlas(Mesh m, UnwrapParam param)
    {
        xatlas.Unwrap(m, uparams);
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/scripts/xatlas/xatlasEnable.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Bakery/shader/BakeryShaderGUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 0465c9a9a7404f34fadd23fd32de6557
# ASMDEF: ldx.framework.editor.dll
# ---
#if UNITY_EDITOR

// Disable 'obsolete' warnings
#pragma warning disable 0618
#pragma warning disable 0612

using System;
using UnityEngine;

namespace UnityEditor
{
    public class BakeryShaderGUI : ShaderGUI
    {
        private enum WorkflowMode
        {
            Specular,
            Metallic,
            Dielectric
        }

        public enum BlendMode
        {
            Opaque,
            Cutout,
            Fade,		// Old school alpha-blending mode, fresnel does not affect amount of transparency
            Transparent // Physically plausible transparency mode, implemented as alpha pre-multiply
        }

        public enum SmoothnessMapChannel
        {
            SpecularMetallicAlpha,
            AlbedoAlpha,
        }

        private static class Styles
        {
            public static GUIStyle optionsButton = "PaneOptions";
            public static GUIContent uvSetLabel = new GUIContent("UV Set");
            public static GUIContent[] uvSetOptions = new GUIContent[] { new GUIContent("UV channel 0"), new GUIContent("UV channel 1") };

            public static string emptyTootip = "";
            public static GUIContent albedoText = new GUIContent("Albedo", "Albedo (RGB) and Transparency (A)");
            public static GUIContent alphaCutoffText = new GUIContent("Alpha Cutoff", "Threshold for alpha cutoff");
            public static GUIContent specularMapText = new GUIContent("Specular", "Specular (RGB) and Smoothness (A)");
            public static GUIContent metallicMapText = new GUIContent("Metallic", "Metallic (R) and Smoothness (A)");
            public static GUIContent smoothnessText = new GUIContent("Smoothness", "Smoothness value");
            public static GUIContent smoothnessScaleText = new GUIContent("Smoothness", "Smoothness scale factor");
            public static GUIContent smoothnessMapChannelText = new GUIContent("Source", "Smoothness texture and channel");
            public static GUIContent highlightsText = new GUIContent("Specular Highlights", "Specular Highlights");
            public static GUIContent reflectionsText = new GUIContent("Reflections", "Glossy Reflections");
            public static GUIContent normalMapText = new GUIContent("Normal Map", "Normal Map");
            public static GUIContent heightMapText = new GUIContent("Height Map", "Height Map (G)");
            public static GUIContent occlusionText = new GUIContent("Occlusion", "Occlusion (G)");
            public static GUIContent emissionText = new GUIContent("Emission", "Emission (RGB)");
            public static GUIContent detailMaskText = new GUIContent("Detail Mask", "Mask for Secondary Maps (A)");
            public static GUIContent detailAlbedoText = new GUIContent("Detail Albedo x2", "Albedo (RGB) multiplied by 2");
            public static GUIContent detailNormalMapText = new GUIContent("Normal Map", "Normal Map");

            public static string whiteSpaceString = " ";
            public static string primaryMapsText = "Main Maps";
            public static string secondaryMapsText = "Secondary Maps";
            public static string forwardText = "Forward Rendering Options";
            public static string renderingMode = "Rendering Mode";
            public static GUIContent emissiveWarning = new GUIContent("Emissive value is animated but the material has not been configured to support emissive. Please make sure the material itself has some amount of emissive.");
            public static GUIContent emissiveColorWarning = new GUIContent("Ensure emissive color is non-black for emission to have effect.");
            public static readonly string[] blendNames = Enum.GetNames(typeof(BlendMode));

            public static string bakeryText = "Bakery Options";
            public static GUIContent doubleSidedLabel = new GUIContent("Double-sided", "Render both sides of triangles.");
            public static GUIContent vertexLMLabel = new GUIContent("Allow Vertex Lightmaps", "Allows this material to use vertex lightmaps, if present.");
            public static GUIContent vertexLMdirLabel = new GUIContent("Enable VertexLM directional", "Enables directional vertex lightmaps.");
            public static GUIContent vertexLMSHLabel = new GUIContent("Enable VertexLM SH", "Enables SH vertex lightmaps.");
            public static GUIContent vertexLMMaskLabel = new GUIContent("Enable VertexLM Shadowmask", "Enables per-vertex shadowmasks.");
            public static GUIContent rnmLabel = new GUIContent("Allow RNM Lightmaps", "Allows this material to use RNM lightmaps, if present.");
            public static GUIContent shLabel = new GUIContent("Allow SH Lightmaps", "Allows this material to use SH lightmaps, if present.");
            public static GUIContent monoshLabel = new GUIContent("Enable MonoSH", "Makes this material treat directional maps as MonoSH.");
            public static GUIContent shnLabel = new GUIContent("Non-linear SH", "This option can enhance contrast (closer to ground truth), but it makes the shader a bit slower.");
            public static GUIContent specLabel = new GUIContent("Enable Lightmap Specular", "Enables baked specular for all directional modes.");
            public static GUIContent specOcclusionLabel = new GUIContent("Use Lightmap Specular as Reflection Occlusion", "Uses baked specular as a mask for reflection probes.");
            public static GUIContent bicubicLabel = new GUIContent("Force Bicubic Filter", "Enables bicubic filtering for all lightmaps (color/shadowmask/direction/etc) used in the material.");
            public static GUIContent pshnLabel = new GUIContent("Non-linear Light Probe SH", "Prevents negative values in light probes. This is recommended when baking probes in L1 mode. Can slow down the shader a bit.");
            public static GUIContent volLabel = new GUIContent("Enable Volumes", "Enable usages of BakeryVolumes");
            public static GUIContent volLabelRot = new GUIContent("Support Volume Rotation", "Normally volumes can only be repositioned or rescaled at runtime. With this checkbox volume's rotation matrix will also be used. Volumes must have a similar checkbox enabled.");
            public static GUIContent volLabel0 = new GUIContent("Volume 0");
            public static GUIContent volLabel1 = new GUIContent("Volume 1");
            public static GUIContent volLabel2 = new GUIContent("Volume 2");
            public static GUIContent volLabelMask = new GUIContent("Volume mask");
        }

        MaterialProperty blendMode = null;
        MaterialProperty albedoMap = null;
        MaterialProperty albedoColor = null;
        MaterialProperty alphaCutoff = null;
        MaterialProperty specularMap = null;
        MaterialProperty specularColor = null;
        MaterialProperty metallicMap = null;
        MaterialProperty metallic = null;
        MaterialProperty smoothness = null;
        MaterialProperty smoothnessScale = null;
        MaterialProperty smoothnessMapChannel = null;
        MaterialProperty highlights = null;
        MaterialProperty reflections = null;
        MaterialProperty bumpScale = null;
        MaterialProperty bumpMap = null;
        MaterialProperty occlusionStrength = null;
        MaterialProperty occlusionMap = null;
        MaterialProperty heigtMapScale = null;
        MaterialProperty heightMap = null;
        MaterialProperty emissionColorForRendering = null;
        MaterialProperty emissionMap = null;
        MaterialProperty detailMask = null;
        MaterialProperty detailAlbedoMap = null;
        MaterialProperty detailNormalMapScale = null;
        MaterialProperty detailNormalMap = null;
        MaterialProperty uvSetSecondary = null;
        MaterialProperty enableDoubleSided = null;
        MaterialProperty enableDoubleSidedOn = null;
        MaterialProperty enableVertexLM = null;
        MaterialProperty enableVertexLMdir = null;
        MaterialProperty enableVertexLMSH = null;
        MaterialProperty enableVertexLMmask = null;
        MaterialProperty enableSH = null;
        MaterialProperty enableMonoSH = null;
        MaterialProperty enableSHN = null;
        MaterialProperty enableRNM = null;
        MaterialProperty enableSpec = null;
        MaterialProperty enableSpecOcclusion = null;
        MaterialProperty enableBicubic = null;
        MaterialProperty enablePSHN = null;
        MaterialProperty enableVolumes = null;
        MaterialProperty enableVolumeRot = null;
        MaterialProperty volume0 = null;
        MaterialProperty volume1 = null;
        MaterialProperty volume2 = null;
        MaterialProperty volumeMask = null;
        MaterialProperty volumeMin = null;
        MaterialProperty volumeInvSize = null;

        BakeryVolume assignedVolume = null;

        MaterialEditor m_MaterialEditor;
        WorkflowMode m_WorkflowMode = WorkflowMode.Specular;
        ColorPickerHDRConfig m_ColorPickerHDRConfig = new ColorPickerHDRConfig(0f, 99f, 1 / 99f, 3f);

        bool m_FirstTimeApply = true;

        public void FindProperties(MaterialProperty[] props)
        {
            blendMode = FindProperty("_Mode", props);
            albedoMap = FindProperty("_MainTex", props);
            albedoColor = FindProperty("_Color", props);
            alphaCutoff = FindProperty("_Cutoff", props);
            specularMap = FindProperty("_SpecGlossMap", props, false);
            specularColor = FindProperty("_SpecColor", props, false);
            metallicMap = FindProperty("_MetallicGlossMap", props, false);
            metallic = FindProperty("_Metallic", props, false);
            if (specularMap != null && specularColor != null)
                m_WorkflowMode = WorkflowMode.Specular;
            else if (metallicMap != null && metallic != null)
                m_WorkflowMode = WorkflowMode.Metallic;
            else
                m_WorkflowMode = WorkflowMode.Dielectric;
            smoothness = FindProperty("_Glossiness", props);
            smoothnessScale = FindProperty("_GlossMapScale", props, false);
            smoothnessMapChannel = FindProperty("_SmoothnessTextureChannel", props, false);
            highlights = FindProperty("_SpecularHighlights", props, false);
            reflections = FindProperty("_GlossyReflections", props, false);
            bumpScale = FindProperty("_BumpScale", props);
            bumpMap = FindProperty("_BumpMap", props);
            heigtMapScale = FindProperty("_Parallax", props);
            heightMap = FindProperty("_ParallaxMap", props);
            occlusionStrength = FindProperty("_OcclusionStrength", props);
            occlusionMap = FindProperty("_OcclusionMap", props);
            emissionColorForRendering = FindProperty("_EmissionColor", props);
            emissionMap = FindProperty("_EmissionMap", props);
            detailMask = FindProperty("_DetailMask", props);
            detailAlbedoMap = FindProperty("_DetailAlbedoMap", props);
            detailNormalMapScale = FindProperty("_DetailNormalMapScale", props);
            detailNormalMap = FindProperty("_DetailNormalMap", props);
            uvSetSecondary = FindProperty("_UVSec", props);
            enableDoubleSided = FindProperty("_BAKERY_2SIDED", props);
            enableDoubleSidedOn = FindProperty("_BAKERY_2SIDEDON", props);
            enableVertexLM = FindProperty("_BAKERY_VERTEXLM", props);
            enableVertexLMdir = FindProperty("_BAKERY_VERTEXLMDIR", props);
            enableVertexLMSH = FindProperty("_BAKERY_VERTEXLMSH", props);
            enableVertexLMmask = FindProperty("_BAKERY_VERTEXLMMASK", props);
            enableSH = FindProperty("_BAKERY_SH", props);
            enableMonoSH = FindProperty("_BAKERY_MONOSH", props);
            enableSHN = FindProperty("_BAKERY_SHNONLINEAR", props);
            enableRNM = FindProperty("_BAKERY_RNM", props);
            enableSpec = FindProperty("_BAKERY_LMSPEC", props);
            enableSpecOcclusion = FindProperty("_BAKERY_LMSPECOCCLUSION", props);
            enableBicubic = FindProperty("_BAKERY_BICUBIC", props);
            enablePSHN = FindProperty("_BAKERY_PROBESHNONLINEAR", props);
            try
            {
                enableVolumes = FindProperty("_BAKERY_VOLUME", props);
                enableVolumeRot = FindProperty("_BAKERY_VOLROTATION", props);
                volume0 = FindProperty("_Volume0", props);
                volume1 = FindProperty("_Volume1", props);
                volume2 = FindProperty("_Volume2", props);
                volumeMask = FindProperty("_VolumeMask", props);
                volumeMin = FindProperty("_VolumeMin", props);
                volumeInvSize = FindProperty("_VolumeInvSize", props);
            }
            catch
            {

            }
        }

        public override void OnGUI(MaterialEditor materialEditor, MaterialProperty[] props)
        {
            FindProperties(props); // MaterialProperties can be animated so we do not cache them but fetch them every event to ensure animated values are updated correctly
            m_MaterialEditor = materialEditor;
            Material material = materialEditor.target as Material;

            // Make sure that needed keywords are set up if we're switching some existing
            // material to a standard shader.
            if (m_FirstTimeApply)
            {
                SetMaterialKeywords(material, m_WorkflowMode);
                m_FirstTimeApply = false;
            }

            ShaderPropertiesGUI(material);
        }

        public void ShaderPropertiesGUI(Material material)
        {
            // Use default labelWidth
            EditorGUIUtility.labelWidth = 0f;

            // Detect any changes to the material
            EditorGUI.BeginChangeCheck();
            {
                BlendModePopup();

                // Primary properties
                GUILayout.Label(Styles.primaryMapsText, EditorStyles.boldLabel);
                DoAlbedoArea(material);
                DoSpecularMetallicArea();
                m_MaterialEditor.TexturePropertySingleLine(Styles.normalMapText, bumpMap, bumpMap.textureValue != null ? bumpScale : null);
                m_MaterialEditor.TexturePropertySingleLine(Styles.heightMapText, heightMap, heightMap.textureValue != null ? heigtMapScale : null);
                m_MaterialEditor.TexturePropertySingleLine(Styles.occlusionText, occlusionMap, occlusionMap.textureValue != null ? occlusionStrength : null);
                DoEmissionArea(material);
                m_MaterialEditor.TexturePropertySingleLine(Styles.detailMaskText, detailMask);
                EditorGUI.BeginChangeCheck();
                m_MaterialEditor.TextureScaleOffsetProperty(albedoMap);
                if (EditorGUI.EndChangeCheck())
                {
                    emissionMap.textureScaleAndOffset = albedoMap.textureScaleAndOffset; // Apply the main texture scale and offset to the emission texture as well, for Enlighten's sake
                }

                EditorGUILayout.Space();

                // Secondary properties
                GUILayout.Label(Styles.secondaryMapsText, EditorStyles.boldLabel);
                m_MaterialEditor.TexturePropertySingleLine(Styles.detailAlbedoText, detailAlbedoMap);
                m_MaterialEditor.TexturePropertySingleLine(Styles.detailNormalMapText, detailNormalMap, detailNormalMapScale);
                m_MaterialEditor.TextureScaleOffsetProperty(detailAlbedoMap);
                m_MaterialEditor.ShaderProperty(uvSetSecondary, Styles.uvSetLabel.text);

                // Third properties
                GUILayout.Label(Styles.forwardText, EditorStyles.boldLabel);
                if (highlights != null)
                    m_MaterialEditor.ShaderProperty(highlights, Styles.highlightsText);
                if (reflections != null)
                    m_MaterialEditor.ShaderProperty(reflections, Styles.reflectionsText);

                GUILayout.Label(Styles.bakeryText, EditorStyles.boldLabel);

                m_MaterialEditor.ShaderProperty(enableDoubleSidedOn, Styles.doubleSidedLabel);
                enableDoubleSided.floatValue = enableDoubleSidedOn.floatValue > 0 ? 0 : 2;

                m_MaterialEditor.ShaderProperty(enableVertexLM, Styles.vertexLMLabel);
                if (enableVertexLM.floatValue > 0)
                {
                    m_MaterialEditor.ShaderProperty(enableVertexLMdir, Styles.vertexLMdirLabel);
                    //if (enableVertexLMdir.floatValue > 0) enableVertexLMSH.floatValue = 0;
                }
                if (enableVertexLM.floatValue > 0)
                {
                    m_MaterialEditor.ShaderProperty(enableVertexLMSH, Styles.vertexLMSHLabel);
                    //if (enableVertexLMSH.floatValue > 0) enableVertexLMdir.floatValue = 0;
                }
                if (enableVertexLM.floatValue > 0)
                {
                    m_MaterialEditor.ShaderProperty(enableVertexLMmask, Styles.vertexLMMaskLabel);
                }
                m_MaterialEditor.ShaderProperty(enableRNM, Styles.rnmLabel);
                m_MaterialEditor.ShaderProperty(enableSH, Styles.shLabel);
                m_MaterialEditor.ShaderProperty(enableMonoSH, Styles.monoshLabel);
                if (enableSH.floatValue > 0 || enableMonoSH.floatValue > 0 || enableVertexLMSH.floatValue > 0)
                    m_MaterialEditor.ShaderProperty(enableSHN, Styles.shnLabel);
                m_MaterialEditor.ShaderProperty(enableSpec, Styles.specLabel);
                if (enableSpec.floatValue > 0)
                {
                    m_MaterialEditor.ShaderProperty(enableSpecOcclusion, Styles.specOcclusionLabel);
                }
                m_MaterialEditor.ShaderProperty(enableBicubic, Styles.bicubicLabel);
                m_MaterialEditor.ShaderProperty(enablePSHN, Styles.pshnLabel);

                try
                {
                    m_MaterialEditor.ShaderProperty(enableVolumes, Styles.volLabel);
                    if (enableVolumes.floatValue > 0)
                    {
                        var prevAssignedVolume = assignedVolume;
                        assignedVolume = EditorGUILayout.ObjectField(volume0.textureValue == null ? "Assign volume" : "Assign different volume", assignedVolume, typeof(BakeryVolume), true) as BakeryVolume;
                        if (prevAssignedVolume != assignedVolume)
                        {
                            volume0.textureValue = assignedVolume.bakedTexture0;
                            volume1.textureValue = assignedVolume.bakedTexture1;
                            volume2.textureValue = assignedVolume.bakedTexture2;
                            volumeMask.textureValue = assignedVolume.bakedMask;
                            var b = assignedVolume.bounds;
                            volumeMin.vectorValue = b.min;
                            volumeInvSize.vectorValue = new Vector3(1.0f/b.size.x, 1.0f/b.size.y, 1.0f/b.size.z);
                            assignedVolume = null;
                        }
                        if (volume0.textureValue != null)
                        {
                            if (GUILayout.Button("Unset volume"))
                            {
                                volume0.textureValue = null;
                                volume1.textureValue = null;
                                volume2.textureValue = null;
                                volumeMask.textureValue = null;
                                volumeMin.vectorValue = Vector3.zero;
                                volumeInvSize.vectorValue = Vector3.one * 1000001;
                            }
                        }
                        EditorGUILayout.LabelField("Current Volume: " + (volume0.textureValue == null ? "<none or global>" : volume0.textureValue.name.Substring(0, volume0.textureValue.name.Length-1)));
                        EditorGUI.BeginDisabledGroup(true);
                        m_MaterialEditor.TexturePropertySingleLine(Styles.volLabel0, volume0);
                        m_MaterialEditor.TexturePropertySingleLine(Styles.volLabel1, volume1);
                        m_MaterialEditor.TexturePropertySingleLine(Styles.volLabel2, volume2);
                        m_MaterialEditor.TexturePropertySingleLine(Styles.volLabelMask, volumeMask);
                        var bmin4 = volumeMin.vectorValue;
                        var bmin = new Vector3(bmin4.x, bmin4.y, bmin4.z);
                        var invSize = volumeInvSize.vectorValue;
                        var bmax = new Vector3(1.0f/invSize.x + bmin.x, 1.0f/invSize.y + bmin.y, 1.0f/invSize.z + bmin.z);
                        EditorGUILayout.LabelField("Min: " + bmin);
                        EditorGUILayout.LabelField("Max: " + bmax);
                        EditorGUI.EndDisabledGroup();
                        m_MaterialEditor.ShaderProperty(enableVolumeRot, Styles.volLabelRot);
                    }
                }
                catch
                {

                }

                EditorGUILayout.Space();
            }
            if (EditorGUI.EndChangeCheck())
            {
                foreach (var obj in blendMode.targets)
                    MaterialChanged((Material)obj, m_WorkflowMode);
            }
        }

        internal void DetermineWorkflow(MaterialProperty[] props)
        {
            if (FindProperty("_SpecGlossMap", props, false) != null && FindProperty("_SpecColor", props, false) != null)
                m_WorkflowMode = WorkflowMode.Specular;
            else if (FindProperty("_MetallicGlossMap", props, false) != null && FindProperty("_Metallic", props, false) != null)
                m_WorkflowMode = WorkflowMode.Metallic;
            else
                m_WorkflowMode = WorkflowMode.Dielectric;
        }

        public override void AssignNewShaderToMaterial(Material material, Shader oldShader, Shader newShader)
        {
            // _Emission property is lost after assigning Standard shader to the material
            // thus transfer it before assigning the new shader
            if (material.HasProperty("_Emission"))
            {
                material.SetColor("_EmissionColor", material.GetColor("_Emission"));
            }

            base.AssignNewShaderToMaterial(material, oldShader, newShader);

            if (oldShader == null || !oldShader.name.Contains("Legacy Shaders/"))
            {
                SetupMaterialWithBlendMode(material, (BlendMode)material.GetFloat("_Mode"));
                return;
            }

            BlendMode blendMode = BlendMode.Opaque;
            if (oldShader.name.Contains("/Transparent/Cutout/"))
            {
                blendMode = BlendMode.Cutout;
            }
            else if (oldShader.name.Contains("/Transparent/"))
            {
                // NOTE: legacy shaders did not provide physically based transparency
                // therefore Fade mode
                blendMode = BlendMode.Fade;
            }
            material.SetFloat("_Mode", (float)blendMode);

            DetermineWorkflow(MaterialEditor.GetMaterialProperties(new Material[] { material }));
            MaterialChanged(material, m_WorkflowMode);
        }

        void BlendModePopup()
        {
            EditorGUI.showMixedValue = blendMode.hasMixedValue;
            var mode = (BlendMode)blendMode.floatValue;

            EditorGUI.BeginChangeCheck();
            mode = (BlendMode)EditorGUILayout.Popup(Styles.renderingMode, (int)mode, Styles.blendNames);
            if (EditorGUI.EndChangeCheck())
            {
                m_MaterialEditor.RegisterPropertyChangeUndo("Rendering Mode");
                blendMode.floatValue = (float)mode;
            }

            EditorGUI.showMixedValue = false;
        }

        void DoAlbedoArea(Material material)
        {
            m_MaterialEditor.TexturePropertySingleLine(Styles.albedoText, albedoMap, albedoColor);
            if (((BlendMode)material.GetFloat("_Mode") == BlendMode.Cutout))
            {
                m_MaterialEditor.ShaderProperty(alphaCutoff, Styles.alphaCutoffText.text, MaterialEditor.kMiniTextureFieldLabelIndentLevel + 1);
            }
        }

        void DoEmissionArea(Material material)
        {
            bool showHelpBox = !HasValidEmissiveKeyword(material);

            bool hadEmissionTexture = emissionMap.textureValue != null;

            // Texture and HDR color controls
            m_MaterialEditor.TexturePropertyWithHDRColor(Styles.emissionText, emissionMap, emissionColorForRendering, m_ColorPickerHDRConfig, false);

            // If texture was assigned and color was black set color to white
            float brightness = emissionColorForRendering.colorValue.maxColorComponent;
            if (emissionMap.textureValue != null && !hadEmissionTexture && brightness <= 0f)
                emissionColorForRendering.colorValue = Color.white;

            // Emission for GI?
            m_MaterialEditor.LightmapEmissionProperty(MaterialEditor.kMiniTextureFieldLabelIndentLevel + 1);

            if (showHelpBox)
            {
                EditorGUILayout.HelpBox(Styles.emissiveWarning.text, MessageType.Warning);
            }
        }

        void DoSpecularMetallicArea()
        {
            bool hasGlossMap = false;
            if (m_WorkflowMode == WorkflowMode.Specular)
            {
                hasGlossMap = specularMap.textureValue != null;
                m_MaterialEditor.TexturePropertySingleLine(Styles.specularMapText, specularMap, hasGlossMap ? null : specularColor);
            }
            else if (m_WorkflowMode == WorkflowMode.Metallic)
            {
                hasGlossMap = metallicMap.textureValue != null;
                m_MaterialEditor.TexturePropertySingleLine(Styles.metallicMapText, metallicMap, hasGlossMap ? null : metallic);
            }

            bool showSmoothnessScale = hasGlossMap;
            if (smoothnessMapChannel != null)
            {
                int smoothnessChannel = (int)smoothnessMapChannel.floatValue;
                if (smoothnessChannel == (int)SmoothnessMapChannel.AlbedoAlpha)
                    showSmoothnessScale = true;
            }

            int indentation = 2; // align with labels of texture properties
            m_MaterialEditor.ShaderProperty(showSmoothnessScale ? smoothnessScale : smoothness, showSmoothnessScale ? Styles.smoothnessScaleText : Styles.smoothnessText, indentation);

            ++indentation;
            if (smoothnessMapChannel != null)
                m_MaterialEditor.ShaderProperty(smoothnessMapChannel, Styles.smoothnessMapChannelText, indentation);
        }

        public static void SetupMaterialWithBlendMode(Material material, BlendMode blendMode)
        {
            switch (blendMode)
            {
                case BlendMode.Opaque:
                    material.SetOverrideTag("RenderType", "Opaque");
                    material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.One);
                    material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.Zero);
                    material.SetInt("_ZWrite", 1);
                    material.DisableKeyword("_ALPHATEST_ON");
                    material.DisableKeyword("_ALPHABLEND_ON");
                    material.DisableKeyword("_ALPHAPREMULTIPLY_ON");
                    material.renderQueue = -1;
                    break;
                case BlendMode.Cutout:
                    material.SetOverrideTag("RenderType", "TransparentCutout");
                    material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.One);
                    material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.Zero);
                    material.SetInt("_ZWrite", 1);
                    material.EnableKeyword("_ALPHATEST_ON");
                    material.DisableKeyword("_ALPHABLEND_ON");
                    material.DisableKeyword("_ALPHAPREMULTIPLY_ON");
                    material.renderQueue = (int)UnityEngine.Rendering.RenderQueue.AlphaTest;
                    break;
                case BlendMode.Fade:
                    material.SetOverrideTag("RenderType", "Transparent");
                    material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);
                    material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);
                    material.SetInt("_ZWrite", 0);
                    material.DisableKeyword("_ALPHATEST_ON");
                    material.EnableKeyword("_ALPHABLEND_ON");
                    material.DisableKeyword("_ALPHAPREMULTIPLY_ON");
                    material.renderQueue = (int)UnityEngine.Rendering.RenderQueue.Transparent;
                    break;
                case BlendMode.Transparent:
                    material.SetOverrideTag("RenderType", "Transparent");
                    material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.One);
                    material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);
                    material.SetInt("_ZWrite", 0);
                    material.DisableKeyword("_ALPHATEST_ON");
                    material.DisableKeyword("_ALPHABLEND_ON");
                    material.EnableKeyword("_ALPHAPREMULTIPLY_ON");
                    material.renderQueue = (int)UnityEngine.Rendering.RenderQueue.Transparent;
                    break;
            }
        }

        static SmoothnessMapChannel GetSmoothnessMapChannel(Material material)
        {
            int ch = (int)material.GetFloat("_SmoothnessTextureChannel");
            if (ch == (int)SmoothnessMapChannel.AlbedoAlpha)
                return SmoothnessMapChannel.AlbedoAlpha;
            else
                return SmoothnessMapChannel.SpecularMetallicAlpha;
        }

        static bool ShouldEmissionBeEnabled(Material mat, Color color)
        {
            var realtimeEmission = (mat.globalIlluminationFlags & MaterialGlobalIlluminationFlags.RealtimeEmissive) > 0;
            return color.maxColorComponent > 0.1f / 255.0f || realtimeEmission;
        }

        static void SetMaterialKeywords(Material material, WorkflowMode workflowMode)
        {
            // Note: keywords must be based on Material value not on MaterialProperty due to multi-edit & material animation
            // (MaterialProperty value might come from renderer material property block)
            SetKeyword(material, "_NORMALMAP", material.GetTexture("_BumpMap") || material.GetTexture("_DetailNormalMap"));
            if (workflowMode == WorkflowMode.Specular)
                SetKeyword(material, "_SPECGLOSSMAP", material.GetTexture("_SpecGlossMap"));
            else if (workflowMode == WorkflowMode.Metallic)
                SetKeyword(material, "_METALLICGLOSSMAP", material.GetTexture("_MetallicGlossMap"));
            SetKeyword(material, "_PARALLAXMAP", material.GetTexture("_ParallaxMap"));
            SetKeyword(material, "_DETAIL_MULX2", material.GetTexture("_DetailAlbedoMap") || material.GetTexture("_DetailNormalMap"));

            bool shouldEmissionBeEnabled = ShouldEmissionBeEnabled(material, material.GetColor("_EmissionColor"));
            SetKeyword(material, "_EMISSION", shouldEmissionBeEnabled);

            if (material.HasProperty("_SmoothnessTextureChannel"))
            {
                SetKeyword(material, "_SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A", GetSmoothnessMapChannel(material) == SmoothnessMapChannel.AlbedoAlpha);
            }

            // Setup lightmap emissive flags
            MaterialGlobalIlluminationFlags flags = material.globalIlluminationFlags;
            if ((flags & (MaterialGlobalIlluminationFlags.BakedEmissive | MaterialGlobalIlluminationFlags.RealtimeEmissive)) != 0)
            {
                flags &= ~MaterialGlobalIlluminationFlags.EmissiveIsBlack;
                if (!shouldEmissionBeEnabled)
                    flags |= MaterialGlobalIlluminationFlags.EmissiveIsBlack;

                material.globalIlluminationFlags = flags;
            }
        }

        bool HasValidEmissiveKeyword(Material material)
        {
            // Material animation might be out of sync with the material keyword.
            // So if the emission support is disabled on the material, but the property blocks have a value that requires it, then we need to show a warning.
            // (note: (Renderer MaterialPropertyBlock applies its values to emissionColorForRendering))
            bool hasEmissionKeyword = material.IsKeywordEnabled("_EMISSION");
            if (!hasEmissionKeyword && ShouldEmissionBeEnabled(material, emissionColorForRendering.colorValue))
                return false;
            else
                return true;
        }

        static void MaterialChanged(Material material, WorkflowMode workflowMode)
        {
            SetupMaterialWithBlendMode(material, (BlendMode)material.GetFloat("_Mode"));

            SetMaterialKeywords(material, workflowMode);
        }

        static void SetKeyword(Material m, string keyword, bool state)
        {
            if (state)
                m.EnableKeyword(keyword);
            else
                m.DisableKeyword(keyword);
        }
    }
}

#endif
# --- end Packages/com_ldx_framework/Editor/Third Party/Bakery/shader/BakeryShaderGUI.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EdgeGUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 24716a188674d4449a2ec3ca3f5fc46c
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEditor.Graphs;
using UnityEngine;
using Graphs = UnityEditor.Graphs;

namespace EventVisualizer.Base
{
	// Specialized edge drawer class
	public class EdgeGUI : IEdgeGUI
	{
		public const float EDGE_WIDTH = 6;
		private const float K_EDGE_BOTTOM_MARGIN = 4;
		private const float K_NODE_TITLE_SPACE = 36;
		private const float K_NODE_EDGE_SEPARATION = 12;
		
		private Edge moveEdge;
		private Slot dragSourceSlot;
		private Slot dropTarget;

		public GraphGUI host { get; set; }
		public List<int> edgeSelection { get; set; }

		public EdgeGUI()
		{
			edgeSelection = new List<int>();
		}

		#region IEdgeGUI implementation

		public void DoEdges()
		{
			// Draw edges on repaint.
			if (Event.current.type == EventType.Repaint)
			{
				foreach (Edge edge in host.graph.edges)
				{
					if (edge == moveEdge) continue;

					Vector2Int indexes = FindSlotIndexes(edge);
					DrawEdge(edge, indexes, ColorForIndex(edge.fromSlotName));
				}
			}
		}
		
		private Vector2Int FindSlotIndexes(Edge edge)
		{
			Vector2Int indexes = Vector2Int.zero;

			int totalOutputs = 0;
			bool found = false;
			foreach(Slot slot in edge.fromSlot.node.outputSlots)
			{
				if(slot != edge.fromSlot && !found)
				{
					indexes.x++;
				}
				else
				{
					found = true;
				}
				totalOutputs++;
			}
			indexes.x = totalOutputs - indexes.x - 1;

			foreach (Slot slot in edge.toSlot.node.inputSlots)
			{
				if (slot != edge.toSlot)
				{
					indexes.y++;
				}
				else
				{
					break;
				}
			}

			return indexes;
		}

		public static Color ColorForIndex(string name)
		{
			int hash = Math.Abs(Animator.StringToHash(name));
			return Color.HSVToRGB((float) (hash / (double) int.MaxValue), 1f, 1f);
		}

		public void DoDraggedEdge() { }

		public void BeginSlotDragging(Slot slot, bool allowStartDrag, bool allowEndDrag) { }

		public void SlotDragging(Slot slot, bool allowEndDrag, bool allowMultiple) { }

		public void EndSlotDragging(Slot slot, bool allowMultiple) { }
		
		public void EndDragging() { }

		public Edge FindClosestEdge()
		{
			return null;
		}
		
		#endregion

		#region Edge drawer

		static private void DrawEdge(Edge edge, Vector2Int indexes, Color color)
		{
			Vector2 p1 = GetPositionAsFromSlot(edge.fromSlot, indexes.x);
			Vector2 p2 = GetPositionAsToSlot(edge.toSlot, indexes.y);
			DrawEdge(p1, p2,  color * edge.color, EdgeTriggersTracker.GetTimings(edge));
		}

		static private void DrawEdge(Vector2 p1, Vector2 p2, Color color, List<float> triggers)
		{
			Color prevColor = Handles.color;
			Handles.color = color;

			float l = Mathf.Min(Mathf.Abs(p1.y - p2.y), 50);
			Vector2 p3 = p1 + new Vector2(l, 0);
			Vector2 p4 = p2 - new Vector2(l, 0);
			Texture2D texture = (Texture2D)Styles.selectedConnectionTexture.image;
			Handles.DrawBezier(p1, p2, p3, p4, color, texture, EDGE_WIDTH);
			
			foreach (float trigger in triggers)
			{
				Vector3 pos = CalculateBezierPoint(trigger, p1, p3, p4, p2);
				Handles.DrawSolidArc(pos, Vector3.back, pos + Vector3.up, 360, EDGE_WIDTH );
			}

			Handles.color = prevColor;
		}

		#endregion

		#region Utilities to access private members
		
		static private Vector2 GetPositionAsFromSlot(Slot slot, int index)
		{
			NodeGUI node = slot.node as NodeGUI;
			if (node != null)
			{
				Vector2 pos = node.position.position;
			
				pos.y = node.position.yMax - K_EDGE_BOTTOM_MARGIN;
				pos.y -= K_NODE_EDGE_SEPARATION * index;

				pos.x = node.position.xMax;

				return pos;
			}
			
			return Vector2.zero;
		}

		static private Vector2 GetPositionAsToSlot(Slot slot, int index)
		{
			NodeGUI node = slot.node as NodeGUI;
			if (node != null)
			{
				Vector2 pos = node.position.position;
				pos.y += K_NODE_TITLE_SPACE;
				pos.y += K_NODE_EDGE_SEPARATION * index;
				pos.x = node.position.x;

				return pos;
			}
			
			return Vector2.zero;
		}
		
		#endregion

		public static Vector3 CalculateBezierPoint(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
		{
			float u = 1.0f - t;
			float tt = t * t;
			float uu = u * u;
			float uuu = uu * u;
			float ttt = tt * t;

			Vector3 p = uuu * p0;
			p += 3 * uu * t * p1;
			p += 3 * u * tt * p2;
			p += ttt * p3;

			return p;
		}
	}

}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EdgeGUI.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EdgeTriggersTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 57a57526436160744ba47854e093c284
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using UnityEditor.Graphs;
using UnityEngine;

namespace EventVisualizer.Base
{
    public static class EdgeTriggersTracker
    {
        public class EdgeTrigger
        {
			public EventCall eventCall;
            public Edge edge;
            public float triggeredTime;
        }

        public static readonly float TimeToLive = 1f;
        private static readonly List<EdgeTrigger> Triggers = new List<EdgeTrigger>();

        public static void RegisterTrigger(Edge edge, EventCall eventCall)
        {
            Triggers.Add(new EdgeTrigger() { edge = edge, eventCall = eventCall, triggeredTime = Time.unscaledTime });
        }

		public static List<float> GetTimings(EventCall eventCall) 
		{
			float now = Time.unscaledTime;
			List<EdgeTrigger> acceptedTriggers = Triggers.FindAll(t => t.eventCall == eventCall);
			return GetTimings(acceptedTriggers);
		}

		public static List<float> GetTimings(Edge edge) 
		{
			List<EdgeTrigger> acceptedTriggers = Triggers.FindAll(t => t.edge == edge);
			return GetTimings(acceptedTriggers);
		}

		private static List<float> GetTimings(List<EdgeTrigger> acceptedTriggers)
		{
			float now = Time.unscaledTime;
			List<float> timings = new List<float>();//TODO cache
			foreach (EdgeTrigger t in acceptedTriggers) 
			{
				float time = Mathf.Abs(t.triggeredTime - now) / TimeToLive;
				if (time <= 1f) 
				{
					timings.Add(time);
				}
				else 
				{
					Triggers.Remove(t);
				}
			}
			return timings;
		}

        public static void CleanObsolete()
        {
            float now = Time.unscaledTime;
            Triggers.RemoveAll(trigger => Mathf.Abs(now - trigger.triggeredTime) > TimeToLive);
        }

        public static bool HasData()
        {
            return Triggers.Count > 0;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EdgeTriggersTracker.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EditorZoomArea.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 740582e9454097243a1e7bb1aa2e503f
# ASMDEF: ldx.framework.editor.dll
# ---
using Ldx.Framework.Utilities.Extensions;
using UnityEngine;

namespace EventVisualizer.Base
{
    public class EditorZoomArea
    {
        private const float EDITOR_WINDOW_TAB_HEIGHT = 21.0f;
        private static Matrix4x4 PrevGuiMatrix;

        public static Rect Begin(float zoomScale, Rect screenCoordsArea)
        {
            GUI.EndGroup();        // End the group Unity begins automatically for an EditorWindow to clip out the window tab. This allows us to draw outside of the size of the EditorWindow.

            Rect clippedArea = screenCoordsArea.ScaleSizeBy(1.0f / zoomScale, screenCoordsArea.TopLeft());
            clippedArea.y += EDITOR_WINDOW_TAB_HEIGHT;
            GUI.BeginGroup(clippedArea);

            PrevGuiMatrix = GUI.matrix;
            Matrix4x4 translation = Matrix4x4.TRS(clippedArea.TopLeft(), Quaternion.identity, Vector3.one);
            Matrix4x4 scale = Matrix4x4.Scale(new Vector3(zoomScale, zoomScale, 1.0f));
            GUI.matrix = translation * scale * translation.inverse * GUI.matrix;

            return clippedArea;
        }

        public static void End()
        {
            GUI.matrix = PrevGuiMatrix;
            GUI.EndGroup();
            GUI.BeginGroup(new Rect(0.0f, EDITOR_WINDOW_TAB_HEIGHT, Screen.width, Screen.height));
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EditorZoomArea.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventCall.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b9a31c3ec17359c4184082738f092498
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Reflection;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEngine;
using UnityEngine.Events;

namespace EventVisualizer.Base
{
    [System.Serializable]
    public class EventCall
    {
        private static Regex parenteshesPattern = new Regex(@"\(([^\(]*)\)$");
        
        public readonly Object sender;
        public readonly Object receiver;
		public readonly string eventShortName;
		public readonly string eventFullName;
		public readonly string method;
        public readonly Color color;
        public readonly UnityEventBase unityEvent;
        
        public System.Action OnTriggered;

		public NodeData nodeSender;
        public NodeData nodeReceiver;
        
        public string ReceiverComponentName { get; private set; }
        public string ReceiverComponentNameSimple { get; private set; }
        public string MethodFullPath => ReceiverComponentName + "." + method;
        public double lastTimeExecuted { get; private set; }
        public int timesExecuted { get; private set; }

        public EventCall(Object sender, Object receiver, string eventShortName, string eventFullName, string methodName, UnityEventBase unityEvent)
        {
            this.sender = sender as Component ? (sender as Component)?.gameObject : sender;
            this.receiver = receiver as Component ? (receiver as Component)?.gameObject : receiver;
			this.eventShortName = eventShortName;
			this.eventFullName = eventFullName;
			method = methodName;
			color = EdgeGUI.ColorForIndex(this.eventShortName);
			this.unityEvent = unityEvent;

            UpdateReceiverComponentName(receiver);
            AttachTrigger(unityEvent);
        }

        private void AttachTrigger(UnityEventBase unityEvent)
        {
            if (unityEvent == null)
            {
                return;
            }
            MethodInfo eventRegisterMethod = unityEvent.GetType().GetMethod("AddListener");
            if (eventRegisterMethod != null)
            {
                System.Type eventType = eventRegisterMethod.GetParameters()[0].ParameterType;
                ParameterInfo[] eventParameters = eventType.GetMethod("Invoke")?.GetParameters(); 
                
                if (eventParameters is { Length: 0 })
                {
                    MethodInfo methodInfo = this.GetType()
                        .GetMethod("TriggerZeroArgs", BindingFlags.Public | BindingFlags.Instance);

                    System.Type actionT = typeof(UnityAction);
                    System.Delegate triggerAction = System.Delegate.CreateDelegate(actionT, this, methodInfo);

                    eventRegisterMethod.Invoke(unityEvent, new object[]
                    {
                        triggerAction
                    });
                }

                else if (eventParameters is { Length: 1 })
                {
                    System.Type t0 = eventParameters[0].ParameterType;

                    MethodInfo methodInfo = GetType()
                        .GetMethod("TriggerOneArg", BindingFlags.Public | BindingFlags.Instance)
                        ?.MakeGenericMethod(t0);

                    System.Type actionT = typeof(UnityAction<>).MakeGenericType(t0);
                    System.Delegate triggerAction = System.Delegate.CreateDelegate(actionT, this, methodInfo);

                    eventRegisterMethod.Invoke(unityEvent, new object[]
                    {
                        triggerAction
                    });
                }
                else if (eventParameters is { Length: 2 })
                {
                    System.Type t0 = eventParameters[0].ParameterType;
                    System.Type t1 = eventParameters[1].ParameterType;

                    MethodInfo methodInfo = GetType()
                        .GetMethod("TriggerTwoArgs", BindingFlags.Public | BindingFlags.Instance)
                        ?.MakeGenericMethod(t0, t1);

                    System.Type actionT = typeof(UnityAction<,>).MakeGenericType(t0, t1);
                    System.Delegate triggerAction = System.Delegate.CreateDelegate(actionT, this, methodInfo);

                    eventRegisterMethod.Invoke(unityEvent, new object[]
                    {
                        triggerAction
                    });
                }
                else if (eventParameters is { Length: 3 })
                {
                    System.Type t0 = eventParameters[0].ParameterType;
                    System.Type t1 = eventParameters[1].ParameterType;
                    System.Type t2 = eventParameters[2].ParameterType;

                    MethodInfo methodInfo = GetType()
                        .GetMethod("TriggerThreeArgs", BindingFlags.Public | BindingFlags.Instance)
                        ?.MakeGenericMethod(t0, t1,t2);

                    System.Type actionT = typeof(UnityAction<,,>).MakeGenericType(t0, t1,t2);
                    System.Delegate triggerAction = System.Delegate.CreateDelegate(actionT, this, methodInfo);

                    eventRegisterMethod.Invoke(unityEvent, new object[]
                    {
                        triggerAction
                    });
                }
                else if (eventParameters is { Length: 2 })
                {
                    System.Type t0 = eventParameters[0].ParameterType;
                    System.Type t1 = eventParameters[1].ParameterType;
                    System.Type t2 = eventParameters[2].ParameterType;
                    System.Type t3 = eventParameters[3].ParameterType;

                    MethodInfo methodInfo = GetType()
                        .GetMethod("TriggerFourArgs", BindingFlags.Public | BindingFlags.Instance)
                        ?.MakeGenericMethod(t0, t1,t2,t3);

                    System.Type actionT = typeof(UnityAction<,,,>).MakeGenericType(t0, t1, t2,t3);
                    System.Delegate triggerAction = System.Delegate.CreateDelegate(actionT, this, methodInfo);

                    eventRegisterMethod.Invoke(unityEvent, new object[]
                    {
                        triggerAction
                    });
                }
            }
        }

        #region generic callers
        public void TriggerZeroArgs()
        {
            OnExecuted();
            OnTriggered?.Invoke();
        }

        public void TriggerOneArg<T0>(T0 arg0)
        {
            OnExecuted();
            OnTriggered?.Invoke();
        }
        public void TriggerTwoArgs<T0,T1>(T0 arg0, T1 arg1)
        {
            OnExecuted();
            OnTriggered?.Invoke();
        }
        public void TriggerThreeArgs<T0,T1,T2>(T0 arg,T1 arg1, T2 arg2)
        {
            OnExecuted();
            OnTriggered?.Invoke();
        }
        public void TriggerFourArgs<T0, T1, T2, T3>(T0 arg, T1 arg1, T2 arg2, T3 arg3)
        {
            OnExecuted();
            OnTriggered?.Invoke();
        }

        private void OnExecuted() 
        {
            timesExecuted++;
            lastTimeExecuted = EditorApplication.timeSinceStartup;
        }
        #endregion

        private void UpdateReceiverComponentName(Object component)
        {
            if (receiver != null)
            {
                MatchCollection matches = parenteshesPattern.Matches(component.ToString());
                if (matches is { Count: 1 })
                {
                    ReceiverComponentName = matches[0].Value;
                    ReceiverComponentName = ReceiverComponentName.Substring(1, ReceiverComponentName.Length - 2);
					int lastDot = ReceiverComponentName.LastIndexOf('.') + 1;
					ReceiverComponentNameSimple = ReceiverComponentName.Substring(lastDot, ReceiverComponentName.Length - lastDot);
				}
            }
        }
        
		public override bool Equals(object obj) 
        {
			EventCall ec = (EventCall) obj;
			return null != ec && ec.unityEvent == unityEvent && receiver == ec.receiver && method == ec.method;
		}

		public override int GetHashCode() 
        {
			return unityEvent == null ? 0 : unityEvent.GetHashCode() ^ (receiver == null ? 0 : receiver.GetHashCode() ^ method.GetHashCode());
		}
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventCall.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventsGraph.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a48afff5ab5b4244f86f43a26d925a16
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;
using System.Collections.Generic;
using UnityEditor.Graphs;
using System.Linq;
using UnityEditor;

namespace EventVisualizer.Base
{
	[System.Serializable]
	public class EventsGraph : Graph
	{
		private const float VERTICAL_SPACING = 80f;
		private const float HORIZONTAL_SPACING = 400f;
		private const int WARNING_CALLS_THRESHOLD = 1000;
		
		private HashSet<Node> positionedNodes = new HashSet<Node>();
		private GameObject[] selectedRoots;
		private bool searchingHierarchy;

		static public EventsGraph Create()
		{
			EventsGraph graph = CreateInstance<EventsGraph>();
			graph.hideFlags = HideFlags.HideAndDontSave;
			return graph;
		}

		public EventsGraphGUI GetEditor()
		{
			EventsGraphGUI gui = CreateInstance<EventsGraphGUI>();
			gui.graph = this;
			gui.hideFlags = HideFlags.HideAndDontSave;
			return gui;
		}

		public void RebuildGraph(GameObject[] roots, bool searchHierarchy)
		{
			selectedRoots = roots;
			searchingHierarchy = searchHierarchy;
			BuildGraph(selectedRoots, searchHierarchy);
			SortGraph(nodes,false);
		}

		public void RefreshGraphConnections()
		{
			Dictionary<string, Rect> positions = new Dictionary<string, Rect>();
			List<Node> adriftNodes = new List<Node>();
			NodeGUI singleNode = null;
			
			foreach (Node node1 in nodes)
			{
				singleNode = (NodeGUI)node1;
				positions.Add(singleNode.name, singleNode.position);
			}
			BuildGraph(selectedRoots, searchingHierarchy);

			foreach (Node node1 in nodes)
			{
				singleNode = (NodeGUI)node1;
				if(positions.TryGetValue(singleNode.name, out Rect position))
				{
					singleNode.position = position;
				}
				else
				{
					adriftNodes.Add(singleNode);
				}
			}
			SortGraph(adriftNodes,true);
		}

		private void BuildGraph(GameObject[] roots, bool searchHierarchy)
		{
			NodeData.ClearAll();
			Clear(true);
			List<EventCall> calls = EventsFinder.FindAllEvents(roots, searchHierarchy);
			if(calls.Count > WARNING_CALLS_THRESHOLD)
			{
				bool goAhead = EditorUtility.DisplayDialog("Confirm massive graph",
					"You are about to generate a graph with "+ calls.Count+" events.\n"
					+ "Tip: You can select some gameobjects and search events in just those or their children instead.",
					"Go ahead",
					"Abort");

				if(goAhead)
				{
					GenerateGraphFromCalls(calls);
				}
			}
			else
			{
				GenerateGraphFromCalls(calls);
			}
		}

		private void GenerateGraphFromCalls(List<EventCall> calls)
		{
			foreach (EventCall call in calls)
			{
				NodeData.RegisterEvent(call);
			}

			NodeGUI node = null;
			foreach (NodeData data in NodeData.Nodes)
			{
				node = NodeGUI.Create(data);
				if (!nodes.Contains(node))
				{
					AddNode(node);
				}
			}
			foreach (Node node1 in nodes)
			{
				node = (NodeGUI)node1;
				node.PopulateEdges();
			}
		}

		#region sorting

		private void SortGraph(List<Node> nodesToSort, bool skipParents)
		{
			positionedNodes.Clear();

			List<Node> sortedNodes = new List<Node>(nodesToSort); //cannot sort the original collection so a clone is needed
			sortedNodes.Sort((x, y) =>
			{
				int xScore = x.outputEdges.Count() - x.inputEdges.Count();
				int yScore = y.outputEdges.Count() - y.inputEdges.Count();
				return yScore.CompareTo(xScore);
			});

			Vector2 position = Vector2.zero;
			foreach (Node node in sortedNodes)
			{
				if (!positionedNodes.Contains(node))
				{
					positionedNodes.Add(node);
					position.y += PositionNodeHierarchy(node, position, skipParents);
				}
			}
		}
		
		private float PositionNodeHierarchy(Node currentNode, Vector2 masterPosition, bool skipParents)
		{
			float height = VERTICAL_SPACING;
			if (!skipParents)
			{
				foreach (Edge outputEdge in currentNode.outputEdges)
				{
					Node node = outputEdge.toSlot.node;
					if (!positionedNodes.Contains(node))
					{
						positionedNodes.Add(node);
						height += PositionNodeHierarchy(node, masterPosition
							+ Vector2.right * HORIZONTAL_SPACING
							+ Vector2.up * height, skipParents);
					}
				}
			}
			currentNode.position = new Rect(masterPosition + Vector2.up * height * 0.5f, currentNode.position.size);

			return height;
		}

		#endregion
	}
}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventsGraph.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventsGraphGUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d0a9d505156c000439f4832d50c68d7f
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;
using UnityEditor;
using EventVisualizer.Base;
using System.Collections.Generic;
using UnityEditor.Graphs;
using UnityEngine.Serialization;

namespace EventVisualizer.Base
{
    [System.Serializable]
	public class EventsGraphGUI : GraphGUI
    {
        public int SelectionOverride;
      
        public override void OnGraphGUI()
        {
            // Show node subwindows.
			m_Host.BeginWindows();
			
			foreach (Node node in graph.nodes)
            {
                // Recapture the variable for the delegate.
                Node node2 = node;

                // Subwindow style (active/nonactive)
                bool isActive = selection.Contains(node);
                GUIStyle style = Styles.GetNodeStyle(node.style, node.color, isActive);
                
                node.position = GUILayout.Window
                (
                    node.GetInstanceID(), 
                    node.position,
                    delegate { NodeGUI(node2); },
                    node.title, 
                    style, 
                    GUILayout.Width(150)
                );
            }
            
            if (graph.nodes.Count == 0)
            { 
                GUILayout.Window(0, new Rect(0, 0, 1, 1), delegate {}, "", "MiniLabel");
            }
			
			m_Host.EndWindows();

			// Graph edges
			edgeGUI.DoEdges();

			
			// Mouse drag
#if UNITY_2017 || UNITY_2017_1_OR_NEWER
			DragSelection();
#else
			DragSelection(new Rect(-5000, -5000, 10000, 10000));
#endif
        }
        
        public override IEdgeGUI edgeGUI
        {
            get
            {
                if (m_EdgeGUI == null)
                    m_EdgeGUI = new EdgeGUI { host = this };
                return m_EdgeGUI;
            }
        }
        
        public override void NodeGUI(Node node)
        {
            SelectNode(node);

            foreach (Slot slot in node.inputSlots)
                LayoutSlot(slot, slot.title, false, true, true, Styles.triggerPinIn);

            node.NodeUI(this);

            foreach (Slot slot in node.outputSlots)
            {
                EditorGUILayout.BeginHorizontal();
                GUILayout.FlexibleSpace();
                LayoutSlot(slot, slot.title, true, false, true, Styles.triggerPinOut);
                EditorGUILayout.EndHorizontal();
            }

            DragNodes();

            UpdateSelection();
        }

        private void UpdateSelection()
        {
            OverrideSelection();
            if (selection.Count > 0)
            {
                int[] selectedIds = new int[selection.Count];
                for (int i = 0; i < selection.Count; i++)
                {
					if(selection[i] != null)
					{
						selectedIds[i] = int.Parse(selection[i].name);
					}
                }
                Selection.instanceIDs = selectedIds;
            }
        }

        private void OverrideSelection()
        {
            if (SelectionOverride != 0)
            {
                Node selectedNode = graph[SelectionOverride.ToString()];
                
                if (selectedNode != null)
                {
                    selection.Clear();
                    selection.Add(selectedNode);
                    CenterGraph(selectedNode.position.position);
                }
                SelectionOverride = 0;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventsGraphGUI.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventsGraphWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 29ac7234bb09f2f4d8dafebd9faacc56
# ASMDEF: ldx.framework.editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Text;
using Ldx.Framework.Utilities.Extensions;
using UnityEditor;
using UnityEngine;
using UnityEngine.Serialization;

namespace EventVisualizer.Base
{
	public class EventsGraphWindow : EditorWindow
	{
		private const float BAR_HEIGHT = 17;
		private const float ZOOM_MIN = 0.1f;
		private const float ZOOM_MAX = 1.0f;
		
		private static readonly string[] toolbarStrings = new string[] {"Rebuild on selected Hierarchy", "Rebuild JUST selected", "Update connections" };

		[Serializable]
		public class SavedPrefBool 
		{
			public readonly string name;
			protected readonly bool defaultValue;
			protected bool value;
			private bool ready = false;

			public SavedPrefBool(string name, bool defaultValue) 
			{
				this.name = name;
				this.defaultValue = defaultValue;
			}

			public bool Get() 
			{
				if (!ready) {
					ready = true;
					value = EditorPrefs.GetBool(name, defaultValue);
				}
				return value;
			}
			
			public void Set(bool value) 
			{
				this.value = value;
				EditorPrefs.SetBool(name, value);
			}
		}
		
		[FormerlySerializedAs("_graph")]
		[SerializeField] private EventsGraph graph;
		[FormerlySerializedAs("_graphGUI")]
		[SerializeField] private EventsGraphGUI graphGUI;
		[SerializeField] private SavedPrefBool showOnlyWhenSelected = new SavedPrefBool("EventVisualizer_showOnlyWhenSelected", true);
		[SerializeField] private SavedPrefBool showLabels = new SavedPrefBool("EventVisualizer_showLabels", true);
		[SerializeField] private SavedPrefBool showComponentName = new SavedPrefBool("EventVisualizer_showComponentName", true);
		[SerializeField] private SavedPrefBool showTimesExecuted = new SavedPrefBool("EventVisualizer_showTimesExecuted", true);
		[SerializeField] private SavedPrefBool eventFullName = new SavedPrefBool("EventVisualizer_eventFullName", true);

		private struct Bezier 
		{
			public enum Tangent { None, Auto, Positive, Negative, PositiveUnscaled, NegativeUnscaled }
			public Vector2 start;
			public Vector2 end;
			public Tangent startTangent, endTangent;
		}

		private struct EventBox 
		{
			public EventCall ev;
			public GUIContent content;
			public Rect rect;
		}

		private Dictionary<EventCall, Bezier> beziersToDraw = new Dictionary<EventCall, Bezier>();
		private List<EventBox> boxesToDraw = new List<EventBox>();
		
		public float separation = 3;
		public GUISkin guiSkin;
		private Rect zoomArea = new Rect(0.0f, 75.0f, 600.0f, 300.0f - 100.0f);
		private float zoom = 1f;
		private Vector2 zoomCoordsOrigin = Vector2.zero;
		private bool initialized = false;

		[MenuItem("Window/Events Graph editor")]
		static private void ShowEditor()
		{
			EventsGraphWindow editor = EditorWindow.GetWindow<EventsGraphWindow>();
			editor.hideFlags = HideFlags.HideAndDontSave;
			editor.Initialize();
		}

		public void Initialize()
		{
			if (initialized) return;
			initialized = true;
			graph = EventsGraph.Create();
			//_graph.RebuildGraph();

			graphGUI = graph.GetEditor();
			graphGUI.CenterGraph();

			EditorUtility.SetDirty(graphGUI);
			EditorUtility.SetDirty(graph);
		}
		
		private void OnGUI()
		{
			Initialize();

			float width = position.width;
			float height = position.height;
			zoomArea = new Rect(0, 0, width, height);
			HandleEvents();

			if (graphGUI != null)
			{
				Rect r = EditorZoomArea.Begin(zoom, zoomArea);
				// Main graph area
				graphGUI.BeginGraphGUI(this, r);
				graphGUI.OnGraphGUI();
				graphGUI.EndGraphGUI();

				// Clear selection on background click
				Event e = Event.current;
				if (e.type == EventType.MouseDown && e.clickCount == 1)
					graphGUI.ClearSelection();
				
				EditorZoomArea.End();
			}
			
			// Status bar
			GUILayout.BeginArea(new Rect(0, 0, width, BAR_HEIGHT+5));
			int result = GUILayout.Toolbar(-1, toolbarStrings);
			switch (result)
			{
				case 0:
					RebuildGraphOnSelected(true);
					break;
				case 1:
					RebuildGraphOnSelected(false);
					break;
				case 2:
					RefreshGraphConnections();
					break;
			}
			GUILayout.EndArea();

			const float maxWidth = 200;
			GUILayout.BeginArea(new Rect(0, BAR_HEIGHT + 5, maxWidth, 20 * 5), GUI.skin.box);
			showOnlyWhenSelected.Set(EditorGUILayout.Toggle("Show only when selected", showOnlyWhenSelected.Get(), GUILayout.MaxWidth(maxWidth)));
			showLabels.Set(EditorGUILayout.Toggle("Labels", showLabels.Get(), GUILayout.MaxWidth(maxWidth)));
			showComponentName.Set(EditorGUILayout.Toggle("Function Full Path", showComponentName.Get(), GUILayout.MaxWidth(maxWidth)));
			eventFullName.Set(EditorGUILayout.Toggle("Event Full Name", eventFullName.Get(), GUILayout.MaxWidth(maxWidth)));
			showTimesExecuted.Set(EditorGUILayout.Toggle("Times Executed", showTimesExecuted.Get(), GUILayout.MaxWidth(maxWidth)));
			GUILayout.EndArea();
		}
		
		private void Update()
		{
			if (EdgeTriggersTracker.HasData())
			{
				Repaint();
			}
		}

		public void OverrideSelection(int overrideIndex)
		{
			graphGUI.SelectionOverride = overrideIndex;
		}

		public Vector2 ConvertScreenCoordsToZoomCoords(Vector2 screenCoords)
		{
			return (screenCoords - zoomArea.TopLeft()) / zoom + zoomCoordsOrigin;
		}
		
		private void HandleEvents()
		{
			if (Event.current.type == EventType.ScrollWheel)
			{
				Vector2 screenCoordsMousePos = Event.current.mousePosition;
				Vector2 delta = Event.current.delta;
				Vector2 zoomCoordsMousePos = ConvertScreenCoordsToZoomCoords(screenCoordsMousePos);
				float zoomDelta = -delta.y / 150.0f;
				float oldZoom = zoom;
				zoom += zoomDelta;
				zoom = Mathf.Clamp(zoom, ZOOM_MIN, ZOOM_MAX);
				zoomCoordsOrigin += (zoomCoordsMousePos - zoomCoordsOrigin) - (oldZoom / zoom) * (zoomCoordsMousePos - zoomCoordsOrigin);

				Event.current.Use();
			}
		}
		
		public void RebuildGraphOnSelected(bool searchHierarchy)
		{
			RebuildGraph(Selection.gameObjects, searchHierarchy);
		}

		public void RebuildGraph(GameObject[] roots, bool searchHierarchy)
		{
			if (graph != null)
			{
				graph.RebuildGraph(Selection.gameObjects, searchHierarchy);
			}
		}

		public void RefreshGraphConnections()
		{
			Debug.Log("Refreshing UnityEventVisualizer Graph Connections");
			if (graph != null)
			{
				graph.RefreshGraphConnections();
			}
		}
		
		private void OnFocus() 
		{
			RemoveCallbacks();
			AddCallbacks();
		}

		private void OnDestroy() 
		{
			RemoveCallbacks();
		}

		private void AddCallbacks() 
		{
			SceneView.duringSceneGui += OnSceneGUI;
			EditorApplication.playModeStateChanged += OnPlayModeStateChanged;
		}

		private void RemoveCallbacks() 
		{
			SceneView.duringSceneGui -= OnSceneGUI;
			EditorApplication.playModeStateChanged -= OnPlayModeStateChanged;
		}

		private void OnPlayModeStateChanged(PlayModeStateChange mode) 
		{
			switch (mode) 
			{
				case PlayModeStateChange.EnteredEditMode:
					break;
				case PlayModeStateChange.EnteredPlayMode:
					RefreshGraphConnections();
					break;
			}
		}

		private void OnSceneGUI(SceneView sceneView) 
		{
			Handles.BeginGUI();
			GUI.skin = guiSkin;
			
			foreach (NodeData elem in NodeData.Nodes) 
			{
				GameObject entity = elem.Entity as GameObject;
				if (null != entity) 
				{
					bool isEntitySelected = CheckSelection(entity.gameObject);
					Vector2 senderPos2D = WorldToGUIPoint(entity.transform.position, SceneView.currentDrawingSceneView.camera.transform.position, out bool behindScreen);

					if (isEntitySelected) 
					{
						StringBuilder sb = new StringBuilder();
						foreach (EventCall ev in elem.Inputs)
						{
							GameObject receiver = ev.receiver as GameObject;
							GameObject sender = ev.sender as GameObject;

							if (null != sender && receiver != ev.sender) 
							{
								if (behindScreen) senderPos2D = WorldToGUIPoint(entity.transform.position, sender.transform.position, out behindScreen);
								Rect rect = DrawEventBox(sb, " ", boxesToDraw, ev, ref senderPos2D, behindScreen);
								sb.Length = 0;

								beziersToDraw.TryGetValue(ev, out Bezier b);
								b.endTangent = Bezier.Tangent.Negative;
								b.end = new Vector2(rect.x, rect.y + rect.height * 0.5f);
								beziersToDraw[ev] = b;
							}
						}
						foreach (EventCall ev in elem.Inputs)
						{
							GameObject receiver = ev.receiver as GameObject;
							if (receiver == ev.sender) 
							{
								if (behindScreen) continue; // Don't draw
								Rect rect = DrawEventBox(sb, "   ", boxesToDraw, ev, ref senderPos2D, behindScreen);
								sb.Length = 0;

								Bezier b;
								beziersToDraw.TryGetValue(ev, out b);
								b.endTangent = Bezier.Tangent.NegativeUnscaled;
								b.startTangent = Bezier.Tangent.NegativeUnscaled;
								b.start = new Vector2(rect.x, rect.y + rect.height * 0.25f);
								b.end = new Vector2(rect.x, rect.y + rect.height * 0.75f);
								beziersToDraw[ev] = b;
							}
						}
						
						foreach (EventCall ev in elem.Outputs)
						{
							GameObject receiver = ev.receiver as GameObject;
							if (null != receiver && receiver != ev.sender)
							{
								if (behindScreen) senderPos2D = WorldToGUIPoint(entity.transform.position, receiver.transform.position, out behindScreen);
								Rect rect = DrawEventBox(sb, " ", boxesToDraw, ev, ref senderPos2D, behindScreen);
								sb.Length = 0;

								Bezier b;
								beziersToDraw.TryGetValue(ev, out b);
								b.startTangent = behindScreen ? Bezier.Tangent.None : Bezier.Tangent.Positive;
								b.start = new Vector2(rect.x + rect.width, rect.y + rect.height * 0.5f);
								beziersToDraw[ev] = b;
							}
						}
					}
					else
					{
						foreach (EventCall ev in elem.Inputs)
						{
							GameObject sender = ev.sender as GameObject;
							if (null != sender) 
							{
								bool isSenderSelected = CheckSelection(sender.gameObject);

								if (isSenderSelected || ev.lastTimeExecuted + EdgeTriggersTracker.TimeToLive >= EditorApplication.timeSinceStartup) 
								{
									if (behindScreen) senderPos2D = WorldToGUIPoint(entity.transform.position, sender.transform.position, out behindScreen);
									Vector2 localEnd2D = senderPos2D + new Vector2(0, separation * ev.nodeSender.Inputs.IndexOf(ev));

									beziersToDraw.TryGetValue(ev, out Bezier b);
									b.endTangent = behindScreen ? Bezier.Tangent.None : Bezier.Tangent.Auto;
									b.end = localEnd2D;
									beziersToDraw[ev] = b;
								}
							}
						}

						for (int i = 0; i < elem.Outputs.Count; i++) 
						{
							EventCall ev = elem.Outputs[i];
							GameObject receiver = ev.receiver as GameObject;
							if (null != receiver) 
							{
								bool isReceiverSelected = CheckSelection(receiver.gameObject);

								if (isReceiverSelected || ev.lastTimeExecuted + EdgeTriggersTracker.TimeToLive >= EditorApplication.timeSinceStartup) 
								{
									if (behindScreen) senderPos2D = WorldToGUIPoint(entity.transform.position, receiver.transform.position, out behindScreen);
									Vector2 localStart2D = senderPos2D + new Vector2(0, separation * i);

									beziersToDraw.TryGetValue(ev, out Bezier b);
									b.startTangent = Bezier.Tangent.Auto;
									b.start = localStart2D;
									beziersToDraw[ev] = b;
								}
							}
						}
					}
				}
			}

			foreach (KeyValuePair<EventCall, Bezier> elem in beziersToDraw) 
			{
				DrawConnection(elem.Key, elem.Value);
			}
			
			beziersToDraw.Clear();

			foreach (EventBox box in boxesToDraw) 
			{
				DrawEventBox(box);
			}
			boxesToDraw.Clear();

			Handles.EndGUI();
		}

		private bool CheckSelection(GameObject go) 
		{
			return !showOnlyWhenSelected.Get() || Selection.Contains(go);
		}

		private Rect DrawEventBox(StringBuilder sb, string type, List<EventBox> boxes, EventCall ev, ref Vector2 boxPos, bool outsideScreen) 
		{
			Rect rect = new Rect(boxPos, new Vector2(0, separation));

			if (!outsideScreen && showLabels.Get()) 
			{
				sb.Append(type);
				if (showTimesExecuted.Get()) sb.Append("(").Append(ev.timesExecuted).Append(") ");
				sb.Append(eventFullName.Get() ? ev.eventFullName : ev.eventShortName).Append("    ");
				if (showComponentName.Get()) sb.Append(ev.ReceiverComponentNameSimple).Append(".");
				sb.Append(ev.method);

				GUIContent content = new GUIContent(sb.ToString());

				rect.size = GUI.skin.box.CalcSize(content);

				boxes.Add(new EventBox() 
				{
					content = content,
					ev = ev,
					rect = rect
				});
			}

			boxPos.y += rect.height;
			return rect;
		}
		
		private static void DrawEventBox(EventBox box) 
		{
			Color originalContentColor = GUI.contentColor;
			Color originalBackgroundColor = GUI.backgroundColor;

			GUI.backgroundColor = box.ev.color;
			GUI.contentColor = Brightness(box.ev.color) < 0.5f ? Color.white : Color.black;
			
			if (GUI.Button(box.rect, box.content)) 
			{
				Selection.activeObject = box.ev.sender;
			}

			GUI.contentColor = originalContentColor;
			GUI.backgroundColor = originalBackgroundColor;
		}

		private static float Brightness(Color color) 
		{
			return 0.2126f * color.r + 0.7152f * color.g + 0.0722f * color.b;
		}
		
		private static void DrawConnection(EventCall ev, Bezier b) 
		{
			const float tangentSize = 50;

			float diff = b.end.x - b.start.x;
			diff = Mathf.Sign(diff) * Mathf.Min(Mathf.Abs(diff), tangentSize);

			Vector2 p1 = b.start;
			Vector2 p2 = b.end;
			Vector2 p3 = p1;
			Vector2 p4 = p2;

			if (b.startTangent == Bezier.Tangent.Auto) p3 += new Vector2(diff, 0);
			else if (b.startTangent == Bezier.Tangent.Negative) p3 -= new Vector2(Math.Abs(diff), 0);
			else if (b.startTangent == Bezier.Tangent.Positive) p3 += new Vector2(Math.Abs(diff), 0);
			else if (b.startTangent == Bezier.Tangent.NegativeUnscaled) p3 -= new Vector2(tangentSize, 0);
			else if (b.startTangent == Bezier.Tangent.PositiveUnscaled) p3 += new Vector2(tangentSize, 0);

			if (b.endTangent == Bezier.Tangent.Auto) p4 -= new Vector2(diff, 0);
			else if (b.endTangent == Bezier.Tangent.Negative) p4 -= new Vector2(Math.Abs(diff), 0);
			else if (b.endTangent == Bezier.Tangent.Positive) p4 += new Vector2(Math.Abs(diff), 0);
			else if (b.endTangent == Bezier.Tangent.NegativeUnscaled) p4 -= new Vector2(tangentSize, 0);
			else if (b.endTangent == Bezier.Tangent.PositiveUnscaled) p4 += new Vector2(tangentSize, 0);
			
			Color c = ev.color;
			Color prevColor = Handles.color;
			Handles.color = c;
			Handles.DrawBezier(p1, p2, p3, p4, c, (Texture2D) UnityEditor.Graphs.Styles.selectedConnectionTexture.image, EdgeGUI.EDGE_WIDTH);
			foreach (float trigger in EdgeTriggersTracker.GetTimings(ev)) 
			{
				Vector3 pos = EdgeGUI.CalculateBezierPoint(trigger, p1, p3, p4, p2);
				Handles.DrawSolidArc(pos, Vector3.back, pos + Vector3.up, 360, EdgeGUI.EDGE_WIDTH);
			}
			Handles.color = prevColor;
		}

		/// <param name="p2">if p is behind the screen, p2 is used to trace a line to p and raycast it to the near clipping camera of the scene camera</param>
		private static Vector2 WorldToGUIPoint(Vector3 p, Vector3 p2, out bool behindScreen) 
		{
			Camera cam = SceneView.currentDrawingSceneView.camera;
			Vector3 viewPos = cam.WorldToViewportPoint(p);
			behindScreen = viewPos.z < 0;

			if (behindScreen && cam.WorldToViewportPoint(p2).z < 0)
			{
				return Vector2.zero;
			}

			if (behindScreen) 
			{
				if (p2 == cam.transform.position) return Vector2.zero;
				
				Plane plane = new Plane(cam.transform.forward, cam.transform.position + cam.transform.forward * cam.nearClipPlane);
				Ray r = new Ray(p, p2 - p);

				if (!plane.Raycast(r, out float enter))
				{
					return Vector2.zero;
				}

				Vector3 proj = r.origin + r.direction * enter;

				viewPos = cam.WorldToViewportPoint(proj);
			}
			float scaleFactor = 1f;
			return new Vector2(viewPos.x *  cam.scaledPixelWidth, (1 - viewPos.y) * cam.scaledPixelHeight) * scaleFactor;
		}
	}
}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventsGraphWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventsVisualizer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f765f9e5d63c890448d227f118754401
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using UnityEngine.EventSystems;
using System.Reflection;
using UnityEngine.Events;
using System;
using System.Diagnostics;
using UnityEditor.Callbacks;
using System.Linq;
using Debug = UnityEngine.Debug;

namespace EventVisualizer.Base
{
    public static class EventsFinder
    {
	    public static bool NeedsGraphRefresh = false;
	    private static HashSet<Type> ComponentsThatCanHaveUnityEvent = new HashSet<Type>();
	    private static Dictionary<Type, bool> TmpSearchedTypes = new Dictionary<Type, bool>();
	    
        public static List<EventCall> FindAllEvents(GameObject[] roots, bool searchHierarchy = true)
        {
            HashSet<EventCall> calls = new HashSet<EventCall>();
			foreach (Type type in ComponentsThatCanHaveUnityEvent)
			{
				if(type.IsGenericTypeDefinition)
				{
					continue;
				}

				HashSet<UnityEngine.Object> selectedComponents = new HashSet<UnityEngine.Object>();
				if(roots is { Length: > 0 })
				{
					foreach(GameObject root in roots)
					{
						if(root != null)
						{
							if(searchHierarchy)
							{
								selectedComponents.UnionWith(root.GetComponentsInChildren(type));
							}
							else
							{
								selectedComponents.Add(root.GetComponent(type));
							}
						}
					}
				}
				else 
				{
					selectedComponents = new HashSet<UnityEngine.Object>(GameObject.FindObjectsOfType(type));
				}

				foreach (UnityEngine.Object caller in selectedComponents)
				{
					Component comp = caller as Component;
					if(comp != null)
					{
						ExtractDefaultEventTriggers(calls, comp);
						ExtractEvents(calls, comp);
					}
				}
			}
			return calls.ToList();
        }

		private static void ExtractEvents(HashSet<EventCall> calls, Component caller)
        {
            SerializedProperty iterator = new SerializedObject(caller).GetIterator();
            iterator.Next(true);
			RecursivelyExtractEvents(calls, caller, iterator, 0);
        }

		private static bool RecursivelyExtractEvents(HashSet<EventCall> calls, Component caller, SerializedProperty iterator, int level) 
		{
			bool hasData = true;

			do 
			{
				SerializedProperty persistentCalls = iterator.FindPropertyRelative("m_PersistentCalls.m_Calls");
				bool isUnityEvent = persistentCalls != null;
				if (isUnityEvent && persistentCalls.arraySize > 0) 
				{
					UnityEventBase unityEvent = Puppy.EditorHelper.GetTargetObjectOfProperty(iterator) as UnityEventBase;
					AddEventCalls(calls, caller, unityEvent, iterator.displayName, iterator.propertyPath);
				}
				hasData = iterator.Next(!isUnityEvent);
				if (hasData) 
				{
					if (iterator.depth < level)
					{
						return hasData;
					}
					
					if (iterator.depth > level)
					{
						hasData = RecursivelyExtractEvents(calls, caller, iterator, iterator.depth);
					}
				}
			}
			
			while (hasData);
			return false;
		}

        private static void ExtractDefaultEventTriggers(HashSet<EventCall> calls, Component caller)
        {
            EventTrigger eventTrigger = caller as EventTrigger;
            if (eventTrigger != null)
            {
                foreach (EventTrigger.Entry trigger in eventTrigger.triggers)
                {
					string name = trigger.eventID.ToString();
					AddEventCalls(calls, caller, trigger.callback, name, name);
                }
            }
        }

		private static void AddEventCalls(HashSet<EventCall> calls, Component caller, UnityEventBase unityEvent, string eventShortName, string eventFullName) 
		{
			for (int i = 0; i < unityEvent.GetPersistentEventCount(); i++) 
			{
				string methodName = unityEvent.GetPersistentMethodName(i);
				UnityEngine.Object receiver = unityEvent.GetPersistentTarget(i);

				if (receiver != null && methodName != null && methodName != "") 
				{
					calls.Add(new EventCall(caller, receiver, eventShortName, eventFullName, methodName, unityEvent));
				}
			}
		}
		
		[DidReloadScripts, InitializeOnLoadMethod]
		static void RefreshTypesThatCanHoldUnityEvents() 
		{
			Stopwatch sw = System.Diagnostics.Stopwatch.StartNew();
			
#if NET_4_6
			IEnumerable<Type> objects = AppDomain.CurrentDomain.GetAssemblies().Where(a => !a.IsDynamic)
				.SelectMany(a => a.GetTypes())
				.Where(t => typeof(Component).IsAssignableFrom(t));
#else
			var objects = AppDomain.CurrentDomain.GetAssemblies()
				.SelectMany(a => a.GetTypes())
				.Where(t => typeof(Component).IsAssignableFrom(t));
#endif

			foreach (Type obj in objects) 
			{
				if (RecursivelySearchFields<UnityEventBase>(obj)) 
				{
					ComponentsThatCanHaveUnityEvent.Add(obj);
				}
			}
			TmpSearchedTypes.Clear();
			
			Debug.Log("UnityEventVisualizer Updated Components that can have UnityEvents (" + ComponentsThatCanHaveUnityEvent.Count + "). Milliseconds: " + sw.Elapsed.TotalMilliseconds);
		}

		/// <summary>
		/// Search for types that have a field or property of type <typeparamref name="T"/> or can hold an object that can.
		/// </summary>
		/// <typeparam name="T">Needle</typeparam>
		/// <param name="type">Haystack</param>
		/// <returns>Can contain some object <typeparamref name="T"/></returns>
		static bool RecursivelySearchFields<T>(Type type) 
		{
			if (TmpSearchedTypes.TryGetValue(type, out bool wanted))
			{
				return wanted;
			}
			
			TmpSearchedTypes.Add(type, false);
			
			const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;
			foreach (Type fType in type.GetFields(flags)
				         .Where(f => !f.FieldType.IsPrimitive)
				         .Select(f => f.FieldType)
				         .Concat(type.GetProperties(flags)
					         .Select(p => p.PropertyType))) 
			{
				if (typeof(T).IsAssignableFrom(fType)) 
				{
					return TmpSearchedTypes[type] = true;
				}
				if (typeof(UnityEngine.Object).IsAssignableFrom(fType)) 
				{
					continue;
				}
				if (!TmpSearchedTypes.TryGetValue(fType, out wanted)) 
				{
					if (RecursivelySearchFields<T>(fType)) 
					{
						return TmpSearchedTypes[type] = true;
					}
				}
				else if (wanted) 
				{
					return TmpSearchedTypes[type] = true;
				}
			}

			if (type.IsArray) 
			{
				if (RecursivelySearchFields<T>(type.GetElementType())) 
				{
					return TmpSearchedTypes[type] = true;
				}
			}

			return false;
		}
	}
}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/EventsVisualizer.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/FindInGraphButton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 82c731ab640f84c418a051295fc47a71
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace EventVisualizer.Base
{
    public static class FindInGraphButton
    {
        [MenuItem("GameObject/EventGraph/Find in current graph", false, 0)]
        private static void FindEvents()
        {
            EventsGraphWindow window = EditorWindow.GetWindow<EventsGraphWindow>();
            if(window != null)
            {
                window.OverrideSelection(Selection.activeInstanceID);
            }
        }

		[MenuItem("GameObject/EventGraph/Graph just this", false, 0)]
		private static void GraphSelection()
		{
			EventsGraphWindow window = EditorWindow.GetWindow<EventsGraphWindow>();
			window.RebuildGraph(new GameObject[] { Selection.activeGameObject }, false);
		}
		
		[MenuItem("GameObject/EventGraph/Graph this hierarchy", false, 0)]
		private static void GraphSelectionHierarchy()
		{
			EventsGraphWindow window = EditorWindow.GetWindow<EventsGraphWindow>();
			window.RebuildGraph(new GameObject[] { Selection.activeGameObject }, true);
		}
	}

}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/FindInGraphButton.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/NodeData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e15846c0f71123d4e8406b6a6a30b732
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections.Generic;
using UnityEngine;

namespace EventVisualizer.Base
{
    [System.Serializable]
    public class NodeData
    {
	    private static Dictionary<int, NodeData> nodes = new Dictionary<int, NodeData>();
	    public static ICollection<NodeData> Nodes => nodes?.Values;
	    
        public Object Entity { get; private set; }
        public string Name => Entity != null ? Entity.name : "<Missing>";
        public List<EventCall> Outputs { get; private set; }
        public List<EventCall> Inputs { get; private set; }

        public NodeData(Object entity)
        {
	        Entity = entity;
	        Outputs = new List<EventCall>();
	        Inputs = new List<EventCall>();
        }
        
        public static void ClearAll() 
        {
            nodes.Clear();
        }

		public static void ClearSlots()
		{
			foreach(int node in nodes.Keys)
			{
				nodes[node].Outputs.Clear();
				nodes[node].Inputs.Clear();
			}
		}
        
        public static void RegisterEvent(EventCall eventCall)
        {
            NodeData nodeSender = CreateNode(eventCall.sender);
            NodeData nodeReceiver = CreateNode(eventCall.receiver);

			eventCall.nodeSender = nodeSender;
			eventCall.nodeReceiver = nodeReceiver;

			nodeSender.Outputs.Add(eventCall);
			nodeReceiver.Inputs.Add(eventCall);
        }
        
        private static NodeData CreateNode(Object entity)
        {
			int id = entity.GetInstanceID();

			if (!nodes.TryGetValue(id, out NodeData nodeData))
            {
                nodes.Add(id, nodeData = new NodeData(entity));
            }
			return nodeData;
		}
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/NodeData.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/NodeGUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 387c6d86b11d7d241a2da4a68b1dd9a5
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;
using UnityEditor;
using System.Linq;
using UnityEditor.Graphs;
using System.Collections.Generic;

namespace EventVisualizer.Base
{
    public class NodeGUI : Node
    {
	    private Texture2D icon;
	    private NodeData runtimeInstance;
	    
	    public bool IsValid => runtimeInstance != null;
	    public override string title => IsValid ? runtimeInstance.Name : "<Missing>";

	    static public NodeGUI Create(NodeData dataInstance)
        {
			bool isGameObject = dataInstance.Entity is GameObject;

			NodeGUI node = CreateInstance<NodeGUI>();
            node.Initialize(dataInstance);
            node.name = dataInstance.Entity.GetInstanceID().ToString();
			node.icon = (Texture2D)EditorGUIUtility.IconContent(isGameObject?"GameObject Icon" : "ScriptableObject Icon").image;
			return node;
        }
	    
	    private void Initialize(NodeData instance)
	    {
		    hideFlags = HideFlags.DontSave;
			
		    runtimeInstance = instance;
		    position = new Rect(Vector2.one * Random.Range(0, 500), Vector2.zero);

		    PopulateSlots();
	    }
	    
		public override void NodeUI(GraphGUI host)
		{
			base.NodeUI(host);
			if (icon != null)
			{
				GUI.DrawTexture(new Rect(Vector2.one * 5, new Vector2(20, 20)), icon);
			}
		}

		private void PopulateSlots()
        {
            foreach (EventCall call in runtimeInstance.Outputs)
            {
                string eventName = call.eventShortName;
                string eventTitle = ObjectNames.NicifyVariableName(eventName);
                
                if (outputSlots.All(s => s.title != eventTitle))
                {
                    Slot slot = AddOutputSlot(eventName);
                    slot.title = eventTitle;
                }
            }

            foreach (EventCall call in runtimeInstance.Inputs)
            {
                string methodPath = call.MethodFullPath;
                string methodName = ObjectNames.NicifyVariableName(methodPath);
                if (inputSlots.All(s => s.title != methodName))
                {
                    Slot slot = AddInputSlot(methodPath);
                    slot.title = methodName;
                }
            }
        }

        public void PopulateEdges()
        {
            foreach (Slot outSlot in outputSlots)
            {
                List<EventCall> outCalls = runtimeInstance.Outputs.FindAll(call => call.eventShortName == outSlot.name);

                foreach (EventCall call in outCalls)
                {
                    Node targetNode = graph[call.receiver.GetInstanceID().ToString()];
                    Slot inSlot = targetNode[call.MethodFullPath];
					
					if (graph.Connected(outSlot, inSlot))
					{
						Edge existingEdge = graph.edges.Find(e => e.fromSlot == outSlot && e.toSlot == inSlot);
						graph.RemoveEdge(existingEdge);
					}

					Edge edge = graph.Connect(outSlot, inSlot);
					call.OnTriggered += (() => EdgeTriggersTracker.RegisterTrigger(edge, call));
				}
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/NodeGUI.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/PuppyEditor/EditorHelper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: df6a2a6945f2bdd459f360036853fb7f
# ASMDEF: ldx.framework.editor.dll
# ---
//https://github.com/lordofduct/spacepuppy-unity-framework/blob/master/SpacepuppyBaseEditor/EditorHelper.cs
// Removed some functions from the original file that aren't needed here

using System;
using System.Collections;
using UnityEditor;
using System.Linq;
using System.Reflection;

namespace EventVisualizer.Puppy
{
	public static class EditorHelper
	{
		#region SerializedProperty Helpers
		
		public static object GetTargetObjectOfProperty(SerializedProperty prop)
		{
			string path = prop.propertyPath.Replace(".Array.data[", "[");
			object obj = prop.serializedObject.targetObject;
			string[] elements = path.Split('.');
			foreach (string element in elements)
			{
				if (element.Contains("["))
				{
					string elementName = element.Substring(0, element.IndexOf("["));
					int index = System.Convert.ToInt32(element.Substring(element.IndexOf("[")).Replace("[", "").Replace("]", ""));
					obj = GetValue_Imp(obj, elementName, index);
				}
				else
				{
					obj = GetValue_Imp(obj, element);
				}
			}
			return obj;
		}
		
		public static object GetTargetObjectWithProperty(SerializedProperty prop)
		{
			string path = prop.propertyPath.Replace(".Array.data[", "[");
			object obj = prop.serializedObject.targetObject;
			string[] elements = path.Split('.');
			foreach (string element in elements.Take(elements.Length - 1))
			{
				if (element.Contains("["))
				{
					string elementName = element.Substring(0, element.IndexOf("["));
					int index = System.Convert.ToInt32(element.Substring(element.IndexOf("[")).Replace("[", "").Replace("]", ""));
					obj = GetValue_Imp(obj, elementName, index);
				}
				else
				{
					obj = GetValue_Imp(obj, element);
				}
			}
			return obj;
		}

		private static object GetValue_Imp(object source, string name)
		{
			if (source == null)
				return null;
			Type type = source.GetType();

			while (type != null)
			{
				FieldInfo f = type.GetField(name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance);
				if (f != null)
					return f.GetValue(source);

				PropertyInfo p = type.GetProperty(name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
				if (p != null)
					return p.GetValue(source, null);

				type = type.BaseType;
			}
			return null;
		}

		private static object GetValue_Imp(object source, string name, int index)
		{
			IEnumerable enumerable = GetValue_Imp(source, name) as System.Collections.IEnumerable;
			if (enumerable == null) return null;
			IEnumerator enm = enumerable.GetEnumerator();

			for (int i = 0; i <= index; i++)
			{
				if (!enm.MoveNext()) return null;
			}
			return enm.Current;
		}

		#endregion
	}

}
# --- end Packages/com_ldx_framework/Editor/Third Party/EventVisualizer/Editor/PuppyEditor/EditorHelper.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/CallbackManager.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 82a67790066696745bdebd45b38f9c82
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System;
using System.Collections.Generic;
using UnityEditor;

namespace MarkupAttributes.Editor
{
    public enum CallbackEvent
    {
        BeforeProperty,
        ReplaceProperty,
        AfterProperty
    }

    internal class CallbackManager
    {
        private readonly bool usedByShaderGUI;
        private readonly SerializedProperty[] properties;
        private readonly MaterialPropertiesWrapper materialProperties;
        private readonly MaterialEditor materialEditor;

        private readonly Dictionary<string, int> propertyIndices = new Dictionary<string, int>();
        private readonly Dictionary<(int, CallbackEvent), Action<SerializedProperty>> callbacks;
        private readonly Dictionary<(int, CallbackEvent), Action<MaterialEditor, MaterialProperty[], MaterialProperty>> shaderGuiCallbacks;

        public CallbackManager(SerializedProperty[] props)
        {
            properties = props;
            callbacks = new Dictionary<(int, CallbackEvent), Action<SerializedProperty>>();
            for (int i = 0; i < props.Length; i++)
            {
                if (!propertyIndices.ContainsKey(props[i].name))
                    propertyIndices.Add(props[i].name, i);
            }
        }

        public CallbackManager(MaterialEditor materialEditor, MaterialPropertiesWrapper materialProperties)
        {
            usedByShaderGUI = true;
            this.materialEditor = materialEditor;
            this.materialProperties = materialProperties;
            shaderGuiCallbacks = new Dictionary<(int, CallbackEvent), Action<MaterialEditor, MaterialProperty[], MaterialProperty>>();
            for (int i = 0; i < materialProperties.value.Length; i++)
            {
                if (!propertyIndices.ContainsKey(materialProperties.value[i].name))
                    propertyIndices.Add(materialProperties.value[i].name, i);
            }
        }

        public void AddCallback(SerializedProperty property, CallbackEvent callbackType, 
            Action<SerializedProperty> action)
        {
            if (propertyIndices.ContainsKey(property.name))
            {
                var key = (propertyIndices[property.name], callbackType);
                if (callbacks.ContainsKey(key))
                {
                    UnityEngine.Debug.LogError("Callback for property " + property.name +
                        " with type " + callbackType.ToString() + " already exists.");
                }
                else
                {
                    callbacks.Add(key, action);
                }
            }
        }

        public void AddCallback(MaterialProperty property, CallbackEvent callbackType,
            Action<MaterialEditor, MaterialProperty[], MaterialProperty> action)
        {

            if (propertyIndices.ContainsKey(property.name))
            {
                var key = (propertyIndices[property.name], callbackType);
                if (shaderGuiCallbacks.ContainsKey(key))
                {
                    UnityEngine.Debug.LogError("Callback for property " + property.name +
                        " with type " + callbackType.ToString() + " already exists.");
                }
                else
                {
                    shaderGuiCallbacks.Add(key, action);
                }
            }
        }

        public bool InvokeCallback(int index, CallbackEvent hookType)
        {
            var id = (index, hookType);
            if (!usedByShaderGUI)
            {
                if (callbacks.ContainsKey(id))
                {
                    callbacks[id].Invoke(properties[index]);
                    return true;
                }
            }
            else
            {
                if (shaderGuiCallbacks.ContainsKey(id))
                {
                    shaderGuiCallbacks[id].Invoke(materialEditor, 
                        materialProperties.value, materialProperties.value[index]);
                    return true;
                }
            }
            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/CallbackManager.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/ConditionWrapper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 818db179e4cec2b43ba9f373f3ddda24
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEditor;
using UnityEngine;

namespace MarkupAttributes.Editor
{
    internal class ConditionWrapper
    {
        private readonly bool alwaysTrue;
        private readonly bool alwaysFalse;
        private readonly bool inverted;

        private readonly TargetObjectWrapper targetObjectWrapper;
        private readonly FieldInfo fieldInfo;
        private readonly PropertyInfo propertyInfo;
        private readonly MethodInfo methodInfo;
        private readonly object memberValue;
        private readonly bool hasMemberValue;

        private readonly int materialPropertyIndex;
        private readonly Material targetMaterial;
        private readonly string shaderKeyword;
        private readonly bool isShaderKeywordGlobal;
        private readonly MaterialPropertiesWrapper materialProperties;

        public static ConditionWrapper Create(ConditionDescriptor descriptor, TargetObjectWrapper targetObjectWrapper)
        {
            if (descriptor.fixedValue.HasValue)
                return new ConditionWrapper(descriptor.fixedValue.Value);

            if (targetObjectWrapper != null && targetObjectWrapper.Target != null)
            {
                object targetObject = targetObjectWrapper.Target;
                Type type = targetObject.GetType();

                FieldInfo fieldInfo = type.GetField(descriptor.memberName, MarkupEditorUtils.DefaultBindingFlags);
                if (fieldInfo != null)
                {
                    if (IsConditionValid(fieldInfo.FieldType, descriptor))
                        return new ConditionWrapper(descriptor.isInverted, targetObjectWrapper, fieldInfo, null, null, descriptor.value, descriptor.hasValue);
                }

                PropertyInfo propertyInfo = type.GetProperty(descriptor.memberName, MarkupEditorUtils.DefaultBindingFlags);
                if (propertyInfo != null)
                {
                    if (IsConditionValid(propertyInfo.PropertyType, descriptor))
                        return new ConditionWrapper(descriptor.isInverted, targetObjectWrapper, null, propertyInfo, null, descriptor.value, descriptor.hasValue);
                }

                MethodInfo methodInfo = type.GetMethod(descriptor.memberName, MarkupEditorUtils.DefaultBindingFlags);
                if (methodInfo != null && methodInfo.GetParameters().Length == 0)
                {
                    if (IsConditionValid(methodInfo.ReturnType, descriptor))
                        return new ConditionWrapper(descriptor.isInverted, targetObjectWrapper, null, null, methodInfo, descriptor.value, descriptor.hasValue);
                }
            }
            return null;
        }

        public static ConditionWrapper Create(ConditionDescriptor descriptor, 
            MaterialPropertiesWrapper materialProperties, Material targetMaterial)
        {
            if (descriptor.fixedValue.HasValue)
                return new ConditionWrapper(descriptor.fixedValue.Value);

            var props = materialProperties.value;
            for (int i = 0; i < props.Length; i++)
            {
                var materialProperty = props[i];
                if ((materialProperty.propertyType == UnityEngine.Rendering.ShaderPropertyType.Float
                                    || materialProperty.propertyType == UnityEngine.Rendering.ShaderPropertyType.Range)
                                    && materialProperty.name == descriptor.memberName)
                {
                    return new ConditionWrapper(descriptor.isInverted, i, materialProperties,
                        null, null, false);
                }
            }

            string keyword = ShaderAttributesParser.GetKeyword(descriptor.memberName, out bool isGlobal);
            return new ConditionWrapper(descriptor.isInverted, -1, null, targetMaterial, keyword, isGlobal);
        }

        private ConditionWrapper(bool inverted, TargetObjectWrapper targetObjectWrapper, 
            FieldInfo fieldInfo, PropertyInfo propertyInfo, MethodInfo methodInfo, object memberValue, bool hasValue)
        {
            this.inverted = inverted;
            this.targetObjectWrapper = targetObjectWrapper;
            this.fieldInfo = fieldInfo;
            this.propertyInfo = propertyInfo;
            this.methodInfo = methodInfo;
            this.memberValue = memberValue;
            this.hasMemberValue = hasValue;
        }

        private ConditionWrapper(bool inverted, int materialPropertyIndex, 
            MaterialPropertiesWrapper materialPropertiesWrapper,
            Material targetMaterial, string shaderKeyword, bool isShaderKeywordGlobal)
        {
            this.inverted = inverted;
            this.materialPropertyIndex = materialPropertyIndex;
            this.materialProperties = materialPropertiesWrapper;
            this.targetMaterial = targetMaterial;
            this.shaderKeyword = shaderKeyword;
            this.isShaderKeywordGlobal = isShaderKeywordGlobal;
        }

        private ConditionWrapper(bool value)
        {
            if (value)
                alwaysTrue = true;
            else
                alwaysFalse = false;
        }

        public bool GetValue()
        {
            if (alwaysTrue) return true;
            if (alwaysFalse) return false;

            object target = null;
            if (targetObjectWrapper != null)
                target = targetObjectWrapper.Target;

            if (target != null)
            {
                if (fieldInfo != null)
                    return FromMemberValue(fieldInfo.GetValue(target));

                if (propertyInfo != null)
                    return FromMemberValue(propertyInfo.GetValue(target));

                if (methodInfo != null)
                    return FromMemberValue(methodInfo.Invoke(target, null));
            }

            if (materialProperties != null)
            {
                return (materialProperties.value[materialPropertyIndex].floatValue > 0) ^ inverted;
            }

            if (isShaderKeywordGlobal && shaderKeyword != null)
            {
                return Shader.IsKeywordEnabled(shaderKeyword) ^ inverted;
            }

            if (targetMaterial != null && shaderKeyword != null)
            {
                return targetMaterial.IsKeywordEnabled(shaderKeyword) ^ inverted;
            }

            return false;
        }

        private bool FromMemberValue(object value)
        {
            if (hasMemberValue)
                return value.Equals(memberValue) ^ inverted;
            else
                return (bool)value ^ inverted;
        }

        private static bool IsConditionValid(Type type, ConditionDescriptor descriptor) =>
            type == typeof(bool) || descriptor.hasValue;
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/ConditionWrapper.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/EditorLayoutDataBuilder.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b1e629edeb5d2754c8204c94ebe7f259
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEditor;

namespace MarkupAttributes.Editor
{
    internal class InlineEditorData
    {
        public UnityEditor.Editor editor;
        public InlineEditorMode mode;
        public bool enabled = true;

        public InlineEditorData(UnityEditor.Editor editor, InlineEditorAttribute attribute)
        {
            this.editor = editor;
            mode = attribute.Mode;
        }
    }

    internal static class EditorLayoutDataBuilder
    {
        public static void BuildLayoutData(SerializedObject serializedObject,
            out SerializedProperty[] allProps,
            out SerializedProperty[] topLevelProps,
            out List<PropertyLayoutData> layoutData,
            out Dictionary<SerializedProperty, InlineEditorData> inlineEditors,
            out List<TargetObjectWrapper> targetsRequireUpdate)
        {
            var props = new List<SerializedProperty>();
            layoutData = new List<PropertyLayoutData>();
            inlineEditors = new Dictionary<SerializedProperty, InlineEditorData>();
            targetsRequireUpdate = new List<TargetObjectWrapper>();
            Type targetType = serializedObject.targetObject.GetType();

            topLevelProps = MarkupEditorUtils.GetSerializedObjectProperties(serializedObject);
            GetLayoutDataForSiblings(null, topLevelProps, targetType, 
                new TargetObjectWrapper(serializedObject.targetObject),
                props, layoutData, inlineEditors, targetsRequireUpdate);
            allProps = props.ToArray();
        }

        private static int GetLayoutDataForSiblings(InspectorLayoutGroup scopeGroup,
            SerializedProperty[] siblings, Type targetType, TargetObjectWrapper targetObjectWrapper,
            List<SerializedProperty> allProps, List<PropertyLayoutData> layoutData,
            Dictionary<SerializedProperty, InlineEditorData> inlineEditors, List<TargetObjectWrapper> targetObjectWrappers)
        {
            int scopesToClose = 0;
            for (int i = 0; i < siblings.Length; i++)
            {
                var sibling = siblings[i];
                var groups = new List<InspectorLayoutGroup>();
                if (scopeGroup != null && i == 0)
                {
                    groups.Add(scopeGroup);
                }

                FieldInfo fieldInfo = targetType.GetField(sibling.name, MarkupEditorUtils.DefaultBindingFlags);

                PropertyLayoutData data = null;
                if (fieldInfo != null)
                {
                    // layout groups
                    var groupAttribues = fieldInfo.GetCustomAttributes<LayoutGroupAttribute>(true).ToArray();

                    bool isPropertyHidden = false;
                    foreach (var groupAttribute in groupAttribues)
                    {
                        var group = CreateGroupFromAttribute(ref isPropertyHidden, 
                            groupAttribute, sibling, targetObjectWrapper);
                        groups.Add(group);
                    }

                    // conditionals 
                    var hideConditions = new List<ConditionWrapper>();
                    foreach (var attribute in fieldInfo.GetCustomAttributes<HideIfAttribute>())
                    {
                        hideConditions.Add(ConditionWrapper.Create(attribute.Condition, targetObjectWrapper));
                    }

                    var disableConditions = new List<ConditionWrapper>();
                    foreach (var attribute in fieldInfo.GetCustomAttributes<DisableIfAttribute>())
                    {
                        disableConditions.Add(ConditionWrapper.Create(attribute.Condition, targetObjectWrapper));
                    }

                    var end = fieldInfo.GetCustomAttribute<EndGroupAttribute>();
                    data = new PropertyLayoutData(groups, hideConditions, disableConditions, end);
                    data.alwaysHide = isPropertyHidden;
                    data.isTopLevel = scopeGroup == null;
                    data.numberOfScopesToClose = scopesToClose;
                    scopesToClose = 0;
                    

                    // InlineEditors
                    var inline = fieldInfo.GetCustomAttribute<InlineEditorAttribute>();
                    if (inline != null)
                        inlineEditors.Add(sibling, new InlineEditorData(null, inline));
                }

                allProps.Add(sibling);
                layoutData.Add(data);

                // Nested properties
                if (sibling.propertyType == SerializedPropertyType.Generic
                    && fieldInfo != null)
                {
                    var markedUp = fieldInfo.GetCustomAttribute<MarkedUpTypeAttribute>();
                    if (markedUp == null)
                        markedUp = fieldInfo.FieldType.GetCustomAttribute<MarkedUpTypeAttribute>(true);

                    if (markedUp != null)
                    {
                        var subTarget = MarkupEditorUtils.GetTargetObjectOfProperty(sibling);
                        var subTargetType = subTarget.GetType();
                        var subTargetWrapper = new TargetObjectWrapper(subTarget, sibling);
                        if (subTargetType.IsValueType)
                            targetObjectWrappers.Add(subTargetWrapper);
                        if (subTargetType != targetType)
                        {
                            var children = MarkupEditorUtils.GetChildrenOfProperty(sibling).ToArray();
                            if (children != null && children.Length > 0)
                            {
                                data.includeChildren = false;
                                data.alwaysHide |= !markedUp.ShowControl;
                                var subScopeGroup = InspectorLayoutGroup.CreateScopeGroup(
                                    "./" + sibling.name, sibling, subTargetType.FullName, 
                                    markedUp.ShowControl, markedUp.IndentChildren);
                                scopesToClose += GetLayoutDataForSiblings(
                                    subScopeGroup, children, subTargetType, subTargetWrapper, 
                                    allProps, layoutData, inlineEditors, targetObjectWrappers);
                                scopesToClose += 1;
                            }
                        }
                    }
                }
            }
            return scopesToClose;
        }

        private static InspectorLayoutGroup CreateGroupFromAttribute(ref bool isHidden,
            LayoutGroupAttribute attribute, SerializedProperty property, TargetObjectWrapper targetObjectWrapper)
        {
            ConditionWrapper conditionWrapper = null;
            if (attribute.HasCondition)
            {
                conditionWrapper = ConditionWrapper.Create(attribute.Condition, targetObjectWrapper);
                if (conditionWrapper == null)
                    return null;
            }

            TogglableValueWrapper togglableValueWrapper = null;
            if (attribute.Toggle)
            {
                togglableValueWrapper = TogglableValueWrapper.Create(property);
                if (togglableValueWrapper == null)
                    return null;
                isHidden = true;
            }

            return new InspectorLayoutGroup(attribute, conditionWrapper, togglableValueWrapper);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/EditorLayoutDataBuilder.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/HeaderlessMaterialEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 3c2fabac705015648a641e96f00af8fc
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using UnityEditor;
using UnityEditorInternal;

namespace MarkupAttributes.Editor
{
    internal class HeaderlessMaterialEditor : MaterialEditor
    {
        protected override void OnHeaderGUI()
        {
            InternalEditorUtility.SetIsInspectorExpanded(target, true);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/HeaderlessMaterialEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/InspectorLayoutController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 0219c6840910b53418ee2e1185a2773c
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace MarkupAttributes.Editor
{
    internal class InspectorLayoutController
    {
        public bool IncludeChildren(int index) => layoutData[index] == null || layoutData[index].includeChildren;
        public bool IsPropertyVisible(int index) => layoutData[index] == null || layoutData[index].IsVisible();
        public bool IsPropertyEnabled(int index) => layoutData[index] == null || layoutData[index].IsEnabled();

        public bool IsTopLevel(int index) => layoutData[index] == null || layoutData[index].isTopLevel;
        public bool ScopeEnabled => groupsStack.Count == 0 || groupsStack.Peek().isEnabled;
        public bool ScopeVisible => groupsStack.Count == 0 || groupsStack.Peek().isVisible;
        
        private readonly string defaultPrefsPrefix;
        private readonly PropertyLayoutData[] layoutData;
        private readonly Stack<InspectorLayoutGroup> groupsStack = new Stack<InspectorLayoutGroup>();
        private List<string> currentPath = new List<string>();
        private string prefsPrefix = null;
        private int localScopeStart = -1;
        private string activeTabName;

        public InspectorLayoutController(string prefsPrefix, PropertyLayoutData[] layoutData)
        {
            defaultPrefsPrefix = prefsPrefix;
            this.layoutData = layoutData;
        }

        public void Begin()
        {
            groupsStack.Clear();
            currentPath.Clear();
            prefsPrefix = defaultPrefsPrefix;
            localScopeStart = -1;
            activeTabName = null;
        }

        public void Finish()
        {
            EndAll();
        }

        public void BeforeProperty(int index)
        {
            var layout = layoutData[index];
            if (layout == null) return;

            if (layout.end != null)
            {
                EndGroupsUntill(layout.end.GroupName);
            }

            for (int i = 0; i < layout.numberOfScopesToClose; i++)
            {
                EndLocalScope();
            }

            if (layout.groups == null)
                return;

            foreach (var group in layout.groups)
            {
                SetScope(group.pathArray);
                bool isVisible = ScopeVisible;
                bool isEnabled = ScopeEnabled;

                if (group.data.Type == LayoutGroupType.LocalScope)
                {
                    group.cachedLocalScopeStart = localScopeStart;
                    localScopeStart = groupsStack.Count;
                }

                if (ScopeVisible)
                {
                    BeginGroup(group, ref isVisible, ref isEnabled);
                }

                group.isVisible = isVisible;
                group.isEnabled = isEnabled;
                groupsStack.Push(group);
            }
        }

        private void BeginGroup(InspectorLayoutGroup group, ref bool isVisible, ref bool isEnabled)
        {
            if (group.data.Space > 0)
                GUILayout.Space(group.data.Space);

            if (group.data.Type == LayoutGroupType.LocalScope)
            {
                group.guiHandle = new MarkupGUI.GroupHandle(false, false);
                if (group.localScope.indent)
                    EditorGUI.indentLevel += 1;
                isVisible &= !group.localScope.showControl || group.localScope.IsExpanded;
                group.cachedPrefsPrefix = prefsPrefix;
                prefsPrefix = group.localScope.prefsPrefixOverride;
            }

            if (group.data.Type == LayoutGroupType.DisableIf)
            {
                isEnabled &= !group.data.conditionWrapper.GetValue();
            }

            if (group.data.Type == LayoutGroupType.HideIf)
            {
                isVisible &= !group.data.conditionWrapper.GetValue();
            }

            if (group.data.Type == LayoutGroupType.Tab)
            {
                isVisible &= (activeTabName == null || activeTabName == group.name);
            }

            if (group.data.Type == LayoutGroupType.TabScope)
            {
                bool boxed = group.data.BodyStyle == MarkupBodyStyle.Box;
                string prefsName = GetPrefsName();
                int activeTab = MarkupAttributesPrefs.GetInt(prefsName);
                group.guiHandle = MarkupGUI.BeginTabsGroup(ref activeTab, group.data.Tabs, boxed);
                MarkupAttributesPrefs.SetInt(prefsName, activeTab);
                group.cachedActiveTab = activeTabName;
                activeTabName = group.data.Tabs[activeTab];
            }

            if (group.data.Type == LayoutGroupType.Horizontal)
            {
                group.guiHandle = new MarkupGUI.GroupHandle(false, true);
                EditorGUIUtility.labelWidth = group.data.LabelWidth;
                EditorGUILayout.BeginHorizontal(GUIStyle.none);
            }

            if (group.data.Type == LayoutGroupType.Vertical)
            {
                string prefsName = GetPrefsName();
                bool isExpanded = MarkupAttributesPrefs.GetBool(prefsName);

                group.guiHandle = MarkupGUI.BeginGenericVerticalGroup(
                    ref isExpanded, ref isEnabled,
                    group.data.HeaderStyle, group.data.BodyStyle, group.name,
                    group.data.togglableValueWrapper);

                MarkupAttributesPrefs.SetBool(prefsName, isExpanded);
                isVisible &= isExpanded;
            }
        }
        
        private string GetPrefsName()
        {
            if (prefsPrefix != null)
            {
                return prefsPrefix + "/" + string.Join("/", currentPath.ToArray(),
                    localScopeStart + 1, currentPath.Count - localScopeStart - 1);
            }
            else
            {
                return defaultPrefsPrefix + "/" + string.Join("/", currentPath);
            }
        }

        private void SetScope(string[] path)
        {
            if (path == null || path.Length < 1)
            {
                EndAll();
                currentPath.Add("");
                return;
            }

            if (path.Length > 1 && (path[0] == "." || path[0] == ".."))
            {
                if (currentPath.Count > 0 && path[0] == "..")
                {
                    EndGroup();
                }
                currentPath.Add(path.Last());
                return;
            }

            var newPath = new List<string>();
            int i = 0;
            int j = 0;
            while (j < path.Length && i < currentPath.Count)
            {
                if (i <= localScopeStart)
                {
                    newPath.Add(currentPath[i]);
                }
                else
                {
                    if (path[j] != currentPath[i])
                    {
                        break;
                    }
                    newPath.Add(path[j]);
                    j++;
                }
                i++;
            }

            if (j < path.Length)
                newPath.Add(path.Last());

            int groupsToRemove = currentPath.Count - i;
            for (int k = 0; k < groupsToRemove; k++)
            {
                EndGroup();
            }

            currentPath = newPath;
        }

        private void EndGroupsUntill(string name)
        {
            int limit = name != null ? -1 :
                Mathf.Max(-1, currentPath.Count - 2);
            limit = Mathf.Max(limit, localScopeStart);
            int index = currentPath.Count - 1;
            while (index > limit)
            {
                if (currentPath[index] != name)
                {
                    EndGroup();
                    index -= 1;
                }
                else
                {
                    EndGroup();
                    break;
                }     
            }
        }

        private void EndLocalScope()
        {
            int count = localScopeStart;
            while (groupsStack.Count > count)
            {
                EndGroup();
            }
        }

        private void EndAll()
        {
            while (groupsStack.Count > 0)
            {
                EndGroup();
            }
        }

        private void EndGroup()
        {
            if (groupsStack.Count > 0)
            {
                InspectorLayoutGroup group = groupsStack.Pop();
                if (currentPath.Count > 0)
                    currentPath.RemoveAt(currentPath.Count - 1);

                if (group.cachedLocalScopeStart.HasValue)
                    localScopeStart = group.cachedLocalScopeStart.Value;
                if (ScopeVisible)
                {
                    if (group.cachedPrefsPrefix != null)
                        prefsPrefix = group.cachedPrefsPrefix;

                    if (group.cachedActiveTab != null)
                        activeTabName = group.cachedActiveTab;

                    if (group.guiHandle.HasValue)
                        group.guiHandle.Value.End();

                    group.cachedPrefsPrefix = null;
                    group.cachedActiveTab = null;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/InspectorLayoutController.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/InspectorLayoutGroup.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 397caf8001d83484daf9dfdcadbd4f62
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System.Linq;
using UnityEditor;

namespace MarkupAttributes.Editor
{
    internal class InspectorLayoutGroup
    {
        public readonly Params data;
        public readonly string[] pathArray;
        public readonly string name;
        public readonly LocalScopeData localScope;
        public bool isVisible;
        public bool isEnabled;
        public string cachedPrefsPrefix = null;
        public int? cachedLocalScopeStart = null;
        public string cachedActiveTab = null;
        public MarkupGUI.GroupHandle? guiHandle;

        public int Order()
        {
            if (data.Type == LayoutGroupType.LocalScope)
                return pathArray.Length - 1000;
            if (pathArray.Length > 0 && (pathArray[0] == "." || pathArray[0] == ".."))
                return pathArray.Length + 1000;
            return pathArray.Length;
        }

        public static InspectorLayoutGroup CreateScopeGroup(string path, 
            SerializedProperty property, string prefsPrefix,
            bool showControl, bool indent)
        {
            return new InspectorLayoutGroup(path, 
                new LocalScopeData(property, prefsPrefix, showControl, indent));
        }

        public InspectorLayoutGroup(LayoutGroupAttribute attribute, ConditionWrapper conditionWrapper = null, 
            TogglableValueWrapper togglableValueWrapper = null)
        {
            data = new Params(attribute, conditionWrapper, togglableValueWrapper);
            SetNameAndPathArray(attribute.Path, out pathArray, out name);
        }

        private InspectorLayoutGroup(string path, LocalScopeData scopeData)
        {
            data = new Params(path, LayoutGroupType.LocalScope);
            localScope = scopeData;
            SetNameAndPathArray(path, out pathArray, out name);
        }

        private void SetNameAndPathArray(string path, 
            out string[] pathArray, out string name)
        {
            if (path != null)
            {
                pathArray = path.Split('/');
                if (pathArray.Length > 0)
                    name = pathArray.Last();
                else
                    name = "";
            }
            else
            {
                pathArray = new string[0];
                name = "";
            }
        }

        public class Params
        {
            public string Path => path;
            public LayoutGroupType Type => type;
            public MarkupHeaderFlags HeaderStyle => headerStyle;
            public MarkupBodyStyle BodyStyle => bodyStyle;
            public float LabelWidth => labelWidth;
            public float Space => space;
            public string[] Tabs => tabs;

            public readonly ConditionWrapper conditionWrapper;
            public readonly TogglableValueWrapper togglableValueWrapper;
            private readonly string path;
            private readonly LayoutGroupType type;
            private readonly MarkupHeaderFlags headerStyle;
            private readonly MarkupBodyStyle bodyStyle;
            private readonly float labelWidth;
            private readonly float space;
            private readonly string[] tabs;

            public Params(LayoutGroupAttribute attribute, ConditionWrapper conditionWrapper,
                TogglableValueWrapper togglableValueWrapper)
            {
                path = attribute.Path;
                type = attribute.Type;
                headerStyle = attribute.HeaderFlags;
                bodyStyle = attribute.BodyStyle;
                labelWidth = attribute.LabelWidth;
                space = attribute.Space;
                tabs = attribute.Tabs;
                this.conditionWrapper = conditionWrapper;
                this.togglableValueWrapper = togglableValueWrapper;
            }

            public Params(string path, LayoutGroupType type)
            {
                this.path = path;
                this.type = type;
            }
        }

        public class LocalScopeData
        {
            public readonly bool showControl;
            public readonly bool indent;
            public readonly string prefsPrefixOverride;
            private readonly SerializedProperty serializedProperty;
            public bool IsExpanded => serializedProperty.isExpanded;

            public LocalScopeData(SerializedProperty property, string prefsPrefix, bool showControl, bool indent)
            {
                serializedProperty = property;
                prefsPrefixOverride = prefsPrefix;
                this.showControl = showControl;
                this.indent = indent;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/InspectorLayoutGroup.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkedUpEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 62168cb1e92a5494b89909fd2443875b
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace MarkupAttributes.Editor
{
    [CanEditMultipleObjects]
    public class MarkedUpEditor : UnityEditor.Editor
    {
        private SerializedProperty[] allProps;
        private SerializedProperty[] firstLevelProps;
        private List<PropertyLayoutData> layoutData;

        private InspectorLayoutController layoutController;
        private CallbackManager callbackManager;
        private Dictionary<SerializedProperty, InlineEditorData> inlineEditors;
        private List<TargetObjectWrapper> targetsRequireUpdate;

        protected virtual void OnInitialize() { }
        protected virtual void OnCleanup() { }
        protected void AddCallback(SerializedProperty property, CallbackEvent type, Action<SerializedProperty> callback)
        {
            callbackManager.AddCallback(property, type, callback);
        }

        protected void OnEnable()
        {
            InitializeMarkedUpEditor();
        }

        protected void OnDisable()
        {
            CleanupMarkedUpEditor();
        }

        public override void OnInspectorGUI()
        {
            DrawMarkedUpInspector();
        }

        protected void InitializeMarkedUpEditor()
        {
            EditorLayoutDataBuilder.BuildLayoutData(serializedObject, out allProps, 
                out firstLevelProps, out layoutData, out inlineEditors, out targetsRequireUpdate);
            layoutController = new InspectorLayoutController(target.GetType().FullName,
                layoutData.ToArray());
            callbackManager = new CallbackManager(firstLevelProps);
            OnInitialize();
        }

        protected void CleanupMarkedUpEditor()
        {
            OnCleanup();
            foreach (var item in inlineEditors)
            {
                DestroyImmediate(item.Value.editor);
            }
        }

        protected bool DrawMarkedUpInspector()
        {
            EditorGUI.BeginChangeCheck();
            serializedObject.UpdateIfRequiredOrScript();

            CreateInlineEditors();
            UpdateTargets();
            int topLevelIndex = 1;
            layoutController.Begin();

            if (!MarkupGUI.IsInsideInlineEditor)
            {
                using (new EditorGUI.DisabledScope(true))
                {
                    EditorGUILayout.PropertyField(allProps[0]);
                }
            }

            for (int i = 1; i < allProps.Length; i++)
            {
                layoutController.BeforeProperty(i);
                if (layoutController.ScopeVisible)
                {
                    using (new EditorGUI.DisabledScope(!layoutController.ScopeEnabled))
                    {
                        DrawProperty(i, topLevelIndex);
                    }
                }

                if (layoutController.IsTopLevel(i))
                    topLevelIndex += 1;
            }
            layoutController.Finish();

            serializedObject.ApplyModifiedProperties();
            return EditorGUI.EndChangeCheck();
        }

        private void DrawProperty(int index, int topLevelIndex)
        {
            var prop = allProps[index];
            bool topLevel = layoutController.IsTopLevel(index);

            if (topLevel) callbackManager.InvokeCallback(topLevelIndex, CallbackEvent.BeforeProperty);
            

            using (new EditorGUI.DisabledScope(!layoutController.IsPropertyEnabled(index)))
            {
                if (layoutController.IsPropertyVisible(index))
                {
                    if (!topLevel || !callbackManager.InvokeCallback(index, CallbackEvent.ReplaceProperty))
                    {
                        if (inlineEditors.ContainsKey(prop))
                        {
                            InlineEditorData data = inlineEditors[prop];
                            MarkupGUI.DrawEditorInline(prop, data.editor, data.mode, data.enabled);
                        }
                        else
                        {
                            EditorGUILayout.PropertyField(prop, layoutController.IncludeChildren(index));
                        }
                    }
                }
            }
            if (topLevel) callbackManager.InvokeCallback(topLevelIndex, CallbackEvent.AfterProperty);
        }

        private void CreateInlineEditors()
        {
            var props = new List<SerializedProperty>(inlineEditors.Keys);
            foreach (var prop in props)
            {
                var editor = inlineEditors[prop].editor;

                if (prop.objectReferenceValue != serializedObject.targetObject)
                {
                    Material material = prop.objectReferenceValue as Material;
                    if (material != null)
                    {
                        CreateCachedEditor(material, typeof(HeaderlessMaterialEditor), ref editor);
                        inlineEditors[prop].enabled = AssetDatabase.GetAssetPath(material).StartsWith("Assets");
                    }
                    else
                        CreateCachedEditor(prop.objectReferenceValue, null, ref editor);
                }
                else
                {
                    editor = null;
                    prop.objectReferenceValue = null;
                    Debug.LogError("Self reference in the InlinedEditor property is not allowed.");
                }

                
                inlineEditors[prop].editor = editor;
            }
        }

        private void UpdateTargets()
        {
            foreach (var wrapper in targetsRequireUpdate)
            {
                wrapper.Update();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkedUpEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkedUpShaderGUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 4b7102832313cd84c92c9ea75e82aa04
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using UnityEngine;
using UnityEditor;
using System;

namespace MarkupAttributes.Editor
{
    [CanEditMultipleObjects()]
    public class MarkedUpShaderGUI : ShaderGUI
    {
        private static MaterialEditor currentEditor;
        private static MaterialPropertiesWrapper materialPropertiesWrapper;
        private static string[][] allAttributes;
        private static InspectorLayoutController layoutController;
        private static CallbackManager callbackManager;
        private static Shader shader;
        private static Material material;
        private static int systemPropertiesIndex;

        protected virtual void OnInitialize(MaterialEditor materialEditor, MaterialProperty[] properties) { }

        protected void AddCallback(MaterialProperty property, CallbackEvent type, 
            Action<MaterialEditor, MaterialProperty[], MaterialProperty> callback)
        {
            callbackManager.AddCallback(property, type, callback);
        }

        public override void OnGUI(MaterialEditor materialEditor, MaterialProperty[] properties)
        {
            Initialize(materialEditor, properties);

            layoutController.Begin();
            for (int i = 0; i < properties.Length; i++)
            {
                layoutController.BeforeProperty(i);
                
                if (layoutController.ScopeVisible && layoutController.IsPropertyVisible(i))
                {
                    callbackManager.InvokeCallback(i, CallbackEvent.BeforeProperty);
                    using (new EditorGUI.DisabledScope(
                        !layoutController.ScopeEnabled || !layoutController.IsPropertyEnabled(i)))
                    {
                        if (!callbackManager.InvokeCallback(i, CallbackEvent.ReplaceProperty))
                            DrawProperty(materialEditor, properties[i]);
                    }
                    callbackManager.InvokeCallback(i, CallbackEvent.AfterProperty);

                    if (i == systemPropertiesIndex)
                    {
                        EditorGUILayout.Space();
                        DrawSystemProperties(materialEditor);
                    }

                }
            }
            layoutController.Finish();
        }

        private void Initialize(MaterialEditor materialEditor, MaterialProperty[] properties)
        {
            if (currentEditor == materialEditor && allAttributes != null
                && properties.Length == materialPropertiesWrapper.value.Length)
            {
                materialPropertiesWrapper.value = properties;
                return;
            }

            material = (Material)materialEditor.target;
            shader = material.shader;
            currentEditor = materialEditor;
            allAttributes = GetAttributes(shader, properties.Length);
            materialPropertiesWrapper = new MaterialPropertiesWrapper();
            materialPropertiesWrapper.value = properties;
            layoutController = new InspectorLayoutController(shader.name,
                ShaderAttributesParser.GetLayoutData(allAttributes, materialPropertiesWrapper, material));
            callbackManager = new CallbackManager(materialEditor, materialPropertiesWrapper);
            systemPropertiesIndex = ShaderAttributesParser.GetDrawSystemPropertiesAttribute(allAttributes);
            
            OnInitialize(materialEditor, properties);
        }

        private string[][] GetAttributes(Shader shader, int propsCount)
        {
            var output = new string[propsCount][];
            for (int i = 0; i < propsCount; i++)
            {
                output[i] = shader.GetPropertyAttributes(i);
            }
            return output;
        }

        private void DrawProperty(MaterialEditor editor, MaterialProperty prop)
        {
            if (prop.propertyFlags.HasFlag(UnityEngine.Rendering.ShaderPropertyFlags.HideInInspector))
                return;
            bool hierarchyMode = EditorGUIUtility.hierarchyMode;
            if (prop.propertyType == UnityEngine.Rendering.ShaderPropertyType.Range)
                EditorGUIUtility.hierarchyMode = true;
            editor.ShaderProperty(prop, MakeLabel(prop));
            EditorGUIUtility.hierarchyMode = hierarchyMode;
        }

        private void DrawSystemProperties(MaterialEditor materialEditor)
        {
            materialEditor.RenderQueueField();
            materialEditor.EnableInstancingField();
            materialEditor.DoubleSidedGIField();
        }

        private static GUIContent TempLabel = new GUIContent();
        private static GUIContent MakeLabel(MaterialProperty property, string tooltip = null)
        {
            TempLabel.text = property.displayName;
            TempLabel.tooltip = tooltip;
            return TempLabel;
        }

        
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkedUpShaderGUI.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupAttributesPrefs.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: da0d25574c33ac64d98db1c615ce7ff9
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace MarkupAttributes.Editor
{
    internal class MarkupAttributesPrefs : ScriptableObject
    {
        private static MarkupAttributesPrefs instance;
        private static MarkupAttributesPrefs Instance
        {
            get
            {
                if (instance == null)
                {
                    var guids = AssetDatabase.FindAssets(
                        string.Format("t:{0}", typeof(MarkupAttributesPrefs)));

                    MarkupAttributesPrefs asset = null;
                    for (int i = 0; i < guids.Length; i++)
                    {
                        string path = AssetDatabase.GUIDToAssetPath(guids[i]);
                        asset = AssetDatabase.LoadAssetAtPath<MarkupAttributesPrefs>(path);
                        if (asset != null) break;
                    }
                    if (asset == null)
                    {
                        asset = CreateInstance<MarkupAttributesPrefs>();
                        if (!AssetDatabase.IsValidFolder("Assets/Editor"))
                            AssetDatabase.CreateFolder("Assets", "Editor");
                        AssetDatabase.CreateAsset(asset, "Assets/Editor/MarkupAttributesPersistentData.asset");
                        AssetDatabase.SaveAssets();
                    }

                    instance = asset;
                    SerializedObject so = new SerializedObject(instance);
                    instance.boolsHandler =
                        new SerializedDictionaryHandler(so.FindProperty("serializedBoolEntries"));
                    instance.intsHandler =
                        new SerializedDictionaryHandler(so.FindProperty("serializedIntEntries"));
                }
                return instance;
            }
        }

        public static bool GetBool(string key, bool defaultValue = false)
        {
            return Instance.boolsHandler.GetBool(key, defaultValue);
        }
        public static void SetBool(string key, bool value)
        {
            Instance.boolsHandler.SetBool(key, value);
        }
        public static int GetInt(string key, int defaultValue = 0)
        {
            return Instance.boolsHandler.GetInt(key, defaultValue);
        }
        public static void SetInt(string key, int value)
        {
            Instance.boolsHandler.SetInt(key, value);
        }

        public static void DeleteAll()
        {
            Instance.boolsHandler.DeleteAll();
            Instance.intsHandler.DeleteAll();
        }

        private SerializedDictionaryHandler boolsHandler;
        private SerializedDictionaryHandler intsHandler;

        [NonReorderable]
        [SerializeField] private BoolEntry[] serializedBoolEntries;
        [NonReorderable]
        [SerializeField] private IntEntry[] serializedIntEntries;

        [System.Serializable]
        private class BoolEntry
        {
            public string key;
            public bool value;
        }

        [System.Serializable]
        private class IntEntry
        {
            public string key;
            public int value;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupAttributesPrefs.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupAttributesPrefsEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d25dab21600856347aceaf6e44131ea6
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace MarkupAttributes.Editor
{
    [CustomEditor(typeof(MarkupAttributesPrefs))]
    internal class MarkupAttributesPrefsEditor : UnityEditor.Editor
    {
        string message = "Hi! I am a file that keeps data about " +
            "selected tabs, expanded foldouts and things like that for " +
            "MarkupAttributes.\n" +
            "1. You can keep me inside any of your Editor folders.\n" +
            "2. You can check me out of your version control.";

        public override void OnInspectorGUI()
        {
            EditorGUILayout.HelpBox(message, MessageType.Info);

            using (new EditorGUI.DisabledScope(true))
            {
                DrawDefaultInspector();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupAttributesPrefsEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupEditorUtils.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7c7df93f6d00b3c418191b311072bfba
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEditor;

namespace MarkupAttributes.Editor
{
	internal static class MarkupEditorUtils
	{
		public const BindingFlags DefaultBindingFlags = BindingFlags.Instance | BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public;

		public static SerializedProperty[] GetSerializedObjectProperties(SerializedObject serializedObject)
		{
			List<SerializedProperty> props = new List<SerializedProperty>();
			using (SerializedProperty iterator = serializedObject.GetIterator())
			{
				if (iterator.NextVisible(true))
				{
					do
					{
						props.Add(iterator.Copy());
					}
					while (iterator.NextVisible(false));
				}
			}
			return props.ToArray();
		}

		public static SerializedProperty[] GetChildrenProperties(SerializedProperty serializedProperty)
		{
			return GetChildrenOfProperty(serializedProperty).ToArray();
		}

		public static IEnumerable<SerializedProperty> GetChildrenOfProperty(SerializedProperty serializedProperty)
		{
			SerializedProperty currentProperty = serializedProperty.Copy();
			SerializedProperty nextSiblingProperty = serializedProperty.Copy();

			nextSiblingProperty.Next(false);
			if (currentProperty.Next(true))
			{
				do
				{
					if (SerializedProperty.EqualContents(currentProperty, nextSiblingProperty))
						break;

					yield return currentProperty.Copy();
				}
				while (currentProperty.Next(false));
			}
		}


		// from https://github.com/lordofduct/spacepuppy-unity-framework-3.0/blob/master/SpacepuppyUnityFrameworkEditor/EditorHelper.cs
		public static object GetTargetObjectOfProperty(SerializedProperty property)
		{
			if (property == null)
			{
				return null;
			}

			string path = property.propertyPath.Replace(".Array.data[", "[");
			object obj = property.serializedObject.targetObject;
			string[] elements = path.Split('.');

			foreach (var element in elements)
			{
				if (element.Contains("["))
				{
					string elementName = element.Substring(0, element.IndexOf("["));
					int index = Convert.ToInt32(element.Substring(element.IndexOf("[")).Replace("[", "").Replace("]", ""));
					obj = GetValue_Imp(obj, elementName, index);
				}
				else
				{
					obj = GetValue_Imp(obj, element);
				}
			}

			return obj;
		}

		private static object GetValue_Imp(object source, string name)
		{
			if (source == null)
			{
				return null;
			}

			Type type = source.GetType();

			while (type != null)
			{
				FieldInfo field = type.GetField(name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance);
				if (field != null)
				{
					return field.GetValue(source);
				}

				PropertyInfo property = type.GetProperty(name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
				if (property != null)
				{
					return property.GetValue(source, null);
				}

				type = type.BaseType;
			}

			return null;
		}

		private static object GetValue_Imp(object source, string name, int index)
		{
			IEnumerable enumerable = GetValue_Imp(source, name) as IEnumerable;
			if (enumerable == null)
			{
				return null;
			}

			IEnumerator enumerator = enumerable.GetEnumerator();
			for (int i = 0; i <= index; i++)
			{
				if (!enumerator.MoveNext())
				{
					return null;
				}
			}

			return enumerator.Current;
		}
	}
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupEditorUtils.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupGUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 51862abc1839c29419a81574e53da6a0
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace MarkupAttributes.Editor
{
    public static class MarkupGUI
    {
        internal const float SpaceAfterBoxedHeader = 4;
        internal const float SpaceBeforeHeader = 5;

        #region Utility

        private static readonly GUIContent tempContent = new GUIContent();
        private static GUIContent GetContent(string label = null, string tooltip = null)
        {
            if (label == null)
                return GUIContent.none;
            tempContent.text = label;
            tempContent.tooltip = tooltip;
            return tempContent;
        }

        public static bool IsInsideInlineEditor { get; private set; } = false;
        public class InlineEditorScope : IDisposable
        {
            private readonly bool cachedIsInsideInlineEditor;

            public InlineEditorScope()
            {
                cachedIsInsideInlineEditor = IsInsideInlineEditor;
                IsInsideInlineEditor = true;
            }

            public void Dispose()
            {
                IsInsideInlineEditor = cachedIsInsideInlineEditor;
            }
        }

        private struct LabelState
        {
            private bool? hierarchyMode;
            private int? indentLevel;
            private float? labelWidth;

            public static LabelState Current()
            {
                LabelState state = new LabelState();
                state.hierarchyMode = EditorGUIUtility.hierarchyMode;
                state.indentLevel = EditorGUI.indentLevel;
                state.labelWidth = EditorGUIUtility.labelWidth;
                return state;
            }

            public void Restore()
            {
                if (hierarchyMode.HasValue)
                    EditorGUIUtility.hierarchyMode = hierarchyMode.Value;
                if (indentLevel.HasValue)
                    EditorGUI.indentLevel = indentLevel.Value;
                if (labelWidth.HasValue)
                    EditorGUIUtility.labelWidth = labelWidth.Value;
            }
        }

        internal static void StartNonHierarchyScope(float padding)
        {
            float labelWidth = EditorGUIUtility.labelWidth;
            EditorGUIUtility.hierarchyMode = false;
            EditorGUIUtility.labelWidth = labelWidth - padding;
        }

        public struct GroupHandle
        {
            private readonly LabelState labelState;
            private readonly bool isVertical;
            private readonly bool isHorizontal;

            public GroupHandle(bool isVertical, bool isHorizontal)
            {
                labelState = LabelState.Current();
                this.isVertical = isVertical;
                this.isHorizontal = isHorizontal;
            }

            public void End()
            {
                labelState.Restore();
                if (isVertical)
                    EditorGUILayout.EndVertical();
                if (isHorizontal)
                    EditorGUILayout.EndHorizontal();
            }
        }

        public class GroupsStack
        {
            private readonly Stack<GroupHandle> groups = new Stack<GroupHandle>();
            public void PushGroup(GroupHandle group) => groups.Push(group);

            public void EndAll()
            {
                while (groups.Count > 0)
                {
                    groups.Pop().End();
                }
            }

            public void EndGroup()
            {
                if (groups.Count < 1)
                {
                    Debug.LogWarning("No MarkupGUI groups to end.");
                }
                groups.Pop().End();
            }

            public void Clear()
            {
                groups.Clear();
            }

            public static GroupsStack operator +(GroupsStack stateStack, GroupHandle group)
            {
                stateStack.PushGroup(group);
                return stateStack;
            }

        }

        #endregion Utility

        public static void HorizontalLine(float height = 1)
        {
            float c = EditorGUIUtility.isProSkin ? 0.45f : 0.4f;
            HorizontalLine(new Color(c, c, c), height);
        }
        public static void HorizontalLine(Color color, float height)
        {
            Rect rect = EditorGUILayout.GetControlRect(false, height);
            rect = EditorGUI.IndentedRect(rect);
            EditorGUI.DrawRect(rect, color);
            GUILayout.Space(2);
        }
        public static Rect BeginVertical(MarkupBodyStyle style, MarkupHeaderFlags headerFlags, bool isExpanded)
        {
            Rect headerRect = Rect.zero;
            bool hasHeader = headerFlags.HasFlag(MarkupHeaderFlags.Label);
            bool underline = headerFlags.HasFlag(MarkupHeaderFlags.Underline);
            if (style == MarkupBodyStyle.None)
            {
                EditorGUILayout.BeginVertical();
                if (hasHeader)
                {
                    headerRect = EditorGUILayout.GetControlRect();
                    if (isExpanded && underline)
                    {
                        HorizontalLine();
                    }
                }
                return headerRect;
            }

            if (style == MarkupBodyStyle.ContentBox)
            {
                // Inlined editors create unwanted padding, 
                // if there is an empty GUIStyle.none vertical scope
                // (which can happen, for example, in unexpanded foldouts).
                // I don't know if it's a bug or an intended behaviour.
                // Workaround - put header inside the scope if it's not expanded.
                if (!isExpanded)
                    EditorGUILayout.BeginVertical();
                if (hasHeader)
                    headerRect = EditorGUILayout.GetControlRect();
                if (isExpanded)
                    EditorGUILayout.BeginVertical(MarkupStyles.Box);
                return headerRect;
            }

            if (style == MarkupBodyStyle.Box)
            {
                EditorGUILayout.BeginVertical(MarkupStyles.OutlinedBox);
                if (hasHeader)
                {
                    headerRect = EditorGUILayout.GetControlRect();
                    Rect headerBoxRect = MarkupStyles.OutlinedBox.padding.Add(headerRect);
                    GUI.Box(headerBoxRect, GUIContent.none, MarkupStyles.OutlinedHeaderBox(isExpanded));
                    if (isExpanded)
                    {
                        GUILayout.Space(SpaceAfterBoxedHeader);
                    }
                }
                return headerRect;
            }

            EditorGUILayout.BeginVertical();
            return headerRect;
        }

        internal static GroupHandle BeginGenericVerticalGroup(
            ref bool isExpanded, ref bool isEnabled,
            MarkupHeaderFlags headerStyle, MarkupBodyStyle bodyStyle,
            string label, TogglableValueWrapper togglableValue)
        {
            return BeginGenericVerticalGroup(ref isExpanded, ref isEnabled,
                headerStyle, bodyStyle, GetContent(label), togglableValue);
        }

        internal static GroupHandle BeginGenericVerticalGroup(
            ref bool isExpanded, ref bool isEnabled,
            MarkupHeaderFlags headerFlags, MarkupBodyStyle bodyStyle, 
            GUIContent label, TogglableValueWrapper togglableValue)
        {
            var handle = new GroupHandle(true, false);
            bool hasLabel = headerFlags.HasFlag(MarkupHeaderFlags.Label);
            bool isFoldable = headerFlags.HasFlag(MarkupHeaderFlags.Foldable);
            if (!isFoldable)
            {
                isExpanded = togglableValue == null || togglableValue.GetValue();
            }

            Rect headerRect = BeginVertical(bodyStyle, headerFlags, isExpanded);

            if (bodyStyle == MarkupBodyStyle.Box)
            {
                StartNonHierarchyScope(MarkupStyles.OutlinedBox.padding.left);
            }

            if (hasLabel)
            {
                if (togglableValue != null)
                {
                    if (!isFoldable)
                        isExpanded = togglableValue.GetValue();
                    bool value = Toggle(headerRect, togglableValue, label, 
                        ref isExpanded, isFoldable);
                    if (isFoldable)
                    {
                        isEnabled &= value;
                    }
                    else
                        isExpanded &= value;
                }
                else
                {
                    using (new EditorGUI.DisabledScope(!isEnabled))
                    {
                        if (isFoldable)
                        {
                            isExpanded = EditorGUI.Foldout(headerRect, isExpanded, label, true, MarkupStyles.BoldFoldout);
                        }
                        else
                        {
                            EditorGUI.LabelField(headerRect, label, EditorStyles.boldLabel);
                        }
                    }
                }
            }

            if (bodyStyle == MarkupBodyStyle.ContentBox)
            {
                StartNonHierarchyScope(MarkupStyles.Box.padding.left);
            }

            return handle;
        }

        public static GroupHandle BeginBoxGroup(string label = null) => BeginBoxGroup(GetContent(label));

        public static GroupHandle BeginBoxGroup(GUIContent label)
        {
            bool isExpanded = true;
            bool isEnabled = true;
            return BeginGenericVerticalGroup(ref isExpanded, ref isEnabled,
                label != GUIContent.none ? MarkupHeaderFlags.Label : MarkupHeaderFlags.None,
                MarkupBodyStyle.Box, label, null);
        }

        public static GroupHandle BeginTitleGroup(string label, bool contentBox = false, bool underline = true) 
            => BeginTitleGroup(GetContent(label), contentBox, underline);

        public static GroupHandle BeginTitleGroup(GUIContent label, bool contentBox = false, bool underline = true)
        {
            bool isExpanded = true;
            bool isEnabled = true;
            MarkupHeaderFlags headerFlags = MarkupHeaderFlags.Label;
            if (underline)
                headerFlags |= MarkupHeaderFlags.Underline;
            return BeginGenericVerticalGroup(ref isExpanded, ref isEnabled, headerFlags, 
                contentBox ? MarkupBodyStyle.ContentBox : MarkupBodyStyle.None, label, null);
        }

        public static GroupHandle BeginFoldoutGroup(ref bool isExpanded, string label, bool box = true)
            => BeginFoldoutGroup(ref isExpanded, GetContent(label), box);

        public static GroupHandle BeginFoldoutGroup(ref bool isExpanded, GUIContent label, bool box = true)
        {
            bool isEnabled = true;
            return BeginGenericVerticalGroup(ref isExpanded, ref isEnabled,
                MarkupHeaderFlags.Foldable | MarkupHeaderFlags.Label, box ?
                MarkupBodyStyle.Box : MarkupBodyStyle.ContentBox, label, null);
        }

        public static GroupHandle BeginTabsGroup(ref int selected, string[] tabs, bool box = false)
        {
            var handle = new GroupHandle(true, false);
            if (box)
            {
                EditorGUILayout.BeginVertical(MarkupStyles.TabsBox);
                StartNonHierarchyScope(MarkupStyles.TabsBox.padding.left);

                Rect position = EditorGUILayout.GetControlRect(false);
                var padding = MarkupStyles.OutlinedBox.padding;
                position.x -= padding.left;
                position.width += padding.right + padding.left - 1;
                position.y -= padding.top;
                position.height += padding.top;

                for (int i = 0; i < tabs.Length; i++)
                {
                    Rect r = GetTabRect(position, i, tabs.Length, out GUIStyle style);
                    if (EditorGUI.Toggle(r, i == selected, style))
                        selected = i;
                    EditorGUI.LabelField(r, tabs[i], MarkupStyles.CenteredLabel);
                }
            }
            else
            {
                selected = GUILayout.Toolbar(selected, tabs);
                EditorGUILayout.BeginVertical(GUIStyle.none);
            }
            GUILayout.Space(SpaceAfterBoxedHeader);

            return handle;
        }

        private static Rect GetTabRect(Rect rect, int tabIndex, int tabCount, out GUIStyle tabStyle)
        {
            tabStyle = MarkupStyles.TabMiddle;

            if (tabCount == 1)
            {
                tabStyle = MarkupStyles.TabOnlyOne;
            }
            else if (tabIndex == 0)
            {
                tabStyle = MarkupStyles.TabFirst;
            }
            else if (tabIndex == (tabCount - 1))
            {
                tabStyle = MarkupStyles.TabLast;
            }

            float tabWidth = rect.width / tabCount;
            int left = Mathf.RoundToInt(tabIndex * tabWidth);
            int right = Mathf.RoundToInt((tabIndex + 1) * tabWidth);
            return new Rect(rect.x + left, rect.y, right - left, rect.height);
        }

        internal static bool FoldoutWithObjectField(SerializedProperty property)
        {
            Rect rect = EditorGUILayout.GetControlRect();
            bool res = FoldoutWithObjectField(rect, property);
            return res;
        }

        internal static bool FoldoutWithObjectField(Rect position,
            SerializedProperty property, GUIContent label = null)
        {
            label = EditorGUI.BeginProperty(position, label, property);
            var foldoutRect = new Rect(position.x, position.y, EditorGUIUtility.labelWidth, EditorGUIUtility.singleLineHeight);
            bool result = false;
            if (property.objectReferenceValue != null)
                result = EditorGUI.Foldout(foldoutRect, property.isExpanded, label, true);
            else
                EditorGUI.LabelField(position, label);

            float xOffset = EditorGUIUtility.labelWidth + EditorGUIUtility.standardVerticalSpacing;
            var propertyRect = new Rect(position.x + xOffset,
                position.y, position.width - xOffset, EditorGUIUtility.singleLineHeight);
            EditorGUI.ObjectField(propertyRect, property, GUIContent.none);
            EditorGUI.EndProperty();
            return result;
        }

        internal static bool Toggle(Rect position,
            TogglableValueWrapper wrapper, GUIContent label, ref bool isExpanded, bool foldable)
        {
            float toggleWidth = EditorStyles.boldLabel.CalcSize(label).x + 20;
            Rect rectToggle = position;
            rectToggle.width = toggleWidth;
            Rect rectFoldout = position;
            rectFoldout.x += toggleWidth;
            rectFoldout.width -= toggleWidth;

            bool hasMixedValue = wrapper.HasMixedValue;
            bool value = wrapper.GetValue();
            if (wrapper.TargetSerializedProperty != null)
                label = EditorGUI.BeginProperty(position, label, wrapper.TargetSerializedProperty);
            else
                EditorGUI.showMixedValue = hasMixedValue;

            EditorGUI.BeginChangeCheck();

            value = EditorGUI.ToggleLeft(rectToggle, label, value, EditorStyles.boldLabel);
            if (EditorGUI.EndChangeCheck())
                wrapper.SetValue(value, true);

            if (foldable)
            {
                Rect smallRect = rectFoldout;
                smallRect.x += rectFoldout.width - 20;
                smallRect.width = 20;
                isExpanded = EditorGUI.Foldout(smallRect, isExpanded, GUIContent.none);

                Rect controlRect = rectFoldout;
                var padding = MarkupStyles.OutlinedBox.padding;
                controlRect.y -= padding.top;
                controlRect.height += padding.top + padding.bottom;
                isExpanded = EditorGUI.Foldout(controlRect, isExpanded,
                    GUIContent.none, true, EditorStyles.label);
            }

            if (wrapper.TargetSerializedProperty != null)
                EditorGUI.EndProperty();
            else
                EditorGUI.showMixedValue = false;

            if (!foldable)
                isExpanded = value;
            return value && !hasMixedValue;
        }

        public static void DrawEditorInline(SerializedProperty property,
            UnityEditor.Editor editor, InlineEditorMode mode, bool enabled = true)
        {
            var labelState = LabelState.Current();
            
            bool expanded = mode == InlineEditorMode.Stripped || property.isExpanded;
            expanded &= editor != null;
            expanded &= !property.hasMultipleDifferentValues;
            MaterialEditor materialEditor = editor as MaterialEditor;

            if (mode == InlineEditorMode.Box)
            {
                Rect headerRect = BeginVertical(MarkupBodyStyle.Box, MarkupHeaderFlags.Label, property.isExpanded);
                StartNonHierarchyScope(MarkupStyles.OutlinedBox.padding.left);
                property.isExpanded = FoldoutWithObjectField(headerRect, property);
            }

            if (mode == InlineEditorMode.ContentBox)
            {
                Rect headerRect = BeginVertical(MarkupBodyStyle.ContentBox, MarkupHeaderFlags.Label, property.isExpanded);
                property.isExpanded = FoldoutWithObjectField(headerRect, property);
                StartNonHierarchyScope(MarkupStyles.Box.padding.left);
            }

            if (mode == InlineEditorMode.Stripped)
            {
                if (editor == null)
                    FoldoutWithObjectField(EditorGUILayout.GetControlRect(), property);
            }

            if (expanded)
            {
                // begin dummy vertical group,
                // because MaterialEditor interrupts one in OnInspectorGUI
                if (materialEditor)
                {
                    EditorGUILayout.BeginVertical();
                }
                using (new EditorGUI.DisabledScope(!enabled))
                {
                    using (new InlineEditorScope())
                    {
                        if (materialEditor)
                            editor.DrawHeader();
                        editor.OnInspectorGUI();
                    }
                }
                if (materialEditor)
                    EditorGUILayout.EndVertical();
            }

            if (mode != InlineEditorMode.Stripped)
            {
                EditorGUILayout.EndVertical();
                labelState.Restore();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupGUI.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupStyles.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b244c28a611b27b4091704d0f2acbe6f
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace MarkupAttributes.Editor
{
    public static class MarkupStyles
    {
        public static GUIStyle OutlinedBox => EditorStyles.helpBox;
        public static GUIStyle Box => GUI.skin.box;

        public static GUIStyle CenteredLabel
        {
            get
            {
                if (centeredLabel == null)
                {
                    centeredLabel = new GUIStyle(EditorStyles.label);
                    centeredLabel.alignment = TextAnchor.MiddleCenter;
                }
                return centeredLabel;
            }
        }

        public static GUIStyle BoldFoldout
        {
            get
            {
                if (boldFoldout == null)
                {
                    boldFoldout = new GUIStyle(EditorStyles.foldout);
                    boldFoldout.font = EditorStyles.boldFont;
                }
                return boldFoldout;
            }
        }

        public static GUIStyle OutlinedHeaderBox(bool opened)
        {
            InitializeHeaderStyles();
            if (opened)
                return EditorGUIUtility.isProSkin ? headerBoxOpenedDark : headerBoxOpenedLight;
            else
                return EditorGUIUtility.isProSkin ? headerBoxClosedDark : headerBoxClosedLight;
        }

        public static GUIStyle TabOnlyOne = "Tab onlyOne";
        public static GUIStyle TabFirst = "Tab first";
        public static GUIStyle TabMiddle = "Tab middle";
        public static GUIStyle TabLast = "Tab last";
        public static GUIStyle TabsBox
        {
            get
            {
                if (frameBox == null)
                {
                    frameBox = new GUIStyle("FrameBox");
                    frameBox.padding = EditorStyles.helpBox.padding;
                }
                return frameBox;
            }
        }

        private static GUIStyle centeredLabel;
        private static GUIStyle boldFoldout;
        private static GUIStyle frameBox;
        private static GUIStyle headerBoxOpenedDark;
        private static GUIStyle headerBoxOpenedLight;
        private static GUIStyle headerBoxClosedDark;
        private static GUIStyle headerBoxClosedLight;

        private static void InitializeHeaderStyles()
        {
            if (headerBoxOpenedDark == null)
            {
                headerBoxOpenedDark = CreateBoxStyle(GetTexture("MarkupAttributes_HeaderOpened_Dark"));
                headerBoxOpenedLight = CreateBoxStyle(GetTexture("MarkupAttributes_HeaderOpened_Light"));
                headerBoxClosedDark = CreateBoxStyle(GetTexture("MarkupAttributes_HeaderClosed_Dark"));
                headerBoxClosedLight = CreateBoxStyle(GetTexture("MarkupAttributes_HeaderClosed_Light"));
            }
        }

        private static GUIStyle CreateBoxStyle(Texture2D texture)
        {
            var style = new GUIStyle(EditorStyles.helpBox);
            if (texture != null)
            {
                style.normal.background = texture;
                style.normal.scaledBackgrounds = new Texture2D[0];
            }
            return style;
        }

        private static Texture2D GetTexture(string name)
        {
            string[] results = AssetDatabase.FindAssets(name);
            if (results != null && results.Length > 0)
                return AssetDatabase.LoadAssetAtPath<Texture2D>(AssetDatabase.GUIDToAssetPath(results[0]));
            return null;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MarkupStyles.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MaterialPropertiesWrapper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 487fd20e934be0e4d898e531a6468334
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using UnityEditor;

namespace MarkupAttributes.Editor
{
    internal class MaterialPropertiesWrapper
    {
        public MaterialProperty[] value {get; set;}
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/MaterialPropertiesWrapper.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/PropertyLayoutData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 749c26665bfd07245b0e37e400387a41
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System.Collections.Generic;

namespace MarkupAttributes.Editor
{
    internal class PropertyLayoutData
    {
        public readonly InspectorLayoutGroup[] groups;
        public readonly EndGroupAttribute end;
        public readonly ConditionWrapper[] hideConditions;
        public readonly ConditionWrapper[] disableConditions;
        public bool isTopLevel = true;
        public bool alwaysHide = false;
        public bool includeChildren = true;
        public int numberOfScopesToClose;

        public bool IsVisible()
        {
            if (alwaysHide)
                return false;
            for (int i = 0; i < hideConditions.Length; i++)
            {
                if (hideConditions[i].GetValue())
                    return false;
            }
            return true;
        }

        public bool IsEnabled()
        {
            for (int i = 0; i < disableConditions.Length; i++)
            {
                if (disableConditions[i].GetValue())
                    return false;
            }
            return true;
        }

        public PropertyLayoutData(List<InspectorLayoutGroup> groups, 
            List<ConditionWrapper> hideConditions, List<ConditionWrapper> disableConditions,
            EndGroupAttribute end)
        {
            groups.Sort((g0, g1) => g0.Order().CompareTo(g1.Order()));

            this.groups = groups.ToArray();
            this.hideConditions = hideConditions.ToArray();
            this.disableConditions = disableConditions.ToArray();
            this.end = end;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/PropertyLayoutData.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/SerializedDictionaryHandler.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 5db5e42b4b6ebc64598d8b52bd13dee6
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System.Collections.Generic;
using UnityEditor;

namespace MarkupAttributes.Editor
{
    internal class SerializedDictionaryHandler
    {
        private readonly SerializedProperty array;
        private Dictionary<string, SerializedProperty> dictionary;

        public SerializedDictionaryHandler(SerializedProperty targetArray)
        {
            array = targetArray;
            dictionary = new Dictionary<string, SerializedProperty>();

            for (int i = 0; i < array.arraySize; i++)
            {
                var prop = array.GetArrayElementAtIndex(i);
                dictionary.Add(prop.FindPropertyRelative("key").stringValue,
                    prop.FindPropertyRelative("value"));
            }
        }

        public void DeleteAll()
        {
            array.arraySize = 0;
            array.serializedObject.ApplyModifiedPropertiesWithoutUndo();
        }

        public bool GetBool(string key, bool defaultValue = false)
        {
            var prop = GetValueProp(key, false);
            return prop == null ? defaultValue : prop.boolValue;
        }
        public int GetInt(string key, int defaultValue = 0)
        {
            var prop = GetValueProp(key, false);
            return prop == null ? defaultValue : prop.intValue;
        }
        public void SetBool(string key, bool value)
        {
            var prop = GetValueProp(key, true);
            prop.boolValue = value;
            array.serializedObject.ApplyModifiedPropertiesWithoutUndo();
        }
        public void SetInt(string key, int value)
        {
            var prop = GetValueProp(key, true);
            prop.intValue = value;
            array.serializedObject.ApplyModifiedPropertiesWithoutUndo();
        }

        private SerializedProperty GetValueProp(string key, bool createIfNotPresent)
        {
            if (dictionary.TryGetValue(key, out SerializedProperty prop))
                return prop;
            else
                return createIfNotPresent ? AddKey(key) : null;
        }

        private SerializedProperty AddKey(string key)
        {
            array.arraySize += 1;
            SerializedProperty prop = array.GetArrayElementAtIndex(array.arraySize - 1);
            prop.FindPropertyRelative("key").stringValue = key;
            SerializedProperty valueProp = prop.FindPropertyRelative("value");
            dictionary.Add(key, valueProp);
            return valueProp;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/SerializedDictionaryHandler.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/ShaderAttributesParser.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 34bb20890b6122d4990bcd780184febf
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;

namespace MarkupAttributes.Editor
{
    internal static class ShaderAttributesParser
    {
        public static string GetKeyword(string arg, out bool isGlobal)
        {
            string[] s = arg.Split(' ');
            if (s.Length < 2)
            {
                isGlobal = false;
                return arg;
            }
            else
            {
                isGlobal = s[0] == "G";
                return s[1];
            }
        }

        public static int GetDrawSystemPropertiesAttribute(string[][] allAttributes)
        {
            for (int i = 0; i < allAttributes.Length; i++)
            {
                var attributes = allAttributes[i];
                foreach (var attribute in attributes)
                {
                    if (ParseAttribute(attribute, "DrawSystemProperties"))
                        return i;
                }
            }
            return -1;
        }

        public static PropertyLayoutData[] GetLayoutData(string[][] allAttributes,
            MaterialPropertiesWrapper propertiesWrapper, Material targetMaterial)
        {
            var props = propertiesWrapper.value;
            var output = new PropertyLayoutData[props.Length];
            for (int i = 0; i < props.Length; i++)
            {
                bool isPropertyHidden = false;

                var groupAttributes = GetLayoutGroupAttributes(allAttributes[i]);
                var groups = new List<InspectorLayoutGroup>();
                foreach (var groupAttribute in groupAttributes)
                {
                    var group = CreateGroupFromAttribute(ref isPropertyHidden, groupAttribute,
                        i, propertiesWrapper, targetMaterial);
                    if (group != null)
                        groups.Add(group);
                }

                var conditionals = GetConditionals(allAttributes[i], propertiesWrapper, targetMaterial);

                output[i] = new PropertyLayoutData(groups, conditionals.Item1, conditionals.Item2,
                    GetEndGroupAttribute(allAttributes[i]));
                output[i].alwaysHide = isPropertyHidden;
            }

            return output;
        }

        private static InspectorLayoutGroup CreateGroupFromAttribute(ref bool isHidden,
            LayoutGroupAttribute attribute, int index, 
            MaterialPropertiesWrapper allProperties, Material targetMaterial)
        {
            ConditionWrapper conditionWrapper = null;
            if (attribute.HasCondition)
            {
                conditionWrapper = ConditionWrapper.Create(attribute.Condition, 
                    allProperties, targetMaterial);
                if (conditionWrapper == null) return null;
            }

            TogglableValueWrapper togglableValueWrapper = null;
            if (attribute.Toggle)
            {
                if (attribute.ToggleShaderKeyword != null)
                {
                    togglableValueWrapper = TogglableValueWrapper.Create(index, allProperties, targetMaterial, attribute.ToggleShaderKeyword);
                    isHidden = true;
                }
                else
                {
                    togglableValueWrapper = TogglableValueWrapper.Create(index, allProperties);
                    isHidden = true;
                }
                
                if (togglableValueWrapper == null)
                    return null;
            }

            return new InspectorLayoutGroup(attribute, conditionWrapper, togglableValueWrapper);
        }

        private static EndGroupAttribute GetEndGroupAttribute(string[] attributes)
        {
            foreach (var attribute in attributes)
            {
                if (ParseAttribute(attribute, "EndGroup", 0, out string[] args))
                {
                    EndGroupAttribute a;
                    if (args != null && args.Length > 0)
                        a = new EndGroupAttribute(args[0]);
                    else
                        a = new EndGroupAttribute();
                    return a;
                }
            }
            return null;
        }

        private static (List<ConditionWrapper>, List<ConditionWrapper>) GetConditionals(
            string[] attributes, MaterialPropertiesWrapper materialProperties, Material material)
        {
            List<ConditionWrapper> hideConditions = new List<ConditionWrapper>();
            List<ConditionWrapper> disableConditions = new List<ConditionWrapper>();

            foreach (var attribute in attributes)
            {
                var hideIf = GetHideIfAttribute(attribute);
                if (hideIf != null)
                    hideConditions.Add(ConditionWrapper.Create(
                        hideIf.Condition, materialProperties, material));
                
                var disableIf = GetDisableIfAttribute(attribute);
                if (disableIf != null)
                    disableConditions.Add(ConditionWrapper.Create(
                        disableIf.Condition, materialProperties, material));
            }

            return (hideConditions, disableConditions);
        }

        private static HideIfAttribute GetHideIfAttribute(string attribute)
        {
            string[] args;
            bool valid = ParseAttribute(attribute, "HideIf", 1, out args);
            if (valid)
                return new HideIfAttribute(args[0]);
            valid = ParseAttribute(attribute, "ShowIf", 1, out args);
            if (valid)
                return new ShowIfAttribute(args[0]);
            return null;
        }

        private static DisableIfAttribute GetDisableIfAttribute(string attribute)
        {
            string[] args;
            bool valid = ParseAttribute(attribute, "DisableIf", 1, out args);
            if (valid)
                return new DisableIfAttribute(args[0]);
            valid = ParseAttribute(attribute, "EnableIf", 1, out args);
            if (valid)
                return new EnableIfAttribute(args[0]);
            valid = ParseAttribute(attribute, "ReadOnly");
            if (valid)
                return new ReadOnlyAttribute();

            return null;
        }

        private static LayoutGroupAttribute[] GetLayoutGroupAttributes(string[] attributes)
        {
            var groups = new List<LayoutGroupAttribute>();
            var temp = new List<LayoutGroupAttribute>();
            for (int i = 0; i < attributes.Length; i++)
            {
                temp.Clear();
                temp.Add(GetHideIfGroupAttribute(attributes[i]));
                temp.Add(GetDisableIfGroupAttribute(attributes[i]));
                temp.Add(GetTabScopeAttribute(attributes[i]));
                temp.Add(GetTabAttribute(attributes[i]));
                temp.Add(GetVerticalGroupAttribute(attributes[i]));
                temp.Add(GetHorizontalGroupAttribute(attributes[i]));
                temp.Add(GetTitleGroupAttribute(attributes[i]));
                temp.Add(GetFoldoutGroupAttribute(attributes[i]));
                temp.Add(GetToggleGroupAttribute(attributes[i]));
                temp.Add(GetBoxAttribute(attributes[i]));

                foreach (var g in temp)
                {
                    if (g != null)
                        groups.Add(g);
                }
            }
            return groups.ToArray();
        }

        private static HideIfGroupAttribute GetHideIfGroupAttribute(string attribute)
        {
            string[] args;
            bool valid = ParseAttribute(attribute, "HideIfGroup", 2, out args);
            if (valid)
                return new HideIfGroupAttribute(GetPath(args[0]), args[1]);
            valid = ParseAttribute(attribute, "ShowIfGroup", 2, out args);
            if (valid)
                return new ShowIfGroupAttribute(GetPath(args[0]), args[1]);
            return null;
        }

        private static DisableIfGroupAttribute GetDisableIfGroupAttribute(string attribute)
        {
            string[] args;
            bool valid = ParseAttribute(attribute, "DisableIfGroup", 2, out args);
            if (valid)
                return new DisableIfGroupAttribute(GetPath(args[0]), args[1]);
            valid = ParseAttribute(attribute, "EnableIfGroup", 2, out args);
            if (valid)
                return new EnableIfGroupAttribute(GetPath(args[0]), args[1]);
            valid = ParseAttribute(attribute, "ReadOnlyGroup", 1, out args);
            if (valid)
                return new ReadOnlyGroupAttribute(GetPath(args[0]));
            return null;
        }

        private static TabScopeAttribute GetTabScopeAttribute(string attribute)
        {
            bool valid = ParseAttribute(attribute, "TabScope", 2, out string[] args);
            if (valid)
            {
                if (args.Length < 3)
                    return new TabScopeAttribute(GetPath(args[0]), GetTabs(args[1]));
                if (args.Length < 4)
                    return new TabScopeAttribute(GetPath(args[0]), GetTabs(args[1]), GetBool(args[2]));
                else
                    return new TabScopeAttribute(GetPath(args[0]), GetTabs(args[1]), GetBool(args[2]), GetFloat(args[3]));
            }
            return null;
        }

        private static TabAttribute GetTabAttribute(string attribute)
        {
            bool valid = ParseAttribute(attribute, "Tab", 1, out string[] args);
            if (valid)
                return new TabAttribute(GetPath(args[0]));
            return null;
        }

        private static VerticalGroupAttribute GetVerticalGroupAttribute(string attribute)
        {
            bool valid = ParseAttribute(attribute, "VerticalGroup", 1, out string[] args);
            if (valid)
            {
                if (args.Length < 2)
                    return new VerticalGroupAttribute(GetPath(args[0]));
                else
                    return new VerticalGroupAttribute(GetPath(args[0]), GetFloat(args[1]));
            }  
            return null;
        }

        private static HorizontalGroupAttribute GetHorizontalGroupAttribute(string attribute)
        {
            bool valid = ParseAttribute(attribute, "HorizontalGroup", 2, out string[] args);
            if (valid)
            {
                if (args.Length < 3)
                    return new HorizontalGroupAttribute(GetPath(args[0]), GetFloat(args[1]));
                else
                    return new HorizontalGroupAttribute(GetPath(args[0]), GetFloat(args[1]), GetFloat(args[2]));
            }
            return null;
        }

        private static FoldoutAttribute GetFoldoutGroupAttribute(string attribute)
        {
            bool valid = ParseAttribute(attribute, "Foldout", 1, out string[] args);
            if (valid)
            {
                if (args.Length < 2)
                    return new FoldoutAttribute(GetPath(args[0]));
                if (args.Length < 3)
                    return new FoldoutAttribute(GetPath(args[0]), GetBool(args[1]));
                else
                    return new FoldoutAttribute(GetPath(args[0]), GetBool(args[1]), GetFloat(args[2]));
            }
            return null;
        }

        private static ToggleGroupAttribute GetToggleGroupAttribute(string attribute)
        {
            bool valid = ParseAttribute(attribute, "ToggleGroup", 1, out string[] args);
            if (valid)
            {
                if (args.Length < 2)
                    return ToggleGroupAttribute.CreateForShader(GetPath(args[0]), false, true, null);
                if (args.Length < 3)
                    return ToggleGroupAttribute.CreateForShader(GetPath(args[0]), GetBool(args[1]), true, null);
                if (args.Length < 4)
                    return ToggleGroupAttribute.CreateForShader(GetPath(args[0]), GetBool(args[1]), GetBool(args[2]), null);
                return ToggleGroupAttribute.CreateForShader(GetPath(args[0]), GetBool(args[1]), GetBool(args[2]), args[3]);
            }
            return null;
        }

        private static TitleGroupAttribute GetTitleGroupAttribute(string attribute)
        {
            bool valid = ParseAttribute(attribute, "TitleGroup", 1, out string[] args);
            if (valid)
            {
                if (args.Length < 2)
                    return new TitleGroupAttribute(GetPath(args[0]));
                if (args.Length < 3)
                    return new TitleGroupAttribute(GetPath(args[0]), GetBool(args[1]));
                if (args.Length < 4)
                    return new TitleGroupAttribute(GetPath(args[0]), GetBool(args[1]), GetBool(args[2]));
                else
                    return new TitleGroupAttribute(GetPath(args[0]), GetBool(args[1]), GetBool(args[2]), GetFloat(args[3]));
            }
            return null;
        }

        private static BoxAttribute GetBoxAttribute(string attribute)
        {
            bool valid = ParseAttribute(attribute, "Box", 1, out string[] args);
            if (valid)
            {
                if (args.Length < 2)
                    return new BoxAttribute(GetPath(args[0]));
                if (args.Length < 3)
                    return new BoxAttribute(GetPath(args[0]), GetBool(args[1]));
                else
                    return new BoxAttribute(GetPath(args[0]), GetBool(args[1]), GetFloat(args[2]));
            }
            return null;
        }

        private static string GetPath(string arg)
        {
            arg = arg.Replace(' ', '/');
            arg = arg.Replace('_', ' ');
            return arg;
        }

        private static string GetTabs(string arg)
        {
            arg = arg.Replace(' ', '|');
            arg = arg.Replace('_', ' ');
            return arg;
        }

        private static float GetFloat(string arg) => float.Parse(arg, CultureInfo.InvariantCulture.NumberFormat);

        private static bool GetBool(string arg) => arg == "true";

        private static T GetEnum<T>(string arg) where T : Enum
        {
            var values = Enum.GetValues(typeof(T)).Cast<T>();
            foreach (var value in values)
            {
                if (Enum.GetName(typeof(T), value) == arg)
                    return value;
            }
            return values.First();
        }

        private static bool ParseAttribute(string attribute, string attributeName)
        {
            return ParseAttribute(attribute, attributeName, 0, out _);
        }

        private static bool ParseAttribute(string attribute, string attributeName, int minArgsCount, out string[] args)
        {
            args = null;
            int argStartIndex = attribute.IndexOf('(');
            if (argStartIndex < 0 && minArgsCount > 0)
                return false;
            if (!(argStartIndex < 0 ? attribute : attribute.Substring(0, argStartIndex)).Equals(attributeName))
                return false;

            if (argStartIndex < 0)
                return true;

            string argument = attribute.Substring(argStartIndex + 1, attribute.Length - argStartIndex - 1);
            argument = argument.Trim(')');
            if (argument.Length < 1)
                return !(minArgsCount > 0);

            args = argument.Split(',');
            if (args.Length < minArgsCount)
                return false;

            for (int i = 0; i < args.Length; i++)
            {
                args[i] = args[i].Trim();
            }
            return true;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/ShaderAttributesParser.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/TargetObjectWrapper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: fba078294f8f0f04ea472aa55ba1e24b
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using UnityEditor;
using UnityEngine;

namespace MarkupAttributes.Editor
{
    internal class TargetObjectWrapper
    {
        public object Target => targetObject;

        private object targetObject;
        private readonly SerializedProperty serializedProperty;

        public TargetObjectWrapper(object targetObject, SerializedProperty serializedProperty = null)
        {
            this.targetObject = targetObject;
            if (serializedProperty != null && targetObject.GetType().IsValueType)
                this.serializedProperty = serializedProperty;
        }

        public void Update()
        {
            if (serializedProperty != null)
            {
                targetObject = MarkupEditorUtils.GetTargetObjectOfProperty(serializedProperty);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/TargetObjectWrapper.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/TogglableValueWrapper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d6fe201aa42070f4aad8270b16f84f97
# ASMDEF: MarkupAttributes.Editor.dll
# ---
using System.Reflection;
using UnityEditor;
using UnityEngine;

namespace MarkupAttributes.Editor
{
    internal class TogglableValueWrapper
    {
        private readonly SerializedProperty serializedProperty;

        private readonly MaterialPropertiesWrapper materialProperties;
        private readonly int materialPropertyIndex;
        private readonly Material targetMaterial;
        private readonly string shaderKeyword;

        public MaterialProperty MaterialProperty
        {
            get
            {
                if (materialProperties != null)
                    return materialProperties.value[materialPropertyIndex];
                return null;
            }
        }

        public SerializedProperty TargetSerializedProperty => serializedProperty;

        public static TogglableValueWrapper Create(SerializedProperty serializedProperty)
        {
            if (serializedProperty.propertyType == SerializedPropertyType.Boolean)
                return new TogglableValueWrapper(serializedProperty);
            return null;
        }

        public static TogglableValueWrapper Create(int index, MaterialPropertiesWrapper materialProperties)
        {
            if (materialProperties.value[index].propertyType == UnityEngine.Rendering.ShaderPropertyType.Float)
                return new TogglableValueWrapper(index, materialProperties);
            return null;
        }

        public static TogglableValueWrapper Create(int index, MaterialPropertiesWrapper materialProperties, 
            Material material, string keyword)
        {
            if (material != null && keyword != null &&
                materialProperties.value[index].propertyType == UnityEngine.Rendering.ShaderPropertyType.Float)
            {
                return new TogglableValueWrapper(index, materialProperties, material, keyword);
            }
            return null;
        }

        public bool HasMixedValue
        {
            get
            {
                if (serializedProperty != null && serializedProperty.hasMultipleDifferentValues)
                    return true;
                if (MaterialProperty != null && MaterialProperty.hasMixedValue)
                {
                    return true;
                }
                return false;
            }
        }

        private TogglableValueWrapper(SerializedProperty serializedProperty)
        {
            this.serializedProperty = serializedProperty;
        }

        private TogglableValueWrapper(int index, MaterialPropertiesWrapper materialProperties, 
            Material material = null, string shaderKeyword = null)
        {
            this.materialPropertyIndex = index;
            this.materialProperties = materialProperties;
            targetMaterial = material;
            this.shaderKeyword = shaderKeyword;
        }

        public bool GetValue()
        {
            if (serializedProperty != null)
                return serializedProperty.boolValue;

            if (MaterialProperty != null)
            {
                bool b = MaterialProperty.floatValue > 0;
                SetKeywordOnMaterial(b);
                return b;
            }

            return false;
        }

        public void SetValue(bool b, bool forceIfMixed)
        {
            if (serializedProperty != null)
            {
                if (!forceIfMixed && serializedProperty.hasMultipleDifferentValues)
                    return;
                serializedProperty.boolValue = b;
                return;
            }

            if (MaterialProperty != null)
            {
                if (!forceIfMixed && MaterialProperty.hasMixedValue)
                    return;
                MaterialProperty.floatValue = b ? 1 : 0;
                SetKeywordOnMaterial(b);
                return;
            }
        }

        private void SetKeywordOnMaterial(bool b)
        {
            if (targetMaterial != null && shaderKeyword != null)
            {
                if (b)
                    targetMaterial.EnableKeyword(shaderKeyword);
                else
                    targetMaterial.DisableKeyword(shaderKeyword);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Markup-Attributes-main/Assets/MarkupAttributes/Core/TogglableValueWrapper.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Rope/Core/DisableInPlayModePropertyDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f096bd19e16171c4bad990519eddc8b7
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;
using UnityEditor;

namespace RopeToolkit
{
    [CustomPropertyDrawer(typeof(DisableInPlayModeAttribute))]
    public class BeginLockInPlayModeDecoratorDrawer : PropertyDrawer
    {
        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            return EditorGUI.GetPropertyHeight(property, label, true);
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            var playing = Application.isPlaying;
            if (playing)
            {
                GUI.enabled = false;
            }

            var ranges = fieldInfo.GetCustomAttributes(typeof(RangeAttribute), true);
            var range = ranges != null && ranges.Length > 0 ? ranges[0] as RangeAttribute : null;
            if (range != null && property.propertyType == SerializedPropertyType.Float)
            {
                EditorGUI.Slider(position, property, range.min, range.max);
            }
            else if (range != null && property.propertyType == SerializedPropertyType.Integer)
            {
                EditorGUI.IntSlider(position, property, (int)range.min, (int)range.max);
            }
            else
            {
                EditorGUI.PropertyField(position, property, label, true);
            }

            if (playing)
            {
                GUI.enabled = true;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Rope/Core/DisableInPlayModePropertyDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Rope/Core/RopeEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: cb712eea104baa44597cd77e9a7f2cb1
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;
using UnityEditor;
using Unity.Mathematics;

namespace RopeToolkit
{
    [CustomEditor(typeof(Rope)), CanEditMultipleObjects]
    public class RopeEditor : Editor
    {
        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
        }

        public void OnSceneGUI()
        {
            if (Application.isPlaying)
            {
                return;
            }

            var rope = target as Rope;
            if (rope == null)
            {
                return;
            }

            // Draw floating window with buttons
            if (Selection.objects.Length == 1)
            {
                Handles.BeginGUI();
                GUI.skin = EditorGUIUtility.GetBuiltinSkin(EditorSkin.Scene);

                var lastSpawn = rope.spawnPoints.Count > 0 ? rope.spawnPoints[rope.spawnPoints.Count - 1] : float3.zero;
                var location = HandleUtility.WorldToGUIPoint(rope.transform.TransformPoint(lastSpawn)) + Vector2.right * 64.0f;
                GUILayout.Window(0, new Rect(location, Vector2.one), (id) =>
                {
                    if (GUILayout.Button("Push spawn point"))
                    {
                        Undo.RecordObject(rope, "Push Rope Spawn Point");
                        rope.PushSpawnPoint();
                    }
                    if (rope.spawnPoints.Count > 2 && GUILayout.Button("Pop spawn point"))
                    {
                        Undo.RecordObject(rope, "Pop Rope Spawn Point");
                        rope.PopSpawnPoint();
                    }
                }, rope.gameObject.name);

                Handles.EndGUI();
            }

            // Draw position handles
            Handles.color = Rope.Colors.spawnPointHandle;
            for (int i = 0; i < rope.spawnPoints.Count; i++)
            {
                var spawnPoint = rope.spawnPoints[i];
                var position = rope.transform.TransformPoint(spawnPoint);

                EditorGUI.BeginChangeCheck();
                if (Event.current.modifiers.HasFlag(EventModifiers.Shift))
                {
                    position = Handles.PositionHandle(position, Quaternion.identity);
                }
                else
                {
                    var fmh_69_65_638846360657886157 = Quaternion.identity; position = Handles.FreeMoveHandle(position, rope.radius * 4.0f, Vector3.one * 0.5f, Handles.SphereHandleCap);
                }
                if (EditorGUI.EndChangeCheck())
                {
                    Undo.RecordObject(rope, "Move Rope Spawn Point");
                    spawnPoint = rope.transform.InverseTransformPoint(position);
                    rope.spawnPoints[i] = spawnPoint;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Rope/Core/RopeEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/00_Main/ApplyTorqueOnKey.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c1451225f8bdb1545ae082cfd03cddfd
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;

namespace RopeToolkit.Example
{
    public class ApplyTorqueOnKey : MonoBehaviour
    {
        public Vector3 relativeTorque;
        public float maxAngularSpeed;

        public KeyCode key;

        protected Rigidbody rb;

        public void Start()
        {
            rb = GetComponent<Rigidbody>();
        }

        public void FixedUpdate()
        {
            if (rb == null)
            {
                return;
            }

            if (Input.GetKey(key))
            {
                var torqueAxis = relativeTorque.normalized;
                var strength = Mathf.SmoothStep(relativeTorque.magnitude, 0.0f, Vector3.Dot(torqueAxis, rb.angularVelocity) / maxAngularSpeed);
                rb.AddRelativeTorque(torqueAxis * strength, ForceMode.Force);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/00_Main/ApplyTorqueOnKey.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/00_Main/RopeBridgePlank.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1a91ac0b60b8b4d4eba00ef9563d2003
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;
using Unity.Mathematics;

namespace RopeToolkit.Example
{
    [RequireComponent(typeof(Rigidbody))]
    public class RopeBridgePlank : MonoBehaviour
    {
        public Rope ropeLeft;
        public Rope ropeRight;
        public float extentLeft = -0.5f;
        public float extentRight = 0.5f;
        public float extentPivot = 0.5f;

        [Tooltip("A measure of the longitudal stiffness of the plank. That is, how quickly should the particles on the opposite ropes move to the correct distance between them.")]
        [Range(0.0f, 1.0f)] public float longitudalStiffness = 0.25f;

        public float restingRigidbodyMassMultiplier = 5.0f;

        protected Rigidbody rb;
        protected int particleLeft;
        protected int particleRight;
        protected int particlePivotLeft;
        protected int particlePivotRight;
        protected float distance;
        protected float frameTotalMass;

        public void Start()
        {
            rb = GetComponent<Rigidbody>();
            if (rb != null)
            {
                rb.isKinematic = true;
            }

            var pointOnBodyLeft = transform.TransformPoint(Vector3.right * extentLeft);
            var pointOnBodyRight = transform.TransformPoint(Vector3.right * extentRight);
            var pointOnBodyPivot = transform.TransformPoint(Vector3.forward * extentPivot);

            if (ropeLeft != null)
            {
                ropeLeft.GetClosestParticle(pointOnBodyLeft, out particleLeft, out float distance);
                ropeLeft.GetClosestParticle(pointOnBodyPivot, out particlePivotLeft, out distance);
            }
            if (ropeRight != null)
            {
                ropeRight.GetClosestParticle(pointOnBodyRight, out particleRight, out float distance);
                ropeRight.GetClosestParticle(pointOnBodyPivot, out particlePivotRight, out distance);
            }

            if (ropeLeft != null && ropeRight != null)
            {
                distance = math.distance(ropeLeft.GetPositionAt(particleLeft), ropeRight.GetPositionAt(particleRight));
            }
        }

        public void FixedUpdate()
        {
            if (rb == null)
            {
                return;
            }
            if (ropeLeft == null || ropeRight == null)
            {
                rb.isKinematic = false;
                return;
            }

            var left = ropeLeft.GetPositionAt(particleLeft);
            var right = ropeRight.GetPositionAt(particleRight);
            var pivot = (ropeLeft.GetPositionAt(particlePivotLeft) + ropeRight.GetPositionAt(particlePivotRight)) * 0.5f;

            left.KeepAtDistance(ref right, distance, longitudalStiffness);

            var middle = (left + right) * 0.5f;

            rb.MoveRotation(Quaternion.LookRotation(pivot - middle, Vector3.Cross(pivot - middle, right - left)));
            rb.MovePosition((Vector3)middle - transform.TransformVector(Vector3.right * (extentLeft + extentRight) * 0.5f));

            ropeLeft.SetPositionAt(particleLeft, left);
            ropeRight.SetPositionAt(particleRight, right);

            var massMultiplier = 1.0f + frameTotalMass * restingRigidbodyMassMultiplier;
            frameTotalMass = 0.0f;

            if (ropeLeft.GetMassMultiplierAt(particleLeft) > 0.0f)
            {
                ropeLeft.SetMassMultiplierAt(particleLeft, massMultiplier);
            }
            if (ropeRight.GetMassMultiplierAt(particleRight) > 0.0f)
            {
                ropeRight.SetMassMultiplierAt(particleRight, massMultiplier);
            }
        }

        public void OnCollisionStay(Collision collision)
        {
            if (collision.rigidbody != null)
            {
                frameTotalMass += collision.rigidbody.mass;
            }
        }

#if UNITY_EDITOR
        public void OnDrawGizmosSelected()
        {
            var pointOnBodyLeft = transform.TransformPoint(Vector3.right * extentLeft);
            var pointOnBodyRight = transform.TransformPoint(Vector3.right * extentRight);
            var pointOnBodyPivot = transform.TransformPoint(Vector3.forward * extentPivot);

            Gizmos.color = Color.red;
            Gizmos.DrawWireSphere(pointOnBodyLeft, 0.05f);
            Gizmos.DrawWireSphere(pointOnBodyRight, 0.05f);
            Gizmos.DrawLine(pointOnBodyLeft, pointOnBodyRight);

            Gizmos.color = Color.blue;
            Gizmos.DrawWireSphere(pointOnBodyPivot, 0.05f);
            Gizmos.DrawLine(pointOnBodyLeft, pointOnBodyPivot);
            Gizmos.DrawLine(pointOnBodyRight, pointOnBodyPivot);
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/00_Main/RopeBridgePlank.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/00_Main/RopeMouseInteraction.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d741c2b5cb0190448822896128d51f8a
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;
using Unity.Mathematics;
using System.Collections.Generic;

namespace RopeToolkit
{
    public class RopeMouseInteraction : MonoBehaviour
    {
        public Mesh indicatorMesh;
        public Material indicatorMaterial;

        public List<Rope> ropes;

        protected bool ready;
        protected Rope pulledRope;
        protected int pulledParticle;
        protected float pulledDistance;
        protected float3 currentPosition;
        protected float3 targetPosition;

        protected Rope GetClosestRope(Ray ray, out int closestParticleIndex, out float closestDistanceAlongRay)
        {
            closestParticleIndex = -1;
            closestDistanceAlongRay = 0.0f;

            var closestRopeIndex = -1;
            var closestDistance = 0.0f;
            for (int i = 0; i < ropes.Count; i++)
            {
                ropes[i].GetClosestParticle(ray, out int particleIndex, out float distance, out float distanceAlongRay);

                if (distance < closestDistance || closestRopeIndex == -1)
                {
                    closestRopeIndex = i;
                    closestParticleIndex = particleIndex;
                    closestDistance = distance;
                    closestDistanceAlongRay = distanceAlongRay;
                }
            }

            return closestRopeIndex != -1 ? ropes[closestRopeIndex] : null;
        }
        
        public void FixedUpdate()
        {
            var ray = Camera.main.ScreenPointToRay(Input.mousePosition);
            
            if (Input.GetMouseButton(0))
            {
                // Mouse down
                if (ready && pulledRope == null)
                {
                    // Not pulling a rope, find the closest one to the mouse
                    var closestRope = GetClosestRope(ray, out int closestParticleIndex, out float closestDistanceAlongRay);

                    if (closestRope != null && closestParticleIndex != -1 && closestRope.GetMassMultiplierAt(closestParticleIndex) > 0.0f)
                    {
                        // Found a rope and particle on the rope, start pulling that particle!
                        pulledRope = closestRope;
                        pulledParticle = closestParticleIndex;
                        pulledDistance = closestDistanceAlongRay;

                        ready = false;
                    }
                }
            }
            else
            {
                // Mouse up
                if (pulledRope != null)
                {
                    // Stop pulling the rope
                    pulledRope.SetMassMultiplierAt(pulledParticle, 1.0f);
                    pulledRope = null;
                }
            }

            if (pulledRope != null)
            {
                // We are pulling the rope

                // Adjust the grab plane
                pulledDistance += Input.mouseScrollDelta.y * 2.0f;

                // Move the rope particle to the mouse position on the grab-plane
                currentPosition = pulledRope.GetPositionAt(pulledParticle);
                targetPosition = ray.GetPoint(pulledDistance);

                pulledRope.SetPositionAt(pulledParticle, targetPosition);
                pulledRope.SetVelocityAt(pulledParticle, float3.zero);
                pulledRope.SetMassMultiplierAt(pulledParticle, 0.0f);

                // Split the rope if spacebar is pressed!
                if (Input.GetKey(KeyCode.Space))
                {
                    ropes.Remove(pulledRope);

                    var newRopes = new Rope[2];
                    pulledRope.SplitAt(pulledParticle, newRopes);
                    if (newRopes[0] != null) ropes.Add(newRopes[0]);
                    if (newRopes[1] != null) ropes.Add(newRopes[1]);

                    pulledRope = null;
                }
            }
        }

        public void Update()
        {
            if (!Input.GetMouseButton(0))
            {
                ready = true;
            }

            if (indicatorMesh == null || indicatorMaterial == null)
            {
                return;
            }

            if (pulledRope != null)
            {
                Graphics.DrawMesh(indicatorMesh, Matrix4x4.TRS(currentPosition, Quaternion.identity, Vector3.one * 0.25f), indicatorMaterial, 0);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/00_Main/RopeMouseInteraction.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/00_Main/SoftBackdrop/SoftBackdrop.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6c341fba7d5799942b92f6085edb4743
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;
using System.Collections.Generic;
using UnityEngine.Rendering;

[ExecuteAlways]
public class SoftBackdrop : MonoBehaviour
{
    protected const int ParticleCount = 32;
    protected const float Size = 10.0f;

    public Material speckMaterial;
    public Mesh speckMesh;
    public float speckScale = 0.5f;
    public float speckMaxSpeed = 1.0f;

    public Material sphereMaterial;
    public Mesh sphereMesh;

    protected Mesh invertedSphereMesh;

    protected Vector3[] positions;
    protected Vector3[] velocities;
    protected Matrix4x4[] transforms;

    public void Start()
    {
        Init();
    }

    public void OnValidate()
    {
        Init();
    }

    public void Init()
    {
        positions = new Vector3[ParticleCount];
        velocities = new Vector3[ParticleCount];
        transforms = new Matrix4x4[ParticleCount];

        for (int i = 0; i < positions.Length; i++)
        {
            positions[i] = (new Vector3(Random.value, Random.value, Random.value) * 2.0f - new Vector3(1.0f, 1.0f, 1.0f)) * Size;
            velocities[i] = Random.insideUnitSphere * Random.value * speckMaxSpeed;
        }

        if (sphereMesh != null)
        {
            var n = sphereMesh.normals;
            for (int i = 0; i < n.Length; i++)
            {
                n[i] = -n[i];
            }
            var t = sphereMesh.triangles;
            for (int i = 0; i < t.Length / 3; i++)
            {
                var i1 = t[i * 3 + 1];
                t[i * 3 + 1] = t[i * 3 + 2];
                t[i * 3 + 2] = i1;
            }
            if (invertedSphereMesh != null)
            {
                if (Application.isPlaying)
                {
                    Destroy(invertedSphereMesh);
                }
                else
                {
                    DestroyImmediate(invertedSphereMesh);
                }
            }
            invertedSphereMesh = new Mesh
            {
                vertices = sphereMesh.vertices,
                normals = n,
                triangles = t,
            };
        }
    }

    public void OnDestroy()
    {
        if (invertedSphereMesh != null)
        {
            if (Application.isPlaying)
            {
                Destroy(invertedSphereMesh);
            }
            else
            {
                DestroyImmediate(invertedSphereMesh);
            }
        }
    }

    public void Update()
    {
        if (positions == null)
        {
            return;
        }

        for (int i = 0; i < positions.Length; i++)
        {
            var p = positions[i];
            var v = velocities[i];

            p += v* Time.deltaTime;

            if (p.magnitude > Size)
            {
                p = -p.normalized * Size;
            }

            positions[i] = p;
        }

        for (int i = 0; i < positions.Length; i++)
        {
            var dir = positions[i].normalized;
            var size = 1.0f - Mathf.Pow(Mathf.Clamp01(positions[i].magnitude / Size), 4.0f);
            size *= speckScale;
            transforms[i] = Matrix4x4.TRS(transform.TransformPoint(dir * 0.3f), Quaternion.LookRotation(dir), transform.lossyScale * size);
        }

        if (invertedSphereMesh != null && sphereMaterial != null)
        {
            Graphics.DrawMesh(invertedSphereMesh, transform.localToWorldMatrix, sphereMaterial, 0, null, 0, null, false, false);
        }

        if (speckMesh != null && speckMaterial != null)
        {
            speckMaterial.enableInstancing = true;
            Graphics.DrawMeshInstanced(speckMesh, 0, speckMaterial, transforms, transforms.Length, null, ShadowCastingMode.Off, false);
        }
    }

    public void OnDrawGizmos()
    {
        if (positions == null)
        {
            return;
        }

        Gizmos.color = Color.red;
        for (int i = 0; i < positions.Length; i++)
        {
            Gizmos.DrawWireSphere(transform.TransformPoint(positions[i]), 0.5f);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/00_Main/SoftBackdrop/SoftBackdrop.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/01_DynamicAttach/BackAndForthMovement.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e4453a595a14042518c9341023037a8d
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace RopeToolkit.Example
{
    public class BackAndForthMovement : MonoBehaviour
    {
        public Vector3 amount = new Vector3(2.0f, 0.0f, 0.0f);

        protected Vector3 startPos;

        public void Start()
        {
            startPos = transform.position;
        }

        public void Update()
        {
            transform.position = startPos + amount * Mathf.Sin(Time.time);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/01_DynamicAttach/BackAndForthMovement.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/01_DynamicAttach/DynamicAttach.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6ae913a7495f9445da3517bf946c1e9f
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace RopeToolkit.Example
{
    public class DynamicAttach : MonoBehaviour
    {
        public Material ropeMaterial;

        public Vector3 attachPoint;
        public Transform target;
        public Vector3 targetAttachPoint;

        protected GameObject ropeObject;

        public void Detach()
        {
            if (ropeObject)
            {
                Destroy(ropeObject);
            }
            ropeObject = null;
        }

        public void Attach()
        {
            Detach();

            ropeObject = new GameObject();
            ropeObject.name = "Rope";

            var start = transform.TransformPoint(attachPoint);
            var end = target.TransformPoint(targetAttachPoint);

            var rope = ropeObject.AddComponent<Rope>();
            rope.material = ropeMaterial;
            rope.spawnPoints.Add(ropeObject.transform.InverseTransformPoint(start));
            rope.spawnPoints.Add(ropeObject.transform.InverseTransformPoint(end));

            var conn0 = ropeObject.AddComponent<RopeConnection>();
            conn0.type = RopeConnectionType.PinRopeToTransform;
            conn0.ropeLocation = 0.0f;
            conn0.transformSettings.transform = transform;
            conn0.localConnectionPoint = attachPoint;

            var conn1 = ropeObject.AddComponent<RopeConnection>();
            conn1.type = RopeConnectionType.PinRopeToTransform;
            conn1.ropeLocation = 1.0f;
            conn1.transformSettings.transform = target;
            conn1.localConnectionPoint = targetAttachPoint;
        }

        public void OnGUI()
        {
            if (GUI.Button(new Rect(16, 16, 100, 32), "Attach"))
            {
                Attach();
            }
            if (GUI.Button(new Rect(16, 64, 100, 32), "Detach"))
            {
                Detach();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/01_DynamicAttach/DynamicAttach.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/02_BoxingRing/Spawner.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: d7f10005d854a49a4b3371d4701441fd
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Spawner : MonoBehaviour
{
    public Transform prefab;
    public float randomRange = 0.5f;
    public float timeToSpawn = 4.0f;

    private float timer;

    public void Update()
    {
        timer += Time.deltaTime;

        if (timer >= timeToSpawn)
        {
            timer = 0.0f;

            var obj = Instantiate(prefab, transform.position + Random.insideUnitSphere * randomRange, transform.rotation);
            obj.gameObject.SetActive(true);
        }
    }

    public void OnDrawGizmos()
    {
        Gizmos.color = Color.yellow;
        Gizmos.DrawWireSphere(transform.position, randomRange);
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/Rope/Examples/02_BoxingRing/Spawner.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/SplineMesh/Editor/SplineEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 939ffc1cc7c3bfc42b8b61242dd8f0f6
# ASMDEF: ldx.framework.editor.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace SplineMesh {
    [CustomEditor(typeof(Spline))]
    public class SplineEditor : Editor {

        private const int QUAD_SIZE = 12;
        private static Color CURVE_COLOR = new Color(0.8f, 0.8f, 0.8f);
        private static Color CURVE_BUTTON_COLOR = new Color(0.8f, 0.8f, 0.8f);
        private static Color DIRECTION_COLOR = Color.red;
        private static Color DIRECTION_BUTTON_COLOR = Color.red;
        private static Color UP_BUTTON_COLOR = Color.green;

        private static bool showUpVector = false;

        private enum SelectionType {
            Node,
            Direction,
            InverseDirection,
            Up
        }

        private SplineNode selection;
        private SelectionType selectionType;
        private bool mustCreateNewNode = false;
        private SerializedProperty nodesProp { get { return serializedObject.FindProperty("nodes"); } }
        private Spline spline { get { return (Spline)serializedObject.targetObject; } }

        private GUIStyle nodeButtonStyle, directionButtonStyle, upButtonStyle;

        private void OnEnable() {
            Texture2D t = new Texture2D(1, 1);
            t.SetPixel(0, 0, CURVE_BUTTON_COLOR);
            t.Apply();
            nodeButtonStyle = new GUIStyle();
            nodeButtonStyle.normal.background = t;

            t = new Texture2D(1, 1);
            t.SetPixel(0, 0, DIRECTION_BUTTON_COLOR);
            t.Apply();
            directionButtonStyle = new GUIStyle();
            directionButtonStyle.normal.background = t;

            t = new Texture2D(1, 1);
            t.SetPixel(0, 0, UP_BUTTON_COLOR);
            t.Apply();
            upButtonStyle = new GUIStyle();
            upButtonStyle.normal.background = t;
            selection = null;
			
            Undo.undoRedoPerformed -= spline.RefreshCurves;
            Undo.undoRedoPerformed += spline.RefreshCurves;
        }

        SplineNode AddClonedNode(SplineNode node) {
            int index = spline.nodes.IndexOf(node);
            SplineNode res = new SplineNode(node.Position, node.Direction);
            if (index == spline.nodes.Count - 1) {
                spline.AddNode(res);
            } else {
                spline.InsertNode(index + 1, res);
            }
            return res;
        }

        void OnSceneGUI() {
            // disable game object transform gyzmo
            // if the spline script is active
            if (Selection.activeGameObject == spline.gameObject) {
                if (!spline.enabled) {
                    Tools.current = Tool.Move;
                } else {
                    Tools.current = Tool.None;
                    if (selection == null && spline.nodes.Count > 0)
                        selection = spline.nodes[0];
                }
            }

            // draw a bezier curve for each curve in the spline
            foreach (CubicBezierCurve curve in spline.GetCurves()) {
                Handles.DrawBezier(spline.transform.TransformPoint(curve.n1.Position),
                    spline.transform.TransformPoint(curve.n2.Position),
                    spline.transform.TransformPoint(curve.n1.Direction),
                    spline.transform.TransformPoint(curve.GetInverseDirection()),
                    CURVE_COLOR,
                    null,
                    3);
            }

            if (!spline.enabled)
                return;

            // draw the selection handles
            switch (selectionType) {
                case SelectionType.Node:
                    // place a handle on the node and manage position change

                    // TODO place the handle depending on user params (local or world)
                    Vector3 newPosition = spline.transform.InverseTransformPoint(Handles.PositionHandle(spline.transform.TransformPoint(selection.Position), spline.transform.rotation));
                    if (newPosition != selection.Position) {
                        Undo.RecordObject(spline, "Spline node change");
                        // position handle has been moved
                        if (mustCreateNewNode) {
                            mustCreateNewNode = false;
                            selection = AddClonedNode(selection);
                            selection.Direction += newPosition - selection.Position;
                            selection.Position = newPosition;
                        } else {
                            selection.Direction += newPosition - selection.Position;
                            selection.Position = newPosition;
                        }
                    }
                    break;
                case SelectionType.Direction:
                    var result = Handles.PositionHandle(spline.transform.TransformPoint(selection.Direction), Quaternion.identity);
                    Vector3 newDir = spline.transform.InverseTransformPoint(result);
                    if (newDir != selection.Direction)
                    {
                        Undo.RecordObject(spline, "Spline node change");
                        selection.Direction = newDir;
                    }
                    break;
                case SelectionType.InverseDirection:
                    result = Handles.PositionHandle(2 * spline.transform.TransformPoint(selection.Position) - spline.transform.TransformPoint(selection.Direction), Quaternion.identity);
                    result = 2 * selection.Position - spline.transform.InverseTransformPoint(result);
                    if (result != selection.Direction)
                    {
                        Undo.RecordObject(spline, "Spline node change");
                        selection.Direction = result;
                    }
                    break;
                case SelectionType.Up:
                    result = Handles.PositionHandle(spline.transform.TransformPoint(selection.Position + selection.Up), Quaternion.LookRotation(selection.Direction - selection.Position));
                    result = (spline.transform.InverseTransformPoint(result) - selection.Position).normalized;
                    if (result != selection.Up)
                    {
                        Undo.RecordObject(spline, "Spline node change");
                        selection.Up = result;
                    }
                    break;
            }

            // draw the handles of all nodes, and manage selection motion
            Handles.BeginGUI();
            foreach (SplineNode n in spline.nodes) {
                var dir = spline.transform.TransformPoint(n.Direction);
                var pos = spline.transform.TransformPoint(n.Position);
                var invDir = spline.transform.TransformPoint(2 * n.Position - n.Direction);
                var up = spline.transform.TransformPoint(n.Position + n.Up);
                // first we check if at least one thing is in the camera field of view
                if (!(CameraUtility.IsOnScreen(pos) ||
                    CameraUtility.IsOnScreen(dir) ||
                    CameraUtility.IsOnScreen(invDir) ||
                    (showUpVector && CameraUtility.IsOnScreen(up)))) {
                    continue;
                }

                Vector3 guiPos = HandleUtility.WorldToGUIPoint(pos);
                if (n == selection) {
                    Vector3 guiDir = HandleUtility.WorldToGUIPoint(dir);
                    Vector3 guiInvDir = HandleUtility.WorldToGUIPoint(invDir);
                    Vector3 guiUp = HandleUtility.WorldToGUIPoint(up);

                    // for the selected node, we also draw a line and place two buttons for directions
                    Handles.color = DIRECTION_COLOR;
                    Handles.DrawLine(guiDir, guiInvDir);

                    // draw quads direction and inverse direction if they are not selected
                    if (selectionType != SelectionType.Node) {
                        if (Button(guiPos, directionButtonStyle)) {
                            selectionType = SelectionType.Node;
                        }
                    }
                    if (selectionType != SelectionType.Direction) {
                        if (Button(guiDir, directionButtonStyle)) {
                            selectionType = SelectionType.Direction;
                        }
                    }
                    if (selectionType != SelectionType.InverseDirection) {
                        if (Button(guiInvDir, directionButtonStyle)) {
                            selectionType = SelectionType.InverseDirection;
                        }
                    }
                    if (showUpVector) {
                        Handles.color = Color.green;
                        Handles.DrawLine(guiPos, guiUp);
                        if (selectionType != SelectionType.Up) {
                            if (Button(guiUp, upButtonStyle)) {
                                selectionType = SelectionType.Up;
                            }
                        }
                    }
                } else {
                    if (Button(guiPos, nodeButtonStyle)) {
                        selection = n;
                        selectionType = SelectionType.Node;
                    }
                }
            }
            Handles.EndGUI();
            if (GUI.changed)
                EditorUtility.SetDirty(target);
        }

        bool Button(Vector2 position, GUIStyle style) {
            return GUI.Button(new Rect(position - new Vector2(QUAD_SIZE / 2, QUAD_SIZE / 2), new Vector2(QUAD_SIZE, QUAD_SIZE)), GUIContent.none, style);
        }

        public override void OnInspectorGUI() {
            serializedObject.Update();

            if(spline.nodes.IndexOf(selection) < 0) {
                selection = null;
            }

            // add button
            if (selection == null) {
                GUI.enabled = false;
            }
            if (GUILayout.Button("Add node after selected")) {
                Undo.RecordObject(spline, "add spline node");
                SplineNode newNode = new SplineNode(selection.Direction, selection.Direction + selection.Direction - selection.Position);
                var index = spline.nodes.IndexOf(selection);
                if(index == spline.nodes.Count - 1) {
                    spline.AddNode(newNode);
                } else {
                    spline.InsertNode(index + 1, newNode);
                }
                selection = newNode;
                serializedObject.Update();
            }
            GUI.enabled = true;

            // delete button
            if (selection == null || spline.nodes.Count <= 2) {
                GUI.enabled = false;
            }
            if (GUILayout.Button("Delete selected node")) {
                Undo.RecordObject(spline, "delete spline node");
                spline.RemoveNode(selection);
                selection = null;
                serializedObject.Update();
            }
            GUI.enabled = true;

            showUpVector = GUILayout.Toggle(showUpVector, "Show up vector");
            spline.IsLoop = GUILayout.Toggle(spline.IsLoop, "Is loop");

            // nodes
            GUI.enabled = false;
            EditorGUILayout.PropertyField(nodesProp);
            GUI.enabled = true;

            if (selection != null) {
                int index = spline.nodes.IndexOf(selection);
                SerializedProperty nodeProp = nodesProp.GetArrayElementAtIndex(index);

                EditorGUILayout.LabelField("Selected node (node " + index + ")");

                EditorGUI.indentLevel++;
                DrawNodeData(nodeProp, selection);
                EditorGUI.indentLevel--;
            } else {
                EditorGUILayout.LabelField("No selected node");
            }
        }

        private void DrawNodeData(SerializedProperty nodeProperty, SplineNode node) {
            var positionProp = nodeProperty.FindPropertyRelative("position");
            var directionProp = nodeProperty.FindPropertyRelative("direction");
            var upProp = nodeProperty.FindPropertyRelative("up");
            var scaleProp = nodeProperty.FindPropertyRelative("scale");
            var rollProp = nodeProperty.FindPropertyRelative("roll");

            EditorGUI.BeginChangeCheck();
            EditorGUILayout.PropertyField(positionProp, new GUIContent("Position"));
            EditorGUILayout.PropertyField(directionProp, new GUIContent("Direction"));
            EditorGUILayout.PropertyField(upProp, new GUIContent("Up"));
            EditorGUILayout.PropertyField(scaleProp, new GUIContent("Scale"));
            EditorGUILayout.PropertyField(rollProp, new GUIContent("Roll"));

            if (EditorGUI.EndChangeCheck()) {
                Undo.RecordObject(target, "Spline nodes change");
                node.Position = positionProp.vector3Value;
                node.Direction = directionProp.vector3Value;
                node.Up = upProp.vector3Value;
                node.Scale = scaleProp.vector2Value;
                node.Roll = rollProp.floatValue;
                serializedObject.Update();
            }
        }

        [MenuItem("GameObject/3D Object/Spline")]
        public static void CreateSpline() {
            new GameObject("Spline", typeof(Spline));
        }

        [DrawGizmo(GizmoType.InSelectionHierarchy)]
        static void DisplayUnselected(Spline spline, GizmoType gizmoType) {
            foreach (CubicBezierCurve curve in spline.GetCurves()) {
                Handles.DrawBezier(spline.transform.TransformPoint(curve.n1.Position),
                    spline.transform.TransformPoint(curve.n2.Position),
                    spline.transform.TransformPoint(curve.n1.Direction),
                    spline.transform.TransformPoint(curve.GetInverseDirection()),
                    CURVE_COLOR,
                    null,
                    3);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/SplineMesh/Editor/SplineEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/SplineMesh/Editor/SplineExtrusionEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7f8d2f224507f8d4881b64654b6cb902
# ASMDEF: ldx.framework.editor.dll
# ---
using UnityEngine;
using System.Collections;
using UnityEditor;

namespace SplineMesh {
    [CustomEditor(typeof(SplineExtrusion))]
    public class SplineExtrusionEditor : Editor {
        private const int QUAD_SIZE = 10;
        private Color CURVE_COLOR = new Color(0.8f, 0.8f, 0.8f);
        private bool mustCreateNewNode = false;
        private SerializedProperty textureScale;
        private SerializedProperty sampleSpacing;
        private SerializedProperty material;
        private SerializedProperty vertices;

        private SplineExtrusion se;
        private ExtrusionSegment.Vertex selection = null;

        private void OnEnable() {
            se = (SplineExtrusion)target;
            textureScale = serializedObject.FindProperty("textureScale");
            sampleSpacing = serializedObject.FindProperty("sampleSpacing");
            material = serializedObject.FindProperty("material");
            vertices = serializedObject.FindProperty("shapeVertices");
        }

        void OnSceneGUI() {
            Event e = Event.current;
            if (e.type == EventType.MouseDown) {
                Undo.RegisterCompleteObjectUndo(se, "change extruded shape");
                // if control key pressed, we will have to create a new vertex if position is changed
                if (e.alt) {
                    mustCreateNewNode = true;
                }
            }
            if (e.type == EventType.MouseUp) {
                mustCreateNewNode = false;
            }
            var spline = se.GetComponent<Spline>();

            CurveSample startSample = spline.GetSample(0);
            Quaternion q = startSample.Rotation;
            foreach (ExtrusionSegment.Vertex v in se.shapeVertices) {
                // we create point and normal relative to the spline start where the shape is drawn
                Vector3 point = se.transform.TransformPoint(q * v.point + startSample.location);
                Vector3 normal = se.transform.TransformPoint(q * (v.point + v.normal) + startSample.location);

                // first we check if at least one thing is in the camera field of view
                if (!CameraUtility.IsOnScreen(point) && !CameraUtility.IsOnScreen(normal)) continue;

                if (v == selection) {
                    // draw the handles for selected vertex position and normal
                    float size = HandleUtility.GetHandleSize(point) * 0.3f;
                    float snap = 0.1f;

                    // create a handle for the vertex position
                    Vector3 movedPoint = Handles.Slider2D(0, point, startSample.tangent, Vector3.right, Vector3.up, size, Handles.CircleHandleCap, new Vector2(snap, snap));
                    if (movedPoint != point) {
                        // position has been moved
                        Vector2 newVertexPoint = Quaternion.Inverse(q) * (se.transform.InverseTransformPoint(movedPoint) - startSample.location);
                        if (mustCreateNewNode) {
                            // We must create a new node
                            mustCreateNewNode = false;
                            ExtrusionSegment.Vertex newVertex = new ExtrusionSegment.Vertex(newVertexPoint, v.normal, v.uCoord);
                            int i = se.shapeVertices.IndexOf(v);
                            if (i == se.shapeVertices.Count - 1) {
                                se.shapeVertices.Add(newVertex);
                            } else {
                                se.shapeVertices.Insert(i + 1, newVertex);
                            }
                            selection = newVertex;
                        } else {
                            v.point = newVertexPoint;
                            // normal must be updated if point has been moved
                            normal = se.transform.TransformPoint(q * (v.point + v.normal) + startSample.location);
                        }
                        se.SetToUpdate();
                    } else {
                        // vertex position handle hasn't been moved
                        // create a handle for normal
                        Vector3 movedNormal = Handles.Slider2D(normal, startSample.tangent, Vector3.right, Vector3.up, size, Handles.CircleHandleCap, snap);
                        if (movedNormal != normal) {
                            // normal has been moved
                            v.normal = (Vector2)(Quaternion.Inverse(q) * (se.transform.InverseTransformPoint(movedNormal) - startSample.location)) - v.point;
                            se.SetToUpdate();
                        }
                    }

                    Handles.BeginGUI();
                    DrawQuad(HandleUtility.WorldToGUIPoint(point), CURVE_COLOR);
                    DrawQuad(HandleUtility.WorldToGUIPoint(normal), Color.red);
                    Handles.EndGUI();
                } else {
                    // we draw a button to allow selection of the vertex
                    Handles.BeginGUI();
                    Vector2 p = HandleUtility.WorldToGUIPoint(point);
                    if (GUI.Button(new Rect(p - new Vector2(QUAD_SIZE / 2, QUAD_SIZE / 2), new Vector2(QUAD_SIZE, QUAD_SIZE)), GUIContent.none)) {
                        selection = v;
                    }
                    Handles.EndGUI();
                }

                // draw an arrow from the vertex location to the normal
                Handles.color = Color.red;
                Handles.DrawLine(point, normal);

                // draw a line between that vertex and the next one
                int index = se.shapeVertices.IndexOf(v);
                int nextIndex = index == se.shapeVertices.Count - 1 ? 0 : index + 1;
                ExtrusionSegment.Vertex next = se.shapeVertices[nextIndex];
                Handles.color = CURVE_COLOR;
                Vector3 vAtSplineEnd = se.transform.TransformPoint(q * next.point + startSample.location);
                Handles.DrawLine(point, vAtSplineEnd);
            }
        }

        void DrawQuad(Rect rect, Color color) {
            Texture2D texture = new Texture2D(1, 1);
            texture.SetPixel(0, 0, color);
            texture.Apply();
            GUI.skin.box.normal.background = texture;
            GUI.Box(rect, GUIContent.none);
        }

        void DrawQuad(Vector2 position, Color color) {
            DrawQuad(new Rect(position - new Vector2(QUAD_SIZE / 2, QUAD_SIZE / 2), new Vector2(QUAD_SIZE, QUAD_SIZE)), color);
        }

        public override void OnInspectorGUI() {
            serializedObject.Update();
            // Add vertex hint
            EditorGUILayout.HelpBox("Hold Alt and drag a vertex to create a new one.", MessageType.Info);

            // Delete vertex button
            if (selection == null || se.shapeVertices.Count <= 3) {
                GUI.enabled = false;
            }
            if (GUILayout.Button("Delete selected vertex")) {
                Undo.RegisterCompleteObjectUndo(se, "delete vertex");
                se.shapeVertices.Remove(selection);
                selection = null;
                se.SetToUpdate();
            }
            GUI.enabled = true;

            // Properties
            EditorGUILayout.PropertyField(textureScale, true);
            EditorGUILayout.PropertyField(sampleSpacing, true);
            EditorGUILayout.PropertyField(material, true);

            EditorGUILayout.PropertyField(vertices);
            EditorGUI.indentLevel += 1;
            if (vertices.isExpanded) {
                for (int i = 0; i < vertices.arraySize; i++) {
                    EditorGUILayout.PropertyField(vertices.GetArrayElementAtIndex(i), new GUIContent("Vertex " + i), true);
                }
            }
            EditorGUI.indentLevel -= 1;

            serializedObject.ApplyModifiedProperties();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/SplineMesh/Editor/SplineExtrusionEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Curvy Examples/Editor/E01_HeightMetadataEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 90ad9f4a58552ff48aecd9e1464f44a9
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.Curvy.Examples;
using FluffyUnderware.CurvyEditor;

namespace FluffyUnderware.Curvy.ExamplesEditor
{

    [CanEditMultipleObjects]
    [CustomEditor(typeof(E01_HeightMetadata))]
    public class E01_HeightMetadataEditor : DTEditor<E01_HeightMetadata>
    {

        [DrawGizmo(GizmoType.Active | GizmoType.NonSelected | GizmoType.InSelectionHierarchy)]
        static void GizmoDrawer(E01_HeightMetadata data, GizmoType context)
        {
            if (CurvyGlobalManager.ShowMetadataGizmo && data.Spline.ShowGizmos)
            {
                Vector3 position = data.ControlPoint.transform.position;
#pragma warning disable CS0618
                CurvyGizmo.PointLabel(position, data.MetaDataValue.ToString(), OrientationAxisEnum.Down);
#pragma warning restore CS0618
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Curvy Examples/Editor/E01_HeightMetadataEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/AboutWindow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: abfe48122637018449c040b59b54099e
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy;
using FluffyUnderware.DevToolsEditor;
using System.Linq;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.CurvyEditor
{

    public class AboutWindow : EditorWindow
    {
        static bool heightHasBeenSet = false;


        public static void Open()
        {
            EditorWindow.GetWindow<AboutWindow>(true, "About Curvy");
        }

        void OnEnable()
        {
            CurvyProject.Instance.ShowAboutOnLoad = false;
        }

        void OnGUI()
        {
            GUILayout.BeginVertical();
            GUILayout.Label(new GUIContent(CurvyStyles.TexLogoBig));
            DTGUI.PushContentColor(Color.black);

            GUIStyle labelStyle = new GUIStyle(EditorStyles.label);
            labelStyle.alignment = TextAnchor.UpperLeft;
            labelStyle.fontSize = 18;
            labelStyle.richText = true;

            GUI.Label(new Rect(300, 70, 215, 40), "<b>v " + CurvySpline.VERSION + "</b>", labelStyle);
            labelStyle.fontSize = 14;
            GUI.Label(new Rect(300, 95, 215, 40), " 2013 ToolBuddy", labelStyle);
            DTGUI.PopContentColor();


            //head("Links");
            if (buttonCol("Release notes", "View release notes and upgrade instructions"))
                OpenReleaseNotes();
            if (buttonCol("Leave a review", "We've got to feed the Asset Store's algorithm"))
                Application.OpenURL("https://assetstore.unity.com/packages/tools/level-design/curvy-splines-7038");
            if (buttonCol("Custom development", "We can provide custom modifications for Curvy"))
                Application.OpenURL("mailto:admin@curvyeditor.com?subject=Curvy custom development request");
            if (buttonCol("Curvy Website", "Visit Curvy Splines' website"))
                OpenWeb();
            if (buttonCol("Our other assets", "Find our other assets on the Asset Store"))
                Application.OpenURL("https://assetstore.unity.com/publishers/304");
            if (buttonCol("Submit a bug report", "Found a bug? Please issue a bug report"))
                CurvyEditorUtility.SendBugReport();
            foot();

            GUILayout.Space(10);

            head("Learning Resources");
            if (buttonCol("View Examples", "Show examples folder in the Project window"))
                ShowExamples();
            if (buttonCol("Tutorials", "Watch some tutorials"))
                OpenTutorials();
            if (buttonCol("Documentation", "Manuals! That magic source of wisdom"))
                OpenDocs();
            if (buttonCol("API Reference", "Browse the API reference"))
                OpenAPIDocs();
            if (buttonCol("Support Forum", "Visit Support forum"))
                OpenForum();
            foot();

            GUILayout.EndVertical();

            if (!heightHasBeenSet && Event.current.type == EventType.Repaint)
                setHeightToContent();
        }

        private void setHeightToContent()
        {
            int w = 500;
            float height = GUILayoutUtility.GetLastRect().height + 10f;
            position.Set(position.x, position.y, w, height);
            minSize = new Vector2(w, height);
            maxSize = new Vector2(w, height + 1);
            heightHasBeenSet = true;
        }

        void head(string text)
        {
            GUILayout.BeginHorizontal();
            GUILayout.Space(35);
            GUILayout.Label(text, EditorStyles.boldLabel);
            GUILayout.FlexibleSpace();
            GUILayout.EndHorizontal();
            GUILayout.Space(3);
        }

        void foot()
        {
            GUILayout.Space(5);
        }

        bool buttonCol(string btnText, string text)
        {
            return buttonCol(new GUIContent(btnText), text);
        }

        bool buttonCol(GUIContent btn, string text)
        {
            GUILayout.BeginHorizontal();
            GUILayout.Space(20);
            bool res = GUILayout.Button(btn, GUILayout.Width(150));
            GUILayout.Space(20);
            EditorGUILayout.LabelField("<i>" + text + "</i>", DTStyles.HtmlLabel);
            GUILayout.EndHorizontal();
            return res;
        }

        public static void ShowExamples()
        {
            string searchString;
            searchString = "t:Folder Curvy Examples";
            string[] assetsGuids = AssetDatabase.FindAssets(searchString);
            if (assetsGuids.Any())
                EditorGUIUtility.PingObject(AssetDatabase.LoadMainAssetAtPath(AssetDatabase.GUIDToAssetPath(assetsGuids.First())));
            else
                DTLog.LogError("[Curvy] Could not find the \"Curvy Examples\" folder");
        }

        public static void OpenTutorials()
        {
            Application.OpenURL(CurvySpline.DOCLINK + "tutorials");
        }
        public static void OpenReleaseNotes()
        {
            Application.OpenURL(CurvySpline.DOCLINK + "releasenotes");
        }

        public static void OpenDocs()
        {
            Application.OpenURL(CurvySpline.WEBROOT + "documentation/");
        }

        public static void OpenAPIDocs()
        {
            Application.OpenURL("https://api.curvyeditor.com/" + CurvySpline.APIVERSION + "/");
        }

        public static void OpenWeb()
        {
            Application.OpenURL(CurvySpline.WEBROOT);
        }

        public static void OpenForum()
        {
            Application.OpenURL("https://forum.curvyeditor.com");
        }


    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/AboutWindow.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildRasterizedPathEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a22d0d1b506cab148ac30469a3cbe49d
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator.Modules;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(BuildRasterizedPath))]
    public class BuildRasterizedPathEditor : CGModuleEditor<BuildRasterizedPath>
    {
        protected override void OnEnable()
        {
            base.OnEnable();
            HasDebugVisuals = true;
        }

        public override void OnModuleSceneDebugGUI()
        {
            base.OnModuleSceneDebugGUI();
            CGPath data = Target.OutPath.GetData<CGPath>();
            if (data)
            {
                Handles.matrix = Target.Generator.transform.localToWorldMatrix;
                CGEditorUtility.SceneGUIPlot(data.Positions.Array, data.Positions.Count, 0.1f, Color.white);
                Handles.matrix = Matrix4x4.identity;
            }
        }

        public override void OnModuleDebugGUI()
        {
            CGPath data = Target.OutPath.GetData<CGPath>();
            if (data)
            {
                EditorGUILayout.LabelField("Samples: " + data.Count.ToString());
            }
        }
    }




}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildRasterizedPathEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildShapeExtrusionEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 665128a47ac13454d8d965e27da8833b
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevToolsEditor;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(BuildShapeExtrusion))]
    public class BuildShapeExtrusionEditor : CGModuleEditor<BuildShapeExtrusion>
    {
        bool mEditCross;
        bool mShowEditButton;

        public override void OnModuleDebugGUI()
        {
            EditorGUILayout.LabelField("Samples Path/Cross: " + Target.PathSamples.ToString() + "/" + Target.CrossSamples.ToString());
            EditorGUILayout.LabelField("Cross Sample Groups: " + Target.CrossGroups.ToString());
        }

        void CBEditCrossButton()
        {

            if (DTGUI.IsLayout)
                mShowEditButton = (Target.IsConfigured && Target.InCross.SourceSlot().ExternalInput != null && Target.InCross.SourceSlot().ExternalInput.SupportsIPE);

            if (mShowEditButton)
            {
                EditorGUI.BeginChangeCheck();
                mEditCross = GUILayout.Toggle(mEditCross, "Edit Cross", EditorStyles.miniButton);
                if (EditorGUI.EndChangeCheck())
                {
                    if (mEditCross)
                    {
                        CGGraph.SetIPE(Target.Cross, this);
                    }
                    else
                        CGGraph.SetIPE();
                }
            }
        }

        /// <summary>
        /// Called for the IPE initiator to get the TRS values for the target
        /// </summary>
        internal override void OnIPEGetTRS(out Vector3 position, out Quaternion rotation, out Vector3 scale)
        {
            position = Target.CrossPosition;
            rotation = Target.CrossRotation;
            Vector2 scaleVector = (Target as ScalingModule).GetScale(0);
            scale = new Vector3(scaleVector.x, scaleVector.y, 1);
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildShapeExtrusionEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildVolumeCapsEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a5d8157ce69d4dd4b92fdc9a14c40e18
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevToolsEditor;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(BuildVolumeCaps))]
    public class BuildVolumeCapsEditor : CGModuleEditor<BuildVolumeCaps>
    {


        public override void OnModuleDebugGUI()
        {
            CGVMesh vmesh = Target.OutVMesh.GetData<CGVMesh>();
            if (vmesh)
            {
                EditorGUILayout.LabelField("Vertices: " + vmesh.Count.ToString());
                EditorGUILayout.LabelField("Triangles: " + vmesh.TriangleCount.ToString());
                EditorGUILayout.LabelField("SubMeshes: " + vmesh.SubMeshes.Length.ToString());
            }
        }


    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildVolumeCapsEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildVolumeMeshEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1ea43086e5fba3b4e8d79ebce55076b7
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator.Modules;
using System.Linq;
using FluffyUnderware.DevToolsEditor;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(BuildVolumeMesh))]
    public class BuildVolumeMeshEditor : CGModuleEditor<BuildVolumeMesh>
    {
        bool showAddButton;
        int matcount;

        public override void OnModuleDebugGUI()
        {
            CGVMesh vmesh = Target.OutVMesh.GetData<CGVMesh>();
            if (vmesh)
            {
                EditorGUILayout.LabelField("Vertices: " + vmesh.Count.ToString());
                EditorGUILayout.LabelField("Triangles: " + vmesh.TriangleCount.ToString());
                EditorGUILayout.LabelField("SubMeshes: " + vmesh.SubMeshes.Length.ToString());
            }
        }

        protected override void OnReadNodes()
        {
            ensureMaterialTabs();
        }

        void ensureMaterialTabs()
        {
            DTGroupNode tabbar = Node.FindTabBarAt("Default");

            if (tabbar == null)
                return;

            tabbar.MaxItemsPerRow = 4;
            for (int i = 0; i < Target.MaterialCount; i++)
            {
                string tabName = string.Format("Mat {0}", i);
                if (tabbar.Count <= i + 1)
                    tabbar.AddTab(tabName, OnRenderTab);
                else
                {
                    tabbar[i + 1].Name = tabName;
                    tabbar[i + 1].GUIContent.text = tabName;
                }
            }
            while (tabbar.Count > Target.MaterialCount + 1)
                tabbar[tabbar.Count - 1].Delete();
            matcount = Target.MaterialCount;
        }

        void OnRenderTab(DTInspectorNode node)
        {
            int idx = node.Index - 1;

            if (idx >= 0 && idx < Target.MaterialCount)
            {
                CGMaterialSettingsEx mat = Target.MaterialSettings[idx];
                EditorGUI.BeginChangeCheck();

                bool matSwapUv = EditorGUILayout.Toggle("Swap UV", mat.SwapUV);
                if (matSwapUv != mat.SwapUV)
                {
                    Undo.RegisterCompleteObjectUndo(Target, "Modify Swap UV");
                    mat.SwapUV = matSwapUv;
                }

                CGKeepAspectMode cgKeepAspectMode = (CGKeepAspectMode)EditorGUILayout.EnumPopup("Keep Aspect", mat.KeepAspect);
                if (cgKeepAspectMode != mat.KeepAspect)
                {
                    Undo.RegisterCompleteObjectUndo(Target, "Modify Keep Aspect");
                    mat.KeepAspect = cgKeepAspectMode;
                }

                Vector2 matUvOffset = EditorGUILayout.Vector2Field("UV Offset", mat.UVOffset);
                if (matUvOffset != mat.UVOffset)
                {
                    Undo.RegisterCompleteObjectUndo(Target, "Modify UV Offset");
                    mat.UVOffset = matUvOffset;
                }

                Vector2 matUvScale = EditorGUILayout.Vector2Field("UV Scale", mat.UVScale);
                if (matUvScale != mat.UVScale)
                {
                    Undo.RegisterCompleteObjectUndo(Target, "Modify UV Scale");
                    mat.UVScale = matUvScale;
                }

                Target.SetMaterial(idx, EditorGUILayout.ObjectField("Material", Target.GetMaterial(idx), typeof(Material), true) as Material);

                if (Target.MaterialCount > 1 && GUILayout.Button("Remove"))
                {
                    Target.RemoveMaterial(idx);
                    node.Delete();
                    ensureMaterialTabs();
                    GUIUtility.ExitGUI();
                }
                if (EditorGUI.EndChangeCheck())
                {
                    Target.Dirty = true;
                    EditorUtility.SetDirty(Target);
                }
            }
        }

        void CBAddMaterial()
        {
            if (DTGUI.IsLayout)
                showAddButton = Node.FindTabBarAt("Default").SelectedIndex == 0;
            if (showAddButton)
            {
                if (GUILayout.Button("Add Material Group"))
                {
                    Target.AddMaterial();
                    ensureMaterialTabs();
                    GUIUtility.ExitGUI();
                }
            }

        }

        protected override void OnCustomInspectorGUI()
        {
            base.OnCustomInspectorGUI();
            if (matcount != Target.MaterialCount)
                ensureMaterialTabs();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildVolumeMeshEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildVolumeSpotsEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: ba3517e1babdd03478ed6bded8b06b79
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevToolsEditor.Extensions;
using UnityEditorInternal;
using FluffyUnderware.Curvy;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(BuildVolumeSpots))]
    public class BuildVolumeSpotsEditor : CGModuleEditor<BuildVolumeSpots>
    {
        ReorderableList mGroupItemsList;
        CGBoundsGroup mCurrentGroup;

        private DTGroupNode distributionGroupNode;
        private DTGroupNode rotationGroupNode;
        private DTGroupNode translationGroupNode;
        private DTGroupNode scaleGroupNode;

        private readonly GUIContent uniformScalingLabel = new GUIContent("Scale");
        private readonly GUIContent itemsNumberLabel = new GUIContent("    Items #");
        private readonly GUIContent emptyLabel1 = new GUIContent("");
        private readonly GUIContent emptyLabel2 = new GUIContent("");
        private readonly GUIContent emptyLabel3 = new GUIContent("");

        protected override void OnEnable()
        {
            base.OnEnable();
            HasDebugVisuals = true;
        }

        public override void OnModuleSceneDebugGUI()
        {
            CGSpots data = Target.SimulatedSpots;
            if (data)
            {
                Handles.matrix = Target.Generator.transform.localToWorldMatrix;
                for (int i = 0; i < data.Spots.Count; i++)
                {
                    Quaternion Q = data.Spots.Array[i].Rotation * Quaternion.Euler(-90, 0, 0);
#if UNITY_5_6_OR_NEWER
                    Handles.ArrowHandleCap(0, data.Spots.Array[i].Position, Q, 2, EventType.Repaint);
#else
                    Handles.ArrowCap(0, data.Points[i].Position, Q, 2);
#endif

                    Handles.Label(data.Spots.Array[i].Position, data.Spots.Array[i].Index.ToString(), EditorStyles.whiteBoldLabel);
                }
                Handles.matrix = Matrix4x4.identity;
            }
        }

        protected override void OnReadNodes()
        {
            base.OnReadNodes();
            ensureGroupTabs();

            //Used to subdivide nicely the diplayed fields within groups
            distributionGroupNode = new DTGroupNode("Distribution");

            rotationGroupNode = new DTGroupNode("Rotation");
            rotationGroupNode.Expanded = false;
            translationGroupNode = new DTGroupNode("Translation");
            translationGroupNode.Expanded = false;
            scaleGroupNode = new DTGroupNode("Scale");
            scaleGroupNode.Expanded = false;
        }

        void ensureGroupTabs()
        {
            DTGroupNode tabbar = Node.FindTabBarAt("Default");
            for (int i = 0; i < Target.GroupCount; i++)
            {
                string tabName = string.Format("{0}:{1}", i, Target.Groups[i].Name);
                if (tabbar.Count <= i + 2)
                    tabbar.AddTab(tabName, OnRenderTab);
                else
                {
                    tabbar[i + 2].Name = tabName;
                    tabbar[i + 2].GUIContent.text = tabName;
                }
            }
            for (int i = tabbar.Count - 1; i > Target.GroupCount + 1; i--)
                tabbar[i].Delete();


        }

        void OnRenderTab(DTInspectorNode node)
        {
            int grpIdx = node.Index - 2;

            if (grpIdx >= 0 && grpIdx < Target.GroupCount)
            {

                SerializedProperty pGroup = serializedObject.FindProperty(string.Format("m_Groups.Array.data[{0}]", grpIdx));
                if (pGroup != null)
                {

                    CGBoundsGroup boundsGroup = Target.Groups[grpIdx];
                    SerializedProperty pItems = pGroup.FindPropertyRelative("m_Items");
                    if (pItems != null)
                    {

                        if (mCurrentGroup != null && mCurrentGroup != boundsGroup)
                            mGroupItemsList = null;
                        if (mGroupItemsList == null)
                        {
                            mCurrentGroup = boundsGroup;
                            mGroupItemsList = new ReorderableList(pItems.serializedObject, pItems);
                            mGroupItemsList.draggable = true;
                            mGroupItemsList.drawHeaderCallback = (Rect Rect) => { EditorGUI.LabelField(Rect, "Items"); };
                            mGroupItemsList.drawElementCallback = (Rect rect, int index, bool isActive, bool isFocused) =>
                            {
                                #region ---

                                SerializedProperty prop = pItems.FindPropertyRelative(string.Format("Array.data[{0}]", index));
                                SerializedProperty pIndex = prop.FindPropertyRelative("Index");

                                rect.height = EditorGUIUtility.singleLineHeight;
                                EditorGUI.LabelField(new Rect(rect.x, rect.y, 30, rect.height), "#" + index.ToString() + ":");

                                GUIContent[] boundNames = Target.BoundsNames;
                                int[] boundIndices = Target.BoundsIndices;
                                if (boundNames.Length == 0)
                                    pIndex.intValue = EditorGUI.IntField(GetSelectorDrawArea(rect), "", pIndex.intValue);
                                else
                                    EditorGUI.IntPopup(GetSelectorDrawArea(rect), pIndex, boundNames, boundIndices, emptyLabel1);

                                if (boundsGroup.RandomizeItems && index >= boundsGroup.FirstRepeating && index <= boundsGroup.LastRepeating)
                                    EditorGUI.PropertyField(GetWeightDrawArea(rect), prop.FindPropertyRelative("m_Weight"), emptyLabel2);
                                #endregion
                            };

                            mGroupItemsList.onAddCallback = (ReorderableList l) =>
                            {
                                boundsGroup.Items.Insert(Mathf.Clamp(l.index + 1, 0, boundsGroup.ItemCount), new CGBoundsGroupItem());
                                boundsGroup.LastRepeating++;
                                Target.Dirty = true;
                                EditorUtility.SetDirty(Target);
                            };
                            mGroupItemsList.onRemoveCallback = (ReorderableList l) =>
                            {
                                boundsGroup.Items.RemoveAt(l.index);
                                boundsGroup.LastRepeating--;
                                Target.Dirty = true;
                                EditorUtility.SetDirty(Target);
                            };
                        }

                        mGroupItemsList.DoLayoutList();

                        RenderSectionHeader(distributionGroupNode);
                        if (distributionGroupNode.ContentVisible)
                        {
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_RandomizeItems"));
                            if (boundsGroup.RandomizeItems)
                                EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_RepeatingItems"), itemsNumberLabel);
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_KeepTogether"));
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_SpaceBefore"));
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_SpaceAfter"));
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_CrossBase"));
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_IgnoreModuleCrossBase"));
                        }
                        RenderSectionFooter(distributionGroupNode);
                        NeedRepaint |= distributionGroupNode.NeedRepaint;

                        RenderSectionHeader(translationGroupNode);
                        if (translationGroupNode.ContentVisible)
                        {
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_RelativeTranslation"));
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_TranslationX"));//, XTranslationContent);
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_TranslationY"));//, YTranslationContent);
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_TranslationZ"));//, ZTranslationContent);
                        }
                        RenderSectionFooter(translationGroupNode);
                        NeedRepaint |= translationGroupNode.NeedRepaint;

                        RenderSectionHeader(rotationGroupNode);
                        if (rotationGroupNode.ContentVisible)
                        {
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_RotationMode"));
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_RotationX"));//, XRotationContent);
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_RotationY"));//, YRotationContent);
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_RotationZ"));//, ZRotationContent);
                        }
                        RenderSectionFooter(rotationGroupNode);
                        NeedRepaint |= rotationGroupNode.NeedRepaint;

                        RenderSectionHeader(scaleGroupNode);
                        if (scaleGroupNode.ContentVisible)
                        {
                            EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_UniformScaling"));//, XScaleContent);
                            if (boundsGroup.UniformScaling)
                            {
                                EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_ScaleX"), uniformScalingLabel);
                            }
                            else
                            {
                                EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_ScaleX"));//, XScaleContent);
                                EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_ScaleY"));//, YScaleContent);
                                EditorGUILayout.PropertyField(pGroup.FindPropertyRelative("m_ScaleZ"));//, ZScaleContent);
                            }
                        }
                        RenderSectionFooter(scaleGroupNode);
                        NeedRepaint |= scaleGroupNode.NeedRepaint;
                    }
                }
            }
        }

        void RenderSectionHeader(DTGroupNode node)
        {
            GUILayout.Space(10);
            Rect controlRect = EditorGUILayout.GetControlRect(false, 16);
            bool toggleState = node.Expanded;
            DTInspectorNodeDefaultRenderer.RenderHeader(controlRect, 0, String.Empty, node.GUIContent, ref toggleState);
            node.Expanded = toggleState;
            EditorGUILayout.BeginFadeGroup(node.ExpandedFaded);
            //BUG if indentation is activated, mouse detection on the FloatRegion parameters gets fucked up
            //EditorGUI.indentLevel = EditorGUI.indentLevel + 1;
        }

        void RenderSectionFooter(DTGroupNode node)
        {
            //BUG if indentation is activated, mouse detection on the FloatRegion parameters gets fucked up
            //EditorGUI.indentLevel = EditorGUI.indentLevel - 1;
            EditorGUILayout.EndFadeGroup();
        }

        protected override void SetupArrayEx(DTFieldNode node, DevTools.ArrayExAttribute attribute)
        {
            switch (node.Name)
            {
                case "m_Groups":
                    node.ArrayEx.drawHeaderCallback = (Rect Rect) => { EditorGUI.LabelField(Rect, "Groups"); };
                    node.ArrayEx.drawElementCallback = OnGroupElementGUI;
                    node.ArrayEx.onAddCallback = (ReorderableList l) =>
                    {
                        //TODO unify this code with the one in BuildVolumeSpot.AddGroup()

                        //Creates a group
                        CGBoundsGroup cgBoundsGroup = new CGBoundsGroup("Group");

                        ////Adds the first item from input module if any.
                        //if (Target.InBounds)
                        //{
                        //    List<CGGameObject> inGameObjects = Target.InBounds.GetAllData<CGGameObject>();
                        //    if (inGameObjects.Count != 0)
                        //    {
                        //        CGBoundsGroupItem cgBoundsGroupItem = new CGBoundsGroupItem();
                        //        cgBoundsGroup.Items.Add(cgBoundsGroupItem);
                        //    }
                        //}

                        //Always add an input
                        cgBoundsGroup.Items.Add(new CGBoundsGroupItem());

                        //Adds the group
                        Target.Groups.Insert(Mathf.Clamp(l.index + 1, 0, Target.GroupCount), cgBoundsGroup);

                        Target.LastRepeating++;
                        EditorUtility.SetDirty(Target);
                        ensureGroupTabs();
                    };
                    node.ArrayEx.onRemoveCallback = (ReorderableList l) =>
                    {
                        mGroupItemsList = null;
                        Target.Groups.RemoveAt(l.index);
                        Target.LastRepeating--;
                        EditorUtility.SetDirty(Target);

                        //node[1+l.index].Delete();
                        ensureGroupTabs();
                        GUIUtility.ExitGUI();
                    };
                    node.ArrayEx.onReorderCallback = (ReorderableList l) =>
                    {
                        ensureGroupTabs();
                        GUIUtility.ExitGUI();
                    };
                    break;
            }
        }

        void OnGroupElementGUI(Rect rect, int index, bool isActive, bool isFocused)
        {
            bool fix = (index < Target.FirstRepeating || index > Target.LastRepeating);

            if (fix)
                DTHandles.DrawSolidRectangleWithOutline(rect, new Color(0, 0, 0.5f, 0.2f), new Color(0, 0, 0, 0));

            SerializedProperty prop = serializedObject.FindProperty(string.Format("m_Groups.Array.data[{0}]", index));
            if (prop != null)
            {
                SerializedProperty pName = prop.FindPropertyRelative("m_Name");
                SerializedProperty pRepeatingOrder = serializedObject.FindProperty("m_RepeatingOrder");

                rect.height = EditorGUIUtility.singleLineHeight;
                EditorGUI.LabelField(new Rect(rect.x, rect.y, 30, rect.height), "#" + index.ToString() + ":");

                EditorGUI.BeginChangeCheck();
                pName.stringValue = EditorGUI.TextField(GetSelectorDrawArea(rect), "", pName.stringValue);
                if (EditorGUI.EndChangeCheck())
                {
                    DTGroupNode tab = Node.FindTabBarAt("Default");
                    if (tab && tab.Count > index + 2)
                    {
                        tab[index + 2].Name = string.Format("{0}:{1}", index, pName.stringValue);
                        tab[index + 2].GUIContent.text = string.Format("{0}:{1}", index, pName.stringValue);
                    }
                }

                if (!fix && pRepeatingOrder.intValue == (int)CurvyRepeatingOrderEnum.Random)
                    EditorGUI.PropertyField(GetWeightDrawArea(rect), prop.FindPropertyRelative("m_Weight"), emptyLabel3);
            }
        }

        protected override void OnCustomInspectorGUIBefore()
        {
            base.OnCustomInspectorGUIBefore();
            EditorGUILayout.HelpBox("Spots: " + Target.Count.ToString(), MessageType.Info);
        }

        private static Rect GetSelectorDrawArea(Rect rect)
        {
            Rect itemSelectorDrawArea = new Rect(rect);
            itemSelectorDrawArea.x += 30;
            itemSelectorDrawArea.y += 1;
            itemSelectorDrawArea.width = rect.width / 2 - 50;
            return itemSelectorDrawArea;
        }

        private static Rect GetWeightDrawArea(Rect rect)
        {
            Rect weightDrawArea = new Rect(rect);
            weightDrawArea.x += rect.width / 2 - 10;
            weightDrawArea.y += 1;
            weightDrawArea.width = rect.width / 2;
            return weightDrawArea;
        }
    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/BuildVolumeSpotsEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ConformPathEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1b6b2bda946d97f4091098f7f032f604
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(ConformPath))]
    public class ConformPathEditor : CGModuleEditor<ConformPath>
    {

    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ConformPathEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/CreateGameObjectEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: f5b8ec7e389706a4aa211345824992e9
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevToolsEditor;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(CreateGameObject))]
    public class CreateGameObjectEditor : CGModuleEditor<CreateGameObject>
    {
        protected override void OnReadNodes()
        {
            base.OnReadNodes();
            Node.FindTabBarAt("Default").AddTab("Export", OnExportTab);
        }

        void OnExportTab(DTInspectorNode node)
        {
            GUI.enabled = Target.GameObjects.Count > 0;
            if (GUILayout.Button("Save To Scene"))
                Target.SaveToScene();
            GUI.enabled = true;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/CreateGameObjectEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/CreateMeshEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 86844bb464cc3bb4db7570a1e838dbe3
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevToolsEditor;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(CreateMesh))]
    public class CreateMeshEditor : CGModuleEditor<CreateMesh>
    {
        public override void OnModuleDebugGUI()
        {
            base.OnModuleDebugGUI();
            if (Target)
            {
                EditorGUILayout.LabelField("Meshes: " + Target.MeshCount.ToString());
                EditorGUILayout.LabelField("Vertices: " + Target.VertexCount.ToString());
            }
        }

        protected override void OnReadNodes()
        {
            base.OnReadNodes();
            Node.FindTabBarAt("Default").AddTab("Export", onExportTab);
        }

        void onExportTab(DTInspectorNode node)
        {
            GUI.enabled = Target.MeshCount > 0;

            if (GUILayout.Button(new GUIContent("Save To Scene", "Creates a GameObject, outside of the generator, containing a copy of the generated mesh(es)")))
            {
                Target.SaveToScene();
            }
            if (GUILayout.Button(new GUIContent("Save To Assets", "Saves a copy of the generated mesh(es) as Asset(s)")))
            {
                Target.SaveToAsset();
            }
            if (GUILayout.Button(new GUIContent("Save To Both (Prefab Compatible)", "Saves a copy of the generated mesh(es) as Asset(s), then creates a GameObject, outside of the generator, referencing those mesh assets. This way the created GameObject can be made part of a prefab without issues")))
            {
                Target.SaveToSceneAndAsset();
            }

            GUI.enabled = true;
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/CreateMeshEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/CreatePathLineRendererEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e23df703953ef014db32b2b9fdd05f64
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(CreatePathLineRenderer))]
    public class CreatePathLineRendererEditor : CGModuleEditor<CreatePathLineRenderer>
    {

        protected override void OnCustomInspectorGUIBefore()
        {
            base.OnCustomInspectorGUIBefore();
            EditorGUILayout.HelpBox("Please edit parameters in inspector!", MessageType.Info);
            if (GUILayout.Button("Select Inspector"))
                Selection.activeGameObject = Target.gameObject;
        }

    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/CreatePathLineRendererEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/DebugRasterizedPathEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b947cab6e199c084498c2905219851e6
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevToolsEditor;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(DebugRasterizedPath))]
    public class DebugRasterizedPathEditor : CGModuleEditor<DebugRasterizedPath>
    {

        protected override void OnEnable()
        {
            base.OnEnable();
            HasDebugVisuals = true;
            ShowDebugVisuals = true;
        }

        // Scene View GUI - Called only if the module is initialized and configured
        //public override void OnModuleSceneGUI() {}

        // Scene View Debug GUI - Called only when Show Debug Visuals is activated
        public override void OnModuleSceneDebugGUI()
        {
            if (Target.ShowNormals || Target.ShowOrientation)
            {
                CGPath path = Target.InPath.GetData<CGPath>(out bool isDisposable);
                if (path)
                {
                    Color gizmoOrientationColor = CurvyGlobalManager.GizmoOrientationColor;
                    Color gizmoTangentColor = CurvySplineSegment.GizmoTangentColor;

                    if (Target.ShowOrientation)
                    {
                        DTHandles.PushHandlesColor(gizmoOrientationColor);

                        for (int i = 0; i < path.Count; i++)
                            Handles.DrawLine(path.Positions.Array[i], path.Positions.Array[i] + path.Directions.Array[i] * 2);

                        DTHandles.PopHandlesColor();
                    }

                    if (Target.ShowNormals)
                    {
                        DTHandles.PushHandlesColor(gizmoTangentColor);

                        for (int i = 0; i < path.Count; i++)
                            Handles.DrawLine(path.Positions.Array[i], path.Positions.Array[i] + path.Normals.Array[i] * 2);

                        DTHandles.PopHandlesColor();
                    }
                }
                if (isDisposable)
                    path.Dispose();
            }
        }

        public override void OnModuleDebugGUI()
        {
            CGPath path = Target.InPath.GetData<CGPath>(out bool isDisposable);
            if (path)
            {
                EditorGUILayout.LabelField("VertexCount: " + path.Count.ToString());
            }
            if (isDisposable)
                path.Dispose();
        }

        // Inspector Debug GUI - Called only when Show Debug Values is activated
        //public override void OnModuleDebugGUI() {}

        protected override void OnCustomInspectorGUI()
        {
            DebugVMeshEditor.CheckGeneratorDebugMode(Target);
            base.OnCustomInspectorGUI();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/DebugRasterizedPathEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/DebugVMeshEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 5f5d4bf9eab46c54a858a95a4e04b83b
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.Curvy.Generator.Modules;
using System.Linq;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(DebugVMesh))]
    public class DebugVMeshEditor : CGModuleEditor<DebugVMesh>
    {

        protected override void OnEnable()
        {
            base.OnEnable();
            HasDebugVisuals = true;
            ShowDebugVisuals = true;
        }

        public override void OnModuleSceneDebugGUI()
        {
            CGVMesh vmesh = Target.InData.GetData<CGVMesh>(out bool isDisposable);
            if (vmesh)
            {
                Handles.matrix = Target.Generator.transform.localToWorldMatrix;
                if (Target.ShowVertices)
                    CGEditorUtility.SceneGUIPlot(vmesh.Vertices.Array, vmesh.Vertices.Count, 0.1f, Color.gray);

                if (Target.ShowVertexID)
                {
                    string[] labels = Enumerable.Range(0, vmesh.Count).Select(i => i.ToString()).ToArray();
                    CGEditorUtility.SceneGUILabels(vmesh.Vertices.Array, vmesh.Vertices.Count, labels, Color.black, Vector2.zero);
                }
                if (Target.ShowUV && vmesh.HasUV)
                {
                    string[] labels = Enumerable.Range(0, vmesh.UVs.Count - 1).Select(i => string.Format("({0:0.##},{1:0.##})", vmesh.UVs.Array[i].x, vmesh.UVs.Array[i].y)).ToArray();
                    CGEditorUtility.SceneGUILabels(vmesh.Vertices.Array, vmesh.Vertices.Count, labels, Color.black, Vector2.zero);
                }
                Handles.matrix = Matrix4x4.identity;
            }
            if (isDisposable)
                vmesh.Dispose();
        }

        public override void OnModuleDebugGUI()
        {
            CGVMesh vmesh = Target.InData.GetData<CGVMesh>(out bool isDisposable);
            if (vmesh)
            {
                EditorGUILayout.LabelField("VertexCount: " + vmesh.Count.ToString());
            }
            if (isDisposable)
                vmesh.Dispose();
        }

        protected override void OnCustomInspectorGUI()
        {
            CheckGeneratorDebugMode(Target);
            base.OnCustomInspectorGUI();
        }

        /// <summary>
        /// Clears all existing UI messages and adds one if the generator debug mode is not active
        /// </summary>
        internal static void CheckGeneratorDebugMode(CGModule module)
        {
            module.UIMessages.Clear();
            if (module.Generator.ShowDebug == false)
                module.UIMessages.Add("To display the debug information, activate the Generator's Debug mode either via its toolbar, or its inspector");
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/DebugVMeshEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/DebugVolumeEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 332a17315cf8b0346aea0b8019a9f00f
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.Curvy.Generator.Modules;
using System.Linq;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(DebugVolume))]
    public class DebugVolumeEditor : CGModuleEditor<DebugVolume>
    {

        protected override void OnEnable()
        {
            base.OnEnable();
            HasDebugVisuals = true;
            ShowDebugVisuals = true;
        }

        protected override void OnReadNodes()
        {
            base.OnReadNodes();
            Node.FindTabBarAt("Default").AddTab("Cross Groups", OnCrossGroupTab);
        }

        public override void OnModuleSceneDebugGUI()
        {
            base.OnModuleSceneDebugGUI();
            CGVolume vol = Target.InData.GetData<CGVolume>(out bool isDisposable);
            if (vol)
            {
                Handles.matrix = Target.Generator.transform.localToWorldMatrix;

                if (Target.ShowPathSamples)
                {
                    CGEditorUtility.SceneGUIPlot(vol.Positions.Array, vol.Positions.Count, 0.1f, Target.PathColor);
                    if (Target.ShowIndex)
                    {
                        string[] labels = Enumerable.Range(0, vol.Count).Select(i => i.ToString()).ToArray();
                        CGEditorUtility.SceneGUILabels(vol.Positions.Array, vol.Positions.Count, labels, Color.black, Vector2.zero);
                    }

                    if (Target.ShowNormals)
                    {
                        DTHandles.PushHandlesColor(Target.NormalColor);

                        for (int i = 0; i < vol.Count; i++)
                            Handles.DrawLine(vol.Positions.Array[i], vol.Positions.Array[i] + vol.Normals.Array[i] * 2);

                        DTHandles.PopHandlesColor();
                    }
                }
                if (Target.ShowCrossSamples)
                {
                    int vtLo = Target.LimitCross.From * vol.CrossSize;
                    int vtHi = vtLo + vol.CrossSize;
                    if (!Target.LimitCross.SimpleValue)
                    {
                        vtLo = Target.LimitCross.Low * vol.CrossSize;
                        vtHi = (Target.LimitCross.High + 1) * vol.CrossSize;
                    }

                    vtLo = Mathf.Clamp(vtLo, 0, vol.VertexCount);
                    vtHi = Mathf.Clamp(vtHi, vtLo, vol.VertexCount);
                    var range = vol.Vertices.Array.Skip(vtLo).Take(vtHi - vtLo).ToArray();
                    CGEditorUtility.SceneGUIPlot(range, range.Length, 0.1f, Color.white);

                    if (Target.ShowIndex)
                    {
                        string[] labels = Enumerable.Range(vtLo, vtHi).Select(i => i.ToString()).ToArray();
                        CGEditorUtility.SceneGUILabels(range, range.Length, labels, Color.black, Vector2.zero);
                    }

                    if (Target.ShowMap)
                    {
                        string[] labels = Enumerable.Range(vtLo, vtHi).Select(i => DTMath.SnapPrecision(vol.CrossCustomValues.Array[i], 3).ToString()).ToArray();
                        CGEditorUtility.SceneGUILabels(range, range.Length, labels, new Color(1, 0, 1), new Vector2(10, 20));
                    }

                    if (Target.ShowNormals)
                    {
                        DTHandles.PushHandlesColor(Target.NormalColor);

                        for (int i = vtLo; i < vtHi; i++)
                            Handles.DrawLine(vol.Vertices.Array[i], vol.Vertices.Array[i] + vol.VertexNormals.Array[i] * 2);

                        DTHandles.PopHandlesColor();
                    }
                }
                if (Target.Interpolate)
                {
                    Vector3 pos;
                    Vector3 tan;
                    Vector3 up;
                    vol.InterpolateVolume(Target.InterpolatePathF, Target.InterpolateCrossF, out pos, out tan, out up);
#if UNITY_5_6_OR_NEWER
                    Handles.ConeHandleCap(0, pos, Quaternion.LookRotation(up, tan), 1f, EventType.Repaint);
#else
                    Handles.ConeCap(0, pos, Quaternion.LookRotation(up,tan), 1f);
#endif
                }
                Handles.matrix = Matrix4x4.identity;

                if (isDisposable)
                    vol.Dispose();
            }
        }

        public override void OnModuleDebugGUI()
        {
            CGVolume vol = Target.InData.GetData<CGVolume>(out bool isDisposable);
            if (vol)
            {
                EditorGUILayout.LabelField("VertexCount: " + vol.VertexCount.ToString());
            }
            if (isDisposable)
                vol.Dispose();
        }

        void OnCrossGroupTab(DTInspectorNode node)
        {
            CGVolume vol = Target.InData.GetData<CGVolume>(out bool isDisposable);
            if (vol)
            {
                GUILayout.Label("MaterialGroup.Patch: (MaterialID) Patch Details", EditorStyles.boldLabel);
                for (int i = 0; i < vol.CrossMaterialGroups.Count; i++)
                {
                    for (int p = 0; p < vol.CrossMaterialGroups[i].Patches.Count; p++)
                        GUILayout.Label(string.Format("{0}.{1}: (Mat:{2}) {3}", i, p, vol.CrossMaterialGroups[i].MaterialID, vol.CrossMaterialGroups[i].Patches[p].ToString()));
                }
            }
            if (isDisposable)
                vol.Dispose();
        }

        protected override void OnCustomInspectorGUI()
        {
            DebugVMeshEditor.CheckGeneratorDebugMode(Target);
            base.OnCustomInspectorGUI();
        }

    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/DebugVolumeEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/DeformMeshEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 876c0f57076046442ad41d8487345baa
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEditor;
using FluffyUnderware.Curvy.Generator.Modules;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(DeformMesh))]
    public class DeformMeshEditor : CGModuleEditor<DeformMesh>
    {

        // Scene View GUI - Called only if the module is initialized and configured
        //public override void OnModuleSceneGUI() {}

        // Scene View Debug GUI - Called only when Show Debug Visuals is activated
        //public override void OnModuleSceneDebugGUI() {}

        // Inspector Debug GUI - Called only when Show Debug Values is activated
        //public override void OnModuleDebugGUI() {}

    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/DeformMeshEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/GameObjectToMeshEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a65f5e84bb3e07347ac89a2b08a71877
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(GameObjectToMesh))]
    public class GameObjectToMeshEditor : CGModuleEditor<GameObjectToMesh>
    {

        // Scene View GUI - Called only if the module is initialized and configured
        //public override void OnModuleSceneGUI() {}

        // Scene View Debug GUI - Called only when Show Debug Visuals is activated
        //public override void OnModuleSceneDebugGUI() {}

        // Inspector Debug GUI - Called only when Show Debug Values is activated
        //public override void OnModuleDebugGUI() {}

    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/GameObjectToMeshEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputGameObjectEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 9d4c717ece1291b428da067095f4b11e
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevToolsEditor;
using UnityEditorInternal;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(InputGameObject))]
    public class InputGameObjectsEditor : CGModuleEditor<InputGameObject>
    {
        int selectedIndex;

        protected override void SetupArrayEx(DTFieldNode node, DevTools.ArrayExAttribute attribute)
        {
            node.ArrayEx.drawElementCallback = onGameObjectGUI;
            node.ArrayEx.onSelectCallback = (ReorderableList l) => { selectedIndex = l.index; };
            node.ArrayEx.onAddCallback = (ReorderableList l) =>
            {
                Target.GameObjects.Insert(Mathf.Clamp(l.index + 1, 0, Target.GameObjects.Count), new CGGameObjectProperties());
                EditorUtility.SetDirty(Target);
            };
        }



        void onGameObjectGUI(Rect rect, int index, bool isActive, bool isFocused)
        {
            SerializedProperty prop = serializedObject.FindProperty(string.Format("m_GameObjects.Array.data[{0}]", index));
            if (prop != null)
            {
                rect.height = EditorGUIUtility.singleLineHeight;
                rect.y += 1;

                SerializedProperty mshProp = prop.FindPropertyRelative("m_Object");
                mshProp.objectReferenceValue = EditorGUI.ObjectField(rect, mshProp.objectReferenceValue, typeof(GameObject), true);
            }
        }


        void OnPropertiesGUI()
        {
            SerializedProperty prop = serializedObject.FindProperty(string.Format("m_GameObjects.Array.data[{0}]", selectedIndex));
            if (prop != null)
            {
                EditorGUILayout.PropertyField(prop.FindPropertyRelative("m_Translation"));
                EditorGUILayout.PropertyField(prop.FindPropertyRelative("m_Rotation"));
                EditorGUILayout.PropertyField(prop.FindPropertyRelative("m_Scale"));
            }
        }

        protected override void OnCustomInspectorGUI()
        {
            base.OnCustomInspectorGUI();
            if (Target && selectedIndex < Target.GameObjects.Count && Target.GameObjects[selectedIndex].Object)
            {
                GUILayout.Space(5);
                bool open = true;
                CurvyGUI.Foldout(ref open, "Properties");
                OnPropertiesGUI();
            }
        }

    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputGameObjectEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputMeshEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c127229c77cce034395d42ebc04baf85
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevToolsEditor;
using UnityEditorInternal;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(InputMesh))]
    public class InputMeshEditor : CGModuleEditor<InputMesh>
    {
        int selectedIndex;

        protected override void SetupArrayEx(DTFieldNode node, DevTools.ArrayExAttribute attribute)
        {
            node.ArrayEx.drawElementCallback = OnMeshGUI;
            node.ArrayEx.onSelectCallback = (ReorderableList l) => { selectedIndex = l.index; };
            node.ArrayEx.onAddCallback = (ReorderableList l) =>
            {
                Target.Meshes.Insert(Mathf.Clamp(l.index + 1, 0, Target.Meshes.Count), new CGMeshProperties());
                EditorUtility.SetDirty(Target);
            };
        }



        void OnMeshGUI(Rect rect, int index, bool isActive, bool isFocused)
        {
            SerializedProperty prop = serializedObject.FindProperty(string.Format("m_Meshes.Array.data[{0}]", index));
            if (prop != null)
            {
                rect.height = EditorGUIUtility.singleLineHeight;
                rect.y += 1;
                rect.width -= 100;
                SerializedProperty mshProp = prop.FindPropertyRelative("m_Mesh");
                mshProp.objectReferenceValue = EditorGUI.ObjectField(rect, mshProp.objectReferenceValue, typeof(Mesh), false);

                rect.x += rect.width;
                EditorGUI.LabelField(rect, getFormattedMeshInfo(mshProp.objectReferenceValue as Mesh), DTStyles.HtmlLabel);
            }
        }

        void OnPropertiesGUI()
        {
            SerializedProperty prop = serializedObject.FindProperty(string.Format("m_Meshes.Array.data[{0}]", selectedIndex));
            if (prop != null)
            {
                SerializedProperty matProp = prop.FindPropertyRelative("m_Material");
                if (matProp != null)
                {
                    ReorderableList l = new ReorderableList(serializedObject, matProp, true, true, false, false);
                    l.drawHeaderCallback = (Rect rect) => { GUI.Label(rect, "Materials for " + Target.Meshes[selectedIndex].Mesh.name); };
                    l.drawElementCallback = (Rect rect, int index, bool isActive, bool isFocused) =>
                    {
                        rect.height = EditorGUIUtility.singleLineHeight;
                        SerializedProperty pMat = prop.FindPropertyRelative(string.Format("m_Material.Array.data[{0}]", index));
                        pMat.objectReferenceValue = EditorGUI.ObjectField(rect, pMat.objectReferenceValue, typeof(Material), false);
                    };
                    l.DoLayoutList();
                }
                EditorGUILayout.PropertyField(prop.FindPropertyRelative("m_Translation"));
                EditorGUILayout.PropertyField(prop.FindPropertyRelative("m_Rotation"));
                EditorGUILayout.PropertyField(prop.FindPropertyRelative("m_Scale"));
            }
        }

        protected override void OnCustomInspectorGUI()
        {
            base.OnCustomInspectorGUI();
            if (Target && selectedIndex < Target.Meshes.Count && Target.Meshes[selectedIndex].Mesh)
            {
                GUILayout.Space(5);
                bool open = true;
                CurvyGUI.Foldout(ref open, "Properties");
                OnPropertiesGUI();
            }
        }

        string getFormattedMeshInfo(Mesh mesh)
        {
            if (mesh)
            {
                string has = "<color=#008000>";
                string hasnt = "<color=#800000>";
                string close = "</color>";
                //OPTIM this code calls mesh's properties, just to get their length. Those properties do copy an array, every frame! A solution might be to store their length (or the boolean) in CGMeshProperties
                string norm = (mesh.normals.Length > 0) ? has : hasnt;
                string tan = (mesh.tangents.Length > 0) ? has : hasnt;
                string uv = (mesh.uv.Length > 0) ? has : hasnt;
                string uv2 = (mesh.uv2.Length > 0) ? has : hasnt;
                return string.Format("{1}Nor{0} {2}Tan{0} {3}UV{0} {4}UV2{0}", close, norm, tan, uv, uv2);
            }
            else return "";
        }
    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputMeshEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputSplinePathEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 128e3e284da92124aafc1d1c6f295d51
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(InputSplinePath))]
    public class InputSplinePathEditor : CGModuleEditor<InputSplinePath>
    {

    }


}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputSplinePathEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputSplineShapeEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: b4c453ed3cd5e1d47b5a49f02cc592d3
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.Curvy;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(InputSplineShape))]
    public class InputSplineShapeEditor : CGModuleEditor<InputSplineShape>
    {

        protected override void OnEnable()
        {
            base.OnEnable();
            EndIPE();
        }

        internal override void BeginIPE()
        {
            Target.Shape.ShowGizmos = true;

            if (Target.Shape.ControlPointCount > 0)
            {
                Selection.activeObject = Target.Shape.ControlPointsList[0];


                SceneView scn = SceneView.lastActiveSceneView;
                if (scn != null)
                {
                    Transform t = Target.Shape.transform;
                    scn.size = Target.Shape.Bounds.extents.magnitude * 1.5f;
                    scn.FixNegativeSize();
                    scn.LookAt(t.position + t.forward, Quaternion.LookRotation(t.forward, Vector3.up));
                }

                SceneView.RepaintAll();
            }
        }


        /// <summary>
        /// Called for the IPE Target when the module should TRS it's IPE editor to the given values
        /// </summary>
        internal override void OnIPESetTRS(Vector3 position, Quaternion rotation, Vector3 scale)
        {
            if (Target && Target.Shape)
            {
                Target.Shape.transform.localPosition = position;
                Target.Shape.transform.localRotation = rotation;
                Target.Shape.transform.localScale = scale;
            }
        }

        internal override void EndIPE()
        {

        }



    }


}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputSplineShapeEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputSpotsEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: aacae595af62b6b41904baca420e0d2e
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;
using UnityEditorInternal;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(InputSpots))]
    public class InputSpotsEditor : CGModuleEditor<InputSpots>
    {

        protected override void SetupArrayEx(DevToolsEditor.DTFieldNode node, DevTools.ArrayExAttribute attribute)
        {
            base.SetupArrayEx(node, attribute);
            node.ArrayEx.elementHeight *= 4;
            node.ArrayEx.drawElementCallback = OnSpotGUI;
            node.ArrayEx.onAddCallback = (ReorderableList l) =>
            {
                int spotsCount = Target.Spots.Count;

                //value of -1 means nothing selected previously
                var selectedIndex = l.index;
                //when deleting all entries, while having element 0 selected, l.index would be equal to 0, so to handle this:
                selectedIndex = selectedIndex < spotsCount ? selectedIndex : -1;

                CGSpot newSpot;
                int insertionIndex;
                if (selectedIndex < 0)
                {
                    newSpot = new CGSpot(0, Vector3.zero, Quaternion.identity, Vector3.one);
                    insertionIndex = Mathf.Max(spotsCount - 1, 0);
                }
                else
                {
                    newSpot = Target.Spots[selectedIndex];
                    insertionIndex = selectedIndex;
                }

                Target.Spots.Insert(insertionIndex, newSpot);
                EditorUtility.SetDirty(Target);
            };
        }


        void OnSpotGUI(Rect rect, int index, bool isActive, bool isFocused)
        {
            SerializedProperty prop = serializedObject.FindProperty(string.Format("m_Spots.Array.data[{0}]", index.ToString()));
            rect.height = EditorGUIUtility.singleLineHeight;
            if (prop != null)
            {
                EditorGUIUtility.labelWidth = 40;
                Rect r = new Rect(rect);
                GUI.Label(new Rect(r.x, r.y, 30, r.height), "#" + index.ToString());
                EditorGUI.PropertyField(new Rect(r.x + 30, r.y, 115, r.height), prop.FindPropertyRelative("m_Index"));

                EditorGUIUtility.labelWidth = 55;
                r.y += r.height + 1;
                EditorGUI.PropertyField(r, prop.FindPropertyRelative("m_Position"));
                r.y += r.height + 1;
                EditorGUI.PropertyField(r, prop.FindPropertyRelative("m_Rotation"));
                r.y += r.height + 1;
                EditorGUI.PropertyField(r, prop.FindPropertyRelative("m_Scale"));
                if (serializedObject.ApplyModifiedProperties())
                    Target.Dirty = true;
            }
        }

        Vector2 scroll;


        public override void OnInspectorGUI()
        {
            scroll = EditorGUILayout.BeginScrollView(scroll, GUILayout.Height(210));
            base.OnInspectorGUI();
            EditorGUILayout.EndScrollView();
            if (GUILayout.Button("Clear") && EditorUtility.DisplayDialog("Clear List", "Are you sure?", "Yes", "No"))
                Target.Spots.Clear();
        }

    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputSpotsEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputTransformSpotsEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c3be363d24b936045a35d0cee3cd81aa
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;
using UnityEditorInternal;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(InputTransformSpots))]
    public class InputTransformSpotsEditor : CGModuleEditor<InputTransformSpots>
    {
        protected override void SetupArrayEx(DevToolsEditor.DTFieldNode node, DevTools.ArrayExAttribute attribute)
        {
            base.SetupArrayEx(node, attribute);
            node.ArrayEx.elementHeight *= 2;
            node.ArrayEx.drawElementCallback = OnSpotGUI;
            node.ArrayEx.onAddCallback = (ReorderableList l) =>
            {
                int spotsCount = Target.TransformSpots.Count;

                //value of -1 means nothing selected previously
                var selectedIndex = l.index;
                //when deleting all entries, while having element 0 selected, l.index would be equal to 0, so to handle this:
                selectedIndex = selectedIndex < spotsCount ? selectedIndex : -1;

                InputTransformSpots.TransformSpot newSpot;
                int insertionIndex;
                if (selectedIndex < 0)
                {
                    newSpot = new InputTransformSpots.TransformSpot();
                    insertionIndex = Mathf.Max(spotsCount - 1, 0);
                }
                else
                {
                    newSpot = Target.TransformSpots[selectedIndex];
                    insertionIndex = selectedIndex;
                }

                Target.TransformSpots.Insert(insertionIndex, newSpot);
                EditorUtility.SetDirty(Target);
            };
        }


        void OnSpotGUI(Rect rect, int index, bool isActive, bool isFocused)
        {
            SerializedProperty prop = serializedObject.FindProperty(string.Format("transformSpots.Array.data[{0}]", index.ToString()));
            rect.height = EditorGUIUtility.singleLineHeight;
            if (prop != null)
            {
                EditorGUIUtility.labelWidth = 40;
                Rect r = new Rect(rect);
                GUI.Label(new Rect(r.x, r.y, 30, r.height), "#" + index.ToString());
                EditorGUI.PropertyField(new Rect(r.x + 30, r.y, 115, r.height), prop.FindPropertyRelative("index"));

                EditorGUIUtility.labelWidth = 55;
                r.y += r.height + 1;
                EditorGUI.PropertyField(r, prop.FindPropertyRelative("transform"));
                if (serializedObject.ApplyModifiedProperties())
                    Target.Dirty = true;
            }
        }

        Vector2 scroll;


        public override void OnInspectorGUI()
        {
            scroll = EditorGUILayout.BeginScrollView(scroll, GUILayout.Height(210));
            base.OnInspectorGUI();
            EditorGUILayout.EndScrollView();
            if (GUILayout.Button("Clear") && EditorUtility.DisplayDialog("Clear List", "Are you sure?", "Yes", "No"))
                Target.TransformSpots.Clear();
        }

    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/InputTransformSpotsEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/MixShapesEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 46b6e4aba8f7b00449969382092fa0d5
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator.Modules;
using System.Collections.Generic;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(ModifierMixShapes))]
    public class ModifierMixShapesEditor : CGModuleEditor<ModifierMixShapes>
    {
    }




}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/MixShapesEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierMixPathsEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7c356fb19bdfc11478de97cfb65c6b24
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator.Modules;
using System.Collections.Generic;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(ModifierMixPaths))]
    public class ModifierMixPathsEditor : CGModuleEditor<ModifierMixPaths>
    {
    }




}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierMixPathsEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierPathRelativeTranslationEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6dd872e6ca32ec243b1377d13ab1c075
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEditor;
using FluffyUnderware.Curvy.Generator.Modules;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(ModifierPathRelativeTranslation))]
    public class ModifierPathRelativeTranslationEditor : CGModuleEditor<ModifierPathRelativeTranslation>
    {

        // Scene View GUI - Called only if the module is initialized and configured
        //public override void OnModuleSceneGUI() {}

        // Scene View Debug GUI - Called only when Show Debug Visuals is activated
        //public override void OnModuleSceneDebugGUI() {}

        // Inspector Debug GUI - Called only when Show Debug Values is activated
        //public override void OnModuleDebugGUI() {}

    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierPathRelativeTranslationEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierTRSMeshEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 2aca7d5fc73d5784a88c56b1c7c60b00
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(ModifierTRSMesh))]
    public class ModifierTRSMeshEditor : CGModuleEditor<ModifierTRSMesh>
    {

    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierTRSMeshEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierTRSPathEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 8112efb25a3080b4eb194e5815cf5465
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator.Modules;
using System.Collections.Generic;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(ModifierTRSPath))]
    public class ModifierTRSPathEditor : CGModuleEditor<ModifierTRSPath>
    {
    }




}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierTRSPathEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierTRSShapeEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 995de8b354016994286bf1a9a9e1979c
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(ModifierTRSShape))]
    public class ModifierTRSShapeEditor : CGModuleEditor<ModifierTRSShape>
    {

    }

}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierTRSShapeEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierVariableMixShapesEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c416b73776f822f42a39e134ce855b96
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEditor;
using FluffyUnderware.Curvy.Generator.Modules;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(ModifierVariableMixShapes))]
    public class ModifierVariableMixShapesEditor : CGModuleEditor<ModifierVariableMixShapes>
    {
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/ModifierVariableMixShapesEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/NoteEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7d0032aeab6fa1c499d5711ded39d964
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator.Modules;
using System.Collections.Generic;

namespace FluffyUnderware.CurvyEditor.Generator.Modules
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(Note))]
    public class NoteEditor : CGModuleEditor<Note>
    {
        /*
        // Skip Label
        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
            serializedObject.UpdateIfDirtyOrScript();
            EditorGUILayout.PropertyField(serializedObject.FindProperty("m_Text"), new GUIContent(""));
            serializedObject.ApplyModifiedProperties();
                

        }
         */
    }




}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG Modules/NoteEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CanvasSelection.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e3a1be3eec3ac794e8bb30df7860a875
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.DevToolsEditor;
using JetBrains.Annotations;

namespace FluffyUnderware.CurvyEditor.Generator
{
    public class CanvasSelection
    {
        public List<CGModule> SelectedModules = new List<CGModule>();

        public CGModuleLink SelectedLink { get; private set; }
        public CGModule SelectedModule
        {
            get { return (SelectedModules.Count > 0) ? SelectedModules[0] : null; }
        }

        //todo unused, remove it
        public CGGraph Parent;

        /// <summary>
        /// Returns a new array with the <see cref="SelectedLink"/> if any, otherwise <see cref="SelectedModules"/>
        /// </summary>
        public object[] SelectedObjects
        {
            get
            {
                if (SelectedLink != null)
                    return new object[1] { SelectedLink };
                return SelectedModules.ToArray();
            }
        }

        /// <summary>
        /// Empties list and adds into it the <see cref="SelectedLink"/> if any, otherwise <see cref="SelectedModules"/>
        /// </summary>
        public void FillWithSelectedObjects(List<object> list)
        {
            list.Clear();
            if (SelectedLink != null)
                list.Add(SelectedLink);
            else
                list.AddRange(SelectedModules);
        }

        public CanvasSelection(CGGraph parent)
        {
            Parent = parent;
        }

        public void Clear()
        {
            SelectedLink = null;
            SelectedModules.Clear();
            if (CurvyProject.Instance.CGSynchronizeSelection)
                DTSelection.Clear();
        }

        /// <summary>
        /// Selects nothing (null), a link or one or more modules
        /// </summary>
        /// <param name="mod"></param>
        [Obsolete("Use SetSelectionTo, or Clear, depending on your needs")]
        public void Select(params object[] objects)
        {
            Clear();
            if (objects == null || objects.Length == 0)
                return;
            if (objects[0] is List<CGModule>)
                objects = ((List<CGModule>)objects[0]).ToArray();
            if (objects[0] is CGModuleLink)
                SelectedLink = (CGModuleLink)objects[0];
            else
            {
                List<Component> cmp = new List<Component>();
                foreach (object o in objects)
                    if (o is CGModule)
                    {
                        SelectedModules.Add((CGModule)o);
                        cmp.Add((CGModule)o);
                    }

                if (CurvyProject.Instance.CGSynchronizeSelection)
                    DTSelection.SetGameObjects(cmp.ToArray());
            }

        }

        public void SetSelectionTo([NotNull] CGModuleLink link)
        {
            Clear();
            SelectedLink = link;
        }

        public void SetSelectionTo([NotNull] CGModule module)
        {
            SetSelectionTo(new[] { module });
        }

        public void SetSelectionTo([NotNull] IEnumerable<CGModule> modules)
        {
            bool modulesSelectionChanged = modules.SequenceEqual(SelectedModules) == false;

            Clear();

            SelectedModules.AddRange(modules);

            if (modulesSelectionChanged && CurvyProject.Instance.CGSynchronizeSelection)
                DTSelection.SetGameObjects(modules.Select(m => m as Component).ToArray());
        }

        /// <summary>
        /// Adds or removes a module from the selection
        /// </summary>
        // Todo this code does not handle selection synchronisation. fix this before rehabilitating the method if needed
        [Obsolete("Use SetSelectionTo, or Clear, depending on your needs")]
        public void MultiSelectModule(CGModule mod)
        {
            if (mod == null)
                return;
            if (SelectedModules.Contains(mod))
                SelectedModules.Remove(mod);
            else
                SelectedModules.Add(mod);

            //todo why is this nt handling  if (CurvyProject.Instance.CGSynchronizeSelection)

        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CanvasSelection.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CanvasState.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e7b2f43090b47ae4cb2bce3016056f9c
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.DevToolsEditor.Data;

namespace FluffyUnderware.CurvyEditor.Generator
{
    internal class CanvasState
    {
        readonly CGGraph Parent;
        public CanvasSelection Sel { get { return Parent.Sel; } }
        public CanvasUI UI { get { return Parent.UI; } }
        Event EV { get { return Event.current; } }


        public CanvasState(CGGraph parent)
        {
            Parent = parent;
        }


        /// <summary>
        /// The module the mouse is hovering
        /// </summary>
        //todo this and IsMouseOverModule should be tied
        public CGModule MouseOverModule;


        /// <summary>
        /// Storing Event.current.mousePosition (in Canvasspace!)
        /// </summary>
        public Vector2 MousePosition;

        #region Scrolling



        /// <summary>
        /// Canvas scrolling state
        /// </summary>
        [Obsolete("Use ScrollValue, ScrollTarget, ScrollSpeed or IsScrollValueAnimating")]
        public AnimVector2 Scroll = new AnimVector2();

        private Vector2 scrollValue;

        /// <summary>
        /// Setting ScrollValue will stop any ongoing animation
        /// </summary>
        public Vector2 ScrollValue
        {
            get => scrollValue;
            set
            {
                value.x = Mathf.Max(0f, value.x);
                value.y = Mathf.Max(0f, value.y);

                scrollValue = value;
                ScrollTarget = value;
                ScrollSpeed = 0;
            }
        }

        public Vector2 ScrollTarget { get; private set; }
        public float ScrollSpeed { get; private set; }
        public bool IsScrollValueAnimating => ScrollTarget != ScrollValue;

        public void SetScrollTarget(Vector2 target, float speed)
        {
            target.x = Mathf.Max(0f, target.x);
            target.y = Mathf.Max(0f, target.y);

            ScrollTarget = target;
            ScrollSpeed = speed;
        }

        public void UpdateScrollingAnimation(double time)
        {
            scrollValue = Vector2.MoveTowards(scrollValue, ScrollTarget, (float)(ScrollSpeed * time));
        }

        #endregion

        /// <summary>
        /// Left/Top offset of Canvas from window
        /// </summary>
        public Vector2 ClientRectOffset;

        /// <summary>
        /// Whether the mouse is hovering over a module or not
        /// </summary>
        //todo this and MouseOverModule should be tied
        public bool IsMouseOverModule { get; private set; }

        public bool IsMouseOverCanvas
        {
            get
            {
                return ViewPort.Contains(MousePosition);
            }
        }
        /// <summary>
        /// Gets the canvas' scrollview size in window space
        /// </summary>
        public Rect ClientRect { get; private set; }
        /// <summary>
        /// Gets the total canvas size
        /// </summary>
        public Rect CanvasRect { get; private set; }

        /// <summary>
        /// Gets the visible rect of the canvas
        /// </summary>
        public Rect ViewPort
        {
            get
            {
                return new Rect(CanvasRect.x + ScrollValue.x, CanvasRect.y + ScrollValue.y, ClientRect.width, ClientRect.height);
            }
        }

        public Vector2 ViewPortMousePosition
        {
            get
            {
                return MousePosition + ClientRectOffset - ViewPort.min;
            }
        }

        public void SetClientRect(float xOffset, float yOffset, float xspace = 0, float yspace = 0)
        {
            ClientRectOffset = new Vector2(xOffset, yOffset);
            ClientRect = new Rect(ClientRectOffset.x, ClientRectOffset.y, (Parent.position.width - ClientRectOffset.x - xspace), (Parent.position.height - ClientRectOffset.y - yspace));

        }

        /// <summary>
        /// Grows the canvas to include the rect
        /// </summary>
        /// <param name="r">a rect in canvas space</param>
        public void EnlargeCanvasFor(Rect r)
        {
            //if (CurvyGUI.IsLayout)
            CanvasRect = CanvasRect.Include(r);
        }

        public void BeginGUI()
        {
            if (EV.isMouse || EV.type == EventType.DragUpdated || EV.type == EventType.DragExited)
                MousePosition = EV.mousePosition;

            //if (EV.type != EventType.Repaint && EV.type != EventType.Layout)
            //    Debug.Log("BeginGUI()  " + EV.type + "  " + IsMouseOverCanvas);

            if (IsMouseOverCanvas)
                //mouse events
                switch (EV.type)
                {
                    case EventType.MouseDrag:
                        if (!IsDragging)
                        {
                            if (IsMouseOverModule)
                                StartModuleDrag();
                            else
                                StartSelectionRectangleDrag();
                        }
                        break;
                    case EventType.MouseMove:
                    case EventType.MouseUp:
                        //ending drag is done in EventType.MouseMove to handle cases where the drag is finished while the mouse is out of the window, meaning that the MouseUp event is not catched
                        if (IsModuleDrag)
                            EndModuleDrag();
                        if (EV.type == EventType.MouseUp)
                        {
                            if (EV.button == 1)
                                UI.ContextMenu();
                        }
                        break;
                    case EventType.MouseDown:
                        if (IsCanvasDrag == false && EV.button == 2)
                            StartCanvasDrag(false);
                        break;
                }

            //keyboard events
            switch (EV.type)
            {
                case EventType.KeyDown:
                    if (IsCanvasDrag == false && EV.keyCode == KeyCode.Space)
                        StartCanvasDrag(true);
                    break;
                case EventType.KeyUp:
                    if (IsCanvasDrag && isKeyboardCanvasDrag && EV.keyCode == KeyCode.Space)
                        EndCanvasDrag();
                    break;
            }

            if (EV.type != EventType.Layout)
                IsMouseOverModule = false;

            if (IsCanvasDrag)
                EditorGUIUtility.AddCursorRect(ViewPort, MouseCursor.Pan);
        }

        /// <summary>
        /// Processing of Events AFTER Module Window drawing (Beware! Window dragging eats up most events!)
        /// </summary>
        public void EndGUI()
        {
            //if (EV.type != EventType.Repaint && EV.type != EventType.Layout)
            //    Debug.Log("EndGUI()  " + EV.type + "  " + IsMouseOverCanvas);

            if (IsMouseOverCanvas)
                //mouse events
                switch (EV.type)
                {
                    case EventType.MouseDrag:
                        // Drag canvas (i.e. change scroll offset)
                        if (IsCanvasDrag)
                        {
                            ScrollValue -= EV.delta;
                        }
                        break;
                    case EventType.MouseMove:
                    case EventType.MouseUp:
                        if (EV.type == EventType.MouseUp)
                        {
                            if (EV.button == 0 && !IsDragging)
                            {
                                if (Sel.SelectedLink && !MouseOverLink(Sel.SelectedLink)
                                    || (Sel.SelectedModule && !MouseOverModule))
                                    Sel.Clear();
                            }

                            // Multi Selection
                            if (IsSelectionRectDrag)
                                EndSelectionRectangleDrag();

                            Parent.StatusBar.Clear();
                        }

                        //ending drag is done in EventType.MouseMove to handle cases where the drag is finished while the mouse is out of the window, meaning that the MouseUp event is not caught
                        {
                            if (IsLinkDrag)
                                EndLinkDrag();

                            // Multi Selection
                            if (IsSelectionRectDrag)
                                CancelSelectionRectangleDrag();

                            if (IsCanvasDrag && isKeyboardCanvasDrag == false)
                                EndCanvasDrag();
                        }
                        break;
                    case EventType.DragUpdated:
                        UI.HandleDragDropProgress();
                        break;
                    case EventType.DragPerform:
                        UI.HandleDragDropDone();
                        break;
                }

            //keyboard events
            switch (EV.type)
            {
                case EventType.KeyDown:
                    switch (EV.keyCode)
                    {
                        case KeyCode.Delete:
                            CanvasUI.DeleteSelection(UI);
                            break;
                        case KeyCode.A:
                            if (EV.control)
                                CanvasUI.SelectAll(UI);
                            break;
                        case KeyCode.C:
                            if (EV.control)
                                CanvasUI.CopySelection(UI);
                            break;
                        case KeyCode.V:
                            if (EV.control)
                                CanvasUI.PastSelection(UI);
                            break;
                        case KeyCode.X:
                            if (EV.control)
                                CanvasUI.CutSelection(UI);
                            break;
                        case KeyCode.D:
                            if (EV.control)
                            {
                                CanvasUI.CopySelection(UI);
                                CanvasUI.PastSelection(UI);
                            }
                            break;
                    }
                    break;
            }
        }

        public void ViewPortRegisterWindow(CGModule module)
        {
            Rect winRect = module.Properties.Dimensions;
            EnlargeCanvasFor(winRect);

            if (!IsMouseOverModule && EV.type != EventType.Layout)
            {
                IsMouseOverModule = winRect.Contains(EV.mousePosition);
                MouseOverModule = (IsMouseOverModule) ? module : null;
            }
        }

        /// <summary>
        /// Sets the Canvas Rectangle so that it includes all the given modules
        /// </summary>
        public void ComputeCanvasRectangle(List<CGModule> modules)
        {
            CanvasRect = new Rect(0, 0, 0, 0);
            foreach (CGModule mod in modules)
                if (mod != null)
                    ViewPortRegisterWindow(mod);
        }

        public void FocusSelection()
        {
            CGModule selectedModule = Sel.SelectedModule;
            if (selectedModule)
            {
                Vector2 scrollDelta = GetFocusDelta(selectedModule);
                SetScrollTarget(ScrollValue + scrollDelta, Mathf.Max(60f, scrollDelta.magnitude * 4f));
            }
        }

        /// <summary>
        /// Returns the translation the viewport needs to do to focus on the given module
        /// </summary>
        /// <param name="targetModule">The module to focus on</param>

        public Vector2 GetFocusDelta(CGModule targetModule)
        {
            Rect focusedDimensions = targetModule.Properties.Dimensions;

            Rect viewPort = ViewPort;

            //add a margin, to include the module's highlight in the screen
            const float xMargin = 5;
            const float yMargin = 5;
            focusedDimensions.x -= xMargin;
            focusedDimensions.y -= yMargin;
            //the + 17 is to take into account the pixels taken by the scroll bar. I am always assuming the scroll bar is visible. An improvement is to check if they are actually there or not.
            focusedDimensions.width += 2 * xMargin + 17;
            focusedDimensions.height += 2 * yMargin + 17;

            //clamp the focused rectangle to what can be possibly seen within the viewport
            focusedDimensions.width = Mathf.Min(focusedDimensions.width, viewPort.width);
            focusedDimensions.height = Mathf.Min(focusedDimensions.height, viewPort.height);

            //clamp the focused rectangle to the canvas dimensions
            focusedDimensions.xMax = Math.Min(focusedDimensions.xMax, CanvasRect.width);
            focusedDimensions.yMax = Math.Min(focusedDimensions.yMax, CanvasRect.height);
            focusedDimensions.xMin = Math.Max(focusedDimensions.xMin, CanvasRect.x);
            focusedDimensions.yMin = Math.Max(focusedDimensions.yMin, CanvasRect.y);


            Vector2 delta = Vector2.zero;
            if (focusedDimensions.xMax > viewPort.xMax)
                delta.x = focusedDimensions.xMax - viewPort.xMax;
            else if (focusedDimensions.xMin < viewPort.xMin)
                delta.x = focusedDimensions.xMin - viewPort.xMin;

            if (focusedDimensions.yMax > viewPort.yMax)
                delta.y = focusedDimensions.yMax - viewPort.yMax;
            else if (focusedDimensions.yMin < viewPort.yMin)
                delta.y = focusedDimensions.yMin - viewPort.yMin;
            return delta;
        }

        public bool MouseOverLink(CGModuleLink link)
        {
            if (link == null)
                return false;

            CGModuleOutputSlot outSlot = Parent.Generator.ModulesByID[link.ModuleID].GetOutputSlot(link.SlotName);
            CGModuleInputSlot inSlot = Parent.Generator.ModulesByID[link.TargetModuleID].GetInputSlot(link.TargetSlotName);

            Vector3 startPosition = outSlot.Origin;
            Vector3 endPosition = inSlot.Origin;

            CGGraph.GetLinkBezierTangents(
                startPosition,
                endPosition,
                out Vector2 startTangent,
                out Vector2 endTangent);

            return HandleUtility.DistancePointBezier(EV.mousePosition, startPosition, endPosition, startTangent, endTangent) <= CGGraph.LinkSelectionDistance;
        }


        #region Drag handling

        /// <summary>
        /// Gets whether the user is currently dragging anything (Canvas, Module, Link, etc..)
        /// </summary>
        public bool IsDragging
        {
            get { return IsCanvasDrag || IsModuleDrag || IsLinkDrag || IsSelectionRectDrag; }
        }

        #region CanvasDrag

        public bool IsCanvasDrag;
        /// <summary>
        /// Was the Canvas drag initiated by the keyboard or the mouse?
        /// </summary>
        private bool isKeyboardCanvasDrag;

        private void StartCanvasDrag(bool isKeyboardInitiated)
        {
            IsCanvasDrag = true;
            isKeyboardCanvasDrag = isKeyboardInitiated;
        }

        private void EndCanvasDrag()
        {
            IsCanvasDrag = false;
        }

        #endregion
        #region Module Drag

        public bool IsModuleDrag;

        private void StartModuleDrag()
        {
            IsModuleDrag = true;
        }

        private void EndModuleDrag()
        {
            IsModuleDrag = false;
        }

        #endregion

        //The rest of the code handling links dragging is in CGGraph.cs
        #region Link Drag


        public CGModuleOutputSlot LinkDragFrom;

        /// <summary>
        /// Gets whether a link is currently dragged
        /// </summary>
        public bool IsLinkDrag
        {
            get { return LinkDragFrom != null; }
        }

        public CGModuleOutputSlot AutoConnectFrom;

        private void EndLinkDrag()
        {
            if (EV.control)
            {
                AutoConnectFrom = LinkDragFrom;
                UI.AddModuleQuickmenu(LinkDragFrom);
            }

            LinkDragFrom = null;
        }

        //The rest of the code handling links dragging is in CGGraph.cs


        #endregion

        #region Selection Rectangle Drag

        public bool IsSelectionRectDrag;

        /// <summary>
        /// Starting position of selection drag
        /// </summary>
        public Vector2 SelectionRectStart;

        private void StartSelectionRectangleDrag()
        {
            IsSelectionRectDrag = true;
            SelectionRectStart = ViewPortMousePosition;
        }

        public void HandleMultiSelection()
        {
            Rect selectionRect = new Rect().SetBetween(SelectionRectStart, ViewPortMousePosition);
            selectionRect.position -= ClientRectOffset - ViewPort.position;

            Sel.SetSelectionTo(Parent.Modules.Where(m => selectionRect.Overlaps(m.Properties.Dimensions, true)).ToList());
        }

        private void EndSelectionRectangleDrag()
        {
            HandleMultiSelection();
            IsSelectionRectDrag = false;
        }
        private void CancelSelectionRectangleDrag()
        {
            IsSelectionRectDrag = false;
        }

        #endregion

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CanvasState.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CanvasUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6ce3f6137153735498d55b2fce2ad997
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.Reflection;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevTools;
using Object = UnityEngine.Object;

namespace FluffyUnderware.CurvyEditor.Generator
{


    public class CanvasUI
    {
        public static CGClipboard Clipboard = new CGClipboard();
        readonly CGGraph Parent;
        /// <summary>
        /// Gets ModuleInfo->Module Type mapping
        /// </summary>
        SortedDictionary<ModuleInfoAttribute, System.Type> TypeByModuleInfo = new SortedDictionary<ModuleInfoAttribute, System.Type>();
        /// <summary>
        /// Gets Modules that accept a certain input data type
        /// </summary>
        readonly Dictionary<System.Type, List<ModuleInfoAttribute>> ModuleInfoByInput = new Dictionary<System.Type, List<ModuleInfoAttribute>>();

        /// <summary>
        /// Used to get InputSlotInfo from (ModuleInfoAttribute,InputType) couples
        /// </summary>
        readonly Dictionary<ModuleInfoAttribute, Dictionary<Type, InputSlotInfo>> inputSlotInfoByModuleInfoAndInputType = new Dictionary<ModuleInfoAttribute, Dictionary<Type, InputSlotInfo>>();
        readonly SortedDictionary<string, string> TemplatesByMenuName = new SortedDictionary<string, string>();

        CanvasSelection Sel { get { return Parent.Sel; } }
        CanvasState Canvas { get { return Parent.Canvas; } }

        public CanvasUI(CGGraph parent)
        {
            Parent = parent;
            LoadData();
        }

        public void AddModuleQuickmenu(CGModuleOutputSlot forOutputSlot)
        {
            GenericMenu mnu = new GenericMenu();
            List<ModuleInfoAttribute> matches;
            System.Type outType = forOutputSlot.OutputInfo.DataType;
            while (typeof(CGData).IsAssignableFrom(outType) && outType != typeof(CGData))
            {

                if (ModuleInfoByInput.TryGetValue(outType, out matches))
                {
                    foreach (ModuleInfoAttribute mi in matches)
                    {
                        InputSlotInfo si = inputSlotInfoByModuleInfoAndInputType[mi][outType];
                        if (CGModuleInputSlot.AreInputAndOutputSlotsCompatible(si, typeof(IOnRequestProcessing).IsAssignableFrom(TypeByModuleInfo[mi]), forOutputSlot.OutputInfo, forOutputSlot.OnRequestModule != null))
                            mnu.AddItem(new GUIContent(mi.MenuName), false, CTXOnAddAndConnectModule, mi);
                    }
                    mnu.ShowAsContext();
                }
                outType = outType.BaseType;
            }
        }



        void AddMenuItem(GenericMenu mnu, string item, GenericMenu.MenuFunction2 func, object userData, bool enabled = true)
        {
            if (enabled)
                mnu.AddItem(new GUIContent(item), false, func, userData);
            else
                mnu.AddDisabledItem(new GUIContent(item));
        }

        void AddMenuItem(GenericMenu mnu, string item, GenericMenu.MenuFunction func, bool enabled = true)
        {
            if (enabled)
                mnu.AddItem(new GUIContent(item), false, func);
            else
                mnu.AddDisabledItem(new GUIContent(item));
        }

        public void ContextMenu()
        {
            GenericMenu mnu = new GenericMenu();
            // Add/<Modules>
            List<ModuleInfoAttribute> miNames = new List<ModuleInfoAttribute>(TypeByModuleInfo.Keys);

            foreach (ModuleInfoAttribute mi in miNames)
                AddMenuItem(mnu, "Add/" + mi.MenuName, CTXOnAddModule, mi);
            // Add/<Templates>


            foreach (string tplName in TemplatesByMenuName.Keys)
                AddMenuItem(mnu, "Add Template/" + tplName, CTXOnAddTemplate, tplName);

            mnu.AddSeparator("");
            AddMenuItem(mnu, "Reset", CTXOnReset, Sel.SelectedModules.Count > 0);
            mnu.AddSeparator("");
            AddMenuItem(mnu, "Cut", () => CutSelection(this), Sel.SelectedModules.Count > 0);
            AddMenuItem(mnu, "Copy", () => CopySelection(this), Sel.SelectedModules.Count > 0);
            AddMenuItem(mnu, "Paste", () => PastSelection(this), !Clipboard.Empty);
            mnu.AddSeparator("");
            AddMenuItem(mnu, "Delete", () => DeleteSelection(this), Sel.SelectedModules.Count > 0 || Sel.SelectedLink != null);
            mnu.AddSeparator("");
            AddMenuItem(mnu, "Select all", () => SelectAll(this));
            mnu.ShowAsContext();
        }

        void CTXOnReset()
        {
            foreach (CGModule mod in Sel.SelectedModules)
                mod.Reset();
        }

        void CTXOnAddModule(object userData)
        {
            ModuleInfoAttribute mi = (ModuleInfoAttribute)userData;
            CGModule mod = AddModule(TypeByModuleInfo[mi]);
            mod.Properties.Dimensions = mod.Properties.Dimensions.SetPosition(Canvas.MousePosition);
        }

        void CTXOnAddAndConnectModule(object userData)
        {
            if (!Canvas.AutoConnectFrom)
                return;

            ModuleInfoAttribute mi = (ModuleInfoAttribute)userData;
            CGModule mod = AddModule(TypeByModuleInfo[mi]);

            mod.Properties.Dimensions = mod.Properties.Dimensions.SetPosition(Canvas.MousePosition);

            foreach (CGModuleInputSlot inputSlot in mod.Input)
                if (inputSlot.CanLinkTo(Canvas.AutoConnectFrom))
                {
                    Canvas.AutoConnectFrom.LinkTo(inputSlot);
                    return;
                }

        }

        void CTXOnAddTemplate(object userData)
        {
            string tplPath;
            if (TemplatesByMenuName.TryGetValue((string)userData, out tplPath))
                CGEditorUtility.LoadTemplate(Parent.Generator, tplPath, Canvas.MousePosition);
        }

        public CGModule AddModule(System.Type type)
        {
            CGModule mod = Parent.Generator.AddModule(type);
            Undo.RegisterCreatedObjectUndo(mod, "Create Module");
            return mod;
        }

        /// <summary>
        /// Deletes a link or one or more modules (Undo-Aware!)
        /// </summary>
        /// <param name="objects"></param>
        public void Delete(params object[] objects)
        {
            if (objects == null || objects.Length == 0)
                return;
            if (objects[0] is CGModuleLink)
                DeleteLink((CGModuleLink)objects[0]);
            else
                foreach (CGModule m in objects)
                    m.Delete();
        }

        public void DeleteLink(CGModuleLink link)
        {
            CGModuleOutputSlot sOut = Parent.Generator.GetModule(link.ModuleID, true).OutputByName[link.SlotName];
            CGModuleInputSlot sIn = Parent.Generator.GetModule(link.TargetModuleID, true).InputByName[link.TargetSlotName];
            sOut.UnlinkFrom(sIn);
        }

        public void LoadData()
        {
            // Build TypeByModuleInfo and ModuleInfoByInput dictionaries
            TypeByModuleInfo.Clear();
            ModuleInfoByInput.Clear();
            inputSlotInfoByModuleInfoAndInputType.Clear();
            TypeByModuleInfo = new SortedDictionary<ModuleInfoAttribute, System.Type>(typeof(CGModule).GetAllTypesWithAttribute<ModuleInfoAttribute>());

            foreach (KeyValuePair<ModuleInfoAttribute, Type> kv in TypeByModuleInfo)
            {
                Type moduleType = kv.Value;
                ModuleInfoAttribute moduleInfoAttribute = kv.Key;

                FieldInfo[] fields = moduleType.GetFields(BindingFlags.Public | BindingFlags.Instance);
                foreach (FieldInfo fieldInfo in fields)
                    if (fieldInfo.FieldType == typeof(CGModuleInputSlot))
                    {
                        object[] slotAttrib = fieldInfo.GetCustomAttributes(typeof(InputSlotInfo), true);
                        if (slotAttrib.Length > 0)
                        {
                            InputSlotInfo inputSlotInfo = (InputSlotInfo)slotAttrib[0];
                            List<ModuleInfoAttribute> moduleInfoAttributes;
                            for (int x = 0; x < inputSlotInfo.DataTypes.Length; x++)
                            {
                                Type dataType = inputSlotInfo.DataTypes[x];
                                if (!ModuleInfoByInput.TryGetValue(dataType, out moduleInfoAttributes))
                                {
                                    moduleInfoAttributes = new List<ModuleInfoAttribute>();
                                    ModuleInfoByInput.Add(dataType, moduleInfoAttributes);
                                }

                                moduleInfoAttributes.Add(moduleInfoAttribute);

                                if (inputSlotInfoByModuleInfoAndInputType.ContainsKey(moduleInfoAttribute) == false)
                                    inputSlotInfoByModuleInfoAndInputType[moduleInfoAttribute] = new Dictionary<Type, InputSlotInfo>();
                                if (inputSlotInfoByModuleInfoAndInputType[moduleInfoAttribute].ContainsKey(dataType) == false)
                                    inputSlotInfoByModuleInfoAndInputType[moduleInfoAttribute][dataType] = inputSlotInfo;
                            }
                        }
                    }
            }
            // load Templates
            ReloadTemplates();
        }

        /// <summary>
        /// Reloads the available templates from the prefabs in the Templates folder
        /// </summary>
        public void ReloadTemplates()
        {
            TemplatesByMenuName.Clear();
            string[] baseFolders;
            if (AssetDatabase.IsValidFolder("Assets/" + CurvyProject.Instance.CustomizationRootPath + CurvyProject.RELPATH_CGTEMPLATES))
                baseFolders = new string[2] { "Assets/" + CurvyEditorUtility.GetPackagePath("CG Templates"), "Assets/" + CurvyProject.Instance.CustomizationRootPath + CurvyProject.RELPATH_CGTEMPLATES };
            else
                baseFolders = new string[1] { "Assets/" + CurvyEditorUtility.GetPackagePath("CG Templates") };

            string[] prefabs = AssetDatabase.FindAssets("t:gameobject", baseFolders);

            foreach (string guid in prefabs)
            {
                string path = AssetDatabase.GUIDToAssetPath(guid);
                // Store under a unique menu name
                string name = AssetDatabase.LoadAssetAtPath(path, typeof(Transform)).name;
                string menuPath = System.IO.Path.GetDirectoryName(path).Replace(System.IO.Path.DirectorySeparatorChar.ToString(), "/");
                foreach (string s in baseFolders)
                    menuPath = menuPath.TrimStart(s);
                menuPath = menuPath.TrimStart('/');

                string menuName = string.IsNullOrEmpty(menuPath)
                    ? name
                    : menuPath + "/" + name;
                int i = 0;
                while (TemplatesByMenuName.ContainsKey((i == 0)
                    ? menuName
                    : menuName + i.ToString()))
                    i++;
                TemplatesByMenuName.Add((i == 0)
                    ? menuName
                    : menuName + i.ToString(), path);
            }
        }

        public void HandleDragDropProgress()
        {
            DragAndDrop.visualMode = DragAndDropVisualMode.Generic;
        }

        public void HandleDragDropDone()
        {
            Vector2 mousePosition = Event.current.mousePosition;

            foreach (Object @object in DragAndDrop.objectReferences)
            {
                CGModule module = null;
                if (@object is GameObject gameObject)
                {
                    CurvySpline spline = gameObject.GetComponent<CurvySpline>();
                    if (spline)
                    {
                        CurvyShape shape = gameObject.GetComponent<CurvyShape>();
                        if (shape)
                        {
                            InputSplineShape inputModule = Parent.Generator.AddModule<InputSplineShape>();
                            inputModule.Shape = spline;
                            module = inputModule;
                        }
                        else
                        {
                            InputSplinePath inputModule = Parent.Generator.AddModule<InputSplinePath>();
                            inputModule.Spline = spline;
                            module = inputModule;
                        }
                    }
                    else
                    {
                        InputGameObject inputModule = Parent.Generator.AddModule<InputGameObject>();
                        inputModule.GameObjects.Add(new CGGameObjectProperties(gameObject));
                        module = inputModule;
                    }

                }
                else if (@object is Mesh mesh)
                {
                    InputMesh inputModule = Parent.Generator.AddModule<InputMesh>();
                    inputModule.Meshes.Add(new CGMeshProperties(mesh));
                    module = inputModule;
                }

                if (module)
                {
                    module.Properties.Dimensions.position = mousePosition;
                    module.Properties.Dimensions.xMin -= module.Properties.MinWidth / 2;
                    mousePosition.y += module.Properties.Dimensions.height;
                }
            }

            DragAndDrop.AcceptDrag();
        }

        #region shortcut/contextual menu shared commands

        public static void SelectAll(CanvasUI ui)
        {
            ui.Sel.SetSelectionTo(ui.Parent.Modules);
        }

        public static void DeleteSelection(CanvasUI ui)
        {
            ui.Delete(ui.Sel.SelectedObjects);
            ui.Sel.Clear();
        }

        public static void CopySelection(CanvasUI ui)
        {
            Clipboard.CopyModules(ui.Sel.SelectedModules);
        }
        public static void CutSelection(CanvasUI ui)
        {
            Clipboard.CutModules(ui.Sel.SelectedModules);
        }
        public static void PastSelection(CanvasUI ui)
        {
            // relative position between modules were kept, but take current mouse position as reference!
            Vector2 off = ui.Canvas.MousePosition - Clipboard.Modules[0].Properties.Dimensions.position;
            ui.Sel.SetSelectionTo(Clipboard.PasteModules(ui.Parent.Generator, off));
        }

        #endregion
    }

    public class CGClipboard
    {
        public enum ClipboardMode
        {
            Cut,
            Copy
        }

        public ClipboardMode Mode = ClipboardMode.Copy;

        public List<CGModule> Modules = new List<CGModule>();


        public bool Empty { get { return Modules.Count == 0; } }

        public CurvyGenerator ParentGenerator
        {
            get
            {
                return (Modules.Count > 0) ? Modules[0].Generator : null;
            }
        }

        public void CutModules(IList<CGModule> modules)
        {
            Mode = ClipboardMode.Cut;
            copyInternal(modules);
        }

        public void CopyModules(IList<CGModule> modules)
        {
            Mode = ClipboardMode.Copy;
            copyInternal(modules);
        }

        public void Clear()
        {
            Modules.Clear();

        }

        /// <summary>
        /// Paste all Clipboard modules
        /// </summary>
        /// <param name="target">the generator to paste to</param>
        /// <param name="positionOffset">Canvas offset to use</param>
        /// <returns>the new modules</returns>
        public List<CGModule> PasteModules(CurvyGenerator target, Vector2 positionOffset)
        {
            List<CGModule> res = CGEditorUtility.CopyModules(Modules, target, positionOffset);
            if (Mode == ClipboardMode.Cut)
                foreach (CGModule mod in Modules)
                    ParentGenerator.DeleteModule(mod);
            Clear();

            return res;
        }

        void copyInternal(IList<CGModule> modules)
        {
            Modules.Clear();
            Modules.AddRange(modules);
        }


    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CanvasUI.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CGEditorUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: a3160a5daacc00349af244daf1e13e36
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Utils;
using System.Reflection;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.DevToolsEditor.Extensions;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevTools;
using FluffyUnderware.Curvy;
using System.IO;

namespace FluffyUnderware.CurvyEditor.Generator
{
    public static class CGEditorUtility
    {

        static List<CGModuleOutputSlot> findOutputSlots(CurvyGenerator generator, bool includeOnRequestProcessing, System.Type filterSlotDataType = null)
        {
            List<CGModule> modules = generator.GetModules(includeOnRequestProcessing);
            List<CGModuleOutputSlot> res = new List<CGModuleOutputSlot>();
            foreach (CGModule mod in modules)
                res.AddRange(mod.GetOutputSlots(filterSlotDataType));
            return res;
        }

        public static void ShowOutputSlotsMenu(GenericMenu.MenuFunction2 func, System.Type filterSlotDataType = null)
        {
            GenericMenu mnu = new GenericMenu();
            CurvyGenerator[] generators = Component.FindObjectsOfType<CurvyGenerator>();

            mnu.AddItem(new GUIContent("none"), false, func, null);

            foreach (CurvyGenerator gen in generators)
            {
                List<CGModuleOutputSlot> slots = findOutputSlots(gen, false, filterSlotDataType);
                foreach (CGModuleOutputSlot slot in slots)
                    mnu.AddItem(new GUIContent(gen.name + "/" + slot.Module.ModuleName + "/" + slot.Info.DisplayName), false, func, slot);
            }

            mnu.ShowAsContext();
        }

        public static List<CGModule> CopyModules(IList<CGModule> sourceModules, CurvyGenerator target, Vector2 canvasPosition)
        {
            List<CGModule> res = new List<CGModule>();

            Dictionary<int, int> IDMapping = new Dictionary<int, int>();


            // I. Copy Module, store mapping from old to new ID
            foreach (CGModule mod in sourceModules)
            {
                int oldID = mod.UniqueID;
                // Duplicate module GameObject and parent it to the target Generator, also ensure a unique module name and module id
                CGModule newMod = mod.CopyTo(target);
                res.Add(newMod);
                IDMapping.Add(oldID, newMod.UniqueID);
                newMod.Properties.Dimensions.position += canvasPosition;

                // ! Handle managed Resources !
                /*
                var resourceFields = DTUtility.GetFieldsWithAttribute(mod.GetType(), typeof(CGResourceManagerAttribute), BindingFlags.Instance | BindingFlags.NonPublic);
                foreach (var fi in resourceFields)
                {
                    var v = fi.GetValue(mod) as Component;
                    // Managed?
                    if (v != null && v.transform.parent == mod.transform)
                    {
                        var newV = v.DuplicateGameObject(newMod.transform);
                        if (newV != null)
                            fi.SetValue(newMod, newV);
                    }
                }*/
                //newMod.renameManagedResourcesINTERNAL();

            }
            // II. Update Links to use the new IDs
            for (int m = 0; m < res.Count; m++)
            {
                CGModule mod = res[m];
                int newID = mod.UniqueID;

                for (int i = mod.InputLinks.Count - 1; i >= 0; i--)
                {
                    // if target module was copied as well, change both IDs
                    int newTargetID;
                    if (IDMapping.TryGetValue(mod.InputLinks[i].TargetModuleID, out newTargetID))
                    {
                        mod.InputLinks[i].SetModuleIDIINTERNAL(newID, newTargetID);
                    }
                    else // otherwise delete link
                        mod.InputLinks.RemoveAt(i);
                }
                for (int i = mod.OutputLinks.Count - 1; i >= 0; i--)
                {
                    // if target module was copied as well, change both IDs
                    int newTargetID;
                    if (IDMapping.TryGetValue(mod.OutputLinks[i].TargetModuleID, out newTargetID))
                    {
                        mod.OutputLinks[i].SetModuleIDIINTERNAL(newID, newTargetID);
                    }
                    else // otherwise delete link
                        mod.OutputLinks.RemoveAt(i);
                }
                mod.ReInitializeLinkedSlots();
            }


            /// III. Reinitialize target generator
            target.Initialize(true);

            return res;
        }

        public static bool CreateTemplate(IList<CGModule> modules, string absFilePath)
        {
            if (!Directory.Exists(Path.GetDirectoryName(absFilePath)))
            {
                Directory.CreateDirectory(Path.GetDirectoryName(absFilePath));

            }
            // Convert absolute to relative path
            absFilePath = absFilePath.Replace(Application.dataPath, "Assets");
            if (modules.Count == 0 || string.IsNullOrEmpty(absFilePath))
                return false;

            CurvyGenerator assetGenerator = CurvyGenerator.Create();
            assetGenerator.name = Path.GetFileNameWithoutExtension(absFilePath);
            CopyModules(modules, assetGenerator, Vector2.zero);
            foreach (CGModule mod in assetGenerator.Modules)
                mod.OnTemplateCreated();
            assetGenerator.ArrangeModules();
            PrefabUtility.SaveAsPrefabAsset(assetGenerator.gameObject, absFilePath);
            GameObject.DestroyImmediate(assetGenerator.gameObject);
            AssetDatabase.Refresh();
            return true;

        }

        public static List<CGModule> LoadTemplate(CurvyGenerator generator, string path, Vector2 canvasPosition)
        {
            CurvyGenerator srcGen = AssetDatabase.LoadAssetAtPath(path, typeof(CurvyGenerator)) as CurvyGenerator;
            if (srcGen)
                return CGEditorUtility.CopyModules(srcGen.Modules, generator, canvasPosition);
            else
                return null;
        }

        public static void SetModulesExpandedState(bool expanded, params CGModule[] modules)
        {
            foreach (CGModule mod in modules)
                mod.Properties.Expanded.target = expanded;
        }

        public static void SceneGUIPlot(Vector3[] vertices, int verticesCount, float size, Color col)
        {
            DTHandles.PushHandlesColor(col);
            for (int index = 0; index < verticesCount; index++)
            {
                Vector3 v = vertices[index];
                Handles.CubeHandleCap(0, v, Quaternion.identity, size * HandleUtility.GetHandleSize(v), EventType.Repaint);
            }

            DTHandles.PopHandlesColor();
        }
        
        [Obsolete("Use the other overload or make a copy of this method")]
        public static void SceneGUIPlot(IList<Vector3> vertices, float size, Color col)
        {
            DTHandles.PushHandlesColor(col);
            for (int index = 0; index < vertices.Count; index++)
            {
                Vector3 v = vertices[index];
                Handles.CubeHandleCap(0, v, Quaternion.identity, size * HandleUtility.GetHandleSize(v), EventType.Repaint);
            }

            DTHandles.PopHandlesColor();
        }

        public static void SceneGUILabels(Vector3[] vertices, int verticesCount, IList<string> labels, Color col, Vector2 offset)
        {
            Dictionary<Vector3, string> labelsByPos = new Dictionary<Vector3, string>();
            int ub = Mathf.Min(verticesCount, labels.Count);

            for (int i = 0; i < ub; i++)
            {
                string val;
                if (labelsByPos.TryGetValue(vertices[i], out val))
                    labelsByPos[vertices[i]] = val + "," + labels[i];
                else
                    labelsByPos.Add(vertices[i], labels[i]);
            }

            GUIStyle style = new GUIStyle(EditorStyles.boldLabel);
            style.normal.textColor = col;
            foreach (KeyValuePair<Vector3, string> kv in labelsByPos)
                Handles.Label(DTHandles.TranslateByPixel(kv.Key, offset), kv.Value, style);

        }
        
        [Obsolete("Use the other overload or make a copy of this method")]
        public static void SceneGUILabels(IList<Vector3> vertices, IList<string> labels, Color col, Vector2 offset)
        {
            Dictionary<Vector3, string> labelsByPos = new Dictionary<Vector3, string>();
            int ub = Mathf.Min(vertices.Count, labels.Count);

            for (int i = 0; i < ub; i++)
            {
                string val;
                if (labelsByPos.TryGetValue(vertices[i], out val))
                    labelsByPos[vertices[i]] = val + "," + labels[i];
                else
                    labelsByPos.Add(vertices[i], labels[i]);
            }

            GUIStyle style = new GUIStyle(EditorStyles.boldLabel);
            style.normal.textColor = col;
            foreach (KeyValuePair<Vector3, string> kv in labelsByPos)
                Handles.Label(DTHandles.TranslateByPixel(kv.Key, offset), kv.Value, style);

        }

        public static void SceneGUIPoly(IEnumerable<Vector3> vertices, Color col)
        {
            DTHandles.PushHandlesColor(col);

            Handles.DrawPolyLine(vertices as Vector3[]);
            DTHandles.PopHandlesColor();
        }


    }


}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CGEditorUtility.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CGGraph.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c4d6374fae71341468322075901f0d3b
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevToolsEditor.Extensions;
using FluffyUnderware.Curvy.Generator;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.DevToolsEditor;
using UnityEditor.AnimatedValues;
using FluffyUnderware.DevTools;
using System.Reflection;
using JetBrains.Annotations;
using UnityEditor.Experimental.SceneManagement;
using UnityEditor.SceneManagement;
using UnityEngine.Assertions;
using UnityEngine.SceneManagement;

namespace FluffyUnderware.CurvyEditor.Generator
{
    public class CGGraph : EditorWindow
    {

        #region ### Static Properties ###

        public static CGModuleEditorBase InPlaceEditTarget;
        public static CGModuleEditorBase InPlaceEditInitiatedBy;

        /// <summary>
        /// Initiates an IPE session or terminates it
        /// </summary>
        public static void SetIPE(IExternalInput target = null, CGModuleEditorBase initiatedBy = null)
        {

            if (InPlaceEditTarget != null)
                InPlaceEditTarget.EndIPE();

            InPlaceEditInitiatedBy = initiatedBy;

            if (target != null)
            {
                InPlaceEditTarget = initiatedBy.Graph.GetModuleEditor((CGModule)target);

                if (SceneView.currentDrawingSceneView)
                    SceneView.currentDrawingSceneView.Focus();

                SyncIPE();
                InPlaceEditTarget.BeginIPE();
            }
        }

        /// <summary>
        /// Sets IPE target's TRS
        /// </summary>
        public static void SyncIPE()
        {
            if (InPlaceEditInitiatedBy != null && InPlaceEditTarget != null)
            {
                Vector3 pos;
                Quaternion rot;
                Vector3 scl;
                InPlaceEditInitiatedBy.OnIPEGetTRS(out pos, out rot, out scl);
                InPlaceEditTarget.OnIPESetTRS(pos, rot, scl);
            }
        }


        #endregion

        public CurvyGenerator Generator;
        public Dictionary<CGModule, CGModuleEditorBase> ModuleEditors = new Dictionary<CGModule, CGModuleEditorBase>();
        public Dictionary<System.Type, Color> TypeColors = new Dictionary<System.Type, Color>();


        List<CGModule> mModules;
        public List<CGModule> Modules
        {
            get
            {
                if (mModules == null)
                    mModules = new List<CGModule>(Generator.Modules.ToArray());
                return mModules;
            }
            set
            {
                mModules = value;
            }
        }

        internal CanvasState Canvas;
        public CanvasSelection Sel;
        internal CanvasUI UI;
        // Statusbar
        public DTStatusbar StatusBar = new DTStatusbar();
        const int mStatusbarHeight = 20;
        int mModuleCount;
        bool mDoRepaint;
        /// <summary>
        /// True if the user clicked on the Reorder button
        /// </summary>
        bool mDoReorder;
        readonly AnimBool mShowDebug = new AnimBool();

        Event EV { get { return Event.current; } }
        public bool LMB { get { return EV.type == EventType.MouseDown && EV.button == 0; } }
        public bool RMB { get { return EV.type == EventType.MouseDown && EV.button == 1; } }




        CGModule editTitleModule;

        void OnSelectionChange()
        {
            CurvyGenerator gen = null;
            List<CGModule> mod = DTSelection.GetAllAs<CGModule>();
            if (mod.Count > 0)
                gen = mod[0].Generator;
            if (gen == null)
                gen = DTSelection.GetAs<CurvyGenerator>();
            if (gen != null && (Generator == null || gen != Generator))
            {
                Initialize(gen);
                Repaint();
            }
            else
                if (mod.Count > 0 && CurvyProject.Instance.CGSynchronizeSelection)
            {
                Sel.SetSelectionTo(mod);
                Canvas.FocusSelection();
                Repaint();
            }

            //OnSelectionChange is called when a selected module is deleted (from the hierarchy for example)
            Sel.SelectedModules.RemoveAll(m => m == null);
        }

        internal static CGGraph Open(CurvyGenerator generator)
        {
            generator.Initialize(true);
            CGGraph win = EditorWindow.GetWindow<CGGraph>("", true);
            win.Initialize(generator);
            win.wantsMouseMove = true;
            win.autoRepaintOnSceneChange = true;
            return win;
        }

        public void Initialize(CurvyGenerator generator)
        {
            destroyEditors();
            if (generator)
            {
                mShowDebug.speed = 3;
                mShowDebug.value = generator.ShowDebug;
                mShowDebug.valueChanged.RemoveAllListeners();
                mShowDebug.valueChanged.AddListener(Repaint);
#if UNITY_5_0 || UNITY_4_6
                title=generator.name;
#else
                titleContent.text = generator.name;
#endif
                Generator = generator;
                Generator.ArrangeModules();
                Sel.Clear();
                Show();
                if (Generator.Modules.Count == 0)
                    StatusBar.SetInfo("Welcome to the Curvy Generator! Right click or drag a CurvySpline on the canvas to get started!", "", 10);
                else
                    StatusBar.SetMessage(Generator.Modules.Count.ToString() + " modules loaded!", "", MessageType.None, 3);
            }
        }

        void OnDestroy()
        {
            destroyEditors();
            Resources.UnloadUnusedAssets();
        }

        void OnDisable()
        {
            SceneView.duringSceneGui -= OnSceneGUI;

            EditorApplication.playModeStateChanged -= OnPlayModeStateChanged;
            EditorApplication.pauseStateChanged -= onPauseStateChanged;
            SetIPE();
            EditorApplication.update -= onUpdate;
            Undo.undoRedoPerformed -= OnUndoRedo;
        }

        void OnEnable()
        {
            Canvas = new CanvasState(this);
            UI = new CanvasUI(this);
            Sel = new CanvasSelection(this);
            loadTypeColors();
            SceneView.duringSceneGui -= OnSceneGUI;
            SceneView.duringSceneGui += OnSceneGUI;

            EditorApplication.playModeStateChanged -= OnPlayModeStateChanged;
            EditorApplication.pauseStateChanged -= onPauseStateChanged;
            EditorApplication.playModeStateChanged += OnPlayModeStateChanged;
            EditorApplication.pauseStateChanged += onPauseStateChanged;
            EditorApplication.update -= onUpdate;
            EditorApplication.update += onUpdate;

            autoRepaintOnSceneChange = true;
            wantsMouseMove = true;
            Undo.undoRedoPerformed -= OnUndoRedo;
            Undo.undoRedoPerformed += OnUndoRedo;
        }

        void OnUndoRedo()
        {
            if (Generator)
            {
                if (mModuleCount != Generator.GetComponentsInChildren<CGModule>().Length)
                {
                    Generator.Initialize(true);
                    Generator.Initialize(false);
                    Initialize(Generator);
                }
            }
        }

        double? previousEditorTimeSinceStartup;

        void onUpdate()
        {
            double timeSinceStartup = EditorApplication.timeSinceStartup;
            double editorDeltaTime = previousEditorTimeSinceStartup.HasValue == false ? 0 : timeSinceStartup - previousEditorTimeSinceStartup.Value;
            previousEditorTimeSinceStartup = timeSinceStartup;

            Canvas.UpdateScrollingAnimation(editorDeltaTime);

            /* THIS CAUSES NullRefException when rendering ReorderableList's:
            if (EditorApplication.isCompiling)
            {
                var eds = new List<CGModuleEditorBase>(ModuleEditors.Values);
                for (int i = eds.Count - 1; i >= 0; i--)
                    Editor.DestroyImmediate(eds[i]);
                ModuleEditors.Clear();
            }*/
        }

        void OnPlayModeStateChanged(PlayModeStateChange state)
        {
            OnStateChanged();
        }

        void onPauseStateChanged(PauseState state)
        {
            OnStateChanged();
        }

        void OnStateChanged()
        {
            destroyEditors();
            if (!Generator && Selection.activeGameObject)
            {
                Initialize(Selection.activeGameObject.GetComponent<CurvyGenerator>());
                Repaint();
            }
        }

        void OnSceneGUI(SceneView sceneView)
        {
            if (!Generator)
                return;
            for (int i = 0; i < Modules.Count; i++)
            {
                CGModule mod = Modules[i];
                if (mod != null && mod.IsInitialized && mod.IsConfigured && mod.Active)
                {
                    CGModuleEditorBase ed = GetModuleEditor(mod);
                    ed.OnModuleSceneGUI();
                    if (Generator.ShowDebug && ed.ShowDebugVisuals)
                        ed.OnModuleSceneDebugGUI();
                }
            }
        }

        Vector2 deltaAccu;

        private List<object> selectedObjectsCache1 = new List<object>();
        private List<object> selectedObjectsCache2 = new List<object>();

        void OnGUI()
        {

            mDoRepaint = false;
            if (!Generator)
                return;
            if (!Generator.IsInitialized)
            {
                Generator.Initialize();
            }


            Modules = new List<CGModule>(Generator.Modules.ToArray());
            mModuleCount = Modules.Count; // store count to be checked in window GUI

            if (!Application.isPlaying && !Generator.IsInitialized)
                Repaint();

            DrawToolbar();
            Canvas.SetClientRect(0, GUILayoutUtility.GetLastRect().yMax, 0, mStatusbarHeight);

            // Scrollable Canvas
            if (Canvas.IsScrollValueAnimating)
                GUI.BeginScrollView(Canvas.ClientRect, Canvas.ScrollValue, Canvas.CanvasRect);
            else
                Canvas.ScrollValue = GUI.BeginScrollView(Canvas.ClientRect, Canvas.ScrollValue, Canvas.CanvasRect);


            // render background
            DTGUI.PushColor(Color.black.SkinAwareColor(true));
            GUI.Box(Canvas.ViewPort, "");
            DTGUI.PopColor();

#if CURVY_DEBUG

            GUILayout.BeginArea(Canvas.ViewPort);
            GUILayout.Label("Canvas ClientRect: " + Canvas.ClientRect);
            GUILayout.Label("Canvas Rect: " + Canvas.CanvasRect);
            GUILayout.Label("Canvas Scroll: " + $" {Canvas.ScrollValue}/{Canvas.ScrollTarget} Speed {Canvas.ScrollSpeed}");
            GUILayout.Label("Canvas ViewPort: " + Canvas.ViewPort);

            GUILayout.Label("Mouse: " + EV.mousePosition);
            //GUILayout.Label("IsWindowDrag: " + Canvas.IsWindowDrag);
            GUILayout.Label("IsSelectionDrag: " + Canvas.IsSelectionRectDrag);
            GUILayout.Label("IsLinkDrag: " + Canvas.IsLinkDrag);
            GUILayout.Label("IsCanvasDrag: " + Canvas.IsCanvasDrag);
            GUILayout.Label("IsModuleDrag: " + Canvas.IsModuleDrag);
            GUILayout.Label("MouseOverModule: " + Canvas.MouseOverModule);
            GUILayout.Label("MouseOverCanvas: " + Canvas.IsMouseOverCanvas);
            GUILayout.Label("SelectedLink: " + Sel.SelectedLink);
            GUILayout.Label("Selected Module: " + Sel.SelectedModule);
            GUILayout.EndArea();
#endif

            if (CurvyProject.Instance.CGShowHelp)
            {
                Rect r = new Rect(Canvas.ViewPort);
                r.x = r.width - 230;
                r.y = 10;
                r.width = 220;
                r.height = 240;

                GUILayout.BeginArea(r, GUI.skin.box);
                GUI.Label(new Rect(10, -2, r.width, r.height),
@"<b>General:</b>

  <b>RMB</b>               Contextual menu
  <b>MMB/Space</b> Drag canvas
  <b>Alt</b>                   Hold to snap to grid
  <b>Del</b>                  Delete selection


<b>Add Modules:</b>

  - <b>Drag & Drop</b> objects (mesh,
      spline, prefab,...) to create
      associated input module
  - Through the <b>contextual menu</b>
  - Hold <b>Ctrl</b> while releasing a
      link to create & connect", DTStyles.HtmlLabel);

                GUILayout.EndArea();
            }

            DrawLinks();

            // Init and early catch some events
            Canvas.BeginGUI();

            DrawModules();

            Canvas.EndGUI();

            // Draw Selection

            DTGUI.PushBackgroundColor(Color.white);//.SkinAwareColor());
            foreach (CGModule mod in Sel.SelectedModules)
            {
                Rect selectionHighlightRectangle = mod.Properties.Dimensions.ScaleBy(2);
#pragma warning disable 162
                {
                    selectionHighlightRectangle.x -= 1;
                    selectionHighlightRectangle.y -= 1;
                    selectionHighlightRectangle.width += 2;
                    selectionHighlightRectangle.height += 1;
                }
#pragma warning restore 162
                GUI.Box(selectionHighlightRectangle, "", CurvyStyles.RoundRectangle);
            }
            DTGUI.PopBackgroundColor();

            // Keep dragged Module in view and handle multiselection move
            if (Canvas.IsModuleDrag && !DTGUI.IsLayout)
            {
                CGModule selectedModule = Canvas.Sel.SelectedModule;

#if CURVY_SANITY_CHECKS_PRIVATE
                if (selectedModule == null)
                    Debug.LogError($"Custom assertion is false: selectedModule != null");
#endif
                Vector2 mouseDelta = EV.delta;
                deltaAccu += EV.delta;
                if (EV.alt)
                {
                    mouseDelta = deltaAccu.Snap(CurvyProject.Instance.CGGraphSnapping);
                    if (mouseDelta == deltaAccu)
                        mouseDelta = Vector2.zero;
                }
                if (Sel.SelectedModules.Count > 1)
                {
                    foreach (CGModule mod in Sel.SelectedModules)
                    {
                        mod.Properties.Dimensions.position += mouseDelta;
                    }
                    if (!EV.alt || mouseDelta != Vector2.zero)
                        deltaAccu = Vector2.zero;
                }
                CGModule focusedModule;
                if (Canvas.MouseOverModule && Sel.SelectedModules.Contains(Canvas.MouseOverModule))
                    focusedModule = Canvas.MouseOverModule;
                else
                    focusedModule = selectedModule;

                if (focusedModule)
                {
                    Vector2 scrollDelta = Canvas.GetFocusDelta(focusedModule);
                    Canvas.SetScrollTarget(Canvas.ScrollValue + scrollDelta, Mathf.Max(60f, scrollDelta.magnitude * 20f));
                }
            }

            // Linking in progress?
            if (Canvas.IsLinkDrag)
            {
                Texture2D linkstyle = (Canvas.LinkDragFrom.OnRequestModule != null) ? CurvyStyles.RequestLineTexture : CurvyStyles.LineTexture;
                Vector2 startPosition = Canvas.LinkDragFrom.Origin;
                Vector2 endPosition = EV.mousePosition;

                CGGraph.GetLinkBezierTangents(
                    startPosition,
                    endPosition,
                    out Vector2 startTangent,
                    out Vector2 endTangent);

                Handles.DrawBezier(startPosition, endPosition, startTangent, endTangent, Color.white, linkstyle, 2);
            }

            GUI.EndScrollView(true);

            // Selection
            if (Canvas.IsSelectionRectDrag)
                DrawSelectionRect();

            // Statusbar
            DrawStatusbar();

            // IPE
            SyncIPE();

            bool selectionHasChanged;
            {
                Canvas.Sel.FillWithSelectedObjects(selectedObjectsCache1);
                selectionHasChanged = selectedObjectsCache1.SequenceEqual(selectedObjectsCache2);
                //swap both lists
                (selectedObjectsCache2, selectedObjectsCache1) = (selectedObjectsCache1, selectedObjectsCache2);
            }

            mDoRepaint = mDoRepaint || Canvas.IsCanvasDrag || Canvas.IsLinkDrag || Canvas.IsSelectionRectDrag || EV.type == EventType.MouseMove || mShowDebug.isAnimating || Canvas.IsScrollValueAnimating || selectionHasChanged;


            // Disable Title edit mode?
            if (editTitleModule != null)
            {
                if ((EV.isKey && (EV.keyCode == KeyCode.Escape || EV.keyCode == KeyCode.Return)) ||
                    Sel.SelectedModule != editTitleModule
                    )
                {
                    editTitleModule = null;
                    //GUI.FocusControl("");
                    mDoRepaint = true;
                }
            }

            if (mDoReorder)
                Generator.ReorderModules();
            if (mDoRepaint)
                Repaint();
        }



        void DrawModules()
        {
            //TODO at some point this method should be reworked to distinguish between what should be called when Event.current.type == EventType.Layout and what should be called otherwise
            const int refreshHighlightSize = 9;

            //When modules are culled, they are not rendered (duh) and thus their height is not updated. This is ok as long as the height is constant. When there is some module expanding/collapsing, the height should change. In those cases, we disable the culling (for all modules for implementation simplicity sake, could be optimized) so the height is updated, so that the modules reordering code can work based on the actual height, and not the preculling one, which was leading to bad reordering results.
            bool animationIsHappening = mShowDebug.isAnimating || Modules.Exists(m => m.Properties.Expanded.isAnimating);

            CGModule curSel = Sel.SelectedModule;
            // Begin drawing Module Windows
            BeginWindows();
            for (int i = 0; i < Modules.Count; i++)
            {
                CGModule mod = Modules[i];
                if (mod != null)
                {
                    mod.Properties.Dimensions.width = Mathf.Max(mod.Properties.Dimensions.width, mod.Properties.MinWidth);

                    //This is based on the condition at which mod.Properties.Expanded.target is modified in OnModuleWindowCB
                    bool autoModuleDetailsWillMakeModuleAnimate = DTGUI.IsLayout && CurvyProject.Instance.CGAutoModuleDetails && mod.Properties.Expanded.target != (mod == curSel);

                    // Render title
                    string title = mod.ModuleName;
                    if (!mod.IsConfigured)
                        title = string.Format("<color={0}>{1}</color>", new Color(1, 0.2f, 0.2f).SkinAwareColor().ToHtml(), mod.ModuleName);
                    //"<color=#ff3333>" + mod.ModuleName + "</color>"; 
                    else if (mod is IOnRequestProcessing)
                        title = string.Format("<color={0}>{1}</color>", CurvyStyles.IOnRequestProcessingTitleColor.SkinAwareColor().ToHtml(), mod.ModuleName);

#if CURVY_DEBUG
                    title = mod.UniqueID + ":" + title;
#endif

                    // the actual window
                    Vector2 oldPos = mod.Properties.Dimensions.position;

                    bool shouldDraw;
                    {
                        //Ok, shit gets complicated here. The idea was to not draw modules that are out of the screen, but for reasons I don't fully grasp, the height can be 0, which fucks up the boundaries test.
                        //The height is set to 0 in the line just before calling GUILayout.Window, with the apparent goal for that method to update the height, but this update does not happen all the time. It happens when the OnGUI method is called following an Event of type Repaint, but does not happen when is called following an Event of type Layout.
                        //And if you remove the code setting height to 0, the height of the module is not updated correctly
                        if (mod.Properties.Dimensions.height == 0 || animationIsHappening || autoModuleDetailsWillMakeModuleAnimate)
                            shouldDraw = true;
                        else
                        {
                            Rect testedBoundaries = mod.Properties.Dimensions.ScaleBy(refreshHighlightSize);
                            shouldDraw = Canvas.ViewPort.Contains(testedBoundaries.min) || Canvas.ViewPort.Overlaps(testedBoundaries);
                        }
                    }

                    Rect newWindowRect;
                    if (shouldDraw)
                    {
                        mod.Properties.Dimensions.height = 0; // will be set by GUILayout.Window
                        newWindowRect = GUILayout.Window(i, mod.Properties.Dimensions, OnModuleWindowCB, title, CurvyStyles.ModuleWindow);
                    }
                    else
                    {
                        UpdateLinks(mod);
                        newWindowRect = mod.Properties.Dimensions;
                    }

                    if (!Application.isPlaying && oldPos != newWindowRect.position)
                        EditorSceneManager.MarkAllScenesDirty();

                    if (Sel.SelectedModules.Count > 1) // Multi-Module move in OnGUI()
                    {
                        mod.Properties.Dimensions = newWindowRect.SetPosition(oldPos);
                    }
                    else
                    {
                        if (EV.alt && Canvas.IsModuleDrag && Sel.SelectedModule == mod)
                            newWindowRect.position = newWindowRect.position.Snap(CurvyProject.Instance.CGGraphSnapping);
                        mod.Properties.Dimensions = newWindowRect;
                    }



                    // Debugging
                    double lastUpdateDelta = (System.DateTime.Now - mod.DEBUG_LastUpdateTime).TotalMilliseconds;
                    if (lastUpdateDelta < 1500)
                    {
                        float alpha = Mathf.SmoothStep(1, 0, (float)lastUpdateDelta / 1500f);
                        DTGUI.PushBackgroundColor(new Color(0, 1, 0, alpha));
                        GUI.Box(mod.Properties.Dimensions.ScaleBy(refreshHighlightSize), "", CurvyStyles.GlowBox);
                        DTGUI.PopBackgroundColor();
                        Repaint();
                    }

                }
            }
            EndWindows();

            //update canvas rect to include any possible module's rectangle change (position and size)
            if (EV.type != EventType.Layout)
                //The following line is ignored in EventType.Layout, because the call to GUILayout.Window in that event, call on which we rely on to give us the correct module's rectangle, does not update the height. Maybe because that method is not supposed to be called in event layout, and maybe supposed to be called only in event repaint, but I am not going to do such drastic changes to this code now. This is a fight for another time
                Canvas.ComputeCanvasRectangle(Modules);

            //focus selection
            if (Sel.SelectedModule != curSel)
                Canvas.FocusSelection();
        }

        void DrawSelectionRect()
        {
            Vector2 p = Canvas.SelectionRectStart;
            Vector2 p2 = Canvas.ViewPortMousePosition;
            Vector3[] verts = new Vector3[4]
            {
                new Vector3(p.x,p.y,0),
                new Vector3(p2.x,p.y,0),
                new Vector3(p2.x,p2.y,0),
                new Vector3(p.x,p2.y,0)
            };
            Handles.DrawSolidRectangleWithOutline(verts, new Color(.5f, .5f, .5f, 0.1f), Color.white);
        }

        void OnModuleWindowCB(int id)
        {
            // something happened in the meantime?
            if (id >= Modules.Count || mModuleCount != Modules.Count)
                return;
            CGModule mod = Modules[id];

            //if (EV.type != EventType.Repaint && EV.type != EventType.Layout)
            //    Debug.Log("OnModuleWindowCB()  " + EV.type + "  " + Canvas.IsMouseOverCanvas);
            if (EV.type == EventType.MouseDown && EV.button != 2 && !Sel.SelectedModules.Contains(mod)
                /*&& Canvas.IsCanvasDrag == false && Canvas.IsLinkDrag == false*/)
                Sel.SetSelectionTo(Modules[id]);

            Rect winRect = mod.Properties.Dimensions;

            // Draw Title Buttons
            // Enabled
            EditorGUI.BeginChangeCheck();
            mod.Active = GUI.Toggle(new Rect(2, 2, 16, 16), mod.Active, "");
            if (EditorGUI.EndChangeCheck())
                EditorUtility.SetDirty(Generator);

            //Edit Title & Color
            if (editTitleModule == mod)
            {
                GUI.SetNextControlName("editTitle" + id.ToString());
                mod.ModuleName = GUI.TextField(new Rect(30, 5, winRect.width - 120, 16), mod.ModuleName);
                mod.Properties.BackgroundColor = EditorGUI.ColorField(new Rect(winRect.width - 70, 5, 32, 16), mod.Properties.BackgroundColor);
            }


            if (GUI.Button(new Rect(winRect.width - 32, 6, 16, 16), new GUIContent(CurvyStyles.EditTexture, "Rename"), CurvyStyles.BorderlessButton))
            {
                editTitleModule = mod;
                //is this needed?
                Sel.SetSelectionTo(mod);
                EditorGUI.FocusTextInControl("editTitle" + id.ToString());
            }

            // Help
            if (GUI.Button(new Rect(winRect.width - 16, 6, 16, 16), new GUIContent(CurvyStyles.HelpTexture, "Help"), CurvyStyles.BorderlessButton))
            {
                string url = DTUtility.GetHelpUrl(mod);
                if (!string.IsNullOrEmpty(url))
                    Application.OpenURL(url);
            }


            // Check errors
            if (mod.CircularReferenceError)
                EditorGUILayout.HelpBox("Circular Reference", MessageType.Error);
            // Draw Slots
            DTGUI.PushColor(mod.Properties.BackgroundColor.SkinAwareColor(true));
            GUILayout.Space(1);
            EditorGUILayout.BeginVertical(CurvyStyles.ModuleWindowSlotBackground);
            DTGUI.PopColor();
            UpdateLinks(mod);
            OnModuleWindowSlotGUI(mod);
            EditorGUILayout.EndVertical();

            CGModuleEditorBase ed = GetModuleEditor(mod);

            if (ed && ed.target != null)
            {

                if (EditorGUILayout.BeginFadeGroup(mShowDebug.faded))
                    ed.OnInspectorDebugGUIINTERNAL(Repaint);
                EditorGUILayout.EndFadeGroup();

                // Draw Module Options

                //I don't see the need for this, but I am not familiar enough with CG editor's code to feel confident to remove it
                mod.Properties.Expanded.valueChanged.RemoveListener(Repaint);
                mod.Properties.Expanded.valueChanged.AddListener(Repaint);

                if (!CurvyProject.Instance.CGAutoModuleDetails)
                    mod.Properties.Expanded.target = GUILayout.Toggle(mod.Properties.Expanded.target, new GUIContent(mod.Properties.Expanded.target ? CurvyStyles.CollapseTexture : CurvyStyles.ExpandTexture, "Show Details"), CurvyStyles.ShowDetailsButton);

                // === Module Details ===
                // Handle Auto-Folding
                if (DTGUI.IsLayout && CurvyProject.Instance.CGAutoModuleDetails)
                    mod.Properties.Expanded.target = (mod == Sel.SelectedModule);

                if (EditorGUILayout.BeginFadeGroup(mod.Properties.Expanded.faded))
                {
                    EditorGUIUtility.labelWidth = (mod.Properties.LabelWidth);
                    // Draw Inspectors using Modules Background color
                    DTGUI.PushColor(ed.Target.Properties.BackgroundColor.SkinAwareColor(true));
                    EditorGUILayout.BeginVertical(CurvyStyles.ModuleWindowBackground);
                    DTGUI.PopColor();

                    ed.RenderGUI(true);
                    if (ed.NeedRepaint)
                        mDoRepaint = true;
                    GUILayout.Space(2);
                    EditorGUILayout.EndVertical();
                }
                EditorGUILayout.EndFadeGroup();


            }

            // Make it dragable
            GUI.DragWindow(new Rect(0, 0, winRect.width, CurvyStyles.ModuleWindowTitleHeight));

        }

        void OnModuleWindowSlotGUI(CGModule module)
        {

            int i = 0;

            while (module.Input.Count > i || module.Output.Count > i)
            {
                GUILayout.BeginHorizontal();

                if (module.Input.Count > i)
                {
                    CGModuleInputSlot slot = module.Input[i];
                    Color linkDataTypeColor = getTypeColor(slot.Info.DataTypes);
                    if (Canvas.IsLinkDrag && !slot.CanLinkTo(Canvas.LinkDragFrom))
                        linkDataTypeColor = new Color(0.2f, 0.2f, 0.2f).SkinAwareColor(true);
                    DTGUI.PushColor(linkDataTypeColor);
                    GUILayout.Box("<", CurvyStyles.Slot);
                    DTGUI.PopColor();
                    string postfix = "";
                    if (slot.Info.Array && slot.Info.ArrayType == SlotInfo.SlotArrayType.Normal)
                        postfix = (slot.LastDataCountINTERNAL > 0) ? "[" + slot.LastDataCountINTERNAL.ToString() + "]" : "[]";
                    GUILayout.Label(new GUIContent(ObjectNames.NicifyVariableName(slot.Info.DisplayName) + postfix, slot.Info.Tooltip), CurvyStyles.GetSlotLabelStyle(slot));

                    // LinkDrag?
                    if (Canvas.IsLinkDrag)
                    {
                        // If ending drag over dropzone, create static link
                        if (EV.type == EventType.MouseUp && slot.DropZone.Contains(EV.mousePosition) && slot.CanLinkTo(Canvas.LinkDragFrom))
                            finishLink(slot);
                    }
                    // Clicking on Dropzone to pick existing link
                    else if (LMB && slot.Count == 1 && slot.DropZone.Contains(EV.mousePosition))
                    {
                        CGModuleOutputSlot linkedOutSlot = slot.SourceSlot();
                        linkedOutSlot.UnlinkFrom(slot);
                        EditorUtility.SetDirty(slot.Module);
                        startLinkDrag(linkedOutSlot);
                        GUIUtility.ExitGUI();
                    }
                }

                if (module.Output.Count > i)
                {
                    CGModuleOutputSlot slot = module.Output[i];
                    string postfix = "";
                    if (slot.Info.Array && slot.Info.ArrayType == SlotInfo.SlotArrayType.Normal)
                        postfix = (slot.Data != null && slot.Data.Length > 1) ? "[" + slot.Data.Length.ToString() + "]" : "";

                    GUILayout.Label(new GUIContent(ObjectNames.NicifyVariableName(slot.Info.DisplayName) + postfix, slot.Info.Tooltip), CurvyStyles.GetSlotLabelStyle(slot));
                    DTGUI.PushColor(getTypeColor(slot.Info.DataTypes));
                    GUILayout.Box(">", CurvyStyles.Slot);
                    DTGUI.PopColor();
                    // Debug
                    /*
                    if (Generator.ShowDebug)
                    {
                        GUI.enabled = slot.Data != null && slot.Data.Length>0;
                        if (GUILayout.Button(new GUIContent(CurvyStyles.DebugTexture, "Show Dump"), CurvyStyles.SmallButton, GUILayout.Width(16), GUILayout.Height(16)))
                            DTDebugWindow.Open(slot.Data[0].GetType().Name + ":", slot.Data[0].ToDumpString());
                        GUI.enabled = true;
                    }
                    */
                    // Start Linking?
                    if (LMB && !Canvas.IsSelectionRectDrag && slot.DropZone.Contains(EV.mousePosition))
                    {
                        startLinkDrag(slot);
                    }

                }
                GUILayout.EndHorizontal();
                i++;
            }


        }

        void DrawToolbar()
        {
            GUILayout.BeginHorizontal(CurvyStyles.Toolbar);
            // Clear
            if (GUILayout.Button(new GUIContent(CurvyStyles.DeleteTexture, "Clear modules"), EditorStyles.miniButton) && EditorUtility.DisplayDialog("Clear", "Clear graph?", "Yes", "No"))
            {
                Sel.Clear();
                Generator.Clear();
                Repaint();
                GUIUtility.ExitGUI();
            }

            GUILayout.Space(10);

            // clear outputs
            if (GUILayout.Button(new GUIContent(CurvyStyles.DeleteBTexture, "Clear output"), EditorStyles.miniButton))
            {
                bool associatedPrefabWasModified;
                if (Generator.DeleteAllOutputManagedResources(out associatedPrefabWasModified) && Application.isPlaying == false)
                    if (PrefabStageUtility.GetPrefabStage(Generator.gameObject) == null) //if not editing the prefab in prefab mode
                        EditorSceneManager.MarkSceneDirty(SceneManager.GetActiveScene());

                if (associatedPrefabWasModified)
                    EditorUtility.DisplayDialog("Prefab asset modified", "The prefab asset associated with the prefab instance containing this Curvy Generator was modified.\n\nThis was done in order to allow the operation you initiated (Clear Output). You might need to apply the operation again.", "Ok");
            }

            // save resources to scene
            if (GUILayout.Button(new GUIContent(CurvyStyles.SaveResourcesTexture, "Save output to scene"), EditorStyles.miniButton))
            {
                Generator.SaveAllOutputManagedResources();
            }

            GUILayout.Space(10);

            // Refresh
            if (GUILayout.Button(new GUIContent(CurvyStyles.RefreshTexture, "Refresh"), EditorStyles.miniButton, GUILayout.ExpandWidth(false)) && !DTGUI.IsLayout)
            {
                Modules = null;
                Generator.Refresh(true);
                Repaint();
                GUIUtility.ExitGUI();
            }

            // reorder
            mDoReorder = GUILayout.Button(new GUIContent(CurvyStyles.ReorderTexture, "Reorder modules"), EditorStyles.miniButton, GUILayout.ExpandWidth(false)) && !DTGUI.IsLayout;

            // Debug
            EditorGUI.BeginChangeCheck();
            mShowDebug.target = GUILayout.Toggle(mShowDebug.target, new GUIContent(CurvyStyles.DebugTexture, "Debug"), EditorStyles.miniButton);
            if (EditorGUI.EndChangeCheck())
            {
                Generator.ShowDebug = mShowDebug.target;
                SceneView.RepaintAll();
            }

            GUILayout.Space(10);


            // Expanded/Collapsed actions
            CurvyProject.Instance.CGAutoModuleDetails = GUILayout.Toggle(CurvyProject.Instance.CGAutoModuleDetails, new GUIContent(CurvyStyles.CGAutoFoldTexture, "Auto-Expand selected module"), EditorStyles.miniButton);
            if (GUILayout.Button(new GUIContent(CurvyStyles.ExpandTexture, "Expand all"), EditorStyles.miniButton))
                CGEditorUtility.SetModulesExpandedState(true, Generator.Modules.ToArray());
            if (GUILayout.Button(new GUIContent(CurvyStyles.CollapseTexture, "Collapse all"), EditorStyles.miniButton))
                CGEditorUtility.SetModulesExpandedState(false, Generator.Modules.ToArray());
            // Sync Selection
            CurvyProject.Instance.CGSynchronizeSelection = GUILayout.Toggle(CurvyProject.Instance.CGSynchronizeSelection, new GUIContent(CurvyStyles.SynchronizeTexture, "Synchronize Selection"), EditorStyles.miniButton);

            // Save Template
            GUILayout.Space(10);
            GUI.enabled = Sel.SelectedModule != null;
            if (GUILayout.Button(new GUIContent(CurvyStyles.AddTemplateTexture, "Save Selection as Template"), EditorStyles.miniButton))
                TemplateWizard.Open(Sel.SelectedModules, UI);

            GUI.enabled = true;
            GUILayout.FlexibleSpace();
            GUILayout.Label(new GUIContent(CurvyStyles.TexGridSnap, "Snap Grid Size\n(Hold Alt while dragging to snap)"));
            CurvyProject.Instance.CGGraphSnapping = (int)GUILayout.HorizontalSlider(CurvyProject.Instance.CGGraphSnapping, 1, 20, GUILayout.Width(60));
            GUILayout.Label(CurvyProject.Instance.CGGraphSnapping.ToString(), GUILayout.Width(20));
            CurvyProject.Instance.CGShowHelp = GUILayout.Toggle(CurvyProject.Instance.CGShowHelp, new GUIContent(CurvyStyles.HelpTexture, "Show Help"), EditorStyles.miniButton, GUILayout.Height(20));
            GUILayout.EndHorizontal();
        }

        void DrawStatusbar()
        {
            Rect r = new Rect(-1, position.height - mStatusbarHeight, 201, mStatusbarHeight - 1);
            // Performance
            EditorGUI.HelpBox(r, string.Format("Exec. Time (Avg): {0:0.###} ms", Generator.DEBUG_ExecutionTime.AverageMS), MessageType.None);
            // Message
            if (StatusBar.Render(new Rect(200, position.height - mStatusbarHeight, position.width, mStatusbarHeight - 1)))
                mDoRepaint = true;
        }

        void loadTypeColors()
        {
            TypeColors.Clear();

            IEnumerable<Type> loadedTypes = TypeCache.GetTypesDerivedFrom(typeof(CGData));
            foreach (Type t in loadedTypes)
            {
                object[] ai = t.GetCustomAttributes(typeof(CGDataInfoAttribute), true);
                if (ai.Length > 0)
                {
                    TypeColors.Add(t, ((CGDataInfoAttribute)ai[0]).Color);
                }
            }
        }

        public void destroyEditors()
        {
            List<CGModuleEditorBase> ed = new List<CGModuleEditorBase>(ModuleEditors.Values);
            for (int i = ed.Count - 1; i >= 0; i--)
                DestroyImmediate(ed[i]);
            ModuleEditors.Clear();
            InPlaceEditTarget = null;
            InPlaceEditInitiatedBy = null;
        }

        internal CGModuleEditorBase GetModuleEditor([NotNull] CGModule module)
        {
            CGModuleEditorBase ed;
            if (!ModuleEditors.TryGetValue(module, out ed))
            {
                ed = Editor.CreateEditor(module) as CGModuleEditorBase;
                if (ed)
                {
                    ed.Graph = this;
                    ModuleEditors.Add(module, ed);
                }
                else
                    DTLog.LogError("[Curvy] Curvy Generator: Missing editor script for module '" + module.GetType().Name + "' !", module);
            }

            return ed;
        }

        Color getTypeColor(System.Type[] type)
        {
            Color c = Color.white; ;
            if (type.Length == 1)
                TypeColors.TryGetValue(type[0], out c);

            return c;//.SkinAwareColor();
        }

        #region Links

        public const int LinkSelectionDistance = 6;

        /// <summary>
        /// Given a link's start and end positions, you get the Bezier tangents of the link at those positions
        /// </summary>
        public static void GetLinkBezierTangents(Vector2 startPosition, Vector2 endPosition, out Vector2 startTangent, out Vector2 endTangent)
        {
            float deltaX = Mathf.Abs(endPosition.x - startPosition.x);
            float deltaY = Mathf.Abs(endPosition.y - startPosition.y);

            float xInfluence = deltaX / 2;
            //when there is a big delta in y, a small delta in x, and multiple links going to the same module, the links are too close to distinguish. I "bump" the links (by increasing the tangent) in those cases so that they are distinguishable near the modules.
            float yInfluence = 100f * Mathf.Min(1000f, deltaY) / 1000f;

            Vector2 tangent = new Vector2(xInfluence + yInfluence, 0);
            startTangent = startPosition + tangent;
            endTangent = endPosition - tangent;
        }

        void DrawLinks()
        {
            Rect r = new Rect();

            foreach (CGModule mod in Modules)
            {
                //Debug.Log(mod.name + ":" + mod.Properties.Dimensions.yMin+" to "+mod.Properties.Dimensions.yMax);
                if (mod.OutputByName != null)
                {
                    foreach (CGModuleOutputSlot slotOut in mod.OutputByName.Values)
                    {
                        Vector2 startPosition = slotOut.Origin;
                        foreach (CGModuleSlot slotIn in slotOut.LinkedSlots)
                        {
                            Vector2 endPosition = slotIn.Origin;

                            r.Set(startPosition.x, startPosition.y, endPosition.x - startPosition.x, endPosition.y - startPosition.y);
                            // draw only visible lines
                            if (Canvas.ViewPort.Overlaps(r, true))
                            {
                                GetLinkBezierTangents(
                                        startPosition,
                                        endPosition,
                                        out Vector2 startTangent,
                                        out Vector2 endTangent);

                                if (EV.type == EventType.Repaint)
                                {
                                    float w = (Sel.SelectedLink != null && Sel.SelectedLink.IsBetween(slotOut, slotIn)) ? 7 : 2;

                                    Color slotColor = getTypeColor(slotOut.Info.DataTypes);


                                    if (!((CGModuleInputSlot)slotIn).InputInfo.RequestDataOnly && slotIn.OnRequestModule == null)
                                    {
                                        Handles.DrawBezier(startPosition,
                                            endPosition,
                                            startTangent,
                                            endTangent,
                                            slotColor,
                                            CurvyStyles.LineTexture,
                                            w);
                                    }
                                    else
                                    {
                                        //draw two parallel lines
                                        Vector2 yOff = new Vector3(0, 2);
                                        Handles.DrawBezier(startPosition + yOff,
                                            endPosition + yOff,
                                            startTangent + yOff,
                                            endTangent + yOff,
                                            slotColor,
                                            CurvyStyles.LineTexture,
                                            w);

                                        yOff = new Vector3(0, -2);
                                        Handles.DrawBezier(startPosition + yOff,
                                            endPosition + yOff,
                                            startTangent + yOff,
                                            endTangent + yOff,
                                            slotColor,
                                            CurvyStyles.LineTexture,
                                            w);
                                    }
                                }

                                if (LMB && HandleUtility.DistancePointBezier(EV.mousePosition, startPosition, endPosition, startTangent, endTangent) <= LinkSelectionDistance)
                                {
                                    Sel.SetSelectionTo(slotOut.Module.GetOutputLink((CGModuleOutputSlot)slotOut, (CGModuleInputSlot)slotIn));
                                }
                            }
                        }
                    }
                }
            }

        }

        void UpdateLinks(CGModule module)
        {

            int i = 0;
            float slotDropZoneHeight = 18;

            while (module.Input.Count > i || module.Output.Count > i)
            {
                float y = CurvyStyles.ModuleWindowTitleHeight + slotDropZoneHeight * i;

                if (module.Input.Count > i)
                {
                    CGModuleInputSlot slot = module.Input[i];
                    slot.DropZone = new Rect(0, y, module.Properties.Dimensions.width / 2, slotDropZoneHeight);
                    slot.Origin = new Vector2(module.Properties.Dimensions.xMin, module.Properties.Dimensions.yMin + y + slotDropZoneHeight / 2);
                }

                if (module.Output.Count > i)
                {
                    CGModuleOutputSlot slot = module.Output[i];
                    slot.DropZone = new Rect(module.Properties.Dimensions.width / 2, y, module.Properties.Dimensions.width / 2, slotDropZoneHeight);
                    slot.Origin = new Vector2(module.Properties.Dimensions.xMax, module.Properties.Dimensions.yMin + y + slotDropZoneHeight / 2);
                }
                i++;
            }
        }

        #endregion

        #region ### Actions ###

        void startLinkDrag(CGModuleSlot slot)
        {
            Sel.Clear();
            Canvas.LinkDragFrom = (CGModuleOutputSlot)slot;
            StatusBar.SetMessage("Hold <b><Ctrl></b> to quickly create & connect a module");
        }

        void finishLink(CGModuleInputSlot target)
        {
            StatusBar.Clear();
            Canvas.LinkDragFrom.LinkTo(target);
            EditorUtility.SetDirty(target.Module);
            if (!DTGUI.IsLayout)
                GUIUtility.ExitGUI();
        }
        #endregion



    }


}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CGGraph.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CGModuleEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 2952921a87141e144bafce916291be32
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevToolsEditor.Extensions;
using FluffyUnderware.Curvy;
using System.Collections.Generic;
using System;
using FluffyUnderware.DevToolsEditor;
using UnityEditor.AnimatedValues;
using UnityEngine.Events;
using FluffyUnderware.DevTools;
using Object = UnityEngine.Object;

namespace FluffyUnderware.CurvyEditor.Generator
{
    public class CGModuleEditorBase : CurvyEditorBase<CGModule>
    {
        public CGGraph Graph { get; internal set; }

        public AnimBool ShowDebugStats { get; set; }
        public bool ShowDebugVisuals { get; set; }
        protected bool HasDebugVisuals;

        protected override void OnEnable()
        {
            base.OnEnable();
            ShowDebugStats = new AnimBool(true);
            ShowDebugStats.speed = 3;
            HasDebugVisuals = false;
            EndIPE();
        }

        /// <summary>
        /// Called by the graph when an IPE session starts
        /// </summary>
        internal virtual void BeginIPE()
        {
        }

        /// <summary>
        /// Called by the graph when an IPE session ends
        /// </summary>
        internal virtual void EndIPE()
        {
        }

        /// <summary>
        /// Called for the IPE Target when the module should TRS it's IPE editor to the given values
        /// </summary>
        internal virtual void OnIPESetTRS(Vector3 position, Quaternion rotation, Vector3 scale) { }

        /// <summary>
        /// Called for the IPE initiator to get the TRS values for the target
        /// </summary>
        internal virtual void OnIPEGetTRS(out Vector3 position, out Quaternion rotation, out Vector3 scale)
        {
            position = Vector3.zero;
            rotation = Quaternion.identity;
            scale = Vector3.one;
        }


        /// <summary>
        /// Scene View GUI
        /// </summary>
        /// <remarks>Called only if the module is initialized and configured</remarks>
        public virtual void OnModuleSceneGUI()
        {
        }

        /// <summary>
        /// Scene View Debug GUI
        /// </summary>
        /// <remarks>Called only when Show Debug Visuals is activated</remarks>
        public virtual void OnModuleSceneDebugGUI()
        {
        }
        /// <summary>
        /// Inspector Debug GUI
        /// </summary>
        /// <remarks>Called only when Show Debug Values is activated </remarks>
        public virtual void OnModuleDebugGUI()
        {
        }

        protected override void OnCustomInspectorGUI()
        {
            base.OnCustomInspectorGUI();
            for (int m = 0; m < Target.UIMessages.Count; m++)
                EditorGUILayout.HelpBox(Target.UIMessages[m], MessageType.Warning);
        }

        protected override void OnReadNodes()
        {
            base.OnReadNodes();
        }

        public override void OnInspectorGUI()
        {
            //With the new prefab system (Unity 2018.3) prefabs don't show inspector, and when opening prefab editor, its objects are of type PrefabAssetType.NotAPrefab, so no way to know if its from prefab or not?

            if (Target)
            {
                if (!Target.IsInitialized)
                {
                    Target.Initialize();
                }
                DTGroupNode slotSection;

                if (DTGUI.IsLayout && IsInsideInspector && Target.Input != null && Target.Output != null && (Target.Input.Count > 0 || Target.Output.Count > 0) && !Node.FindNode("Slots", out slotSection))
                {
                    Node.AddSection("Slots", OnShowSlots).SortOrder = 99999;
                    Node.Sort();
                }

                if (GUILayout.Button(new GUIContent(CurvyStyles.OpenGraphTexture, "Edit Graph")) && Target.Generator)
                {
                    CGGraph win = CGGraph.Open(Target.Generator);
                    win.Sel.SetSelectionTo(Target);
                    win.Canvas.FocusSelection();
                }

                base.OnInspectorGUI();



            }
        }

        void OnShowSlots(DTInspectorNode node)
        {
            if (Target)
            {
                List<CGModuleInputSlot> inSlots = Target.Input;
                List<CGModuleOutputSlot> outSlots = Target.Output;

                EditorGUILayout.BeginVertical(GUI.skin.box);

                if (inSlots.Count > 0)
                {
                    EditorGUILayout.LabelField("Input", EditorStyles.boldLabel);
                    showSlots(inSlots);
                }

                if (outSlots.Count > 0)
                {
                    EditorGUILayout.LabelField("Output", EditorStyles.boldLabel);
                    showSlots(outSlots);
                }
                EditorGUILayout.EndVertical();
                GUILayout.Space(10);

            }
        }

        void showSlots<T>(List<T> slots) where T : CGModuleSlot
        {
            foreach (CGModuleSlot slot in slots)
            {
                List<CGModule> linked = slot.GetLinkedModules();
                if (linked.Count > 1)
                {
                    for (int i = 0; i < linked.Count; i++)
                    {
                        Object sel = EditorGUILayout.ObjectField((i == 0) ? slot.Info.DisplayName : " ", linked[i], typeof(CGModule), true);
                        if (sel != linked[i])
                            DTLog.Log("[Curvy] Linking modules from the inspector isn't supported yet! Use the Graph editor instead!", Target);
                    }
                }
                else
                {
                    CGModule lm = (linked.Count == 0) ? null : linked[0];
                    Object sel = EditorGUILayout.ObjectField(slot.Info.DisplayName, lm, typeof(CGModule), true);
                    if (sel != lm)
                        DTLog.Log("[Curvy] Linking modules from the inspector isn't supported yet! Use the Graph editor instead!", Target);
                }
            }
        }


        public void OnInspectorDebugGUIINTERNAL(UnityAction onChange)
        {
            if (Target)
            {
                ShowDebugStats.valueChanged.RemoveListener(onChange);
                ShowDebugStats.valueChanged.AddListener(onChange);
                GUILayout.BeginHorizontal(CurvyStyles.Toolbar);

                ShowDebugStats.target = GUILayout.Toggle(ShowDebugStats.target, new GUIContent(CurvyStyles.DebugTexture, "Show Values"), EditorStyles.toolbarButton);

                if (HasDebugVisuals)
                {
                    EditorGUI.BeginChangeCheck();
                    ShowDebugVisuals = GUILayout.Toggle(ShowDebugVisuals, new GUIContent(CurvyStyles.DebugSceneViewTexture, "Visualize"), EditorStyles.toolbarButton);
                    if (EditorGUI.EndChangeCheck())
                        SceneView.RepaintAll();
                }
                else
                    ShowDebugVisuals = false;
                GUILayout.FlexibleSpace();
                GUILayout.Label(string.Format("{0:0.###} ms", Target.DEBUG_ExecutionTime.AverageMS));
                GUILayout.Label(string.Format("{0:0} %", Target.DEBUG_ExecutionTime.AverageMS / Target.Generator.DEBUG_ExecutionTime.AverageMS * 100));
                GUILayout.EndHorizontal();
                GUILayout.Space(2);

                if (EditorGUILayout.BeginFadeGroup(ShowDebugStats.faded))
                {
                    OnModuleDebugGUI();
                }
                EditorGUILayout.EndFadeGroup();
            }
        }



        void CBSeedOptions()
        {
            if (!Target.RandomizeSeed)
            {
                Rect r = EditorGUILayout.GetControlRect(true, 16, EditorStyles.numberField, null);
                r.width -= 16;
                EditorGUI.PropertyField(r, serializedObject.FindProperty("m_Seed"));
                r.x += r.width;
                r.width = 16;
                if (GUI.Button(r, new GUIContent(CurvyStyles.RndSeedTexture, "Randomize now!"), CurvyStyles.ImageButton))
                {
                    Target.Seed = unchecked((int)System.DateTime.Now.Ticks);
                    Target.Generator.Refresh();
                }
            }
        }


    }

    public class CGModuleEditor<T> : CGModuleEditorBase where T : CGModule
    {
        public new T Target
        {
            get
            {
                return target as T;
            }
        }


    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CGModuleEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CGResourceEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 91cf6d920c15d7e44acdac5c2e58ad1a
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Generator;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.Curvy;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevToolsEditor;

namespace FluffyUnderware.CurvyEditor.Generator
{

    public static class CGResourceEditorHandler
    {
        static readonly Dictionary<string, System.Type> Editors = new Dictionary<string, System.Type>();

        internal static CGResourceEditor GetEditor(string resourceName, Component resource)
        {
            if (Editors.Count == 0)
                loadEditors();
            if (Editors.ContainsKey(resourceName))
            {
                return (CGResourceEditor)System.Activator.CreateInstance(Editors[resourceName], (object)resource);
            }
            return null;
        }

        static void loadEditors()
        {
            Editors.Clear();
            TypeCache.TypeCollection types = TypeCache.GetTypesWithAttribute<ResourceEditorAttribute>();
            foreach (Type T in types)
            {
                object[] at = T.GetCustomAttributes(typeof(ResourceEditorAttribute), true);
                Editors.Add(((ResourceEditorAttribute)at[0]).ResourceName, T);
            }
        }
    }

    public class CGResourceEditor
    {
        protected Component Resource { get; private set; }

        public CGResourceEditor() { }

        public CGResourceEditor(Component resource)
        {
            Resource = resource;
        }

        /// <summary>
        /// Resource GUI
        /// </summary>
        /// <returns>true if changes were made</returns>
        public virtual bool OnGUI() { return false; }

        public static implicit operator bool(CGResourceEditor a)
        {
            return !object.ReferenceEquals(a, null);
        }
    }

    [ResourceEditor("Mesh")]
    public class CGMeshResourceGUI : CGResourceEditor
    {

        public CGMeshResourceGUI(Component resource) : base(resource)
        {
        }


    }

    [ResourceEditor("Spline")]
    public class CGSplineResourceGUI : CGResourceEditor
    {

        public CGSplineResourceGUI(Component resource)
            : base(resource)
        {
        }
    }

    [ResourceEditor("Shape")]
    public class CGShapeResourceGUI : CGResourceEditor
    {
        CurvyShape2D mCurrentShape;
        readonly string[] mMenuNames;
        int mSelection;
        bool mFreeform;

        public CGShapeResourceGUI(Component resource) : base(resource)
        {
            mCurrentShape = resource.GetComponent<CurvyShape2D>();
            mMenuNames = CurvyShape.GetShapesMenuNames((mCurrentShape) ? mCurrentShape.GetType() : null, out mSelection, true).ToArray();
            mFreeform = (mCurrentShape == null);
        }

        public override bool OnGUI()
        {
            bool dirty = false;

            bool b = GUILayout.Toggle(mFreeform, "Freeform");
            if (b != mFreeform)
            {
                if (b)
                {
                    mCurrentShape.Spline.ShowGizmos = true;
                    mCurrentShape.Delete();
                    mCurrentShape = null;
                    mFreeform = b;

                }
                else if (EditorUtility.DisplayDialog("Warning", "The current shape will be irreversible replaced. Are you sure?", "Ok", "Cancel"))
                {
                    if (DTUtility.DoesPrefabStatusAllowDeletion(Resource.gameObject.gameObject, out string errorMessage))
                    {
                        mFreeform = b;
                        mCurrentShape = (CurvyShape2D)Resource.gameObject.AddComponent(CurvyShape.GetShapeType(mMenuNames[mSelection]));
                        mCurrentShape.Dirty = true;
                    }
                    else
                    {
                        EditorUtility.DisplayDialog($"Cannot delete Game Object '{Resource.gameObject.name}'", errorMessage, "Ok");
                    }
                }

            }
            if (!mFreeform)
            {
                int sel = EditorGUILayout.Popup(mSelection, mMenuNames);
                if (sel != mSelection)
                {
                    if (DTUtility.DoesPrefabStatusAllowDeletion(Resource.gameObject, out string errorMessage))
                    {
                        mSelection = sel;
                        dirty = true;
                        if (mCurrentShape)
                            mCurrentShape.Delete();
                        mCurrentShape = (CurvyShape2D)Resource.gameObject.AddComponent(CurvyShape.GetShapeType(mMenuNames[mSelection]));
                        mCurrentShape.Dirty = true;
                    }
                    else
                    {
                        EditorUtility.DisplayDialog($"Cannot delete Game Object '{Resource.gameObject.name}'", errorMessage, "Ok");
                    }
                }
                if (mCurrentShape)
                {
                    using (SerializedObject so = new SerializedObject(mCurrentShape))
                    {
                        SerializedProperty prop = so.GetIterator();

                        bool enterChildren = true;

                        while (prop.NextVisible(enterChildren))
                        {
                            switch (prop.name)
                            {
                                case "m_Script":
                                case "InspectorFoldout":
                                case "m_Plane":
                                    //case "m_Persistent":
                                    break;
                                default:
                                    EditorGUILayout.PropertyField(prop);
                                    break;
                            }
                            enterChildren = false;
                        }
                        dirty = dirty || so.ApplyModifiedProperties();
                    }
                }
            }

            return dirty;
        }
    }

    [System.AttributeUsage(System.AttributeTargets.Class)]
    public class ResourceEditorAttribute : System.Attribute
    {
        public readonly string ResourceName;

        public ResourceEditorAttribute(string resName)
        {
            ResourceName = resName;
        }
    }


}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CGResourceEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CurvyGeneratorEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 1bc2fddee027afa438e389e26eb163dc
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections;
using FluffyUnderware.Curvy.Generator;
using System.Collections.Generic;
using FluffyUnderware.DevToolsEditor.Extensions;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.CurvyEditor.Generator
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(CurvyGenerator))]
    public class CurvyGeneratorEditor : CurvyEditorBase<CurvyGenerator>
    {
        protected override void OnCustomInspectorGUI()
        {
            GUILayout.Space(5);
            if (Target)
                EditorGUILayout.HelpBox("# of Modules: " + Target.Modules.Count.ToString(), MessageType.Info);
        }

        public override void OnInspectorGUI()
        {
            //With the new prefab system (Unity 2018.3) prefabs don't show inspector, and when opening prefab editor, its objects are of type PrefabAssetType.NotAPrefab, so no way to know if its from prefab or not?

            GUILayout.BeginHorizontal(GUILayout.Height(24));
            if (GUILayout.Button(new GUIContent(CurvyStyles.OpenGraphTexture, "Edit Graph")))
                CGGraph.Open(Target);

            if (GUILayout.Button(new GUIContent(CurvyStyles.DeleteTexture, "Clear Graph"), GUILayout.ExpandWidth(false), GUILayout.ExpandHeight(true)) && EditorUtility.DisplayDialog("Clear", "Clear graph?", "Yes", "No"))
                Target.Clear();
            GUILayout.EndHorizontal();

            base.OnInspectorGUI();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/CurvyGeneratorEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/MetaCGOptionsEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 352a72fc4de23574f851e54f2adb3971
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif
using UnityEngine;
using UnityEditor;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.Curvy;
using UnityEngine.Assertions;

namespace FluffyUnderware.CurvyEditor
{
    [CustomEditor(typeof(MetaCGOptions))]
    [CanEditMultipleObjects]
    public class MetaCGOptionsEditor : DTEditor<MetaCGOptions>
    {

        [DrawGizmo(GizmoType.Active | GizmoType.NonSelected | GizmoType.InSelectionHierarchy)]
        static void MetaGizmoDrawer(MetaCGOptions data, GizmoType context)
        {
            if (data.Spline == null)
                return;

            if (CurvyGlobalManager.ShowMetadataGizmo && data.Spline.ShowGizmos)
            {
                if (data.CorrectedHardEdge)
                {
                    Vector3 position = data.ControlPoint.transform.position;
#pragma warning disable CS0618
                    CurvyGizmo.PointLabel(position, "^", OrientationAxisEnum.Down);
#pragma warning restore CS0618
                }
                if (data.Spline.Dirty == false && data.MaterialID != 0)
                {
                    Vector3 position = data.Spline.ToWorldPosition(data.ControlPoint.Interpolate(0.5f));
#pragma warning disable CS0618
                    CurvyGizmo.PointLabel(position, data.MaterialID.ToString(), OrientationAxisEnum.Forward);
#pragma warning restore CS0618
                }
            }
        }

        void CBSetFirstU()
        {
#if CONTRACTS_FULL
            Contract.Requires(Target.ControlPoint.Spline != null);
#endif
            if (!Target.CorrectedUVEdge && GUILayout.Button("Set U from neighbours"))
            {
                CurvySplineSegment targetControlPoint = Target.ControlPoint;
                CurvySpline targetSpline = targetControlPoint.Spline;

                float uValue;
                if (targetSpline.IsControlPointVisible(targetControlPoint))
                {
                    if (targetSpline.Count == 0)
                        uValue = 0;
                    else
                    {
                        //TODO this implementation has a lot in common with SplineInputModuleBase.CalculateExtendedUV. I am sure there is some duplicated code between these two, and there might be bugs due to those two implementations calculating U differently in some cases

                        CurvySplineSegment previousUWithDefinedCp;
                        CurvySpline curvySpline = Target.Spline;
                        {
                            CurvySplineSegment currentCp = curvySpline.GetPreviousControlPoint(targetControlPoint);
                            if (currentCp == null || targetControlPoint == curvySpline.FirstVisibleControlPoint)
                                previousUWithDefinedCp = targetControlPoint;
                            else
                            {
                                while (currentCp != curvySpline.FirstVisibleControlPoint)
                                {
                                    MetaCGOptions currentCpOptions = currentCp.GetMetadata<MetaCGOptions>(true);
                                    if (currentCpOptions.CorrectedUVEdge || currentCpOptions.ExplicitU)
                                        break;
                                    currentCp = curvySpline.GetPreviousControlPoint(currentCp);
                                }
                                previousUWithDefinedCp = currentCp;
                            }

                        }
                        MetaCGOptions previousDefinedOptions = previousUWithDefinedCp.GetMetadata<MetaCGOptions>(true);

                        CurvySplineSegment nextCpWithDefinedU;
                        {

                            CurvySplineSegment currentCp = curvySpline.GetNextControlPoint(targetControlPoint);
                            if (currentCp == null || targetControlPoint == curvySpline.LastVisibleControlPoint)
                                nextCpWithDefinedU = targetControlPoint;
                            else
                            {
                                while (currentCp != curvySpline.LastVisibleControlPoint)
                                {
                                    MetaCGOptions currentCpOptions = currentCp.GetMetadata<MetaCGOptions>(true);
                                    if (currentCpOptions.CorrectedUVEdge || currentCpOptions.ExplicitU)
                                        break;
                                    currentCp = curvySpline.GetNextControlPoint(currentCp);
                                }

                                nextCpWithDefinedU = currentCp;
                            }
                        }
                        if (curvySpline.Closed && nextCpWithDefinedU == curvySpline.LastVisibleControlPoint)
                            nextCpWithDefinedU = curvySpline.GetPreviousControlPoint(nextCpWithDefinedU);
                        MetaCGOptions nextDefinedOptions = nextCpWithDefinedU.GetMetadata<MetaCGOptions>(true);

                        float frag = (targetControlPoint.Distance - previousUWithDefinedCp.Distance) / (nextCpWithDefinedU.Distance - previousUWithDefinedCp.Distance);
#if CURVY_SANITY_CHECKS
                        Assert.IsFalse(float.IsNaN(frag));
#endif

                        float startingU = (previousUWithDefinedCp == targetControlPoint) ? 0 : previousDefinedOptions.GetDefinedSecondU(0);
                        float endingU = (nextCpWithDefinedU == targetControlPoint) ? 1 : nextDefinedOptions.GetDefinedFirstU(1);
                        uValue = Mathf.Lerp(startingU, endingU, frag);
                    }

                }
                else
                    uValue = 0;

                Target.FirstU = uValue;


                EditorUtility.SetDirty(target);
            }
        }
    }


}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CG/MetaCGOptionsEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/CurvyControllerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 3952319cbfad670488083249e69f8d33
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.Controllers;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.DevTools;
using UnityEngine.Assertions;

namespace FluffyUnderware.CurvyEditor.Controllers
{

    public class CurvyControllerEditor<T> : CurvyEditorBase<T> where T : CurvyController
    {
        protected override void OnEnable()
        {
            EditorApplication.playModeStateChanged += OnPlayModeStateChanged;
            base.OnEnable();
        }

        protected override void OnDisable()
        {
            EditorApplication.playModeStateChanged -= OnPlayModeStateChanged;
            base.OnDisable();
            if (Application.isPlaying == false)
                if (Target)
                Target.Stop();
        }

        void OnPlayModeStateChanged(PlayModeStateChange state)
        {
            OnStateChanged();
        }

        void OnStateChanged()
        {
            if (Application.isPlaying == false)
                Target.Stop();

        }

        protected override void OnReadNodes()
        {
            DTGroupNode node = Node.AddSection("Preview", ShowPreviewButtons);
            node.Expanded = false;
            node.SortOrder = 5000;
        }


        /// <summary>
        /// Show the preview buttons
        /// </summary>
        protected void ShowPreviewButtons(DTInspectorNode node)
        {
            GUILayout.BeginHorizontal();
            GUI.enabled = !Application.isPlaying;

            bool isPlayingOrPaused = Target.PlayState == CurvyController.CurvyControllerState.Playing || Target.PlayState == CurvyController.CurvyControllerState.Paused;

            //TODO it would be nice to have two different icons, one for Play and one for Pause
            if (GUILayout.Toggle(isPlayingOrPaused, new GUIContent(CurvyStyles.TexPlay, "Play/Pause in Editor"), GUI.skin.button) != isPlayingOrPaused)
            {

                switch (Target.PlayState)
                {
                    case CurvyController.CurvyControllerState.Paused:
                    case CurvyController.CurvyControllerState.Stopped:
                        Target.Play();
                        break;
                    case CurvyController.CurvyControllerState.Playing:
                        Target.Pause();
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
            if (GUILayout.Button(new GUIContent(CurvyStyles.TexStop, "Stop/Reset")))
            {
                Target.Stop();
            }
            GUI.enabled = true;
            GUILayout.EndHorizontal();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/CurvyControllerEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/MoveModeDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: bc870c7e0be8b8a42bb5579d77bfa8e3
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using FluffyUnderware.Curvy.Controllers;
using UnityEngine;
using UnityEditor;

namespace FluffyUnderware.CurvyEditor.Controllers
{
    [CustomPropertyDrawer(typeof(CurvyController.MoveModeEnum))]
    public class MoveModeDrawer : PropertyDrawer
    {
        readonly GUIContent[] options = new[] { new GUIContent("Relative", "Speed is expressed as spline lengths per second"), new GUIContent("Absolute", "Speed is expressed as world units per second") };
        readonly GUIStyle guiStyle = EditorStyles.popup;

        override public void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            EditorGUI.BeginProperty(position, label, property);
            property.intValue = EditorGUI.Popup(position, label, property.intValue, options, guiStyle);
            EditorGUI.EndProperty();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/MoveModeDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/OnPositionReachedSettingsDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 85be52f98941fdb4a95eec748bb89ba7
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

#region

using System;
using System.Collections.Generic;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.Controllers;
using FluffyUnderware.DevTools.Extensions;
using UnityEditor;
using UnityEngine;

#endregion

namespace FluffyUnderware.CurvyEditor.Controllers
{
    [CustomPropertyDrawer(typeof(OnPositionReachedSettings))]
    public class OnPositionReachedSettingsDrawer : PropertyDrawer
    {
        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            OnPositionReachedSettings onPositionReachedSettings;
            {
                object value = fieldInfo.GetValue(property.serializedObject.targetObject);
                if (value.GetType().IsArrayOrList())
                {
                    int startIndex = property.propertyPath.LastIndexOf('[');
                    int endIndex = property.propertyPath.LastIndexOf(']');
                    int index = Convert.ToInt32(property.propertyPath.Substring(startIndex + 1, endIndex - startIndex - 1));
                    onPositionReachedSettings = ((List<OnPositionReachedSettings>)value)[index];
                }
                else
                {
                    onPositionReachedSettings = (OnPositionReachedSettings)value;
                }
            }

            return GetPropertyHeight(property, onPositionReachedSettings);
        }

        public static float GetPropertyHeight(SerializedProperty property, OnPositionReachedSettings onPositionReachedSettings)
        {
            if (property.isExpanded == false)
                return EditorGUIUtility.singleLineHeight;

            return 190 + Math.Max(0, onPositionReachedSettings.Event.GetPersistentEventCount() - 1) * 47;
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            SerializedProperty nameProperty = property.FindPropertyRelative(nameof(OnPositionReachedSettings.Name));
            SerializedProperty colorProperty = property.FindPropertyRelative(nameof(OnPositionReachedSettings.GizmoColor));
            SerializedProperty eventProperty = property.FindPropertyRelative(nameof(OnPositionReachedSettings.Event));
            SerializedProperty positionProperty = property.FindPropertyRelative(nameof(OnPositionReachedSettings.Position));
            SerializedProperty positionModeProperty = property.FindPropertyRelative(nameof(OnPositionReachedSettings.PositionMode));
            SerializedProperty triggeringDirectionsProperty = property.FindPropertyRelative(nameof(OnPositionReachedSettings.TriggeringDirections));

            float fieldHeight = EditorGUIUtility.singleLineHeight;
            float fieldMarginHeight = EditorGUIUtility.standardVerticalSpacing;

            // Using BeginProperty / EndProperty on the parent property means that
            // prefab override logic works on the entire property.
            EditorGUI.BeginProperty(position, label, property);

            string labelString;
            {
                if (property.isExpanded)
                    labelString = $"{nameProperty.stringValue}";
                else
                {
                    string positionModeEnumName;
                    {
                        bool positionModeParseSucceeded = Enum.TryParse(positionModeProperty.enumNames[positionModeProperty.enumValueIndex], out CurvyPositionMode positionMode);
                        positionModeEnumName = positionModeParseSucceeded ? CurvyPositionModeDrawer.GetDisplayName(positionMode) : positionModeProperty.enumDisplayNames[positionModeProperty.enumValueIndex];
                    }

                    labelString = $"{nameProperty.stringValue} (Position: {positionModeEnumName} {positionProperty.floatValue} - Direction: {triggeringDirectionsProperty.enumDisplayNames[triggeringDirectionsProperty.enumValueIndex]})";
                }
            }
            int indent = EditorGUI.indentLevel;
            EditorGUI.indentLevel = indent + 1;

            property.isExpanded = EditorGUI.Foldout(
                new Rect(position.x,
                    position.y,
                    position.width,
                    EditorGUIUtility.singleLineHeight),
                property.isExpanded,
                labelString);

            if (property.isExpanded)
            {
                float yCoordinate = position.y;

                EditorGUI.indentLevel = indent + 1;

                yCoordinate += fieldHeight + fieldMarginHeight;

                Rect nameRect = new Rect(position.x,
                    yCoordinate,
                    position.width - 75,
                    fieldHeight);
                Rect colorRect = new Rect(position.x + position.width - 70,
                    yCoordinate,
                    70,
                    fieldHeight);

                yCoordinate += fieldHeight + fieldMarginHeight;
                Rect positionRect = new Rect(position.x,
                    yCoordinate,
                    position.width - 115,
                    fieldHeight);
                Rect positionModeRect = new Rect(position.x + position.width - 110,
                    yCoordinate,
                    110,
                    fieldHeight);

                yCoordinate += fieldHeight + fieldMarginHeight;
                Rect directionRect = new Rect(position.x,
                    yCoordinate,
                    position.width,
                    fieldHeight);

                yCoordinate += fieldHeight + fieldMarginHeight;
                Rect eventRect = new Rect(position.x,
                    yCoordinate,
                    position.width,
                    position.height - 70);
                eventRect = EditorGUI.IndentedRect(eventRect);

                EditorGUI.PropertyField(nameRect, nameProperty);
                EditorGUI.PropertyField(colorRect, colorProperty, GUIContent.none);
                EditorGUI.PropertyField(eventRect, eventProperty, GUIContent.none);
                EditorGUI.PropertyField(positionRect, positionProperty);
                EditorGUI.PropertyField(positionModeRect, positionModeProperty, GUIContent.none);
                EditorGUI.PropertyField(directionRect, triggeringDirectionsProperty);

            }
            EditorGUI.indentLevel = indent;


            EditorGUI.EndProperty();
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/OnPositionReachedSettingsDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/PathControllerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 709467389ecf3f446bda424d4e6fc7a7
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Controllers;

namespace FluffyUnderware.CurvyEditor.Controllers
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(PathController), true)]
    public class PathControllerEditor : CurvyControllerEditor<PathController>
    {
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/PathControllerEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/SplineControllerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e3d05319f569b3242a40cd95655a6a80
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using System.Collections;
using FluffyUnderware.Curvy;
using FluffyUnderware.CurvyEditor;
using FluffyUnderware.Curvy.Controllers;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevToolsEditor;

namespace FluffyUnderware.CurvyEditor.Controllers
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(SplineController), true)]
    public class SplineControllerEditor : CurvyControllerEditor<SplineController>
    {
        protected override void SetupArrayEx(DTFieldNode node, ArrayExAttribute attribute)
        {
            base.SetupArrayEx(node, attribute);

            float ArrayExElementHeightCallback(int index)
            {
                if (index >= node.serializedProperty.arraySize)
                    // this case happens due to this regression:  https://issuetracker.unity3d.com/issues/reorderablelist-dot-elementheightcallback-is-invoked-when-list-has-no-element
                    return 0;

                return OnPositionReachedSettingsDrawer.GetPropertyHeight(
                    node.serializedProperty.GetArrayElementAtIndex(index),
                    ((SplineController)target).OnPositionReachedList[index]);
            }

            node.ArrayEx.elementHeightCallback = ArrayExElementHeightCallback;
        }

        protected override void OnSceneGUI()
        {
            base.OnSceneGUI();

            CurvySpline spline;

            if (Target != null && (spline = Target.Spline) != null)
            {
                for (int index = 0; index < Target.OnPositionReachedList.Count; index++)
                {
                    OnPositionReachedSettings settings = Target.OnPositionReachedList[index];
                    DTHandles.PushHandlesColor(settings.GizmoColor);

                    Vector3 position;
                    {
                        switch (settings.PositionMode)
                        {
                            case CurvyPositionMode.Relative:
                                position = spline.Interpolate(settings.Position, Space.World);
                                break;
                            case CurvyPositionMode.WorldUnits:
                                position = spline.InterpolateByDistance(settings.Position, Space.World);
                                break;
                            default:
                                throw new ArgumentOutOfRangeException();
                        }
                    }

                    EditorGUI.BeginChangeCheck();

                    float handleSize = HandleUtility.GetHandleSize(position) * .2f;
                    Vector3 newPosition = Handles.FreeMoveHandle(position,
#if UNITY_2022_1_OR_NEWER == false
                        Quaternion.identity,
#endif
                        handleSize,
                        Vector3.one * 0.5f, //couldn't figure out what value to put here. I put the same value as the example in the documentation
                        Handles.SphereHandleCap);

                    if (EditorGUI.EndChangeCheck())
                    {
                        Undo.RecordObject(Target, "Modify Custom Event Position");
                        float nearestTf = spline.GetNearestPointTF(newPosition, Space.World);
                        switch (settings.PositionMode)
                        {
                            case CurvyPositionMode.Relative:
                                settings.Position = nearestTf;
                                break;
                            case CurvyPositionMode.WorldUnits:
                                settings.Position = spline.TFToDistance(nearestTf);
                                break;
                            default:
                                throw new ArgumentOutOfRangeException();
                        }
                    }

                    //draw label
                    {
                        Color textColor = new Color(
                            settings.GizmoColor.r * 0.2f,
                            settings.GizmoColor.g * 0.2f,
                            settings.GizmoColor.b * 0.2f,
                            1);

                        GUIStyle guiStyle = CurvyStyles.ControllerCustomEventStyle;
                        lock (guiStyle)
                        {
                            guiStyle.normal.textColor = textColor;

                            //inlined version of CurvyGizmo.PointLabel(newPosition, settings.Name, OrientationAxisEnum.Up, handleSize * 4, guiStyle);
                            //I did the inline because CurvyGizmo.PointLabel has an issue with 2021.2, and I have a hack in that method to avoid the issue. The problem is the hack is counter-productive when the method is called from a OnSceneGUI method
                            Vector3 labelPosition = newPosition;
                            string label = settings.Name;

                            //ugly shit to bypass the joke that is style.alignment. Tried to bypass the issue by using style.CalcSize(new GUIContent(label)) to manually place the labels. No luck with that
                            while (label.Length <= 5)
                                label = $" {label} ";

                            labelPosition -= Camera.current.transform.right * (handleSize * 4) * 0.1f;
                            labelPosition += Camera.current.transform.up * (handleSize * 4) * 0.1f;
                            labelPosition += Camera.current.transform.up * (handleSize * 4) * 0.3f;

                            Handles.Label(labelPosition, label, guiStyle);
                        }
                    }

                    //direction handles
                    {
                        //optim if needed
                        float tf = settings.PositionMode == CurvyPositionMode.Relative ? settings.Position : spline.DistanceToTF(settings.Position);
                        Vector3 forward = spline.GetTangent(tf, Space.World);
                        Vector3 backward = -spline.GetTangent(tf * (1f - 0.001f), Space.World); //todo not the best way to compute the backward tangent, but it is a decent one for now. Enhance this if needed once you rework tangents computing code

                        if (settings.TriggeringDirections != TriggeringDirections.Backward)
                            DTHandles.ArrowCap(newPosition, forward, Camera.current.transform.forward, settings.GizmoColor, .7f, .1f, .3f, .4f, handleSize * 2);
                        if (settings.TriggeringDirections != TriggeringDirections.Forward)
                            DTHandles.ArrowCap(newPosition, backward, Camera.current.transform.forward, settings.GizmoColor, .7f, .1f, .3f, .4f, handleSize * 2);
                    }
                    DTHandles.PopHandlesColor();
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/SplineControllerEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/VolumeControllerEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: c857adf1af41cc34896f8a078cd9ea11
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy.Controllers;

namespace FluffyUnderware.CurvyEditor.Controllers
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(VolumeController), true)]
    public class VolumeControllerEditor : CurvyControllerEditor<VolumeController>
    {
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/Controllers/VolumeControllerEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyConnectionEditor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 512f7156b64ad1843b880b394f7bd408
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.Curvy;
using FluffyUnderware.DevToolsEditor;
using UnityEditor;
using UnityEngine;
using UnityEngine.Assertions;

namespace FluffyUnderware.CurvyEditor
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(CurvyConnection))]
    public class CurvyConnectionEditor : CurvyEditorBase<CurvyConnection>
    {
        /// <summary>
        /// the gui style used in drawing the gizmo's label
        /// </summary>
        private GUIStyle sceneGuiLabelStyle;
        /// <summary>
        /// Used in the inspector, to avoid the margins added by Unity when subdivising a space
        /// </summary>
        private GUIStyle noMarginsStyle;

        private GUIStyle highlightedItemStyle;

        GUIContent selectCpContent;
        GUIContent removeFromConnectionContent;
        GUIContent controlPointTitleContent;
        GUIContent syncPositionTitleContent;
        GUIContent syncPositionContent;
        GUIContent syncRotationTitleContent;
        GUIContent syncRotationContent;
        GUIContent noSyncPresetContent;
        GUIContent positionSyncPresetContent;
        GUIContent rotationSyncPresetContent;
        GUIContent fullSyncPresetContent;

        private GUIContent splineTitleContent;
        private GUIContent endControlPointTitleContent;
        private GUIContent followUpTitleContent;
        private GUIContent headingDirectionTitleContent;

        GUIContent splineStartDirectionContent;
        GUIContent emptyContent;
        GUIContent noDirectionContent;
        GUIContent splineEndDirectionContent;
        GUIContent automaticDirectionContent;
        GUIContent directionUnavailableContent;

        [DrawGizmo(GizmoType.Active | GizmoType.NonSelected | GizmoType.InSelectionHierarchy)]
        private static void ConnectionGizmoDrawer(CurvyConnection connection, GizmoType context)
        {
            if (CurvyGlobalManager.ShowConnectionsGizmo)
            {
                Gizmos.color = connection.GetGizmoColor();

                foreach (CurvySplineSegment cp in connection.ControlPointsList)
                {
                    if (cp.Spline.ShowGizmos)
                    {
                        //optim avoid drawing gizmo multiple times if cps have the same positin
                        Vector3 position = cp.transform.position;
                        float handleSize = HandleUtility.GetHandleSize(position);
                        Gizmos.DrawWireSphere(position, handleSize * CurvyGlobalManager.GizmoControlPointSize * 1.1f);
                    }
                }
            }
        }


        protected override void OnEnable()
        {
            base.OnEnable();
            sceneGuiLabelStyle = new GUIStyle();
            noMarginsStyle = new GUIStyle();
            noMarginsStyle.margin = new RectOffset();
            highlightedItemStyle = new GUIStyle();
            highlightedItemStyle.normal.background = new Texture2D(1, 1);
            highlightedItemStyle.normal.background.SetPixel(0, 0, new Color(62 / 255f, 125 / 255f, 231 / 255f));
            highlightedItemStyle.normal.background.Apply();

            selectCpContent = new GUIContent("Select", "Select the Control Point");
            removeFromConnectionContent = new GUIContent(CurvyStyles.DeleteSmallTexture, "Remove the Control Point from this Connection");
            controlPointTitleContent = new GUIContent("Control Point", "The name of the Control Point. You can select it or remove it from the connection");
            syncPositionTitleContent = new GUIContent("Sync Position", "Synchronize the Control Point's position with the connection's");
            syncPositionContent = new GUIContent("", "Synchronize the Control Point's position with the connection's");
            syncRotationTitleContent = new GUIContent("Sync Rotation", "Synchronize the Control Point's rotation with the connection's");
            syncRotationContent = new GUIContent("", "Synchronize the Control Point's rotation with the connection's");
            noSyncPresetContent = new GUIContent(CurvyStyles.TexConnection, "No synchronization");
            positionSyncPresetContent = new GUIContent(CurvyStyles.TexConnectionPos, "Position only");
            rotationSyncPresetContent = new GUIContent(CurvyStyles.TexConnectionRot, "Rotation only");
            fullSyncPresetContent = new GUIContent(CurvyStyles.TexConnectionFull, "Position and rotation");

            splineTitleContent = new GUIContent("Spline", "The open spline for which the Follow-Up will be defined");
            endControlPointTitleContent = new GUIContent("Control Point", "The spline's end that will have a Follow-Up, either its first or last visible Control Point");
            followUpTitleContent = new GUIContent("Follow-Up", "The Control Point that will act as the continuity of the spline's end");
            headingDirectionTitleContent = new GUIContent("Heading Direction", "In which direction the Follow-Up should continue on");

            splineStartDirectionContent = new GUIContent("To spline's start", "The Follow-Up segment continues towards its spline's start");
            emptyContent = new GUIContent("");
            noDirectionContent = new GUIContent("Nowhere", "There is no continuity for the Follow-Up");
            splineEndDirectionContent = new GUIContent("To spline's end", "The Follow-Up segment continues towards its spline's end");
            automaticDirectionContent = new GUIContent("Automatic", "Automatically selects the best option");
            directionUnavailableContent = new GUIContent("---", "Select a Follow-Up first");
        }

        public new void OnSceneGUI()
        {
            if (SceneView.currentDrawingSceneView.camera && Target)
            {
                int cpsCount = Target.ControlPointsList.Count;
                if (cpsCount > 0)
                {
                    sceneGuiLabelStyle.normal.textColor = Target.GetGizmoColor();

                    int syncedCPsCount = 0;
                    for (int i = 0; i < cpsCount; i++)
                    {
                        CurvySplineSegment controlPoint = Target.ControlPointsList[i];

                        int lineIndex;
                        if (controlPoint.ConnectionSyncPosition)
                        {
                            lineIndex = syncedCPsCount;
                            syncedCPsCount++;
                        }
                        else
                            lineIndex = 0;

                        Handles.Label(DTHandles.TranslateByPixel(controlPoint.transform.position, 12, -12 * (1 + lineIndex)), controlPoint.ToString(), sceneGuiLabelStyle);
                    }
                }
            }
        }

        protected override void OnReadNodes()
        {
            //If ControlPointsGui is no more called first, make sure the undoing code in it is moved to the right place
            Node.AddSection("Control Point Options", ControlPointsGui);
            Node.AddSection("Follow-Up", FollowUpGui);
            Node.AddSection("Connection Options", ConnectionGui);
        }

        private static float GetNodeWidth(DTInspectorNode node)
        {
            return EditorGUIUtility.currentViewWidth - 2 * node.Level * 15 /*value of EditorGUI.indent*/;
        }

        void ControlPointsGui(DTInspectorNode node)
        {
            const string undoingOperationLabel = "Connection Modification";
            Undo.RecordObject(Target, undoingOperationLabel);
            Undo.RecordObjects(Target.ControlPointsList.Select(o => (UnityEngine.Object)o).ToArray(), undoingOperationLabel);
            Undo.RecordObjects(Target.ControlPointsList.Select(o => (UnityEngine.Object)o.transform).ToArray(), undoingOperationLabel);

            float drawingWidth = GetNodeWidth(node);
            float column1Width = drawingWidth * 16 / 32;
            float column2Width = drawingWidth * 8 / 32;
            float column3Width = drawingWidth * 8 / 32;

            //header           
            {
                EditorGUILayout.BeginHorizontal();
                PositionGuiElements(() => GUILayout.Label(controlPointTitleContent, EditorStyles.boldLabel), column1Width, false);
                PositionGuiElements(() => GUILayout.Label(syncPositionTitleContent, EditorStyles.boldLabel), column2Width);
                PositionGuiElements(() => GUILayout.Label(syncRotationTitleContent, EditorStyles.boldLabel), column3Width);
                EditorGUILayout.EndHorizontal();
            }

            //Items
            for (int index = 0; index < Target.ControlPointsList.Count; index++)
            {
                CurvySplineSegment item = Target.ControlPointsList[index];

                bool itemIsSelected = item.gameObject == Selection.activeGameObject;
                EditorGUILayout.BeginHorizontal(itemIsSelected
                    ? highlightedItemStyle
                    : GUIStyle.none);

                {
                    PositionGuiElements(() =>
                                        {
                                            bool clicked = GUILayout.Button(item.ToString(), itemIsSelected
                                                ? EditorStyles.whiteLabel
                                                : EditorStyles.label, GUILayout.MinWidth(column1Width * 0.6f));

                                            if (GUILayout.Button(selectCpContent, GUILayout.MinWidth(50)))
                                                clicked = true;

                                            if (clicked)
                                                DTSelection.SetGameObjects(item);

                                            if (GUILayout.Button(removeFromConnectionContent, CurvyStyles.ImageButton, GUILayout.MinWidth(20), GUILayout.MinHeight(18)))
                                            {
                                                item.Disconnect();
                                                CurvyProject.Instance.ScanConnections();
                                                GUIUtility.ExitGUI();
                                            }
                                        }, column1Width, false);
                }

                {
                    PositionGuiElements(() =>
                                        {
                                            bool oldValue = item.ConnectionSyncPosition;
                                            item.ConnectionSyncPosition = GUILayout.Toggle(oldValue, syncPositionContent);
                                            if (item.ConnectionSyncPosition != oldValue)
                                                item.Connection.SetSynchronisationPositionAndRotation(item.Connection.transform.position, item.Connection.transform.rotation);
                                        }, column2Width);
                    PositionGuiElements(() =>
                                        {
                                            bool oldValue = item.ConnectionSyncRotation;
                                            item.ConnectionSyncRotation = GUILayout.Toggle(oldValue, syncRotationContent);
                                            if (item.ConnectionSyncRotation != oldValue)
                                                item.Connection.SetSynchronisationPositionAndRotation(item.Connection.transform.position, item.Connection.transform.rotation);
                                        }, column3Width);
                }

                EditorGUILayout.EndHorizontal();
            }

            //Presets
            {
                EditorGUILayout.BeginHorizontal();
                GUILayout.Label("Synchronization Presets", EditorStyles.boldLabel);
                EditorGUILayout.EndHorizontal();


                EditorGUILayout.BeginHorizontal(GUILayout.Width(drawingWidth));
                bool syncPosition = false;
                bool syncRotation = false;
                bool buttonClicked = false;
                if (GUILayout.Button(noSyncPresetContent))
                {
                    syncPosition = false;
                    syncRotation = false;
                    buttonClicked = true;
                }

                if (GUILayout.Button(positionSyncPresetContent))
                {
                    syncPosition = true;
                    syncRotation = false;
                    buttonClicked = true;
                }

                if (GUILayout.Button(rotationSyncPresetContent))
                {
                    syncPosition = false;
                    syncRotation = true;
                    buttonClicked = true;
                }

                if (GUILayout.Button(fullSyncPresetContent))
                {
                    syncPosition = true;
                    syncRotation = true;
                    buttonClicked = true;
                }

                if (buttonClicked && Target.ControlPointsList.Any())
                {
                    foreach (CurvySplineSegment controlPoint in Target.ControlPointsList)
                    {
                        controlPoint.ConnectionSyncPosition = syncPosition;
                        controlPoint.ConnectionSyncRotation = syncRotation;
                    }

                    Target.SetSynchronisationPositionAndRotation(Target.transform.position, Target.transform.rotation);
                    Target.AutoSetFollowUp();
                }

                EditorGUILayout.EndHorizontal();
            }
        }

        private void PositionGuiElements(Action guiElementsDrawer, float elementsTotalWidth, bool spaceBefore = true, bool spaceAfter = true)
        {
            EditorGUILayout.BeginHorizontal(noMarginsStyle, GUILayout.Width(elementsTotalWidth));
            if (spaceBefore)
                GUILayout.FlexibleSpace();
            guiElementsDrawer();
            if (spaceAfter)
                GUILayout.FlexibleSpace();
            EditorGUILayout.EndHorizontal();
        }

        void FollowUpGui(DTInspectorNode node)
        {
            float drawingWidth = GetNodeWidth(node);
            float column1Width = drawingWidth * 2 / 10;
            float column2Width = drawingWidth * 2 / 10;
            float column3Width = drawingWidth * 3 / 10;
            float column4Width = drawingWidth * 3 / 10;

            bool hasCpWhichCanHaveFollowUp = Target.ControlPointsList.Any(item => item.Spline && item.Spline.CanControlPointHaveFollowUp(item));

            if (hasCpWhichCanHaveFollowUp)
            {
                //header           
                {
                    EditorGUILayout.BeginHorizontal();
                    PositionGuiElements(() => GUILayout.Label(splineTitleContent, EditorStyles.boldLabel, GUILayout.MaxWidth(column1Width)), column1Width);
                    PositionGuiElements(() => GUILayout.Label(endControlPointTitleContent, EditorStyles.boldLabel, GUILayout.MaxWidth(column2Width)), column2Width);
                    PositionGuiElements(() => GUILayout.Label(followUpTitleContent, EditorStyles.boldLabel), column3Width);
                    PositionGuiElements(() => GUILayout.Label(headingDirectionTitleContent, EditorStyles.boldLabel), column4Width);
                    EditorGUILayout.EndHorizontal();
                }

                for (int index = 0; index < Target.ControlPointsList.Count; index++)
                {
                    CurvySplineSegment item = Target.ControlPointsList[index];
                    if (item.Spline && item.Spline.CanControlPointHaveFollowUp(item))
                    {
                        EditorGUILayout.BeginHorizontal();

                        PositionGuiElements(() =>
                            GUILayout.Label(item.Spline.name, GUILayout.MaxWidth(column1Width)), column1Width);
                        PositionGuiElements(() =>
                            GUILayout.Label(String.Format("{0} ({1})", item.name, item.IsLastControlPoint
                                                ? "Last CP"
                                                : "First CP"), GUILayout.MaxWidth(column2Width)), column2Width);
                        PositionGuiElements(() =>
                            {
                                List<CurvySplineSegment> possibleTargets = (from cp in Target.ControlPointsList where cp != item select cp).ToList();
                                int popUpIndex;
                                {
                                    if (item.FollowUp == null)
                                        popUpIndex = 0;
                                    else
                                    {
                                        int followUpIndex = possibleTargets.IndexOf(item.FollowUp);
#if CURVY_SANITY_CHECKS
                                        Assert.IsTrue(followUpIndex != -1);
#endif
                                        popUpIndex = followUpIndex + 1;
                                    }
                                }

                                List<string> popUpContent;
                                {
                                    popUpContent = (from cp in possibleTargets select cp.ToString()).ToList();
                                    popUpContent.Insert(0, "No Follow-Up");
                                }

                                EditorGUI.BeginChangeCheck();

                                popUpIndex = EditorGUILayout.Popup(popUpIndex, popUpContent.ToArray(), GUILayout.MaxWidth(column3Width));

                                if (EditorGUI.EndChangeCheck())
                                {
                                    item.SetFollowUp(popUpIndex == 0
                                        ? null
                                        : possibleTargets[popUpIndex - 1]);
                                }
                            }, column3Width);

                        PositionGuiElements(() =>
                                            {
                                                CurvySplineSegment itemFollowUp = item.FollowUp;
                                                if (itemFollowUp)
                                                {
                                                    int popUpIndex = (int)item.FollowUpHeading + 1;
#if CURVY_SANITY_CHECKS
                                                    Assert.IsTrue((int)ConnectionHeadingEnum.Minus == -1);
                                                    Assert.IsTrue((int)ConnectionHeadingEnum.Sharp == 0);
                                                    Assert.IsTrue((int)ConnectionHeadingEnum.Plus == 1);
                                                    Assert.IsTrue((int)ConnectionHeadingEnum.Auto == 2);
#endif

                                                    GUIContent[] popUpContent =
                                                                        {
                                    CurvySplineSegment.CanFollowUpHeadToStart(itemFollowUp)
                                        ? splineStartDirectionContent
                                        : emptyContent,
                                    noDirectionContent,
                                    CurvySplineSegment.CanFollowUpHeadToEnd(itemFollowUp)
                                        ? splineEndDirectionContent
                                        : emptyContent,
                                    automaticDirectionContent
                                                    };
                                                    EditorGUI.BeginChangeCheck();
                                                    popUpIndex = EditorGUILayout.Popup(popUpIndex, popUpContent.ToArray(), GUILayout.MaxWidth(column4Width));
                                                    if (EditorGUI.EndChangeCheck())
                                                        item.FollowUpHeading = (ConnectionHeadingEnum)(popUpIndex - 1);
                                                }
                                                else
                                                    GUILayout.Label(directionUnavailableContent);
                                            }, column4Width);

                        EditorGUILayout.EndHorizontal();
                    }
                }
            }
            else
                GUILayout.Label("You should connect the first or last Control Point of an open spline to be able to setup Follow-Ups");
        }

        void ConnectionGui(DTInspectorNode node)
        {
            float drawingWidth = GetNodeWidth(node);

            if (GUILayout.Button("Delete Connection", GUILayout.Width(drawingWidth)))
            {
                Target.Delete();
                GUIUtility.ExitGUI();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyConnectionEditor.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyEditorBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7e36bb3df4d2e75438de2de819b17da8
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.DevTools;
using FluffyUnderware.Curvy;
using System.Collections.Generic;


namespace FluffyUnderware.CurvyEditor
{
    public class CurvyEditorBase<T> : DTEditor<T> where T:MonoBehaviour
    {
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyEditorBase.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyEditorUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 0352d3a03998f41468aeff206517dd0e
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEditor;
using System.IO;
using FluffyUnderware.Curvy;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevToolsEditor;
using FluffyUnderware.DevTools;
using JetBrains.Annotations;
using Application = UnityEngine.Application;

namespace FluffyUnderware.CurvyEditor
{

    public static class CurvyEditorUtility
    {
        public static void SendBugReport()
        {
            string par = string.Format("@Operating System@={0}&@Unity Version@={1}&@Curvy Version@={2}", SystemInfo.operatingSystem, Application.unityVersion, CurvySpline.VERSION);
            Application.OpenURL(CurvySpline.WEBROOT + "bugreport?" + par.Replace(" ", "%20"));
        }

        public static void GenerateAssemblyDefinitions()
        {
            string curvyRootPath = GetCurvyRootPath();
            if (String.IsNullOrEmpty(curvyRootPath))
            {
                DTLog.LogError("[Curvy] Assembly Definitions generation aborted, couldn't locate the installation folder");
            }
            else
            {
                string curvyRootPathAbsolute = Application.dataPath + "/" + curvyRootPath;
                DirectoryInfo parentInfo = Directory.GetParent(curvyRootPathAbsolute).Parent;
                string assetsParentDirectory = parentInfo.FullName;
                string toolbuddyDirectory = parentInfo.Parent.FullName;

                GenerateAssemblyDefinition($"{assetsParentDirectory}/Arrays Pooling/ToolBuddy.ArraysPooling.asmdef",
                    @"
{
	""name"":""ToolBuddy.ArraysPooling""
}");

                GenerateAssemblyDefinition($"{toolbuddyDirectory}/Dependencies/Vector Graphics/ToolBuddy.Dependencies.VectorGraphics.asmdef",
                    @"
{
	""name"":""ToolBuddy.Dependencies.VectorGraphics""
}");

                GenerateAssemblyDefinition($"{toolbuddyDirectory}/Dependencies/DevTools/FluffyUnderware.DevTools.asmdef",
                    @"
{
	""name"":""FluffyUnderware.DevTools""
}");

                GenerateAssemblyDefinition($"{toolbuddyDirectory}/Dependencies/LibTessDotNet/LibTessDotNet.asmdef",
                @"
{
	""name"":""LibTessDotNet"",
    ""references"":[
        ""ToolBuddy.ArraysPooling""
    ],
    ""includePlatforms"":[],
    ""excludePlatforms"":[]
}");

                GenerateAssemblyDefinition($"{toolbuddyDirectory}/Dependencies/DevTools/Editor/FlufyUnderware.DevTools.Editor.asmdef",
                @"
{
    ""name"":""FluffyUnderware.DevTools.Editor"",
    ""references"":[
        ""ToolBuddy.ArraysPooling"",
        ""FluffyUnderware.DevTools""
    ],
    ""includePlatforms"":[
        ""Editor""
    ],
    ""excludePlatforms"":[]
}");

                GenerateAssemblyDefinition($"{assetsParentDirectory}/Curvy/ToolBuddy.Curvy.asmdef",
                @"
{
    ""name"":""ToolBuddy.Curvy"",
    ""references"":[
        ""ToolBuddy.ArraysPooling"",
        ""ToolBuddy.Dependencies.VectorGraphics"",
        ""FluffyUnderware.DevTools"",
        ""LibTessDotNet""
    ],
    ""includePlatforms"":[],
    ""excludePlatforms"":[]
}");

                GenerateAssemblyDefinition($"{assetsParentDirectory}/Curvy/Editor/ToolBuddy.Curvy.Editor.asmdef",
                @"
{
    ""name"":""ToolBuddy.Curvy.Editor"",
    ""references"":[
        ""ToolBuddy.ArraysPooling"",
        ""ToolBuddy.Curvy"",
        ""FluffyUnderware.DevTools"",
        ""FluffyUnderware.DevTools.Editor"",
        ""LibTessDotNet""
    ],
    ""includePlatforms"":[
        ""Editor""
    ],
    ""excludePlatforms"":[]
}");

                GenerateAssemblyDefinition($"{assetsParentDirectory}/Curvy Examples/ToolBuddy.Curvy.Examples.asmdef",
                @"
{
    ""name"":""ToolBuddy.Curvy.Examples"",
    ""references"":[
        ""ToolBuddy.ArraysPooling"",
        ""FluffyUnderware.DevTools"",
        ""ToolBuddy.Curvy""
    ],
    ""includePlatforms"":[],
    ""excludePlatforms"":[]
}");

                GenerateAssemblyDefinition($"{assetsParentDirectory}/Curvy Examples/Editor/ToolBuddy.Curvy.Examples.Editor.asmdef",
                @"
{
    ""name"":""ToolBuddy.Curvy.Examples.Editor"",
    ""references"":[
        ""ToolBuddy.ArraysPooling"",
        ""FluffyUnderware.DevTools"",
        ""FluffyUnderware.DevTools.Editor"",
        ""ToolBuddy.Curvy"",
        ""ToolBuddy.Curvy.Editor"",
        ""ToolBuddy.Curvy.Examples""
    ],
    ""includePlatforms"":[
        ""Editor""
    ],
    ""excludePlatforms"":[]
}");

                AssetDatabase.Refresh();
            }
        }

        private static void GenerateAssemblyDefinition(string filePath, string fileContent)
        {
            DirectoryInfo directory = Directory.GetParent(filePath);
            if (Directory.Exists(directory.FullName) == false)
                EditorUtility.DisplayDialog("Missing directory",
                    String.Format("Could not find the directory '{0}', file generation will be skipped", directory.FullName), "Continue");
            else if (!File.Exists(filePath) || EditorUtility.DisplayDialog("Replace File?", String.Format("The file '{0}' already exists! Replace it?", filePath), "Yes", "No"))
                using (StreamWriter streamWriter = File.CreateText(filePath))
                {
                    streamWriter.WriteLine(fileContent);
                }
        }


        /// <summary>
        /// Converts a path/file relative to Curvy's root path to the real path, e.g. "ReadMe.txt" gives "Curvy/ReadMe.txt"
        /// </summary>
        /// <param name="relativePath">a path/file inside the Curvy package, WITHOUT the leading Curvy</param>
        /// <returns>the real path, relative to Assets</returns>
        public static string GetPackagePath(string relativePath)
        {
            return GetCurvyRootPath() + relativePath.TrimStart('/', '\\');
        }
        /// <summary>
        /// Converts a path/file relative to Curvy's root path to the real absolute path
        /// </summary>
        /// <param name="relativePath">a path/file inside the Curvy package, WITHOUT the leading Curvy</param>
        /// <returns>the absolute system path</returns>
        public static string GetPackagePathAbsolute(string relativePath)
        {
            return Application.dataPath + "/" + GetPackagePath(relativePath);
        }

        /// <summary>
        /// Gets the Curvy folder relative path, e.g. "Plugins/Curvy/" by default
        /// </summary>
        /// <returns></returns>
        public static string GetCurvyRootPath()
        {
            // Quick check for the regular path
            if (File.Exists(Application.dataPath + "/Plugins/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySpline.cs"))
                return "Plugins/ToolBuddy/Assets/Curvy/";


            // Still no luck? Do a project search
            string[] guid = AssetDatabase.FindAssets("curvyspline_private"); //FindAssets("curvyspline") returns also files other than CurvySpline.cs
            if (guid.Length == 0)
            {
                DTLog.LogError("[Curvy] Unable to locate CurvySpline_private.cs in the project! Is the Curvy package fully imported?");
                return null;
            }
            else
                return AssetDatabase.GUIDToAssetPath(guid[0]).TrimStart("Assets/").TrimEnd("Scripts/Splines/CurvySpline_private.cs");
        }

        /// <summary>
        /// Gets the Curvy folder absolute path, i.e. Application.dataPath+"/"+CurvyEditorUtility.GetCurvyRootPath()
        /// </summary>
        /// <returns></returns>
        public static string GetCurvyRootPathAbsolute()
        {
            return Application.dataPath + "/" + GetCurvyRootPath();
        }
    }

    public static class CurvyGizmo
    {
        /// <summary>
        /// Displays a label next to a point. The relative position of the label compared to the point is defined by <paramref name="direction"/>
        /// </summary>
#if CURVY_SANITY_CHECKS_PRIVATE
        [Obsolete("Do not call this method from a method not having the DrawGizmo attribute until the issue with Unity 2021.2 is fixed")]
#endif
        public static void PointLabel(Vector3 pointPosition, String label, OrientationAxisEnum direction, float? handleSize = null, [CanBeNull] GUIStyle style = null)
        {
#if UNITY_2021_2_0 || UNITY_2021_2_1 || UNITY_2021_2_2 || UNITY_2021_2_3 || UNITY_2021_2_4 || UNITY_2021_2_5 || UNITY_2021_2_6 || UNITY_2021_2_7 || UNITY_2021_2_8 || UNITY_2021_2_9 || UNITY_2021_2_10 || UNITY_2021_2_11
            //workaround to this issue: https://issuetracker.unity3d.com/issues/handles-dot-label-does-not-appear-in-the-supposed-place
            //the issue seems to not happen when this method is called from a OnGui method.
            pointPosition = DTHandles.TranslateByPixel(pointPosition, -53, 23);
#endif
            //ugly shit to bypass the joke that is style.alignment. Tried to bypass the issue by using style.CalcSize(new GUIContent(label)) to manually place the labels. No luck with that
            while (label.Length <= 5)
                label = $" {label} ";

            if (handleSize.HasValue == false)
                handleSize = HandleUtility.GetHandleSize(pointPosition);

            style = style ?? CurvyStyles.GizmoText;

            pointPosition -= Camera.current.transform.right * handleSize.Value * 0.1f;
            pointPosition += Camera.current.transform.up * handleSize.Value * 0.1f;
            Vector3 labelPosition;
            switch (direction)
            {
                case OrientationAxisEnum.Up:
                    //style.alignment = TextAnchor.LowerCenter;
                    labelPosition = pointPosition;
                    labelPosition += Camera.current.transform.up * handleSize.Value * 0.3f;
                    break;
                case OrientationAxisEnum.Down:
                    //style.alignment = TextAnchor.UpperCenter;
                    labelPosition = pointPosition;
                    labelPosition -= Camera.current.transform.up * handleSize.Value * 0.3f;
                    break;
                case OrientationAxisEnum.Right:
                    //style.alignment = TextAnchor.MiddleLeft;
                    labelPosition = pointPosition;
                    labelPosition += Camera.current.transform.right * handleSize.Value * 0.4f;
                    break;
                case OrientationAxisEnum.Left:
                    //style.alignment = TextAnchor.MiddleRight;
                    labelPosition = pointPosition;
                    labelPosition -= Camera.current.transform.right * handleSize.Value * 0.45f;
                    break;
                case OrientationAxisEnum.Forward:
                case OrientationAxisEnum.Backward:
                    //style.alignment = TextAnchor.MiddleCenter;
                    labelPosition = pointPosition;
                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(direction), direction, null);
            }

            Handles.Label(labelPosition, label, style);
        }
    }
    public static class CurvyGUI
    {

        #region ### GUI Controls ###

        public static bool Foldout(ref bool state, string text) { return Foldout(ref state, new GUIContent(text), null); }
        public static bool Foldout(ref bool state, string text, string helpURL) { return Foldout(ref state, new GUIContent(text), helpURL); }

        public static bool Foldout(ref bool state, GUIContent content, string helpURL, bool hierarchyMode = true)
        {
            Rect controlRect = GUILayoutUtility.GetRect(content, CurvyStyles.Foldout);
            bool isInsideInspector = DTInspectorNode.IsInsideInspector;
            int xOffset = isInsideInspector ? 12 : -2;
            controlRect.x -= xOffset;
            controlRect.width += (isInsideInspector ? 0 : 1);

            int indentLevel = DTInspectorNodeDefaultRenderer.RenderHeader(controlRect, xOffset, helpURL, content, ref state);

            EditorGUI.indentLevel = indentLevel;

            return state;
        }

        #endregion

    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyEditorUtility.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyMenu.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: e881cd4f4b87e7646b55f627032e4ec0
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using System.Collections;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.Components;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.CurvyEditor.Generator;
using FluffyUnderware.Curvy.Controllers;
using FluffyUnderware.Curvy.Shapes;
using FluffyUnderware.DevToolsEditor;

namespace FluffyUnderware.CurvyEditor
{

    public static class CurvyMenu
    {
        #region ### Tools Menu ###
        #endregion

        #region ### GameObject Menu ###

        [MenuItem("GameObject/Curvy/Spline", false, 0)]
        public static void CreateCurvySpline(MenuCommand cmd)
        {
            CurvySpline spline = Create<CurvySpline>(cmd);
            ApplyIncrementalNameToSpline(spline);
        }

        [MenuItem("GameObject/Curvy/UI Spline", false, 1)]
        public static void CreateCurvyUISpline(MenuCommand cmd)
        {
            GameObject parent = cmd.context as GameObject;
            if (!parent || parent.GetComponentInParent<Canvas>() == null)
            {
                Canvas cv = GameObject.FindObjectOfType<Canvas>();
                if (cv)
                    parent = cv.gameObject;
                else
                    parent = new GameObject("Canvas", typeof(Canvas));
            }

            GameObject[] selectedGameObjects = Selection.gameObjects;
            if (selectedGameObjects.Length > 0 && cmd.context == selectedGameObjects[0])
                Selection.activeObject = null;

            CurvyUISpline uiSpline;
            {
                const string gameObjectName = "UI Spline";
                uiSpline = CurvyUISpline.CreateUISpline(gameObjectName);
                GameObjectUtility.SetParentAndAlign(uiSpline.gameObject, parent as GameObject);
                Undo.RegisterCreatedObjectUndo(uiSpline.gameObject, "Create " + gameObjectName);
            }

            DTSelection.AddGameObjects(uiSpline);
        }

        [MenuItem("GameObject/Curvy/Generator", false, 5)]
        public static void CreateCG(MenuCommand cmd)
        {
            CurvyGenerator generator = Create<CurvyGenerator>(cmd);
            ApplyIncrementalNameToGenerator(generator);

        }

        [MenuItem("GameObject/Curvy/Controllers/Spline", false, 10)]
        public static void CreateSplineController(MenuCommand cmd) => Create<SplineController>(cmd);

        [MenuItem("GameObject/Curvy/Controllers/CG Path", false, 12)]
        public static void CreatePathController(MenuCommand cmd) => Create<PathController>(cmd);

        [MenuItem("GameObject/Curvy/Controllers/CG Volume", false, 13)]
        public static void CreateVolumeController(MenuCommand cmd) => Create<VolumeController>(cmd);

        [MenuItem("GameObject/Curvy/Controllers/UI Text Spline", false, 14)]
        public static void CreateUITextSplineController(MenuCommand cmd) => Create<UITextSplineController>(cmd);

        [MenuItem("GameObject/" + CurvyLineRenderer.ComponentPath, false, 14)]
        public static void CreateCurvyLineRenderer(MenuCommand cmd) => Create<CurvyLineRenderer>(cmd);

        [MenuItem("GameObject/" + CurvySplineToEdgeCollider2D.ComponentPath, false, 14)]
        public static void CreateCurvySplineToEdgeCollider2D(MenuCommand cmd) => Create<CurvySplineToEdgeCollider2D>(cmd);

        [MenuItem("GameObject/Curvy/Shapes/Circle", false, 14)]
        public static void CreateCSCircle(MenuCommand cmd) => Create<CSCircle>(cmd);

        [MenuItem("GameObject/Curvy/Shapes/Pie", false, 14)]
        public static void CreateCSPie(MenuCommand cmd) => Create<CSPie>(cmd);

        [MenuItem("GameObject/Curvy/Shapes/Rectangle", false, 14)]
        public static void CreateCSRectangle(MenuCommand cmd) => Create<CSRectangle>(cmd);

        [MenuItem("GameObject/Curvy/Shapes/Rounded Rectangle", false, 14)]
        public static void CreateCSRoundedRectangle(MenuCommand cmd) => Create<CSRoundedRectangle>(cmd);

        [MenuItem("GameObject/Curvy/Shapes/Spiral", false, 14)]
        public static void CreateCSSpiral(MenuCommand cmd) => Create<CSSpiral>(cmd);

        [MenuItem("GameObject/Curvy/Shapes/Star", false, 14)]
        public static void CreateCSStar(MenuCommand cmd) => Create<CSStar>(cmd);

        [MenuItem("GameObject/Curvy/Misc/Nearest Spline Point", false, 14)]
        public static void CreateNearestSplinePoint(MenuCommand cmd) => Create<NearestSplinePoint>(cmd);

        [MenuItem("GameObject/Curvy/Misc/Curvy GL Renderer", false, 14)]
        public static void CreateCurvyGLRenderer(MenuCommand cmd) => Create<CurvyGLRenderer>(cmd);


        private static T Create<T>(MenuCommand cmd) where T : MonoBehaviour
        {
            GameObject[] selectedGameObjects = Selection.gameObjects;
            if (selectedGameObjects.Length > 0 && cmd.context == selectedGameObjects[0])
                Selection.activeObject = null;
            T createdObject = CreateCurvyObjectAsChild<T>(cmd.context, typeof(T).Name);
            DTSelection.AddGameObjects(createdObject);
            return createdObject;
        }

        #endregion

        #region ### Project window Create Menu ###

        [MenuItem("Assets/Create/Curvy/CG Module")]
        public static void CreatePCGModule()
        {
            ModuleWizard.Open();
        }

        [MenuItem("Assets/Create/Curvy/Shape")]
        public static void CreateShape()
        {
            ShapeWizard.Open();
        }

        #endregion

        public static T CreateCurvyObject<T>(Object parent, string name) where T : MonoBehaviour
        {
            GameObject go = parent as GameObject;
            if (go == null)
            {
                go = new GameObject(name);
                Undo.RegisterCreatedObjectUndo(go, "Create " + name);
            }

            T obj = go.AddComponent<T>();
            Undo.RegisterCreatedObjectUndo(obj, "Create " + name);

            return obj;
        }

        public static T CreateCurvyObjectAsChild<T>(Object parent, string name) where T : MonoBehaviour
        {
            GameObject go = new GameObject(name);
            T obj = go.AddComponent<T>();
            GameObjectUtility.SetParentAndAlign(go, parent as GameObject);
            Undo.RegisterCreatedObjectUndo(go, "Create " + name);

            return obj;
        }

        /// <summary>
        /// Rename the given spline to "Curvy Spline number_of_existing_splines"
        /// </summary>
        public static void ApplyIncrementalNameToSpline(CurvySpline spline)
        {
            ApplyIncrementalName(spline, "Curvy Spline");
        }

        /// <summary>
        /// Rename the given generator to "Curvy Generator number_of_existing_generators"
        /// </summary>
        public static void ApplyIncrementalNameToGenerator(CurvyGenerator generator)
        {
            ApplyIncrementalName(generator, "Curvy Generator");
        }

        /// <summary>
        /// Rename the given component to "<paramref name="baseName"/> number_of_existing_components_of_type_T"
        /// </summary>
        public static void ApplyIncrementalName<T>(T component, string baseName) where T : Component
        {
            component.name = $"{baseName} {Object.FindObjectsOfType<T>().Length}";
        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyMenu.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyPositionModeDrawer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 7c344282607d5504190915d0f7a2c163
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using FluffyUnderware.Curvy;
using UnityEngine;
using UnityEditor;

namespace FluffyUnderware.CurvyEditor.Controllers
{
    [CustomPropertyDrawer(typeof(CurvyPositionMode))]
    public class CurvyPositionModeDrawer : PropertyDrawer
    {
        private const string Relative = "Relative";
        private const string Absolute = "Absolute";

        readonly GUIContent[] options = new[]
        {
            new GUIContent(Relative,
                "Position is expressed as a fraction of a spline: 0 meaning the spline start, 1 meaning the spline end."),
            new GUIContent(Absolute,
                "Position is expressed as world units")
        };
        readonly GUIStyle guiStyle = EditorStyles.popup;

        override public void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            EditorGUI.BeginProperty(position, label, property);
            property.intValue = EditorGUI.Popup(position, label, property.intValue, options, guiStyle);
            EditorGUI.EndProperty();
        }

        /// <summary>
        /// Gets the display name associated with a specific CurvyPositionMode value
        /// </summary>
        public static string GetDisplayName(CurvyPositionMode positionMode)
        {
            string displayName;
            
            switch (positionMode)
            {
                case CurvyPositionMode.Relative:
                    displayName = Relative;
                    break;
                case CurvyPositionMode.WorldUnits:
                    displayName = Absolute;
                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(positionMode), positionMode, null);
            }

            return displayName;

        }
    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyPositionModeDrawer.cs

# FILE: Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyProject.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Editor
# GUID: 6827729ab53799b47807d90abc775dbe
# ASMDEF: Toolbuddy.Editor.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using UnityEditor;
using FluffyUnderware.Curvy;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevToolsEditor;
using System.Collections.Generic;

namespace FluffyUnderware.CurvyEditor
{
    public class CurvyProject : DTProject
    {
        public const string NAME = "Curvy";
        public const string RELPATH_SHAPEWIZARDSCRIPTS = "/Shapes";
        public const string RELPATH_CGMODULEWIZARDSCRIPTS = "/Generator Modules";
        public const string RELPATH_CGMODULEWIZARDEDITORSCRIPTS = "/Generator Modules/Editor";
        public const string RELPATH_CGTEMPLATES = "/Generator Templates";

        public static CurvyProject Instance
        {
            get
            {
                return (CurvyProject)DT.Project(NAME);
            }
        }

        #region ### Persistent Settings ###
        // DESIGN those settings are a mess: some are public fields, other properties of which the setter updates the editor preferences, and finally others ae part of CurvyGlobalManager (see CurvyProject.LoadPreferences to have a listing of them all). Shouldn't all of those settings be treated similarly?

        // Settings from Preferences window not stored in CurvyGlobalManager

        public bool SnapValuePrecision = true;
        /// <summary>
        /// If enabled and the spline has Restrict To 2D enabled, dots are shown instead of the default move handles
        /// </summary>
        public bool UseTiny2DHandles = false;
        /// <summary>
        /// Should the spline's text gizmos fade if the spline is too small on the screen
        /// </summary>
        public bool AutoFadeLabels = true;
        public bool ShowGlobalToolbar = true;
        public bool ShowHints = true;
        public bool EnableMetrics = true;
        public bool EnableAnnouncements = true;

        // Settings made in the toolbar or somewhere else

        bool mCGAutoModuleDetails = false;
        public bool CGAutoModuleDetails
        {
            get { return mCGAutoModuleDetails; }
            set
            {
                if (mCGAutoModuleDetails != value)
                {
                    mCGAutoModuleDetails = value;
                    SetEditorPrefs("CGAutoModuleDetails", mCGAutoModuleDetails);
                }
            }
        }

        bool mCGSynchronizeSelection = true;
        public bool CGSynchronizeSelection
        {
            get { return mCGSynchronizeSelection; }
            set
            {
                if (mCGSynchronizeSelection != value)
                {
                    mCGSynchronizeSelection = value;
                    SetEditorPrefs("CGSynchronizeSelection", mCGSynchronizeSelection);
                }
            }
        }

        bool mCGShowHelp = true;
        public bool CGShowHelp
        {
            get { return mCGShowHelp; }
            set
            {
                if (mCGShowHelp != value)
                {
                    mCGShowHelp = value;
                    SetEditorPrefs("CGShowHelp", mCGShowHelp);
                }
            }
        }

        int mCGGraphSnapping = 5;
        /// <summary>
        /// The size of the grid used for snapping when dragging a module in Curvy Generator Graph
        /// </summary>
        public int CGGraphSnapping
        {
            get { return mCGGraphSnapping; }
            set
            {
                int v = Mathf.Max(1, value);
                if (mCGGraphSnapping != v)
                {
                    mCGGraphSnapping = v;
                    SetEditorPrefs("CGGraphSnapping", mCGGraphSnapping);
                }
            }
        }

        string mCustomizationRootPath = "Packages/Curvy Customization";
        public string CustomizationRootPath
        {
            get
            {
                return mCustomizationRootPath;
            }
            set
            {
                if (mCustomizationRootPath != value)
                {
                    mCustomizationRootPath = value;
                    SetEditorPrefs("CustomizationRootPath", mCustomizationRootPath);
                }
            }
        }

        CurvyBezierModeEnum mBezierMode = CurvyBezierModeEnum.Direction | CurvyBezierModeEnum.Length;
        public CurvyBezierModeEnum BezierMode
        {
            get { return mBezierMode; }
            set
            {
                if (mBezierMode != value)
                {
                    mBezierMode = value;
                    SetEditorPrefs("BezierMode", mBezierMode);
                }
            }
        }

        CurvyAdvBezierModeEnum mAdvBezierMode = CurvyAdvBezierModeEnum.Direction | CurvyAdvBezierModeEnum.Length;
        public CurvyAdvBezierModeEnum AdvBezierMode
        {
            get { return mAdvBezierMode; }
            set
            {
                if (mAdvBezierMode != value)
                {
                    mAdvBezierMode = value;
                    SetEditorPrefs("AdvBezierMode", mAdvBezierMode);
                }
            }
        }

        bool mShowAboutOnLoad = true;
        public bool ShowAboutOnLoad
        {
            get
            {
                return mShowAboutOnLoad;
            }
            set
            {
                if (mShowAboutOnLoad != value)
                    mShowAboutOnLoad = value;
                SetEditorPrefs("ShowAboutOnLoad", mShowAboutOnLoad);
            }
        }

        #endregion





        static Vector2 scroll;
        static readonly bool[] foldouts = new bool[4] { true, true, true, true };
        readonly List<int> mShowConIconObjects = new List<int>();


        public CurvyProject()
            : base(NAME, CurvySpline.VERSION)
        {
            Resource = CurvyResource.Instance;
            Undo.undoRedoPerformed -= OnUndoRedo;
            Undo.undoRedoPerformed += OnUndoRedo;
            EditorApplication.update -= OnUpdate;
            EditorApplication.update += OnUpdate;
            EditorApplication.update += checkLaunch;
            EditorApplication.hierarchyChanged -= ScanConnections;
            EditorApplication.hierarchyChanged += ScanConnections;
            EditorApplication.hierarchyWindowItemOnGUI -= OnHierarchyWindowItemOnGUI;
            EditorApplication.hierarchyWindowItemOnGUI += OnHierarchyWindowItemOnGUI;
            ScanConnections();
        }

        /// <summary>
        /// Rebuilds the list of GameObject that needs to show a connection icon in the hierarchy window
        /// </summary>
        /// <remarks>Usually there is no need to call this manually</remarks>
        public void ScanConnections()
        {
            int old = mShowConIconObjects.Count;
            mShowConIconObjects.Clear();

            CurvyConnection[] o = GameObject.FindObjectsOfType<CurvyConnection>();
            foreach (CurvyConnection con in o)
            {
                foreach (CurvySplineSegment cp in con.ControlPointsList)
                {
                    if (cp != null && cp.gameObject != null)
                        // see comment in CurvyConnection.DoUpdate to know more about when cp.gameObject can be null
                        mShowConIconObjects.Add(cp.gameObject.GetInstanceID());
                }
            }

            if (old != mShowConIconObjects.Count)
                EditorApplication.RepaintHierarchyWindow();
        }

        void OnHierarchyWindowItemOnGUI(int instanceid, Rect selectionrect)
        {
            if (mShowConIconObjects.Contains(instanceid))
            {
                GUI.DrawTexture(new Rect(selectionrect.xMax - 14, selectionrect.yMin + 4, 10, 10), CurvyStyles.HierarchyConnectionTexture);
            }
        }

        void checkLaunch()
        {
            EditorApplication.update -= checkLaunch;
            if (ShowAboutOnLoad)
                AboutWindow.Open();
        }

        void OnUpdate()
        {

            // check if a deleted Curvy object defines a new object to select
            if (EditorApplication.isPlayingOrWillChangePlaymode)
                CurvySpline._newSelectionInstanceIDINTERNAL = 0;

            if (CurvySpline._newSelectionInstanceIDINTERNAL != 0)
            {
                Object o = EditorUtility.InstanceIDToObject(CurvySpline._newSelectionInstanceIDINTERNAL);
                if (o != null && o is Component)
                    DTSelection.SetGameObjects((Component)o);
                CurvySpline._newSelectionInstanceIDINTERNAL = 0;
            }
        }

        void OnUndoRedo()
        {
            List<CurvySpline> splines = DTSelection.GetAllAs<CurvySpline>();
            List<CurvySplineSegment> cps = DTSelection.GetAllAs<CurvySplineSegment>();
            foreach (CurvySplineSegment cp in cps)
            {
                CurvySpline curvySpline = cp.transform.parent
                    ? cp.transform.parent.GetComponent<CurvySpline>()
                    : cp.Spline;
                if (curvySpline && !splines.Contains(curvySpline))
                    splines.Add(curvySpline);
            }

            foreach (CurvySpline spl in splines)
            {
                spl.SyncSplineFromHierarchy();
                //spl.SetDirtyAll(SplineDirtyingType.Everything, true); is already done in spl.SyncSplineFromHierarchy();
                spl.Refresh();
            }
        }



        public override void ResetPreferences()
        {
            //reset only settings that are settable through the Preferences window

            base.ResetPreferences();
            CurvyGlobalManager.DefaultInterpolation = CurvyInterpolation.CatmullRom;
            CurvyGlobalManager.DefaultGizmoColor = CurvyGlobalManager.DefaultDefaultGizmoColor;
            CurvyGlobalManager.DefaultGizmoSelectionColor = CurvyGlobalManager.DefaultDefaultGizmoSelectionColor;
            CurvyGlobalManager.GizmoControlPointSize = 0.15f;
            CurvyGlobalManager.GizmoOrientationLength = 1f;
            CurvyGlobalManager.GizmoOrientationColor = CurvyGlobalManager.DefaultGizmoOrientationColor;
            CurvyGlobalManager.SceneViewResolution = 0.5f;
            CurvyGlobalManager.HideManager = false;
            CurvyGlobalManager.SplineLayer = 0;
            CurvyGlobalManager.SaveGeneratorOutputs = true;

            CustomizationRootPath = "Packages/Curvy Customization";
            SnapValuePrecision = true;
            UseTiny2DHandles = false;
            AutoFadeLabels = true;
            ShowGlobalToolbar = true;
            EnableMetrics = true;
            EnableAnnouncements = true;
            ShowHints = true;

            ToolbarMode = DTToolbarMode.Full;
            ToolbarOrientation = DTToolbarOrientation.Left;

            DT._UseSnapValuePrecision = SnapValuePrecision;
            DTToolbarItem._StatusBar.Visible = ShowHints;
        }

        public override void LoadPreferences()
        {
            if (GetEditorPrefs("Version", "PreDT") == "PreDT")
            {
                DeletePreDTSettings();
                SavePreferences();
            }
            base.LoadPreferences();
            CurvyGlobalManager.DefaultInterpolation = GetEditorPrefs("DefaultInterpolation", CurvyGlobalManager.DefaultInterpolation);
            CurvyGlobalManager.DefaultGizmoColor = GetEditorPrefs("GizmoColor", CurvyGlobalManager.DefaultGizmoColor);
            CurvyGlobalManager.DefaultGizmoSelectionColor = GetEditorPrefs("GizmoSelectionColor", CurvyGlobalManager.DefaultGizmoSelectionColor);
            CurvyGlobalManager.GizmoControlPointSize = GetEditorPrefs("GizmoControlPointSize", CurvyGlobalManager.GizmoControlPointSize);
            CurvyGlobalManager.GizmoOrientationLength = GetEditorPrefs("GizmoOrientationLength", CurvyGlobalManager.GizmoOrientationLength);
            CurvyGlobalManager.GizmoOrientationColor = GetEditorPrefs("GizmoOrientationColor", CurvyGlobalManager.GizmoOrientationColor);
            CurvyGlobalManager.Gizmos = GetEditorPrefs("Gizmos", CurvyGlobalManager.Gizmos);
            CurvyGlobalManager.SceneViewResolution = Mathf.Clamp01(GetEditorPrefs("SceneViewResolution", CurvyGlobalManager.SceneViewResolution));
            CurvyGlobalManager.HideManager = GetEditorPrefs("HideManager", CurvyGlobalManager.HideManager);
            CurvyGlobalManager.SplineLayer = GetEditorPrefs("SplineLayer", CurvyGlobalManager.SplineLayer);
            CurvyGlobalManager.SaveGeneratorOutputs = GetEditorPrefs("SaveGeneratorOutputs", CurvyGlobalManager.SaveGeneratorOutputs);

            mCustomizationRootPath = GetEditorPrefs("CustomizationRootPath", mCustomizationRootPath);
            SnapValuePrecision = GetEditorPrefs("SnapValuePrecision", true);
            UseTiny2DHandles = GetEditorPrefs("UseTiny2DHandles", UseTiny2DHandles);
            AutoFadeLabels = GetEditorPrefs("AutoFadeLabels", AutoFadeLabels);
            ShowGlobalToolbar = GetEditorPrefs("ShowGlobalToolbar", ShowGlobalToolbar);
            EnableMetrics = GetEditorPrefs("EnableMetrics", true);
            EnableAnnouncements = GetEditorPrefs("EnableAnnouncements", true);
            ShowHints = GetEditorPrefs("ShowHints", ShowHints);

            CurvyGlobalManager.SaveRuntimeSettings();

            mCGAutoModuleDetails = GetEditorPrefs("CGAutoModuleDetails", mCGAutoModuleDetails);
            mCGSynchronizeSelection = GetEditorPrefs("CGSynchronizeSelection", mCGSynchronizeSelection);
            mCGShowHelp = GetEditorPrefs("CGShowHelp", mCGShowHelp);
            mCGGraphSnapping = GetEditorPrefs("CGGraphSnapping", mCGGraphSnapping);
            mBezierMode = GetEditorPrefs("BezierMode", mBezierMode);
            mAdvBezierMode = GetEditorPrefs("AdvBezierMode", mAdvBezierMode);
            mShowAboutOnLoad = GetEditorPrefs("ShowAboutOnLoad", mShowAboutOnLoad);

            DT._UseSnapValuePrecision = SnapValuePrecision;
            DTToolbarItem._StatusBar.Visible = ShowHints;
        }

        public override void SavePreferences()
        {
            base.SavePreferences();
            SetEditorPrefs("DefaultInterpolation", CurvyGlobalManager.DefaultInterpolation);
            SetEditorPrefs("GizmoColor", CurvyGlobalManager.DefaultGizmoColor);
            SetEditorPrefs("GizmoSelectionColor", CurvyGlobalManager.DefaultGizmoSelectionColor);
            SetEditorPrefs("GizmoControlPointSize", CurvyGlobalManager.GizmoControlPointSize);
            SetEditorPrefs("GizmoOrientationLength", CurvyGlobalManager.GizmoOrientationLength);
            SetEditorPrefs("GizmoOrientationColor", CurvyGlobalManager.GizmoOrientationColor);
            SetEditorPrefs("Gizmos", CurvyGlobalManager.Gizmos);
            SetEditorPrefs("SnapValuePrecision", SnapValuePrecision);
            SetEditorPrefs("EnableAnnouncements", EnableAnnouncements);
            SetEditorPrefs("EnableMetrics", EnableMetrics);
            SetEditorPrefs("SceneViewResolution", CurvyGlobalManager.SceneViewResolution);
            SetEditorPrefs("HideManager", CurvyGlobalManager.HideManager);
            SetEditorPrefs("UseTiny2DHandles", UseTiny2DHandles);
            SetEditorPrefs("AutoFadeLabels", AutoFadeLabels);
            SetEditorPrefs("ShowGlobalToolbar", ShowGlobalToolbar);
            SetEditorPrefs("ShowHints", ShowHints);
            SetEditorPrefs("SplineLayer", CurvyGlobalManager.SplineLayer);
            SetEditorPrefs("SaveGeneratorOutputs", CurvyGlobalManager.SaveGeneratorOutputs);
            SetEditorPrefs("CustomizationRootPath", mCustomizationRootPath);

            CurvyGlobalManager.SaveRuntimeSettings();
            DT._UseSnapValuePrecision = SnapValuePrecision;
            DTToolbarItem._StatusBar.Visible = ShowHints;
        }

        protected override void UpgradePreferences(string oldVersion)
        {
            base.UpgradePreferences(oldVersion);
            // Ensure that About Window will be shown after upgrade
            DeleteEditorPrefs("ShowAboutOnLoad");
            if (oldVersion == "2.0.0")
            {
                if (GetEditorPrefs("GizmoOrientationLength", CurvyGlobalManager.GizmoOrientationLength) == 4)
                    DeleteEditorPrefs("GizmoOrientationLength");
            }

        }

        void DeletePreDTSettings()
        {
            DTLog.Log("[Curvy] Removing old preferences");
            EditorPrefs.DeleteKey("Curvy_GizmoColor");
            EditorPrefs.DeleteKey("Curvy_GizmoSelectionColor");
            EditorPrefs.DeleteKey("Curvy_ControlPointSize");
            EditorPrefs.DeleteKey("Curvy_OrientationLength");
            EditorPrefs.DeleteKey("Curvy_Gizmos");
            EditorPrefs.DeleteKey("Curvy_ToolbarLabels");
            EditorPrefs.DeleteKey("Curvy_ToolbarOrientation");
            EditorPrefs.DeleteKey("Curvy_ShowShapeWizardUndoWarning");
            EditorPrefs.DeleteKey("Curvy_KeyBindings");
        }

        #region Settings window

        /// <summary>
        /// The name of the settings entry of Curvy
        /// </summary>
        const string SettingsEntryName = "Curvy";

        /// <summary>
        /// The class used by Unity 2018.3 and newer to provide Curvy's preferences window
        /// </summary>
        public class CurvySettingsProvider : SettingsProvider
        {

            public CurvySettingsProvider(SettingsScope scopes, IEnumerable<string> keywords = null)
                : base(GetPreferencesPath(), scopes, keywords)
            { }

            public override void OnGUI(string searchContext)
            {
                PreferencesGUI();
            }

            /// <summary>
            /// The settings path for Curvy's Settings
            /// </summary>
            public static string GetPreferencesPath()
            {
                return "Preferences/" + SettingsEntryName;
            }
        }

        [SettingsProvider]
        static SettingsProvider MyNewPrefCode()
        {
            return new CurvySettingsProvider(SettingsScope.User);
        }

        public static void PreferencesGUI()
        {
            scroll = EditorGUILayout.BeginScrollView(scroll);
            CurvyGlobalManager.DefaultInterpolation = (CurvyInterpolation)EditorGUILayout.EnumPopup("Default Spline Type", CurvyGlobalManager.DefaultInterpolation);
            CurvyGlobalManager.SplineLayer = EditorGUILayout.LayerField(new GUIContent("Default Spline Layer", "Layer to use for splines and Control Points"), CurvyGlobalManager.SplineLayer);

            CurvyGlobalManager.SaveGeneratorOutputs = EditorGUILayout.Toggle(new GUIContent("Save Generator Outputs", "Whether the output of Curvy Generators should be saved in the scene file.\nDisable this option to reduce the size of scene files. This might increase the saving time for complex scenes.\nThis option applies only on generators that are enabled and have Auto Refresh set to true"), CurvyGlobalManager.SaveGeneratorOutputs);

            Instance.SnapValuePrecision = EditorGUILayout.Toggle(new GUIContent("Snap Value Precision", "Round inspector values"), Instance.SnapValuePrecision);

            CurvyGlobalManager.HideManager = EditorGUILayout.Toggle(new GUIContent("Hide _CurvyGlobal_", "Hide the global manager in Hierarchy?"), CurvyGlobalManager.HideManager);

            Instance.EnableAnnouncements = EditorGUILayout.Toggle(new GUIContent("Enable Announcements", "Display announcements from Curvy's developers"), Instance.EnableAnnouncements);

            Instance.EnableMetrics = EditorGUILayout.Toggle(new GUIContent("Enable Metrics", "Send metrics to Curvy's developers. This includes data such as the Unity version, Curvy version, etc... Keeping this enabled helps us a lot maintaining Curvy"), Instance.EnableMetrics);

            {
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.TextField(new GUIContent("Customization Root Path", "Base Path for custom Curvy extensions"), Instance.CustomizationRootPath);
                if (GUILayout.Button(new GUIContent("<", "Select"), GUILayout.ExpandWidth(false)))
                {
                    string path = EditorUtility.OpenFolderPanel("Customization Root Path", Application.dataPath, "");
                    if (!string.IsNullOrEmpty(path))
                        Instance.CustomizationRootPath = path.Replace(Application.dataPath + "/", "");
                }
                EditorGUILayout.EndHorizontal();
            }
            CurvyGlobalManager.SceneViewResolution = EditorGUILayout.Slider(new GUIContent("SceneView Resolution", "Lower values results in faster SceneView drawing"), CurvyGlobalManager.SceneViewResolution, 0, 1);

            foldouts[0] = EditorGUILayout.Foldout(foldouts[0], "Gizmo", CurvyStyles.Foldout);
            if (foldouts[0])
            {
                CurvyGlobalManager.DefaultGizmoColor = EditorGUILayout.ColorField("Spline color", CurvyGlobalManager.DefaultGizmoColor);
                CurvyGlobalManager.DefaultGizmoSelectionColor = EditorGUILayout.ColorField("Spline Selection color", CurvyGlobalManager.DefaultGizmoSelectionColor);
                CurvyGlobalManager.GizmoControlPointSize = EditorGUILayout.FloatField("Control Point Size", CurvyGlobalManager.GizmoControlPointSize);
                CurvyGlobalManager.GizmoOrientationLength = EditorGUILayout.FloatField(new GUIContent("Orientation Length", "Orientation gizmo size"), CurvyGlobalManager.GizmoOrientationLength);
                CurvyGlobalManager.GizmoOrientationColor = EditorGUILayout.ColorField(new GUIContent("Orientation Color", "Orientation gizmo color"), CurvyGlobalManager.GizmoOrientationColor);
                Instance.UseTiny2DHandles = EditorGUILayout.Toggle(new GUIContent("Use Tiny 2D Handles", "If enabled and the spline has Restrict To 2D enabled, dots are shown instead of the default move handles"), Instance.UseTiny2DHandles);
                Instance.AutoFadeLabels = EditorGUILayout.Toggle(new GUIContent("Auto Fade Labels", "Should the spline's text gizmos fade if the spline is too small on the screen"), Instance.AutoFadeLabels);
            }

            foldouts[1] = EditorGUILayout.Foldout(foldouts[1], "UI", CurvyStyles.Foldout);
            if (foldouts[1])
            {
                Instance.ShowGlobalToolbar = EditorGUILayout.Toggle(new GUIContent("Show Global Toolbar", "Always show Curvy Toolbar"), Instance.ShowGlobalToolbar);
                Instance.ToolbarMode = (DTToolbarMode)EditorGUILayout.EnumPopup(new GUIContent("Toolbar Labels", "Defines Toolbar Display Mode"), Instance.ToolbarMode);
                Instance.ToolbarOrientation = (DTToolbarOrientation)EditorGUILayout.EnumPopup(new GUIContent("Toolbar Orientation", "Defines Toolbar Position"), Instance.ToolbarOrientation);
                Instance.ShowHints = EditorGUILayout.Toggle(new GUIContent("Show Hints", "Show hints, at the bottom of scene view, about the usage of some Curvy editor tools"), Instance.ShowHints);
            }

            foldouts[2] = EditorGUILayout.Foldout(foldouts[2], "Shortcuts", CurvyStyles.Foldout);
            if (foldouts[2])
            {
                List<EditorKeyBinding> keys = Instance.GetProjectBindings();
                foreach (EditorKeyBinding binding in keys)
                {
                    if (binding.OnPreferencesGUI()) // save changed bindings
                    {
                        Instance.SetEditorPrefs(binding.Name, binding.ToPrefsString());
                    }
                    GUILayout.Space(2);
                    GUILayout.Box("", GUILayout.Height(1), GUILayout.ExpandWidth(true));
                    GUILayout.Space(2);
                }
            }
            if (GUILayout.Button("Reset to defaults"))
            {
                Instance.ResetPreferences();

                List<EditorKeyBinding> keys = Instance.GetProjectBindings();
                foreach (EditorKeyBinding binding in keys)
                    Instance.DeleteEditorPrefs(binding.Name);
            }

            EditorGUILayout.EndScrollView();

            if (GUI.changed)
            {
                Instance.SavePreferences();
                DT.ReInitialize(false);
            }

        }

        #endregion
    }

    /// <summary>
    /// Class for loading image resources
    /// </summary>
    public class CurvyResource : DTResource
    {
        static CurvyResource _Instance;
        public static CurvyResource Instance
        {
            get
            {
                if (_Instance == null)
                    _Instance = new CurvyResource();
                return _Instance;
            }
        }

        public CurvyResource()
        {
            ResourceDLL = FindResourceDLL("CurvyEditorIcons");
            ResourceNamespace = "";//Assets.Curvy.Editor.Resources.";
        }

        private const string fallbackPackedString = "missing,16,16";

        public static Texture2D Load(string packedString)
        {
            Texture2D tex = Instance.LoadPacked(packedString);
            if (tex == null)
            {
                DTLog.LogError("Loading texture from packed string failed: " + packedString);
                return Instance.LoadPacked(fallbackPackedString);
            }

            return tex;
        }




    }
}
# --- end Packages/com_ldx_framework/Editor/Third Party/ToolBuddy/Curvy/Editor/CurvyProject.cs

